{
  "org.springframework.aop.aspectj.<unknown>#argBinding(jp,jpMatch,returnValue,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Take the arguments at the method execution join point and output a set of arguments\n\t * to the advice method.\n\t * @param jp the current JoinPoint\n\t * @param jpMatch the join point match that matched this execution join point\n\t * @param returnValue the return value from the method execution (may be null)\n\t * @param ex the exception thrown by the method execution (may be null)\n\t * @return the empty array if there are no arguments\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jp",
      "jpMatch",
      "returnValue",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 549
    },
    "return": "Object[]",
    "signature": "protected Object[] argBinding(JoinPoint jp, @Nullable JoinPointMatch jpMatch,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable ex)",
    "source_code": "\tprotected Object[] argBinding(JoinPoint jp, @Nullable JoinPointMatch jpMatch,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable ex) {\n\n\t\tcalculateArgumentBindings();\n\n\t\t// AMC start\n\t\tObject[] adviceInvocationArgs = new Object[this.parameterTypes.length];\n\t\tint numBound = 0;\n\n\t\tif (this.joinPointArgumentIndex != -1) {\n\t\t\tadviceInvocationArgs[this.joinPointArgumentIndex] = jp;\n\t\t\tnumBound++;\n\t\t}\n\t\telse if (this.joinPointStaticPartArgumentIndex != -1) {\n\t\t\tadviceInvocationArgs[this.joinPointStaticPartArgumentIndex] = jp.getStaticPart();\n\t\t\tnumBound++;\n\t\t}\n\n\t\tif (!CollectionUtils.isEmpty(this.argumentBindings)) {\n\t\t\t// binding from pointcut match\n\t\t\tif (jpMatch != null) {\n\t\t\t\tPointcutParameter[] parameterBindings = jpMatch.getParameterBindings();\n\t\t\t\tfor (PointcutParameter parameter : parameterBindings) {\n\t\t\t\t\tString name = parameter.getName();\n\t\t\t\t\tInteger index = this.argumentBindings.get(name);\n\t\t\t\t\tadviceInvocationArgs[index] = parameter.getBinding();\n\t\t\t\t\tnumBound++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// binding from returning clause\n\t\t\tif (this.returningName != null) {\n\t\t\t\tInteger index = this.argumentBindings.get(this.returningName);\n\t\t\t\tadviceInvocationArgs[index] = returnValue;\n\t\t\t\tnumBound++;\n\t\t\t}\n\t\t\t// binding from thrown exception\n\t\t\tif (this.throwingName != null) {\n\t\t\t\tInteger index = this.argumentBindings.get(this.throwingName);\n\t\t\t\tadviceInvocationArgs[index] = ex;\n\t\t\t\tnumBound++;\n\t\t\t}\n\t\t}\n\n\t\tif (numBound != this.parameterTypes.length) {\n\t\t\tthrow new IllegalStateException(\"Required to bind \" + this.parameterTypes.length +\n\t\t\t\t\t\" arguments, but only bound \" + numBound + \" (JoinPointMatch \" +\n\t\t\t\t\t(jpMatch == null ? \"was NOT\" : \"WAS\") + \" bound in invocation)\");\n\t\t}\n\n\t\treturn adviceInvocationArgs;\n\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#couldMatchJoinPointsInType(someClass,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "someClass",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 624
    },
    "return": "boolean",
    "signature": "public boolean couldMatchJoinPointsInType(Class someClass, MatchingContext context)",
    "source_code": "\t\tpublic boolean couldMatchJoinPointsInType(Class someClass, MatchingContext context) {\n\t\t\treturn (contextMatch(someClass) == FuzzyBoolean.YES);\n\t\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#invokeAdviceMethod(jp,jpMatch,returnValue,t)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jp",
      "jpMatch",
      "returnValue",
      "t"
    ],
    "position": {
      "column": 1,
      "line": 618
    },
    "return": "Object",
    "signature": "protected Object invokeAdviceMethod(JoinPoint jp, @Nullable JoinPointMatch jpMatch,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable t)",
    "source_code": "\tprotected Object invokeAdviceMethod(JoinPoint jp, @Nullable JoinPointMatch jpMatch,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable t) throws Throwable {\n\n\t\treturn invokeAdviceMethodWithGivenArgs(argBinding(jp, jpMatch, returnValue, t));\n\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#invokeAdviceMethod(jpMatch,returnValue,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the advice method.\n\t * @param jpMatch the JoinPointMatch that matched this execution join point\n\t * @param returnValue the return value from the method execution (may be null)\n\t * @param ex the exception thrown by the method execution (may be null)\n\t * @return the invocation result\n\t * @throws Throwable in case of invocation failure\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jpMatch",
      "returnValue",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 610
    },
    "return": "Object",
    "signature": "protected Object invokeAdviceMethod(@Nullable JoinPointMatch jpMatch, @Nullable Object returnValue, @Nullable Throwable ex)",
    "source_code": "\tprotected Object invokeAdviceMethod(\n\t\t\t@Nullable JoinPointMatch jpMatch, @Nullable Object returnValue, @Nullable Throwable ex)\n\t\t\tthrows Throwable {\n\n\t\treturn invokeAdviceMethodWithGivenArgs(argBinding(getJoinPoint(), jpMatch, returnValue, ex));\n\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#matches(method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 705
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\t\treturn !this.adviceMethod.equals(method);\n\t\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#matches(method,targetClass,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass, Object... args)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass, Object... args) {\n\t\tobtainPointcutExpression();\n\t\tShadowMatch shadowMatch = getTargetShadowMatch(method, targetClass);\n\n\t\t// Bind Spring AOP proxy to AspectJ \"this\" and Spring AOP target to AspectJ target,\n\t\t// consistent with return of MethodInvocationProceedingJoinPoint\n\t\tProxyMethodInvocation pmi = null;\n\t\tObject targetObject = null;\n\t\tObject thisObject = null;\n\t\ttry {\n\t\t\tMethodInvocation mi = ExposeInvocationInterceptor.currentInvocation();\n\t\t\ttargetObject = mi.getThis();\n\t\t\tif (!(mi instanceof ProxyMethodInvocation _pmi)) {\n\t\t\t\tthrow new IllegalStateException(\"MethodInvocation is not a Spring ProxyMethodInvocation: \" + mi);\n\t\t\t}\n\t\t\tpmi = _pmi;\n\t\t\tthisObject = pmi.getProxy();\n\t\t}\n\t\tcatch (IllegalStateException ex) {\n\t\t\t// No current invocation...\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Could not access current invocation - matching with limited context: \" + ex);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tJoinPointMatch joinPointMatch = shadowMatch.matchesJoinPoint(thisObject, targetObject, args);\n\n\t\t\t/*\n\t\t\t * Do a final check to see if any this(TYPE) kind of residue match. For\n\t\t\t * this purpose, we use the original method's (proxy method's) shadow to\n\t\t\t * ensure that 'this' is correctly checked against. Without this check,\n\t\t\t * we get incorrect match on this(TYPE) where TYPE matches the target\n\t\t\t * type but not 'this' (as would be the case of JDK dynamic proxies).\n\t\t\t * <p>See SPR-2979 for the original bug.\n\t\t\t */\n\t\t\tif (pmi != null && thisObject != null) {  // there is a current invocation\n\t\t\t\tRuntimeTestWalker originalMethodResidueTest = getRuntimeTestWalker(getShadowMatch(method, method));\n\t\t\t\tif (!originalMethodResidueTest.testThisInstanceOfResidue(thisObject.getClass())) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (joinPointMatch.matches()) {\n\t\t\t\t\tbindParameters(pmi, joinPointMatch);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn joinPointMatch.matches();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Failed to evaluate join point for arguments \" + Arrays.toString(args) +\n\t\t\t\t\t\t\" - falling back to non-match\", ex);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#matches(method,targetClass,hasIntroductions)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass",
      "hasIntroductions"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass, boolean hasIntroductions)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass, boolean hasIntroductions) {\n\t\tobtainPointcutExpression();\n\t\tShadowMatch shadowMatch = getTargetShadowMatch(method, targetClass);\n\n\t\t// Special handling for this, target, @this, @target, @annotation\n\t\t// in Spring - we can optimize since we know we have exactly this class,\n\t\t// and there will never be matching subclass at runtime.\n\t\tif (shadowMatch.alwaysMatches()) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (shadowMatch.neverMatches()) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\t// the maybe case\n\t\t\tif (hasIntroductions) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// A match test returned maybe - if there are any subtype sensitive variables\n\t\t\t// involved in the test (this, target, at_this, at_target, at_annotation) then\n\t\t\t// we say this is not a match as in Spring there will never be a different\n\t\t\t// runtime subtype.\n\t\t\tRuntimeTestWalker walker = getRuntimeTestWalker(shadowMatch);\n\t\t\treturn (!walker.testsSubtypeSensitiveVars() || walker.testTargetInstanceOfResidue(targetClass));\n\t\t}\n\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#matchesJoinPoint(thisObject,targetObject,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "thisObject",
      "targetObject",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 697
    },
    "return": "JoinPointMatch",
    "signature": "public JoinPointMatch matchesJoinPoint(Object thisObject, Object targetObject, Object[] args)",
    "source_code": "\t\tpublic JoinPointMatch matchesJoinPoint(Object thisObject, Object targetObject, Object[] args) {\n\t\t\ttry {\n\t\t\t\treturn this.primary.matchesJoinPoint(thisObject, targetObject, args);\n\t\t\t}\n\t\t\tcatch (ReflectionWorldException ex) {\n\t\t\t\treturn this.other.matchesJoinPoint(thisObject, targetObject, args);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.aop.aspectj.annotation.<unknown>#getAdvice(candidateAdviceMethod,expressionPointcut,aspectInstanceFactory,declarationOrder,aspectName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "candidateAdviceMethod",
      "expressionPointcut",
      "aspectInstanceFactory",
      "declarationOrder",
      "aspectName"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "Advice",
    "signature": "public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,\n\t\t\tMetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName)",
    "source_code": "\tpublic Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,\n\t\t\tMetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {\n\n\t\tClass<?> candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();\n\t\tvalidate(candidateAspectClass);\n\n\t\tAspectJAnnotation<?> aspectJAnnotation =\n\t\t\t\tAbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);\n\t\tif (aspectJAnnotation == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// If we get here, we know we have an AspectJ method.\n\t\t// Check that it's an AspectJ-annotated class\n\t\tif (!isAspect(candidateAspectClass)) {\n\t\t\tthrow new AopConfigException(\"Advice must be declared inside an aspect type: \" +\n\t\t\t\t\t\"Offending method '\" + candidateAdviceMethod + \"' in class [\" +\n\t\t\t\t\tcandidateAspectClass.getName() + \"]\");\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Found AspectJ method: \" + candidateAdviceMethod);\n\t\t}\n\n\t\tAbstractAspectJAdvice springAdvice;\n\n\t\tswitch (aspectJAnnotation.getAnnotationType()) {\n\t\t\tcase AtPointcut -> {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Processing pointcut '\" + candidateAdviceMethod.getName() + \"'\");\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tcase AtAround -> springAdvice = new AspectJAroundAdvice(\n\t\t\t\t\tcandidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n\t\t\tcase AtBefore -> springAdvice = new AspectJMethodBeforeAdvice(\n\t\t\t\t\tcandidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n\t\t\tcase AtAfter -> springAdvice = new AspectJAfterAdvice(\n\t\t\t\t\tcandidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n\t\t\tcase AtAfterReturning -> {\n\t\t\t\tspringAdvice = new AspectJAfterReturningAdvice(\n\t\t\t\t\t\tcandidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n\t\t\t\tAfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();\n\t\t\t\tif (StringUtils.hasText(afterReturningAnnotation.returning())) {\n\t\t\t\t\tspringAdvice.setReturningName(afterReturningAnnotation.returning());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase AtAfterThrowing -> {\n\t\t\t\tspringAdvice = new AspectJAfterThrowingAdvice(\n\t\t\t\t\t\tcandidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n\t\t\t\tAfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();\n\t\t\t\tif (StringUtils.hasText(afterThrowingAnnotation.throwing())) {\n\t\t\t\t\tspringAdvice.setThrowingName(afterThrowingAnnotation.throwing());\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefault -> throw new UnsupportedOperationException(\n\t\t\t\t\t\"Unsupported advice type on method: \" + candidateAdviceMethod);\n\t\t}\n\n\t\t// Now to configure the advice...\n\t\tspringAdvice.setAspectName(aspectName);\n\t\tspringAdvice.setDeclarationOrder(declarationOrder);\n\t\tString[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);\n\t\tif (argNames != null) {\n\t\t\tspringAdvice.setArgumentNamesFromStringArray(argNames);\n\t\t}\n\t\tspringAdvice.calculateArgumentBindings();\n\n\t\treturn springAdvice;\n\t}"
  },
  "org.springframework.aop.aspectj.annotation.<unknown>#getAdvisor(candidateAdviceMethod,aspectInstanceFactory,declarationOrderInAspect,aspectName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "candidateAdviceMethod",
      "aspectInstanceFactory",
      "declarationOrderInAspect",
      "aspectName"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "Advisor",
    "signature": "public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,\n\t\t\tint declarationOrderInAspect, String aspectName)",
    "source_code": "\tpublic Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,\n\t\t\tint declarationOrderInAspect, String aspectName) {\n\n\t\tvalidate(aspectInstanceFactory.getAspectMetadata().getAspectClass());\n\n\t\tAspectJExpressionPointcut expressionPointcut = getPointcut(\n\t\t\t\tcandidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());\n\t\tif (expressionPointcut == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,\n\t\t\t\tthis, aspectInstanceFactory, declarationOrderInAspect, aspectName);\n\t}"
  },
  "org.springframework.aop.aspectj.annotation.<unknown>#matches(method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\t\t// We're either instantiated and matching on declared pointcut,\n\t\t\t// or uninstantiated matching on either pointcut...\n\t\t\treturn (isAspectMaterialized() && this.declaredPointcut.matches(method, targetClass)) ||\n\t\t\t\t\tthis.preInstantiationPointcut.getMethodMatcher().matches(method, targetClass);\n\t\t}"
  },
  "org.springframework.aop.aspectj.annotation.<unknown>#matches(method,targetClass,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass, Object... args)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass, Object... args) {\n\t\t\t// This can match only on declared pointcut.\n\t\t\treturn (isAspectMaterialized() && this.declaredPointcut.matches(method, targetClass));\n\t\t}"
  },
  "org.springframework.aop.aspectj.autoproxy.<unknown>#shouldSkip(beanClass,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "boolean",
    "signature": "protected boolean shouldSkip(Class<?> beanClass, String beanName)",
    "source_code": "\tprotected boolean shouldSkip(Class<?> beanClass, String beanName) {\n\t\t// TODO: Consider optimization by caching the list of the aspect names\n\t\tList<Advisor> candidateAdvisors = findCandidateAdvisors();\n\t\tfor (Advisor advisor : candidateAdvisors) {\n\t\t\tif (advisor instanceof AspectJPointcutAdvisor pointcutAdvisor &&\n\t\t\t\t\tpointcutAdvisor.getAspectName().equals(beanName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn super.shouldSkip(beanClass, beanName);\n\t}"
  },
  "org.springframework.aop.config.<unknown>#decorate(node,definition,parserContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "node",
      "definition",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext)",
    "source_code": "\tpublic BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {\n\t\tboolean proxyTargetClass = true;\n\t\tif (node instanceof Element ele) {\n\t\t\tif (ele.hasAttribute(PROXY_TARGET_CLASS)) {\n\t\t\t\tproxyTargetClass = Boolean.parseBoolean(ele.getAttribute(PROXY_TARGET_CLASS));\n\t\t\t}\n\t\t}\n\n\t\t// Register the original bean definition as it will be referenced by the scoped proxy\n\t\t// and is relevant for tooling (validation, navigation).\n\t\tBeanDefinitionHolder holder =\n\t\t\t\tScopedProxyUtils.createScopedProxy(definition, parserContext.getRegistry(), proxyTargetClass);\n\t\tString targetBeanName = ScopedProxyUtils.getTargetBeanName(definition.getBeanName());\n\t\tparserContext.getReaderContext().fireComponentRegistered(\n\t\t\t\tnew BeanComponentDefinition(definition.getBeanDefinition(), targetBeanName));\n\t\treturn holder;\n\t}"
  },
  "org.springframework.aop.config.<unknown>#decorate(node,definitionHolder,parserContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "node",
      "definitionHolder",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definitionHolder, ParserContext parserContext)",
    "source_code": "\tpublic final BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definitionHolder, ParserContext parserContext) {\n\t\tBeanDefinitionRegistry registry = parserContext.getRegistry();\n\n\t\t// get the root bean name - will be the name of the generated proxy factory bean\n\t\tString existingBeanName = definitionHolder.getBeanName();\n\t\tBeanDefinition targetDefinition = definitionHolder.getBeanDefinition();\n\t\tBeanDefinitionHolder targetHolder = new BeanDefinitionHolder(targetDefinition, existingBeanName + \".TARGET\");\n\n\t\t// delegate to subclass for interceptor definition\n\t\tBeanDefinition interceptorDefinition = createInterceptorDefinition(node);\n\n\t\t// generate name and register the interceptor\n\t\tString interceptorName = existingBeanName + '.' + getInterceptorNameSuffix(interceptorDefinition);\n\t\tBeanDefinitionReaderUtils.registerBeanDefinition(\n\t\t\t\tnew BeanDefinitionHolder(interceptorDefinition, interceptorName), registry);\n\n\t\tBeanDefinitionHolder result = definitionHolder;\n\n\t\tif (!isProxyFactoryBeanDefinition(targetDefinition)) {\n\t\t\t// create the proxy definition\n\t\t\tRootBeanDefinition proxyDefinition = new RootBeanDefinition();\n\t\t\t// create proxy factory bean definition\n\t\t\tproxyDefinition.setBeanClass(ProxyFactoryBean.class);\n\t\t\tproxyDefinition.setScope(targetDefinition.getScope());\n\t\t\tproxyDefinition.setLazyInit(targetDefinition.isLazyInit());\n\t\t\t// set the target\n\t\t\tproxyDefinition.setDecoratedDefinition(targetHolder);\n\t\t\tproxyDefinition.getPropertyValues().add(\"target\", targetHolder);\n\t\t\t// create the interceptor names list\n\t\t\tproxyDefinition.getPropertyValues().add(\"interceptorNames\", new ManagedList<String>());\n\t\t\t// copy autowire settings from original bean definition.\n\t\t\tproxyDefinition.setAutowireCandidate(targetDefinition.isAutowireCandidate());\n\t\t\tproxyDefinition.setPrimary(targetDefinition.isPrimary());\n\t\t\tif (targetDefinition instanceof AbstractBeanDefinition abd) {\n\t\t\t\tproxyDefinition.copyQualifiersFrom(abd);\n\t\t\t}\n\t\t\t// wrap it in a BeanDefinitionHolder with bean name\n\t\t\tresult = new BeanDefinitionHolder(proxyDefinition, existingBeanName);\n\t\t}\n\n\t\taddInterceptorNameToList(interceptorName, result.getBeanDefinition());\n\t\treturn result;\n\t}"
  },
  "org.springframework.aop.config.<unknown>#parse(element,parserContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "BeanDefinition",
    "signature": "public BeanDefinition parse(Element element, ParserContext parserContext)",
    "source_code": "\tpublic BeanDefinition parse(Element element, ParserContext parserContext) {\n\t\tCompositeComponentDefinition compositeDef =\n\t\t\t\tnew CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element));\n\t\tparserContext.pushContainingComponent(compositeDef);\n\n\t\tconfigureAutoProxyCreator(parserContext, element);\n\n\t\tList<Element> childElts = DomUtils.getChildElements(element);\n\t\tfor (Element elt: childElts) {\n\t\t\tString localName = parserContext.getDelegate().getLocalName(elt);\n\t\t\tswitch (localName) {\n\t\t\t\tcase POINTCUT -> parsePointcut(elt, parserContext);\n\t\t\t\tcase ADVISOR -> parseAdvisor(elt, parserContext);\n\t\t\t\tcase ASPECT -> parseAspect(elt, parserContext);\n\t\t\t}\n\t\t}\n\n\t\tparserContext.popAndRegisterContainingComponent();\n\t\treturn null;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#addAdvice(pos,advice)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Cannot add introductions this way unless the advice implements IntroductionInfo.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "advice"
    ],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "void",
    "signature": "public void addAdvice(int pos, Advice advice)",
    "source_code": "\tpublic void addAdvice(int pos, Advice advice) throws AopConfigException {\n\t\tAssert.notNull(advice, \"Advice must not be null\");\n\t\tif (advice instanceof IntroductionInfo introductionInfo) {\n\t\t\t// We don't need an IntroductionAdvisor for this kind of introduction:\n\t\t\t// It's fully self-describing.\n\t\t\taddAdvisor(pos, new DefaultIntroductionAdvisor(advice, introductionInfo));\n\t\t}\n\t\telse if (advice instanceof DynamicIntroductionAdvice) {\n\t\t\t// We need an IntroductionAdvisor for this kind of introduction.\n\t\t\tthrow new AopConfigException(\"DynamicIntroductionAdvice may only be added as part of IntroductionAdvisor\");\n\t\t}\n\t\telse {\n\t\t\taddAdvisor(pos, new DefaultPointcutAdvisor(advice));\n\t\t}\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#addAdvisor(pos,advisor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "advisor"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "void",
    "signature": "public void addAdvisor(int pos, Advisor advisor)",
    "source_code": "\tpublic void addAdvisor(int pos, Advisor advisor) throws AopConfigException {\n\t\tif (advisor instanceof IntroductionAdvisor introductionAdvisor) {\n\t\t\tvalidateIntroductionAdvisor(introductionAdvisor);\n\t\t}\n\t\taddAdvisorInternal(pos, advisor);\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#copyConfigurationFrom(other,targetSource,advisors)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the AOP configuration from the given AdvisedSupport object,\n\t * but allow substitution of a fresh TargetSource and a given interceptor chain.\n\t * @param other the AdvisedSupport object to take proxy configuration from\n\t * @param targetSource the new TargetSource\n\t * @param advisors the Advisors for the chain\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "other",
      "targetSource",
      "advisors"
    ],
    "position": {
      "column": 1,
      "line": 503
    },
    "return": "void",
    "signature": "protected void copyConfigurationFrom(AdvisedSupport other, TargetSource targetSource, List<Advisor> advisors)",
    "source_code": "\tprotected void copyConfigurationFrom(AdvisedSupport other, TargetSource targetSource, List<Advisor> advisors) {\n\t\tcopyFrom(other);\n\t\tthis.targetSource = targetSource;\n\t\tthis.advisorChainFactory = other.advisorChainFactory;\n\t\tthis.interfaces = new ArrayList<>(other.interfaces);\n\t\tfor (Advisor advisor : advisors) {\n\t\t\tif (advisor instanceof IntroductionAdvisor introductionAdvisor) {\n\t\t\t\tvalidateIntroductionAdvisor(introductionAdvisor);\n\t\t\t}\n\t\t\tAssert.notNull(advisor, \"Advisor must not be null\");\n\t\t\tthis.advisors.add(advisor);\n\t\t}\n\t\tadviceChanged();\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#createProxyClassAndInstance(enhancer,callbacks)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "enhancer",
      "callbacks"
    ],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "Object",
    "signature": "protected Object createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks)",
    "source_code": "\tprotected Object createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks) {\n\t\tenhancer.setInterceptDuringConstruction(false);\n\t\tenhancer.setCallbacks(callbacks);\n\t\treturn (this.constructorArgs != null && this.constructorArgTypes != null ?\n\t\t\t\tenhancer.create(this.constructorArgTypes, this.constructorArgs) :\n\t\t\t\tenhancer.create());\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#equalsAdvisors(a,b)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check equality of the advisors behind the given AdvisedSupport objects.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "a",
      "b"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "boolean",
    "signature": "public boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b)",
    "source_code": "\tpublic static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b) {\n\t\treturn a.getAdvisorCount() == b.getAdvisorCount() && Arrays.equals(a.getAdvisors(), b.getAdvisors());\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#equalsInProxy(a,b)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check equality of the proxies behind the given AdvisedSupport objects.\n\t * Not the same as equality of the AdvisedSupport objects:\n\t * rather, equality of interfaces, advisors and target sources.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "a",
      "b"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "boolean",
    "signature": "public boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b)",
    "source_code": "\tpublic static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b) {\n\t\treturn (a == b ||\n\t\t\t\t(equalsProxiedInterfaces(a, b) && equalsAdvisors(a, b) && a.getTargetSource().equals(b.getTargetSource())));\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#equalsProxiedInterfaces(a,b)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check equality of the proxied interfaces behind the given AdvisedSupport objects.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "a",
      "b"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "boolean",
    "signature": "public boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b)",
    "source_code": "\tpublic static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b) {\n\t\treturn Arrays.equals(a.getProxiedInterfaces(), b.getProxiedInterfaces());\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#getInterceptorsAndDynamicInterceptionAdvice(config,method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "config",
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "List<Object>",
    "signature": "public List<Object> getInterceptorsAndDynamicInterceptionAdvice(Advised config, Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic List<Object> getInterceptorsAndDynamicInterceptionAdvice(\n\t\t\tAdvised config, Method method, @Nullable Class<?> targetClass) {\n\n\t\t// This is somewhat tricky... We have to process introductions first,\n\t\t// but we need to preserve order in the ultimate list.\n\t\tAdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();\n\t\tAdvisor[] advisors = config.getAdvisors();\n\t\tList<Object> interceptorList = new ArrayList<>(advisors.length);\n\t\tClass<?> actualClass = (targetClass != null ? targetClass : method.getDeclaringClass());\n\t\tBoolean hasIntroductions = null;\n\n\t\tfor (Advisor advisor : advisors) {\n\t\t\tif (advisor instanceof PointcutAdvisor pointcutAdvisor) {\n\t\t\t\t// Add it conditionally.\n\t\t\t\tif (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {\n\t\t\t\t\tMethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();\n\t\t\t\t\tboolean match;\n\t\t\t\t\tif (mm instanceof IntroductionAwareMethodMatcher iamm) {\n\t\t\t\t\t\tif (hasIntroductions == null) {\n\t\t\t\t\t\t\thasIntroductions = hasMatchingIntroductions(advisors, actualClass);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = iamm.matches(method, actualClass, hasIntroductions);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmatch = mm.matches(method, actualClass);\n\t\t\t\t\t}\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tMethodInterceptor[] interceptors = registry.getInterceptors(advisor);\n\t\t\t\t\t\tif (mm.isRuntime()) {\n\t\t\t\t\t\t\t// Creating a new object instance in the getInterceptors() method\n\t\t\t\t\t\t\t// isn't a problem as we normally cache created chains.\n\t\t\t\t\t\t\tfor (MethodInterceptor interceptor : interceptors) {\n\t\t\t\t\t\t\t\tinterceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tinterceptorList.addAll(Arrays.asList(interceptors));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (advisor instanceof IntroductionAdvisor ia) {\n\t\t\t\tif (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) {\n\t\t\t\t\tInterceptor[] interceptors = registry.getInterceptors(advisor);\n\t\t\t\t\tinterceptorList.addAll(Arrays.asList(interceptors));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tInterceptor[] interceptors = registry.getInterceptors(advisor);\n\t\t\t\tinterceptorList.addAll(Arrays.asList(interceptors));\n\t\t\t}\n\t\t}\n\n\t\treturn interceptorList;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#getInterceptorsAndDynamicInterceptionAdvice(method,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine a list of {@link org.aopalliance.intercept.MethodInterceptor} objects\n\t * for the given method, based on this configuration.\n\t * @param method the proxied method\n\t * @param targetClass the target class\n\t * @return a List of MethodInterceptors (may also include InterceptorAndDynamicMethodMatchers)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 469
    },
    "return": "List<Object>",
    "signature": "public List<Object> getInterceptorsAndDynamicInterceptionAdvice(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic List<Object> getInterceptorsAndDynamicInterceptionAdvice(Method method, @Nullable Class<?> targetClass) {\n\t\tMethodCacheKey cacheKey = new MethodCacheKey(method);\n\t\tList<Object> cached = this.methodCache.get(cacheKey);\n\t\tif (cached == null) {\n\t\t\tcached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(\n\t\t\t\t\tthis, method, targetClass);\n\t\t\tthis.methodCache.put(cacheKey, cached);\n\t\t}\n\t\treturn cached;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#intercept(proxy,method,args,methodProxy)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args",
      "methodProxy"
    ],
    "position": {
      "column": 1,
      "line": 674
    },
    "return": "Object",
    "signature": "public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy)",
    "source_code": "\t\tpublic Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n\t\t\tObject oldProxy = null;\n\t\t\tboolean setProxyContext = false;\n\t\t\tObject target = null;\n\t\t\tTargetSource targetSource = this.advised.getTargetSource();\n\t\t\ttry {\n\t\t\t\tif (this.advised.exposeProxy) {\n\t\t\t\t\t// Make invocation available if necessary.\n\t\t\t\t\toldProxy = AopContext.setCurrentProxy(proxy);\n\t\t\t\t\tsetProxyContext = true;\n\t\t\t\t}\n\t\t\t\t// Get as late as possible to minimize the time we \"own\" the target, in case it comes from a pool...\n\t\t\t\ttarget = targetSource.getTarget();\n\t\t\t\tClass<?> targetClass = (target != null ? target.getClass() : null);\n\t\t\t\tList<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\n\t\t\t\tObject retVal;\n\t\t\t\t// Check whether we only have one InvokerInterceptor: that is,\n\t\t\t\t// no real advice, but just reflective invocation of the target.\n\t\t\t\tif (chain.isEmpty()) {\n\t\t\t\t\t// We can skip creating a MethodInvocation: just invoke the target directly.\n\t\t\t\t\t// Note that the final invoker must be an InvokerInterceptor, so we know\n\t\t\t\t\t// it does nothing but a reflective operation on the target, and no hot\n\t\t\t\t\t// swapping or fancy proxying.\n\t\t\t\t\tObject[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);\n\t\t\t\t\tretVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// We need to create a method invocation...\n\t\t\t\t\tretVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();\n\t\t\t\t}\n\t\t\t\treturn processReturnType(proxy, target, method, retVal);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (target != null && !targetSource.isStatic()) {\n\t\t\t\t\ttargetSource.releaseTarget(target);\n\t\t\t\t}\n\t\t\t\tif (setProxyContext) {\n\t\t\t\t\t// Restore old proxy.\n\t\t\t\t\tAopContext.setCurrentProxy(oldProxy);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.aop.framework.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Implementation of {@code InvocationHandler.invoke}.\n\t * <p>Callers will see exactly the exception thrown by the target,\n\t * unless a hook method throws an exception.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\tObject oldProxy = null;\n\t\tboolean setProxyContext = false;\n\n\t\tTargetSource targetSource = this.advised.targetSource;\n\t\tObject target = null;\n\n\t\ttry {\n\t\t\tif (!this.equalsDefined && AopUtils.isEqualsMethod(method)) {\n\t\t\t\t// The target does not implement the equals(Object) method itself.\n\t\t\t\treturn equals(args[0]);\n\t\t\t}\n\t\t\telse if (!this.hashCodeDefined && AopUtils.isHashCodeMethod(method)) {\n\t\t\t\t// The target does not implement the hashCode() method itself.\n\t\t\t\treturn hashCode();\n\t\t\t}\n\t\t\telse if (method.getDeclaringClass() == DecoratingProxy.class) {\n\t\t\t\t// There is only getDecoratedClass() declared -> dispatch to proxy config.\n\t\t\t\treturn AopProxyUtils.ultimateTargetClass(this.advised);\n\t\t\t}\n\t\t\telse if (!this.advised.opaque && method.getDeclaringClass().isInterface() &&\n\t\t\t\t\tmethod.getDeclaringClass().isAssignableFrom(Advised.class)) {\n\t\t\t\t// Service invocations on ProxyConfig with the proxy config...\n\t\t\t\treturn AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);\n\t\t\t}\n\n\t\t\tObject retVal;\n\n\t\t\tif (this.advised.exposeProxy) {\n\t\t\t\t// Make invocation available if necessary.\n\t\t\t\toldProxy = AopContext.setCurrentProxy(proxy);\n\t\t\t\tsetProxyContext = true;\n\t\t\t}\n\n\t\t\t// Get as late as possible to minimize the time we \"own\" the target,\n\t\t\t// in case it comes from a pool.\n\t\t\ttarget = targetSource.getTarget();\n\t\t\tClass<?> targetClass = (target != null ? target.getClass() : null);\n\n\t\t\t// Get the interception chain for this method.\n\t\t\tList<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\n\n\t\t\t// Check whether we have any advice. If we don't, we can fall back on direct\n\t\t\t// reflective invocation of the target, and avoid creating a MethodInvocation.\n\t\t\tif (chain.isEmpty()) {\n\t\t\t\t// We can skip creating a MethodInvocation: just invoke the target directly\n\t\t\t\t// Note that the final invoker must be an InvokerInterceptor so we know it does\n\t\t\t\t// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.\n\t\t\t\tObject[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);\n\t\t\t\tretVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We need to create a method invocation...\n\t\t\t\tMethodInvocation invocation =\n\t\t\t\t\t\tnew ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);\n\t\t\t\t// Proceed to the joinpoint through the interceptor chain.\n\t\t\t\tretVal = invocation.proceed();\n\t\t\t}\n\n\t\t\t// Massage return value if necessary.\n\t\t\tClass<?> returnType = method.getReturnType();\n\t\t\tif (retVal != null && retVal == target &&\n\t\t\t\t\treturnType != Object.class && returnType.isInstance(proxy) &&\n\t\t\t\t\t!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {\n\t\t\t\t// Special case: it returned \"this\" and the return type of the method\n\t\t\t\t// is type-compatible. Note that we can't help if the target sets\n\t\t\t\t// a reference to itself in another returned object.\n\t\t\t\tretVal = proxy;\n\t\t\t}\n\t\t\telse if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {\n\t\t\t\tthrow new AopInvocationException(\n\t\t\t\t\t\t\"Null return value from advice does not match primitive return type for: \" + method);\n\t\t\t}\n\t\t\treturn retVal;\n\t\t}\n\t\tfinally {\n\t\t\tif (target != null && !targetSource.isStatic()) {\n\t\t\t\t// Must have come from TargetSource.\n\t\t\t\ttargetSource.releaseTarget(target);\n\t\t\t}\n\t\t\tif (setProxyContext) {\n\t\t\t\t// Restore old proxy.\n\t\t\t\tAopContext.setCurrentProxy(oldProxy);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#isEligible(bean,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given bean is eligible for advising with this\n\t * post-processor's {@link Advisor}.\n\t * <p>Delegates to {@link #isEligible(Class)} for target class checking.\n\t * Can be overridden e.g. to specifically exclude certain beans by name.\n\t * <p>Note: Only called for regular bean instances but not for existing\n\t * proxy instances which implement {@link Advised} and allow for adding\n\t * the local {@link Advisor} to the existing proxy's {@link Advisor} chain.\n\t * For the latter, {@link #isEligible(Class)} is being called directly,\n\t * with the actual target class behind the existing proxy (as determined\n\t * by {@link AopUtils#getTargetClass(Object)}).\n\t * @param bean the bean instance\n\t * @param beanName the name of the bean\n\t * @see #isEligible(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "boolean",
    "signature": "protected boolean isEligible(Object bean, String beanName)",
    "source_code": "\tprotected boolean isEligible(Object bean, String beanName) {\n\t\treturn isEligible(bean.getClass());\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) {\n\t\tif (this.advisor == null || bean instanceof AopInfrastructureBean) {\n\t\t\t// Ignore AOP infrastructure such as scoped proxies.\n\t\t\treturn bean;\n\t\t}\n\n\t\tif (bean instanceof Advised advised) {\n\t\t\tif (!advised.isFrozen() && isEligible(AopUtils.getTargetClass(bean))) {\n\t\t\t\t// Add our local Advisor to the existing proxy's Advisor chain.\n\t\t\t\tif (this.beforeExistingAdvisors) {\n\t\t\t\t\tadvised.addAdvisor(0, this.advisor);\n\t\t\t\t}\n\t\t\t\telse if (advised.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE &&\n\t\t\t\t\t\tadvised.getAdvisorCount() > 0) {\n\t\t\t\t\t// No target, leave last Advisor in place and add new Advisor right before.\n\t\t\t\t\tadvised.addAdvisor(advised.getAdvisorCount() - 1, this.advisor);\n\t\t\t\t\treturn bean;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tadvised.addAdvisor(this.advisor);\n\t\t\t\t}\n\t\t\t\treturn bean;\n\t\t\t}\n\t\t}\n\n\t\tif (isEligible(bean, beanName)) {\n\t\t\tProxyFactory proxyFactory = prepareProxyFactory(bean, beanName);\n\t\t\tif (!proxyFactory.isProxyTargetClass()) {\n\t\t\t\tevaluateProxyInterfaces(bean.getClass(), proxyFactory);\n\t\t\t}\n\t\t\tproxyFactory.addAdvisor(this.advisor);\n\t\t\tcustomizeProxyFactory(proxyFactory);\n\n\t\t\t// Use original ClassLoader if bean class not locally loaded in overriding class loader\n\t\t\tClassLoader classLoader = getProxyClassLoader();\n\t\t\tif (classLoader instanceof SmartClassLoader smartClassLoader &&\n\t\t\t\t\tclassLoader != bean.getClass().getClassLoader()) {\n\t\t\t\tclassLoader = smartClassLoader.getOriginalClassLoader();\n\t\t\t}\n\t\t\treturn proxyFactory.getProxy(classLoader);\n\t\t}\n\n\t\t// No proxy needed.\n\t\treturn bean;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#prepareProxyFactory(bean,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare a {@link ProxyFactory} for the given bean.\n\t * <p>Subclasses may customize the handling of the target instance and in\n\t * particular the exposure of the target class. The default introspection\n\t * of interfaces for non-target-class proxies and the configured advisor\n\t * will be applied afterwards; {@link #customizeProxyFactory} allows for\n\t * late customizations of those parts right before proxy creation.\n\t * @param bean the bean instance to create a proxy for\n\t * @param beanName the corresponding bean name\n\t * @return the ProxyFactory, initialized with this processor's\n\t * {@link ProxyConfig} settings and the specified bean\n\t * @since 4.2.3\n\t * @see #customizeProxyFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "ProxyFactory",
    "signature": "protected ProxyFactory prepareProxyFactory(Object bean, String beanName)",
    "source_code": "\tprotected ProxyFactory prepareProxyFactory(Object bean, String beanName) {\n\t\tProxyFactory proxyFactory = new ProxyFactory();\n\t\tproxyFactory.copyFrom(this);\n\t\tproxyFactory.setTarget(bean);\n\t\treturn proxyFactory;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#replaceAdvisor(a,b)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "a",
      "b"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "boolean",
    "signature": "public boolean replaceAdvisor(Advisor a, Advisor b)",
    "source_code": "\tpublic boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException {\n\t\tAssert.notNull(a, \"Advisor a must not be null\");\n\t\tAssert.notNull(b, \"Advisor b must not be null\");\n\t\tint index = indexOf(a);\n\t\tif (index == -1) {\n\t\t\treturn false;\n\t\t}\n\t\tremoveAdvisor(index);\n\t\taddAdvisor(index, b);\n\t\treturn true;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#setConstructorArguments(constructorArgs,constructorArgTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set constructor arguments to use for creating the proxy.\n\t * @param constructorArgs the constructor argument values\n\t * @param constructorArgTypes the constructor argument types\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constructorArgs",
      "constructorArgTypes"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes)",
    "source_code": "\tpublic void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes) {\n\t\tif (constructorArgs == null || constructorArgTypes == null) {\n\t\t\tthrow new IllegalArgumentException(\"Both 'constructorArgs' and 'constructorArgTypes' need to be specified\");\n\t\t}\n\t\tif (constructorArgs.length != constructorArgTypes.length) {\n\t\t\tthrow new IllegalArgumentException(\"Number of 'constructorArgs' (\" + constructorArgs.length +\n\t\t\t\t\t\") must match number of 'constructorArgTypes' (\" + constructorArgTypes.length + \")\");\n\t\t}\n\t\tthis.constructorArgs = constructorArgs;\n\t\tthis.constructorArgTypes = constructorArgTypes;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#setUserAttribute(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "void",
    "signature": "public void setUserAttribute(String key, @Nullable Object value)",
    "source_code": "\tpublic void setUserAttribute(String key, @Nullable Object value) {\n\t\tif (value != null) {\n\t\t\tif (this.userAttributes == null) {\n\t\t\t\tthis.userAttributes = new HashMap<>();\n\t\t\t}\n\t\t\tthis.userAttributes.put(key, value);\n\t\t}\n\t\telse {\n\t\t\tif (this.userAttributes != null) {\n\t\t\t\tthis.userAttributes.remove(key);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.aop.framework.adapter.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (bean instanceof AdvisorAdapter advisorAdapter) {\n\t\t\tthis.advisorAdapterRegistry.registerAdvisorAdapter(advisorAdapter);\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.aop.framework.adapter.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#buildAdvisors(beanName,specificInterceptors)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the advisors for the given bean, including the specific interceptors\n\t * as well as the common interceptor, all adapted to the Advisor interface.\n\t * @param beanName the name of the bean\n\t * @param specificInterceptors the set of interceptors that is\n\t * specific to this bean (may be empty, but not null)\n\t * @return the list of Advisors for the given bean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "specificInterceptors"
    ],
    "position": {
      "column": 1,
      "line": 556
    },
    "return": "Advisor[]",
    "signature": "protected Advisor[] buildAdvisors(@Nullable String beanName, @Nullable Object[] specificInterceptors)",
    "source_code": "\tprotected Advisor[] buildAdvisors(@Nullable String beanName, @Nullable Object[] specificInterceptors) {\n\t\t// Handle prototypes correctly...\n\t\tAdvisor[] commonInterceptors = resolveInterceptorNames();\n\n\t\tList<Object> allInterceptors = new ArrayList<>();\n\t\tif (specificInterceptors != null) {\n\t\t\tif (specificInterceptors.length > 0) {\n\t\t\t\t// specificInterceptors may equal PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS\n\t\t\t\tallInterceptors.addAll(Arrays.asList(specificInterceptors));\n\t\t\t}\n\t\t\tif (commonInterceptors.length > 0) {\n\t\t\t\tif (this.applyCommonInterceptorsFirst) {\n\t\t\t\t\tallInterceptors.addAll(0, Arrays.asList(commonInterceptors));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tallInterceptors.addAll(Arrays.asList(commonInterceptors));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tint nrOfCommonInterceptors = commonInterceptors.length;\n\t\t\tint nrOfSpecificInterceptors = (specificInterceptors != null ? specificInterceptors.length : 0);\n\t\t\tlogger.trace(\"Creating implicit proxy for bean '\" + beanName + \"' with \" + nrOfCommonInterceptors +\n\t\t\t\t\t\" common interceptors and \" + nrOfSpecificInterceptors + \" specific interceptors\");\n\t\t}\n\n\t\tAdvisor[] advisors = new Advisor[allInterceptors.size()];\n\t\tfor (int i = 0; i < allInterceptors.size(); i++) {\n\t\t\tadvisors[i] = this.advisorAdapterRegistry.wrap(allInterceptors.get(i));\n\t\t}\n\t\treturn advisors;\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#createProxy(beanClass,beanName,specificInterceptors,targetSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create an AOP proxy for the given bean.\n\t * @param beanClass the class of the bean\n\t * @param beanName the name of the bean\n\t * @param specificInterceptors the set of interceptors that is\n\t * specific to this bean (may be empty, but not null)\n\t * @param targetSource the TargetSource for the proxy,\n\t * already pre-configured to access the bean\n\t * @return the AOP proxy for the bean\n\t * @see #buildAdvisors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName",
      "specificInterceptors",
      "targetSource"
    ],
    "position": {
      "column": 1,
      "line": 461
    },
    "return": "Object",
    "signature": "protected Object createProxy(Class<?> beanClass, @Nullable String beanName,\n\t\t\t@Nullable Object[] specificInterceptors, TargetSource targetSource)",
    "source_code": "\tprotected Object createProxy(Class<?> beanClass, @Nullable String beanName,\n\t\t\t@Nullable Object[] specificInterceptors, TargetSource targetSource) {\n\n\t\treturn buildProxy(beanClass, beanName, specificInterceptors, targetSource, false);\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#findAdvisorsThatCanApply(candidateAdvisors,beanClass,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Search the given candidate Advisors to find all Advisors that\n\t * can apply to the specified bean.\n\t * @param candidateAdvisors the candidate Advisors\n\t * @param beanClass the target's bean class\n\t * @param beanName the target's bean name\n\t * @return the List of applicable Advisors\n\t * @see ProxyCreationContext#getCurrentProxiedBeanName()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "candidateAdvisors",
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "List<Advisor>",
    "signature": "protected List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> beanClass, String beanName)",
    "source_code": "\tprotected List<Advisor> findAdvisorsThatCanApply(\n\t\t\tList<Advisor> candidateAdvisors, Class<?> beanClass, String beanName) {\n\n\t\tProxyCreationContext.setCurrentProxiedBeanName(beanName);\n\t\ttry {\n\t\t\treturn AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);\n\t\t}\n\t\tfinally {\n\t\t\tProxyCreationContext.setCurrentProxiedBeanName(null);\n\t\t}\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#findEligibleAdvisors(beanClass,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find all eligible Advisors for auto-proxying this class.\n\t * @param beanClass the clazz to find advisors for\n\t * @param beanName the name of the currently proxied bean\n\t * @return the empty List, not {@code null},\n\t * if there are no pointcuts or interceptors\n\t * @see #findCandidateAdvisors\n\t * @see #sortAdvisors\n\t * @see #extendAdvisors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "List<Advisor>",
    "signature": "protected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName)",
    "source_code": "\tprotected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {\n\t\tList<Advisor> candidateAdvisors = findCandidateAdvisors();\n\t\tList<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);\n\t\textendAdvisors(eligibleAdvisors);\n\t\tif (!eligibleAdvisors.isEmpty()) {\n\t\t\teligibleAdvisors = sortAdvisors(eligibleAdvisors);\n\t\t}\n\t\treturn eligibleAdvisors;\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#getAdvicesAndAdvisorsForBean(beanClass,beanName,customTargetSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the given bean is to be proxied, what additional\n\t * advices (e.g. AOP Alliance interceptors) and advisors to apply.\n\t * @param beanClass the class of the bean to advise\n\t * @param beanName the name of the bean\n\t * @param customTargetSource the TargetSource returned by the\n\t * {@link #getCustomTargetSource} method: may be ignored.\n\t * Will be {@code null} if no custom target source is in use.\n\t * @return an array of additional interceptors for the particular bean;\n\t * or an empty array if no additional interceptors but just the common ones;\n\t * or {@code null} if no proxy at all, not even with the common interceptors.\n\t * See constants DO_NOT_PROXY and PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS.\n\t * @throws BeansException in case of errors\n\t * @see #DO_NOT_PROXY\n\t * @see #PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName",
      "customTargetSource"
    ],
    "position": {
      "column": 1,
      "line": 636
    },
    "return": "Object[]",
    "signature": "protected Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanName,\n\t\t\t@Nullable TargetSource customTargetSource)",
    "source_code": "\tprotected abstract Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanName,\n\t\t\t@Nullable TargetSource customTargetSource) throws BeansException;\n\n}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#getAdvicesAndAdvisorsForBean(beanClass,beanName,targetSource)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName",
      "targetSource"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "Object[]",
    "signature": "protected Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanName, @Nullable TargetSource targetSource)",
    "source_code": "\tprotected Object[] getAdvicesAndAdvisorsForBean(\n\t\t\tClass<?> beanClass, String beanName, @Nullable TargetSource targetSource) {\n\n\t\tList<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);\n\t\tif (advisors.isEmpty()) {\n\t\t\treturn DO_NOT_PROXY;\n\t\t}\n\t\treturn advisors.toArray();\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#getCacheKey(beanClass,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Build a cache key for the given bean class and bean name.\n\t * <p>Note: As of 4.2.3, this implementation does not return a concatenated\n\t * class/name String anymore but rather the most efficient cache key possible:\n\t * a plain bean name, prepended with {@link BeanFactory#FACTORY_BEAN_PREFIX}\n\t * in case of a {@code FactoryBean}; or if no bean name specified, then the\n\t * given bean {@code Class} as-is.\n\t * @param beanClass the bean class\n\t * @param beanName the bean name\n\t * @return the cache key for the given class and name\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "Object",
    "signature": "protected Object getCacheKey(Class<?> beanClass, @Nullable String beanName)",
    "source_code": "\tprotected Object getCacheKey(Class<?> beanClass, @Nullable String beanName) {\n\t\tif (StringUtils.hasLength(beanName)) {\n\t\t\treturn (FactoryBean.class.isAssignableFrom(beanClass) ?\n\t\t\t\t\tBeanFactory.FACTORY_BEAN_PREFIX + beanName : beanName);\n\t\t}\n\t\telse {\n\t\t\treturn beanClass;\n\t\t}\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#getCustomTargetSource(beanClass,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a target source for bean instances. Uses any TargetSourceCreators if set.\n\t * Returns {@code null} if no custom TargetSource should be used.\n\t * <p>This implementation uses the \"customTargetSourceCreators\" property.\n\t * Subclasses can override this method to use a different mechanism.\n\t * @param beanClass the class of the bean to create a TargetSource for\n\t * @param beanName the name of the bean\n\t * @return a TargetSource for this bean\n\t * @see #setCustomTargetSourceCreators\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "TargetSource",
    "signature": "protected TargetSource getCustomTargetSource(Class<?> beanClass, String beanName)",
    "source_code": "\tprotected TargetSource getCustomTargetSource(Class<?> beanClass, String beanName) {\n\t\t// We can't create fancy target sources for directly registered singletons.\n\t\tif (this.customTargetSourceCreators != null &&\n\t\t\t\tthis.beanFactory != null && this.beanFactory.containsBean(beanName)) {\n\t\t\tfor (TargetSourceCreator tsc : this.customTargetSourceCreators) {\n\t\t\t\tTargetSource ts = tsc.getTargetSource(beanClass, beanName);\n\t\t\t\tif (ts != null) {\n\t\t\t\t\t// Found a matching TargetSource.\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"TargetSourceCreator [\" + tsc +\n\t\t\t\t\t\t\t\t\"] found custom TargetSource for bean with name '\" + beanName + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\treturn ts;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// No custom TargetSource found.\n\t\treturn null;\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#getEarlyBeanReference(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "Object",
    "signature": "public Object getEarlyBeanReference(Object bean, String beanName)",
    "source_code": "\tpublic Object getEarlyBeanReference(Object bean, String beanName) {\n\t\tObject cacheKey = getCacheKey(bean.getClass(), beanName);\n\t\tthis.earlyProxyReferences.put(cacheKey, bean);\n\t\treturn wrapIfNecessary(bean, beanName, cacheKey);\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#isEligible(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "boolean",
    "signature": "protected boolean isEligible(Object bean, String beanName)",
    "source_code": "\tprotected boolean isEligible(Object bean, String beanName) {\n\t\treturn (!AutoProxyUtils.isOriginalInstance(beanName, bean.getClass()) &&\n\t\t\t\tsuper.isEligible(bean, beanName));\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a proxy with the configured interceptors if the bean is\n\t * identified as one to proxy by the subclass.\n\t * @see #getAdvicesAndAdvisorsForBean\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(@Nullable Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {\n\t\tif (bean != null) {\n\t\t\tObject cacheKey = getCacheKey(bean.getClass(), beanName);\n\t\t\tif (this.earlyProxyReferences.remove(cacheKey) != bean) {\n\t\t\t\treturn wrapIfNecessary(bean, beanName, cacheKey);\n\t\t\t}\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#postProcessBeforeInstantiation(beanClass,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) {\n\t\tObject cacheKey = getCacheKey(beanClass, beanName);\n\n\t\tif (!StringUtils.hasLength(beanName) || !this.targetSourcedBeans.contains(beanName)) {\n\t\t\tif (this.advisedBeans.containsKey(cacheKey)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) {\n\t\t\t\tthis.advisedBeans.put(cacheKey, Boolean.FALSE);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// Create proxy here if we have a custom TargetSource.\n\t\t// Suppresses unnecessary default instantiation of the target bean:\n\t\t// The TargetSource will handle target instances in a custom fashion.\n\t\tTargetSource targetSource = getCustomTargetSource(beanClass, beanName);\n\t\tif (targetSource != null) {\n\t\t\tif (StringUtils.hasLength(beanName)) {\n\t\t\t\tthis.targetSourcedBeans.add(beanName);\n\t\t\t}\n\t\t\tObject[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);\n\t\t\tObject proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);\n\t\t\tthis.proxyTypes.put(cacheKey, proxy.getClass());\n\t\t\treturn proxy;\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#postProcessProperties(pvs,bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "PropertyValues",
    "signature": "public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)",
    "source_code": "\tpublic PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n\t\treturn pvs;  // skip postProcessPropertyValues\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#prepareProxyFactory(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "ProxyFactory",
    "signature": "protected ProxyFactory prepareProxyFactory(Object bean, String beanName)",
    "source_code": "\tprotected ProxyFactory prepareProxyFactory(Object bean, String beanName) {\n\t\tif (this.beanFactory != null) {\n\t\t\tAutoProxyUtils.exposeTargetClass(this.beanFactory, beanName, bean.getClass());\n\t\t}\n\n\t\tProxyFactory proxyFactory = super.prepareProxyFactory(bean, beanName);\n\t\tif (!proxyFactory.isProxyTargetClass() && this.beanFactory != null &&\n\t\t\t\tAutoProxyUtils.shouldProxyTargetClass(this.beanFactory, beanName)) {\n\t\t\tproxyFactory.setProxyTargetClass(true);\n\t\t}\n\t\treturn proxyFactory;\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#shouldProxyTargetClass(beanClass,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given bean should be proxied with its target class rather than its interfaces.\n\t * <p>Checks the {@link AutoProxyUtils#PRESERVE_TARGET_CLASS_ATTRIBUTE \"preserveTargetClass\" attribute}\n\t * of the corresponding bean definition.\n\t * @param beanClass the class of the bean\n\t * @param beanName the name of the bean\n\t * @return whether the given bean should be proxied with its target class\n\t * @see AutoProxyUtils#shouldProxyTargetClass\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 529
    },
    "return": "boolean",
    "signature": "protected boolean shouldProxyTargetClass(Class<?> beanClass, @Nullable String beanName)",
    "source_code": "\tprotected boolean shouldProxyTargetClass(Class<?> beanClass, @Nullable String beanName) {\n\t\treturn (this.beanFactory instanceof ConfigurableListableBeanFactory clbf &&\n\t\t\t\tAutoProxyUtils.shouldProxyTargetClass(clbf, beanName));\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#shouldSkip(beanClass,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses should override this method to return {@code true} if the\n\t * given bean should not be considered for auto-proxying by this post-processor.\n\t * <p>Sometimes we need to be able to avoid this happening, e.g. if it will lead to\n\t * a circular reference or if the existing target instance needs to be preserved.\n\t * This implementation returns {@code false} unless the bean name indicates an\n\t * \"original instance\" according to {@code AutowireCapableBeanFactory} conventions.\n\t * @param beanClass the class of the bean\n\t * @param beanName the name of the bean\n\t * @return whether to skip the given bean\n\t * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#ORIGINAL_INSTANCE_SUFFIX\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "boolean",
    "signature": "protected boolean shouldSkip(Class<?> beanClass, String beanName)",
    "source_code": "\tprotected boolean shouldSkip(Class<?> beanClass, String beanName) {\n\t\treturn AutoProxyUtils.isOriginalInstance(beanName, beanClass);\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#wrapIfNecessary(bean,beanName,cacheKey)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Wrap the given bean if necessary, i.e. if it is eligible for being proxied.\n\t * @param bean the raw bean instance\n\t * @param beanName the name of the bean\n\t * @param cacheKey the cache key for metadata access\n\t * @return a proxy wrapping the bean, or the raw bean instance as-is\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "beanName",
      "cacheKey"
    ],
    "position": {
      "column": 1,
      "line": 353
    },
    "return": "Object",
    "signature": "protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey)",
    "source_code": "\tprotected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {\n\t\tif (StringUtils.hasLength(beanName) && this.targetSourcedBeans.contains(beanName)) {\n\t\t\treturn bean;\n\t\t}\n\t\tif (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {\n\t\t\treturn bean;\n\t\t}\n\t\tif (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {\n\t\t\tthis.advisedBeans.put(cacheKey, Boolean.FALSE);\n\t\t\treturn bean;\n\t\t}\n\n\t\t// Create proxy if we have advice.\n\t\tObject[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);\n\t\tif (specificInterceptors != DO_NOT_PROXY) {\n\t\t\tthis.advisedBeans.put(cacheKey, Boolean.TRUE);\n\t\t\tObject proxy = createProxy(\n\t\t\t\t\tbean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));\n\t\t\tthis.proxyTypes.put(cacheKey, proxy.getClass());\n\t\t\treturn proxy;\n\t\t}\n\n\t\tthis.advisedBeans.put(cacheKey, Boolean.FALSE);\n\t\treturn bean;\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.target.<unknown>#createBeanFactoryBasedTargetSource(beanClass,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "AbstractBeanFactoryBasedTargetSource",
    "signature": "protected AbstractBeanFactoryBasedTargetSource createBeanFactoryBasedTargetSource(Class<?> beanClass, String beanName)",
    "source_code": "\tprotected AbstractBeanFactoryBasedTargetSource createBeanFactoryBasedTargetSource(\n\t\t\tClass<?> beanClass, String beanName) {\n\n\t\tif (getBeanFactory() instanceof ConfigurableListableBeanFactory clbf) {\n\t\t\tBeanDefinition definition = clbf.getBeanDefinition(beanName);\n\t\t\tif (definition.isLazyInit()) {\n\t\t\t\treturn new LazyInitTargetSource();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.target.<unknown>#getTargetSource(beanClass,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "TargetSource",
    "signature": "public TargetSource getTargetSource(Class<?> beanClass, String beanName)",
    "source_code": "\tpublic final TargetSource getTargetSource(Class<?> beanClass, String beanName) {\n\t\tAbstractBeanFactoryBasedTargetSource targetSource =\n\t\t\t\tcreateBeanFactoryBasedTargetSource(beanClass, beanName);\n\t\tif (targetSource == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Configuring AbstractBeanFactoryBasedTargetSource: \" + targetSource);\n\t\t}\n\n\t\tDefaultListableBeanFactory internalBeanFactory = getInternalBeanFactoryForBean(beanName);\n\n\t\t// We need to override just this bean definition, as it may reference other beans\n\t\t// and we're happy to take the parent's definition for those.\n\t\t// Always use prototype scope if demanded.\n\t\tBeanDefinition bd = this.beanFactory.getMergedBeanDefinition(beanName);\n\t\tGenericBeanDefinition bdCopy = new GenericBeanDefinition(bd);\n\t\tif (isPrototypeBased()) {\n\t\t\tbdCopy.setScope(BeanDefinition.SCOPE_PROTOTYPE);\n\t\t}\n\t\tinternalBeanFactory.registerBeanDefinition(beanName, bdCopy);\n\n\t\t// Complete configuring the PrototypeTargetSource.\n\t\ttargetSource.setTargetBeanName(beanName);\n\t\ttargetSource.setBeanFactory(internalBeanFactory);\n\n\t\treturn targetSource;\n\t}"
  },
  "org.springframework.aop.interceptor.<unknown>#configure(defaultExecutor,exceptionHandler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure this aspect with the given executor and exception handler suppliers,\n\t * applying the corresponding default if a supplier is not resolvable.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultExecutor",
      "exceptionHandler"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void configure(@Nullable Supplier<Executor> defaultExecutor,\n\t\t\t@Nullable Supplier<AsyncUncaughtExceptionHandler> exceptionHandler)",
    "source_code": "\tpublic void configure(@Nullable Supplier<Executor> defaultExecutor,\n\t\t\t@Nullable Supplier<AsyncUncaughtExceptionHandler> exceptionHandler) {\n\n\t\tthis.defaultExecutor = new SingletonSupplier<>(defaultExecutor, () -> getDefaultExecutor(this.beanFactory));\n\t\tthis.exceptionHandler = new SingletonSupplier<>(exceptionHandler, SimpleAsyncUncaughtExceptionHandler::new);\n\t}"
  },
  "org.springframework.aop.interceptor.<unknown>#doSubmit(task,executor,returnType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate for actually executing the given task with the chosen executor.\n\t * @param task the task to execute\n\t * @param executor the chosen executor\n\t * @param returnType the declared return type (potentially a {@link Future} variant)\n\t * @return the execution result (potentially a corresponding {@link Future} handle)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "executor",
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "Object",
    "signature": "protected Object doSubmit(Callable<Object> task, AsyncTaskExecutor executor, Class<?> returnType)",
    "source_code": "\tprotected Object doSubmit(Callable<Object> task, AsyncTaskExecutor executor, Class<?> returnType) {\n\t\tif (CompletableFuture.class.isAssignableFrom(returnType)) {\n\t\t\treturn executor.submitCompletable(task);\n\t\t}\n\t\telse if (org.springframework.util.concurrent.ListenableFuture.class.isAssignableFrom(returnType)) {\n\t\t\treturn ((org.springframework.core.task.AsyncListenableTaskExecutor) executor).submitListenable(task);\n\t\t}\n\t\telse if (Future.class.isAssignableFrom(returnType)) {\n\t\t\treturn executor.submit(task);\n\t\t}\n\t\telse if (void.class == returnType) {\n\t\t\texecutor.submit(task);\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Invalid return type for async method (only Future and void supported): \" + returnType);\n\t\t}\n\t}"
  },
  "org.springframework.aop.interceptor.<unknown>#findQualifiedExecutor(beanFactory,qualifier)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a target executor for the given qualifier.\n\t * @param qualifier the qualifier to resolve\n\t * @return the target executor, or {@code null} if none available\n\t * @since 4.2.6\n\t * @see #getExecutorQualifier(Method)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactory",
      "qualifier"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "Executor",
    "signature": "protected Executor findQualifiedExecutor(@Nullable BeanFactory beanFactory, String qualifier)",
    "source_code": "\tprotected Executor findQualifiedExecutor(@Nullable BeanFactory beanFactory, String qualifier) {\n\t\tif (beanFactory == null) {\n\t\t\tthrow new IllegalStateException(\"BeanFactory must be set on \" + getClass().getSimpleName() +\n\t\t\t\t\t\" to access qualified executor '\" + qualifier + \"'\");\n\t\t}\n\t\treturn BeanFactoryAnnotationUtils.qualifiedBeanOfType(beanFactory, Executor.class, qualifier);\n\t}"
  },
  "org.springframework.aop.interceptor.<unknown>#handleError(ex,method,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handles a fatal error thrown while asynchronously invoking the specified\n\t * {@link Method}.\n\t * <p>If the return type of the method is a {@link Future} object, the original\n\t * exception can be propagated by just throwing it at the higher level. However,\n\t * for all other cases, the exception will not be transmitted back to the client.\n\t * In that later case, the current {@link AsyncUncaughtExceptionHandler} will be\n\t * used to manage such exception.\n\t * @param ex the exception to handle\n\t * @param method the method that was invoked\n\t * @param params the parameters used to invoke the method\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "method",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "void",
    "signature": "protected void handleError(Throwable ex, Method method, Object... params)",
    "source_code": "\tprotected void handleError(Throwable ex, Method method, Object... params) throws Exception {\n\t\tif (Future.class.isAssignableFrom(method.getReturnType())) {\n\t\t\tReflectionUtils.rethrowException(ex);\n\t\t}\n\t\telse {\n\t\t\t// Could not transmit the exception to the caller with default executor\n\t\t\ttry {\n\t\t\t\tthis.exceptionHandler.obtain().handleUncaughtException(ex, method, params);\n\t\t\t}\n\t\t\tcatch (Throwable ex2) {\n\t\t\t\tlogger.warn(\"Exception handler for async method '\" + method.toGenericString() +\n\t\t\t\t\t\t\"' threw unexpected exception itself\", ex2);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.aop.scope.<unknown>#createScopedProxy(definition,registry,proxyTargetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a scoped proxy for the supplied target bean, registering the target\n\t * bean with an internal name and setting 'targetBeanName' on the scoped proxy.\n\t * @param definition the original bean definition\n\t * @param registry the bean definition registry\n\t * @param proxyTargetClass whether to create a target class proxy\n\t * @return the scoped proxy definition\n\t * @see #getTargetBeanName(String)\n\t * @see #getOriginalBeanName(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "definition",
      "registry",
      "proxyTargetClass"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder createScopedProxy(BeanDefinitionHolder definition,\n\t\t\tBeanDefinitionRegistry registry, boolean proxyTargetClass)",
    "source_code": "\tpublic static BeanDefinitionHolder createScopedProxy(BeanDefinitionHolder definition,\n\t\t\tBeanDefinitionRegistry registry, boolean proxyTargetClass) {\n\n\t\tString originalBeanName = definition.getBeanName();\n\t\tBeanDefinition targetDefinition = definition.getBeanDefinition();\n\t\tString targetBeanName = getTargetBeanName(originalBeanName);\n\n\t\t// Create a scoped proxy definition for the original bean name,\n\t\t// \"hiding\" the target bean in an internal target definition.\n\t\tRootBeanDefinition proxyDefinition = new RootBeanDefinition(ScopedProxyFactoryBean.class);\n\t\tproxyDefinition.setDecoratedDefinition(new BeanDefinitionHolder(targetDefinition, targetBeanName));\n\t\tproxyDefinition.setOriginatingBeanDefinition(targetDefinition);\n\t\tproxyDefinition.setSource(definition.getSource());\n\t\tproxyDefinition.setRole(targetDefinition.getRole());\n\n\t\tproxyDefinition.getPropertyValues().add(\"targetBeanName\", targetBeanName);\n\t\tif (proxyTargetClass) {\n\t\t\ttargetDefinition.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n\t\t\t// ScopedProxyFactoryBean's \"proxyTargetClass\" default is TRUE, so we don't need to set it explicitly here.\n\t\t}\n\t\telse {\n\t\t\tproxyDefinition.getPropertyValues().add(\"proxyTargetClass\", Boolean.FALSE);\n\t\t}\n\n\t\t// Copy autowire settings from original bean definition.\n\t\tproxyDefinition.setAutowireCandidate(targetDefinition.isAutowireCandidate());\n\t\tproxyDefinition.setPrimary(targetDefinition.isPrimary());\n\t\tif (targetDefinition instanceof AbstractBeanDefinition abd) {\n\t\t\tproxyDefinition.copyQualifiersFrom(abd);\n\t\t}\n\n\t\t// The target bean should be ignored in favor of the scoped proxy.\n\t\ttargetDefinition.setAutowireCandidate(false);\n\t\ttargetDefinition.setPrimary(false);\n\n\t\t// Register the target bean as separate bean in the factory.\n\t\tregistry.registerBeanDefinition(targetBeanName, targetDefinition);\n\n\t\t// Return the scoped proxy definition as primary bean definition\n\t\t// (potentially an inner bean).\n\t\treturn new BeanDefinitionHolder(proxyDefinition, originalBeanName, definition.getAliases());\n\t}"
  },
  "org.springframework.aop.scope.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,constructorOrFactoryMethod,allowDirectSupplierShortcut)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "constructorOrFactoryMethod",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\t\tExecutable constructorOrFactoryMethod,\n\t\t\t\tboolean allowDirectSupplierShortcut)",
    "source_code": "\t\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\t\tExecutable constructorOrFactoryMethod,\n\t\t\t\tboolean allowDirectSupplierShortcut) {\n\n\t\t\tGeneratedMethod generatedMethod = beanRegistrationCode.getMethods()\n\t\t\t\t\t.add(\"getScopedProxyInstance\", method -> {\n\t\t\t\t\t\tmethod.addJavadoc(\n\t\t\t\t\t\t\t\t\"Create the scoped proxy bean instance for '$L'.\",\n\t\t\t\t\t\t\t\tthis.registeredBean.getBeanName());\n\t\t\t\t\t\tmethod.addModifiers(Modifier.PRIVATE, Modifier.STATIC);\n\t\t\t\t\t\tmethod.returns(ScopedProxyFactoryBean.class);\n\t\t\t\t\t\tmethod.addParameter(RegisteredBean.class,\n\t\t\t\t\t\t\t\tREGISTERED_BEAN_PARAMETER_NAME);\n\t\t\t\t\t\tmethod.addStatement(\"$T factory = new $T()\",\n\t\t\t\t\t\t\t\tScopedProxyFactoryBean.class,\n\t\t\t\t\t\t\t\tScopedProxyFactoryBean.class);\n\t\t\t\t\t\tmethod.addStatement(\"factory.setTargetBeanName($S)\",\n\t\t\t\t\t\t\t\tthis.targetBeanName);\n\t\t\t\t\t\tmethod.addStatement(\n\t\t\t\t\t\t\t\t\"factory.setBeanFactory($L.getBeanFactory())\",\n\t\t\t\t\t\t\t\tREGISTERED_BEAN_PARAMETER_NAME);\n\t\t\t\t\t\tmethod.addStatement(\"return factory\");\n\t\t\t\t\t});\n\t\t\treturn CodeBlock.of(\"$T.of($L)\", InstanceSupplier.class,\n\t\t\t\t\tgeneratedMethod.toMethodReference().toCodeBlock());\n\t\t}"
  },
  "org.springframework.aop.scope.<unknown>#generateNewBeanDefinitionCode(generationContext,beanType,beanRegistrationCode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanType",
      "beanRegistrationCode"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateNewBeanDefinitionCode(GenerationContext generationContext,\n\t\t\t\tResolvableType beanType, BeanRegistrationCode beanRegistrationCode)",
    "source_code": "\t\tpublic CodeBlock generateNewBeanDefinitionCode(GenerationContext generationContext,\n\t\t\t\tResolvableType beanType, BeanRegistrationCode beanRegistrationCode) {\n\n\t\t\treturn super.generateNewBeanDefinitionCode(generationContext,\n\t\t\t\t\tthis.targetBeanDefinition.getResolvableType(), beanRegistrationCode);\n\t\t}"
  },
  "org.springframework.aop.scope.<unknown>#generateSetBeanDefinitionPropertiesCode(generationContext,beanRegistrationCode,beanDefinition,attributeFilter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "beanDefinition",
      "attributeFilter"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateSetBeanDefinitionPropertiesCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\t\tRootBeanDefinition beanDefinition, Predicate<String> attributeFilter)",
    "source_code": "\t\tpublic CodeBlock generateSetBeanDefinitionPropertiesCode(\n\t\t\t\tGenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\t\tRootBeanDefinition beanDefinition, Predicate<String> attributeFilter) {\n\n\t\t\tRootBeanDefinition processedBeanDefinition = new RootBeanDefinition(\n\t\t\t\t\tbeanDefinition);\n\t\t\tprocessedBeanDefinition\n\t\t\t\t\t.setTargetType(this.targetBeanDefinition.getResolvableType());\n\t\t\tprocessedBeanDefinition.getPropertyValues()\n\t\t\t\t\t.removePropertyValue(\"targetBeanName\");\n\t\t\treturn super.generateSetBeanDefinitionPropertiesCode(generationContext,\n\t\t\t\t\tbeanRegistrationCode, processedBeanDefinition, attributeFilter);\n\t\t}"
  },
  "org.springframework.aop.scope.<unknown>#getTarget(registeredBean,constructorOrFactoryMethod)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "constructorOrFactoryMethod"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "ClassName",
    "signature": "public ClassName getTarget(RegisteredBean registeredBean, Executable constructorOrFactoryMethod)",
    "source_code": "\t\tpublic ClassName getTarget(RegisteredBean registeredBean, Executable constructorOrFactoryMethod) {\n\t\t\treturn ClassName.get(this.targetBeanDefinition.getResolvableType().toClass());\n\t\t}"
  },
  "org.springframework.aop.support.<unknown>#canApply(advisor,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Can the given advisor apply at all on the given class?\n\t * This is an important test as it can be used to optimize\n\t * out an advisor for a class.\n\t * @param advisor the advisor to check\n\t * @param targetClass class we're testing\n\t * @return whether the pointcut can apply on any method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "advisor",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "boolean",
    "signature": "public boolean canApply(Advisor advisor, Class<?> targetClass)",
    "source_code": "\tpublic static boolean canApply(Advisor advisor, Class<?> targetClass) {\n\t\treturn canApply(advisor, targetClass, false);\n\t}"
  },
  "org.springframework.aop.support.<unknown>#canApply(advisor,targetClass,hasIntroductions)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Can the given advisor apply at all on the given class?\n\t * <p>This is an important test as it can be used to optimize out an advisor for a class.\n\t * This version also takes into account introductions (for IntroductionAwareMethodMatchers).\n\t * @param advisor the advisor to check\n\t * @param targetClass class we're testing\n\t * @param hasIntroductions whether the advisor chain for this bean includes\n\t * any introductions\n\t * @return whether the pointcut can apply on any method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "advisor",
      "targetClass",
      "hasIntroductions"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "boolean",
    "signature": "public boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions)",
    "source_code": "\tpublic static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {\n\t\tif (advisor instanceof IntroductionAdvisor ia) {\n\t\t\treturn ia.getClassFilter().matches(targetClass);\n\t\t}\n\t\telse if (advisor instanceof PointcutAdvisor pca) {\n\t\t\treturn canApply(pca.getPointcut(), targetClass, hasIntroductions);\n\t\t}\n\t\telse {\n\t\t\t// It doesn't have a pointcut so we assume it applies.\n\t\t\treturn true;\n\t\t}\n\t}"
  },
  "org.springframework.aop.support.<unknown>#canApply(pc,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Can the given pointcut apply at all on the given class?\n\t * <p>This is an important test as it can be used to optimize\n\t * out a pointcut for a class.\n\t * @param pc the static or dynamic pointcut to check\n\t * @param targetClass the class to test\n\t * @return whether the pointcut can apply on any method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pc",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "boolean",
    "signature": "public boolean canApply(Pointcut pc, Class<?> targetClass)",
    "source_code": "\tpublic static boolean canApply(Pointcut pc, Class<?> targetClass) {\n\t\treturn canApply(pc, targetClass, false);\n\t}"
  },
  "org.springframework.aop.support.<unknown>#canApply(pc,targetClass,hasIntroductions)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Can the given pointcut apply at all on the given class?\n\t * <p>This is an important test as it can be used to optimize\n\t * out a pointcut for a class.\n\t * @param pc the static or dynamic pointcut to check\n\t * @param targetClass the class to test\n\t * @param hasIntroductions whether the advisor chain\n\t * for this bean includes any introductions\n\t * @return whether the pointcut can apply on any method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pc",
      "targetClass",
      "hasIntroductions"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "boolean",
    "signature": "public boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions)",
    "source_code": "\tpublic static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {\n\t\tAssert.notNull(pc, \"Pointcut must not be null\");\n\t\tif (!pc.getClassFilter().matches(targetClass)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tMethodMatcher methodMatcher = pc.getMethodMatcher();\n\t\tif (methodMatcher == MethodMatcher.TRUE) {\n\t\t\t// No need to iterate the methods if we're matching any method anyway...\n\t\t\treturn true;\n\t\t}\n\n\t\tIntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;\n\t\tif (methodMatcher instanceof IntroductionAwareMethodMatcher iamm) {\n\t\t\tintroductionAwareMethodMatcher = iamm;\n\t\t}\n\n\t\tSet<Class<?>> classes = new LinkedHashSet<>();\n\t\tif (!Proxy.isProxyClass(targetClass)) {\n\t\t\tclasses.add(ClassUtils.getUserClass(targetClass));\n\t\t}\n\t\tclasses.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));\n\n\t\tfor (Class<?> clazz : classes) {\n\t\t\tMethod[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);\n\t\t\tfor (Method method : methods) {\n\t\t\t\tif (introductionAwareMethodMatcher != null ?\n\t\t\t\t\t\tintroductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :\n\t\t\t\t\t\tmethodMatcher.matches(method, targetClass)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}"
  },
  "org.springframework.aop.support.<unknown>#findAdvisorsThatCanApply(candidateAdvisors,clazz)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the sublist of the {@code candidateAdvisors} list\n\t * that is applicable to the given class.\n\t * @param candidateAdvisors the Advisors to evaluate\n\t * @param clazz the target class\n\t * @return sublist of Advisors that can apply to an object of the given class\n\t * (may be the incoming List as-is)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "candidateAdvisors",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "List<Advisor>",
    "signature": "public List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz)",
    "source_code": "\tpublic static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {\n\t\tif (candidateAdvisors.isEmpty()) {\n\t\t\treturn candidateAdvisors;\n\t\t}\n\t\tList<Advisor> eligibleAdvisors = new ArrayList<>();\n\t\tfor (Advisor candidate : candidateAdvisors) {\n\t\t\tif (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {\n\t\t\t\teligibleAdvisors.add(candidate);\n\t\t\t}\n\t\t}\n\t\tboolean hasIntroductions = !eligibleAdvisors.isEmpty();\n\t\tfor (Advisor candidate : candidateAdvisors) {\n\t\t\tif (candidate instanceof IntroductionAdvisor) {\n\t\t\t\t// already processed\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (canApply(candidate, clazz, hasIntroductions)) {\n\t\t\t\teligibleAdvisors.add(candidate);\n\t\t\t}\n\t\t}\n\t\treturn eligibleAdvisors;\n\t}"
  },
  "org.springframework.aop.support.<unknown>#getMostSpecificMethod(method,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Given a method, which may come from an interface, and a target class used\n\t * in the current AOP invocation, find the corresponding target method if there\n\t * is one. E.g. the method may be {@code IFoo.bar()} and the target class\n\t * may be {@code DefaultFoo}. In this case, the method may be\n\t * {@code DefaultFoo.bar()}. This enables attributes on that method to be found.\n\t * <p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},\n\t * this method resolves bridge methods in order to retrieve attributes from\n\t * the <i>original</i> method definition.\n\t * @param method the method to be invoked, which may come from an interface\n\t * @param targetClass the target class for the current invocation.\n\t * May be {@code null} or may not even implement the method.\n\t * @return the specific target method, or the original method if the\n\t * {@code targetClass} doesn't implement it or is {@code null}\n\t * @see org.springframework.util.ClassUtils#getMostSpecificMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "Method",
    "signature": "public Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {\n\t\tClass<?> specificTargetClass = (targetClass != null ? ClassUtils.getUserClass(targetClass) : null);\n\t\tMethod resolvedMethod = ClassUtils.getMostSpecificMethod(method, specificTargetClass);\n\t\t// If we are dealing with method with generic parameters, find the original method.\n\t\treturn BridgeMethodResolver.findBridgedMethod(resolvedMethod);\n\t}"
  },
  "org.springframework.aop.support.<unknown>#intersection(cf1,cf2)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Match all classes that <i>both</i> of the given ClassFilters match.\n\t * @param cf1 the first ClassFilter\n\t * @param cf2 the second ClassFilter\n\t * @return a distinct ClassFilter that matches all classes that both\n\t * of the given ClassFilter match\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cf1",
      "cf2"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "ClassFilter",
    "signature": "public ClassFilter intersection(ClassFilter cf1, ClassFilter cf2)",
    "source_code": "\tpublic static ClassFilter intersection(ClassFilter cf1, ClassFilter cf2) {\n\t\tAssert.notNull(cf1, \"First ClassFilter must not be null\");\n\t\tAssert.notNull(cf2, \"Second ClassFilter must not be null\");\n\t\treturn new IntersectionClassFilter(new ClassFilter[] {cf1, cf2});\n\t}"
  },
  "org.springframework.aop.support.<unknown>#intersection(mm1,mm2)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Match all methods that <i>both</i> of the given MethodMatchers match.\n\t * @param mm1 the first MethodMatcher\n\t * @param mm2 the second MethodMatcher\n\t * @return a distinct MethodMatcher that matches all methods that both\n\t * of the given MethodMatchers match\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mm1",
      "mm2"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "MethodMatcher",
    "signature": "public MethodMatcher intersection(MethodMatcher mm1, MethodMatcher mm2)",
    "source_code": "\tpublic static MethodMatcher intersection(MethodMatcher mm1, MethodMatcher mm2) {\n\t\treturn (mm1 instanceof IntroductionAwareMethodMatcher || mm2 instanceof IntroductionAwareMethodMatcher ?\n\t\t\t\tnew IntersectionIntroductionAwareMethodMatcher(mm1, mm2) : new IntersectionMethodMatcher(mm1, mm2));\n\t}"
  },
  "org.springframework.aop.support.<unknown>#invokeJoinpointUsingReflection(target,method,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given target via reflection, as part of an AOP method invocation.\n\t * @param target the target object\n\t * @param method the method to invoke\n\t * @param args the arguments for the method\n\t * @return the invocation result, if any\n\t * @throws Throwable if thrown by the target method\n\t * @throws org.springframework.aop.AopInvocationException in case of a reflection error\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "Object",
    "signature": "public Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args)",
    "source_code": "\tpublic static Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\n\t\t// Use reflection to invoke the method.\n\t\ttry {\n\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\treturn method.invoke(target, args);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\t// Invoked method threw a checked exception.\n\t\t\t// We must rethrow it. The client won't see the interceptor.\n\t\t\tthrow ex.getTargetException();\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tthrow new AopInvocationException(\"AOP configuration seems to be invalid: tried calling method [\" +\n\t\t\t\t\tmethod + \"] on target [\" + target + \"]\", ex);\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\tthrow new AopInvocationException(\"Could not access method [\" + method + \"]\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.aop.support.<unknown>#isMatch(methodName,mappedName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return if the given method name matches the mapped name.\n\t * <p>The default implementation checks for \"xxx*\", \"*xxx\" and \"*xxx*\" matches,\n\t * as well as direct equality. Can be overridden in subclasses.\n\t * @param methodName the method name of the class\n\t * @param mappedName the name in the descriptor\n\t * @return if the names match\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "mappedName"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "boolean",
    "signature": "protected boolean isMatch(String methodName, String mappedName)",
    "source_code": "\tprotected boolean isMatch(String methodName, String mappedName) {\n\t\treturn PatternMatchUtils.simpleMatch(mappedName, methodName);\n\t}"
  },
  "org.springframework.aop.support.<unknown>#matches(method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\tfor (String mappedName : this.mappedNames) {\n\t\t\tif (mappedName.equals(method.getName()) || isMatch(method.getName(), mappedName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.aop.support.<unknown>#matches(method,targetClass,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass, Object... args)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass, Object... args) {\n\t\tthis.evaluations.incrementAndGet();\n\n\t\tfor (StackTraceElement element : new Throwable().getStackTrace()) {\n\t\t\tif (element.getClassName().equals(this.clazz.getName()) &&\n\t\t\t\t\t(this.methodName == null || element.getMethodName().equals(this.methodName))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.aop.support.<unknown>#matches(method,targetClass,hasIntroductions)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass",
      "hasIntroductions"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass, boolean hasIntroductions)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass, boolean hasIntroductions) {\n\t\t\treturn (MethodMatchers.matches(this.mm1, method, targetClass, hasIntroductions) &&\n\t\t\t\t\tMethodMatchers.matches(this.mm2, method, targetClass, hasIntroductions));\n\t\t}"
  },
  "org.springframework.aop.support.<unknown>#matches(mm,method,targetClass,hasIntroductions)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given MethodMatcher to the given Method, supporting an\n\t * {@link org.springframework.aop.IntroductionAwareMethodMatcher}\n\t * (if applicable).\n\t * @param mm the MethodMatcher to apply (may be an IntroductionAwareMethodMatcher)\n\t * @param method the candidate method\n\t * @param targetClass the target class\n\t * @param hasIntroductions {@code true} if the object on whose behalf we are\n\t * asking is the subject on one or more introductions; {@code false} otherwise\n\t * @return whether this method matches statically\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mm",
      "method",
      "targetClass",
      "hasIntroductions"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "boolean",
    "signature": "public boolean matches(MethodMatcher mm, Method method, Class<?> targetClass, boolean hasIntroductions)",
    "source_code": "\tpublic static boolean matches(MethodMatcher mm, Method method, Class<?> targetClass, boolean hasIntroductions) {\n\t\tAssert.notNull(mm, \"MethodMatcher must not be null\");\n\t\treturn (mm instanceof IntroductionAwareMethodMatcher iamm ?\n\t\t\t\tiamm.matches(method, targetClass, hasIntroductions) :\n\t\t\t\tmm.matches(method, targetClass));\n\t}"
  },
  "org.springframework.aop.support.<unknown>#matches(pattern,patternIndex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Does the pattern at the given index match the given String?\n\t * @param pattern the {@code String} pattern to match\n\t * @param patternIndex index of pattern (starting from 0)\n\t * @return {@code true} if there is a match, {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "pattern",
      "patternIndex"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "boolean",
    "signature": "protected boolean matches(String pattern, int patternIndex)",
    "source_code": "\tprotected abstract boolean matches(String pattern, int patternIndex);"
  },
  "org.springframework.aop.support.<unknown>#matchesExclusion(pattern,patternIndex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Does the exclusion pattern at the given index match the given String?\n\t * @param pattern the {@code String} pattern to match\n\t * @param patternIndex index of pattern (starting from 0)\n\t * @return {@code true} if there is a match, {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "pattern",
      "patternIndex"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "boolean",
    "signature": "protected boolean matchesExclusion(String pattern, int patternIndex)",
    "source_code": "\tprotected abstract boolean matchesExclusion(String pattern, int patternIndex);"
  },
  "org.springframework.aop.support.<unknown>#selectInvocableMethod(method,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Select an invocable method on the target type: either the given method itself\n\t * if actually exposed on the target type, or otherwise a corresponding method\n\t * on one of the target type's interfaces or on the target type itself.\n\t * @param method the method to check\n\t * @param targetType the target type to search methods on (typically an AOP proxy)\n\t * @return a corresponding invocable method on the target type\n\t * @throws IllegalStateException if the given method is not invocable on the given\n\t * target type (typically due to a proxy mismatch)\n\t * @since 4.3\n\t * @see MethodIntrospector#selectInvocableMethod(Method, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "Method",
    "signature": "public Method selectInvocableMethod(Method method, @Nullable Class<?> targetType)",
    "source_code": "\tpublic static Method selectInvocableMethod(Method method, @Nullable Class<?> targetType) {\n\t\tif (targetType == null) {\n\t\t\treturn method;\n\t\t}\n\t\tMethod methodToUse = MethodIntrospector.selectInvocableMethod(method, targetType);\n\t\tif (Modifier.isPrivate(methodToUse.getModifiers()) && !Modifier.isStatic(methodToUse.getModifiers()) &&\n\t\t\t\tSpringProxy.class.isAssignableFrom(targetType)) {\n\t\t\tthrow new IllegalStateException(String.format(\n\t\t\t\t\t\"Need to invoke method '%s' found on proxy for target class '%s' but cannot \" +\n\t\t\t\t\t\"be delegated to target bean. Switch its visibility to package or protected.\",\n\t\t\t\t\tmethod.getName(), method.getDeclaringClass().getSimpleName()));\n\t\t}\n\t\treturn methodToUse;\n\t}"
  },
  "org.springframework.aop.support.<unknown>#union(cf1,cf2)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Match all classes that <i>either</i> (or both) of the given ClassFilters matches.\n\t * @param cf1 the first ClassFilter\n\t * @param cf2 the second ClassFilter\n\t * @return a distinct ClassFilter that matches all classes that either\n\t * of the given ClassFilter matches\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cf1",
      "cf2"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "ClassFilter",
    "signature": "public ClassFilter union(ClassFilter cf1, ClassFilter cf2)",
    "source_code": "\tpublic static ClassFilter union(ClassFilter cf1, ClassFilter cf2) {\n\t\tAssert.notNull(cf1, \"First ClassFilter must not be null\");\n\t\tAssert.notNull(cf2, \"Second ClassFilter must not be null\");\n\t\treturn new UnionClassFilter(new ClassFilter[] {cf1, cf2});\n\t}"
  },
  "org.springframework.aop.support.<unknown>#union(mm1,mm2)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Match all methods that <i>either</i> (or both) of the given MethodMatchers matches.\n\t * @param mm1 the first MethodMatcher\n\t * @param mm2 the second MethodMatcher\n\t * @return a distinct MethodMatcher that matches all methods that either\n\t * of the given MethodMatchers matches\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mm1",
      "mm2"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "MethodMatcher",
    "signature": "public MethodMatcher union(MethodMatcher mm1, MethodMatcher mm2)",
    "source_code": "\tpublic static MethodMatcher union(MethodMatcher mm1, MethodMatcher mm2) {\n\t\treturn (mm1 instanceof IntroductionAwareMethodMatcher || mm2 instanceof IntroductionAwareMethodMatcher ?\n\t\t\t\tnew UnionIntroductionAwareMethodMatcher(mm1, mm2) : new UnionMethodMatcher(mm1, mm2));\n\t}"
  },
  "org.springframework.aop.support.annotation.<unknown>#matches(method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\tif (matchesMethod(method)) {\n\t\t\treturn true;\n\t\t}\n\t\t// Proxy classes never have annotations on their redeclared methods.\n\t\tif (Proxy.isProxyClass(targetClass)) {\n\t\t\treturn false;\n\t\t}\n\t\t// The method may be on an interface, so let's check on the target class as well.\n\t\tMethod specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);\n\t\treturn (specificMethod != method && matchesMethod(specificMethod));\n\t}"
  },
  "org.springframework.aop.target.<unknown>#forClass(targetClass,isStatic)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return an EmptyTargetSource for the given target Class.\n\t * @param targetClass the target Class (may be {@code null})\n\t * @param isStatic whether the TargetSource should be marked as static\n\t * @see #getTargetClass()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetClass",
      "isStatic"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "EmptyTargetSource",
    "signature": "public EmptyTargetSource forClass(@Nullable Class<?> targetClass, boolean isStatic)",
    "source_code": "\tpublic static EmptyTargetSource forClass(@Nullable Class<?> targetClass, boolean isStatic) {\n\t\treturn (targetClass == null && isStatic ? INSTANCE : new EmptyTargetSource(targetClass, isStatic));\n\t}"
  },
  "org.springframework.aot.agent.<unknown>#transform(classLoader,className,classBeingRedefined,protectionDomain,classfileBuffer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader",
      "className",
      "classBeingRedefined",
      "protectionDomain",
      "classfileBuffer"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "byte[]",
    "signature": "public byte[] transform(@Nullable ClassLoader classLoader, String className, Class<?> classBeingRedefined,\n\t\t\tProtectionDomain protectionDomain, byte[] classfileBuffer)",
    "source_code": "\tpublic byte[] transform(@Nullable ClassLoader classLoader, String className, Class<?> classBeingRedefined,\n\t\t\tProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n\n\t\tif (isTransformationCandidate(classLoader, className)) {\n\t\t\treturn attemptClassTransformation(classfileBuffer);\n\t\t}\n\t\treturn classfileBuffer;\n\t}"
  },
  "org.springframework.aot.agent.<unknown>#visitInvokeDynamicInsn(name,descriptor,bootstrapMethodHandle,bootstrapMethodArguments)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "descriptor",
      "bootstrapMethodHandle",
      "bootstrapMethodArguments"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void visitInvokeDynamicInsn(String name, String descriptor, Handle bootstrapMethodHandle, Object... bootstrapMethodArguments)",
    "source_code": "\t\tpublic void visitInvokeDynamicInsn(String name, String descriptor, Handle bootstrapMethodHandle, Object... bootstrapMethodArguments) {\n\t\t\tfor (int i = 0; i < bootstrapMethodArguments.length; i++) {\n\t\t\t\tif (bootstrapMethodArguments[i] instanceof Handle argumentHandle) {\n\t\t\t\t\tif (shouldRecordMethodCall(argumentHandle.getOwner(), argumentHandle.getName())) {\n\t\t\t\t\t\tString instrumentedMethodName = rewriteMethodName(argumentHandle.getOwner(), argumentHandle.getName());\n\t\t\t\t\t\tString newDescriptor = rewriteDescriptor(argumentHandle.getTag(), argumentHandle.getOwner(), argumentHandle.getName(), argumentHandle.getDesc());\n\t\t\t\t\t\tbootstrapMethodArguments[i] = new Handle(H_INVOKESTATIC, INSTRUMENTED_CLASS, instrumentedMethodName, newDescriptor, false);\n\t\t\t\t\t\tisTransformed = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsuper.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);\n\t\t}"
  },
  "org.springframework.aot.agent.<unknown>#visitMethod(access,name,descriptor,signature,exceptions)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "access",
      "name",
      "descriptor",
      "signature",
      "exceptions"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "MethodVisitor",
    "signature": "public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions)",
    "source_code": "\tpublic MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n\t\tMethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);\n\t\treturn new InvocationsRecorderMethodVisitor(mv);\n\t}"
  },
  "org.springframework.aot.agent.<unknown>#visitMethodInsn(opcode,owner,name,descriptor,isInterface)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "opcode",
      "owner",
      "name",
      "descriptor",
      "isInterface"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface)",
    "source_code": "\t\tpublic void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {\n\t\t\tif (isOpcodeSupported(opcode) && shouldRecordMethodCall(owner, name)) {\n\t\t\t\tString instrumentedMethodName = rewriteMethodName(owner, name);\n\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, INSTRUMENTED_CLASS, instrumentedMethodName,\n\t\t\t\t\t\trewriteDescriptor(opcode, owner, name, descriptor), false);\n\t\t\t\tisTransformed = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsuper.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.aot.generate.<unknown>#addArguments(code,argumentCodeGenerator)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the code for the method arguments using the specified\n\t * {@link ArgumentCodeGenerator} if necessary.\n\t * @param code the code builder to use to add method arguments\n\t * @param argumentCodeGenerator the code generator to use\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "argumentCodeGenerator"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "protected void addArguments(CodeBlock.Builder code, ArgumentCodeGenerator argumentCodeGenerator)",
    "source_code": "\tprotected void addArguments(CodeBlock.Builder code, ArgumentCodeGenerator argumentCodeGenerator) {\n\t\tList<CodeBlock> arguments = new ArrayList<>();\n\t\tTypeName[] argumentTypes = this.method.parameters.stream()\n\t\t\t\t.map(parameter -> parameter.type).toArray(TypeName[]::new);\n\t\tfor (int i = 0; i < argumentTypes.length; i++) {\n\t\t\tTypeName argumentType = argumentTypes[i];\n\t\t\tCodeBlock argumentCode = argumentCodeGenerator.generateCode(argumentType);\n\t\t\tif (argumentCode == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Could not generate code for \" + this\n\t\t\t\t\t\t+ \": parameter \" + i + \" of type \" + argumentType + \" is not supported\");\n\t\t\t}\n\t\t\targuments.add(argumentCode);\n\t\t}\n\t\tcode.add(CodeBlock.join(arguments, \", \"));\n\t}"
  },
  "org.springframework.aot.generate.<unknown>#addFile(kind,path,content)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "kind",
      "path",
      "content"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void addFile(Kind kind, String path, InputStreamSource content)",
    "source_code": "\tpublic void addFile(Kind kind, String path, InputStreamSource content) {\n\t\tAssert.notNull(kind, \"'kind' must not be null\");\n\t\tAssert.hasLength(path, \"'path' must not be empty\");\n\t\tAssert.notNull(content, \"'content' must not be null\");\n\t\tPath root = this.roots.apply(kind).toAbsolutePath().normalize();\n\t\tPath relativePath = root.resolve(path).toAbsolutePath().normalize();\n\t\tAssert.isTrue(relativePath.startsWith(root), \"'path' must be relative\");\n\t\ttry {\n\t\t\ttry (InputStream inputStream = content.getInputStream()) {\n\t\t\t\tFiles.createDirectories(relativePath.getParent());\n\t\t\t\tFiles.copy(inputStream, relativePath);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.aot.generate.<unknown>#toInvokeCodeBlock(argumentCodeGenerator,targetClassName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argumentCodeGenerator",
      "targetClassName"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock toInvokeCodeBlock(ArgumentCodeGenerator argumentCodeGenerator,\n\t\t\t@Nullable ClassName targetClassName)",
    "source_code": "\tpublic CodeBlock toInvokeCodeBlock(ArgumentCodeGenerator argumentCodeGenerator,\n\t\t\t@Nullable ClassName targetClassName) {\n\t\tString methodName = this.method.name;\n\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\tif (isStatic()) {\n\t\t\tAssert.state(this.declaringClass != null, \"static method reference must define a declaring class\");\n\t\t\tif (isSameDeclaringClass(targetClassName)) {\n\t\t\t\tcode.add(\"$L\", methodName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcode.add(\"$T.$L\", this.declaringClass, methodName);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!isSameDeclaringClass(targetClassName)) {\n\t\t\t\tcode.add(instantiateDeclaringClass(this.declaringClass));\n\t\t\t}\n\t\t\tcode.add(\"$L\", methodName);\n\t\t}\n\t\tcode.add(\"(\");\n\t\taddArguments(code, argumentCodeGenerator);\n\t\tcode.add(\")\");\n\t\treturn code.build();\n\t}"
  },
  "org.springframework.aot.hint.<unknown>#registerComponentHints(hints,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "void",
    "signature": "public void registerComponentHints(ReflectionHints hints, Class<?> type)",
    "source_code": "\t\tpublic static void registerComponentHints(ReflectionHints hints, Class<?> type) {\n\t\t\tKClass<?> kClass = JvmClassMappingKt.getKotlinClass(type);\n\t\t\tif (kClass.isData()) {\n\t\t\t\tfor (Method method : type.getMethods()) {\n\t\t\t\t\tString methodName = method.getName();\n\t\t\t\t\tif (methodName.startsWith(\"component\") || methodName.equals(\"copy\") || methodName.equals(\"copy$default\")) {\n\t\t\t\t\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.aot.hint.<unknown>#registerPatternIfPresent(classLoader,location,resourceHint)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a pattern if the given {@code location} is available on the\n\t * classpath. This delegates to {@link ClassLoader#getResource(String)}\n\t * which validates directories as well. The location is not included in\n\t * the hint.\n\t * @param classLoader the classloader to use\n\t * @param location a '/'-separated path name that should exist\n\t * @param resourceHint a builder to customize the resource pattern\n\t * @return {@code this}, to facilitate method chaining\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader",
      "location",
      "resourceHint"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "ResourceHints",
    "signature": "public ResourceHints registerPatternIfPresent(@Nullable ClassLoader classLoader, String location,\n\t\t\tConsumer<ResourcePatternHints.Builder> resourceHint)",
    "source_code": "\tpublic ResourceHints registerPatternIfPresent(@Nullable ClassLoader classLoader, String location,\n\t\t\tConsumer<ResourcePatternHints.Builder> resourceHint) {\n\t\tClassLoader classLoaderToUse = (classLoader != null) ? classLoader : getClass().getClassLoader();\n\t\tif (classLoaderToUse.getResource(location) != null) {\n\t\t\tregisterPattern(resourceHint);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.aot.hint.<unknown>#registerReflectionHints(hints,types)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the necessary reflection hints to bind the specified types.\n\t * @param hints the hints instance to use\n\t * @param types the types to register\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "types"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void registerReflectionHints(ReflectionHints hints, Type... types)",
    "source_code": "\tpublic void registerReflectionHints(ReflectionHints hints, Type... types) {\n\t\tSet<Type> seen = new LinkedHashSet<>();\n\t\tfor (Type type : types) {\n\t\t\tregisterReflectionHints(hints, seen, type);\n\t\t}\n\t}"
  },
  "org.springframework.aot.hint.<unknown>#registerResourceBundle(baseName,resourceHint)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register that the resource bundle with the specified base name should\n\t * be made available at runtime.\n\t * @param baseName the base name of the resource bundle\n\t * @param resourceHint a builder to further customize the resource bundle\n\t * @return {@code this}, to facilitate method chaining\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "baseName",
      "resourceHint"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "ResourceHints",
    "signature": "public ResourceHints registerResourceBundle(String baseName, @Nullable Consumer<ResourceBundleHint.Builder> resourceHint)",
    "source_code": "\tpublic ResourceHints registerResourceBundle(String baseName, @Nullable Consumer<ResourceBundleHint.Builder> resourceHint) {\n\t\tResourceBundleHint.Builder builder = new ResourceBundleHint.Builder(baseName);\n\t\tif (resourceHint != null) {\n\t\t\tresourceHint.accept(builder);\n\t\t}\n\t\tthis.resourceBundleHints.add(builder.build());\n\t\treturn this;\n\t}"
  },
  "org.springframework.aot.hint.annotation.<unknown>#registerConstructorHint(hints,constructor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register {@link ReflectionHints} against the specified {@link Constructor}.\n\t * @param hints the reflection hints instance to use\n\t * @param constructor the constructor to process\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "constructor"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "protected void registerConstructorHint(ReflectionHints hints, Constructor<?> constructor)",
    "source_code": "\tprotected void registerConstructorHint(ReflectionHints hints, Constructor<?> constructor) {\n\t\thints.registerConstructor(constructor, ExecutableMode.INVOKE);\n\t}"
  },
  "org.springframework.aot.hint.annotation.<unknown>#registerFieldHint(hints,field)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register {@link ReflectionHints} against the specified {@link Field}.\n\t * @param hints the reflection hints instance to use\n\t * @param field the field to process\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "void",
    "signature": "protected void registerFieldHint(ReflectionHints hints, Field field)",
    "source_code": "\tprotected void registerFieldHint(ReflectionHints hints, Field field) {\n\t\thints.registerField(field);\n\t}"
  },
  "org.springframework.aot.hint.annotation.<unknown>#registerMethodHint(hints,method)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register {@link ReflectionHints} against the specified {@link Method}.\n\t * @param hints the reflection hints instance to use\n\t * @param method the method to process\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "void",
    "signature": "protected void registerMethodHint(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerMethodHint(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t}"
  },
  "org.springframework.aot.hint.annotation.<unknown>#registerReflectionHints(hints,element)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "return": "void",
    "signature": "public void registerReflectionHints(ReflectionHints hints, AnnotatedElement element)",
    "source_code": "\tpublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tif (element instanceof Class<?> type) {\n\t\t\tregisterTypeHint(hints, type);\n\t\t}\n\t\telse if (element instanceof Constructor<?> constructor) {\n\t\t\tregisterConstructorHint(hints, constructor);\n\t\t}\n\t\telse if (element instanceof Field field) {\n\t\t\tregisterFieldHint(hints, field);\n\t\t}\n\t\telse if (element instanceof Method method) {\n\t\t\tregisterMethodHint(hints, method);\n\t\t}\n\t}"
  },
  "org.springframework.aot.hint.annotation.<unknown>#registerTypeHint(hints,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register {@link ReflectionHints} against the specified {@link Class}.\n\t * @param hints the reflection hints instance to use\n\t * @param type the class to process\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "void",
    "signature": "protected void registerTypeHint(ReflectionHints hints, Class<?> type)",
    "source_code": "\tprotected void registerTypeHint(ReflectionHints hints, Class<?> type) {\n\t\thints.registerType(type);\n\t}"
  },
  "org.springframework.aot.hint.predicate.<unknown>#forResource(type,resourceName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a predicate that checks whether a resource hint is registered for the given\n\t * resource name, located in the given type's package.\n\t * <p>For example, {@code forResource(org.example.MyClass, \"myResource.txt\")}\n\t * will match against {@code \"org/example/myResource.txt\"}.\n\t * <p>If the given resource name is an absolute path (i.e., starts with a\n\t * leading slash), the supplied type will be ignored. For example,\n\t * {@code forResource(org.example.MyClass, \"/myResource.txt\")} will match against\n\t * {@code \"myResource.txt\"}.\n\t * @param type the type's package where to look for the resource\n\t * @param resourceName the resource name\n\t * @return the {@link RuntimeHints} predicate\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "resourceName"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "Predicate<RuntimeHints>",
    "signature": "public Predicate<RuntimeHints> forResource(TypeReference type, String resourceName)",
    "source_code": "\tpublic Predicate<RuntimeHints> forResource(TypeReference type, String resourceName) {\n\t\tString absoluteName = resolveAbsoluteResourceName(type, resourceName);\n\t\treturn forResource(absoluteName);\n\t}"
  },
  "org.springframework.aot.hint.support.<unknown>#registerHints(hints,classLoader)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "void",
    "signature": "public void registerHints(ResourceHints hints, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic void registerHints(ResourceHints hints, @Nullable ClassLoader classLoader) {\n\t\tClassLoader classLoaderToUse = (classLoader != null) ? classLoader : getClass().getClassLoader();\n\t\tList<String> includes = new ArrayList<>();\n\t\tfor (String location : this.locations) {\n\t\t\tif (classLoaderToUse.getResource(location) != null) {\n\t\t\t\tfor (String extension : this.extensions) {\n\t\t\t\t\tfor (String name : this.names) {\n\t\t\t\t\t\tincludes.add(location + name + \"*\" + extension);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!includes.isEmpty()) {\n\t\t\thints.registerPattern(hint -> hint.includes(includes.toArray(String[]::new)));\n\t\t}\n\t}"
  },
  "org.springframework.aot.nativex.<unknown>#write(chars,offset,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "chars",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "void",
    "signature": "public void write(char[] chars, int offset, int length)",
    "source_code": "\t\tpublic void write(char[] chars, int offset, int length) {\n\t\t\ttry {\n\t\t\t\tif (this.prependIndent) {\n\t\t\t\t\tthis.out.write(this.currentIndent.toCharArray(), 0, this.currentIndent.length());\n\t\t\t\t\tthis.prependIndent = false;\n\t\t\t\t}\n\t\t\t\tthis.out.write(chars, offset, length);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.aot.nativex.<unknown>#write(writer,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "writer",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "void",
    "signature": "public void write(BasicJsonWriter writer, ReflectionHints hints)",
    "source_code": "\tpublic void write(BasicJsonWriter writer, ReflectionHints hints) {\n\t\twriter.writeArray(hints.typeHints().map(this::toAttributes).toList());\n\t}"
  },
  "org.springframework.aot.nativex.<unknown>#writeObject(Map<String,attributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write an object with the specified attributes. Each attribute is\n\t * written according to its value type:\n\t * <ul>\n\t * <li>Map: write the value as a nested object</li>\n\t * <li>List: write the value as a nested array</li>\n\t * <li>Otherwise, write a single value</li>\n\t * </ul>\n\t * @param attributes the attributes of the object\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void writeObject(Map<String, Object> attributes)",
    "source_code": "\tpublic void writeObject(Map<String, Object> attributes) {\n\t\twriteObject(attributes, true);\n\t}"
  },
  "org.springframework.beans.<unknown>#add(propertyName,propertyValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a PropertyValue object, replacing any existing one for the\n\t * corresponding property or getting merged with it (if applicable).\n\t * @param propertyName name of the property\n\t * @param propertyValue value of the property\n\t * @return this in order to allow for adding multiple property values in a chain\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "propertyValue"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "MutablePropertyValues",
    "signature": "public MutablePropertyValues add(String propertyName, @Nullable Object propertyValue)",
    "source_code": "\tpublic MutablePropertyValues add(String propertyName, @Nullable Object propertyValue) {\n\t\taddPropertyValue(new PropertyValue(propertyName, propertyValue));\n\t\treturn this;\n\t}"
  },
  "org.springframework.beans.<unknown>#addPropertyValue(propertyName,propertyValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Overloaded version of {@code addPropertyValue} that takes\n\t * a property name and a property value.\n\t * <p>Note: we recommend using the more concise and chaining-capable variant\n\t * {@link #add(String, Object)}.\n\t * @param propertyName name of the property\n\t * @param propertyValue value of the property\n\t * @see #addPropertyValue(PropertyValue)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "propertyValue"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "void",
    "signature": "public void addPropertyValue(String propertyName, Object propertyValue)",
    "source_code": "\tpublic void addPropertyValue(String propertyName, Object propertyValue) {\n\t\taddPropertyValue(new PropertyValue(propertyName, propertyValue));\n\t}"
  },
  "org.springframework.beans.<unknown>#addPropertyValues(Map<?,other)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add all property values from the given Map.\n\t * @param other a Map with property values keyed by property name,\n\t * which must be a String\n\t * @return this in order to allow for adding multiple property values in a chain\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "other"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "MutablePropertyValues",
    "signature": "public MutablePropertyValues addPropertyValues(@Nullable Map<?, ?> other)",
    "source_code": "\tpublic MutablePropertyValues addPropertyValues(@Nullable Map<?, ?> other) {\n\t\tif (other != null) {\n\t\t\tother.forEach((attrName, attrValue) -> addPropertyValue(\n\t\t\t\t\tnew PropertyValue(attrName.toString(), attrValue)));\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.beans.<unknown>#compare(desc1,desc2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "desc1",
      "desc2"
    ],
    "position": {
      "column": 1,
      "line": 533
    },
    "return": "int",
    "signature": "public int compare(PropertyDescriptor desc1, PropertyDescriptor desc2)",
    "source_code": "\t\tpublic int compare(PropertyDescriptor desc1, PropertyDescriptor desc2) {\n\t\t\tString left = desc1.getName();\n\t\t\tString right = desc2.getName();\n\t\t\tbyte[] leftBytes = left.getBytes();\n\t\t\tbyte[] rightBytes = right.getBytes();\n\t\t\tfor (int i = 0; i < left.length(); i++) {\n\t\t\t\tif (right.length() == i) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tint result = leftBytes[i] - rightBytes[i];\n\t\t\t\tif (result != 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn left.length() - right.length();\n\t\t}"
  },
  "org.springframework.beans.<unknown>#convertForProperty(propertyName,oldValue,newValue,td)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertyName",
      "oldValue",
      "newValue",
      "td"
    ],
    "position": {
      "column": 1,
      "line": 604
    },
    "return": "Object",
    "signature": "protected Object convertForProperty(String propertyName, @Nullable Object oldValue, @Nullable Object newValue, TypeDescriptor td)",
    "source_code": "\tprotected Object convertForProperty(\n\t\t\tString propertyName, @Nullable Object oldValue, @Nullable Object newValue, TypeDescriptor td)\n\t\t\tthrows TypeMismatchException {\n\n\t\treturn convertIfNecessary(propertyName, oldValue, newValue, td.getType(), td);\n\t}"
  },
  "org.springframework.beans.<unknown>#convertForProperty(value,propertyName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given value for the specified property to the latter's type.\n\t * <p>This method is only intended for optimizations in a BeanFactory.\n\t * Use the {@code convertIfNecessary} methods for programmatic conversion.\n\t * @param value the value to convert\n\t * @param propertyName the target property\n\t * (note that nested or indexed properties are not supported here)\n\t * @return the new value, possibly the result of type conversion\n\t * @throws TypeMismatchException if type conversion failed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "Object",
    "signature": "public Object convertForProperty(@Nullable Object value, String propertyName)",
    "source_code": "\tpublic Object convertForProperty(@Nullable Object value, String propertyName) throws TypeMismatchException {\n\t\tCachedIntrospectionResults cachedIntrospectionResults = getCachedIntrospectionResults();\n\t\tPropertyDescriptor pd = cachedIntrospectionResults.getPropertyDescriptor(propertyName);\n\t\tif (pd == null) {\n\t\t\tthrow new InvalidPropertyException(getRootClass(), getNestedPath() + propertyName,\n\t\t\t\t\t\"No property '\" + propertyName + \"' found\");\n\t\t}\n\t\tTypeDescriptor td = cachedIntrospectionResults.getTypeDescriptor(pd);\n\t\tif (td == null) {\n\t\t\ttd = cachedIntrospectionResults.addTypeDescriptor(pd, new TypeDescriptor(property(pd)));\n\t\t}\n\t\treturn convertForProperty(propertyName, null, value, td);\n\t}"
  },
  "org.springframework.beans.<unknown>#convertIfNecessary(propertyName,oldValue,newValue,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the value to the required type for the specified property.\n\t * @param propertyName name of the property\n\t * @param oldValue the previous value, if available (may be {@code null})\n\t * @param newValue the proposed new value\n\t * @param requiredType the type we must convert to\n\t * (or {@code null} if not known, for example in case of a collection element)\n\t * @return the new value, possibly the result of type conversion\n\t * @throws IllegalArgumentException if type conversion failed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "oldValue",
      "newValue",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue,\n\t\t\tObject newValue, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue,\n\t\t\tObject newValue, @Nullable Class<T> requiredType) throws IllegalArgumentException {\n\n\t\treturn convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType));\n\t}"
  },
  "org.springframework.beans.<unknown>#convertIfNecessary(propertyName,oldValue,newValue,requiredType,typeDescriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the value to the required type (if necessary from a String),\n\t * for the specified property.\n\t * @param propertyName name of the property\n\t * @param oldValue the previous value, if available (may be {@code null})\n\t * @param newValue the proposed new value\n\t * @param requiredType the type we must convert to\n\t * (or {@code null} if not known, for example in case of a collection element)\n\t * @param typeDescriptor the descriptor for the target property or field\n\t * @return the new value, possibly the result of type conversion\n\t * @throws IllegalArgumentException if type conversion failed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "oldValue",
      "newValue",
      "requiredType",
      "typeDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,\n\t\t\t@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,\n\t\t\t@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException conversionAttemptEx = null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n\t\tif (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {\n\t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tconversionAttemptEx = ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tObject convertedValue = newValue;\n\n\t\t// Value not of required type?\n\t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&\n\t\t\t\t\tconvertedValue instanceof String text) {\n\t\t\t\tTypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementTypeDesc != null) {\n\t\t\t\t\tClass<?> elementType = elementTypeDesc.getType();\n\t\t\t\t\tif (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {\n\t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray(text);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor == null) {\n\t\t\t\teditor = findDefaultEditor(requiredType);\n\t\t\t}\n\t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tboolean standardConversion = false;\n\n\t\tif (requiredType != null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue != null) {\n\t\t\t\tif (Object.class == requiredType) {\n\t\t\t\t\treturn (T) convertedValue;\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String text && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray(text);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection<?> coll) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue = convertToTypedCollection(coll, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion = true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map<?, ?> map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue = convertToTypedMap(map, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion = true;\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n\t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n\t\t\t\t\tstandardConversion = true;\n\t\t\t\t}\n\t\t\t\tif (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String text && !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor<T> strCtor = requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue = text.trim();\n\t\t\t\t\tif (requiredType.isEnum() && trimmedValue.isEmpty()) {\n\t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t\tstandardConversion = true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Number num && Number.class.isAssignableFrom(requiredType)) {\n\t\t\t\t\tconvertedValue = NumberUtils.convertNumberToTargetClass(num, (Class<Number>) requiredType);\n\t\t\t\t\tstandardConversion = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// convertedValue == null\n\t\t\t\tif (requiredType == Optional.class) {\n\t\t\t\t\tconvertedValue = Optional.empty();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (conversionAttemptEx != null) {\n\t\t\t\t\t// Original exception from former ConversionService call above...\n\t\t\t\t\tthrow conversionAttemptEx;\n\t\t\t\t}\n\t\t\t\telse if (conversionService != null && typeDescriptor != null) {\n\t\t\t\t\t// ConversionService not tried before, probably custom editor found\n\t\t\t\t\t// but editor couldn't produce the required type...\n\t\t\t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n\t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg = new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type '\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"' to required type '\").append(ClassUtils.getQualifiedName(requiredType)).append('\\'');\n\t\t\t\tif (propertyName != null) {\n\t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append('\\'');\n\t\t\t\t}\n\t\t\t\tif (editor != null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type '\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append('\\'');\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (conversionAttemptEx != null) {\n\t\t\tif (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {\n\t\t\t\tthrow conversionAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}"
  },
  "org.springframework.beans.<unknown>#copyProperties(source,target)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the property values of the given source bean into the target bean.\n\t * <p>Note: The source and target classes do not have to match or even be derived\n\t * from each other, as long as the properties match. Any bean properties that the\n\t * source bean exposes but the target bean does not will silently be ignored.\n\t * <p>This is just a convenience method. For more complex transfer needs,\n\t * consider using a full {@link BeanWrapper}.\n\t * <p>As of Spring Framework 5.3, this method honors generic type information\n\t * when matching properties in the source and target objects.\n\t * <p>The following table provides a non-exhaustive set of examples of source\n\t * and target property types that can be copied as well as source and target\n\t * property types that cannot be copied.\n\t * <table border=\"1\">\n\t * <tr><th>source property type</th><th>target property type</th><th>copy supported</th></tr>\n\t * <tr><td>{@code Integer}</td><td>{@code Integer}</td><td>yes</td></tr>\n\t * <tr><td>{@code Integer}</td><td>{@code Number}</td><td>yes</td></tr>\n\t * <tr><td>{@code List<Integer>}</td><td>{@code List<Integer>}</td><td>yes</td></tr>\n\t * <tr><td>{@code List<?>}</td><td>{@code List<?>}</td><td>yes</td></tr>\n\t * <tr><td>{@code List<Integer>}</td><td>{@code List<?>}</td><td>yes</td></tr>\n\t * <tr><td>{@code List<Integer>}</td><td>{@code List<? extends Number>}</td><td>yes</td></tr>\n\t * <tr><td>{@code String}</td><td>{@code Integer}</td><td>no</td></tr>\n\t * <tr><td>{@code Number}</td><td>{@code Integer}</td><td>no</td></tr>\n\t * <tr><td>{@code List<Integer>}</td><td>{@code List<Long>}</td><td>no</td></tr>\n\t * <tr><td>{@code List<Integer>}</td><td>{@code List<Number>}</td><td>no</td></tr>\n\t * </table>\n\t * @param source the source bean\n\t * @param target the target bean\n\t * @throws BeansException if the copying failed\n\t * @see BeanWrapper\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "target"
    ],
    "position": {
      "column": 1,
      "line": 717
    },
    "return": "void",
    "signature": "public void copyProperties(Object source, Object target)",
    "source_code": "\tpublic static void copyProperties(Object source, Object target) throws BeansException {\n\t\tcopyProperties(source, target, null, (String[]) null);\n\t}"
  },
  "org.springframework.beans.<unknown>#copyProperties(source,target,editable)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the property values of the given source bean into the given target bean,\n\t * only setting properties defined in the given \"editable\" class (or interface).\n\t * <p>Note: The source and target classes do not have to match or even be derived\n\t * from each other, as long as the properties match. Any bean properties that the\n\t * source bean exposes but the target bean does not will silently be ignored.\n\t * <p>This is just a convenience method. For more complex transfer needs,\n\t * consider using a full {@link BeanWrapper}.\n\t * <p>As of Spring Framework 5.3, this method honors generic type information\n\t * when matching properties in the source and target objects. See the\n\t * documentation for {@link #copyProperties(Object, Object)} for details.\n\t * @param source the source bean\n\t * @param target the target bean\n\t * @param editable the class (or interface) to restrict property setting to\n\t * @throws BeansException if the copying failed\n\t * @see BeanWrapper\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "target",
      "editable"
    ],
    "position": {
      "column": 1,
      "line": 738
    },
    "return": "void",
    "signature": "public void copyProperties(Object source, Object target, Class<?> editable)",
    "source_code": "\tpublic static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {\n\t\tcopyProperties(source, target, editable, (String[]) null);\n\t}"
  },
  "org.springframework.beans.<unknown>#copyProperties(source,target,ignoreProperties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the property values of the given source bean into the given target bean,\n\t * ignoring the given \"ignoreProperties\".\n\t * <p>Note: The source and target classes do not have to match or even be derived\n\t * from each other, as long as the properties match. Any bean properties that the\n\t * source bean exposes but the target bean does not will silently be ignored.\n\t * <p>This is just a convenience method. For more complex transfer needs,\n\t * consider using a full {@link BeanWrapper}.\n\t * <p>As of Spring Framework 5.3, this method honors generic type information\n\t * when matching properties in the source and target objects. See the\n\t * documentation for {@link #copyProperties(Object, Object)} for details.\n\t * @param source the source bean\n\t * @param target the target bean\n\t * @param ignoreProperties array of property names to ignore\n\t * @throws BeansException if the copying failed\n\t * @see BeanWrapper\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "target",
      "ignoreProperties"
    ],
    "position": {
      "column": 1,
      "line": 759
    },
    "return": "void",
    "signature": "public void copyProperties(Object source, Object target, String... ignoreProperties)",
    "source_code": "\tpublic static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {\n\t\tcopyProperties(source, target, null, ignoreProperties);\n\t}"
  },
  "org.springframework.beans.<unknown>#findDeclaredMethod(clazz,methodName,paramTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a method with the given method name and the given parameter types,\n\t * declared on the given class or one of its superclasses. Will return a public,\n\t * protected, package access, or private method.\n\t * <p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses.\n\t * @param clazz the class to check\n\t * @param methodName the name of the method to find\n\t * @param paramTypes the parameter types of the method to find\n\t * @return the Method object, or {@code null} if not found\n\t * @see Class#getDeclaredMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName",
      "paramTypes"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "Method",
    "signature": "public Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)",
    "source_code": "\tpublic static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n\t\ttry {\n\t\t\treturn clazz.getDeclaredMethod(methodName, paramTypes);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\tif (clazz.getSuperclass() != null) {\n\t\t\t\treturn findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.beans.<unknown>#findDeclaredMethodWithMinimalParameters(clazz,methodName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a method with the given method name and minimal parameters (best case: none),\n\t * declared on the given class or one of its superclasses. Will return a public,\n\t * protected, package access, or private method.\n\t * <p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses.\n\t * @param clazz the class to check\n\t * @param methodName the name of the method to find\n\t * @return the Method object, or {@code null} if not found\n\t * @throws IllegalArgumentException if methods of the given name were found but\n\t * could not be resolved to a unique method with minimal parameters\n\t * @see Class#getDeclaredMethods\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName"
    ],
    "position": {
      "column": 1,
      "line": 374
    },
    "return": "Method",
    "signature": "public Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)",
    "source_code": "\tpublic static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tMethod targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName);\n\t\tif (targetMethod == null && clazz.getSuperclass() != null) {\n\t\t\ttargetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName);\n\t\t}\n\t\treturn targetMethod;\n\t}"
  },
  "org.springframework.beans.<unknown>#findMethod(clazz,methodName,paramTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a method with the given method name and the given parameter types,\n\t * declared on the given class or one of its superclasses. Prefers public methods,\n\t * but will return a protected, package access, or private method too.\n\t * <p>Checks {@code Class.getMethod} first, falling back to\n\t * {@code findDeclaredMethod}. This allows to find public methods\n\t * without issues even in environments with restricted Java security settings.\n\t * @param clazz the class to check\n\t * @param methodName the name of the method to find\n\t * @param paramTypes the parameter types of the method to find\n\t * @return the Method object, or {@code null} if not found\n\t * @see Class#getMethod\n\t * @see #findDeclaredMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName",
      "paramTypes"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "Method",
    "signature": "public Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)",
    "source_code": "\tpublic static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n\t\ttry {\n\t\t\treturn clazz.getMethod(methodName, paramTypes);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\treturn findDeclaredMethod(clazz, methodName, paramTypes);\n\t\t}\n\t}"
  },
  "org.springframework.beans.<unknown>#findMethodWithMinimalParameters(clazz,methodName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a method with the given method name and minimal parameters (best case: none),\n\t * declared on the given class or one of its superclasses. Prefers public methods,\n\t * but will return a protected, package access, or private method too.\n\t * <p>Checks {@code Class.getMethods} first, falling back to\n\t * {@code findDeclaredMethodWithMinimalParameters}. This allows for finding public\n\t * methods without issues even in environments with restricted Java security settings.\n\t * @param clazz the class to check\n\t * @param methodName the name of the method to find\n\t * @return the Method object, or {@code null} if not found\n\t * @throws IllegalArgumentException if methods of the given name were found but\n\t * could not be resolved to a unique method with minimal parameters\n\t * @see Class#getMethods\n\t * @see #findDeclaredMethodWithMinimalParameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName"
    ],
    "position": {
      "column": 1,
      "line": 351
    },
    "return": "Method",
    "signature": "public Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)",
    "source_code": "\tpublic static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tMethod targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName);\n\t\tif (targetMethod == null) {\n\t\t\ttargetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName);\n\t\t}\n\t\treturn targetMethod;\n\t}"
  },
  "org.springframework.beans.<unknown>#findMethodWithMinimalParameters(methods,methodName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a method with the given method name and minimal parameters (best case: none)\n\t * in the given list of methods.\n\t * @param methods the methods to check\n\t * @param methodName the name of the method to find\n\t * @return the Method object, or {@code null} if not found\n\t * @throws IllegalArgumentException if methods of the given name were found but\n\t * could not be resolved to a unique method with minimal parameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methods",
      "methodName"
    ],
    "position": {
      "column": 1,
      "line": 394
    },
    "return": "Method",
    "signature": "public Method findMethodWithMinimalParameters(Method[] methods, String methodName)",
    "source_code": "\tpublic static Method findMethodWithMinimalParameters(Method[] methods, String methodName)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tMethod targetMethod = null;\n\t\tint numMethodsFoundWithCurrentMinimumArgs = 0;\n\t\tfor (Method method : methods) {\n\t\t\tif (method.getName().equals(methodName)) {\n\t\t\t\tint numParams = method.getParameterCount();\n\t\t\t\tif (targetMethod == null || numParams < targetMethod.getParameterCount()) {\n\t\t\t\t\ttargetMethod = method;\n\t\t\t\t\tnumMethodsFoundWithCurrentMinimumArgs = 1;\n\t\t\t\t}\n\t\t\t\telse if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {\n\t\t\t\t\tif (targetMethod.isBridge()) {\n\t\t\t\t\t\t// Prefer regular method over bridge...\n\t\t\t\t\t\ttargetMethod = method;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Additional candidate with same length\n\t\t\t\t\t\tnumMethodsFoundWithCurrentMinimumArgs++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (numMethodsFoundWithCurrentMinimumArgs > 1) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot resolve method '\" + methodName +\n\t\t\t\t\t\"' to a unique method. Attempted to resolve to overloaded method with \" +\n\t\t\t\t\t\"the least number of parameters but there were \" +\n\t\t\t\t\tnumMethodsFoundWithCurrentMinimumArgs + \" candidates.\");\n\t\t}\n\t\treturn targetMethod;\n\t}"
  },
  "org.springframework.beans.<unknown>#findPropertyForMethod(method,clazz)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a JavaBeans {@code PropertyDescriptor} for the given method,\n\t * with the method either being the read method or the write method for\n\t * that bean property.\n\t * @param method the method to find a corresponding PropertyDescriptor for\n\t * @param clazz the (most specific) class to introspect for descriptors\n\t * @return the corresponding PropertyDescriptor, or {@code null} if none\n\t * @throws BeansException if PropertyDescriptor lookup fails\n\t * @since 3.2.13\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 529
    },
    "return": "PropertyDescriptor",
    "signature": "public PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz)",
    "source_code": "\tpublic static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tPropertyDescriptor[] pds = getPropertyDescriptors(clazz);\n\t\tfor (PropertyDescriptor pd : pds) {\n\t\t\tif (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {\n\t\t\t\treturn pd;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.<unknown>#getFinalPath(pa,nestedPath)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the last component of the path. Also works if not nested.\n\t * @param pa property accessor to work on\n\t * @param nestedPath property path we know is nested\n\t * @return last component of the path (the property on the target bean)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "pa",
      "nestedPath"
    ],
    "position": {
      "column": 1,
      "line": 798
    },
    "return": "String",
    "signature": "protected String getFinalPath(AbstractNestablePropertyAccessor pa, String nestedPath)",
    "source_code": "\tprotected String getFinalPath(AbstractNestablePropertyAccessor pa, String nestedPath) {\n\t\tif (pa == this) {\n\t\t\treturn nestedPath;\n\t\t}\n\t\treturn nestedPath.substring(PropertyAccessorUtils.getLastNestedPropertySeparatorIndex(nestedPath) + 1);\n\t}"
  },
  "org.springframework.beans.<unknown>#getPropertyDescriptor(clazz,propertyName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the JavaBeans {@code PropertyDescriptors} for the given property.\n\t * @param clazz the Class to retrieve the PropertyDescriptor for\n\t * @param propertyName the name of the property\n\t * @return the corresponding PropertyDescriptor, or {@code null} if none\n\t * @throws BeansException if PropertyDescriptor lookup fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 500
    },
    "return": "PropertyDescriptor",
    "signature": "public PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)",
    "source_code": "\tpublic static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) throws BeansException {\n\t\treturn CachedIntrospectionResults.forClass(clazz).getPropertyDescriptor(propertyName);\n\t}"
  },
  "org.springframework.beans.<unknown>#instantiateClass(clazz,assignableTo)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate a class using its no-arg constructor and return the new instance\n\t * as the specified assignable type.\n\t * <p>Useful in cases where the type of the class to instantiate (clazz) is not\n\t * available, but the type desired (assignableTo) is known.\n\t * <p>Note that this method tries to set the constructor accessible if given a\n\t * non-accessible (that is, non-public) constructor.\n\t * @param clazz class to instantiate\n\t * @param assignableTo type that clazz must be assignableTo\n\t * @return the new instance\n\t * @throws BeanInstantiationException if the bean cannot be instantiated\n\t * @see Constructor#newInstance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "assignableTo"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "T",
    "signature": "public T instantiateClass(Class<?> clazz, Class<T> assignableTo)",
    "source_code": "\tpublic static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {\n\t\tAssert.isAssignable(assignableTo, clazz);\n\t\treturn (T) instantiateClass(clazz);\n\t}"
  },
  "org.springframework.beans.<unknown>#instantiateClass(ctor,args)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Instantiate a Kotlin class using the provided constructor.\n\t\t * @param ctor the constructor of the Kotlin class to instantiate\n\t\t * @param args the constructor arguments to apply\n\t\t * (use {@code null} for unspecified parameter if needed)\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ctor",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 870
    },
    "return": "T",
    "signature": "public T instantiateClass(Constructor<T> ctor, Object... args)",
    "source_code": "\t\tpublic static <T> T instantiateClass(Constructor<T> ctor, Object... args)\n\t\t\t\tthrows IllegalAccessException, InvocationTargetException, InstantiationException {\n\n\t\t\tKFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor);\n\t\t\tif (kotlinConstructor == null) {\n\t\t\t\treturn ctor.newInstance(args);\n\t\t\t}\n\n\t\t\tif ((!Modifier.isPublic(ctor.getModifiers()) || !Modifier.isPublic(ctor.getDeclaringClass().getModifiers()))) {\n\t\t\t\tKCallablesJvm.setAccessible(kotlinConstructor, true);\n\t\t\t}\n\n\t\t\tList<KParameter> parameters = kotlinConstructor.getParameters();\n\n\t\t\tAssert.isTrue(args.length <= parameters.size(),\n\t\t\t\t\t\"Number of provided arguments must be less than or equal to the number of constructor parameters\");\n\t\t\tif (parameters.isEmpty()) {\n\t\t\t\treturn kotlinConstructor.call();\n\t\t\t}\n\t\t\tMap<KParameter, Object> argParameters = CollectionUtils.newHashMap(parameters.size());\n\t\t\tfor (int i = 0 ; i < args.length ; i++) {\n\t\t\t\tif (!(parameters.get(i).isOptional() && args[i] == null)) {\n\t\t\t\t\targParameters.put(parameters.get(i), args[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn kotlinConstructor.callBy(argParameters);\n\t\t}"
  },
  "org.springframework.beans.<unknown>#newNestedPropertyAccessor(object,nestedPath)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new nested property accessor instance.\n\t * Can be overridden in subclasses to create a PropertyAccessor subclass.\n\t * @param object the object wrapped by this PropertyAccessor\n\t * @param nestedPath the nested path of the object\n\t * @return the nested PropertyAccessor instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "nestedPath"
    ],
    "position": {
      "column": 1,
      "line": 745
    },
    "return": "AbstractNestablePropertyAccessor",
    "signature": "protected AbstractNestablePropertyAccessor newNestedPropertyAccessor(Object object, String nestedPath)",
    "source_code": "\tprotected abstract AbstractNestablePropertyAccessor newNestedPropertyAccessor(Object object, String nestedPath);"
  },
  "org.springframework.beans.<unknown>#resolveSignature(signature,clazz)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a method signature in the form {@code methodName[([arg_list])]},\n\t * where {@code arg_list} is an optional, comma-separated list of fully-qualified\n\t * type names, and attempts to resolve that signature against the supplied {@code Class}.\n\t * <p>When not supplying an argument list ({@code methodName}) the method whose name\n\t * matches and has the least number of parameters will be returned. When supplying an\n\t * argument type list, only the method whose name and argument types match will be returned.\n\t * <p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>\n\t * resolved in the same way. The signature {@code methodName} means the method called\n\t * {@code methodName} with the least number of arguments, whereas {@code methodName()}\n\t * means the method called {@code methodName} with exactly 0 arguments.\n\t * <p>If no method can be found, then {@code null} is returned.\n\t * @param signature the method signature as String representation\n\t * @param clazz the class to resolve the method signature against\n\t * @return the resolved Method\n\t * @see #findMethod\n\t * @see #findMethodWithMinimalParameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "signature",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 446
    },
    "return": "Method",
    "signature": "public Method resolveSignature(String signature, Class<?> clazz)",
    "source_code": "\tpublic static Method resolveSignature(String signature, Class<?> clazz) {\n\t\tAssert.hasText(signature, \"'signature' must not be empty\");\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tint startParen = signature.indexOf('(');\n\t\tint endParen = signature.indexOf(')');\n\t\tif (startParen > -1 && endParen == -1) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid method signature '\" + signature +\n\t\t\t\t\t\"': expected closing ')' for args list\");\n\t\t}\n\t\telse if (startParen == -1 && endParen > -1) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid method signature '\" + signature +\n\t\t\t\t\t\"': expected opening '(' for args list\");\n\t\t}\n\t\telse if (startParen == -1) {\n\t\t\treturn findMethodWithMinimalParameters(clazz, signature);\n\t\t}\n\t\telse {\n\t\t\tString methodName = signature.substring(0, startParen);\n\t\t\tString[] parameterTypeNames =\n\t\t\t\t\tStringUtils.commaDelimitedListToStringArray(signature.substring(startParen + 1, endParen));\n\t\t\tClass<?>[] parameterTypes = new Class<?>[parameterTypeNames.length];\n\t\t\tfor (int i = 0; i < parameterTypeNames.length; i++) {\n\t\t\t\tString parameterTypeName = parameterTypeNames[i].trim();\n\t\t\t\ttry {\n\t\t\t\t\tparameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader());\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid method signature: unable to resolve type [\" +\n\t\t\t\t\t\t\tparameterTypeName + \"] for argument \" + i + \". Root cause: \" + ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn findMethod(clazz, methodName, parameterTypes);\n\t\t}\n\t}"
  },
  "org.springframework.beans.<unknown>#setPropertyValue(propertyName,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "void",
    "signature": "public void setPropertyValue(String propertyName, @Nullable Object value)",
    "source_code": "\tpublic void setPropertyValue(String propertyName, @Nullable Object value) throws BeansException {\n\t\tAbstractNestablePropertyAccessor nestedPa;\n\t\ttry {\n\t\t\tnestedPa = getPropertyAccessorForPropertyPath(propertyName);\n\t\t}\n\t\tcatch (NotReadablePropertyException ex) {\n\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\"Nested property in path '\" + propertyName + \"' does not exist\", ex);\n\t\t}\n\t\tPropertyTokenHolder tokens = getPropertyNameTokens(getFinalPath(nestedPa, propertyName));\n\t\tnestedPa.setPropertyValue(tokens, new PropertyValue(propertyName, value));\n\t}"
  },
  "org.springframework.beans.<unknown>#setPropertyValue(tokens,pv)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "tokens",
      "pv"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "void",
    "signature": "protected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv)",
    "source_code": "\tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tif (tokens.keys != null) {\n\t\t\tprocessKeyedProperty(tokens, pv);\n\t\t}\n\t\telse {\n\t\t\tprocessLocalProperty(tokens, pv);\n\t\t}\n\t}"
  },
  "org.springframework.beans.<unknown>#setPropertyValueAt(pv,i)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Modify a PropertyValue object held in this object.\n\t * Indexed from 0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pv",
      "i"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "void",
    "signature": "public void setPropertyValueAt(PropertyValue pv, int i)",
    "source_code": "\tpublic void setPropertyValueAt(PropertyValue pv, int i) {\n\t\tthis.propertyValueList.set(i, pv);\n\t}"
  },
  "org.springframework.beans.<unknown>#setPropertyValues(Map<?,map)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "public void setPropertyValues(Map<?, ?> map)",
    "source_code": "\tpublic void setPropertyValues(Map<?, ?> map) throws BeansException {\n\t\tsetPropertyValues(new MutablePropertyValues(map));\n\t}"
  },
  "org.springframework.beans.<unknown>#setPropertyValues(pvs,ignoreUnknown)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "ignoreUnknown"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown)",
    "source_code": "\tpublic void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown) throws BeansException {\n\t\tsetPropertyValues(pvs, ignoreUnknown, false);\n\t}"
  },
  "org.springframework.beans.<unknown>#setPropertyValues(pvs,ignoreUnknown,ignoreInvalid)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "ignoreUnknown",
      "ignoreInvalid"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown, boolean ignoreInvalid)",
    "source_code": "\tpublic void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown, boolean ignoreInvalid)\n\t\t\tthrows BeansException {\n\n\t\tList<PropertyAccessException> propertyAccessExceptions = null;\n\t\tList<PropertyValue> propertyValues = (pvs instanceof MutablePropertyValues mpvs ?\n\t\t\t\tmpvs.getPropertyValueList() : Arrays.asList(pvs.getPropertyValues()));\n\n\t\tif (ignoreUnknown) {\n\t\t\tthis.suppressNotWritablePropertyException = true;\n\t\t}\n\t\ttry {\n\t\t\tfor (PropertyValue pv : propertyValues) {\n\t\t\t\t// setPropertyValue may throw any BeansException, which won't be caught\n\t\t\t\t// here, if there is a critical failure such as no matching field.\n\t\t\t\t// We can attempt to deal only with less serious exceptions.\n\t\t\t\ttry {\n\t\t\t\t\tsetPropertyValue(pv);\n\t\t\t\t}\n\t\t\t\tcatch (NotWritablePropertyException ex) {\n\t\t\t\t\tif (!ignoreUnknown) {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t\t// Otherwise, just ignore it and continue...\n\t\t\t\t}\n\t\t\t\tcatch (NullValueInNestedPathException ex) {\n\t\t\t\t\tif (!ignoreInvalid) {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t\t// Otherwise, just ignore it and continue...\n\t\t\t\t}\n\t\t\t\tcatch (PropertyAccessException ex) {\n\t\t\t\t\tif (propertyAccessExceptions == null) {\n\t\t\t\t\t\tpropertyAccessExceptions = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t\tpropertyAccessExceptions.add(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (ignoreUnknown) {\n\t\t\t\tthis.suppressNotWritablePropertyException = false;\n\t\t\t}\n\t\t}\n\n\t\t// If we encountered individual exceptions, throw the composite exception.\n\t\tif (propertyAccessExceptions != null) {\n\t\t\tPropertyAccessException[] paeArray = propertyAccessExceptions.toArray(new PropertyAccessException[0]);\n\t\t\tthrow new PropertyBatchUpdateException(paeArray);\n\t\t}\n\t}"
  },
  "org.springframework.beans.<unknown>#setWrappedInstance(object,nestedPath,rootObject)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Switch the target object, replacing the cached introspection results only\n\t * if the class of the new object is different to that of the replaced object.\n\t * @param object the new target object\n\t * @param nestedPath the nested path of the object\n\t * @param rootObject the root object at the top of the path\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "nestedPath",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "void",
    "signature": "public void setWrappedInstance(Object object, @Nullable String nestedPath, @Nullable Object rootObject)",
    "source_code": "\tpublic void setWrappedInstance(Object object, @Nullable String nestedPath, @Nullable Object rootObject) {\n\t\tthis.wrappedObject = ObjectUtils.unwrapOptional(object);\n\t\tAssert.notNull(this.wrappedObject, \"Target object must not be null\");\n\t\tthis.nestedPath = (nestedPath != null ? nestedPath : \"\");\n\t\tthis.rootObject = (!this.nestedPath.isEmpty() ? rootObject : this.wrappedObject);\n\t\tthis.nestedPropertyAccessors = null;\n\t\tthis.typeConverterDelegate = new TypeConverterDelegate(this, this.wrappedObject);\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanNamesForAnnotationIncludingAncestors(lbf,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get all bean names whose {@code Class} has the supplied {@link Annotation}\n\t * type, including those defined in ancestor factories, without creating any bean\n\t * instances yet. Will return unique names in case of overridden bean definitions.\n\t * @param lbf the bean factory\n\t * @param annotationType the type of annotation to look for\n\t * @return the array of matching bean names, or an empty array if none\n\t * @since 5.0\n\t * @see ListableBeanFactory#getBeanNamesForAnnotation(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "String[]",
    "signature": "public String[] beanNamesForAnnotationIncludingAncestors(ListableBeanFactory lbf, Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic static String[] beanNamesForAnnotationIncludingAncestors(\n\t\t\tListableBeanFactory lbf, Class<? extends Annotation> annotationType) {\n\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tString[] result = lbf.getBeanNamesForAnnotation(annotationType);\n\t\tif (lbf instanceof HierarchicalBeanFactory hbf) {\n\t\t\tif (hbf.getParentBeanFactory() instanceof ListableBeanFactory pbf) {\n\t\t\t\tString[] parentResult = beanNamesForAnnotationIncludingAncestors(pbf, annotationType);\n\t\t\t\tresult = mergeNamesWithParent(result, parentResult, hbf);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanNamesForTypeIncludingAncestors(lbf,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get all bean names for the given type, including those defined in ancestor\n\t * factories. Will return unique names in case of overridden bean definitions.\n\t * <p>Does consider objects created by FactoryBeans, which means that FactoryBeans\n\t * will get initialized. If the object created by the FactoryBean doesn't match,\n\t * the raw FactoryBean itself will be matched against the type.\n\t * <p>This version of {@code beanNamesForTypeIncludingAncestors} automatically\n\t * includes prototypes and FactoryBeans.\n\t * @param lbf the bean factory\n\t * @param type the type that beans must match (as a {@code Class})\n\t * @return the array of matching bean names, or an empty array if none\n\t * @see ListableBeanFactory#getBeanNamesForType(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "String[]",
    "signature": "public String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type)",
    "source_code": "\tpublic static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type) {\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tString[] result = lbf.getBeanNamesForType(type);\n\t\tif (lbf instanceof HierarchicalBeanFactory hbf) {\n\t\t\tif (hbf.getParentBeanFactory() instanceof ListableBeanFactory pbf) {\n\t\t\t\tString[] parentResult = beanNamesForTypeIncludingAncestors(pbf, type);\n\t\t\t\tresult = mergeNamesWithParent(result, parentResult, hbf);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanNamesForTypeIncludingAncestors(lbf,type,includeNonSingletons,allowEagerInit)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get all bean names for the given type, including those defined in ancestor\n\t * factories. Will return unique names in case of overridden bean definitions.\n\t * <p>Does consider objects created by FactoryBeans if the \"allowEagerInit\"\n\t * flag is set, which means that FactoryBeans will get initialized. If the\n\t * object created by the FactoryBean doesn't match, the raw FactoryBean itself\n\t * will be matched against the type. If \"allowEagerInit\" is not set,\n\t * only raw FactoryBeans will be checked (which doesn't require initialization\n\t * of each FactoryBean).\n\t * @param lbf the bean factory\n\t * @param includeNonSingletons whether to include prototype or scoped beans too\n\t * or just singletons (also applies to FactoryBeans)\n\t * @param allowEagerInit whether to initialize <i>lazy-init singletons</i> and\n\t * <i>objects created by FactoryBeans</i> (or by factory methods with a\n\t * \"factory-bean\" reference) for the type check. Note that FactoryBeans need to be\n\t * eagerly initialized to determine their type: So be aware that passing in \"true\"\n\t * for this flag will initialize FactoryBeans and \"factory-bean\" references.\n\t * @param type the type that beans must match\n\t * @return the array of matching bean names, or an empty array if none\n\t * @see ListableBeanFactory#getBeanNamesForType(Class, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "String[]",
    "signature": "public String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic static String[] beanNamesForTypeIncludingAncestors(\n\t\t\tListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {\n\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tString[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n\t\tif (lbf instanceof HierarchicalBeanFactory hbf) {\n\t\t\tif (hbf.getParentBeanFactory() instanceof ListableBeanFactory pbf) {\n\t\t\t\tString[] parentResult = beanNamesForTypeIncludingAncestors(\n\t\t\t\t\t\tpbf, type, includeNonSingletons, allowEagerInit);\n\t\t\t\tresult = mergeNamesWithParent(result, parentResult, hbf);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanOfType(lbf,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a single bean of the given type or subtypes, not looking in ancestor\n\t * factories. Useful convenience method when we expect a single bean and\n\t * don't care about the bean name.\n\t * <p>Does consider objects created by FactoryBeans, which means that FactoryBeans\n\t * will get initialized. If the object created by the FactoryBean doesn't match,\n\t * the raw FactoryBean itself will be matched against the type.\n\t * <p>This version of {@code beanOfType} automatically includes\n\t * prototypes and FactoryBeans.\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @return the matching bean instance\n\t * @throws NoSuchBeanDefinitionException if no bean of the given type was found\n\t * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found\n\t * @throws BeansException if the bean could not be created\n\t * @see ListableBeanFactory#getBeansOfType(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 467
    },
    "return": "T",
    "signature": "public T beanOfType(ListableBeanFactory lbf, Class<T> type)",
    "source_code": "\tpublic static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException {\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tMap<String, T> beansOfType = lbf.getBeansOfType(type);\n\t\treturn uniqueBean(type, beansOfType);\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanOfType(lbf,type,includeNonSingletons,allowEagerInit)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a single bean of the given type or subtypes, not looking in ancestor\n\t * factories. Useful convenience method when we expect a single bean and\n\t * don't care about the bean name.\n\t * <p>Does consider objects created by FactoryBeans if the \"allowEagerInit\"\n\t * flag is set, which means that FactoryBeans will get initialized. If the\n\t * object created by the FactoryBean doesn't match, the raw FactoryBean itself\n\t * will be matched against the type. If \"allowEagerInit\" is not set,\n\t * only raw FactoryBeans will be checked (which doesn't require initialization\n\t * of each FactoryBean).\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @param includeNonSingletons whether to include prototype or scoped beans too\n\t * or just singletons (also applies to FactoryBeans)\n\t * @param allowEagerInit whether to initialize <i>lazy-init singletons</i> and\n\t * <i>objects created by FactoryBeans</i> (or by factory methods with a\n\t * \"factory-bean\" reference) for the type check. Note that FactoryBeans need to be\n\t * eagerly initialized to determine their type: So be aware that passing in \"true\"\n\t * for this flag will initialize FactoryBeans and \"factory-bean\" references.\n\t * @return the matching bean instance\n\t * @throws NoSuchBeanDefinitionException if no bean of the given type was found\n\t * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found\n\t * @throws BeansException if the bean could not be created\n\t * @see ListableBeanFactory#getBeansOfType(Class, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 498
    },
    "return": "T",
    "signature": "public T beanOfType(ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic static <T> T beanOfType(\n\t\t\tListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException {\n\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tMap<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit);\n\t\treturn uniqueBean(type, beansOfType);\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanOfTypeIncludingAncestors(lbf,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a single bean of the given type or subtypes, also picking up beans\n\t * defined in ancestor bean factories if the current bean factory is a\n\t * HierarchicalBeanFactory. Useful convenience method when we expect a\n\t * single bean and don't care about the bean name.\n\t * <p>Does consider objects created by FactoryBeans, which means that FactoryBeans\n\t * will get initialized. If the object created by the FactoryBean doesn't match,\n\t * the raw FactoryBean itself will be matched against the type.\n\t * <p>This version of {@code beanOfTypeIncludingAncestors} automatically includes\n\t * prototypes and FactoryBeans.\n\t * <p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,\n\t * i.e. such beans will be returned from the lowest factory that they are being found in,\n\t * hiding corresponding beans in ancestor factories.</b> This feature allows for\n\t * 'replacing' beans by explicitly choosing the same bean name in a child factory;\n\t * the bean in the ancestor factory won't be visible then, not even for by-type lookups.\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @return the matching bean instance\n\t * @throws NoSuchBeanDefinitionException if no bean of the given type was found\n\t * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found\n\t * @throws BeansException if the bean could not be created\n\t * @see #beansOfTypeIncludingAncestors(ListableBeanFactory, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 405
    },
    "return": "T",
    "signature": "public T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)",
    "source_code": "\tpublic static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)\n\t\t\tthrows BeansException {\n\n\t\tMap<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type);\n\t\treturn uniqueBean(type, beansOfType);\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanOfTypeIncludingAncestors(lbf,type,includeNonSingletons,allowEagerInit)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a single bean of the given type or subtypes, also picking up beans\n\t * defined in ancestor bean factories if the current bean factory is a\n\t * HierarchicalBeanFactory. Useful convenience method when we expect a\n\t * single bean and don't care about the bean name.\n\t * <p>Does consider objects created by FactoryBeans if the \"allowEagerInit\" flag is set,\n\t * which means that FactoryBeans will get initialized. If the object created by the\n\t * FactoryBean doesn't match, the raw FactoryBean itself will be matched against the\n\t * type. If \"allowEagerInit\" is not set, only raw FactoryBeans will be checked\n\t * (which doesn't require initialization of each FactoryBean).\n\t * <p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,\n\t * i.e. such beans will be returned from the lowest factory that they are being found in,\n\t * hiding corresponding beans in ancestor factories.</b> This feature allows for\n\t * 'replacing' beans by explicitly choosing the same bean name in a child factory;\n\t * the bean in the ancestor factory won't be visible then, not even for by-type lookups.\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @param includeNonSingletons whether to include prototype or scoped beans too\n\t * or just singletons (also applies to FactoryBeans)\n\t * @param allowEagerInit whether to initialize <i>lazy-init singletons</i> and\n\t * <i>objects created by FactoryBeans</i> (or by factory methods with a\n\t * \"factory-bean\" reference) for the type check. Note that FactoryBeans need to be\n\t * eagerly initialized to determine their type: So be aware that passing in \"true\"\n\t * for this flag will initialize FactoryBeans and \"factory-bean\" references.\n\t * @return the matching bean instance\n\t * @throws NoSuchBeanDefinitionException if no bean of the given type was found\n\t * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found\n\t * @throws BeansException if the bean could not be created\n\t * @see #beansOfTypeIncludingAncestors(ListableBeanFactory, Class, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 442
    },
    "return": "T",
    "signature": "public T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic static <T> T beanOfTypeIncludingAncestors(\n\t\t\tListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException {\n\n\t\tMap<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type, includeNonSingletons, allowEagerInit);\n\t\treturn uniqueBean(type, beansOfType);\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beansOfTypeIncludingAncestors(lbf,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return all beans of the given type or subtypes, also picking up beans defined in\n\t * ancestor bean factories if the current bean factory is a HierarchicalBeanFactory.\n\t * The returned Map will only contain beans of this type.\n\t * <p>Does consider objects created by FactoryBeans, which means that FactoryBeans\n\t * will get initialized. If the object created by the FactoryBean doesn't match,\n\t * the raw FactoryBean itself will be matched against the type.\n\t * <p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,\n\t * i.e. such beans will be returned from the lowest factory that they are being found in,\n\t * hiding corresponding beans in ancestor factories.</b> This feature allows for\n\t * 'replacing' beans by explicitly choosing the same bean name in a child factory;\n\t * the bean in the ancestor factory won't be visible then, not even for by-type lookups.\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @return the Map of matching bean instances, or an empty Map if none\n\t * @throws BeansException if a bean could not be created\n\t * @see ListableBeanFactory#getBeansOfType(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "T>",
    "signature": "public T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)",
    "source_code": "\tpublic static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)\n\t\t\tthrows BeansException {\n\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tMap<String, T> result = new LinkedHashMap<>(4);\n\t\tresult.putAll(lbf.getBeansOfType(type));\n\t\tif (lbf instanceof HierarchicalBeanFactory hbf) {\n\t\t\tif (hbf.getParentBeanFactory() instanceof ListableBeanFactory pbf) {\n\t\t\t\tMap<String, T> parentResult = beansOfTypeIncludingAncestors(pbf, type);\n\t\t\t\tparentResult.forEach((beanName, beanInstance) -> {\n\t\t\t\t\tif (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {\n\t\t\t\t\t\tresult.put(beanName, beanInstance);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beansOfTypeIncludingAncestors(lbf,type,includeNonSingletons,allowEagerInit)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return all beans of the given type or subtypes, also picking up beans defined in\n\t * ancestor bean factories if the current bean factory is a HierarchicalBeanFactory.\n\t * The returned Map will only contain beans of this type.\n\t * <p>Does consider objects created by FactoryBeans if the \"allowEagerInit\" flag is set,\n\t * which means that FactoryBeans will get initialized. If the object created by the\n\t * FactoryBean doesn't match, the raw FactoryBean itself will be matched against the\n\t * type. If \"allowEagerInit\" is not set, only raw FactoryBeans will be checked\n\t * (which doesn't require initialization of each FactoryBean).\n\t * <p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,\n\t * i.e. such beans will be returned from the lowest factory that they are being found in,\n\t * hiding corresponding beans in ancestor factories.</b> This feature allows for\n\t * 'replacing' beans by explicitly choosing the same bean name in a child factory;\n\t * the bean in the ancestor factory won't be visible then, not even for by-type lookups.\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @param includeNonSingletons whether to include prototype or scoped beans too\n\t * or just singletons (also applies to FactoryBeans)\n\t * @param allowEagerInit whether to initialize <i>lazy-init singletons</i> and\n\t * <i>objects created by FactoryBeans</i> (or by factory methods with a\n\t * \"factory-bean\" reference) for the type check. Note that FactoryBeans need to be\n\t * eagerly initialized to determine their type: So be aware that passing in \"true\"\n\t * for this flag will initialize FactoryBeans and \"factory-bean\" references.\n\t * @return the Map of matching bean instances, or an empty Map if none\n\t * @throws BeansException if a bean could not be created\n\t * @see ListableBeanFactory#getBeansOfType(Class, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "T>",
    "signature": "public T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic static <T> Map<String, T> beansOfTypeIncludingAncestors(\n\t\t\tListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException {\n\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tMap<String, T> result = new LinkedHashMap<>(4);\n\t\tresult.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit));\n\t\tif (lbf instanceof HierarchicalBeanFactory hbf) {\n\t\t\tif (hbf.getParentBeanFactory() instanceof ListableBeanFactory pbf) {\n\t\t\t\tMap<String, T> parentResult = beansOfTypeIncludingAncestors(pbf, type, includeNonSingletons, allowEagerInit);\n\t\t\t\tparentResult.forEach((beanName, beanInstance) -> {\n\t\t\t\t\tif (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {\n\t\t\t\t\t\tresult.put(beanName, beanInstance);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#applyTo(generationContext,beanRegistrationCode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode"
    ],
    "position": {
      "column": 1,
      "line": 898
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode)",
    "source_code": "\t\tpublic void applyTo(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode) {\n\t\t\tGeneratedClass generatedClass = generationContext.getGeneratedClasses()\n\t\t\t\t\t.addForFeatureComponent(\"Autowiring\", this.target, type -> {\n\t\t\t\t\t\ttype.addJavadoc(\"Autowiring for {@link $T}.\", this.target);\n\t\t\t\t\t\ttype.addModifiers(javax.lang.model.element.Modifier.PUBLIC);\n\t\t\t\t\t});\n\t\t\tGeneratedMethod generateMethod = generatedClass.getMethods().add(\"apply\", method -> {\n\t\t\t\tmethod.addJavadoc(\"Apply the autowiring.\");\n\t\t\t\tmethod.addModifiers(javax.lang.model.element.Modifier.PUBLIC,\n\t\t\t\t\t\tjavax.lang.model.element.Modifier.STATIC);\n\t\t\t\tmethod.addParameter(RegisteredBean.class, REGISTERED_BEAN_PARAMETER);\n\t\t\t\tmethod.addParameter(this.target, INSTANCE_PARAMETER);\n\t\t\t\tmethod.returns(this.target);\n\t\t\t\tmethod.addCode(generateMethodCode(generatedClass.getName(),\n\t\t\t\t\t\tgenerationContext.getRuntimeHints()));\n\t\t\t});\n\t\t\tbeanRegistrationCode.addInstancePostProcessor(generateMethod.toMethodReference());\n\n\t\t\tif (this.candidateResolver != null) {\n\t\t\t\tregisterHints(generationContext.getRuntimeHints());\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#checkQualifier(bdHolder,annotation,typeConverter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Match the given qualifier annotation against the candidate bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bdHolder",
      "annotation",
      "typeConverter"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "boolean",
    "signature": "protected boolean checkQualifier(BeanDefinitionHolder bdHolder, Annotation annotation, TypeConverter typeConverter)",
    "source_code": "\tprotected boolean checkQualifier(\n\t\t\tBeanDefinitionHolder bdHolder, Annotation annotation, TypeConverter typeConverter) {\n\n\t\tClass<? extends Annotation> type = annotation.annotationType();\n\t\tRootBeanDefinition bd = (RootBeanDefinition) bdHolder.getBeanDefinition();\n\n\t\tAutowireCandidateQualifier qualifier = bd.getQualifier(type.getName());\n\t\tif (qualifier == null) {\n\t\t\tqualifier = bd.getQualifier(ClassUtils.getShortName(type));\n\t\t}\n\t\tif (qualifier == null) {\n\t\t\t// First, check annotation on qualified element, if any\n\t\t\tAnnotation targetAnnotation = getQualifiedElementAnnotation(bd, type);\n\t\t\t// Then, check annotation on factory method, if applicable\n\t\t\tif (targetAnnotation == null) {\n\t\t\t\ttargetAnnotation = getFactoryMethodAnnotation(bd, type);\n\t\t\t}\n\t\t\tif (targetAnnotation == null) {\n\t\t\t\tRootBeanDefinition dbd = getResolvedDecoratedDefinition(bd);\n\t\t\t\tif (dbd != null) {\n\t\t\t\t\ttargetAnnotation = getFactoryMethodAnnotation(dbd, type);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (targetAnnotation == null) {\n\t\t\t\t// Look for matching annotation on the target class\n\t\t\t\tif (getBeanFactory() != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tClass<?> beanType = getBeanFactory().getType(bdHolder.getBeanName());\n\t\t\t\t\t\tif (beanType != null) {\n\t\t\t\t\t\t\ttargetAnnotation = AnnotationUtils.getAnnotation(ClassUtils.getUserClass(beanType), type);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t\t// Not the usual case - simply forget about the type check...\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (targetAnnotation == null && bd.hasBeanClass()) {\n\t\t\t\t\ttargetAnnotation = AnnotationUtils.getAnnotation(ClassUtils.getUserClass(bd.getBeanClass()), type);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (targetAnnotation != null && targetAnnotation.equals(annotation)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tMap<String, Object> attributes = AnnotationUtils.getAnnotationAttributes(annotation);\n\t\tif (attributes.isEmpty() && qualifier == null) {\n\t\t\t// If no attributes, the qualifier must be present\n\t\t\treturn false;\n\t\t}\n\t\tfor (Map.Entry<String, Object> entry : attributes.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\t\t\tObject expectedValue = entry.getValue();\n\t\t\tObject actualValue = null;\n\t\t\t// Check qualifier first\n\t\t\tif (qualifier != null) {\n\t\t\t\tactualValue = qualifier.getAttribute(attributeName);\n\t\t\t}\n\t\t\tif (actualValue == null) {\n\t\t\t\t// Fall back on bean definition attribute\n\t\t\t\tactualValue = bd.getAttribute(attributeName);\n\t\t\t}\n\t\t\tif (actualValue == null && attributeName.equals(AutowireCandidateQualifier.VALUE_KEY) &&\n\t\t\t\t\texpectedValue instanceof String name && bdHolder.matchesName(name)) {\n\t\t\t\t// Fall back on bean name (or alias) match\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (actualValue == null && qualifier != null) {\n\t\t\t\t// Fall back on default, but only if the qualifier is present\n\t\t\t\tactualValue = AnnotationUtils.getDefaultValue(annotation, attributeName);\n\t\t\t}\n\t\t\tif (actualValue != null) {\n\t\t\t\tactualValue = typeConverter.convertIfNecessary(actualValue, expectedValue.getClass());\n\t\t\t}\n\t\t\tif (!expectedValue.equals(actualValue)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#checkQualifiers(bdHolder,annotationsToSearch)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Match the given qualifier annotations against the candidate bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bdHolder",
      "annotationsToSearch"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "boolean",
    "signature": "protected boolean checkQualifiers(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch)",
    "source_code": "\tprotected boolean checkQualifiers(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch) {\n\t\tif (ObjectUtils.isEmpty(annotationsToSearch)) {\n\t\t\treturn true;\n\t\t}\n\t\tSimpleTypeConverter typeConverter = new SimpleTypeConverter();\n\t\tfor (Annotation annotation : annotationsToSearch) {\n\t\t\tClass<? extends Annotation> type = annotation.annotationType();\n\t\t\tboolean checkMeta = true;\n\t\t\tboolean fallbackToMeta = false;\n\t\t\tif (isQualifier(type)) {\n\t\t\t\tif (!checkQualifier(bdHolder, annotation, typeConverter)) {\n\t\t\t\t\tfallbackToMeta = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcheckMeta = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (checkMeta) {\n\t\t\t\tboolean foundMeta = false;\n\t\t\t\tfor (Annotation metaAnn : type.getAnnotations()) {\n\t\t\t\t\tClass<? extends Annotation> metaType = metaAnn.annotationType();\n\t\t\t\t\tif (isQualifier(metaType)) {\n\t\t\t\t\t\tfoundMeta = true;\n\t\t\t\t\t\t// Only accept fallback match if @Qualifier annotation has a value...\n\t\t\t\t\t\t// Otherwise, it is just a marker for a custom qualifier annotation.\n\t\t\t\t\t\tif ((fallbackToMeta && ObjectUtils.isEmpty(AnnotationUtils.getValue(metaAnn))) ||\n\t\t\t\t\t\t\t\t!checkQualifier(bdHolder, metaAnn, typeConverter)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (fallbackToMeta && !foundMeta) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#forElements(elements,clazz)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return an {@code InjectionMetadata} instance, possibly for empty elements.\n\t * @param elements the elements to inject (possibly empty)\n\t * @param clazz the target class\n\t * @return a new {@link #InjectionMetadata(Class, Collection)} instance\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elements",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "InjectionMetadata",
    "signature": "public InjectionMetadata forElements(Collection<InjectedElement> elements, Class<?> clazz)",
    "source_code": "\tpublic static InjectionMetadata forElements(Collection<InjectedElement> elements, Class<?> clazz) {\n\t\treturn (elements.isEmpty() ? new InjectionMetadata(clazz, Collections.emptyList()) :\n\t\t\t\tnew InjectionMetadata(clazz, elements));\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#getFactoryMethodAnnotation(bd,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "Annotation",
    "signature": "protected Annotation getFactoryMethodAnnotation(RootBeanDefinition bd, Class<? extends Annotation> type)",
    "source_code": "\tprotected Annotation getFactoryMethodAnnotation(RootBeanDefinition bd, Class<? extends Annotation> type) {\n\t\tMethod resolvedFactoryMethod = bd.getResolvedFactoryMethod();\n\t\treturn (resolvedFactoryMethod != null ? AnnotationUtils.getAnnotation(resolvedFactoryMethod, type) : null);\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#getQualifiedElementAnnotation(bd,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "Annotation",
    "signature": "protected Annotation getQualifiedElementAnnotation(RootBeanDefinition bd, Class<? extends Annotation> type)",
    "source_code": "\tprotected Annotation getQualifiedElementAnnotation(RootBeanDefinition bd, Class<? extends Annotation> type) {\n\t\tAnnotatedElement qualifiedElement = bd.getQualifiedElement();\n\t\treturn (qualifiedElement != null ? AnnotationUtils.getAnnotation(qualifiedElement, type) : null);\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#getResourceToInject(target,requestingBeanName)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Either this or {@link #inject} needs to be overridden.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "Object",
    "signature": "protected Object getResourceToInject(Object target, @Nullable String requestingBeanName)",
    "source_code": "\t\tprotected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#inject(bean,beanName,pvs)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "beanName",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 753
    },
    "return": "void",
    "signature": "protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs)",
    "source_code": "\t\tprotected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {\n\t\t\tif (checkPropertySkipping(pvs)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tMethod method = (Method) this.member;\n\t\t\tObject[] arguments;\n\t\t\tif (this.cached) {\n\t\t\t\ttry {\n\t\t\t\t\targuments = resolveCachedArguments(beanName);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t// Unexpected removal of target bean for cached argument -> re-resolve\n\t\t\t\t\targuments = resolveMethodArguments(method, bean, beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\targuments = resolveMethodArguments(method, bean, beanName);\n\t\t\t}\n\t\t\tif (arguments != null) {\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tmethod.invoke(bean, arguments);\n\t\t\t\t}\n\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#inject(target,beanName,pvs)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "beanName",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs)",
    "source_code": "\tpublic void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {\n\t\tCollection<InjectedElement> checkedElements = this.checkedElements;\n\t\tCollection<InjectedElement> elementsToIterate =\n\t\t\t\t(checkedElements != null ? checkedElements : this.injectedElements);\n\t\tif (!elementsToIterate.isEmpty()) {\n\t\t\tfor (InjectedElement element : elementsToIterate) {\n\t\t\t\telement.inject(target, beanName, pvs);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#inject(target,requestingBeanName,pvs)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Either this or {@link #getResourceToInject} needs to be overridden.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "requestingBeanName",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "void",
    "signature": "protected void inject(Object target, @Nullable String requestingBeanName, @Nullable PropertyValues pvs)",
    "source_code": "\t\tprotected void inject(Object target, @Nullable String requestingBeanName, @Nullable PropertyValues pvs)\n\t\t\t\tthrows Throwable {\n\n\t\t\tif (this.isField) {\n\t\t\t\tField field = (Field) this.member;\n\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\tfield.set(target, getResourceToInject(target, requestingBeanName));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (checkPropertySkipping(pvs)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tMethod method = (Method) this.member;\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tmethod.invoke(target, getResourceToInject(target, requestingBeanName));\n\t\t\t\t}\n\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#invokeDestroyMethods(target,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 373
    },
    "return": "void",
    "signature": "public void invokeDestroyMethods(Object target, String beanName)",
    "source_code": "\t\tpublic void invokeDestroyMethods(Object target, String beanName) throws Throwable {\n\t\t\tCollection<LifecycleElement> checkedDestroyMethods = this.checkedDestroyMethods;\n\t\t\tCollection<LifecycleElement> destroyMethodsToUse =\n\t\t\t\t\t(checkedDestroyMethods != null ? checkedDestroyMethods : this.destroyMethods);\n\t\t\tif (!destroyMethodsToUse.isEmpty()) {\n\t\t\t\tfor (LifecycleElement element : destroyMethodsToUse) {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Invoking destroy method on bean '\" + beanName + \"': \" + element.getMethod());\n\t\t\t\t\t}\n\t\t\t\t\telement.invoke(target);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#invokeInitMethods(target,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 359
    },
    "return": "void",
    "signature": "public void invokeInitMethods(Object target, String beanName)",
    "source_code": "\t\tpublic void invokeInitMethods(Object target, String beanName) throws Throwable {\n\t\t\tCollection<LifecycleElement> checkedInitMethods = this.checkedInitMethods;\n\t\t\tCollection<LifecycleElement> initMethodsToIterate =\n\t\t\t\t\t(checkedInitMethods != null ? checkedInitMethods : this.initMethods);\n\t\t\tif (!initMethodsToIterate.isEmpty()) {\n\t\t\t\tfor (LifecycleElement element : initMethodsToIterate) {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Invoking init method on bean '\" + beanName + \"': \" + element.getMethod());\n\t\t\t\t\t}\n\t\t\t\t\telement.invoke(target);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#isAutowireCandidate(bdHolder,descriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the provided bean definition is an autowire candidate.\n\t * <p>To be considered a candidate the bean's <em>autowire-candidate</em>\n\t * attribute must not have been set to 'false'. Also, if an annotation on\n\t * the field or parameter to be autowired is recognized by this bean factory\n\t * as a <em>qualifier</em>, the bean must 'match' against the annotation as\n\t * well as any attributes it may contain. The bean definition must contain\n\t * the same qualifier or match by meta attributes. A \"value\" attribute will\n\t * fall back to match against the bean name or an alias if a qualifier or\n\t * attribute does not match.\n\t * @see Qualifier\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bdHolder",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "boolean",
    "signature": "public boolean isAutowireCandidate(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor)",
    "source_code": "\tpublic boolean isAutowireCandidate(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor) {\n\t\tboolean match = super.isAutowireCandidate(bdHolder, descriptor);\n\t\tif (match) {\n\t\t\tmatch = checkQualifiers(bdHolder, descriptor.getAnnotations());\n\t\t\tif (match) {\n\t\t\t\tMethodParameter methodParam = descriptor.getMethodParameter();\n\t\t\t\tif (methodParam != null) {\n\t\t\t\t\tMethod method = methodParam.getMethod();\n\t\t\t\t\tif (method == null || void.class == method.getReturnType()) {\n\t\t\t\t\t\tmatch = checkQualifiers(bdHolder, methodParam.getMethodAnnotations());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn match;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#isQualifierMatch(qualifier,beanName,beanFactory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the named bean declares a qualifier of the given name.\n\t * @param qualifier the qualifier to match\n\t * @param beanName the name of the candidate bean\n\t * @param beanFactory the factory from which to retrieve the named bean\n\t * @return {@code true} if either the bean definition (in the XML case)\n\t * or the bean's factory method (in the {@code @Bean} case) defines a matching\n\t * qualifier value (through {@code <qualifier>} or {@code @Qualifier})\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "qualifier",
      "beanName",
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "boolean",
    "signature": "public boolean isQualifierMatch(Predicate<String> qualifier, String beanName, @Nullable BeanFactory beanFactory)",
    "source_code": "\tpublic static boolean isQualifierMatch(\n\t\t\tPredicate<String> qualifier, String beanName, @Nullable BeanFactory beanFactory) {\n\n\t\t// Try quick bean name or alias match first...\n\t\tif (qualifier.test(beanName)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (beanFactory != null) {\n\t\t\tfor (String alias : beanFactory.getAliases(beanName)) {\n\t\t\t\tif (qualifier.test(alias)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tClass<?> beanType = beanFactory.getType(beanName);\n\t\t\t\tif (beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\t\t\tBeanDefinition bd = cbf.getMergedBeanDefinition(beanName);\n\t\t\t\t\t// Explicit qualifier metadata on bean definition? (typically in XML definition)\n\t\t\t\t\tif (bd instanceof AbstractBeanDefinition abd) {\n\t\t\t\t\t\tAutowireCandidateQualifier candidate = abd.getQualifier(Qualifier.class.getName());\n\t\t\t\t\t\tif (candidate != null) {\n\t\t\t\t\t\t\tObject value = candidate.getAttribute(AutowireCandidateQualifier.VALUE_KEY);\n\t\t\t\t\t\t\tif (value != null && qualifier.test(value.toString())) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Corresponding qualifier on factory method? (typically in configuration class)\n\t\t\t\t\tif (bd instanceof RootBeanDefinition rbd) {\n\t\t\t\t\t\tMethod factoryMethod = rbd.getResolvedFactoryMethod();\n\t\t\t\t\t\tif (factoryMethod != null) {\n\t\t\t\t\t\t\tQualifier targetAnnotation = AnnotationUtils.getAnnotation(factoryMethod, Qualifier.class);\n\t\t\t\t\t\t\tif (targetAnnotation != null) {\n\t\t\t\t\t\t\t\treturn qualifier.test(targetAnnotation.value());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Corresponding qualifier on bean implementation class? (for custom user types)\n\t\t\t\tif (beanType != null) {\n\t\t\t\t\tQualifier targetAnnotation = AnnotationUtils.getAnnotation(beanType, Qualifier.class);\n\t\t\t\t\tif (targetAnnotation != null) {\n\t\t\t\t\t\treturn qualifier.test(targetAnnotation.value());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t// Ignore - can't compare qualifiers for a manually registered singleton object\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#needsRefresh(metadata,clazz)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given injection metadata needs to be refreshed.\n\t * @param metadata the existing metadata instance\n\t * @param clazz the current target class\n\t * @return {@code true} indicating a refresh, {@code false} otherwise\n\t * @see #needsRefresh(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadata",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "boolean",
    "signature": "public boolean needsRefresh(@Nullable InjectionMetadata metadata, Class<?> clazz)",
    "source_code": "\tpublic static boolean needsRefresh(@Nullable InjectionMetadata metadata, Class<?> clazz) {\n\t\treturn (metadata == null || metadata.needsRefresh(clazz));\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#postProcessBeforeDestruction(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "void",
    "signature": "public void postProcessBeforeDestruction(Object bean, String beanName)",
    "source_code": "\tpublic void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException {\n\t\tLifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());\n\t\ttry {\n\t\t\tmetadata.invokeDestroyMethods(bean, beanName);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tString msg = \"Destroy method on bean with name '\" + beanName + \"' threw an exception\";\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.warn(msg, ex.getTargetException());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.warn(msg + \": \" + ex.getTargetException());\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.warn(\"Failed to invoke destroy method on bean with name '\" + beanName + \"'\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\tLifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());\n\t\ttry {\n\t\t\tmetadata.invokeInitMethods(bean, beanName);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"Invocation of init method failed\", ex.getTargetException());\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"Failed to invoke init method\", ex);\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t\tfindInjectionMetadata(beanDefinition, beanType);\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#postProcessProperties(pvs,bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 478
    },
    "return": "PropertyValues",
    "signature": "public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)",
    "source_code": "\tpublic PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n\t\tInjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);\n\t\ttry {\n\t\t\tmetadata.inject(bean, beanName, pvs);\n\t\t}\n\t\tcatch (BeanCreationException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"Injection of autowired dependencies failed\", ex);\n\t\t}\n\t\treturn pvs;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#qualifiedBeanOfType(beanFactory,beanType,qualifier)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a\n\t * qualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the given\n\t * qualifier, or having a bean name matching the given qualifier.\n\t * @param beanFactory the factory to get the target bean from (also searching ancestors)\n\t * @param beanType the type of bean to retrieve\n\t * @param qualifier the qualifier for selecting between multiple bean matches\n\t * @return the matching bean of type {@code T} (never {@code null})\n\t * @throws NoUniqueBeanDefinitionException if multiple matching beans of type {@code T} found\n\t * @throws NoSuchBeanDefinitionException if no matching bean of type {@code T} found\n\t * @throws BeansException if the bean could not be created\n\t * @see BeanFactoryUtils#beanOfTypeIncludingAncestors(ListableBeanFactory, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "beanType",
      "qualifier"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "T",
    "signature": "public T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier)",
    "source_code": "\tpublic static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier)\n\t\t\tthrows BeansException {\n\n\t\tAssert.notNull(beanFactory, \"BeanFactory must not be null\");\n\n\t\tif (beanFactory instanceof ListableBeanFactory lbf) {\n\t\t\t// Full qualifier matching supported.\n\t\t\treturn qualifiedBeanOfType(lbf, beanType, qualifier);\n\t\t}\n\t\telse if (beanFactory.containsBean(qualifier)) {\n\t\t\t// Fallback: target bean at least found by bean name.\n\t\t\treturn beanFactory.getBean(qualifier, beanType);\n\t\t}\n\t\telse {\n\t\t\tthrow new NoSuchBeanDefinitionException(qualifier, \"No matching \" + beanType.getSimpleName() +\n\t\t\t\t\t\" bean found for bean name '\" + qualifier +\n\t\t\t\t\t\"'! (Note: Qualifier matching not supported because given \" +\n\t\t\t\t\t\"BeanFactory does not implement ConfigurableListableBeanFactory.)\");\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#qualifiedBeansOfType(beanFactory,beanType,qualifier)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve all beans of type {@code T} from the given {@code BeanFactory} declaring a\n\t * qualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the given\n\t * qualifier, or having a bean name matching the given qualifier.\n\t * @param beanFactory the factory to get the target beans from (also searching ancestors)\n\t * @param beanType the type of beans to retrieve\n\t * @param qualifier the qualifier for selecting among all type matches\n\t * @return the matching beans of type {@code T}\n\t * @throws BeansException if any of the matching beans could not be created\n\t * @since 5.1.1\n\t * @see BeanFactoryUtils#beansOfTypeIncludingAncestors(ListableBeanFactory, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "beanType",
      "qualifier"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "T>",
    "signature": "public T> qualifiedBeansOfType(ListableBeanFactory beanFactory, Class<T> beanType, String qualifier)",
    "source_code": "\tpublic static <T> Map<String, T> qualifiedBeansOfType(\n\t\t\tListableBeanFactory beanFactory, Class<T> beanType, String qualifier) throws BeansException {\n\n\t\tString[] candidateBeans = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, beanType);\n\t\tMap<String, T> result = new LinkedHashMap<>(4);\n\t\tfor (String beanName : candidateBeans) {\n\t\t\tif (isQualifierMatch(qualifier::equals, beanName, beanFactory)) {\n\t\t\t\tresult.put(beanName, beanFactory.getBean(beanName, beanType));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#factoriesAndBeans(springFactoriesLoader,beanFactory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link Loader} that will obtain AOT services from the given\n\t * {@link SpringFactoriesLoader} and {@link ListableBeanFactory}.\n\t * @param springFactoriesLoader the spring factories loader\n\t * @param beanFactory the bean factory\n\t * @return a new {@link Loader} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "springFactoriesLoader",
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "Loader",
    "signature": "public Loader factoriesAndBeans(SpringFactoriesLoader springFactoriesLoader, ListableBeanFactory beanFactory)",
    "source_code": "\tpublic static Loader factoriesAndBeans(SpringFactoriesLoader springFactoriesLoader, ListableBeanFactory beanFactory) {\n\t\tAssert.notNull(beanFactory, \"'beanFactory' must not be null\");\n\t\tAssert.notNull(springFactoriesLoader, \"'springFactoriesLoader' must not be null\");\n\t\treturn new Loader(springFactoriesLoader, beanFactory);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#forFactoryMethod(declaringClass,methodName,parameterTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link BeanInstanceSupplier} that\n\t * resolves arguments for the specified factory method.\n\t * @param <T> the type of instance supplied\n\t * @param declaringClass the class that declares the factory method\n\t * @param methodName the factory method name\n\t * @param parameterTypes the factory method parameter types\n\t * @return a new {@link BeanInstanceSupplier} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "declaringClass",
      "methodName",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "BeanInstanceSupplier<T>",
    "signature": "public BeanInstanceSupplier<T> forFactoryMethod(Class<?> declaringClass, String methodName, Class<?>... parameterTypes)",
    "source_code": "\tpublic static <T> BeanInstanceSupplier<T> forFactoryMethod(\n\t\t\tClass<?> declaringClass, String methodName, Class<?>... parameterTypes) {\n\n\t\tAssert.notNull(declaringClass, \"'declaringClass' must not be null\");\n\t\tAssert.hasText(methodName, \"'methodName' must not be empty\");\n\t\tAssert.notNull(parameterTypes, \"'parameterTypes' must not be null\");\n\t\tAssert.noNullElements(parameterTypes, \"'parameterTypes' must not contain null elements\");\n\t\treturn new BeanInstanceSupplier<>(\n\t\t\t\tnew FactoryMethodLookup(declaringClass, methodName, parameterTypes),\n\t\t\t\tnull, null);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCode(parameterTypes,startIndex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterTypes",
      "startIndex"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(Class<?>[] parameterTypes, int startIndex)",
    "source_code": "\tpublic CodeBlock generateCode(Class<?>[] parameterTypes, int startIndex) {\n\t\treturn generateCode(parameterTypes, startIndex, \"args\");\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCode(parameterTypes,startIndex,variableName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterTypes",
      "startIndex",
      "variableName"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(Class<?>[] parameterTypes, int startIndex,\n\t\t\tString variableName)",
    "source_code": "\tpublic CodeBlock generateCode(Class<?>[] parameterTypes, int startIndex,\n\t\t\tString variableName) {\n\n\t\tAssert.notNull(parameterTypes, \"'parameterTypes' must not be null\");\n\t\tAssert.notNull(variableName, \"'variableName' must not be null\");\n\t\tboolean ambiguous = isAmbiguous();\n\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\tfor (int i = startIndex; i < parameterTypes.length; i++) {\n\t\t\tcode.add((i != startIndex) ? \", \" : \"\");\n\t\t\tif (!ambiguous) {\n\t\t\t\tcode.add(\"$L.get($L)\", variableName, i - startIndex);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcode.add(\"$L.get($L, $T.class)\", variableName, i - startIndex,\n\t\t\t\t\t\tparameterTypes[i]);\n\t\t\t}\n\t\t}\n\t\treturn code.build();\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCode(value,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 552
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(Object value, ResolvableType type)",
    "source_code": "\t\tpublic CodeBlock generateCode(Object value, ResolvableType type) {\n\t\t\tif (value instanceof RuntimeBeanReference runtimeBeanReference &&\n\t\t\t\t\truntimeBeanReference.getBeanType() != null) {\n\t\t\t\treturn CodeBlock.of(\"new $T($T.class)\", RuntimeBeanReference.class,\n\t\t\t\t\t\truntimeBeanReference.getBeanType());\n\t\t\t}\n\t\t\telse if (value instanceof BeanReference beanReference) {\n\t\t\t\treturn CodeBlock.of(\"new $T($S)\", RuntimeBeanReference.class,\n\t\t\t\t\t\tbeanReference.getBeanName());\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCollectionCode(elementType,collection)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "elementType",
      "collection"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "CodeBlock",
    "signature": "protected CodeBlock generateCollectionCode(ResolvableType elementType, T collection)",
    "source_code": "\t\tprotected CodeBlock generateCollectionCode(ResolvableType elementType, T collection) {\n\t\t\treturn generateCollectionOf(collection, this.collectionType, elementType);\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCollectionCode(elementType,set)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "elementType",
      "set"
    ],
    "position": {
      "column": 1,
      "line": 447
    },
    "return": "CodeBlock",
    "signature": "protected CodeBlock generateCollectionCode(ResolvableType elementType, Set<?> set)",
    "source_code": "\t\tprotected CodeBlock generateCollectionCode(ResolvableType elementType, Set<?> set) {\n\t\t\tif (set instanceof LinkedHashSet) {\n\t\t\t\treturn CodeBlock.of(\"new $T($L)\", LinkedHashSet.class,\n\t\t\t\t\t\tgenerateCollectionOf(set, List.class, elementType));\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tset = orderForCodeConsistency(set);\n\t\t\t}\n\t\t\tcatch (ClassCastException ex) {\n\t\t\t\t// If elements are not comparable, just keep the original set\n\t\t\t}\n\t\t\treturn super.generateCollectionCode(elementType, set);\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCollectionOf(collection,collectionType,elementType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "collection",
      "collectionType",
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "CodeBlock",
    "signature": "protected CodeBlock generateCollectionOf(Collection<?> collection,\n\t\t\t\tClass<?> collectionType, ResolvableType elementType)",
    "source_code": "\t\tprotected final CodeBlock generateCollectionOf(Collection<?> collection,\n\t\t\t\tClass<?> collectionType, ResolvableType elementType) {\n\t\t\tBuilder code = CodeBlock.builder();\n\t\t\tcode.add(\"$T.of(\", collectionType);\n\t\t\tIterator<?> iterator = collection.iterator();\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tObject element = iterator.next();\n\t\t\t\tcode.add(\"$L\", BeanDefinitionPropertyValueCodeGenerator.this\n\t\t\t\t\t\t.generateCodeForElement(element, elementType));\n\t\t\t\tif (iterator.hasNext()) {\n\t\t\t\t\tcode.add(\", \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcode.add(\")\");\n\t\t\treturn code.build();\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,constructorOrFactoryMethod,allowDirectSupplierShortcut)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "constructorOrFactoryMethod",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\tExecutable constructorOrFactoryMethod, boolean allowDirectSupplierShortcut)",
    "source_code": "\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\tExecutable constructorOrFactoryMethod, boolean allowDirectSupplierShortcut) {\n\n\t\treturn new InstanceSupplierCodeGenerator(generationContext,\n\t\t\t\tbeanRegistrationCode.getClassName(), beanRegistrationCode.getMethods(), allowDirectSupplierShortcut)\n\t\t\t\t.generateCode(this.registeredBean, constructorOrFactoryMethod);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateNewBeanDefinitionCode(generationContext,beanType,beanRegistrationCode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanType",
      "beanRegistrationCode"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateNewBeanDefinitionCode(GenerationContext generationContext,\n\t\t\tResolvableType beanType, BeanRegistrationCode beanRegistrationCode)",
    "source_code": "\tpublic CodeBlock generateNewBeanDefinitionCode(GenerationContext generationContext,\n\t\t\tResolvableType beanType, BeanRegistrationCode beanRegistrationCode) {\n\n\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\tcode.addStatement(generateBeanTypeCode(beanType));\n\t\tcode.addStatement(\"$T $L = new $T($L)\", RootBeanDefinition.class,\n\t\t\t\tBEAN_DEFINITION_VARIABLE, RootBeanDefinition.class, BEAN_TYPE_VARIABLE);\n\t\treturn code.build();\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateReturnCode(generationContext,beanRegistrationCode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateReturnCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode)",
    "source_code": "\tpublic CodeBlock generateReturnCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode) {\n\n\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\tcode.addStatement(\"return $L\", BEAN_DEFINITION_VARIABLE);\n\t\treturn code.build();\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateSetBeanDefinitionPropertiesCode(generationContext,beanRegistrationCode,beanDefinition,attributeFilter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "beanDefinition",
      "attributeFilter"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateSetBeanDefinitionPropertiesCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode, RootBeanDefinition beanDefinition,\n\t\t\tPredicate<String> attributeFilter)",
    "source_code": "\tpublic CodeBlock generateSetBeanDefinitionPropertiesCode(\n\t\t\tGenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode, RootBeanDefinition beanDefinition,\n\t\t\tPredicate<String> attributeFilter) {\n\n\t\treturn new BeanDefinitionPropertiesCodeGenerator(\n\t\t\t\tgenerationContext.getRuntimeHints(), attributeFilter,\n\t\t\t\tbeanRegistrationCode.getMethods(),\n\t\t\t\t(name, value) -> generateValueCode(generationContext, name, value))\n\t\t\t\t.generateCode(beanDefinition);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateSetBeanInstanceSupplierCode(generationContext,beanRegistrationCode,instanceSupplierCode,postProcessors)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "instanceSupplierCode",
      "postProcessors"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateSetBeanInstanceSupplierCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode, CodeBlock instanceSupplierCode,\n\t\t\tList<MethodReference> postProcessors)",
    "source_code": "\tpublic CodeBlock generateSetBeanInstanceSupplierCode(\n\t\t\tGenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode, CodeBlock instanceSupplierCode,\n\t\t\tList<MethodReference> postProcessors) {\n\n\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\tif (postProcessors.isEmpty()) {\n\t\t\tcode.addStatement(\"$L.setInstanceSupplier($L)\", BEAN_DEFINITION_VARIABLE, instanceSupplierCode);\n\t\t\treturn code.build();\n\t\t}\n\t\tcode.addStatement(\"$T $L = $L\",\n\t\t\t\tParameterizedTypeName.get(InstanceSupplier.class, this.registeredBean.getBeanClass()),\n\t\t\t\tINSTANCE_SUPPLIER_VARIABLE, instanceSupplierCode);\n\t\tfor (MethodReference postProcessor : postProcessors) {\n\t\t\tcode.addStatement(\"$L = $L.andThen($L)\", INSTANCE_SUPPLIER_VARIABLE,\n\t\t\t\t\tINSTANCE_SUPPLIER_VARIABLE, postProcessor.toCodeBlock());\n\t\t}\n\t\tcode.addStatement(\"$L.setInstanceSupplier($L)\", BEAN_DEFINITION_VARIABLE,\n\t\t\t\tINSTANCE_SUPPLIER_VARIABLE);\n\t\treturn code.build();\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateValueCode(generationContext,name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "generationContext",
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "CodeBlock",
    "signature": "protected CodeBlock generateValueCode(GenerationContext generationContext,\n\t\t\tString name, Object value)",
    "source_code": "\tprotected CodeBlock generateValueCode(GenerationContext generationContext,\n\t\t\tString name, Object value) {\n\n\t\tRegisteredBean innerRegisteredBean = getInnerRegisteredBean(value);\n\t\tif (innerRegisteredBean != null) {\n\t\t\tBeanDefinitionMethodGenerator methodGenerator = this.beanDefinitionMethodGeneratorFactory\n\t\t\t\t\t.getBeanDefinitionMethodGenerator(innerRegisteredBean, name);\n\t\t\tAssert.state(methodGenerator != null, \"Unexpected filtering of inner-bean\");\n\t\t\tMethodReference generatedMethod = methodGenerator\n\t\t\t\t\t.generateBeanDefinitionMethod(generationContext, this.beanRegistrationsCode);\n\t\t\treturn generatedMethod.toInvokeCodeBlock(ArgumentCodeGenerator.none());\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#getTarget(registeredBean,constructorOrFactoryMethod)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "constructorOrFactoryMethod"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "ClassName",
    "signature": "public ClassName getTarget(RegisteredBean registeredBean,\n\t\t\tExecutable constructorOrFactoryMethod)",
    "source_code": "\tpublic ClassName getTarget(RegisteredBean registeredBean,\n\t\t\tExecutable constructorOrFactoryMethod) {\n\n\t\tClass<?> target = extractDeclaringClass(registeredBean.getBeanType(), constructorOrFactoryMethod);\n\t\twhile (target.getName().startsWith(\"java.\") && registeredBean.isInnerBean()) {\n\t\t\tRegisteredBean parent = registeredBean.getParent();\n\t\t\tAssert.state(parent != null, \"No parent available for inner bean\");\n\t\t\ttarget = parent.getBeanClass();\n\t\t}\n\t\treturn ClassName.get(target);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#registerRuntimeHints(runtimeHints,constructor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "constructor"
    ],
    "position": {
      "column": 1,
      "line": 253
    },
    "return": "void",
    "signature": "public void registerRuntimeHints(RuntimeHints runtimeHints, Constructor<?> constructor)",
    "source_code": "\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Constructor<?> constructor) {\n\t\t\tClass<?>[] parameterTypes = constructor.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = new MethodParameter(constructor, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(\n\t\t\t\t\t\tmethodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#registerRuntimeHints(runtimeHints,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "void",
    "signature": "public void registerRuntimeHints(RuntimeHints runtimeHints, Method method)",
    "source_code": "\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Method method) {\n\t\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = new MethodParameter(method, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(methodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#withGenerator(ThrowingBiFunction<RegisteredBean,AutowiredArguments,generator)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new {@link BeanInstanceSupplier} instance that uses the specified\n\t * {@code generator} bi-function to instantiate the underlying bean.\n\t * @param generator a {@link ThrowingBiFunction} that uses the\n\t * {@link RegisteredBean} and resolved {@link AutowiredArguments} to\n\t * instantiate the underlying bean\n\t * @return a new {@link BeanInstanceSupplier} instance with the specified\n\t * generator\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ThrowingBiFunction<RegisteredBean",
      "AutowiredArguments",
      "generator"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "BeanInstanceSupplier<T>",
    "signature": "public BeanInstanceSupplier<T> withGenerator(ThrowingBiFunction<RegisteredBean, AutowiredArguments, T> generator)",
    "source_code": "\tpublic BeanInstanceSupplier<T> withGenerator(\n\t\t\tThrowingBiFunction<RegisteredBean, AutowiredArguments, T> generator) {\n\t\tAssert.notNull(generator, \"'generator' must not be null\");\n\t\treturn new BeanInstanceSupplier<>(this.lookup, generator, this.shortcuts);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#withGenerator(ThrowingFunction<RegisteredBean,generator)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new {@link BeanInstanceSupplier} instance that uses the specified\n\t * {@code generator} function to instantiate the underlying bean.\n\t * @param generator a {@link ThrowingFunction} that uses the\n\t * {@link RegisteredBean} to instantiate the underlying bean\n\t * @return a new {@link BeanInstanceSupplier} instance with the specified\n\t * generator\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ThrowingFunction<RegisteredBean",
      "generator"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "BeanInstanceSupplier<T>",
    "signature": "public BeanInstanceSupplier<T> withGenerator(ThrowingFunction<RegisteredBean, T> generator)",
    "source_code": "\tpublic BeanInstanceSupplier<T> withGenerator(\n\t\t\tThrowingFunction<RegisteredBean, T> generator) {\n\t\tAssert.notNull(generator, \"'generator' must not be null\");\n\t\treturn new BeanInstanceSupplier<>(this.lookup,\n\t\t\t\t(registeredBean, args) -> generator.apply(registeredBean), this.shortcuts);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#addGenericArgumentValue(value,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a generic argument value to be matched by type.\n\t * <p>Note: A single generic argument value will just be used once,\n\t * rather than matched multiple times.\n\t * @param value the argument value\n\t * @param type the type of the constructor argument\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void addGenericArgumentValue(Object value, String type)",
    "source_code": "\tpublic void addGenericArgumentValue(Object value, String type) {\n\t\tthis.genericArgumentValues.add(new ValueHolder(value, type));\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#addIndexedArgumentValue(index,newValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an argument value for the given index in the constructor argument list.\n\t * @param index the index in the constructor argument list\n\t * @param newValue the argument value in the form of a ValueHolder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void addIndexedArgumentValue(int index, ValueHolder newValue)",
    "source_code": "\tpublic void addIndexedArgumentValue(int index, ValueHolder newValue) {\n\t\tAssert.isTrue(index >= 0, \"Index must not be negative\");\n\t\tAssert.notNull(newValue, \"ValueHolder must not be null\");\n\t\taddOrMergeIndexedArgumentValue(index, newValue);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#addIndexedArgumentValue(index,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an argument value for the given index in the constructor argument list.\n\t * @param index the index in the constructor argument list\n\t * @param value the argument value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "void",
    "signature": "public void addIndexedArgumentValue(int index, @Nullable Object value)",
    "source_code": "\tpublic void addIndexedArgumentValue(int index, @Nullable Object value) {\n\t\taddIndexedArgumentValue(index, new ValueHolder(value));\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#addIndexedArgumentValue(index,value,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an argument value for the given index in the constructor argument list.\n\t * @param index the index in the constructor argument list\n\t * @param value the argument value\n\t * @param type the type of the constructor argument\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void addIndexedArgumentValue(int index, @Nullable Object value, String type)",
    "source_code": "\tpublic void addIndexedArgumentValue(int index, @Nullable Object value, String type) {\n\t\taddIndexedArgumentValue(index, new ValueHolder(value, type));\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#addScope(scopeName,scope)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given scope to this configurer's map of scopes.\n\t * @param scopeName the name of the scope\n\t * @param scope the scope implementation\n\t * @since 4.1.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scopeName",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void addScope(String scopeName, Scope scope)",
    "source_code": "\tpublic void addScope(String scopeName, Scope scope) {\n\t\tif (this.scopes == null) {\n\t\t\tthis.scopes = new LinkedHashMap<>(1);\n\t\t}\n\t\tthis.scopes.put(scopeName, scope);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#createServiceLocatorException(exceptionConstructor,cause)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a service locator exception for the given cause.\n\t * Only called in case of a custom service locator exception.\n\t * <p>The default implementation can handle all variations of\n\t * message and exception arguments.\n\t * @param exceptionConstructor the constructor to use\n\t * @param cause the cause of the service lookup failure\n\t * @return the service locator exception to throw\n\t * @see #setServiceLocatorExceptionClass\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exceptionConstructor",
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "Exception",
    "signature": "protected Exception createServiceLocatorException(Constructor<Exception> exceptionConstructor, BeansException cause)",
    "source_code": "\tprotected Exception createServiceLocatorException(Constructor<Exception> exceptionConstructor, BeansException cause) {\n\t\tClass<?>[] paramTypes = exceptionConstructor.getParameterTypes();\n\t\tObject[] args = new Object[paramTypes.length];\n\t\tfor (int i = 0; i < paramTypes.length; i++) {\n\t\t\tif (String.class == paramTypes[i]) {\n\t\t\t\targs[i] = cause.getMessage();\n\t\t\t}\n\t\t\telse if (paramTypes[i].isInstance(cause)) {\n\t\t\t\targs[i] = cause;\n\t\t\t}\n\t\t}\n\t\treturn BeanUtils.instantiateClass(exceptionConstructor, args);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getArgumentValue(index,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look for an argument value that either corresponds to the given index\n\t * in the constructor argument list or generically matches by type.\n\t * @param index the index in the constructor argument list\n\t * @param requiredType the parameter type to match\n\t * @return the ValueHolder for the argument, or {@code null} if none set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getArgumentValue(int index, Class<?> requiredType)",
    "source_code": "\tpublic ValueHolder getArgumentValue(int index, Class<?> requiredType) {\n\t\treturn getArgumentValue(index, requiredType, null, null);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getArgumentValue(index,requiredType,requiredName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look for an argument value that either corresponds to the given index\n\t * in the constructor argument list or generically matches by type.\n\t * @param index the index in the constructor argument list\n\t * @param requiredType the parameter type to match\n\t * @param requiredName the parameter name to match\n\t * @return the ValueHolder for the argument, or {@code null} if none set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "requiredType",
      "requiredName"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getArgumentValue(int index, Class<?> requiredType, String requiredName)",
    "source_code": "\tpublic ValueHolder getArgumentValue(int index, Class<?> requiredType, String requiredName) {\n\t\treturn getArgumentValue(index, requiredType, requiredName, null);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getArgumentValue(index,requiredType,requiredName,usedValueHolders)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look for an argument value that either corresponds to the given index\n\t * in the constructor argument list or generically matches by type.\n\t * @param index the index in the constructor argument list\n\t * @param requiredType the parameter type to match (can be {@code null}\n\t * to find an untyped argument value)\n\t * @param requiredName the parameter name to match (can be {@code null}\n\t * to find an unnamed argument value, or empty String to match any name)\n\t * @param usedValueHolders a Set of ValueHolder objects that have already\n\t * been used in the current resolution process and should therefore not\n\t * be returned again (allowing to return the next generic argument match\n\t * in case of multiple generic argument values of the same type)\n\t * @return the ValueHolder for the argument, or {@code null} if none set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "requiredType",
      "requiredName",
      "usedValueHolders"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getArgumentValue(int index, @Nullable Class<?> requiredType,\n\t\t\t@Nullable String requiredName, @Nullable Set<ValueHolder> usedValueHolders)",
    "source_code": "\tpublic ValueHolder getArgumentValue(int index, @Nullable Class<?> requiredType,\n\t\t\t@Nullable String requiredName, @Nullable Set<ValueHolder> usedValueHolders) {\n\n\t\tAssert.isTrue(index >= 0, \"Index must not be negative\");\n\t\tValueHolder valueHolder = getIndexedArgumentValue(index, requiredType, requiredName);\n\t\tif (valueHolder == null) {\n\t\t\tvalueHolder = getGenericArgumentValue(requiredType, requiredName, usedValueHolders);\n\t\t}\n\t\treturn valueHolder;\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getFlattenedMap(Map<String,source)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a flattened version of the given map, recursively following any nested Map\n\t * or Collection values. Entries from the resulting map retain the same order as the\n\t * source. When called with the Map from a {@link MatchCallback} the result will\n\t * contain the same values as the {@link MatchCallback} Properties.\n\t * @param source the source map\n\t * @return a flattened map\n\t * @since 4.1.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "Object>",
    "signature": "protected Object> getFlattenedMap(Map<String, Object> source)",
    "source_code": "\tprotected final Map<String, Object> getFlattenedMap(Map<String, Object> source) {\n\t\tMap<String, Object> result = new LinkedHashMap<>();\n\t\tbuildFlattenedMap(result, source, null);\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getGenericArgumentValue(requiredType,requiredName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look for a generic argument value that matches the given type.\n\t * @param requiredType the type to match\n\t * @param requiredName the name to match\n\t * @return the ValueHolder for the argument, or {@code null} if none set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "requiredName"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getGenericArgumentValue(Class<?> requiredType, String requiredName)",
    "source_code": "\tpublic ValueHolder getGenericArgumentValue(Class<?> requiredType, String requiredName) {\n\t\treturn getGenericArgumentValue(requiredType, requiredName, null);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getGenericArgumentValue(requiredType,requiredName,usedValueHolders)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look for the next generic argument value that matches the given type,\n\t * ignoring argument values that have already been used in the current\n\t * resolution process.\n\t * @param requiredType the type to match (can be {@code null} to find\n\t * an arbitrary next generic argument value)\n\t * @param requiredName the name to match (can be {@code null} to not\n\t * match argument values by name, or empty String to match any name)\n\t * @param usedValueHolders a Set of ValueHolder objects that have already been used\n\t * in the current resolution process and should therefore not be returned again\n\t * @return the ValueHolder for the argument, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "requiredName",
      "usedValueHolders"
    ],
    "position": {
      "column": 1,
      "line": 278
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getGenericArgumentValue(@Nullable Class<?> requiredType, @Nullable String requiredName,\n\t\t\t@Nullable Set<ValueHolder> usedValueHolders)",
    "source_code": "\tpublic ValueHolder getGenericArgumentValue(@Nullable Class<?> requiredType, @Nullable String requiredName,\n\t\t\t@Nullable Set<ValueHolder> usedValueHolders) {\n\n\t\tfor (ValueHolder valueHolder : this.genericArgumentValues) {\n\t\t\tif (usedValueHolders != null && usedValueHolders.contains(valueHolder)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (valueHolder.getName() != null && (requiredName == null ||\n\t\t\t\t\t(!requiredName.isEmpty() && !requiredName.equals(valueHolder.getName())))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (valueHolder.getType() != null && (requiredType == null ||\n\t\t\t\t\t!ClassUtils.matchesTypeName(requiredType, valueHolder.getType()))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (requiredType != null && valueHolder.getType() == null && valueHolder.getName() == null &&\n\t\t\t\t\t!ClassUtils.isAssignableValue(requiredType, valueHolder.getValue())) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn valueHolder;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getIndexedArgumentValue(index,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get argument value for the given index in the constructor argument list.\n\t * @param index the index in the constructor argument list\n\t * @param requiredType the type to match (can be {@code null} to match\n\t * untyped values only)\n\t * @return the ValueHolder for the argument, or {@code null} if none set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getIndexedArgumentValue(int index, @Nullable Class<?> requiredType)",
    "source_code": "\tpublic ValueHolder getIndexedArgumentValue(int index, @Nullable Class<?> requiredType) {\n\t\treturn getIndexedArgumentValue(index, requiredType, null);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getIndexedArgumentValue(index,requiredType,requiredName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get argument value for the given index in the constructor argument list.\n\t * @param index the index in the constructor argument list\n\t * @param requiredType the type to match (can be {@code null} to match\n\t * untyped values only)\n\t * @param requiredName the type to match (can be {@code null} to match\n\t * unnamed values only, or empty String to match any name)\n\t * @return the ValueHolder for the argument, or {@code null} if none set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "requiredType",
      "requiredName"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getIndexedArgumentValue(int index, @Nullable Class<?> requiredType, @Nullable String requiredName)",
    "source_code": "\tpublic ValueHolder getIndexedArgumentValue(int index, @Nullable Class<?> requiredType, @Nullable String requiredName) {\n\t\tAssert.isTrue(index >= 0, \"Index must not be negative\");\n\t\tValueHolder valueHolder = this.indexedArgumentValues.get(index);\n\t\tif (valueHolder != null &&\n\t\t\t\t(valueHolder.getType() == null || (requiredType != null &&\n\t\t\t\t\t\tClassUtils.matchesTypeName(requiredType, valueHolder.getType()))) &&\n\t\t\t\t(valueHolder.getName() == null || (requiredName != null &&\n\t\t\t\t\t\t(requiredName.isEmpty() || requiredName.equals(valueHolder.getName()))))) {\n\t\t\treturn valueHolder;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getMostSpecific(a,b)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Compare two {@link MatchStatus} items, returning the most specific status.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "a",
      "b"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "MatchStatus",
    "signature": "public MatchStatus getMostSpecific(MatchStatus a, MatchStatus b)",
    "source_code": "\t\tpublic static MatchStatus getMostSpecific(MatchStatus a, MatchStatus b) {\n\t\t\treturn (a.ordinal() < b.ordinal() ? a : b);\n\t\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tif (ReflectionUtils.isEqualsMethod(method)) {\n\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\treturn (proxy == args[0]);\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isHashCodeMethod(method)) {\n\t\t\t\t// Use hashCode of service locator proxy.\n\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isToStringMethod(method)) {\n\t\t\t\treturn \"Service locator: \" + serviceLocatorInterface;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn invokeServiceLocatorMethod(method, args);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#setScopes(Map<String,scopes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the custom scopes that are to be registered.\n\t * <p>The keys indicate the scope names (of type String); each value\n\t * is expected to be the corresponding custom {@link Scope} instance\n\t * or class name.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "scopes"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void setScopes(Map<String, Object> scopes)",
    "source_code": "\tpublic void setScopes(Map<String, Object> scopes) {\n\t\tthis.scopes = scopes;\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#visitIndexedArgumentValues(Map<Integer,ias)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<Integer",
      "ias"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "protected void visitIndexedArgumentValues(Map<Integer, ConstructorArgumentValues.ValueHolder> ias)",
    "source_code": "\tprotected void visitIndexedArgumentValues(Map<Integer, ConstructorArgumentValues.ValueHolder> ias) {\n\t\tfor (ConstructorArgumentValues.ValueHolder valueHolder : ias.values()) {\n\t\t\tObject newVal = resolveValue(valueHolder.getValue());\n\t\t\tif (!ObjectUtils.nullSafeEquals(newVal, valueHolder.getValue())) {\n\t\t\t\tvalueHolder.setValue(newVal);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#visitMap(Map<?,mapVal)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<?",
      "mapVal"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "void",
    "signature": "protected void visitMap(Map<?, ?> mapVal)",
    "source_code": "\tprotected void visitMap(Map<?, ?> mapVal) {\n\t\tMap newContent = new LinkedHashMap();\n\t\tboolean entriesModified = false;\n\t\tfor (Map.Entry entry : mapVal.entrySet()) {\n\t\t\tObject key = entry.getKey();\n\t\t\tint keyHash = (key != null ? key.hashCode() : 0);\n\t\t\tObject newKey = resolveValue(key);\n\t\t\tint newKeyHash = (newKey != null ? newKey.hashCode() : 0);\n\t\t\tObject val = entry.getValue();\n\t\t\tObject newVal = resolveValue(val);\n\t\t\tnewContent.put(newKey, newVal);\n\t\t\tentriesModified = entriesModified || (newVal != val || newKey != key || newKeyHash != keyHash);\n\t\t}\n\t\tif (entriesModified) {\n\t\t\tmapVal.clear();\n\t\t\tmapVal.putAll(newContent);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#addProperty(propertyName,propertyValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "propertyValue"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "GroovyBeanDefinitionWrapper",
    "signature": "public GroovyBeanDefinitionWrapper addProperty(String propertyName, Object propertyValue)",
    "source_code": "\tpublic GroovyBeanDefinitionWrapper addProperty(String propertyName, Object propertyValue) {\n\t\tif (propertyValue instanceof GroovyBeanDefinitionWrapper wrapper) {\n\t\t\tpropertyValue = wrapper.getBeanDefinition();\n\t\t}\n\t\tgetBeanDefinition().getPropertyValues().add(propertyName, propertyValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#applyPropertyToBeanDefinition(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 613
    },
    "return": "void",
    "signature": "protected void applyPropertyToBeanDefinition(String name, Object value)",
    "source_code": "\tprotected void applyPropertyToBeanDefinition(String name, Object value) {\n\t\tif (value instanceof GString) {\n\t\t\tvalue = value.toString();\n\t\t}\n\t\tif (addDeferredProperty(name, value)) {\n\t\t\treturn;\n\t\t}\n\t\telse if (value instanceof Closure<?> callable) {\n\t\t\tGroovyBeanDefinitionWrapper current = this.currentBeanDefinition;\n\t\t\ttry {\n\t\t\t\tClass<?> parameterType = callable.getParameterTypes()[0];\n\t\t\t\tif (Object.class == parameterType) {\n\t\t\t\t\tthis.currentBeanDefinition = new GroovyBeanDefinitionWrapper(\"\");\n\t\t\t\t\tcallable.call(this.currentBeanDefinition);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.currentBeanDefinition = new GroovyBeanDefinitionWrapper(null, parameterType);\n\t\t\t\t\tcallable.call((Object) null);\n\t\t\t\t}\n\n\t\t\t\tvalue = this.currentBeanDefinition.getBeanDefinition();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.currentBeanDefinition = current;\n\t\t\t}\n\t\t}\n\t\tthis.currentBeanDefinition.addProperty(name, value);\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#bean(type,Object...args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Define an inner bean definition.\n\t * @param type the bean type\n\t * @param args the constructors arguments and closure configurer\n\t * @return the bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Object...args"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "AbstractBeanDefinition",
    "signature": "public AbstractBeanDefinition bean(Class<?> type, Object...args)",
    "source_code": "\tpublic AbstractBeanDefinition bean(Class<?> type, Object...args) {\n\t\tGroovyBeanDefinitionWrapper current = this.currentBeanDefinition;\n\t\ttry {\n\t\t\tClosure<?> callable = null;\n\t\t\tCollection<Object> constructorArgs = null;\n\t\t\tif (!ObjectUtils.isEmpty(args)) {\n\t\t\t\tint index = args.length;\n\t\t\t\tObject lastArg = args[index - 1];\n\t\t\t\tif (lastArg instanceof Closure<?> closure) {\n\t\t\t\t\tcallable = closure;\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\tconstructorArgs = resolveConstructorArguments(args, 0, index);\n\t\t\t}\n\t\t\tthis.currentBeanDefinition = new GroovyBeanDefinitionWrapper(null, type, constructorArgs);\n\t\t\tif (callable != null) {\n\t\t\t\tcallable.call(this.currentBeanDefinition);\n\t\t\t}\n\t\t\treturn this.currentBeanDefinition.getBeanDefinition();\n\t\t}\n\t\tfinally {\n\t\t\tthis.currentBeanDefinition = current;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#invokeMethod(name,arg)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This method overrides method invocation to create beans for each method name that\n\t * takes a class argument.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "arg"
    ],
    "position": {
      "column": 1,
      "line": 378
    },
    "return": "Object",
    "signature": "public Object invokeMethod(String name, Object arg)",
    "source_code": "\tpublic Object invokeMethod(String name, Object arg) {\n\t\tObject[] args = (Object[])arg;\n\t\tif (\"beans\".equals(name) && args.length == 1 && args[0] instanceof Closure<?> closure) {\n\t\t\treturn beans(closure);\n\t\t}\n\t\telse if (\"ref\".equals(name)) {\n\t\t\tString refName;\n\t\t\tif (args[0] == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Argument to ref() is not a valid bean or was not found\");\n\t\t\t}\n\t\t\tif (args[0] instanceof RuntimeBeanReference runtimeBeanReference) {\n\t\t\t\trefName = runtimeBeanReference.getBeanName();\n\t\t\t}\n\t\t\telse {\n\t\t\t\trefName = args[0].toString();\n\t\t\t}\n\t\t\tboolean parentRef = false;\n\t\t\tif (args.length > 1 && args[1] instanceof Boolean bool) {\n\t\t\t\tparentRef = bool;\n\t\t\t}\n\t\t\treturn new RuntimeBeanReference(refName, parentRef);\n\t\t}\n\t\telse if (this.namespaces.containsKey(name) && args.length > 0 && args[0] instanceof Closure) {\n\t\t\tGroovyDynamicElementReader reader = createDynamicElementReader(name);\n\t\t\treader.invokeMethod(\"doCall\", args);\n\t\t}\n\t\telse if (args.length > 0 && args[0] instanceof Closure) {\n\t\t\t// abstract bean definition\n\t\t\treturn invokeBeanDefiningMethod(name, args);\n\t\t}\n\t\telse if (args.length > 0 &&\n\t\t\t\t(args[0] instanceof Class || args[0] instanceof RuntimeBeanReference || args[0] instanceof Map)) {\n\t\t\treturn invokeBeanDefiningMethod(name, args);\n\t\t}\n\t\telse if (args.length > 1 && args[args.length -1] instanceof Closure) {\n\t\t\treturn invokeBeanDefiningMethod(name, args);\n\t\t}\n\t\tMetaClass mc = DefaultGroovyMethods.getMetaClass(getRegistry());\n\t\tif (!mc.respondsTo(getRegistry(), name, args).isEmpty()){\n\t\t\treturn mc.invokeMethod(getRegistry(), name, args);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#invokeMethod(name,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 833
    },
    "return": "Object",
    "signature": "public Object invokeMethod(String name, Object args)",
    "source_code": "\t\t\tpublic Object invokeMethod(String name, Object args) {\n\t\t\t\treturn InvokerHelper.invokeMethod(this.propertyValue, name, args);\n\t\t\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#invokeMethod(name,obj)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "Object",
    "signature": "public Object invokeMethod(String name, Object obj)",
    "source_code": "\tpublic Object invokeMethod(String name, Object obj) {\n\t\tObject[] args = (Object[]) obj;\n\t\tif (name.equals(\"doCall\")) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tClosure<Object> callable = (Closure<Object>) args[0];\n\t\t\tcallable.setResolveStrategy(Closure.DELEGATE_FIRST);\n\t\t\tcallable.setDelegate(this);\n\t\t\tObject result = callable.call();\n\n\t\t\tif (this.callAfterInvocation) {\n\t\t\t\tafterInvocation();\n\t\t\t\tthis.callAfterInvocation = false;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\telse {\n\t\t\tStreamingMarkupBuilder builder = new StreamingMarkupBuilder();\n\t\t\tString myNamespace = this.rootNamespace;\n\t\t\tMap<String, String> myNamespaces = this.xmlNamespaces;\n\n\t\t\tClosure<Object> callable = new Closure<>(this) {\n\t\t\t\t@Override\n\t\t\t\tpublic Object call(Object... arguments) {\n\t\t\t\t\t((GroovyObject) getProperty(\"mkp\")).invokeMethod(\"declareNamespace\", new Object[] {myNamespaces});\n\t\t\t\t\tint len = args.length;\n\t\t\t\t\tif (len > 0 && args[len-1] instanceof Closure<?> callable) {\n\t\t\t\t\t\tcallable.setResolveStrategy(Closure.DELEGATE_FIRST);\n\t\t\t\t\t\tcallable.setDelegate(builder);\n\t\t\t\t\t}\n\t\t\t\t\treturn ((GroovyObject) ((GroovyObject) getDelegate()).getProperty(myNamespace)).invokeMethod(name, args);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tcallable.setResolveStrategy(Closure.DELEGATE_FIRST);\n\t\t\tcallable.setDelegate(builder);\n\t\t\tWritable writable = (Writable) builder.bind(callable);\n\t\t\tStringWriter sw = new StringWriter();\n\t\t\ttry {\n\t\t\t\twritable.writeTo(sw);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\n\t\t\tElement element = this.delegate.getReaderContext().readDocumentFromString(sw.toString()).getDocumentElement();\n\t\t\tthis.delegate.initDefaults(element);\n\t\t\tif (this.decorating) {\n\t\t\t\tBeanDefinitionHolder holder = this.beanDefinition.getBeanDefinitionHolder();\n\t\t\t\tholder = this.delegate.decorateIfRequired(element, holder, null);\n\t\t\t\tthis.beanDefinition.setBeanDefinitionHolder(holder);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tBeanDefinition beanDefinition = this.delegate.parseCustomElement(element);\n\t\t\t\tif (beanDefinition != null) {\n\t\t\t\t\tthis.beanDefinition.setBeanDefinition((AbstractBeanDefinition) beanDefinition);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.callAfterInvocation) {\n\t\t\t\tafterInvocation();\n\t\t\t\tthis.callAfterInvocation = false;\n\t\t\t}\n\t\t\treturn element;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#resolveConstructorArguments(args,start,end)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "args",
      "start",
      "end"
    ],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "List<Object>",
    "signature": "protected List<Object> resolveConstructorArguments(Object[] args, int start, int end)",
    "source_code": "\tprotected List<Object> resolveConstructorArguments(Object[] args, int start, int end) {\n\t\tObject[] constructorArgs = Arrays.copyOfRange(args, start, end);\n\t\tfor (int i = 0; i < constructorArgs.length; i++) {\n\t\t\tif (constructorArgs[i] instanceof GString) {\n\t\t\t\tconstructorArgs[i] = constructorArgs[i].toString();\n\t\t\t}\n\t\t\telse if (constructorArgs[i] instanceof List<?> list) {\n\t\t\t\tconstructorArgs[i] = manageListIfNecessary(list);\n\t\t\t}\n\t\t\telse if (constructorArgs[i] instanceof Map<?, ?> map){\n\t\t\t\tconstructorArgs[i] = manageMapIfNecessary(map);\n\t\t\t}\n\t\t}\n\t\treturn List.of(constructorArgs);\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#setProperty(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 843
    },
    "return": "void",
    "signature": "public void setProperty(String name, Object value)",
    "source_code": "\t\t\tpublic void setProperty(String name, Object value) {\n\t\t\t\tInvokerHelper.setProperty(this.propertyValue, name, value);\n\t\t\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#setProperty(property,newValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "property",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 788
    },
    "return": "void",
    "signature": "public void setProperty(String property, Object newValue)",
    "source_code": "\t\tpublic void setProperty(String property, Object newValue) {\n\t\t\tif (!addDeferredProperty(property, newValue)) {\n\t\t\t\tthis.beanDefinition.getBeanDefinition().getPropertyValues().add(property, newValue);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#setVariable(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "void",
    "signature": "public void setVariable(String name, Object value)",
    "source_code": "\t\t\tpublic void setVariable(String name, Object value) {\n\t\t\t\tif (currentBeanDefinition != null) {\n\t\t\t\t\tapplyPropertyToBeanDefinition(name, value);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsuper.setVariable(name, value);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#xmlns(Map<String,definition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Define a Spring XML namespace definition to use.\n\t * @param definition the namespace definition\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 342
    },
    "return": "void",
    "signature": "public void xmlns(Map<String, String> definition)",
    "source_code": "\tpublic void xmlns(Map<String, String> definition) {\n\t\tif (!definition.isEmpty()) {\n\t\t\tfor (Map.Entry<String,String> entry : definition.entrySet()) {\n\t\t\t\tString namespace = entry.getKey();\n\t\t\t\tString uri = entry.getValue();\n\t\t\t\tif (uri == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Namespace definition must supply a non-null URI\");\n\t\t\t\t}\n\t\t\t\tNamespaceHandler namespaceHandler =\n\t\t\t\t\t\tthis.groovyDslXmlBeanDefinitionReader.getNamespaceHandlerResolver().resolve(uri);\n\t\t\t\tif (namespaceHandler == null) {\n\t\t\t\t\tthrow new BeanDefinitionParsingException(new Problem(\"No namespace handler found for URI: \" + uri,\n\t\t\t\t\t\t\tnew Location(new DescriptiveResource((\"Groovy\")))));\n\t\t\t\t}\n\t\t\t\tthis.namespaces.put(namespace, uri);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#add(index,element)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 1968
    },
    "return": "void",
    "signature": "public void add(int index, BeanPostProcessor element)",
    "source_code": "\t\tpublic void add(int index, BeanPostProcessor element) {\n\t\t\tsuper.add(index, element);\n\t\t\tresetBeanPostProcessorCache();\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#addAll(index,c)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "c"
    ],
    "position": {
      "column": 1,
      "line": 2017
    },
    "return": "boolean",
    "signature": "public boolean addAll(int index, Collection<? extends BeanPostProcessor> c)",
    "source_code": "\t\tpublic boolean addAll(int index, Collection<? extends BeanPostProcessor> c) {\n\t\t\tboolean success = super.addAll(index, c);\n\t\t\tif (success) {\n\t\t\t\tresetBeanPostProcessorCache();\n\t\t\t}\n\t\t\treturn success;\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#addBean(name,bean)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a new singleton bean.\n\t * <p>Will overwrite any existing instance for the given name.\n\t * @param name the name of the bean\n\t * @param bean the bean instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void addBean(String name, Object bean)",
    "source_code": "\tpublic void addBean(String name, Object bean) {\n\t\tthis.beans.put(name, bean);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#applyBeanPostProcessorsAfterInitialization(existingBean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 431
    },
    "return": "Object",
    "signature": "public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)",
    "source_code": "\tpublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)\n\t\t\tthrows BeansException {\n\n\t\tObject result = existingBean;\n\t\tfor (BeanPostProcessor processor : getBeanPostProcessors()) {\n\t\t\tObject current = processor.postProcessAfterInitialization(result, beanName);\n\t\t\tif (current == null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = current;\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#applyBeanPostProcessorsBeforeInitialization(existingBean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 416
    },
    "return": "Object",
    "signature": "public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)",
    "source_code": "\tpublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)\n\t\t\tthrows BeansException {\n\n\t\tObject result = existingBean;\n\t\tfor (BeanPostProcessor processor : getBeanPostProcessors()) {\n\t\t\tObject current = processor.postProcessBeforeInitialization(result, beanName);\n\t\t\tif (current == null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = current;\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#applyBeanPostProcessorsBeforeInstantiation(beanClass,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply InstantiationAwareBeanPostProcessors to the specified bean definition\n\t * (by class and name), invoking their {@code postProcessBeforeInstantiation} methods.\n\t * <p>Any returned object will be used as the bean instead of actually instantiating\n\t * the target bean. A {@code null} return value from the post-processor will\n\t * result in the target bean being instantiated.\n\t * @param beanClass the class of the bean to be instantiated\n\t * @param beanName the name of the bean\n\t * @return the bean object to use instead of a default instance of the target bean, or {@code null}\n\t * @see InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 1125
    },
    "return": "Object",
    "signature": "protected Object applyBeanPostProcessorsBeforeInstantiation(Class<?> beanClass, String beanName)",
    "source_code": "\tprotected Object applyBeanPostProcessorsBeforeInstantiation(Class<?> beanClass, String beanName) {\n\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\tObject result = bp.postProcessBeforeInstantiation(beanClass, beanName);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#applyBeanPropertyValues(existingBean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 402
    },
    "return": "void",
    "signature": "public void applyBeanPropertyValues(Object existingBean, String beanName)",
    "source_code": "\tpublic void applyBeanPropertyValues(Object existingBean, String beanName) throws BeansException {\n\t\tmarkBeanAsCreated(beanName);\n\t\tBeanDefinition bd = getMergedBeanDefinition(beanName);\n\t\tBeanWrapper bw = new BeanWrapperImpl(existingBean);\n\t\tinitBeanWrapper(bw);\n\t\tapplyPropertyValues(beanName, bd, bw, bd.getPropertyValues());\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#applyMergedBeanDefinitionPostProcessors(mbd,beanType,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply MergedBeanDefinitionPostProcessors to the specified bean definition,\n\t * invoking their {@code postProcessMergedBeanDefinition} methods.\n\t * @param mbd the merged bean definition for the bean\n\t * @param beanType the actual type of the managed bean instance\n\t * @param beanName the name of the bean\n\t * @see MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mbd",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 1081
    },
    "return": "void",
    "signature": "protected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class<?> beanType, String beanName)",
    "source_code": "\tprotected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class<?> beanType, String beanName) {\n\t\tfor (MergedBeanDefinitionPostProcessor processor : getBeanPostProcessorCache().mergedDefinition) {\n\t\t\tprocessor.postProcessMergedBeanDefinition(mbd, beanType, beanName);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#applyPropertyValues(beanName,mbd,bw,pvs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given property values, resolving any runtime references\n\t * to other beans in this bean factory. Must use deep copy, so we\n\t * don't permanently modify this property.\n\t * @param beanName the bean name passed for better exception information\n\t * @param mbd the merged bean definition\n\t * @param bw the BeanWrapper wrapping the target object\n\t * @param pvs the new property values\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "bw",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 1614
    },
    "return": "void",
    "signature": "protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)",
    "source_code": "\tprotected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {\n\t\tif (pvs.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tMutablePropertyValues mpvs = null;\n\t\tList<PropertyValue> original;\n\n\t\tif (pvs instanceof MutablePropertyValues _mpvs) {\n\t\t\tmpvs = _mpvs;\n\t\t\tif (mpvs.isConverted()) {\n\t\t\t\t// Shortcut: use the pre-converted values as-is.\n\t\t\t\ttry {\n\t\t\t\t\tbw.setPropertyValues(mpvs);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Error setting property values\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\toriginal = mpvs.getPropertyValueList();\n\t\t}\n\t\telse {\n\t\t\toriginal = Arrays.asList(pvs.getPropertyValues());\n\t\t}\n\n\t\tTypeConverter converter = getCustomTypeConverter();\n\t\tif (converter == null) {\n\t\t\tconverter = bw;\n\t\t}\n\t\tBeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);\n\n\t\t// Create a deep copy, resolving any references for values.\n\t\tList<PropertyValue> deepCopy = new ArrayList<>(original.size());\n\t\tboolean resolveNecessary = false;\n\t\tfor (PropertyValue pv : original) {\n\t\t\tif (pv.isConverted()) {\n\t\t\t\tdeepCopy.add(pv);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString propertyName = pv.getName();\n\t\t\t\tObject originalValue = pv.getValue();\n\t\t\t\tif (originalValue == AutowiredPropertyMarker.INSTANCE) {\n\t\t\t\t\tMethod writeMethod = bw.getPropertyDescriptor(propertyName).getWriteMethod();\n\t\t\t\t\tif (writeMethod == null) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Autowire marker for property without write method: \" + pv);\n\t\t\t\t\t}\n\t\t\t\t\toriginalValue = new DependencyDescriptor(new MethodParameter(writeMethod, 0), true);\n\t\t\t\t}\n\t\t\t\tObject resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);\n\t\t\t\tObject convertedValue = resolvedValue;\n\t\t\t\tboolean convertible = bw.isWritableProperty(propertyName) &&\n\t\t\t\t\t\t!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);\n\t\t\t\tif (convertible) {\n\t\t\t\t\tconvertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);\n\t\t\t\t}\n\t\t\t\t// Possibly store converted value in merged bean definition,\n\t\t\t\t// in order to avoid re-conversion for every created bean instance.\n\t\t\t\tif (resolvedValue == originalValue) {\n\t\t\t\t\tif (convertible) {\n\t\t\t\t\t\tpv.setConvertedValue(convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tdeepCopy.add(pv);\n\t\t\t\t}\n\t\t\t\telse if (convertible && originalValue instanceof TypedStringValue typedStringValue &&\n\t\t\t\t\t\t!typedStringValue.isDynamic() &&\n\t\t\t\t\t\t!(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {\n\t\t\t\t\tpv.setConvertedValue(convertedValue);\n\t\t\t\t\tdeepCopy.add(pv);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresolveNecessary = true;\n\t\t\t\t\tdeepCopy.add(new PropertyValue(pv, convertedValue));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (mpvs != null && !resolveNecessary) {\n\t\t\tmpvs.setConverted();\n\t\t}\n\n\t\t// Set our (possibly massaged) deep copy.\n\t\ttry {\n\t\t\tbw.setPropertyValues(new MutablePropertyValues(deepCopy));\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#autowire(beanClass,autowireMode,dependencyCheck)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 371
    },
    "return": "Object",
    "signature": "public Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck)",
    "source_code": "\tpublic Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck) throws BeansException {\n\t\t// Use non-singleton bean definition, to avoid registering bean as dependent bean.\n\t\tRootBeanDefinition bd = new RootBeanDefinition(beanClass, autowireMode, dependencyCheck);\n\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\tif (bd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR) {\n\t\t\treturn autowireConstructor(beanClass.getName(), bd, null, null).getWrappedInstance();\n\t\t}\n\t\telse {\n\t\t\tObject bean = getInstantiationStrategy().instantiate(bd, null, this);\n\t\t\tpopulateBean(beanClass.getName(), bd, new BeanWrapperImpl(bean));\n\t\t\treturn bean;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#autowireBeanProperties(existingBean,autowireMode,dependencyCheck)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "void",
    "signature": "public void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)",
    "source_code": "\tpublic void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)\n\t\t\tthrows BeansException {\n\n\t\tif (autowireMode == AUTOWIRE_CONSTRUCTOR) {\n\t\t\tthrow new IllegalArgumentException(\"AUTOWIRE_CONSTRUCTOR not supported for existing bean instance\");\n\t\t}\n\t\t// Use non-singleton bean definition, to avoid registering bean as dependent bean.\n\t\tRootBeanDefinition bd =\n\t\t\t\tnew RootBeanDefinition(ClassUtils.getUserClass(existingBean), autowireMode, dependencyCheck);\n\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\tBeanWrapper bw = new BeanWrapperImpl(existingBean);\n\t\tinitBeanWrapper(bw);\n\t\tpopulateBean(bd.getBeanClass().getName(), bd, bw);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#autowireByName(beanName,mbd,bw,pvs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Fill in any missing property values with references to\n\t * other beans in this factory if autowire is set to \"byName\".\n\t * @param beanName the name of the bean we're wiring up.\n\t * Useful for debugging messages; not used functionally.\n\t * @param mbd bean definition to update through autowiring\n\t * @param bw the BeanWrapper from which we can obtain information about the bean\n\t * @param pvs the PropertyValues to register wired objects with\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "bw",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 1426
    },
    "return": "void",
    "signature": "protected void autowireByName(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)",
    "source_code": "\tprotected void autowireByName(\n\t\t\tString beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {\n\n\t\tString[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n\t\tfor (String propertyName : propertyNames) {\n\t\t\tif (containsBean(propertyName)) {\n\t\t\t\tObject bean = getBean(propertyName);\n\t\t\t\tpvs.add(propertyName, bean);\n\t\t\t\tregisterDependentBean(propertyName, beanName);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Added autowiring by name from bean name '\" + beanName +\n\t\t\t\t\t\t\t\"' via property '\" + propertyName + \"' to bean named '\" + propertyName + \"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Not autowiring property '\" + propertyName + \"' of bean '\" + beanName +\n\t\t\t\t\t\t\t\"' by name: no matching bean found\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#autowireByType(beanName,mbd,bw,pvs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract method defining \"autowire by type\" (bean properties by type) behavior.\n\t * <p>This is like PicoContainer default, in which there must be exactly one bean\n\t * of the property type in the bean factory. This makes bean factories simple to\n\t * configure for small namespaces, but doesn't work as well as standard Spring\n\t * behavior for bigger applications.\n\t * @param beanName the name of the bean to autowire by type\n\t * @param mbd the merged bean definition to update through autowiring\n\t * @param bw the BeanWrapper from which we can obtain information about the bean\n\t * @param pvs the PropertyValues to register wired objects with\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "bw",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 1460
    },
    "return": "void",
    "signature": "protected void autowireByType(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)",
    "source_code": "\tprotected void autowireByType(\n\t\t\tString beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {\n\n\t\tTypeConverter converter = getCustomTypeConverter();\n\t\tif (converter == null) {\n\t\t\tconverter = bw;\n\t\t}\n\n\t\tSet<String> autowiredBeanNames = new LinkedHashSet<>(4);\n\t\tString[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n\t\tfor (String propertyName : propertyNames) {\n\t\t\ttry {\n\t\t\t\tPropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);\n\t\t\t\t// Don't try autowiring by type for type Object: never makes sense,\n\t\t\t\t// even if it technically is an unsatisfied, non-simple property.\n\t\t\t\tif (Object.class != pd.getPropertyType()) {\n\t\t\t\t\tMethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);\n\t\t\t\t\t// Do not allow eager init for type matching in case of a prioritized post-processor.\n\t\t\t\t\tboolean eager = !(bw.getWrappedInstance() instanceof PriorityOrdered);\n\t\t\t\t\tDependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);\n\t\t\t\t\tObject autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);\n\t\t\t\t\tif (autowiredArgument != null) {\n\t\t\t\t\t\tpvs.add(propertyName, autowiredArgument);\n\t\t\t\t\t}\n\t\t\t\t\tfor (String autowiredBeanName : autowiredBeanNames) {\n\t\t\t\t\t\tregisterDependentBean(autowiredBeanName, beanName);\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Autowiring by type from bean name '\" + beanName + \"' via property '\" +\n\t\t\t\t\t\t\t\t\tpropertyName + \"' to bean named '\" + autowiredBeanName + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tautowiredBeanNames.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (BeansException ex) {\n\t\t\t\tthrow new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#autowireConstructor(beanName,mbd,chosenCtors,explicitArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * \"autowire constructor\" (with constructor arguments by type) behavior.\n\t * Also applied if explicit constructor argument values are specified,\n\t * matching all remaining arguments with beans from the bean factory.\n\t * <p>This corresponds to constructor injection: In this mode, a Spring\n\t * bean factory is able to host components that expect constructor-based\n\t * dependency resolution.\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition for the bean\n\t * @param chosenCtors chosen candidate constructors (or {@code null} if none)\n\t * @param explicitArgs argument values passed in programmatically via the getBean method,\n\t * or {@code null} if none (-> use constructor argument values from bean definition)\n\t * @return a BeanWrapper for the new instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "mbd",
      "chosenCtors",
      "explicitArgs"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "BeanWrapper",
    "signature": "public BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd,\n\t\t\t@Nullable Constructor<?>[] chosenCtors, @Nullable Object[] explicitArgs)",
    "source_code": "\tpublic BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd,\n\t\t\t@Nullable Constructor<?>[] chosenCtors, @Nullable Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tConstructor<?> constructorToUse = null;\n\t\tArgumentsHolder argsHolderToUse = null;\n\t\tObject[] argsToUse = null;\n\n\t\tif (explicitArgs != null) {\n\t\t\targsToUse = explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve = null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tconstructorToUse = (Constructor<?>) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (constructorToUse != null && mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached constructor...\n\t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse == null) {\n\t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve != null) {\n\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (constructorToUse == null || argsToUse == null) {\n\t\t\t// Take specified constructors, if any.\n\t\t\tConstructor<?>[] candidates = chosenCtors;\n\t\t\tif (candidates == null) {\n\t\t\t\tClass<?> beanClass = mbd.getBeanClass();\n\t\t\t\ttry {\n\t\t\t\t\tcandidates = (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\t\tbeanClass.getDeclaredConstructors() : beanClass.getConstructors());\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\"Resolution of declared constructors on bean Class [\" + beanClass.getName() +\n\t\t\t\t\t\t\t\"] from ClassLoader [\" + beanClass.getClassLoader() + \"] failed\", ex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (candidates.length == 1 && explicitArgs == null && !mbd.hasConstructorArgumentValues()) {\n\t\t\t\tConstructor<?> uniqueCandidate = candidates[0];\n\t\t\t\tif (uniqueCandidate.getParameterCount() == 0) {\n\t\t\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\t\t\tmbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;\n\t\t\t\t\t\tmbd.constructorArgumentsResolved = true;\n\t\t\t\t\t\tmbd.resolvedConstructorArguments = EMPTY_ARGS;\n\t\t\t\t\t}\n\t\t\t\t\tbw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));\n\t\t\t\t\treturn bw;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Need to resolve the constructor.\n\t\t\tboolean autowiring = (chosenCtors != null ||\n\t\t\t\t\tmbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);\n\t\t\tConstructorArgumentValues resolvedValues = null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs != null) {\n\t\t\t\tminNrOfArgs = explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues = new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tAutowireUtils.sortConstructors(candidates);\n\t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n\t\t\tSet<Constructor<?>> ambiguousConstructors = null;\n\t\t\tDeque<UnsatisfiedDependencyException> causes = null;\n\n\t\t\tfor (Constructor<?> candidate : candidates) {\n\t\t\t\tint parameterCount = candidate.getParameterCount();\n\n\t\t\t\tif (constructorToUse != null && argsToUse != null && argsToUse.length > parameterCount) {\n\t\t\t\t\t// Already found greedy constructor that can be satisfied ->\n\t\t\t\t\t// do not look any further, there are only less greedy constructors left.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (parameterCount < minNrOfArgs) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tArgumentsHolder argsHolder;\n\t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n\t\t\t\tif (resolvedValues != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString[] paramNames = null;\n\t\t\t\t\t\tif (resolvedValues.containsNamedArgument()) {\n\t\t\t\t\t\t\tparamNames = ConstructorPropertiesChecker.evaluate(candidate, parameterCount);\n\t\t\t\t\t\t\tif (paramNames == null) {\n\t\t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\t\tif (pnd != null) {\n\t\t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,\n\t\t\t\t\t\t\t\tgetUserDeclaredConstructor(candidate), autowiring, candidates.length == 1);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Ignoring constructor [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Swallow and try next constructor.\n\t\t\t\t\t\tif (causes == null) {\n\t\t\t\t\t\t\tcauses = new ArrayDeque<>(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n\t\t\t\t\tif (parameterCount != explicitArgs.length) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n\t\t\t\t}\n\n\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t// Choose this constructor if it represents the closest match.\n\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n\t\t\t\t\tconstructorToUse = candidate;\n\t\t\t\t\targsHolderToUse = argsHolder;\n\t\t\t\t\targsToUse = argsHolder.arguments;\n\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n\t\t\t\t\tambiguousConstructors = null;\n\t\t\t\t}\n\t\t\t\telse if (constructorToUse != null && typeDiffWeight == minTypeDiffWeight) {\n\t\t\t\t\tif (ambiguousConstructors == null) {\n\t\t\t\t\t\tambiguousConstructors = new LinkedHashSet<>();\n\t\t\t\t\t\tambiguousConstructors.add(constructorToUse);\n\t\t\t\t\t}\n\t\t\t\t\tambiguousConstructors.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (constructorToUse == null) {\n\t\t\t\tif (causes != null) {\n\t\t\t\t\tUnsatisfiedDependencyException ex = causes.removeLast();\n\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Could not resolve matching constructor on bean class [\" + mbd.getBeanClassName() + \"] \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)\");\n\t\t\t}\n\t\t\telse if (ambiguousConstructors != null && !mbd.isLenientConstructorResolution()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous constructor matches found on bean class [\" + mbd.getBeanClassName() + \"] \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousConstructors);\n\t\t\t}\n\n\t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, constructorToUse);\n\t\t\t}\n\t\t}\n\n\t\tAssert.state(argsToUse != null, \"Unresolved constructor arguments\");\n\t\tbw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));\n\t\treturn bw;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#autowireConstructor(beanName,mbd,ctors,explicitArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * \"autowire constructor\" (with constructor arguments by type) behavior.\n\t * Also applied if explicit constructor argument values are specified,\n\t * matching all remaining arguments with beans from the bean factory.\n\t * <p>This corresponds to constructor injection: In this mode, a Spring\n\t * bean factory is able to host components that expect constructor-based\n\t * dependency resolution.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param ctors the chosen candidate constructors\n\t * @param explicitArgs argument values passed in programmatically via the getBean method,\n\t * or {@code null} if none (implying the use of constructor argument values from bean definition)\n\t * @return a BeanWrapper for the new instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "ctors",
      "explicitArgs"
    ],
    "position": {
      "column": 1,
      "line": 1342
    },
    "return": "BeanWrapper",
    "signature": "protected BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd, @Nullable Constructor<?>[] ctors, @Nullable Object[] explicitArgs)",
    "source_code": "\tprotected BeanWrapper autowireConstructor(\n\t\t\tString beanName, RootBeanDefinition mbd, @Nullable Constructor<?>[] ctors, @Nullable Object[] explicitArgs) {\n\n\t\treturn new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#checkDependencies(beanName,mbd,pds,pvs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a dependency check that all properties exposed have been set,\n\t * if desired. Dependency checks can be objects (collaborating beans),\n\t * simple (primitives and String), or all (both).\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition the bean was created with\n\t * @param pds the relevant property descriptors for the target bean\n\t * @param pvs the property values to be applied to the bean\n\t * @see #isExcludedFromDependencyCheck(java.beans.PropertyDescriptor)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "pds",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 1586
    },
    "return": "void",
    "signature": "protected void checkDependencies(String beanName, AbstractBeanDefinition mbd, PropertyDescriptor[] pds, @Nullable PropertyValues pvs)",
    "source_code": "\tprotected void checkDependencies(\n\t\t\tString beanName, AbstractBeanDefinition mbd, PropertyDescriptor[] pds, @Nullable PropertyValues pvs)\n\t\t\tthrows UnsatisfiedDependencyException {\n\n\t\tint dependencyCheck = mbd.getDependencyCheck();\n\t\tfor (PropertyDescriptor pd : pds) {\n\t\t\tif (pd.getWriteMethod() != null && (pvs == null || !pvs.contains(pd.getName()))) {\n\t\t\t\tboolean isSimple = BeanUtils.isSimpleProperty(pd.getPropertyType());\n\t\t\t\tboolean unsatisfied = (dependencyCheck == AbstractBeanDefinition.DEPENDENCY_CHECK_ALL) ||\n\t\t\t\t\t\t(isSimple && dependencyCheck == AbstractBeanDefinition.DEPENDENCY_CHECK_SIMPLE) ||\n\t\t\t\t\t\t(!isSimple && dependencyCheck == AbstractBeanDefinition.DEPENDENCY_CHECK_OBJECTS);\n\t\t\t\tif (unsatisfied) {\n\t\t\t\t\tthrow new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, pd.getName(),\n\t\t\t\t\t\t\t\"Set this property value or disable dependency checking for this bean.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#checkForAliasCircle(name,alias)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Also checks for an alias overriding a bean definition of the same name.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "alias"
    ],
    "position": {
      "column": 1,
      "line": 1153
    },
    "return": "void",
    "signature": "protected void checkForAliasCircle(String name, String alias)",
    "source_code": "\tprotected void checkForAliasCircle(String name, String alias) {\n\t\tsuper.checkForAliasCircle(name, alias);\n\t\tif (!isAllowBeanDefinitionOverriding() && containsBeanDefinition(alias)) {\n\t\t\tthrow new IllegalStateException(\"Cannot register alias '\" + alias +\n\t\t\t\t\t\"' for name '\" + name + \"': Alias would override bean definition '\" + alias + \"'\");\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#checkGenericTypeMatch(bdHolder,descriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Match the given dependency type with its generic type information against the given\n\t * candidate bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bdHolder",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "boolean",
    "signature": "protected boolean checkGenericTypeMatch(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor)",
    "source_code": "\tprotected boolean checkGenericTypeMatch(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor) {\n\t\tResolvableType dependencyType = descriptor.getResolvableType();\n\t\tif (dependencyType.getType() instanceof Class) {\n\t\t\t// No generic type -> we know it's a Class type-match, so no need to check again.\n\t\t\treturn true;\n\t\t}\n\n\t\tResolvableType targetType = null;\n\t\tboolean cacheType = false;\n\t\tRootBeanDefinition rbd = null;\n\t\tif (bdHolder.getBeanDefinition() instanceof RootBeanDefinition rootBeanDef) {\n\t\t\trbd = rootBeanDef;\n\t\t}\n\t\tif (rbd != null) {\n\t\t\ttargetType = rbd.targetType;\n\t\t\tif (targetType == null) {\n\t\t\t\tcacheType = true;\n\t\t\t\t// First, check factory method return type, if applicable\n\t\t\t\ttargetType = getReturnTypeForFactoryMethod(rbd, descriptor);\n\t\t\t\tif (targetType == null) {\n\t\t\t\t\tRootBeanDefinition dbd = getResolvedDecoratedDefinition(rbd);\n\t\t\t\t\tif (dbd != null) {\n\t\t\t\t\t\ttargetType = dbd.targetType;\n\t\t\t\t\t\tif (targetType == null) {\n\t\t\t\t\t\t\ttargetType = getReturnTypeForFactoryMethod(dbd, descriptor);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Pre-existing target type: In case of a generic FactoryBean type,\n\t\t\t\t// unwrap nested generic type when matching a non-FactoryBean type.\n\t\t\t\tClass<?> resolvedClass = targetType.resolve();\n\t\t\t\tif (resolvedClass != null && FactoryBean.class.isAssignableFrom(resolvedClass)) {\n\t\t\t\t\tClass<?> typeToBeMatched = dependencyType.resolve();\n\t\t\t\t\tif (typeToBeMatched != null && !FactoryBean.class.isAssignableFrom(typeToBeMatched)) {\n\t\t\t\t\t\ttargetType = targetType.getGeneric();\n\t\t\t\t\t\tif (descriptor.fallbackMatchAllowed()) {\n\t\t\t\t\t\t\t// Matching the Class-based type determination for FactoryBean\n\t\t\t\t\t\t\t// objects in the lazy-determination getType code path below.\n\t\t\t\t\t\t\ttargetType = ResolvableType.forClass(targetType.resolve());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (targetType == null) {\n\t\t\t// Regular case: straight bean instance, with BeanFactory available.\n\t\t\tif (this.beanFactory != null) {\n\t\t\t\tClass<?> beanType = this.beanFactory.getType(bdHolder.getBeanName());\n\t\t\t\tif (beanType != null) {\n\t\t\t\t\ttargetType = ResolvableType.forClass(ClassUtils.getUserClass(beanType));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Fallback: no BeanFactory set, or no type resolvable through it\n\t\t\t// -> best-effort match against the target class if applicable.\n\t\t\tif (targetType == null && rbd != null && rbd.hasBeanClass() && rbd.getFactoryMethodName() == null) {\n\t\t\t\tClass<?> beanClass = rbd.getBeanClass();\n\t\t\t\tif (!FactoryBean.class.isAssignableFrom(beanClass)) {\n\t\t\t\t\ttargetType = ResolvableType.forClass(ClassUtils.getUserClass(beanClass));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (targetType == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (cacheType) {\n\t\t\trbd.targetType = targetType;\n\t\t}\n\t\tif (descriptor.fallbackMatchAllowed() &&\n\t\t\t\t(targetType.hasUnresolvableGenerics() || targetType.resolve() == Properties.class)) {\n\t\t\t// Fallback matches allow unresolvable generics, e.g. plain HashMap to Map<String,String>;\n\t\t\t// and pragmatically also java.util.Properties to any Map (since despite formally being a\n\t\t\t// Map<Object,Object>, java.util.Properties is usually perceived as a Map<String,String>).\n\t\t\treturn true;\n\t\t}\n\t\t// Full check for complex generic type match...\n\t\treturn dependencyType.isAssignableFrom(targetType);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#checkMergedBeanDefinition(mbd,beanName,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check the given merged bean definition,\n\t * potentially throwing validation exceptions.\n\t * @param mbd the merged bean definition to check\n\t * @param beanName the name of the bean\n\t * @param args the arguments for bean creation, if any\n\t * @throws BeanDefinitionStoreException in case of validation failure\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mbd",
      "beanName",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1447
    },
    "return": "void",
    "signature": "protected void checkMergedBeanDefinition(RootBeanDefinition mbd, String beanName, @Nullable Object[] args)",
    "source_code": "\tprotected void checkMergedBeanDefinition(RootBeanDefinition mbd, String beanName, @Nullable Object[] args)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\tif (mbd.isAbstract()) {\n\t\t\tthrow new BeanIsAbstractException(beanName);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#configureBean(existingBean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "Object",
    "signature": "public Object configureBean(Object existingBean, String beanName)",
    "source_code": "\tpublic Object configureBean(Object existingBean, String beanName) throws BeansException {\n\t\tmarkBeanAsCreated(beanName);\n\t\tBeanDefinition mbd = getMergedBeanDefinition(beanName);\n\t\tRootBeanDefinition bd = null;\n\t\tif (mbd instanceof RootBeanDefinition rbd) {\n\t\t\tbd = (rbd.isPrototype() ? rbd : rbd.cloneBeanDefinition());\n\t\t}\n\t\tif (bd == null) {\n\t\t\tbd = new RootBeanDefinition(mbd);\n\t\t}\n\t\tif (!bd.isPrototype()) {\n\t\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\t\tbd.allowCaching = ClassUtils.isCacheSafe(ClassUtils.getUserClass(existingBean), getBeanClassLoader());\n\t\t}\n\t\tBeanWrapper bw = new BeanWrapperImpl(existingBean);\n\t\tinitBeanWrapper(bw);\n\t\tpopulateBean(beanName, bd, bw);\n\t\treturn initializeBean(beanName, existingBean, bd);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#createBean(beanClass,autowireMode,dependencyCheck)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "Object",
    "signature": "public Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck)",
    "source_code": "\tpublic Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck) throws BeansException {\n\t\t// Use non-singleton bean definition, to avoid registering bean as dependent bean.\n\t\tRootBeanDefinition bd = new RootBeanDefinition(beanClass, autowireMode, dependencyCheck);\n\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\treturn createBean(beanClass.getName(), bd, null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#createBean(beanName,mbd,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a bean instance for the given merged bean definition (and arguments).\n\t * The bean definition will already have been merged with the parent definition\n\t * in case of a child definition.\n\t * <p>All bean retrieval methods delegate to this method for actual bean creation.\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition for the bean\n\t * @param args explicit arguments to use for constructor or factory method invocation\n\t * @return a new instance of the bean\n\t * @throws BeanCreationException if the bean could not be created\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1941
    },
    "return": "Object",
    "signature": "protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)",
    "source_code": "\tprotected abstract Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n\t\t\tthrows BeanCreationException;\n\n\n\t/**\n\t * CopyOnWriteArrayList which resets the beanPostProcessorCache field on modification.\n\t *\n\t * @since 5.3\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate class BeanPostProcessorCacheAwareList extends CopyOnWriteArrayList<BeanPostProcessor> {\n\n\t\t@Override\n\t\tpublic BeanPostProcessor set(int index, BeanPostProcessor element) {\n\t\t\tBeanPostProcessor result = super.set(index, element);\n\t\t\tresetBeanPostProcessorCache();\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(BeanPostProcessor o) {\n\t\t\tboolean success = super.add(o);\n\t\t\tresetBeanPostProcessorCache();\n\t\t\treturn success;\n\t\t}\n\n\t\t@Override\n\t\tpublic void add(int index, BeanPostProcessor element) {\n\t\t\tsuper.add(index, element);\n\t\t\tresetBeanPostProcessorCache();\n\t\t}\n\n\t\t@Override\n\t\tpublic BeanPostProcessor remove(int index) {\n\t\t\tBeanPostProcessor result = super.remove(index);\n\t\t\tresetBeanPostProcessorCache();\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\tboolean success = super.remove(o);\n\t\t\tif (success) {\n\t\t\t\tresetBeanPostProcessorCache();\n\t\t\t}\n\t\t\treturn success;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean success = super.removeAll(c);\n\t\t\tif (success) {\n\t\t\t\tresetBeanPostProcessorCache();\n\t\t\t}\n\t\t\treturn success;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\tboolean success = super.retainAll(c);\n\t\t\tif (success) {\n\t\t\t\tresetBeanPostProcessorCache();\n\t\t\t}\n\t\t\treturn success;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends BeanPostProcessor> c) {\n\t\t\tboolean success = super.addAll(c);\n\t\t\tif (success) {\n\t\t\t\tresetBeanPostProcessorCache();\n\t\t\t}\n\t\t\treturn success;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(int index, Collection<? extends BeanPostProcessor> c) {\n\t\t\tboolean success = super.addAll(index, c);\n\t\t\tif (success) {\n\t\t\t\tresetBeanPostProcessorCache();\n\t\t\t}\n\t\t\treturn success;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeIf(Predicate<? super BeanPostProcessor> filter) {\n\t\t\tboolean success = super.removeIf(filter);\n\t\t\tif (success) {\n\t\t\t\tresetBeanPostProcessorCache();\n\t\t\t}\n\t\t\treturn success;\n\t\t}\n\n\t\t@Override\n\t\tpublic void replaceAll(UnaryOperator<BeanPostProcessor> operator) {\n\t\t\tsuper.replaceAll(operator);\n\t\t\tresetBeanPostProcessorCache();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#createBeanInstance(beanName,mbd,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new instance for the specified bean, using an appropriate instantiation strategy:\n\t * factory method, constructor autowiring, or simple instantiation.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param args explicit arguments to use for constructor or factory method invocation\n\t * @return a BeanWrapper for the new instance\n\t * @see #obtainFromSupplier\n\t * @see #instantiateUsingFactoryMethod\n\t * @see #autowireConstructor\n\t * @see #instantiateBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1147
    },
    "return": "BeanWrapper",
    "signature": "protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)",
    "source_code": "\tprotected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {\n\t\t// Make sure bean class is actually resolved at this point.\n\t\tClass<?> beanClass = resolveBeanClass(mbd, beanName);\n\n\t\tif (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean class isn't public, and non-public access not allowed: \" + beanClass.getName());\n\t\t}\n\n\t\tSupplier<?> instanceSupplier = mbd.getInstanceSupplier();\n\t\tif (instanceSupplier != null) {\n\t\t\treturn obtainFromSupplier(instanceSupplier, beanName);\n\t\t}\n\n\t\tif (mbd.getFactoryMethodName() != null) {\n\t\t\treturn instantiateUsingFactoryMethod(beanName, mbd, args);\n\t\t}\n\n\t\t// Shortcut when re-creating the same bean...\n\t\tboolean resolved = false;\n\t\tboolean autowireNecessary = false;\n\t\tif (args == null) {\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tif (mbd.resolvedConstructorOrFactoryMethod != null) {\n\t\t\t\t\tresolved = true;\n\t\t\t\t\tautowireNecessary = mbd.constructorArgumentsResolved;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (resolved) {\n\t\t\tif (autowireNecessary) {\n\t\t\t\treturn autowireConstructor(beanName, mbd, null, null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn instantiateBean(beanName, mbd);\n\t\t\t}\n\t\t}\n\n\t\t// Candidate constructors for autowiring?\n\t\tConstructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n\t\tif (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||\n\t\t\t\tmbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {\n\t\t\treturn autowireConstructor(beanName, mbd, ctors, args);\n\t\t}\n\n\t\t// Preferred constructors for default construction?\n\t\tctors = mbd.getPreferredConstructors();\n\t\tif (ctors != null) {\n\t\t\treturn autowireConstructor(beanName, mbd, ctors, null);\n\t\t}\n\n\t\t// No special handling: simply use no-arg constructor.\n\t\treturn instantiateBean(beanName, mbd);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#createDependencyProvider(descriptor,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 2144
    },
    "return": "Object",
    "signature": "public Object createDependencyProvider(DependencyDescriptor descriptor, @Nullable String beanName)",
    "source_code": "\t\tpublic Object createDependencyProvider(DependencyDescriptor descriptor, @Nullable String beanName) {\n\t\t\treturn new Jsr330Provider(descriptor, beanName);\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#destroyBean(beanName,bean,mbd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Destroy the given bean instance (usually a prototype instance\n\t * obtained from this factory) according to the given bean definition.\n\t * @param beanName the name of the bean definition\n\t * @param bean the bean instance to destroy\n\t * @param mbd the merged bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bean",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1198
    },
    "return": "void",
    "signature": "protected void destroyBean(String beanName, Object bean, RootBeanDefinition mbd)",
    "source_code": "\tprotected void destroyBean(String beanName, Object bean, RootBeanDefinition mbd) {\n\t\tnew DisposableBeanAdapter(\n\t\t\t\tbean, beanName, mbd, getBeanPostProcessorCache().destructionAware).destroy();\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#destroyBean(beanName,beanInstance)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanInstance"
    ],
    "position": {
      "column": 1,
      "line": 1187
    },
    "return": "void",
    "signature": "public void destroyBean(String beanName, Object beanInstance)",
    "source_code": "\tpublic void destroyBean(String beanName, Object beanInstance) {\n\t\tdestroyBean(beanName, beanInstance, getMergedLocalBeanDefinition(beanName));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#determineAutowireCandidate(Map<String,candidates,descriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the autowire candidate in the given set of beans.\n\t * <p>Looks for {@code @Primary} and {@code @Priority} (in that order).\n\t * @param candidates a Map of candidate names and candidate instances\n\t * that match the required type, as returned by {@link #findAutowireCandidates}\n\t * @param descriptor the target dependency to match against\n\t * @return the name of the autowire candidate, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "candidates",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 1645
    },
    "return": "String",
    "signature": "protected String determineAutowireCandidate(Map<String, Object> candidates, DependencyDescriptor descriptor)",
    "source_code": "\tprotected String determineAutowireCandidate(Map<String, Object> candidates, DependencyDescriptor descriptor) {\n\t\tClass<?> requiredType = descriptor.getDependencyType();\n\t\tString primaryCandidate = determinePrimaryCandidate(candidates, requiredType);\n\t\tif (primaryCandidate != null) {\n\t\t\treturn primaryCandidate;\n\t\t}\n\t\tString priorityCandidate = determineHighestPriorityCandidate(candidates, requiredType);\n\t\tif (priorityCandidate != null) {\n\t\t\treturn priorityCandidate;\n\t\t}\n\t\t// Fallback\n\t\tfor (Map.Entry<String, Object> entry : candidates.entrySet()) {\n\t\t\tString candidateName = entry.getKey();\n\t\t\tObject beanInstance = entry.getValue();\n\t\t\tif ((beanInstance != null && this.resolvableDependencies.containsValue(beanInstance)) ||\n\t\t\t\t\tmatchesBeanName(candidateName, descriptor.getDependencyName())) {\n\t\t\t\treturn candidateName;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#determineHighestPriorityCandidate(Map<String,candidates,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the candidate with the highest priority in the given set of beans.\n\t * <p>Based on {@code @jakarta.annotation.Priority}. As defined by the related\n\t * {@link org.springframework.core.Ordered} interface, the lowest value has\n\t * the highest priority.\n\t * @param candidates a Map of candidate names and candidate instances\n\t * (or candidate classes if not created yet) that match the required type\n\t * @param requiredType the target dependency type to match against\n\t * @return the name of the candidate with the highest priority,\n\t * or {@code null} if none found\n\t * @see #getPriority(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "candidates",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 1714
    },
    "return": "String",
    "signature": "protected String determineHighestPriorityCandidate(Map<String, Object> candidates, Class<?> requiredType)",
    "source_code": "\tprotected String determineHighestPriorityCandidate(Map<String, Object> candidates, Class<?> requiredType) {\n\t\tString highestPriorityBeanName = null;\n\t\tInteger highestPriority = null;\n\t\tfor (Map.Entry<String, Object> entry : candidates.entrySet()) {\n\t\t\tString candidateBeanName = entry.getKey();\n\t\t\tObject beanInstance = entry.getValue();\n\t\t\tif (beanInstance != null) {\n\t\t\t\tInteger candidatePriority = getPriority(beanInstance);\n\t\t\t\tif (candidatePriority != null) {\n\t\t\t\t\tif (highestPriorityBeanName != null) {\n\t\t\t\t\t\tif (candidatePriority.equals(highestPriority)) {\n\t\t\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, candidates.size(),\n\t\t\t\t\t\t\t\t\t\"Multiple beans found with the same priority ('\" + highestPriority +\n\t\t\t\t\t\t\t\t\t\"') among candidates: \" + candidates.keySet());\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (candidatePriority < highestPriority) {\n\t\t\t\t\t\t\thighestPriorityBeanName = candidateBeanName;\n\t\t\t\t\t\t\thighestPriority = candidatePriority;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thighestPriorityBeanName = candidateBeanName;\n\t\t\t\t\t\thighestPriority = candidatePriority;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn highestPriorityBeanName;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#determinePrimaryCandidate(Map<String,candidates,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the primary candidate in the given set of beans.\n\t * @param candidates a Map of candidate names and candidate instances\n\t * (or candidate classes if not created yet) that match the required type\n\t * @param requiredType the target dependency type to match against\n\t * @return the name of the primary candidate, or {@code null} if none found\n\t * @see #isPrimary(String, Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "candidates",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 1676
    },
    "return": "String",
    "signature": "protected String determinePrimaryCandidate(Map<String, Object> candidates, Class<?> requiredType)",
    "source_code": "\tprotected String determinePrimaryCandidate(Map<String, Object> candidates, Class<?> requiredType) {\n\t\tString primaryBeanName = null;\n\t\tfor (Map.Entry<String, Object> entry : candidates.entrySet()) {\n\t\t\tString candidateBeanName = entry.getKey();\n\t\t\tObject beanInstance = entry.getValue();\n\t\t\tif (isPrimary(candidateBeanName, beanInstance)) {\n\t\t\t\tif (primaryBeanName != null) {\n\t\t\t\t\tboolean candidateLocal = containsBeanDefinition(candidateBeanName);\n\t\t\t\t\tboolean primaryLocal = containsBeanDefinition(primaryBeanName);\n\t\t\t\t\tif (candidateLocal && primaryLocal) {\n\t\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, candidates.size(),\n\t\t\t\t\t\t\t\t\"more than one 'primary' bean found among candidates: \" + candidates.keySet());\n\t\t\t\t\t}\n\t\t\t\t\telse if (candidateLocal) {\n\t\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn primaryBeanName;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#doCreateBean(beanName,mbd,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually create the specified bean. Pre-creation processing has already happened\n\t * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks.\n\t * <p>Differentiates between default bean instantiation, use of a\n\t * factory method, and autowiring a constructor.\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition for the bean\n\t * @param args explicit arguments to use for constructor or factory method invocation\n\t * @return a new instance of the bean\n\t * @throws BeanCreationException if the bean could not be created\n\t * @see #instantiateBean\n\t * @see #instantiateUsingFactoryMethod\n\t * @see #autowireConstructor\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 553
    },
    "return": "Object",
    "signature": "protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)",
    "source_code": "\tprotected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n\t\t\tthrows BeanCreationException {\n\n\t\t// Instantiate the bean.\n\t\tBeanWrapper instanceWrapper = null;\n\t\tif (mbd.isSingleton()) {\n\t\t\tinstanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n\t\t}\n\t\tif (instanceWrapper == null) {\n\t\t\tinstanceWrapper = createBeanInstance(beanName, mbd, args);\n\t\t}\n\t\tObject bean = instanceWrapper.getWrappedInstance();\n\t\tClass<?> beanType = instanceWrapper.getWrappedClass();\n\t\tif (beanType != NullBean.class) {\n\t\t\tmbd.resolvedTargetType = beanType;\n\t\t}\n\n\t\t// Allow post-processors to modify the merged bean definition.\n\t\tsynchronized (mbd.postProcessingLock) {\n\t\t\tif (!mbd.postProcessed) {\n\t\t\t\ttry {\n\t\t\t\t\tapplyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\"Post-processing of merged bean definition failed\", ex);\n\t\t\t\t}\n\t\t\t\tmbd.markAsPostProcessed();\n\t\t\t}\n\t\t}\n\n\t\t// Eagerly cache singletons to be able to resolve circular references\n\t\t// even when triggered by lifecycle interfaces like BeanFactoryAware.\n\t\tboolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n\t\t\t\tisSingletonCurrentlyInCreation(beanName));\n\t\tif (earlySingletonExposure) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Eagerly caching bean '\" + beanName +\n\t\t\t\t\t\t\"' to allow for resolving potential circular references\");\n\t\t\t}\n\t\t\taddSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n\t\t}\n\n\t\t// Initialize the bean instance.\n\t\tObject exposedObject = bean;\n\t\ttry {\n\t\t\tpopulateBean(beanName, mbd, instanceWrapper);\n\t\t\texposedObject = initializeBean(beanName, exposedObject, mbd);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (ex instanceof BeanCreationException bce && beanName.equals(bce.getBeanName())) {\n\t\t\t\tthrow bce;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);\n\t\t\t}\n\t\t}\n\n\t\tif (earlySingletonExposure) {\n\t\t\tObject earlySingletonReference = getSingleton(beanName, false);\n\t\t\tif (earlySingletonReference != null) {\n\t\t\t\tif (exposedObject == bean) {\n\t\t\t\t\texposedObject = earlySingletonReference;\n\t\t\t\t}\n\t\t\t\telse if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {\n\t\t\t\t\tString[] dependentBeans = getDependentBeans(beanName);\n\t\t\t\t\tSet<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);\n\t\t\t\t\tfor (String dependentBean : dependentBeans) {\n\t\t\t\t\t\tif (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n\t\t\t\t\t\t\tactualDependentBeans.add(dependentBean);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!actualDependentBeans.isEmpty()) {\n\t\t\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName,\n\t\t\t\t\t\t\t\t\"Bean with name '\" + beanName + \"' has been injected into other beans [\" +\n\t\t\t\t\t\t\t\tStringUtils.collectionToCommaDelimitedString(actualDependentBeans) +\n\t\t\t\t\t\t\t\t\"] in its raw version as part of a circular reference, but has eventually been \" +\n\t\t\t\t\t\t\t\t\"wrapped. This means that said other beans do not use the final version of the \" +\n\t\t\t\t\t\t\t\t\"bean. This is often the result of over-eager type matching - consider using \" +\n\t\t\t\t\t\t\t\t\"'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Register bean as disposable.\n\t\ttry {\n\t\t\tregisterDisposableBeanIfNecessary(beanName, bean, mbd);\n\t\t}\n\t\tcatch (BeanDefinitionValidationException ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex);\n\t\t}\n\n\t\treturn exposedObject;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#doGetBean(name,requiredType,args,typeCheckOnly)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return an instance, which may be shared or independent, of the specified bean.\n\t * @param name the name of the bean to retrieve\n\t * @param requiredType the required type of the bean to retrieve\n\t * @param args arguments to use when creating a bean instance using explicit arguments\n\t * (only applied when creating a new instance as opposed to retrieving an existing one)\n\t * @param typeCheckOnly whether the instance is obtained for a type check,\n\t * not for actual use\n\t * @return an instance of the bean\n\t * @throws BeansException if the bean could not be created\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "requiredType",
      "args",
      "typeCheckOnly"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "T",
    "signature": "protected T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)",
    "source_code": "\tprotected <T> T doGetBean(\n\t\t\tString name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)\n\t\t\tthrows BeansException {\n\n\t\tString beanName = transformedBeanName(name);\n\t\tObject beanInstance;\n\n\t\t// Eagerly check singleton cache for manually registered singletons.\n\t\tObject sharedInstance = getSingleton(beanName);\n\t\tif (sharedInstance != null && args == null) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tif (isSingletonCurrentlyInCreation(beanName)) {\n\t\t\t\t\tlogger.trace(\"Returning eagerly cached instance of singleton bean '\" + beanName +\n\t\t\t\t\t\t\t\"' that is not fully initialized yet - a consequence of a circular reference\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.trace(\"Returning cached instance of singleton bean '\" + beanName + \"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbeanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n\t\t}\n\n\t\telse {\n\t\t\t// Fail if we're already creating this bean instance:\n\t\t\t// We're assumably within a circular reference.\n\t\t\tif (isPrototypeCurrentlyInCreation(beanName)) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName);\n\t\t\t}\n\n\t\t\t// Check if bean definition exists in this factory.\n\t\t\tBeanFactory parentBeanFactory = getParentBeanFactory();\n\t\t\tif (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n\t\t\t\t// Not found -> check parent.\n\t\t\t\tString nameToLookup = originalBeanName(name);\n\t\t\t\tif (parentBeanFactory instanceof AbstractBeanFactory abf) {\n\t\t\t\t\treturn abf.doGetBean(nameToLookup, requiredType, args, typeCheckOnly);\n\t\t\t\t}\n\t\t\t\telse if (args != null) {\n\t\t\t\t\t// Delegation to parent with explicit args.\n\t\t\t\t\treturn (T) parentBeanFactory.getBean(nameToLookup, args);\n\t\t\t\t}\n\t\t\t\telse if (requiredType != null) {\n\t\t\t\t\t// No args -> delegate to standard getBean method.\n\t\t\t\t\treturn parentBeanFactory.getBean(nameToLookup, requiredType);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn (T) parentBeanFactory.getBean(nameToLookup);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!typeCheckOnly) {\n\t\t\t\tmarkBeanAsCreated(beanName);\n\t\t\t}\n\n\t\t\tStartupStep beanCreation = this.applicationStartup.start(\"spring.beans.instantiate\")\n\t\t\t\t\t.tag(\"beanName\", name);\n\t\t\ttry {\n\t\t\t\tif (requiredType != null) {\n\t\t\t\t\tbeanCreation.tag(\"beanType\", requiredType::toString);\n\t\t\t\t}\n\t\t\t\tRootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\t\t\tcheckMergedBeanDefinition(mbd, beanName, args);\n\n\t\t\t\t// Guarantee initialization of beans that the current bean depends on.\n\t\t\t\tString[] dependsOn = mbd.getDependsOn();\n\t\t\t\tif (dependsOn != null) {\n\t\t\t\t\tfor (String dep : dependsOn) {\n\t\t\t\t\t\tif (isDependent(beanName, dep)) {\n\t\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\t\"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tregisterDependentBean(dep, beanName);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tgetBean(dep);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\t\"'\" + beanName + \"' depends on missing bean '\" + dep + \"'\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Create bean instance.\n\t\t\t\tif (mbd.isSingleton()) {\n\t\t\t\t\tsharedInstance = getSingleton(beanName, () -> {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn createBean(beanName, mbd, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\t\t\t// Explicitly remove instance from singleton cache: It might have been put there\n\t\t\t\t\t\t\t// eagerly by the creation process, to allow for circular reference resolution.\n\t\t\t\t\t\t\t// Also remove any beans that received a temporary reference to the bean.\n\t\t\t\t\t\t\tdestroySingleton(beanName);\n\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbeanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n\t\t\t\t}\n\n\t\t\t\telse if (mbd.isPrototype()) {\n\t\t\t\t\t// It's a prototype -> create a new instance.\n\t\t\t\t\tObject prototypeInstance = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbeforePrototypeCreation(beanName);\n\t\t\t\t\t\tprototypeInstance = createBean(beanName, mbd, args);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tafterPrototypeCreation(beanName);\n\t\t\t\t\t}\n\t\t\t\t\tbeanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tString scopeName = mbd.getScope();\n\t\t\t\t\tif (!StringUtils.hasLength(scopeName)) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"No scope name defined for bean '\" + beanName + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tScope scope = this.scopes.get(scopeName);\n\t\t\t\t\tif (scope == null) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObject scopedInstance = scope.get(beanName, () -> {\n\t\t\t\t\t\t\tbeforePrototypeCreation(beanName);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\treturn createBean(beanName, mbd, args);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\t\tafterPrototypeCreation(beanName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbeanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t\t\tthrow new ScopeNotActiveException(beanName, scopeName, ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (BeansException ex) {\n\t\t\t\tbeanCreation.tag(\"exception\", ex.getClass().toString());\n\t\t\t\tbeanCreation.tag(\"message\", String.valueOf(ex.getMessage()));\n\t\t\t\tcleanupAfterBeanCreationFailure(beanName);\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tbeanCreation.end();\n\t\t\t}\n\t\t}\n\n\t\treturn adaptBeanInstance(name, beanInstance, requiredType);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#doResolveDependency(descriptor,beanName,autowiredBeanNames,typeConverter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "beanName",
      "autowiredBeanNames",
      "typeConverter"
    ],
    "position": {
      "column": 1,
      "line": 1332
    },
    "return": "Object",
    "signature": "public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter)",
    "source_code": "\tpublic Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {\n\n\t\tInjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);\n\t\ttry {\n\t\t\tObject shortcut = descriptor.resolveShortcut(this);\n\t\t\tif (shortcut != null) {\n\t\t\t\treturn shortcut;\n\t\t\t}\n\n\t\t\tClass<?> type = descriptor.getDependencyType();\n\t\t\tObject value = getAutowireCandidateResolver().getSuggestedValue(descriptor);\n\t\t\tif (value != null) {\n\t\t\t\tif (value instanceof String strValue) {\n\t\t\t\t\tString resolvedValue = resolveEmbeddedValue(strValue);\n\t\t\t\t\tBeanDefinition bd = (beanName != null && containsBean(beanName) ?\n\t\t\t\t\t\t\tgetMergedBeanDefinition(beanName) : null);\n\t\t\t\t\tvalue = evaluateBeanDefinitionString(resolvedValue, bd);\n\t\t\t\t}\n\t\t\t\tTypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n\t\t\t\ttry {\n\t\t\t\t\treturn converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());\n\t\t\t\t}\n\t\t\t\tcatch (UnsupportedOperationException ex) {\n\t\t\t\t\t// A custom TypeConverter which does not support TypeDescriptor resolution...\n\t\t\t\t\treturn (descriptor.getField() != null ?\n\t\t\t\t\t\t\tconverter.convertIfNecessary(value, type, descriptor.getField()) :\n\t\t\t\t\t\t\tconverter.convertIfNecessary(value, type, descriptor.getMethodParameter()));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tObject multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);\n\t\t\tif (multipleBeans != null) {\n\t\t\t\treturn multipleBeans;\n\t\t\t}\n\n\t\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);\n\t\t\tif (matchingBeans.isEmpty()) {\n\t\t\t\tif (isRequired(descriptor)) {\n\t\t\t\t\traiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tString autowiredBeanName;\n\t\t\tObject instanceCandidate;\n\n\t\t\tif (matchingBeans.size() > 1) {\n\t\t\t\tautowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);\n\t\t\t\tif (autowiredBeanName == null) {\n\t\t\t\t\tif (isRequired(descriptor) || !indicatesMultipleBeans(type)) {\n\t\t\t\t\t\treturn descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// In case of an optional Collection/Map, silently ignore a non-unique case:\n\t\t\t\t\t\t// possibly it was meant to be an empty collection of multiple regular beans\n\t\t\t\t\t\t// (before 4.3 in particular when we didn't even look for collection beans).\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinstanceCandidate = matchingBeans.get(autowiredBeanName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We have exactly one match.\n\t\t\t\tMap.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();\n\t\t\t\tautowiredBeanName = entry.getKey();\n\t\t\t\tinstanceCandidate = entry.getValue();\n\t\t\t}\n\n\t\t\tif (autowiredBeanNames != null) {\n\t\t\t\tautowiredBeanNames.add(autowiredBeanName);\n\t\t\t}\n\t\t\tif (instanceCandidate instanceof Class) {\n\t\t\t\tinstanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);\n\t\t\t}\n\t\t\tObject result = instanceCandidate;\n\t\t\tif (result instanceof NullBean) {\n\t\t\t\tif (isRequired(descriptor)) {\n\t\t\t\t\traiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);\n\t\t\t\t}\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t\tif (!ClassUtils.isAssignableValue(type, result)) {\n\t\t\t\tthrow new BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tfinally {\n\t\t\tConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#evaluate(candidate,paramCount)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "candidate",
      "paramCount"
    ],
    "position": {
      "column": 1,
      "line": 1296
    },
    "return": "String[]",
    "signature": "public String[] evaluate(Constructor<?> candidate, int paramCount)",
    "source_code": "\t\tpublic static String[] evaluate(Constructor<?> candidate, int paramCount) {\n\t\t\tConstructorProperties cp = candidate.getAnnotation(ConstructorProperties.class);\n\t\t\tif (cp != null) {\n\t\t\t\tString[] names = cp.value();\n\t\t\t\tif (names.length != paramCount) {\n\t\t\t\t\tthrow new IllegalStateException(\"Constructor annotated with @ConstructorProperties but not \" +\n\t\t\t\t\t\t\t\"corresponding to actual number of parameters (\" + paramCount + \"): \" + candidate);\n\t\t\t\t}\n\t\t\t\treturn names;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#evaluateBeanDefinitionString(value,beanDefinition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Evaluate the given String as contained in a bean definition,\n\t * potentially resolving it as an expression.\n\t * @param value the value to check\n\t * @param beanDefinition the bean definition that the value comes from\n\t * @return the resolved value\n\t * @see #setBeanExpressionResolver\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 1581
    },
    "return": "Object",
    "signature": "protected Object evaluateBeanDefinitionString(@Nullable String value, @Nullable BeanDefinition beanDefinition)",
    "source_code": "\tprotected Object evaluateBeanDefinitionString(@Nullable String value, @Nullable BeanDefinition beanDefinition) {\n\t\tif (this.beanExpressionResolver == null) {\n\t\t\treturn value;\n\t\t}\n\n\t\tScope scope = null;\n\t\tif (beanDefinition != null) {\n\t\t\tString scopeName = beanDefinition.getScope();\n\t\t\tif (scopeName != null) {\n\t\t\t\tscope = getRegisteredScope(scopeName);\n\t\t\t}\n\t\t}\n\t\treturn this.beanExpressionResolver.evaluate(value, new BeanExpressionContext(this, scope));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#filterPropertyDescriptorsForDependencyCheck(bw,cache)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extract a filtered set of PropertyDescriptors from the given BeanWrapper,\n\t * excluding ignored dependency types or properties defined on ignored dependency interfaces.\n\t * @param bw the BeanWrapper the bean was created with\n\t * @param cache whether to cache filtered PropertyDescriptors for the given bean Class\n\t * @return the filtered PropertyDescriptors\n\t * @see #isExcludedFromDependencyCheck\n\t * @see #filterPropertyDescriptorsForDependencyCheck(org.springframework.beans.BeanWrapper)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bw",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 1532
    },
    "return": "PropertyDescriptor[]",
    "signature": "protected PropertyDescriptor[] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw, boolean cache)",
    "source_code": "\tprotected PropertyDescriptor[] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw, boolean cache) {\n\t\tPropertyDescriptor[] filtered = this.filteredPropertyDescriptorsCache.get(bw.getWrappedClass());\n\t\tif (filtered == null) {\n\t\t\tfiltered = filterPropertyDescriptorsForDependencyCheck(bw);\n\t\t\tif (cache) {\n\t\t\t\tPropertyDescriptor[] existing =\n\t\t\t\t\t\tthis.filteredPropertyDescriptorsCache.putIfAbsent(bw.getWrappedClass(), filtered);\n\t\t\t\tif (existing != null) {\n\t\t\t\t\tfiltered = existing;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn filtered;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#findAllAnnotationsOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 767
    },
    "return": "Set<A>",
    "signature": "public Set<A> findAllAnnotationsOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> Set<A> findAllAnnotationsOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tSet<A> annotations = new LinkedHashSet<>();\n\t\tClass<?> beanType = getType(beanName, allowFactoryBeanInit);\n\t\tif (beanType != null) {\n\t\t\tMergedAnnotations.from(beanType, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t\t.stream(annotationType)\n\t\t\t\t\t.filter(MergedAnnotation::isPresent)\n\t\t\t\t\t.forEach(mergedAnnotation -> annotations.add(mergedAnnotation.synthesize()));\n\t\t}\n\t\tif (containsBeanDefinition(beanName)) {\n\t\t\tRootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n\t\t\t// Check raw bean class, e.g. in case of a proxy.\n\t\t\tif (bd.hasBeanClass() && bd.getFactoryMethodName() == null) {\n\t\t\t\tClass<?> beanClass = bd.getBeanClass();\n\t\t\t\tif (beanClass != beanType) {\n\t\t\t\t\tMergedAnnotations.from(beanClass, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t\t\t\t.stream(annotationType)\n\t\t\t\t\t\t\t.filter(MergedAnnotation::isPresent)\n\t\t\t\t\t\t\t.forEach(mergedAnnotation -> annotations.add(mergedAnnotation.synthesize()));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check annotations declared on factory method, if any.\n\t\t\tMethod factoryMethod = bd.getResolvedFactoryMethod();\n\t\t\tif (factoryMethod != null) {\n\t\t\t\tMergedAnnotations.from(factoryMethod, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t\t\t.stream(annotationType)\n\t\t\t\t\t\t.filter(MergedAnnotation::isPresent)\n\t\t\t\t\t\t.forEach(mergedAnnotation -> annotations.add(mergedAnnotation.synthesize()));\n\t\t\t}\n\t\t}\n\t\treturn annotations;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#findAnnotationOnBean(beanName,annotationType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 720
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\treturn findAnnotationOnBean(beanName, annotationType, true);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#findAnnotationOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 728
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tClass<?> beanType = getType(beanName, allowFactoryBeanInit);\n\t\tif (beanType != null) {\n\t\t\tMergedAnnotation<A> annotation =\n\t\t\t\t\tMergedAnnotations.from(beanType, SearchStrategy.TYPE_HIERARCHY).get(annotationType);\n\t\t\tif (annotation.isPresent()) {\n\t\t\t\treturn annotation.synthesize();\n\t\t\t}\n\t\t}\n\t\tif (containsBeanDefinition(beanName)) {\n\t\t\tRootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n\t\t\t// Check raw bean class, e.g. in case of a proxy.\n\t\t\tif (bd.hasBeanClass() && bd.getFactoryMethodName() == null) {\n\t\t\t\tClass<?> beanClass = bd.getBeanClass();\n\t\t\t\tif (beanClass != beanType) {\n\t\t\t\t\tMergedAnnotation<A> annotation =\n\t\t\t\t\t\t\tMergedAnnotations.from(beanClass, SearchStrategy.TYPE_HIERARCHY).get(annotationType);\n\t\t\t\t\tif (annotation.isPresent()) {\n\t\t\t\t\t\treturn annotation.synthesize();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check annotations declared on factory method, if any.\n\t\t\tMethod factoryMethod = bd.getResolvedFactoryMethod();\n\t\t\tif (factoryMethod != null) {\n\t\t\t\tMergedAnnotation<A> annotation =\n\t\t\t\t\t\tMergedAnnotations.from(factoryMethod, SearchStrategy.TYPE_HIERARCHY).get(annotationType);\n\t\t\t\tif (annotation.isPresent()) {\n\t\t\t\t\treturn annotation.synthesize();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#findAutowireCandidates(beanName,requiredType,descriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find bean instances that match the required type.\n\t * Called during autowiring for the specified bean.\n\t * @param beanName the name of the bean that is about to be wired\n\t * @param requiredType the actual type of bean to look for\n\t * (may be an array component type or collection element type)\n\t * @param descriptor the descriptor of the dependency to resolve\n\t * @return a Map of candidate names and candidate instances that match\n\t * the required type (never {@code null})\n\t * @throws BeansException in case of errors\n\t * @see #autowireByType\n\t * @see #autowireConstructor\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "requiredType",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 1566
    },
    "return": "Object>",
    "signature": "protected Object> findAutowireCandidates(@Nullable String beanName, Class<?> requiredType, DependencyDescriptor descriptor)",
    "source_code": "\tprotected Map<String, Object> findAutowireCandidates(\n\t\t\t@Nullable String beanName, Class<?> requiredType, DependencyDescriptor descriptor) {\n\n\t\tString[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n\t\t\t\tthis, requiredType, true, descriptor.isEager());\n\t\tMap<String, Object> result = CollectionUtils.newLinkedHashMap(candidateNames.length);\n\t\tfor (Map.Entry<Class<?>, Object> classObjectEntry : this.resolvableDependencies.entrySet()) {\n\t\t\tClass<?> autowiringType = classObjectEntry.getKey();\n\t\t\tif (autowiringType.isAssignableFrom(requiredType)) {\n\t\t\t\tObject autowiringValue = classObjectEntry.getValue();\n\t\t\t\tautowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);\n\t\t\t\tif (requiredType.isInstance(autowiringValue)) {\n\t\t\t\t\tresult.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (String candidate : candidateNames) {\n\t\t\tif (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, descriptor)) {\n\t\t\t\taddCandidateEntry(result, candidate, descriptor, requiredType);\n\t\t\t}\n\t\t}\n\t\tif (result.isEmpty()) {\n\t\t\tboolean multiple = indicatesMultipleBeans(requiredType);\n\t\t\t// Consider fallback matches if the first pass failed to find anything...\n\t\t\tDependencyDescriptor fallbackDescriptor = descriptor.forFallbackMatch();\n\t\t\tfor (String candidate : candidateNames) {\n\t\t\t\tif (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, fallbackDescriptor) &&\n\t\t\t\t\t\t(!multiple || getAutowireCandidateResolver().hasQualifier(descriptor))) {\n\t\t\t\t\taddCandidateEntry(result, candidate, descriptor, requiredType);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result.isEmpty() && !multiple) {\n\t\t\t\t// Consider self references as a final pass...\n\t\t\t\t// but in the case of a dependency collection, not the very same bean itself.\n\t\t\t\tfor (String candidate : candidateNames) {\n\t\t\t\t\tif (isSelfReference(beanName, candidate) &&\n\t\t\t\t\t\t\t(!(descriptor instanceof MultiElementDescriptor) || !beanName.equals(candidate)) &&\n\t\t\t\t\t\t\tisAutowireCandidate(candidate, fallbackDescriptor)) {\n\t\t\t\t\t\taddCandidateEntry(result, candidate, descriptor, requiredType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBean(name,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "Object",
    "signature": "public Object getBean(String name, Object... args)",
    "source_code": "\tpublic Object getBean(String name, Object... args) throws BeansException {\n\t\treturn doGetBean(name, null, args, false);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBean(name,requiredType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "T",
    "signature": "public T getBean(String name, Class<T> requiredType)",
    "source_code": "\tpublic <T> T getBean(String name, Class<T> requiredType) throws BeansException {\n\t\treturn doGetBean(name, requiredType, null, false);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBean(name,requiredType,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return an instance, which may be shared or independent, of the specified bean.\n\t * @param name the name of the bean to retrieve\n\t * @param requiredType the required type of the bean to retrieve\n\t * @param args arguments to use when creating a bean instance using explicit arguments\n\t * (only applied when creating a new instance as opposed to retrieving an existing one)\n\t * @return an instance of the bean\n\t * @throws BeansException if the bean could not be created\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "T",
    "signature": "public T getBean(String name, @Nullable Class<T> requiredType, @Nullable Object... args)",
    "source_code": "\tpublic <T> T getBean(String name, @Nullable Class<T> requiredType, @Nullable Object... args)\n\t\t\tthrows BeansException {\n\n\t\treturn doGetBean(name, requiredType, args, false);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBean(requiredType,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "T",
    "signature": "public T getBean(Class<T> requiredType, @Nullable Object... args)",
    "source_code": "\tpublic <T> T getBean(Class<T> requiredType, @Nullable Object... args) throws BeansException {\n\t\tAssert.notNull(requiredType, \"Required type must not be null\");\n\t\tObject resolved = resolveBean(ResolvableType.forRawClass(requiredType), args, false);\n\t\tif (resolved == null) {\n\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t}\n\t\treturn (T) resolved;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBeanNamesForType(type,includeNonSingletons,allowEagerInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 529
    },
    "return": "String[]",
    "signature": "public String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {\n\t\tif (!isConfigurationFrozen() || type == null || !allowEagerInit) {\n\t\t\treturn doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);\n\t\t}\n\t\tMap<Class<?>, String[]> cache =\n\t\t\t\t(includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType);\n\t\tString[] resolvedBeanNames = cache.get(type);\n\t\tif (resolvedBeanNames != null) {\n\t\t\treturn resolvedBeanNames;\n\t\t}\n\t\tresolvedBeanNames = doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, true);\n\t\tif (ClassUtils.isCacheSafe(type, getBeanClassLoader())) {\n\t\t\tcache.put(type, resolvedBeanNames);\n\t\t}\n\t\treturn resolvedBeanNames;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBeanProvider(requiredType,allowEagerInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "ObjectProvider<T>",
    "signature": "public ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit)",
    "source_code": "\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit) {\n\t\treturn new BeanObjectProvider<>() {\n\t\t\t@Override\n\t\t\tpublic T getObject() throws BeansException {\n\t\t\t\tT resolved = resolveBean(requiredType, null, false);\n\t\t\t\tif (resolved == null) {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t\t\t}\n\t\t\t\treturn resolved;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic T getObject(Object... args) throws BeansException {\n\t\t\t\tT resolved = resolveBean(requiredType, args, false);\n\t\t\t\tif (resolved == null) {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t\t\t}\n\t\t\t\treturn resolved;\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T getIfAvailable() throws BeansException {\n\t\t\t\ttry {\n\t\t\t\t\treturn resolveBean(requiredType, null, false);\n\t\t\t\t}\n\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t// Ignore resolved bean in non-active scope\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void ifAvailable(Consumer<T> dependencyConsumer) throws BeansException {\n\t\t\t\tT dependency = getIfAvailable();\n\t\t\t\tif (dependency != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdependencyConsumer.accept(dependency);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t\t// Ignore resolved bean in non-active scope, even on scoped proxy invocation\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T getIfUnique() throws BeansException {\n\t\t\t\ttry {\n\t\t\t\t\treturn resolveBean(requiredType, null, true);\n\t\t\t\t}\n\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t// Ignore resolved bean in non-active scope\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void ifUnique(Consumer<T> dependencyConsumer) throws BeansException {\n\t\t\t\tT dependency = getIfUnique();\n\t\t\t\tif (dependency != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdependencyConsumer.accept(dependency);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t\t// Ignore resolved bean in non-active scope, even on scoped proxy invocation\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t@Override\n\t\t\tpublic Stream<T> stream() {\n\t\t\t\treturn Arrays.stream(getBeanNamesForTypedStream(requiredType, allowEagerInit))\n\t\t\t\t\t\t.map(name -> (T) getBean(name))\n\t\t\t\t\t\t.filter(bean -> !(bean instanceof NullBean));\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t@Override\n\t\t\tpublic Stream<T> orderedStream() {\n\t\t\t\tString[] beanNames = getBeanNamesForTypedStream(requiredType, allowEagerInit);\n\t\t\t\tif (beanNames.length == 0) {\n\t\t\t\t\treturn Stream.empty();\n\t\t\t\t}\n\t\t\t\tMap<String, T> matchingBeans = CollectionUtils.newLinkedHashMap(beanNames.length);\n\t\t\t\tfor (String beanName : beanNames) {\n\t\t\t\t\tObject beanInstance = getBean(beanName);\n\t\t\t\t\tif (!(beanInstance instanceof NullBean)) {\n\t\t\t\t\t\tmatchingBeans.put(beanName, (T) beanInstance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStream<T> stream = matchingBeans.values().stream();\n\t\t\t\treturn stream.sorted(adaptOrderComparator(matchingBeans));\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBeansOfType(type,includeNonSingletons,allowEagerInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 655
    },
    "return": "T>",
    "signature": "public T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic <T> Map<String, T> getBeansOfType(\n\t\t\t@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) throws BeansException {\n\n\t\tString[] beanNames = getBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n\t\tMap<String, T> result = CollectionUtils.newLinkedHashMap(beanNames.length);\n\t\tfor (String beanName : beanNames) {\n\t\t\ttry {\n\t\t\t\tObject beanInstance = getBean(beanName);\n\t\t\t\tif (!(beanInstance instanceof NullBean)) {\n\t\t\t\t\tresult.put(beanName, (T) beanInstance);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (BeanCreationException ex) {\n\t\t\t\tThrowable rootCause = ex.getMostSpecificCause();\n\t\t\t\tif (rootCause instanceof BeanCurrentlyInCreationException bce) {\n\t\t\t\t\tString exBeanName = bce.getBeanName();\n\t\t\t\t\tif (exBeanName != null && isCurrentlyInCreation(exBeanName)) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Ignoring match to currently created bean '\" + exBeanName + \"': \" +\n\t\t\t\t\t\t\t\t\tex.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tonSuppressedException(ex);\n\t\t\t\t\t\t// Ignore: indicates a circular reference when autowiring constructors.\n\t\t\t\t\t\t// We want to find matches other than the currently created bean itself.\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getEarlyBeanReference(beanName,mbd,bean)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a reference for early access to the specified bean,\n\t * typically for the purpose of resolving a circular reference.\n\t * @param beanName the name of the bean (for error handling purposes)\n\t * @param mbd the merged bean definition for the bean\n\t * @param bean the raw bean instance\n\t * @return the object to expose as bean reference\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 948
    },
    "return": "Object",
    "signature": "protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean)",
    "source_code": "\tprotected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {\n\t\tObject exposedObject = bean;\n\t\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) {\n\t\t\t\texposedObject = bp.getEarlyBeanReference(exposedObject, beanName);\n\t\t\t}\n\t\t}\n\t\treturn exposedObject;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getMergedBeanDefinition(beanName,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a RootBeanDefinition for the given top-level bean, by merging with\n\t * the parent if the given bean's definition is a child bean definition.\n\t * @param beanName the name of the bean definition\n\t * @param bd the original bean definition (Root/ChildBeanDefinition)\n\t * @return a (potentially merged) RootBeanDefinition for the given bean\n\t * @throws BeanDefinitionStoreException in case of an invalid bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 1329
    },
    "return": "RootBeanDefinition",
    "signature": "protected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd)",
    "source_code": "\tprotected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\treturn getMergedBeanDefinition(beanName, bd, null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getMergedBeanDefinition(beanName,bd,containingBd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a RootBeanDefinition for the given bean, by merging with the\n\t * parent if the given bean's definition is a child bean definition.\n\t * @param beanName the name of the bean definition\n\t * @param bd the original bean definition (Root/ChildBeanDefinition)\n\t * @param containingBd the containing bean definition in case of inner bean,\n\t * or {@code null} in case of a top-level bean\n\t * @return a (potentially merged) RootBeanDefinition for the given bean\n\t * @throws BeanDefinitionStoreException in case of an invalid bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bd",
      "containingBd"
    ],
    "position": {
      "column": 1,
      "line": 1345
    },
    "return": "RootBeanDefinition",
    "signature": "protected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd)",
    "source_code": "\tprotected RootBeanDefinition getMergedBeanDefinition(\n\t\t\tString beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\tsynchronized (this.mergedBeanDefinitions) {\n\t\t\tRootBeanDefinition mbd = null;\n\t\t\tRootBeanDefinition previous = null;\n\n\t\t\t// Check with full lock now in order to enforce the same merged instance.\n\t\t\tif (containingBd == null) {\n\t\t\t\tmbd = this.mergedBeanDefinitions.get(beanName);\n\t\t\t}\n\n\t\t\tif (mbd == null || mbd.stale) {\n\t\t\t\tprevious = mbd;\n\t\t\t\tif (bd.getParentName() == null) {\n\t\t\t\t\t// Use copy of given root bean definition.\n\t\t\t\t\tif (bd instanceof RootBeanDefinition rootBeanDef) {\n\t\t\t\t\t\tmbd = rootBeanDef.cloneBeanDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmbd = new RootBeanDefinition(bd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Child bean definition: needs to be merged with parent.\n\t\t\t\t\tBeanDefinition pbd;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString parentBeanName = transformedBeanName(bd.getParentName());\n\t\t\t\t\t\tif (!beanName.equals(parentBeanName)) {\n\t\t\t\t\t\t\tpbd = getMergedBeanDefinition(parentBeanName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (getParentBeanFactory() instanceof ConfigurableBeanFactory parent) {\n\t\t\t\t\t\t\t\tpbd = parent.getMergedBeanDefinition(parentBeanName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthrow new NoSuchBeanDefinitionException(parentBeanName,\n\t\t\t\t\t\t\t\t\t\t\"Parent name '\" + parentBeanName + \"' is equal to bean name '\" + beanName +\n\t\t\t\t\t\t\t\t\t\t\t\t\"': cannot be resolved without a ConfigurableBeanFactory parent\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t\tthrow new BeanDefinitionStoreException(bd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\"Could not resolve parent bean definition '\" + bd.getParentName() + \"'\", ex);\n\t\t\t\t\t}\n\t\t\t\t\t// Deep copy with overridden values.\n\t\t\t\t\tmbd = new RootBeanDefinition(pbd);\n\t\t\t\t\tmbd.overrideFrom(bd);\n\t\t\t\t}\n\n\t\t\t\t// Set default singleton scope, if not configured before.\n\t\t\t\tif (!StringUtils.hasLength(mbd.getScope())) {\n\t\t\t\t\tmbd.setScope(SCOPE_SINGLETON);\n\t\t\t\t}\n\n\t\t\t\t// A bean contained in a non-singleton bean cannot be a singleton itself.\n\t\t\t\t// Let's correct this on the fly here, since this might be the result of\n\t\t\t\t// parent-child merging for the outer bean, in which case the original inner bean\n\t\t\t\t// definition will not have inherited the merged outer bean's singleton status.\n\t\t\t\tif (containingBd != null && !containingBd.isSingleton() && mbd.isSingleton()) {\n\t\t\t\t\tmbd.setScope(containingBd.getScope());\n\t\t\t\t}\n\n\t\t\t\t// Cache the merged bean definition for the time being\n\t\t\t\t// (it might still get re-merged later on in order to pick up metadata changes)\n\t\t\t\tif (containingBd == null && isCacheBeanMetadata()) {\n\t\t\t\t\tthis.mergedBeanDefinitions.put(beanName, mbd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (previous != null) {\n\t\t\t\tcopyRelevantMergedBeanDefinitionCaches(previous, mbd);\n\t\t\t}\n\t\t\treturn mbd;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getObjectForBeanInstance(beanInstance,name,beanName,mbd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the object for the given bean instance, either the bean\n\t * instance itself or its created object in case of a FactoryBean.\n\t * @param beanInstance the shared bean instance\n\t * @param name the name that may include factory dereference prefix\n\t * @param beanName the canonical bean name\n\t * @param mbd the merged bean definition\n\t * @return the object to expose for the bean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanInstance",
      "name",
      "beanName",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1785
    },
    "return": "Object",
    "signature": "protected Object getObjectForBeanInstance(Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd)",
    "source_code": "\tprotected Object getObjectForBeanInstance(\n\t\t\tObject beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) {\n\n\t\t// Don't let calling code try to dereference the factory if the bean isn't a factory.\n\t\tif (BeanFactoryUtils.isFactoryDereference(name)) {\n\t\t\tif (beanInstance instanceof NullBean) {\n\t\t\t\treturn beanInstance;\n\t\t\t}\n\t\t\tif (!(beanInstance instanceof FactoryBean)) {\n\t\t\t\tthrow new BeanIsNotAFactoryException(beanName, beanInstance.getClass());\n\t\t\t}\n\t\t\tif (mbd != null) {\n\t\t\t\tmbd.isFactoryBean = true;\n\t\t\t}\n\t\t\treturn beanInstance;\n\t\t}\n\n\t\t// Now we have the bean instance, which may be a normal bean or a FactoryBean.\n\t\t// If it's a FactoryBean, we use it to create a bean instance, unless the\n\t\t// caller actually wants a reference to the factory.\n\t\tif (!(beanInstance instanceof FactoryBean<?> factoryBean)) {\n\t\t\treturn beanInstance;\n\t\t}\n\n\t\tObject object = null;\n\t\tif (mbd != null) {\n\t\t\tmbd.isFactoryBean = true;\n\t\t}\n\t\telse {\n\t\t\tobject = getCachedObjectForFactoryBean(beanName);\n\t\t}\n\t\tif (object == null) {\n\t\t\t// Return bean instance from factory.\n\t\t\t// Caches object obtained from FactoryBean if it is a singleton.\n\t\t\tif (mbd == null && containsBeanDefinition(beanName)) {\n\t\t\t\tmbd = getMergedLocalBeanDefinition(beanName);\n\t\t\t}\n\t\t\tboolean synthetic = (mbd != null && mbd.isSynthetic());\n\t\t\tobject = getObjectFromFactoryBean(factoryBean, beanName, !synthetic);\n\t\t}\n\t\treturn object;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getObjectFromFactoryBean(factory,beanName,shouldPostProcess)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain an object to expose from the given FactoryBean.\n\t * @param factory the FactoryBean instance\n\t * @param beanName the name of the bean\n\t * @param shouldPostProcess whether the bean is subject to post-processing\n\t * @return the object obtained from the FactoryBean\n\t * @throws BeanCreationException if FactoryBean object creation failed\n\t * @see org.springframework.beans.factory.FactoryBean#getObject()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "factory",
      "beanName",
      "shouldPostProcess"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "Object",
    "signature": "protected Object getObjectFromFactoryBean(FactoryBean<?> factory, String beanName, boolean shouldPostProcess)",
    "source_code": "\tprotected Object getObjectFromFactoryBean(FactoryBean<?> factory, String beanName, boolean shouldPostProcess) {\n\t\tif (factory.isSingleton() && containsSingleton(beanName)) {\n\t\t\tsynchronized (getSingletonMutex()) {\n\t\t\t\tObject object = this.factoryBeanObjectCache.get(beanName);\n\t\t\t\tif (object == null) {\n\t\t\t\t\tobject = doGetObjectFromFactoryBean(factory, beanName);\n\t\t\t\t\t// Only post-process and store if not put there already during getObject() call above\n\t\t\t\t\t// (e.g. because of circular reference processing triggered by custom getBean calls)\n\t\t\t\t\tObject alreadyThere = this.factoryBeanObjectCache.get(beanName);\n\t\t\t\t\tif (alreadyThere != null) {\n\t\t\t\t\t\tobject = alreadyThere;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (shouldPostProcess) {\n\t\t\t\t\t\t\tif (isSingletonCurrentlyInCreation(beanName)) {\n\t\t\t\t\t\t\t\t// Temporarily return non-post-processed object, not storing it yet..\n\t\t\t\t\t\t\t\treturn object;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbeforeSingletonCreation(beanName);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tobject = postProcessObjectFromFactoryBean(object, beanName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t\t\tthrow new BeanCreationException(beanName,\n\t\t\t\t\t\t\t\t\t\t\"Post-processing of FactoryBean's singleton object failed\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\t\tafterSingletonCreation(beanName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (containsSingleton(beanName)) {\n\t\t\t\t\t\t\tthis.factoryBeanObjectCache.put(beanName, object);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn object;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tObject object = doGetObjectFromFactoryBean(factory, beanName);\n\t\t\tif (shouldPostProcess) {\n\t\t\t\ttry {\n\t\t\t\t\tobject = postProcessObjectFromFactoryBean(object, beanName);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new BeanCreationException(beanName, \"Post-processing of FactoryBean's object failed\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn object;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getReturnTypeForFactoryMethod(rbd,descriptor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rbd",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "ResolvableType",
    "signature": "protected ResolvableType getReturnTypeForFactoryMethod(RootBeanDefinition rbd, DependencyDescriptor descriptor)",
    "source_code": "\tprotected ResolvableType getReturnTypeForFactoryMethod(RootBeanDefinition rbd, DependencyDescriptor descriptor) {\n\t\t// Should typically be set for any kind of factory method, since the BeanFactory\n\t\t// pre-resolves them before reaching out to the AutowireCandidateResolver...\n\t\tResolvableType returnType = rbd.factoryMethodReturnType;\n\t\tif (returnType == null) {\n\t\t\tMethod factoryMethod = rbd.getResolvedFactoryMethod();\n\t\t\tif (factoryMethod != null) {\n\t\t\t\treturnType = ResolvableType.forMethodReturnType(factoryMethod);\n\t\t\t}\n\t\t}\n\t\tif (returnType != null) {\n\t\t\tClass<?> resolvedClass = returnType.resolve();\n\t\t\tif (resolvedClass != null && descriptor.getDependencyType().isAssignableFrom(resolvedClass)) {\n\t\t\t\t// Only use factory method metadata if the return type is actually expressive enough\n\t\t\t\t// for our dependency. Otherwise, the returned instance type may have matched instead\n\t\t\t\t// in case of a singleton instance having been registered with the container already.\n\t\t\t\treturn returnType;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getTypeForFactoryBean(beanName,mbd,allowInit)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the bean type for the given FactoryBean definition, as far as possible.\n\t * Only called if there is no singleton instance registered for the target bean\n\t * already. The implementation is allowed to instantiate the target factory bean if\n\t * {@code allowInit} is {@code true} and the type cannot be determined another way;\n\t * otherwise it is restricted to introspecting signatures and related metadata.\n\t * <p>If no {@link FactoryBean#OBJECT_TYPE_ATTRIBUTE} if set on the bean definition\n\t * and {@code allowInit} is {@code true}, the default implementation will create\n\t * the FactoryBean via {@code getBean} to call its {@code getObjectType} method.\n\t * Subclasses are encouraged to optimize this, typically by inspecting the generic\n\t * signature of the factory bean class or the factory method that creates it.\n\t * If subclasses do instantiate the FactoryBean, they should consider trying the\n\t * {@code getObjectType} method without fully populating the bean. If this fails,\n\t * a full FactoryBean creation as performed by this implementation should be used\n\t * as fallback.\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition for the bean\n\t * @param allowInit if initialization of the FactoryBean is permitted if the type\n\t * cannot be determined another way\n\t * @return the type for the bean if determinable, otherwise {@code ResolvableType.NONE}\n\t * @since 5.2\n\t * @see org.springframework.beans.factory.FactoryBean#getObjectType()\n\t * @see #getBean(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "allowInit"
    ],
    "position": {
      "column": 1,
      "line": 1663
    },
    "return": "ResolvableType",
    "signature": "protected ResolvableType getTypeForFactoryBean(String beanName, RootBeanDefinition mbd, boolean allowInit)",
    "source_code": "\tprotected ResolvableType getTypeForFactoryBean(String beanName, RootBeanDefinition mbd, boolean allowInit) {\n\t\tResolvableType result = getTypeForFactoryBeanFromAttributes(mbd);\n\t\tif (result != ResolvableType.NONE) {\n\t\t\treturn result;\n\t\t}\n\n\t\tif (allowInit && mbd.isSingleton()) {\n\t\t\ttry {\n\t\t\t\tFactoryBean<?> factoryBean = doGetBean(FACTORY_BEAN_PREFIX + beanName, FactoryBean.class, null, true);\n\t\t\t\tClass<?> objectType = getTypeForFactoryBean(factoryBean);\n\t\t\t\treturn (objectType != null ? ResolvableType.forClass(objectType) : ResolvableType.NONE);\n\t\t\t}\n\t\t\tcatch (BeanCreationException ex) {\n\t\t\t\tif (ex.contains(BeanCurrentlyInCreationException.class)) {\n\t\t\t\t\tlogger.trace(LogMessage.format(\"Bean currently in creation on FactoryBean type check: %s\", ex));\n\t\t\t\t}\n\t\t\t\telse if (mbd.isLazyInit()) {\n\t\t\t\t\tlogger.trace(LogMessage.format(\"Bean creation exception on lazy FactoryBean type check: %s\", ex));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.debug(LogMessage.format(\"Bean creation exception on eager FactoryBean type check: %s\", ex));\n\t\t\t\t}\n\t\t\t\tonSuppressedException(ex);\n\t\t\t}\n\t\t}\n\t\treturn ResolvableType.NONE;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#initializeBean(beanName,bean,mbd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the given bean instance, applying factory callbacks\n\t * as well as init methods and bean post processors.\n\t * <p>Called from {@link #createBean} for traditionally defined beans,\n\t * and from {@link #initializeBean} for existing bean instances.\n\t * @param beanName the bean name in the factory (for debugging purposes)\n\t * @param bean the new bean instance we may need to initialize\n\t * @param mbd the bean definition that the bean was created with\n\t * (can also be {@code null}, if given an existing bean instance)\n\t * @return the initialized bean instance (potentially wrapped)\n\t * @see BeanNameAware\n\t * @see BeanClassLoaderAware\n\t * @see BeanFactoryAware\n\t * @see #applyBeanPostProcessorsBeforeInitialization\n\t * @see #invokeInitMethods\n\t * @see #applyBeanPostProcessorsAfterInitialization\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bean",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1739
    },
    "return": "Object",
    "signature": "protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd)",
    "source_code": "\tprotected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {\n\t\tinvokeAwareMethods(beanName, bean);\n\n\t\tObject wrappedBean = bean;\n\t\tif (mbd == null || !mbd.isSynthetic()) {\n\t\t\twrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n\t\t}\n\n\t\ttry {\n\t\t\tinvokeInitMethods(beanName, wrappedBean, mbd);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t(mbd != null ? mbd.getResourceDescription() : null), beanName, ex.getMessage(), ex);\n\t\t}\n\t\tif (mbd == null || !mbd.isSynthetic()) {\n\t\t\twrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n\t\t}\n\n\t\treturn wrappedBean;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#initializeBean(existingBean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "Object",
    "signature": "public Object initializeBean(Object existingBean, String beanName)",
    "source_code": "\tpublic Object initializeBean(Object existingBean, String beanName) {\n\t\treturn initializeBean(beanName, existingBean, null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiate(ctor,args)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Create a new instance of a dynamically generated subclass implementing the\n\t\t * required lookups.\n\t\t * @param ctor constructor to use. If this is {@code null}, use the\n\t\t * no-arg constructor (no parameterization, or Setter Injection)\n\t\t * @param args arguments to use for the constructor.\n\t\t * Ignored if the {@code ctor} parameter is {@code null}.\n\t\t * @return new instance of the dynamically generated subclass\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ctor",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "Object",
    "signature": "public Object instantiate(@Nullable Constructor<?> ctor, Object... args)",
    "source_code": "\t\tpublic Object instantiate(@Nullable Constructor<?> ctor, Object... args) {\n\t\t\tClass<?> subclass = createEnhancedSubclass(this.beanDefinition);\n\t\t\tObject instance;\n\t\t\tif (ctor == null) {\n\t\t\t\tinstance = BeanUtils.instantiateClass(subclass);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tConstructor<?> enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());\n\t\t\t\t\tinstance = enhancedSubclassConstructor.newInstance(args);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new BeanInstantiationException(this.beanDefinition.getBeanClass(),\n\t\t\t\t\t\t\t\"Failed to invoke constructor for CGLIB enhanced subclass [\" + subclass.getName() + \"]\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// SPR-10785: set callbacks directly on the instance instead of in the\n\t\t\t// enhanced class (via the Enhancer) in order to avoid memory leaks.\n\t\t\tFactory factory = (Factory) instance;\n\t\t\tfactory.setCallbacks(new Callback[] {NoOp.INSTANCE,\n\t\t\t\t\tnew LookupOverrideMethodInterceptor(this.beanDefinition, this.owner),\n\t\t\t\t\tnew ReplaceOverrideMethodInterceptor(this.beanDefinition, this.owner)});\n\t\t\treturn instance;\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiateBean(beanName,mbd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate the given bean using its default constructor.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @return a BeanWrapper for the new instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1299
    },
    "return": "BeanWrapper",
    "signature": "protected BeanWrapper instantiateBean(String beanName, RootBeanDefinition mbd)",
    "source_code": "\tprotected BeanWrapper instantiateBean(String beanName, RootBeanDefinition mbd) {\n\t\ttry {\n\t\t\tObject beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, this);\n\t\t\tBeanWrapper bw = new BeanWrapperImpl(beanInstance);\n\t\t\tinitBeanWrapper(bw);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiateUsingFactoryMethod(beanName,mbd,explicitArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate the bean using a named factory method. The method may be static, if the\n\t * mbd parameter specifies a class, rather than a factoryBean, or an instance variable\n\t * on a factory object itself configured using Dependency Injection.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param explicitArgs argument values passed in programmatically via the getBean method,\n\t * or {@code null} if none (implying the use of constructor argument values from bean definition)\n\t * @return a BeanWrapper for the new instance\n\t * @see #getBean(String, Object[])\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "explicitArgs"
    ],
    "position": {
      "column": 1,
      "line": 1322
    },
    "return": "BeanWrapper",
    "signature": "protected BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs)",
    "source_code": "\tprotected BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tString beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) {\n\n\t\treturn new ConstructorResolver(this).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiateWithMethodInjection(bd,beanName,owner)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "beanName",
      "owner"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "Object",
    "signature": "protected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)",
    "source_code": "\tprotected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {\n\t\treturn instantiateWithMethodInjection(bd, beanName, owner, null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiateWithMethodInjection(bd,beanName,owner,ctor,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "beanName",
      "owner",
      "ctor",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "Object",
    "signature": "protected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n\t\t\t@Nullable Constructor<?> ctor, Object... args)",
    "source_code": "\tprotected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n\t\t\t@Nullable Constructor<?> ctor, Object... args) {\n\n\t\treturn new CglibSubclassCreator(bd, owner).instantiate(ctor, args);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#intercept(obj,method,args,mp)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj",
      "method",
      "args",
      "mp"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "Object",
    "signature": "public Object intercept(Object obj, Method method, Object[] args, MethodProxy mp)",
    "source_code": "\t\tpublic Object intercept(Object obj, Method method, Object[] args, MethodProxy mp) throws Throwable {\n\t\t\tReplaceOverride ro = (ReplaceOverride) getBeanDefinition().getMethodOverrides().getOverride(method);\n\t\t\tAssert.state(ro != null, \"ReplaceOverride not found\");\n\t\t\t// TODO could cache if a singleton for minor performance optimization\n\t\t\tMethodReplacer mr = this.owner.getBean(ro.getMethodReplacerBeanName(), MethodReplacer.class);\n\t\t\treturn mr.reimplement(obj, method, args);\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\treturn switch (method.getName()) {\n\t\t\t\tcase \"equals\" -> (proxy == args[0]); // Only consider equal when proxies are identical.\n\t\t\t\tcase \"hashCode\" -> System.identityHashCode(proxy); // Use hashCode of proxy.\n\t\t\t\tcase \"toString\" -> this.objectFactory.toString();\n\t\t\t\tdefault -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tyield method.invoke(this.objectFactory.getObject(), args);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#invokeCustomInitMethod(beanName,bean,mbd,initMethodName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified custom init method on the given bean.\n\t * Called by invokeInitMethods.\n\t * <p>Can be overridden in subclasses for custom resolution of init\n\t * methods with arguments.\n\t * @see #invokeInitMethods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bean",
      "mbd",
      "initMethodName"
    ],
    "position": {
      "column": 1,
      "line": 1822
    },
    "return": "void",
    "signature": "protected void invokeCustomInitMethod(String beanName, Object bean, RootBeanDefinition mbd, String initMethodName)",
    "source_code": "\tprotected void invokeCustomInitMethod(String beanName, Object bean, RootBeanDefinition mbd, String initMethodName)\n\t\t\tthrows Throwable {\n\n\t\tMethod initMethod = (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\tBeanUtils.findMethod(bean.getClass(), initMethodName) :\n\t\t\t\tClassUtils.getMethodIfAvailable(bean.getClass(), initMethodName));\n\n\t\tif (initMethod == null) {\n\t\t\tif (mbd.isEnforceInitMethod()) {\n\t\t\t\tthrow new BeanDefinitionValidationException(\"Could not find an init method named '\" +\n\t\t\t\t\t\tinitMethodName + \"' on bean with name '\" + beanName + \"'\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"No default init method named '\" + initMethodName +\n\t\t\t\t\t\t\t\"' found on bean with name '\" + beanName + \"'\");\n\t\t\t\t}\n\t\t\t\t// Ignore non-existent default lifecycle methods.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Invoking init method  '\" + initMethodName + \"' on bean with name '\" + beanName + \"'\");\n\t\t}\n\t\tMethod methodToInvoke = ClassUtils.getInterfaceMethodIfPossible(initMethod, bean.getClass());\n\n\t\ttry {\n\t\t\tReflectionUtils.makeAccessible(methodToInvoke);\n\t\t\tmethodToInvoke.invoke(bean);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tthrow ex.getTargetException();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#invokeInitMethods(beanName,bean,mbd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Give a bean a chance to react now all its properties are set,\n\t * and a chance to know about its owning bean factory (this object).\n\t * This means checking whether the bean implements InitializingBean or defines\n\t * a custom init method, and invoking the necessary callback(s) if it does.\n\t * @param beanName the bean name in the factory (for debugging purposes)\n\t * @param bean the new bean instance we may need to initialize\n\t * @param mbd the merged bean definition that the bean was created with\n\t * (can also be {@code null}, if given an existing bean instance)\n\t * @throws Throwable if thrown by init methods or by the invocation process\n\t * @see #invokeCustomInitMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bean",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1790
    },
    "return": "void",
    "signature": "protected void invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd)",
    "source_code": "\tprotected void invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd)\n\t\t\tthrows Throwable {\n\n\t\tboolean isInitializingBean = (bean instanceof InitializingBean);\n\t\tif (isInitializingBean && (mbd == null || !mbd.hasAnyExternallyManagedInitMethod(\"afterPropertiesSet\"))) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Invoking afterPropertiesSet() on bean with name '\" + beanName + \"'\");\n\t\t\t}\n\t\t\t((InitializingBean) bean).afterPropertiesSet();\n\t\t}\n\n\t\tif (mbd != null && bean.getClass() != NullBean.class) {\n\t\t\tString[] initMethodNames = mbd.getInitMethodNames();\n\t\t\tif (initMethodNames != null) {\n\t\t\t\tfor (String initMethodName : initMethodNames) {\n\t\t\t\t\tif (StringUtils.hasLength(initMethodName) &&\n\t\t\t\t\t\t\t!(isInitializingBean && \"afterPropertiesSet\".equals(initMethodName)) &&\n\t\t\t\t\t\t\t!mbd.hasAnyExternallyManagedInitMethod(initMethodName)) {\n\t\t\t\t\t\tinvokeCustomInitMethod(beanName, bean, mbd, initMethodName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isAutowireCandidate(bdHolder,descriptor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bdHolder",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "boolean",
    "signature": "public boolean isAutowireCandidate(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor)",
    "source_code": "\tpublic boolean isAutowireCandidate(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor) {\n\t\tif (!super.isAutowireCandidate(bdHolder, descriptor)) {\n\t\t\t// If explicitly false, do not proceed with any other checks...\n\t\t\treturn false;\n\t\t}\n\t\treturn checkGenericTypeMatch(bdHolder, descriptor);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isAutowireCandidate(beanName,descriptor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 821
    },
    "return": "boolean",
    "signature": "public boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor)",
    "source_code": "\tpublic boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\treturn isAutowireCandidate(beanName, descriptor, getAutowireCandidateResolver());\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isAutowireCandidate(beanName,descriptor,resolver)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the specified bean definition qualifies as an autowire candidate,\n\t * to be injected into other beans which declare a dependency of matching type.\n\t * @param beanName the name of the bean definition to check\n\t * @param descriptor the descriptor of the dependency to resolve\n\t * @param resolver the AutowireCandidateResolver to use for the actual resolution algorithm\n\t * @return whether the bean should be considered as autowire candidate\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "descriptor",
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 835
    },
    "return": "boolean",
    "signature": "protected boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor, AutowireCandidateResolver resolver)",
    "source_code": "\tprotected boolean isAutowireCandidate(\n\t\t\tString beanName, DependencyDescriptor descriptor, AutowireCandidateResolver resolver)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tString bdName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\tif (containsBeanDefinition(bdName)) {\n\t\t\treturn isAutowireCandidate(beanName, getMergedLocalBeanDefinition(bdName), descriptor, resolver);\n\t\t}\n\t\telse if (containsSingleton(beanName)) {\n\t\t\treturn isAutowireCandidate(beanName, new RootBeanDefinition(getType(beanName)), descriptor, resolver);\n\t\t}\n\n\t\tBeanFactory parent = getParentBeanFactory();\n\t\tif (parent instanceof DefaultListableBeanFactory dlbf) {\n\t\t\t// No bean definition found in this factory -> delegate to parent.\n\t\t\treturn dlbf.isAutowireCandidate(beanName, descriptor, resolver);\n\t\t}\n\t\telse if (parent instanceof ConfigurableListableBeanFactory clbf) {\n\t\t\t// If no DefaultListableBeanFactory, can't pass the resolver along.\n\t\t\treturn clbf.isAutowireCandidate(beanName, descriptor);\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isAutowireCandidate(beanName,mbd,descriptor,resolver)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the specified bean definition qualifies as an autowire candidate,\n\t * to be injected into other beans which declare a dependency of matching type.\n\t * @param beanName the name of the bean definition to check\n\t * @param mbd the merged bean definition to check\n\t * @param descriptor the descriptor of the dependency to resolve\n\t * @param resolver the AutowireCandidateResolver to use for the actual resolution algorithm\n\t * @return whether the bean should be considered as autowire candidate\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "descriptor",
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 870
    },
    "return": "boolean",
    "signature": "protected boolean isAutowireCandidate(String beanName, RootBeanDefinition mbd,\n\t\t\tDependencyDescriptor descriptor, AutowireCandidateResolver resolver)",
    "source_code": "\tprotected boolean isAutowireCandidate(String beanName, RootBeanDefinition mbd,\n\t\t\tDependencyDescriptor descriptor, AutowireCandidateResolver resolver) {\n\n\t\tString bdName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\tresolveBeanClass(mbd, bdName);\n\t\tif (mbd.isFactoryMethodUnique && mbd.factoryMethodToIntrospect == null) {\n\t\t\tnew ConstructorResolver(this).resolveFactoryMethodIfPossible(mbd);\n\t\t}\n\t\tBeanDefinitionHolder holder = (beanName.equals(bdName) ?\n\t\t\t\tthis.mergedBeanDefinitionHolders.computeIfAbsent(beanName,\n\t\t\t\t\t\tkey -> new BeanDefinitionHolder(mbd, beanName, getAliases(bdName))) :\n\t\t\t\tnew BeanDefinitionHolder(mbd, beanName, getAliases(bdName)));\n\t\treturn resolver.isAutowireCandidate(holder, descriptor);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isFactoryBean(beanName,mbd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given bean is defined as a {@link FactoryBean}.\n\t * @param beanName the name of the bean\n\t * @param mbd the corresponding bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1629
    },
    "return": "boolean",
    "signature": "protected boolean isFactoryBean(String beanName, RootBeanDefinition mbd)",
    "source_code": "\tprotected boolean isFactoryBean(String beanName, RootBeanDefinition mbd) {\n\t\tBoolean result = mbd.isFactoryBean;\n\t\tif (result == null) {\n\t\t\tClass<?> beanType = predictBeanType(beanName, mbd, FactoryBean.class);\n\t\t\tresult = (beanType != null && FactoryBean.class.isAssignableFrom(beanType));\n\t\t\tmbd.isFactoryBean = result;\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isPrimary(beanName,beanInstance)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the bean definition for the given bean name has been\n\t * marked as a primary bean.\n\t * @param beanName the name of the bean\n\t * @param beanInstance the corresponding bean instance (can be null)\n\t * @return whether the given bean qualifies as primary\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "beanInstance"
    ],
    "position": {
      "column": 1,
      "line": 1751
    },
    "return": "boolean",
    "signature": "protected boolean isPrimary(String beanName, Object beanInstance)",
    "source_code": "\tprotected boolean isPrimary(String beanName, Object beanInstance) {\n\t\tString transformedBeanName = transformedBeanName(beanName);\n\t\tif (containsBeanDefinition(transformedBeanName)) {\n\t\t\treturn getMergedLocalBeanDefinition(transformedBeanName).isPrimary();\n\t\t}\n\t\treturn (getParentBeanFactory() instanceof DefaultListableBeanFactory parent &&\n\t\t\t\tparent.isPrimary(transformedBeanName, beanInstance));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isSetterDefinedInInterface(pd,interfaces)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the setter method of the given bean property is defined\n\t * in any of the given interfaces.\n\t * @param pd the PropertyDescriptor of the bean property\n\t * @param interfaces the Set of interfaces (Class objects)\n\t * @return whether the setter method is defined by an interface\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pd",
      "interfaces"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "boolean",
    "signature": "public boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces)",
    "source_code": "\tpublic static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {\n\t\tMethod setter = pd.getWriteMethod();\n\t\tif (setter != null) {\n\t\t\tClass<?> targetClass = setter.getDeclaringClass();\n\t\t\tfor (Class<?> ifc : interfaces) {\n\t\t\t\tif (ifc.isAssignableFrom(targetClass) && ClassUtils.hasMethod(ifc, setter)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isTypeMatch(name,typeToMatch)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "typeToMatch"
    ],
    "position": {
      "column": 1,
      "line": 658
    },
    "return": "boolean",
    "signature": "public boolean isTypeMatch(String name, Class<?> typeToMatch)",
    "source_code": "\tpublic boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException {\n\t\treturn isTypeMatch(name, ResolvableType.forRawClass(typeToMatch));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isTypeMatch(name,typeToMatch,allowFactoryBeanInit)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Internal extended variant of {@link #isTypeMatch(String, ResolvableType)}\n\t * to check whether the bean with the given name matches the specified type. Allow\n\t * additional constraints to be applied to ensure that beans are not created early.\n\t * @param name the name of the bean to query\n\t * @param typeToMatch the type to match against (as a\n\t * {@code ResolvableType})\n\t * @return {@code true} if the bean type matches, {@code false} if it\n\t * doesn't match or cannot be determined yet\n\t * @throws NoSuchBeanDefinitionException if there is no bean with the given name\n\t * @since 5.2\n\t * @see #getBean\n\t * @see #getType\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "typeToMatch",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 516
    },
    "return": "boolean",
    "signature": "protected boolean isTypeMatch(String name, ResolvableType typeToMatch, boolean allowFactoryBeanInit)",
    "source_code": "\tprotected boolean isTypeMatch(String name, ResolvableType typeToMatch, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tString beanName = transformedBeanName(name);\n\t\tboolean isFactoryDereference = BeanFactoryUtils.isFactoryDereference(name);\n\n\t\t// Check manually registered singletons.\n\t\tObject beanInstance = getSingleton(beanName, false);\n\t\tif (beanInstance != null && beanInstance.getClass() != NullBean.class) {\n\t\t\tif (beanInstance instanceof FactoryBean<?> factoryBean) {\n\t\t\t\tif (!isFactoryDereference) {\n\t\t\t\t\tClass<?> type = getTypeForFactoryBean(factoryBean);\n\t\t\t\t\treturn (type != null && typeToMatch.isAssignableFrom(type));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn typeToMatch.isInstance(beanInstance);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!isFactoryDereference) {\n\t\t\t\tif (typeToMatch.isInstance(beanInstance)) {\n\t\t\t\t\t// Direct match for exposed instance?\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (typeToMatch.hasGenerics() && containsBeanDefinition(beanName)) {\n\t\t\t\t\t// Generics potentially only match on the target class, not on the proxy...\n\t\t\t\t\tRootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\t\t\t\tClass<?> targetType = mbd.getTargetType();\n\t\t\t\t\tif (targetType != null && targetType != ClassUtils.getUserClass(beanInstance)) {\n\t\t\t\t\t\t// Check raw class match as well, making sure it's exposed on the proxy.\n\t\t\t\t\t\tClass<?> classToMatch = typeToMatch.resolve();\n\t\t\t\t\t\tif (classToMatch != null && !classToMatch.isInstance(beanInstance)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (typeToMatch.isAssignableFrom(targetType)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tResolvableType resolvableType = mbd.targetType;\n\t\t\t\t\tif (resolvableType == null) {\n\t\t\t\t\t\tresolvableType = mbd.factoryMethodReturnType;\n\t\t\t\t\t}\n\t\t\t\t\treturn (resolvableType != null && typeToMatch.isAssignableFrom(resolvableType));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\telse if (containsSingleton(beanName) && !containsBeanDefinition(beanName)) {\n\t\t\t// null instance registered\n\t\t\treturn false;\n\t\t}\n\n\t\t// No singleton instance found -> check bean definition.\n\t\tBeanFactory parentBeanFactory = getParentBeanFactory();\n\t\tif (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n\t\t\t// No bean definition found in this factory -> delegate to parent.\n\t\t\treturn parentBeanFactory.isTypeMatch(originalBeanName(name), typeToMatch);\n\t\t}\n\n\t\t// Retrieve corresponding bean definition.\n\t\tRootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\tBeanDefinitionHolder dbd = mbd.getDecoratedDefinition();\n\n\t\t// Set up the types that we want to match against\n\t\tClass<?> classToMatch = typeToMatch.resolve();\n\t\tif (classToMatch == null) {\n\t\t\tclassToMatch = FactoryBean.class;\n\t\t}\n\t\tClass<?>[] typesToMatch = (FactoryBean.class == classToMatch ?\n\t\t\t\tnew Class<?>[] {classToMatch} : new Class<?>[] {FactoryBean.class, classToMatch});\n\n\n\t\t// Attempt to predict the bean type\n\t\tClass<?> predictedType = null;\n\n\t\t// We're looking for a regular reference, but we're a factory bean that has\n\t\t// a decorated bean definition. The target bean should be the same type\n\t\t// as FactoryBean would ultimately return.\n\t\tif (!isFactoryDereference && dbd != null && isFactoryBean(beanName, mbd)) {\n\t\t\t// We should only attempt if the user explicitly set lazy-init to true\n\t\t\t// and we know the merged bean definition is for a factory bean.\n\t\t\tif (!mbd.isLazyInit() || allowFactoryBeanInit) {\n\t\t\t\tRootBeanDefinition tbd = getMergedBeanDefinition(dbd.getBeanName(), dbd.getBeanDefinition(), mbd);\n\t\t\t\tClass<?> targetType = predictBeanType(dbd.getBeanName(), tbd, typesToMatch);\n\t\t\t\tif (targetType != null && !FactoryBean.class.isAssignableFrom(targetType)) {\n\t\t\t\t\tpredictedType = targetType;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we couldn't use the target type, try regular prediction.\n\t\tif (predictedType == null) {\n\t\t\tpredictedType = predictBeanType(beanName, mbd, typesToMatch);\n\t\t\tif (predictedType == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Attempt to get the actual ResolvableType for the bean.\n\t\tResolvableType beanType = null;\n\n\t\t// If it's a FactoryBean, we want to look at what it creates, not the factory class.\n\t\tif (FactoryBean.class.isAssignableFrom(predictedType)) {\n\t\t\tif (beanInstance == null && !isFactoryDereference) {\n\t\t\t\tbeanType = getTypeForFactoryBean(beanName, mbd, allowFactoryBeanInit);\n\t\t\t\tpredictedType = beanType.resolve();\n\t\t\t\tif (predictedType == null) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (isFactoryDereference) {\n\t\t\t// Special case: A SmartInstantiationAwareBeanPostProcessor returned a non-FactoryBean\n\t\t\t// type, but we nevertheless are being asked to dereference a FactoryBean...\n\t\t\t// Let's check the original bean class and proceed with it if it is a FactoryBean.\n\t\t\tpredictedType = predictBeanType(beanName, mbd, FactoryBean.class);\n\t\t\tif (predictedType == null || !FactoryBean.class.isAssignableFrom(predictedType)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// We don't have an exact type but if bean definition target type or the factory\n\t\t// method return type matches the predicted type then we can use that.\n\t\tif (beanType == null) {\n\t\t\tResolvableType definedType = mbd.targetType;\n\t\t\tif (definedType == null) {\n\t\t\t\tdefinedType = mbd.factoryMethodReturnType;\n\t\t\t}\n\t\t\tif (definedType != null && definedType.resolve() == predictedType) {\n\t\t\t\tbeanType = definedType;\n\t\t\t}\n\t\t}\n\n\t\t// If we have a bean type use it so that generics are considered\n\t\tif (beanType != null) {\n\t\t\treturn typeToMatch.isAssignableFrom(beanType);\n\t\t}\n\n\t\t// If we don't have a bean type, fallback to the predicted type\n\t\treturn typeToMatch.isAssignableFrom(predictedType);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#loadBeanDefinitions(encodedResource,prefix)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Load bean definitions from the specified properties file.\n\t * @param encodedResource the resource descriptor for the properties file,\n\t * allowing to specify an encoding to use for parsing the file\n\t * @param prefix a filter within the keys in the map: e.g. 'beans.'\n\t * (can be empty or {@code null})\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encodedResource",
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "int",
    "signature": "public int loadBeanDefinitions(EncodedResource encodedResource, @Nullable String prefix)",
    "source_code": "\tpublic int loadBeanDefinitions(EncodedResource encodedResource, @Nullable String prefix)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Loading properties bean definitions from \" + encodedResource);\n\t\t}\n\n\t\tProperties props = new Properties();\n\t\ttry {\n\t\t\ttry (InputStream is = encodedResource.getResource().getInputStream()) {\n\t\t\t\tif (encodedResource.getEncoding() != null) {\n\t\t\t\t\tgetPropertiesPersister().load(props, new InputStreamReader(is, encodedResource.getEncoding()));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgetPropertiesPersister().load(props, is);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint count = registerBeanDefinitions(props, prefix, encodedResource.getResource().getDescription());\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Loaded \" + count + \" bean definitions from \" + encodedResource);\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(\"Could not parse properties from \" + encodedResource.getResource(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#loadBeanDefinitions(location,actualResources)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Load bean definitions from the specified resource location.\n\t * <p>The location can also be a location pattern, provided that the\n\t * ResourceLoader of this bean definition reader is a ResourcePatternResolver.\n\t * @param location the resource location, to be loaded with the ResourceLoader\n\t * (or ResourcePatternResolver) of this bean definition reader\n\t * @param actualResources a Set to be filled with the actual Resource objects\n\t * that have been resolved during the loading process. May be {@code null}\n\t * to indicate that the caller is not interested in those Resource objects.\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t * @see #getResourceLoader()\n\t * @see #loadBeanDefinitions(org.springframework.core.io.Resource)\n\t * @see #loadBeanDefinitions(org.springframework.core.io.Resource[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "actualResources"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "int",
    "signature": "public int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources)",
    "source_code": "\tpublic int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources) throws BeanDefinitionStoreException {\n\t\tResourceLoader resourceLoader = getResourceLoader();\n\t\tif (resourceLoader == null) {\n\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\"Cannot load bean definitions from location [\" + location + \"]: no ResourceLoader available\");\n\t\t}\n\n\t\tif (resourceLoader instanceof ResourcePatternResolver resourcePatternResolver) {\n\t\t\t// Resource pattern matching available.\n\t\t\ttry {\n\t\t\t\tResource[] resources = resourcePatternResolver.getResources(location);\n\t\t\t\tint count = loadBeanDefinitions(resources);\n\t\t\t\tif (actualResources != null) {\n\t\t\t\t\tCollections.addAll(actualResources, resources);\n\t\t\t\t}\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Loaded \" + count + \" bean definitions from location pattern [\" + location + \"]\");\n\t\t\t\t}\n\t\t\t\treturn count;\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\t\"Could not resolve bean definition resource pattern [\" + location + \"]\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Can only load single resources by absolute URL.\n\t\t\tResource resource = resourceLoader.getResource(location);\n\t\t\tint count = loadBeanDefinitions(resource);\n\t\t\tif (actualResources != null) {\n\t\t\t\tactualResources.add(resource);\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Loaded \" + count + \" bean definitions from location [\" + location + \"]\");\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#loadBeanDefinitions(resource,prefix)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Load bean definitions from the specified properties file.\n\t * @param resource the resource descriptor for the properties file\n\t * @param prefix a filter within the keys in the map: e.g. 'beans.'\n\t * (can be empty or {@code null})\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "int",
    "signature": "public int loadBeanDefinitions(Resource resource, @Nullable String prefix)",
    "source_code": "\tpublic int loadBeanDefinitions(Resource resource, @Nullable String prefix) throws BeanDefinitionStoreException {\n\t\treturn loadBeanDefinitions(new EncodedResource(resource), prefix);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#matchesBeanName(beanName,candidateName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given candidate name matches the bean name or the aliases\n\t * stored in this bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "candidateName"
    ],
    "position": {
      "column": 1,
      "line": 1785
    },
    "return": "boolean",
    "signature": "protected boolean matchesBeanName(String beanName, @Nullable String candidateName)",
    "source_code": "\tprotected boolean matchesBeanName(String beanName, @Nullable String candidateName) {\n\t\treturn (candidateName != null &&\n\t\t\t\t(candidateName.equals(beanName) || ObjectUtils.containsElement(getAliases(beanName), candidateName)));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#obtainFromSupplier(supplier,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a bean instance from the given supplier.\n\t * @param supplier the configured supplier\n\t * @param beanName the corresponding bean name\n\t * @return a BeanWrapper for the new instance\n\t * @since 5.0\n\t * @see #getObjectForBeanInstance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "supplier",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 1210
    },
    "return": "BeanWrapper",
    "signature": "protected BeanWrapper obtainFromSupplier(Supplier<?> supplier, String beanName)",
    "source_code": "\tprotected BeanWrapper obtainFromSupplier(Supplier<?> supplier, String beanName) {\n\t\tObject instance = obtainInstanceFromSupplier(supplier, beanName);\n\t\tif (instance == null) {\n\t\t\tinstance = new NullBean();\n\t\t}\n\t\tBeanWrapper bw = new BeanWrapperImpl(instance);\n\t\tinitBeanWrapper(bw);\n\t\treturn bw;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#populateBean(beanName,mbd,bw)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Populate the bean instance in the given BeanWrapper with the property values\n\t * from the bean definition.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param bw the BeanWrapper with bean instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "bw"
    ],
    "position": {
      "column": 1,
      "line": 1355
    },
    "return": "void",
    "signature": "protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)",
    "source_code": "\tprotected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {\n\t\tif (bw == null) {\n\t\t\tif (mbd.hasPropertyValues()) {\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Skip property population phase for null instance.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the\n\t\t// state of the bean before properties are set. This can be used, for example,\n\t\t// to support styles of field injection.\n\t\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\t\tif (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tPropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);\n\n\t\tint resolvedAutowireMode = mbd.getResolvedAutowireMode();\n\t\tif (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {\n\t\t\tMutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\t\t\t// Add property values based on autowire by name if applicable.\n\t\t\tif (resolvedAutowireMode == AUTOWIRE_BY_NAME) {\n\t\t\t\tautowireByName(beanName, mbd, bw, newPvs);\n\t\t\t}\n\t\t\t// Add property values based on autowire by type if applicable.\n\t\t\tif (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {\n\t\t\t\tautowireByType(beanName, mbd, bw, newPvs);\n\t\t\t}\n\t\t\tpvs = newPvs;\n\t\t}\n\t\tif (hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tif (pvs == null) {\n\t\t\t\tpvs = mbd.getPropertyValues();\n\t\t\t}\n\t\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\t\tPropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);\n\t\t\t\tif (pvsToUse == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpvs = pvsToUse;\n\t\t\t}\n\t\t}\n\n\t\tboolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);\n\t\tif (needsDepCheck) {\n\t\t\tPropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n\t\t\tcheckDependencies(beanName, mbd, filteredPds, pvs);\n\t\t}\n\n\t\tif (pvs != null) {\n\t\t\tapplyPropertyValues(beanName, mbd, bw, pvs);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#postProcessObjectFromFactoryBean(object,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Post-process the given object that has been obtained from the FactoryBean.\n\t * The resulting object will get exposed for bean references.\n\t * <p>The default implementation simply returns the given object as-is.\n\t * Subclasses may override this, for example, to apply post-processors.\n\t * @param object the object obtained from the FactoryBean.\n\t * @param beanName the name of the bean\n\t * @return the object to expose\n\t * @throws org.springframework.beans.BeansException if any post-processing failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "Object",
    "signature": "protected Object postProcessObjectFromFactoryBean(Object object, String beanName)",
    "source_code": "\tprotected Object postProcessObjectFromFactoryBean(Object object, String beanName) throws BeansException {\n\t\treturn object;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBeanDefinition(beanName,Map<?,map,prefix,resourceDescription)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get all property values, given a prefix (which will be stripped)\n\t * and add the bean they define to the factory with the given name.\n\t * @param beanName name of the bean to define\n\t * @param map a Map containing string pairs\n\t * @param prefix prefix of each entry, which will be stripped\n\t * @param resourceDescription description of the resource that the\n\t * Map came from (for logging purposes)\n\t * @throws BeansException if the bean definition could not be parsed or registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "Map<?",
      "map",
      "prefix",
      "resourceDescription"
    ],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "void",
    "signature": "protected void registerBeanDefinition(String beanName, Map<?, ?> map, String prefix, String resourceDescription)",
    "source_code": "\tprotected void registerBeanDefinition(String beanName, Map<?, ?> map, String prefix, String resourceDescription)\n\t\t\tthrows BeansException {\n\n\t\tString className = null;\n\t\tString parent = null;\n\t\tString scope = BeanDefinition.SCOPE_SINGLETON;\n\t\tboolean isAbstract = false;\n\t\tboolean lazyInit = false;\n\n\t\tConstructorArgumentValues cas = new ConstructorArgumentValues();\n\t\tMutablePropertyValues pvs = new MutablePropertyValues();\n\n\t\tString prefixWithSep = prefix + SEPARATOR;\n\t\tint beginIndex = prefixWithSep.length();\n\n\t\tfor (Map.Entry<?, ?> entry : map.entrySet()) {\n\t\t\tString key = ((String) entry.getKey()).strip();\n\t\t\tif (key.startsWith(prefixWithSep)) {\n\t\t\t\tString property = key.substring(beginIndex);\n\t\t\t\tif (CLASS_KEY.equals(property)) {\n\t\t\t\t\tclassName = ((String) entry.getValue()).strip();\n\t\t\t\t}\n\t\t\t\telse if (PARENT_KEY.equals(property)) {\n\t\t\t\t\tparent = ((String) entry.getValue()).strip();\n\t\t\t\t}\n\t\t\t\telse if (ABSTRACT_KEY.equals(property)) {\n\t\t\t\t\tString val = ((String) entry.getValue()).strip();\n\t\t\t\t\tisAbstract = TRUE_VALUE.equals(val);\n\t\t\t\t}\n\t\t\t\telse if (SCOPE_KEY.equals(property)) {\n\t\t\t\t\t// Spring 2.0 style\n\t\t\t\t\tscope = ((String) entry.getValue()).strip();\n\t\t\t\t}\n\t\t\t\telse if (SINGLETON_KEY.equals(property)) {\n\t\t\t\t\t// Spring 1.2 style\n\t\t\t\t\tString val = ((String) entry.getValue()).strip();\n\t\t\t\t\tscope = (!StringUtils.hasLength(val) || TRUE_VALUE.equals(val) ?\n\t\t\t\t\t\t\tBeanDefinition.SCOPE_SINGLETON : BeanDefinition.SCOPE_PROTOTYPE);\n\t\t\t\t}\n\t\t\t\telse if (LAZY_INIT_KEY.equals(property)) {\n\t\t\t\t\tString val = ((String) entry.getValue()).strip();\n\t\t\t\t\tlazyInit = TRUE_VALUE.equals(val);\n\t\t\t\t}\n\t\t\t\telse if (property.startsWith(CONSTRUCTOR_ARG_PREFIX)) {\n\t\t\t\t\tif (property.endsWith(REF_SUFFIX)) {\n\t\t\t\t\t\tint index = Integer.parseInt(property, 1, property.length() - REF_SUFFIX.length(), 10);\n\t\t\t\t\t\tcas.addIndexedArgumentValue(index, new RuntimeBeanReference(entry.getValue().toString()));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint index = Integer.parseInt(property, 1, property.length(), 10);\n\t\t\t\t\t\tcas.addIndexedArgumentValue(index, readValue(entry));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (property.endsWith(REF_SUFFIX)) {\n\t\t\t\t\t// This isn't a real property, but a reference to another prototype\n\t\t\t\t\t// Extract property name: property is of form dog(ref)\n\t\t\t\t\tproperty = property.substring(0, property.length() - REF_SUFFIX.length());\n\t\t\t\t\tString ref = ((String) entry.getValue()).strip();\n\n\t\t\t\t\t// It doesn't matter if the referenced bean hasn't yet been registered:\n\t\t\t\t\t// this will ensure that the reference is resolved at runtime.\n\t\t\t\t\tObject val = new RuntimeBeanReference(ref);\n\t\t\t\t\tpvs.add(property, val);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// It's a normal bean property.\n\t\t\t\t\tpvs.add(property, readValue(entry));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Registering bean definition for bean name '\" + beanName + \"' with \" + pvs);\n\t\t}\n\n\t\t// Just use default parent if we're not dealing with the parent itself,\n\t\t// and if there's no class name specified. The latter has to happen for\n\t\t// backwards compatibility reasons.\n\t\tif (parent == null && className == null && !beanName.equals(this.defaultParentBean)) {\n\t\t\tparent = this.defaultParentBean;\n\t\t}\n\n\t\ttry {\n\t\t\tAbstractBeanDefinition bd = BeanDefinitionReaderUtils.createBeanDefinition(\n\t\t\t\t\tparent, className, getBeanClassLoader());\n\t\t\tbd.setScope(scope);\n\t\t\tbd.setAbstract(isAbstract);\n\t\t\tbd.setLazyInit(lazyInit);\n\t\t\tbd.setConstructorArgumentValues(cas);\n\t\t\tbd.setPropertyValues(pvs);\n\t\t\tgetRegistry().registerBeanDefinition(beanName, bd);\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\tthrow new CannotLoadBeanClassException(resourceDescription, beanName, className, ex);\n\t\t}\n\t\tcatch (LinkageError err) {\n\t\t\tthrow new CannotLoadBeanClassException(resourceDescription, beanName, className, err);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBeanDefinition(beanName,beanDefinition)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 984
    },
    "return": "void",
    "signature": "public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)",
    "source_code": "\tpublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\tAssert.hasText(beanName, \"Bean name must not be empty\");\n\t\tAssert.notNull(beanDefinition, \"BeanDefinition must not be null\");\n\n\t\tif (beanDefinition instanceof AbstractBeanDefinition abd) {\n\t\t\ttry {\n\t\t\t\tabd.validate();\n\t\t\t}\n\t\t\tcatch (BeanDefinitionValidationException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Validation of bean definition failed\", ex);\n\t\t\t}\n\t\t}\n\n\t\tBeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);\n\t\tif (existingDefinition != null) {\n\t\t\tif (!isAllowBeanDefinitionOverriding()) {\n\t\t\t\tthrow new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);\n\t\t\t}\n\t\t\telse if (existingDefinition.getRole() < beanDefinition.getRole()) {\n\t\t\t\t// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE\n\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"Overriding user-defined bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\t\"' with a framework-generated bean definition: replacing [\" +\n\t\t\t\t\t\t\texistingDefinition + \"] with [\" + beanDefinition + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!beanDefinition.equals(existingDefinition)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Overriding bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\t\"' with a different definition: replacing [\" + existingDefinition +\n\t\t\t\t\t\t\t\"] with [\" + beanDefinition + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Overriding bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\t\"' with an equivalent definition: replacing [\" + existingDefinition +\n\t\t\t\t\t\t\t\"] with [\" + beanDefinition + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t}\n\t\telse {\n\t\t\tif (isAlias(beanName)) {\n\t\t\t\tif (!isAllowBeanDefinitionOverriding()) {\n\t\t\t\t\tString aliasedName = canonicalName(beanName);\n\t\t\t\t\tif (containsBeanDefinition(aliasedName)) {  // alias for existing bean definition\n\t\t\t\t\t\tthrow new BeanDefinitionOverrideException(\n\t\t\t\t\t\t\t\tbeanName, beanDefinition, getBeanDefinition(aliasedName));\n\t\t\t\t\t}\n\t\t\t\t\telse {  // alias pointing to non-existing bean definition\n\t\t\t\t\t\tthrow new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\"Cannot register bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\t\t\"' since there is already an alias for bean '\" + aliasedName + \"' bound.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tremoveAlias(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasBeanCreationStarted()) {\n\t\t\t\t// Cannot modify startup-time collection elements anymore (for stable iteration)\n\t\t\t\tsynchronized (this.beanDefinitionMap) {\n\t\t\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t\t\t\tList<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);\n\t\t\t\t\tupdatedDefinitions.addAll(this.beanDefinitionNames);\n\t\t\t\t\tupdatedDefinitions.add(beanName);\n\t\t\t\t\tthis.beanDefinitionNames = updatedDefinitions;\n\t\t\t\t\tremoveManualSingletonName(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Still in startup registration phase\n\t\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t\t\tthis.beanDefinitionNames.add(beanName);\n\t\t\t\tremoveManualSingletonName(beanName);\n\t\t\t}\n\t\t\tthis.frozenBeanDefinitionNames = null;\n\t\t}\n\n\t\tif (existingDefinition != null || containsSingleton(beanName)) {\n\t\t\tresetBeanDefinition(beanName);\n\t\t}\n\t\telse if (isConfigurationFrozen()) {\n\t\t\tclearByTypeCache();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBeanDefinitions(Map<?,map)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register bean definitions contained in a Map, using all property keys (i.e. not\n\t * filtering by prefix).\n\t * @param map a map of {@code name} to {@code property} (String or Object). Property\n\t * values will be strings if coming from a Properties file etc. Property names\n\t * (keys) <b>must</b> be Strings. Class keys must be Strings.\n\t * @return the number of bean definitions found\n\t * @throws BeansException in case of loading or parsing errors\n\t * @see #registerBeanDefinitions(java.util.Map, String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "int",
    "signature": "public int registerBeanDefinitions(Map<?, ?> map)",
    "source_code": "\tpublic int registerBeanDefinitions(Map<?, ?> map) throws BeansException {\n\t\treturn registerBeanDefinitions(map, null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBeanDefinitions(Map<?,map,prefix)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register bean definitions contained in a Map.\n\t * Ignore ineligible properties.\n\t * @param map a map of {@code name} to {@code property} (String or Object). Property\n\t * values will be strings if coming from a Properties file etc. Property names\n\t * (keys) <b>must</b> be Strings. Class keys must be Strings.\n\t * @param prefix a filter within the keys in the map: e.g. 'beans.'\n\t * (can be empty or {@code null})\n\t * @return the number of bean definitions found\n\t * @throws BeansException in case of loading or parsing errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map",
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "int",
    "signature": "public int registerBeanDefinitions(Map<?, ?> map, @Nullable String prefix)",
    "source_code": "\tpublic int registerBeanDefinitions(Map<?, ?> map, @Nullable String prefix) throws BeansException {\n\t\treturn registerBeanDefinitions(map, prefix, \"Map \" + map);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBeanDefinitions(Map<?,map,prefix,resourceDescription)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register bean definitions contained in a Map.\n\t * Ignore ineligible properties.\n\t * @param map a map of {@code name} to {@code property} (String or Object). Property\n\t * values will be strings if coming from a Properties file etc. Property names\n\t * (keys) <b>must</b> be Strings. Class keys must be Strings.\n\t * @param prefix a filter within the keys in the map: e.g. 'beans.'\n\t * (can be empty or {@code null})\n\t * @param resourceDescription description of the resource that the\n\t * Map came from (for logging purposes)\n\t * @return the number of bean definitions found\n\t * @throws BeansException in case of loading or parsing errors\n\t * @see #registerBeanDefinitions(Map, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map",
      "prefix",
      "resourceDescription"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "int",
    "signature": "public int registerBeanDefinitions(Map<?, ?> map, @Nullable String prefix, String resourceDescription)",
    "source_code": "\tpublic int registerBeanDefinitions(Map<?, ?> map, @Nullable String prefix, String resourceDescription)\n\t\t\tthrows BeansException {\n\n\t\tif (prefix == null) {\n\t\t\tprefix = \"\";\n\t\t}\n\t\tint beanCount = 0;\n\n\t\tfor (Object key : map.keySet()) {\n\t\t\tif (!(key instanceof String keyString)) {\n\t\t\t\tthrow new IllegalArgumentException(\"Illegal key [\" + key + \"]: only Strings allowed\");\n\t\t\t}\n\t\t\tif (keyString.startsWith(prefix)) {\n\t\t\t\t// Key is of form: prefix<name>.property\n\t\t\t\tString nameAndProperty = keyString.substring(prefix.length());\n\t\t\t\t// Find dot before property name, ignoring dots in property keys.\n\t\t\t\tint sepIdx ;\n\t\t\t\tint propKeyIdx = nameAndProperty.indexOf(PropertyAccessor.PROPERTY_KEY_PREFIX);\n\t\t\t\tif (propKeyIdx != -1) {\n\t\t\t\t\tsepIdx = nameAndProperty.lastIndexOf(SEPARATOR, propKeyIdx);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsepIdx = nameAndProperty.lastIndexOf(SEPARATOR);\n\t\t\t\t}\n\t\t\t\tif (sepIdx != -1) {\n\t\t\t\t\tString beanName = nameAndProperty.substring(0, sepIdx);\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Found bean name '\" + beanName + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!getRegistry().containsBeanDefinition(beanName)) {\n\t\t\t\t\t\t// If we haven't already registered it...\n\t\t\t\t\t\tregisterBeanDefinition(beanName, map, prefix + beanName, resourceDescription);\n\t\t\t\t\t\t++beanCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Ignore it: It wasn't a valid bean name and property,\n\t\t\t\t\t// although it did start with the required prefix.\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Invalid bean name and property [\" + nameAndProperty + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn beanCount;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBeanDefinitions(rb,prefix)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register bean definitions contained in a ResourceBundle.\n\t * <p>Similar syntax as for a Map. This method is useful to enable\n\t * standard Java internationalization support.\n\t * @param rb the ResourceBundle to load from\n\t * @param prefix a filter within the keys in the map: e.g. 'beans.'\n\t * (can be empty or {@code null})\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rb",
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "int",
    "signature": "public int registerBeanDefinitions(ResourceBundle rb, @Nullable String prefix)",
    "source_code": "\tpublic int registerBeanDefinitions(ResourceBundle rb, @Nullable String prefix) throws BeanDefinitionStoreException {\n\t\t// Simply create a map and call overloaded method.\n\t\tMap<String, Object> map = new HashMap<>();\n\t\tEnumeration<String> keys = rb.getKeys();\n\t\twhile (keys.hasMoreElements()) {\n\t\t\tString key = keys.nextElement();\n\t\t\tmap.put(key, rb.getObject(key));\n\t\t}\n\t\treturn registerBeanDefinitions(map, prefix);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerCustomEditor(requiredType,propertyEditorClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "propertyEditorClass"
    ],
    "position": {
      "column": 1,
      "line": 854
    },
    "return": "void",
    "signature": "public void registerCustomEditor(Class<?> requiredType, Class<? extends PropertyEditor> propertyEditorClass)",
    "source_code": "\tpublic void registerCustomEditor(Class<?> requiredType, Class<? extends PropertyEditor> propertyEditorClass) {\n\t\tAssert.notNull(requiredType, \"Required type must not be null\");\n\t\tAssert.notNull(propertyEditorClass, \"PropertyEditor class must not be null\");\n\t\tthis.customEditors.put(requiredType, propertyEditorClass);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerDisposableBeanIfNecessary(beanName,bean,mbd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given bean to the list of disposable beans in this factory,\n\t * registering its DisposableBean interface and/or the given destroy method\n\t * to be called on factory shutdown (if applicable). Only applies to singletons.\n\t * @param beanName the name of the bean\n\t * @param bean the bean instance\n\t * @param mbd the bean definition for the bean\n\t * @see RootBeanDefinition#isSingleton\n\t * @see RootBeanDefinition#getDependsOn\n\t * @see #registerDisposableBean\n\t * @see #registerDependentBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bean",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1866
    },
    "return": "void",
    "signature": "protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd)",
    "source_code": "\tprotected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) {\n\t\tif (!mbd.isPrototype() && requiresDestruction(bean, mbd)) {\n\t\t\tif (mbd.isSingleton()) {\n\t\t\t\t// Register a DisposableBean implementation that performs all destruction\n\t\t\t\t// work for the given bean: DestructionAwareBeanPostProcessors,\n\t\t\t\t// DisposableBean interface, custom destroy method.\n\t\t\t\tregisterDisposableBean(beanName, new DisposableBeanAdapter(\n\t\t\t\t\t\tbean, beanName, mbd, getBeanPostProcessorCache().destructionAware));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// A bean with a custom scope...\n\t\t\t\tScope scope = this.scopes.get(mbd.getScope());\n\t\t\t\tif (scope == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"No Scope registered for scope name '\" + mbd.getScope() + \"'\");\n\t\t\t\t}\n\t\t\t\tscope.registerDestructionCallback(beanName, new DisposableBeanAdapter(\n\t\t\t\t\t\tbean, beanName, mbd, getBeanPostProcessorCache().destructionAware));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerResolvableDependency(dependencyType,autowiredValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dependencyType",
      "autowiredValue"
    ],
    "position": {
      "column": 1,
      "line": 809
    },
    "return": "void",
    "signature": "public void registerResolvableDependency(Class<?> dependencyType, @Nullable Object autowiredValue)",
    "source_code": "\tpublic void registerResolvableDependency(Class<?> dependencyType, @Nullable Object autowiredValue) {\n\t\tAssert.notNull(dependencyType, \"Dependency type must not be null\");\n\t\tif (autowiredValue != null) {\n\t\t\tif (!(autowiredValue instanceof ObjectFactory || dependencyType.isInstance(autowiredValue))) {\n\t\t\t\tthrow new IllegalArgumentException(\"Value [\" + autowiredValue +\n\t\t\t\t\t\t\"] does not implement specified dependency type [\" + dependencyType.getName() + \"]\");\n\t\t\t}\n\t\t\tthis.resolvableDependencies.put(dependencyType, autowiredValue);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerScope(scopeName,scope)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scopeName",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 1024
    },
    "return": "void",
    "signature": "public void registerScope(String scopeName, Scope scope)",
    "source_code": "\tpublic void registerScope(String scopeName, Scope scope) {\n\t\tAssert.notNull(scopeName, \"Scope identifier must not be null\");\n\t\tAssert.notNull(scope, \"Scope must not be null\");\n\t\tif (SCOPE_SINGLETON.equals(scopeName) || SCOPE_PROTOTYPE.equals(scopeName)) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot replace existing scopes 'singleton' and 'prototype'\");\n\t\t}\n\t\tScope previous = this.scopes.put(scopeName, scope);\n\t\tif (previous != null && previous != scope) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Replacing scope '\" + scopeName + \"' from [\" + previous + \"] to [\" + scope + \"]\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Registering scope '\" + scopeName + \"' with implementation [\" + scope + \"]\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerSingleton(beanName,singletonObject)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "singletonObject"
    ],
    "position": {
      "column": 1,
      "line": 1162
    },
    "return": "void",
    "signature": "public void registerSingleton(String beanName, Object singletonObject)",
    "source_code": "\tpublic void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException {\n\t\tsuper.registerSingleton(beanName, singletonObject);\n\t\tupdateManualSingletonNames(set -> set.add(beanName), set -> !this.beanDefinitionMap.containsKey(beanName));\n\t\tclearByTypeCache();\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#requiresDestruction(bean,mbd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given bean requires destruction on shutdown.\n\t * <p>The default implementation checks the DisposableBean interface as well as\n\t * a specified destroy method and registered DestructionAwareBeanPostProcessors.\n\t * @param bean the bean instance to check\n\t * @param mbd the corresponding bean definition\n\t * @see org.springframework.beans.factory.DisposableBean\n\t * @see AbstractBeanDefinition#getDestroyMethodName()\n\t * @see org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1848
    },
    "return": "boolean",
    "signature": "protected boolean requiresDestruction(Object bean, RootBeanDefinition mbd)",
    "source_code": "\tprotected boolean requiresDestruction(Object bean, RootBeanDefinition mbd) {\n\t\treturn (bean.getClass() != NullBean.class && (DisposableBeanAdapter.hasDestroyMethod(bean, mbd) ||\n\t\t\t\t(hasDestructionAwareBeanPostProcessors() && DisposableBeanAdapter.hasApplicableProcessors(\n\t\t\t\t\t\tbean, getBeanPostProcessorCache().destructionAware))));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveAutowiredArgument(param,beanName,autowiredBeanNames,typeConverter,fallback)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for resolving the specified argument which is supposed to be autowired.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "param",
      "beanName",
      "autowiredBeanNames",
      "typeConverter",
      "fallback"
    ],
    "position": {
      "column": 1,
      "line": 873
    },
    "return": "Object",
    "signature": "protected Object resolveAutowiredArgument(MethodParameter param, String beanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, TypeConverter typeConverter, boolean fallback)",
    "source_code": "\tprotected Object resolveAutowiredArgument(MethodParameter param, String beanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, TypeConverter typeConverter, boolean fallback) {\n\n\t\tClass<?> paramType = param.getParameterType();\n\t\tif (InjectionPoint.class.isAssignableFrom(paramType)) {\n\t\t\tInjectionPoint injectionPoint = currentInjectionPoint.get();\n\t\t\tif (injectionPoint == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current InjectionPoint available for \" + param);\n\t\t\t}\n\t\t\treturn injectionPoint;\n\t\t}\n\t\ttry {\n\t\t\treturn this.beanFactory.resolveDependency(\n\t\t\t\t\tnew DependencyDescriptor(param, true), beanName, autowiredBeanNames, typeConverter);\n\t\t}\n\t\tcatch (NoUniqueBeanDefinitionException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\tif (fallback) {\n\t\t\t\t// Single constructor or factory method -> let's return an empty array/collection\n\t\t\t\t// for e.g. a vararg or a non-null List/Set/Map parameter.\n\t\t\t\tif (paramType.isArray()) {\n\t\t\t\t\treturn Array.newInstance(paramType.getComponentType(), 0);\n\t\t\t\t}\n\t\t\t\telse if (CollectionFactory.isApproximableCollectionType(paramType)) {\n\t\t\t\t\treturn CollectionFactory.createCollection(paramType, 0);\n\t\t\t\t}\n\t\t\t\telse if (CollectionFactory.isApproximableMapType(paramType)) {\n\t\t\t\t\treturn CollectionFactory.createMap(paramType, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveAutowiringValue(autowiringValue,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given autowiring value against the given required type,\n\t * e.g. an {@link ObjectFactory} value to its actual object result.\n\t * @param autowiringValue the value to resolve\n\t * @param requiredType the type to assign the result to\n\t * @return the resolved value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "autowiringValue",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "Object",
    "signature": "public Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType)",
    "source_code": "\tpublic static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {\n\t\tif (autowiringValue instanceof ObjectFactory<?> factory && !requiredType.isInstance(autowiringValue)) {\n\t\t\tif (autowiringValue instanceof Serializable && requiredType.isInterface()) {\n\t\t\t\tautowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),\n\t\t\t\t\t\tnew Class<?>[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn factory.getObject();\n\t\t\t}\n\t\t}\n\t\treturn autowiringValue;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveBeanByName(name,descriptor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 456
    },
    "return": "Object",
    "signature": "public Object resolveBeanByName(String name, DependencyDescriptor descriptor)",
    "source_code": "\tpublic Object resolveBeanByName(String name, DependencyDescriptor descriptor) {\n\t\tInjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);\n\t\ttry {\n\t\t\treturn getBean(name, descriptor.getDependencyType());\n\t\t}\n\t\tfinally {\n\t\t\tConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveBeforeInstantiation(beanName,mbd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply before-instantiation post-processors, resolving whether there is a\n\t * before-instantiation shortcut for the specified bean.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @return the shortcut-determined bean instance, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1095
    },
    "return": "Object",
    "signature": "protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd)",
    "source_code": "\tprotected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {\n\t\tObject bean = null;\n\t\tif (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {\n\t\t\t// Make sure bean class is actually resolved at this point.\n\t\t\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\t\tClass<?> targetType = determineTargetType(beanName, mbd);\n\t\t\t\tif (targetType != null) {\n\t\t\t\t\tbean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);\n\t\t\t\t\tif (bean != null) {\n\t\t\t\t\t\tbean = applyBeanPostProcessorsAfterInitialization(bean, beanName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmbd.beforeInstantiationResolved = (bean != null);\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveCandidate(beanName,requiredType,beanFactory)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "requiredType",
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 2018
    },
    "return": "Object",
    "signature": "public Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory)",
    "source_code": "\t\t\t\t\tpublic Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory) {\n\t\t\t\t\t\treturn beanFactory.getBean(beanName, args);\n\t\t\t\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveConstructorOrFactoryMethod(beanName,mbd)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 912
    },
    "return": "Executable",
    "signature": "public Executable resolveConstructorOrFactoryMethod(String beanName, RootBeanDefinition mbd)",
    "source_code": "\tpublic Executable resolveConstructorOrFactoryMethod(String beanName, RootBeanDefinition mbd) {\n\t\tSupplier<ResolvableType> beanType = () -> getBeanType(beanName, mbd);\n\t\tList<ResolvableType> valueTypes = (mbd.hasConstructorArgumentValues() ?\n\t\t\t\tdetermineParameterValueTypes(mbd) : Collections.emptyList());\n\t\tMethod resolvedFactoryMethod = resolveFactoryMethod(beanName, mbd, valueTypes);\n\t\tif (resolvedFactoryMethod != null) {\n\t\t\treturn resolvedFactoryMethod;\n\t\t}\n\n\t\tClass<?> factoryBeanClass = getFactoryBeanClass(beanName, mbd);\n\t\tif (factoryBeanClass != null && !factoryBeanClass.equals(mbd.getResolvableType().toClass())) {\n\t\t\tResolvableType resolvableType = mbd.getResolvableType();\n\t\t\tboolean isCompatible = ResolvableType.forClass(factoryBeanClass)\n\t\t\t\t\t.as(FactoryBean.class).getGeneric(0).isAssignableFrom(resolvableType);\n\t\t\tAssert.state(isCompatible, () -> String.format(\n\t\t\t\t\t\"Incompatible target type '%s' for factory bean '%s'\",\n\t\t\t\t\tresolvableType.toClass().getName(), factoryBeanClass.getName()));\n\t\t\tExecutable executable = resolveConstructor(beanName, mbd,\n\t\t\t\t\t() -> ResolvableType.forClass(factoryBeanClass), valueTypes);\n\t\t\tif (executable != null) {\n\t\t\t\treturn executable;\n\t\t\t}\n\t\t\tthrow new IllegalStateException(\"No suitable FactoryBean constructor found for \" +\n\t\t\t\t\tmbd + \" and argument types \" + valueTypes);\n\n\t\t}\n\n\t\tExecutable resolvedConstructor = resolveConstructor(beanName, mbd, beanType, valueTypes);\n\t\tif (resolvedConstructor != null) {\n\t\t\treturn resolvedConstructor;\n\t\t}\n\n\t\tthrow new IllegalStateException(\"No constructor or factory method candidate found for \" +\n\t\t\t\tmbd + \" and argument types \" + valueTypes);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveDependency(descriptor,requestingBeanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 468
    },
    "return": "Object",
    "signature": "public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName)",
    "source_code": "\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName) throws BeansException {\n\t\treturn resolveDependency(descriptor, requestingBeanName, null, null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveDependency(descriptor,requestingBeanName,autowiredBeanNames,typeConverter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "requestingBeanName",
      "autowiredBeanNames",
      "typeConverter"
    ],
    "position": {
      "column": 1,
      "line": 1307
    },
    "return": "Object",
    "signature": "public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter)",
    "source_code": "\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {\n\n\t\tdescriptor.initParameterNameDiscovery(getParameterNameDiscoverer());\n\t\tif (Optional.class == descriptor.getDependencyType()) {\n\t\t\treturn createOptionalDependency(descriptor, requestingBeanName);\n\t\t}\n\t\telse if (ObjectFactory.class == descriptor.getDependencyType() ||\n\t\t\t\tObjectProvider.class == descriptor.getDependencyType()) {\n\t\t\treturn new DependencyObjectProvider(descriptor, requestingBeanName);\n\t\t}\n\t\telse if (javaxInjectProviderClass == descriptor.getDependencyType()) {\n\t\t\treturn new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);\n\t\t}\n\t\telse {\n\t\t\tObject result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(\n\t\t\t\t\tdescriptor, requestingBeanName);\n\t\t\tif (result == null) {\n\t\t\t\tresult = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveInnerBean(innerBeanName,innerBd,BiFunction<String,RootBeanDefinition,resolver)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve an inner bean definition and invoke the specified {@code resolver}\n\t * on its merged bean definition.\n\t * @param innerBeanName the inner bean name (or {@code null} to assign one)\n\t * @param innerBd the inner raw bean definition\n\t * @param resolver the function to invoke to resolve\n\t * @param <T> the type of the resolution\n\t * @return a resolved inner bean, as a result of applying the {@code resolver}\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "innerBeanName",
      "innerBd",
      "BiFunction<String",
      "RootBeanDefinition",
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "T",
    "signature": "public T resolveInnerBean(@Nullable String innerBeanName, BeanDefinition innerBd,\n\t\t\tBiFunction<String, RootBeanDefinition, T> resolver)",
    "source_code": "\tpublic <T> T resolveInnerBean(@Nullable String innerBeanName, BeanDefinition innerBd,\n\t\t\tBiFunction<String, RootBeanDefinition, T> resolver) {\n\n\t\tString nameToUse = (innerBeanName != null ? innerBeanName : \"(inner bean)\" +\n\t\t\t\tBeanFactoryUtils.GENERATED_BEAN_NAME_SEPARATOR + ObjectUtils.getIdentityHexString(innerBd));\n\t\treturn resolver.apply(nameToUse,\n\t\t\t\tthis.beanFactory.getMergedBeanDefinition(nameToUse, innerBd, this.beanDefinition));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveNotUnique(type,Map<String,matchingBeans)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<String",
      "matchingBeans"
    ],
    "position": {
      "column": 1,
      "line": 2077
    },
    "return": "Object",
    "signature": "public Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans)",
    "source_code": "\t\t\t\tpublic Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans) {\n\t\t\t\t\treturn null;\n\t\t\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveValueIfNecessary(argName,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Given a PropertyValue, return a value, resolving any references to other\n\t * beans in the factory if necessary. The value could be:\n\t * <li>A BeanDefinition, which leads to the creation of a corresponding\n\t * new bean instance. Singleton flags and names of such \"inner beans\"\n\t * are always ignored: Inner beans are anonymous prototypes.\n\t * <li>A RuntimeBeanReference, which must be resolved.\n\t * <li>A ManagedList. This is a special collection that may contain\n\t * RuntimeBeanReferences or Collections that will need to be resolved.\n\t * <li>A ManagedSet. May also contain RuntimeBeanReferences or\n\t * Collections that will need to be resolved.\n\t * <li>A ManagedMap. In this case the value may be a RuntimeBeanReference\n\t * or Collection that will need to be resolved.\n\t * <li>An ordinary object or {@code null}, in which case it's left alone.\n\t * @param argName the name of the argument that the value is defined for\n\t * @param value the value object to resolve\n\t * @return the resolved object\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "Object",
    "signature": "public Object resolveValueIfNecessary(Object argName, @Nullable Object value)",
    "source_code": "\tpublic Object resolveValueIfNecessary(Object argName, @Nullable Object value) {\n\t\t// We must check each value to see whether it requires a runtime reference\n\t\t// to another bean to be resolved.\n\t\tif (value instanceof RuntimeBeanReference ref) {\n\t\t\treturn resolveReference(argName, ref);\n\t\t}\n\t\telse if (value instanceof RuntimeBeanNameReference ref) {\n\t\t\tString refName = ref.getBeanName();\n\t\t\trefName = String.valueOf(doEvaluate(refName));\n\t\t\tif (!this.beanFactory.containsBean(refName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\t\"Invalid bean name '\" + refName + \"' in bean reference for \" + argName);\n\t\t\t}\n\t\t\treturn refName;\n\t\t}\n\t\telse if (value instanceof BeanDefinitionHolder bdHolder) {\n\t\t\t// Resolve BeanDefinitionHolder: contains BeanDefinition with name and aliases.\n\t\t\treturn resolveInnerBean(bdHolder.getBeanName(), bdHolder.getBeanDefinition(),\n\t\t\t\t\t(name, mbd) -> resolveInnerBeanValue(argName, name, mbd));\n\t\t}\n\t\telse if (value instanceof BeanDefinition bd) {\n\t\t\treturn resolveInnerBean(null, bd,\n\t\t\t\t\t(name, mbd) -> resolveInnerBeanValue(argName, name, mbd));\n\t\t}\n\t\telse if (value instanceof DependencyDescriptor dependencyDescriptor) {\n\t\t\tSet<String> autowiredBeanNames = new LinkedHashSet<>(4);\n\t\t\tObject result = this.beanFactory.resolveDependency(\n\t\t\t\t\tdependencyDescriptor, this.beanName, autowiredBeanNames, this.typeConverter);\n\t\t\tfor (String autowiredBeanName : autowiredBeanNames) {\n\t\t\t\tif (this.beanFactory.containsBean(autowiredBeanName)) {\n\t\t\t\t\tthis.beanFactory.registerDependentBean(autowiredBeanName, this.beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\telse if (value instanceof ManagedArray managedArray) {\n\t\t\t// May need to resolve contained runtime references.\n\t\t\tClass<?> elementType = managedArray.resolvedElementType;\n\t\t\tif (elementType == null) {\n\t\t\t\tString elementTypeName = managedArray.getElementTypeName();\n\t\t\t\tif (StringUtils.hasText(elementTypeName)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\telementType = ClassUtils.forName(elementTypeName, this.beanFactory.getBeanClassLoader());\n\t\t\t\t\t\tmanagedArray.resolvedElementType = elementType;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t// Improve the message by showing the context.\n\t\t\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\t\t\tthis.beanDefinition.getResourceDescription(), this.beanName,\n\t\t\t\t\t\t\t\t\"Error resolving array type for \" + argName, ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\telementType = Object.class;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resolveManagedArray(argName, (List<?>) value, elementType);\n\t\t}\n\t\telse if (value instanceof ManagedList<?> managedList) {\n\t\t\t// May need to resolve contained runtime references.\n\t\t\treturn resolveManagedList(argName, managedList);\n\t\t}\n\t\telse if (value instanceof ManagedSet<?> managedSet) {\n\t\t\t// May need to resolve contained runtime references.\n\t\t\treturn resolveManagedSet(argName, managedSet);\n\t\t}\n\t\telse if (value instanceof ManagedMap<?, ?> managedMap) {\n\t\t\t// May need to resolve contained runtime references.\n\t\t\treturn resolveManagedMap(argName, managedMap);\n\t\t}\n\t\telse if (value instanceof ManagedProperties original) {\n\t\t\t// Properties original = managedProperties;\n\t\t\tProperties copy = new Properties();\n\t\t\toriginal.forEach((propKey, propValue) -> {\n\t\t\t\tif (propKey instanceof TypedStringValue typedStringValue) {\n\t\t\t\t\tpropKey = evaluate(typedStringValue);\n\t\t\t\t}\n\t\t\t\tif (propValue instanceof TypedStringValue typedStringValue) {\n\t\t\t\t\tpropValue = evaluate(typedStringValue);\n\t\t\t\t}\n\t\t\t\tif (propKey == null || propValue == null) {\n\t\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\t\tthis.beanDefinition.getResourceDescription(), this.beanName,\n\t\t\t\t\t\t\t\"Error converting Properties key/value pair for \" + argName + \": resolved to null\");\n\t\t\t\t}\n\t\t\t\tcopy.put(propKey, propValue);\n\t\t\t});\n\t\t\treturn copy;\n\t\t}\n\t\telse if (value instanceof TypedStringValue typedStringValue) {\n\t\t\t// Convert value to target type here.\n\t\t\tObject valueObject = evaluate(typedStringValue);\n\t\t\ttry {\n\t\t\t\tClass<?> resolvedTargetType = resolveTargetType(typedStringValue);\n\t\t\t\tif (resolvedTargetType != null) {\n\t\t\t\t\treturn this.typeConverter.convertIfNecessary(valueObject, resolvedTargetType);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn valueObject;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// Improve the message by showing the context.\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tthis.beanDefinition.getResourceDescription(), this.beanName,\n\t\t\t\t\t\t\"Error converting typed String value for \" + argName, ex);\n\t\t\t}\n\t\t}\n\t\telse if (value instanceof NullBean) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn evaluate(value);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#set(index,element)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 1954
    },
    "return": "BeanPostProcessor",
    "signature": "public BeanPostProcessor set(int index, BeanPostProcessor element)",
    "source_code": "\t\tpublic BeanPostProcessor set(int index, BeanPostProcessor element) {\n\t\t\tBeanPostProcessor result = super.set(index, element);\n\t\t\tresetBeanPostProcessorCache();\n\t\t\treturn result;\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#storeCache(mbd,constructorOrFactoryMethod)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mbd",
      "constructorOrFactoryMethod"
    ],
    "position": {
      "column": 1,
      "line": 1275
    },
    "return": "void",
    "signature": "public void storeCache(RootBeanDefinition mbd, Executable constructorOrFactoryMethod)",
    "source_code": "\t\tpublic void storeCache(RootBeanDefinition mbd, Executable constructorOrFactoryMethod) {\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod = constructorOrFactoryMethod;\n\t\t\t\tmbd.constructorArgumentsResolved = true;\n\t\t\t\tif (this.resolveNecessary) {\n\t\t\t\t\tmbd.preparedConstructorArguments = this.preparedArguments;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmbd.resolvedConstructorArguments = this.arguments;\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#unsatisfiedNonSimpleProperties(mbd,bw)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return an array of non-simple bean properties that are unsatisfied.\n\t * These are probably unsatisfied references to other beans in the\n\t * factory. Does not include simple properties like primitives or Strings.\n\t * @param mbd the merged bean definition the bean was created with\n\t * @param bw the BeanWrapper the bean was created with\n\t * @return an array of bean property names\n\t * @see org.springframework.beans.BeanUtils#isSimpleProperty\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mbd",
      "bw"
    ],
    "position": {
      "column": 1,
      "line": 1510
    },
    "return": "String[]",
    "signature": "protected String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, BeanWrapper bw)",
    "source_code": "\tprotected String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, BeanWrapper bw) {\n\t\tSet<String> result = new TreeSet<>();\n\t\tPropertyValues pvs = mbd.getPropertyValues();\n\t\tPropertyDescriptor[] pds = bw.getPropertyDescriptors();\n\t\tfor (PropertyDescriptor pd : pds) {\n\t\t\tif (pd.getWriteMethod() != null && !isExcludedFromDependencyCheck(pd) && !pvs.contains(pd.getName()) &&\n\t\t\t\t\t!BeanUtils.isSimpleProperty(pd.getPropertyType())) {\n\t\t\t\tresult.add(pd.getName());\n\t\t\t}\n\t\t}\n\t\treturn StringUtils.toStringArray(result);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#buildTypedStringValue(value,targetTypeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Build a typed String value Object for the given raw value.\n\t * @see org.springframework.beans.factory.config.TypedStringValue\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "targetTypeName"
    ],
    "position": {
      "column": 1,
      "line": 1096
    },
    "return": "TypedStringValue",
    "signature": "protected TypedStringValue buildTypedStringValue(String value, @Nullable String targetTypeName)",
    "source_code": "\tprotected TypedStringValue buildTypedStringValue(String value, @Nullable String targetTypeName)\n\t\t\tthrows ClassNotFoundException {\n\n\t\tClassLoader classLoader = this.readerContext.getBeanClassLoader();\n\t\tTypedStringValue typedValue;\n\t\tif (!StringUtils.hasText(targetTypeName)) {\n\t\t\ttypedValue = new TypedStringValue(value);\n\t\t}\n\t\telse if (classLoader != null) {\n\t\t\tClass<?> targetType = ClassUtils.forName(targetTypeName, classLoader);\n\t\t\ttypedValue = new TypedStringValue(value, targetType);\n\t\t}\n\t\telse {\n\t\t\ttypedValue = new TypedStringValue(value, targetTypeName);\n\t\t}\n\t\treturn typedValue;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#buildTypedStringValueForMap(value,defaultTypeName,entryEle)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Build a typed String value Object for the given raw value.\n\t * @see org.springframework.beans.factory.config.TypedStringValue\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "defaultTypeName",
      "entryEle"
    ],
    "position": {
      "column": 1,
      "line": 1291
    },
    "return": "Object",
    "signature": "protected Object buildTypedStringValueForMap(String value, String defaultTypeName, Element entryEle)",
    "source_code": "\tprotected final Object buildTypedStringValueForMap(String value, String defaultTypeName, Element entryEle) {\n\t\ttry {\n\t\t\tTypedStringValue typedValue = buildTypedStringValue(value, defaultTypeName);\n\t\t\ttypedValue.setSource(extractSource(entryEle));\n\t\t\treturn typedValue;\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\terror(\"Type class [\" + defaultTypeName + \"] not found for Map key/value type\", entryEle, ex);\n\t\t\treturn value;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#checkNameUniqueness(beanName,aliases,beanElement)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Validate that the specified bean name and aliases have not been used already\n\t * within the current level of beans element nesting.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "aliases",
      "beanElement"
    ],
    "position": {
      "column": 1,
      "line": 478
    },
    "return": "void",
    "signature": "protected void checkNameUniqueness(String beanName, List<String> aliases, Element beanElement)",
    "source_code": "\tprotected void checkNameUniqueness(String beanName, List<String> aliases, Element beanElement) {\n\t\tString foundName = null;\n\n\t\tif (StringUtils.hasText(beanName) && this.usedNames.contains(beanName)) {\n\t\t\tfoundName = beanName;\n\t\t}\n\t\tif (foundName == null) {\n\t\t\tfoundName = CollectionUtils.findFirstMatch(this.usedNames, aliases);\n\t\t}\n\t\tif (foundName != null) {\n\t\t\terror(\"Bean name '\" + foundName + \"' is already used in this <beans> element\", beanElement);\n\t\t}\n\n\t\tthis.usedNames.add(beanName);\n\t\tthis.usedNames.addAll(aliases);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#createBeanDefinition(className,parentName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a bean definition for the given class name and parent name.\n\t * @param className the name of the bean class\n\t * @param parentName the name of the bean's parent bean\n\t * @return the newly created bean definition\n\t * @throws ClassNotFoundException if bean class resolution was attempted but failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "className",
      "parentName"
    ],
    "position": {
      "column": 1,
      "line": 639
    },
    "return": "AbstractBeanDefinition",
    "signature": "protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)",
    "source_code": "\tprotected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)\n\t\t\tthrows ClassNotFoundException {\n\n\t\treturn BeanDefinitionReaderUtils.createBeanDefinition(\n\t\t\t\tparentName, className, this.readerContext.getBeanClassLoader());\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#createDelegate(readerContext,root,parentDelegate)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readerContext",
      "root",
      "parentDelegate"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "BeanDefinitionParserDelegate",
    "signature": "protected BeanDefinitionParserDelegate createDelegate(XmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate)",
    "source_code": "\tprotected BeanDefinitionParserDelegate createDelegate(\n\t\t\tXmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate) {\n\n\t\tBeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext);\n\t\tdelegate.initDefaults(root, parentDelegate);\n\t\treturn delegate;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#decorate(node,definition,parserContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "node",
      "definition",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext)",
    "source_code": "\tpublic BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {\n\t\tif (node instanceof Attr attr) {\n\t\t\tString propertyName = parserContext.getDelegate().getLocalName(attr);\n\t\t\tString propertyValue = attr.getValue();\n\t\t\tMutablePropertyValues pvs = definition.getBeanDefinition().getPropertyValues();\n\t\t\tif (pvs.contains(propertyName)) {\n\t\t\t\tparserContext.getReaderContext().error(\"Property '\" + propertyName + \"' is already defined using \" +\n\t\t\t\t\t\t\"both <property> and inline syntax. Only one approach may be used per property.\", attr);\n\t\t\t}\n\t\t\tif (propertyName.endsWith(REF_SUFFIX)) {\n\t\t\t\tpropertyName = propertyName.substring(0, propertyName.length() - REF_SUFFIX.length());\n\t\t\t\tpvs.add(Conventions.attributeNameToPropertyName(propertyName), new RuntimeBeanReference(propertyValue));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpvs.add(Conventions.attributeNameToPropertyName(propertyName), propertyValue);\n\t\t\t}\n\t\t}\n\t\treturn definition;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#decorateBeanDefinitionIfRequired(ele,originalDef)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Decorate the given bean definition through a namespace handler, if applicable.\n\t * @param ele the current element\n\t * @param originalDef the current bean definition\n\t * @return the decorated bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "originalDef"
    ],
    "position": {
      "column": 1,
      "line": 1399
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder originalDef)",
    "source_code": "\tpublic BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder originalDef) {\n\t\treturn decorateBeanDefinitionIfRequired(ele, originalDef, null);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#decorateBeanDefinitionIfRequired(ele,originalDef,containingBd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Decorate the given bean definition through a namespace handler, if applicable.\n\t * @param ele the current element\n\t * @param originalDef the current bean definition\n\t * @param containingBd the containing bean definition (if any)\n\t * @return the decorated bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "originalDef",
      "containingBd"
    ],
    "position": {
      "column": 1,
      "line": 1410
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd)",
    "source_code": "\tpublic BeanDefinitionHolder decorateBeanDefinitionIfRequired(\n\t\t\tElement ele, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) {\n\n\t\tBeanDefinitionHolder finalDefinition = originalDef;\n\n\t\t// Decorate based on custom attributes first.\n\t\tNamedNodeMap attributes = ele.getAttributes();\n\t\tfor (int i = 0; i < attributes.getLength(); i++) {\n\t\t\tNode node = attributes.item(i);\n\t\t\tfinalDefinition = decorateIfRequired(node, finalDefinition, containingBd);\n\t\t}\n\n\t\t// Decorate based on custom nested elements.\n\t\tNodeList children = ele.getChildNodes();\n\t\tfor (int i = 0; i < children.getLength(); i++) {\n\t\t\tNode node = children.item(i);\n\t\t\tif (node.getNodeType() == Node.ELEMENT_NODE) {\n\t\t\t\tfinalDefinition = decorateIfRequired(node, finalDefinition, containingBd);\n\t\t\t}\n\t\t}\n\t\treturn finalDefinition;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#decorateIfRequired(node,originalDef,containingBd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Decorate the given bean definition through a namespace handler,\n\t * if applicable.\n\t * @param node the current child node\n\t * @param originalDef the current bean definition\n\t * @param containingBd the containing bean definition (if any)\n\t * @return the decorated bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "node",
      "originalDef",
      "containingBd"
    ],
    "position": {
      "column": 1,
      "line": 1441
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder decorateIfRequired(Node node, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd)",
    "source_code": "\tpublic BeanDefinitionHolder decorateIfRequired(\n\t\t\tNode node, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) {\n\n\t\tString namespaceUri = getNamespaceURI(node);\n\t\tif (namespaceUri != null && !isDefaultNamespace(namespaceUri)) {\n\t\t\tNamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n\t\t\tif (handler != null) {\n\t\t\t\tBeanDefinitionHolder decorated =\n\t\t\t\t\t\thandler.decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd));\n\t\t\t\tif (decorated != null) {\n\t\t\t\t\treturn decorated;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (namespaceUri.startsWith(\"http://www.springframework.org/schema/\")) {\n\t\t\t\terror(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", node);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// A custom namespace, not to be handled by Spring - maybe \"xml:...\".\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"No Spring NamespaceHandler found for XML schema namespace [\" + namespaceUri + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn originalDef;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#error(message,source)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Report an error with the given message for the given source element.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "void",
    "signature": "protected void error(String message, Element source)",
    "source_code": "\tprotected void error(String message, Element source) {\n\t\tthis.readerContext.error(message, source, this.parseState.snapshot());\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#error(message,source,cause)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Report an error with the given message for the given source element.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "source",
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "void",
    "signature": "protected void error(String message, Element source, Throwable cause)",
    "source_code": "\tprotected void error(String message, Element source, Throwable cause) {\n\t\tthis.readerContext.error(message, source, this.parseState.snapshot(), cause);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#initDefaults(root,parent)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the default lazy-init, autowire, dependency check settings,\n\t * init-method, destroy-method and merge settings. Support nested 'beans'\n\t * element use cases by falling back to the given parent in case the\n\t * defaults are not explicitly set locally.\n\t * @see #populateDefaults(DocumentDefaultsDefinition, DocumentDefaultsDefinition, org.w3c.dom.Element)\n\t * @see #getDefaults()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "root",
      "parent"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "void",
    "signature": "public void initDefaults(Element root, @Nullable BeanDefinitionParserDelegate parent)",
    "source_code": "\tpublic void initDefaults(Element root, @Nullable BeanDefinitionParserDelegate parent) {\n\t\tpopulateDefaults(this.defaults, (parent != null ? parent.defaults : null), root);\n\t\tthis.readerContext.fireDefaultsRegistered(this.defaults);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#nodeNameEquals(node,desiredName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the name of the supplied node is equal to the supplied name.\n\t * <p>The default implementation checks the supplied desired name against both\n\t * {@link Node#getNodeName()} and {@link Node#getLocalName()}.\n\t * <p>Subclasses may override the default implementation to provide a different\n\t * mechanism for comparing node names.\n\t * @param node the node to compare\n\t * @param desiredName the name to check for\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "node",
      "desiredName"
    ],
    "position": {
      "column": 1,
      "line": 1517
    },
    "return": "boolean",
    "signature": "public boolean nodeNameEquals(Node node, String desiredName)",
    "source_code": "\tpublic boolean nodeNameEquals(Node node, String desiredName) {\n\t\treturn desiredName.equals(node.getNodeName()) || desiredName.equals(getLocalName(node));\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parse(element,parserContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "BeanDefinition",
    "signature": "public BeanDefinition parse(Element element, ParserContext parserContext)",
    "source_code": "\tpublic BeanDefinition parse(Element element, ParserContext parserContext) {\n\t\tparserContext.getReaderContext().error(\n\t\t\t\t\"Class [\" + getClass().getName() + \"] does not support custom elements.\", element);\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseArrayElement(arrayEle,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse an array element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "arrayEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 1117
    },
    "return": "Object",
    "signature": "public Object parseArrayElement(Element arrayEle, @Nullable BeanDefinition bd)",
    "source_code": "\tpublic Object parseArrayElement(Element arrayEle, @Nullable BeanDefinition bd) {\n\t\tString elementType = arrayEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\tNodeList nl = arrayEle.getChildNodes();\n\t\tManagedArray target = new ManagedArray(elementType, nl.getLength());\n\t\ttarget.setSource(extractSource(arrayEle));\n\t\ttarget.setElementTypeName(elementType);\n\t\ttarget.setMergeEnabled(parseMergeAttribute(arrayEle));\n\t\tparseCollectionElements(nl, target, bd, elementType);\n\t\treturn target;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseBeanDefinitionAttributes(ele,beanName,containingBean,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the attributes of the given bean element to the given bean * definition.\n\t * @param ele bean declaration element\n\t * @param beanName bean name\n\t * @param containingBean containing bean definition\n\t * @return a bean definition initialized according to the bean element attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "beanName",
      "containingBean",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 556
    },
    "return": "AbstractBeanDefinition",
    "signature": "public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,\n\t\t\t@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd)",
    "source_code": "\tpublic AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,\n\t\t\t@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {\n\n\t\tif (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {\n\t\t\terror(\"Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration\", ele);\n\t\t}\n\t\telse if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {\n\t\t\tbd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));\n\t\t}\n\t\telse if (containingBean != null) {\n\t\t\t// Take default from containing bean in case of an inner bean definition.\n\t\t\tbd.setScope(containingBean.getScope());\n\t\t}\n\n\t\tif (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {\n\t\t\tbd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));\n\t\t}\n\n\t\tString lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);\n\t\tif (isDefaultValue(lazyInit)) {\n\t\t\tlazyInit = this.defaults.getLazyInit();\n\t\t}\n\t\tbd.setLazyInit(TRUE_VALUE.equals(lazyInit));\n\n\t\tString autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);\n\t\tbd.setAutowireMode(getAutowireMode(autowire));\n\n\t\tif (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {\n\t\t\tString dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);\n\t\t\tbd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));\n\t\t}\n\n\t\tString autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);\n\t\tif (isDefaultValue(autowireCandidate)) {\n\t\t\tString candidatePattern = this.defaults.getAutowireCandidates();\n\t\t\tif (candidatePattern != null) {\n\t\t\t\tString[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);\n\t\t\t\tbd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));\n\t\t}\n\n\t\tif (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {\n\t\t\tbd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));\n\t\t}\n\n\t\tif (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {\n\t\t\tString initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);\n\t\t\tbd.setInitMethodName(initMethodName);\n\t\t}\n\t\telse if (this.defaults.getInitMethod() != null) {\n\t\t\tbd.setInitMethodName(this.defaults.getInitMethod());\n\t\t\tbd.setEnforceInitMethod(false);\n\t\t}\n\n\t\tif (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {\n\t\t\tString destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);\n\t\t\tbd.setDestroyMethodName(destroyMethodName);\n\t\t}\n\t\telse if (this.defaults.getDestroyMethod() != null) {\n\t\t\tbd.setDestroyMethodName(this.defaults.getDestroyMethod());\n\t\t\tbd.setEnforceDestroyMethod(false);\n\t\t}\n\n\t\tif (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {\n\t\t\tbd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));\n\t\t}\n\t\tif (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {\n\t\t\tbd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));\n\t\t}\n\n\t\treturn bd;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseBeanDefinitionElement(ele,beanName,containingBean)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the bean definition itself, without regard to name or aliases. May return\n\t * {@code null} if problems occurred during the parsing of the bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "beanName",
      "containingBean"
    ],
    "position": {
      "column": 1,
      "line": 500
    },
    "return": "AbstractBeanDefinition",
    "signature": "public AbstractBeanDefinition parseBeanDefinitionElement(Element ele, String beanName, @Nullable BeanDefinition containingBean)",
    "source_code": "\tpublic AbstractBeanDefinition parseBeanDefinitionElement(\n\t\t\tElement ele, String beanName, @Nullable BeanDefinition containingBean) {\n\n\t\tthis.parseState.push(new BeanEntry(beanName));\n\n\t\tString className = null;\n\t\tif (ele.hasAttribute(CLASS_ATTRIBUTE)) {\n\t\t\tclassName = ele.getAttribute(CLASS_ATTRIBUTE).trim();\n\t\t}\n\t\tString parent = null;\n\t\tif (ele.hasAttribute(PARENT_ATTRIBUTE)) {\n\t\t\tparent = ele.getAttribute(PARENT_ATTRIBUTE);\n\t\t}\n\n\t\ttry {\n\t\t\tAbstractBeanDefinition bd = createBeanDefinition(className, parent);\n\n\t\t\tparseBeanDefinitionAttributes(ele, beanName, containingBean, bd);\n\t\t\tbd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));\n\n\t\t\tparseMetaElements(ele, bd);\n\t\t\tparseLookupOverrideSubElements(ele, bd.getMethodOverrides());\n\t\t\tparseReplacedMethodSubElements(ele, bd.getMethodOverrides());\n\n\t\t\tparseConstructorArgElements(ele, bd);\n\t\t\tparsePropertyElements(ele, bd);\n\t\t\tparseQualifierElements(ele, bd);\n\n\t\t\tbd.setResource(this.readerContext.getResource());\n\t\t\tbd.setSource(extractSource(ele));\n\n\t\t\treturn bd;\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\terror(\"Bean class [\" + className + \"] not found\", ele, ex);\n\t\t}\n\t\tcatch (NoClassDefFoundError err) {\n\t\t\terror(\"Class that bean class [\" + className + \"] depends on not found\", ele, err);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\terror(\"Unexpected failure during bean definition parsing\", ele, ex);\n\t\t}\n\t\tfinally {\n\t\t\tthis.parseState.pop();\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseBeanDefinitionElement(ele,containingBean)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parses the supplied {@code <bean>} element. May return {@code null}\n\t * if there were errors during parse. Errors are reported to the\n\t * {@link org.springframework.beans.factory.parsing.ProblemReporter}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "containingBean"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean)",
    "source_code": "\tpublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {\n\t\tString id = ele.getAttribute(ID_ATTRIBUTE);\n\t\tString nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\n\t\tList<String> aliases = new ArrayList<>();\n\t\tif (StringUtils.hasLength(nameAttr)) {\n\t\t\tString[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n\t\t\taliases.addAll(Arrays.asList(nameArr));\n\t\t}\n\n\t\tString beanName = id;\n\t\tif (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {\n\t\t\tbeanName = aliases.remove(0);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No XML 'id' specified - using '\" + beanName +\n\t\t\t\t\t\t\"' as bean name and \" + aliases + \" as aliases\");\n\t\t\t}\n\t\t}\n\n\t\tif (containingBean == null) {\n\t\t\tcheckNameUniqueness(beanName, aliases, ele);\n\t\t}\n\n\t\tAbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);\n\t\tif (beanDefinition != null) {\n\t\t\tif (!StringUtils.hasText(beanName)) {\n\t\t\t\ttry {\n\t\t\t\t\tif (containingBean != null) {\n\t\t\t\t\t\tbeanName = BeanDefinitionReaderUtils.generateBeanName(\n\t\t\t\t\t\t\t\tbeanDefinition, this.readerContext.getRegistry(), true);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbeanName = this.readerContext.generateBeanName(beanDefinition);\n\t\t\t\t\t\t// Register an alias for the plain bean class name, if still possible,\n\t\t\t\t\t\t// if the generator returned the class name plus a suffix.\n\t\t\t\t\t\t// This is expected for Spring 1.2/2.0 backwards compatibility.\n\t\t\t\t\t\tString beanClassName = beanDefinition.getBeanClassName();\n\t\t\t\t\t\tif (beanClassName != null &&\n\t\t\t\t\t\t\t\tbeanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&\n\t\t\t\t\t\t\t\t!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {\n\t\t\t\t\t\t\taliases.add(beanClassName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Neither XML 'id' nor 'name' specified - \" +\n\t\t\t\t\t\t\t\t\"using generated bean name [\" + beanName + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\terror(ex.getMessage(), ele);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString[] aliasesArray = StringUtils.toStringArray(aliases);\n\t\t\treturn new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseBeanDefinitions(root,delegate)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the elements at the root level in the document:\n\t * \"import\", \"alias\", \"bean\".\n\t * @param root the DOM root element of the document\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "root",
      "delegate"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "void",
    "signature": "protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)",
    "source_code": "\tprotected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {\n\t\tif (delegate.isDefaultNamespace(root)) {\n\t\t\tNodeList nl = root.getChildNodes();\n\t\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\t\tNode node = nl.item(i);\n\t\t\t\tif (node instanceof Element ele) {\n\t\t\t\t\tif (delegate.isDefaultNamespace(ele)) {\n\t\t\t\t\t\tparseDefaultElement(ele, delegate);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdelegate.parseCustomElement(ele);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdelegate.parseCustomElement(root);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseCollectionElements(elementNodes,target,bd,defaultElementType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "elementNodes",
      "target",
      "bd",
      "defaultElementType"
    ],
    "position": {
      "column": 1,
      "line": 1156
    },
    "return": "void",
    "signature": "protected void parseCollectionElements(NodeList elementNodes, Collection<Object> target, @Nullable BeanDefinition bd, String defaultElementType)",
    "source_code": "\tprotected void parseCollectionElements(\n\t\t\tNodeList elementNodes, Collection<Object> target, @Nullable BeanDefinition bd, String defaultElementType) {\n\n\t\tfor (int i = 0; i < elementNodes.getLength(); i++) {\n\t\t\tNode node = elementNodes.item(i);\n\t\t\tif (node instanceof Element currentElement && !nodeNameEquals(node, DESCRIPTION_ELEMENT)) {\n\t\t\t\ttarget.add(parsePropertySubElement(currentElement, bd, defaultElementType));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseConstructorArgElement(ele,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a constructor-arg element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 778
    },
    "return": "void",
    "signature": "public void parseConstructorArgElement(Element ele, BeanDefinition bd)",
    "source_code": "\tpublic void parseConstructorArgElement(Element ele, BeanDefinition bd) {\n\t\tString indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);\n\t\tString typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);\n\t\tString nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\t\tif (StringUtils.hasLength(indexAttr)) {\n\t\t\ttry {\n\t\t\t\tint index = Integer.parseInt(indexAttr);\n\t\t\t\tif (index < 0) {\n\t\t\t\t\terror(\"'index' cannot be lower than 0\", ele);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.parseState.push(new ConstructorArgumentEntry(index));\n\t\t\t\t\t\tObject value = parsePropertyValue(ele, bd, null);\n\t\t\t\t\t\tConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);\n\t\t\t\t\t\tif (StringUtils.hasLength(typeAttr)) {\n\t\t\t\t\t\t\tvalueHolder.setType(typeAttr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (StringUtils.hasLength(nameAttr)) {\n\t\t\t\t\t\t\tvalueHolder.setName(nameAttr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueHolder.setSource(extractSource(ele));\n\t\t\t\t\t\tif (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) {\n\t\t\t\t\t\t\terror(\"Ambiguous constructor-arg entries for index \" + index, ele);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tthis.parseState.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NumberFormatException ex) {\n\t\t\t\terror(\"Attribute 'index' of tag 'constructor-arg' must be an integer\", ele);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tthis.parseState.push(new ConstructorArgumentEntry());\n\t\t\t\tObject value = parsePropertyValue(ele, bd, null);\n\t\t\t\tConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);\n\t\t\t\tif (StringUtils.hasLength(typeAttr)) {\n\t\t\t\t\tvalueHolder.setType(typeAttr);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasLength(nameAttr)) {\n\t\t\t\t\tvalueHolder.setName(nameAttr);\n\t\t\t\t}\n\t\t\t\tvalueHolder.setSource(extractSource(ele));\n\t\t\t\tbd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.parseState.pop();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseConstructorArgElements(beanEle,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse constructor-arg sub-elements of the given bean element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 694
    },
    "return": "void",
    "signature": "public void parseConstructorArgElements(Element beanEle, BeanDefinition bd)",
    "source_code": "\tpublic void parseConstructorArgElements(Element beanEle, BeanDefinition bd) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) {\n\t\t\t\tparseConstructorArgElement((Element) node, bd);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseCustomElement(ele,containingBd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a custom element (outside the default namespace).\n\t * @param ele the element to parse\n\t * @param containingBd the containing bean definition (if any)\n\t * @return the resulting bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "containingBd"
    ],
    "position": {
      "column": 1,
      "line": 1380
    },
    "return": "BeanDefinition",
    "signature": "public BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd)",
    "source_code": "\tpublic BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) {\n\t\tString namespaceUri = getNamespaceURI(ele);\n\t\tif (namespaceUri == null) {\n\t\t\treturn null;\n\t\t}\n\t\tNamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n\t\tif (handler == null) {\n\t\t\terror(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", ele);\n\t\t\treturn null;\n\t\t}\n\t\treturn handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseKeyElement(keyEle,bd,defaultKeyTypeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a key sub-element of a map element.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "keyEle",
      "bd",
      "defaultKeyTypeName"
    ],
    "position": {
      "column": 1,
      "line": 1307
    },
    "return": "Object",
    "signature": "protected Object parseKeyElement(Element keyEle, @Nullable BeanDefinition bd, String defaultKeyTypeName)",
    "source_code": "\tprotected Object parseKeyElement(Element keyEle, @Nullable BeanDefinition bd, String defaultKeyTypeName) {\n\t\tNodeList nl = keyEle.getChildNodes();\n\t\tElement subElement = null;\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (node instanceof Element currentElement) {\n\t\t\t\t// Child element is what we're looking for.\n\t\t\t\tif (subElement != null) {\n\t\t\t\t\terror(\"<key> element must not contain more than one value sub-element\", keyEle);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsubElement = currentElement;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (subElement == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn parsePropertySubElement(subElement, bd, defaultKeyTypeName);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseListElement(collectionEle,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a list element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collectionEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 1131
    },
    "return": "List<Object>",
    "signature": "public List<Object> parseListElement(Element collectionEle, @Nullable BeanDefinition bd)",
    "source_code": "\tpublic List<Object> parseListElement(Element collectionEle, @Nullable BeanDefinition bd) {\n\t\tString defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\tNodeList nl = collectionEle.getChildNodes();\n\t\tManagedList<Object> target = new ManagedList<>(nl.getLength());\n\t\ttarget.setSource(extractSource(collectionEle));\n\t\ttarget.setElementTypeName(defaultElementType);\n\t\ttarget.setMergeEnabled(parseMergeAttribute(collectionEle));\n\t\tparseCollectionElements(nl, target, bd, defaultElementType);\n\t\treturn target;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseLookupOverrideSubElements(beanEle,overrides)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse lookup-override sub-elements of the given bean element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanEle",
      "overrides"
    ],
    "position": {
      "column": 1,
      "line": 733
    },
    "return": "void",
    "signature": "public void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides)",
    "source_code": "\tpublic void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) {\n\t\t\t\tElement ele = (Element) node;\n\t\t\t\tString methodName = ele.getAttribute(NAME_ATTRIBUTE);\n\t\t\t\tString beanRef = ele.getAttribute(BEAN_ELEMENT);\n\t\t\t\tLookupOverride override = new LookupOverride(methodName, beanRef);\n\t\t\t\toverride.setSource(extractSource(ele));\n\t\t\t\toverrides.addOverride(override);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseMapElement(mapEle,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a map element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 1170
    },
    "return": "Object>",
    "signature": "public Object> parseMapElement(Element mapEle, @Nullable BeanDefinition bd)",
    "source_code": "\tpublic Map<Object, Object> parseMapElement(Element mapEle, @Nullable BeanDefinition bd) {\n\t\tString defaultKeyType = mapEle.getAttribute(KEY_TYPE_ATTRIBUTE);\n\t\tString defaultValueType = mapEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\n\t\tList<Element> entryEles = DomUtils.getChildElementsByTagName(mapEle, ENTRY_ELEMENT);\n\t\tManagedMap<Object, Object> map = new ManagedMap<>(entryEles.size());\n\t\tmap.setSource(extractSource(mapEle));\n\t\tmap.setKeyTypeName(defaultKeyType);\n\t\tmap.setValueTypeName(defaultValueType);\n\t\tmap.setMergeEnabled(parseMergeAttribute(mapEle));\n\n\t\tfor (Element entryEle : entryEles) {\n\t\t\t// Should only have one value child element: ref, value, list, etc.\n\t\t\t// Optionally, there might be a key child element.\n\t\t\tNodeList entrySubNodes = entryEle.getChildNodes();\n\t\t\tElement keyEle = null;\n\t\t\tElement valueEle = null;\n\t\t\tfor (int j = 0; j < entrySubNodes.getLength(); j++) {\n\t\t\t\tNode node = entrySubNodes.item(j);\n\t\t\t\tif (node instanceof Element candidateEle) {\n\t\t\t\t\tif (nodeNameEquals(candidateEle, KEY_ELEMENT)) {\n\t\t\t\t\t\tif (keyEle != null) {\n\t\t\t\t\t\t\terror(\"<entry> element is only allowed to contain one <key> sub-element\", entryEle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tkeyEle = candidateEle;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Child element is what we're looking for.\n\t\t\t\t\t\tif (nodeNameEquals(candidateEle, DESCRIPTION_ELEMENT)) {\n\t\t\t\t\t\t\t// the element is a <description> -> ignore it\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (valueEle != null) {\n\t\t\t\t\t\t\terror(\"<entry> element must not contain more than one value sub-element\", entryEle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvalueEle = candidateEle;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Extract key from attribute or sub-element.\n\t\t\tObject key = null;\n\t\t\tboolean hasKeyAttribute = entryEle.hasAttribute(KEY_ATTRIBUTE);\n\t\t\tboolean hasKeyRefAttribute = entryEle.hasAttribute(KEY_REF_ATTRIBUTE);\n\t\t\tif ((hasKeyAttribute && hasKeyRefAttribute) ||\n\t\t\t\t\t(hasKeyAttribute || hasKeyRefAttribute) && keyEle != null) {\n\t\t\t\terror(\"<entry> element is only allowed to contain either \" +\n\t\t\t\t\t\t\"a 'key' attribute OR a 'key-ref' attribute OR a <key> sub-element\", entryEle);\n\t\t\t}\n\t\t\tif (hasKeyAttribute) {\n\t\t\t\tkey = buildTypedStringValueForMap(entryEle.getAttribute(KEY_ATTRIBUTE), defaultKeyType, entryEle);\n\t\t\t}\n\t\t\telse if (hasKeyRefAttribute) {\n\t\t\t\tString refName = entryEle.getAttribute(KEY_REF_ATTRIBUTE);\n\t\t\t\tif (!StringUtils.hasText(refName)) {\n\t\t\t\t\terror(\"<entry> element contains empty 'key-ref' attribute\", entryEle);\n\t\t\t\t}\n\t\t\t\tRuntimeBeanReference ref = new RuntimeBeanReference(refName);\n\t\t\t\tref.setSource(extractSource(entryEle));\n\t\t\t\tkey = ref;\n\t\t\t}\n\t\t\telse if (keyEle != null) {\n\t\t\t\tkey = parseKeyElement(keyEle, bd, defaultKeyType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\terror(\"<entry> element must specify a key\", entryEle);\n\t\t\t}\n\n\t\t\t// Extract value from attribute or sub-element.\n\t\t\tObject value = null;\n\t\t\tboolean hasValueAttribute = entryEle.hasAttribute(VALUE_ATTRIBUTE);\n\t\t\tboolean hasValueRefAttribute = entryEle.hasAttribute(VALUE_REF_ATTRIBUTE);\n\t\t\tboolean hasValueTypeAttribute = entryEle.hasAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\t\tif ((hasValueAttribute && hasValueRefAttribute) ||\n\t\t\t\t\t(hasValueAttribute || hasValueRefAttribute) && valueEle != null) {\n\t\t\t\terror(\"<entry> element is only allowed to contain either \" +\n\t\t\t\t\t\t\"'value' attribute OR 'value-ref' attribute OR <value> sub-element\", entryEle);\n\t\t\t}\n\t\t\tif ((hasValueTypeAttribute && hasValueRefAttribute) ||\n\t\t\t\t(hasValueTypeAttribute && !hasValueAttribute) ||\n\t\t\t\t\t(hasValueTypeAttribute && valueEle != null)) {\n\t\t\t\terror(\"<entry> element is only allowed to contain a 'value-type' \" +\n\t\t\t\t\t\t\"attribute when it has a 'value' attribute\", entryEle);\n\t\t\t}\n\t\t\tif (hasValueAttribute) {\n\t\t\t\tString valueType = entryEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\t\t\tif (!StringUtils.hasText(valueType)) {\n\t\t\t\t\tvalueType = defaultValueType;\n\t\t\t\t}\n\t\t\t\tvalue = buildTypedStringValueForMap(entryEle.getAttribute(VALUE_ATTRIBUTE), valueType, entryEle);\n\t\t\t}\n\t\t\telse if (hasValueRefAttribute) {\n\t\t\t\tString refName = entryEle.getAttribute(VALUE_REF_ATTRIBUTE);\n\t\t\t\tif (!StringUtils.hasText(refName)) {\n\t\t\t\t\terror(\"<entry> element contains empty 'value-ref' attribute\", entryEle);\n\t\t\t\t}\n\t\t\t\tRuntimeBeanReference ref = new RuntimeBeanReference(refName);\n\t\t\t\tref.setSource(extractSource(entryEle));\n\t\t\t\tvalue = ref;\n\t\t\t}\n\t\t\telse if (valueEle != null) {\n\t\t\t\tvalue = parsePropertySubElement(valueEle, bd, defaultValueType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\terror(\"<entry> element must specify a value\", entryEle);\n\t\t\t}\n\n\t\t\t// Add final key and value to the Map.\n\t\t\tmap.put(key, value);\n\t\t}\n\n\t\treturn map;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseMetaElements(ele,attributeAccessor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the meta elements underneath the given element, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "attributeAccessor"
    ],
    "position": {
      "column": 1,
      "line": 649
    },
    "return": "void",
    "signature": "public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor)",
    "source_code": "\tpublic void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) {\n\t\tNodeList nl = ele.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, META_ELEMENT)) {\n\t\t\t\tElement metaElement = (Element) node;\n\t\t\t\tString key = metaElement.getAttribute(KEY_ATTRIBUTE);\n\t\t\t\tString value = metaElement.getAttribute(VALUE_ATTRIBUTE);\n\t\t\t\tBeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value);\n\t\t\t\tattribute.setSource(extractSource(metaElement));\n\t\t\t\tattributeAccessor.addMetadataAttribute(attribute);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parsePropertyElement(ele,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a property element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 839
    },
    "return": "void",
    "signature": "public void parsePropertyElement(Element ele, BeanDefinition bd)",
    "source_code": "\tpublic void parsePropertyElement(Element ele, BeanDefinition bd) {\n\t\tString propertyName = ele.getAttribute(NAME_ATTRIBUTE);\n\t\tif (!StringUtils.hasLength(propertyName)) {\n\t\t\terror(\"Tag 'property' must have a 'name' attribute\", ele);\n\t\t\treturn;\n\t\t}\n\t\tthis.parseState.push(new PropertyEntry(propertyName));\n\t\ttry {\n\t\t\tif (bd.getPropertyValues().contains(propertyName)) {\n\t\t\t\terror(\"Multiple 'property' definitions for property '\" + propertyName + \"'\", ele);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tObject val = parsePropertyValue(ele, bd, propertyName);\n\t\t\tPropertyValue pv = new PropertyValue(propertyName, val);\n\t\t\tparseMetaElements(ele, pv);\n\t\t\tpv.setSource(extractSource(ele));\n\t\t\tbd.getPropertyValues().addPropertyValue(pv);\n\t\t}\n\t\tfinally {\n\t\t\tthis.parseState.pop();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parsePropertyElements(beanEle,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse property sub-elements of the given bean element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 707
    },
    "return": "void",
    "signature": "public void parsePropertyElements(Element beanEle, BeanDefinition bd)",
    "source_code": "\tpublic void parsePropertyElements(Element beanEle, BeanDefinition bd) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, PROPERTY_ELEMENT)) {\n\t\t\t\tparsePropertyElement((Element) node, bd);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parsePropertySubElement(ele,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a value, ref or collection sub-element of a property or\n\t * constructor-arg element.\n\t * @param ele subelement of property element; we don't know which yet\n\t * @param bd the current bean definition (if any)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 970
    },
    "return": "Object",
    "signature": "public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd)",
    "source_code": "\tpublic Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd) {\n\t\treturn parsePropertySubElement(ele, bd, null);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parsePropertySubElement(ele,bd,defaultValueType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a value, ref or collection sub-element of a property or\n\t * constructor-arg element.\n\t * @param ele subelement of property element; we don't know which yet\n\t * @param bd the current bean definition (if any)\n\t * @param defaultValueType the default type (class name) for any\n\t * {@code <value>} tag that might be created\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "bd",
      "defaultValueType"
    ],
    "position": {
      "column": 1,
      "line": 983
    },
    "return": "Object",
    "signature": "public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType)",
    "source_code": "\tpublic Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType) {\n\t\tif (!isDefaultNamespace(ele)) {\n\t\t\treturn parseNestedCustomElement(ele, bd);\n\t\t}\n\t\telse if (nodeNameEquals(ele, BEAN_ELEMENT)) {\n\t\t\tBeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);\n\t\t\tif (nestedBd != null) {\n\t\t\t\tnestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);\n\t\t\t}\n\t\t\treturn nestedBd;\n\t\t}\n\t\telse if (nodeNameEquals(ele, REF_ELEMENT)) {\n\t\t\t// A generic reference to any name of any bean.\n\t\t\tString refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);\n\t\t\tboolean toParent = false;\n\t\t\tif (!StringUtils.hasLength(refName)) {\n\t\t\t\t// A reference to the id of another bean in a parent context.\n\t\t\t\trefName = ele.getAttribute(PARENT_REF_ATTRIBUTE);\n\t\t\t\ttoParent = true;\n\t\t\t\tif (!StringUtils.hasLength(refName)) {\n\t\t\t\t\terror(\"'bean' or 'parent' is required for <ref> element\", ele);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!StringUtils.hasText(refName)) {\n\t\t\t\terror(\"<ref> element contains empty target attribute\", ele);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tRuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);\n\t\t\tref.setSource(extractSource(ele));\n\t\t\treturn ref;\n\t\t}\n\t\telse if (nodeNameEquals(ele, IDREF_ELEMENT)) {\n\t\t\treturn parseIdRefElement(ele);\n\t\t}\n\t\telse if (nodeNameEquals(ele, VALUE_ELEMENT)) {\n\t\t\treturn parseValueElement(ele, defaultValueType);\n\t\t}\n\t\telse if (nodeNameEquals(ele, NULL_ELEMENT)) {\n\t\t\t// It's a distinguished null value. Let's wrap it in a TypedStringValue\n\t\t\t// object in order to preserve the source location.\n\t\t\tTypedStringValue nullHolder = new TypedStringValue(null);\n\t\t\tnullHolder.setSource(extractSource(ele));\n\t\t\treturn nullHolder;\n\t\t}\n\t\telse if (nodeNameEquals(ele, ARRAY_ELEMENT)) {\n\t\t\treturn parseArrayElement(ele, bd);\n\t\t}\n\t\telse if (nodeNameEquals(ele, LIST_ELEMENT)) {\n\t\t\treturn parseListElement(ele, bd);\n\t\t}\n\t\telse if (nodeNameEquals(ele, SET_ELEMENT)) {\n\t\t\treturn parseSetElement(ele, bd);\n\t\t}\n\t\telse if (nodeNameEquals(ele, MAP_ELEMENT)) {\n\t\t\treturn parseMapElement(ele, bd);\n\t\t}\n\t\telse if (nodeNameEquals(ele, PROPS_ELEMENT)) {\n\t\t\treturn parsePropsElement(ele);\n\t\t}\n\t\telse {\n\t\t\terror(\"Unknown property sub-element: [\" + ele.getNodeName() + \"]\", ele);\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parsePropertyValue(ele,bd,propertyName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of a property element. May be a list etc.\n\t * Also used for constructor arguments, \"propertyName\" being null in this case.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "bd",
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 909
    },
    "return": "Object",
    "signature": "public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName)",
    "source_code": "\tpublic Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) {\n\t\tString elementName = (propertyName != null ?\n\t\t\t\t\"<property> element for property '\" + propertyName + \"'\" :\n\t\t\t\t\"<constructor-arg> element\");\n\n\t\t// Should only have one child element: ref, value, list, etc.\n\t\tNodeList nl = ele.getChildNodes();\n\t\tElement subElement = null;\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (node instanceof Element currentElement && !nodeNameEquals(node, DESCRIPTION_ELEMENT) &&\n\t\t\t\t\t!nodeNameEquals(node, META_ELEMENT)) {\n\t\t\t\t// Child element is what we're looking for.\n\t\t\t\tif (subElement != null) {\n\t\t\t\t\terror(elementName + \" must not contain more than one sub-element\", ele);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsubElement = currentElement;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);\n\t\tboolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);\n\t\tif ((hasRefAttribute && hasValueAttribute) ||\n\t\t\t\t((hasRefAttribute || hasValueAttribute) && subElement != null)) {\n\t\t\terror(elementName +\n\t\t\t\t\t\" is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element\", ele);\n\t\t}\n\n\t\tif (hasRefAttribute) {\n\t\t\tString refName = ele.getAttribute(REF_ATTRIBUTE);\n\t\t\tif (!StringUtils.hasText(refName)) {\n\t\t\t\terror(elementName + \" contains empty 'ref' attribute\", ele);\n\t\t\t}\n\t\t\tRuntimeBeanReference ref = new RuntimeBeanReference(refName);\n\t\t\tref.setSource(extractSource(ele));\n\t\t\treturn ref;\n\t\t}\n\t\telse if (hasValueAttribute) {\n\t\t\tTypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));\n\t\t\tvalueHolder.setSource(extractSource(ele));\n\t\t\treturn valueHolder;\n\t\t}\n\t\telse if (subElement != null) {\n\t\t\treturn parsePropertySubElement(subElement, bd);\n\t\t}\n\t\telse {\n\t\t\t// Neither child element nor \"ref\" or \"value\" attribute found.\n\t\t\terror(elementName + \" must specify a ref or value\", ele);\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseQualifierElement(ele,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a qualifier element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 865
    },
    "return": "void",
    "signature": "public void parseQualifierElement(Element ele, AbstractBeanDefinition bd)",
    "source_code": "\tpublic void parseQualifierElement(Element ele, AbstractBeanDefinition bd) {\n\t\tString typeName = ele.getAttribute(TYPE_ATTRIBUTE);\n\t\tif (!StringUtils.hasLength(typeName)) {\n\t\t\terror(\"Tag 'qualifier' must have a 'type' attribute\", ele);\n\t\t\treturn;\n\t\t}\n\t\tthis.parseState.push(new QualifierEntry(typeName));\n\t\ttry {\n\t\t\tAutowireCandidateQualifier qualifier = new AutowireCandidateQualifier(typeName);\n\t\t\tqualifier.setSource(extractSource(ele));\n\t\t\tString value = ele.getAttribute(VALUE_ATTRIBUTE);\n\t\t\tif (StringUtils.hasLength(value)) {\n\t\t\t\tqualifier.setAttribute(AutowireCandidateQualifier.VALUE_KEY, value);\n\t\t\t}\n\t\t\tNodeList nl = ele.getChildNodes();\n\t\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\t\tNode node = nl.item(i);\n\t\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, QUALIFIER_ATTRIBUTE_ELEMENT)) {\n\t\t\t\t\tElement attributeEle = (Element) node;\n\t\t\t\t\tString attributeName = attributeEle.getAttribute(KEY_ATTRIBUTE);\n\t\t\t\t\tString attributeValue = attributeEle.getAttribute(VALUE_ATTRIBUTE);\n\t\t\t\t\tif (StringUtils.hasLength(attributeName) && StringUtils.hasLength(attributeValue)) {\n\t\t\t\t\t\tBeanMetadataAttribute attribute = new BeanMetadataAttribute(attributeName, attributeValue);\n\t\t\t\t\t\tattribute.setSource(extractSource(attributeEle));\n\t\t\t\t\t\tqualifier.addMetadataAttribute(attribute);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\terror(\"Qualifier 'attribute' tag must have a 'name' and 'value'\", attributeEle);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbd.addQualifier(qualifier);\n\t\t}\n\t\tfinally {\n\t\t\tthis.parseState.pop();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseQualifierElements(beanEle,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse qualifier sub-elements of the given bean element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 720
    },
    "return": "void",
    "signature": "public void parseQualifierElements(Element beanEle, AbstractBeanDefinition bd)",
    "source_code": "\tpublic void parseQualifierElements(Element beanEle, AbstractBeanDefinition bd) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, QUALIFIER_ELEMENT)) {\n\t\t\t\tparseQualifierElement((Element) node, bd);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseReplacedMethodSubElements(beanEle,overrides)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse replaced-method sub-elements of the given bean element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanEle",
      "overrides"
    ],
    "position": {
      "column": 1,
      "line": 751
    },
    "return": "void",
    "signature": "public void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides)",
    "source_code": "\tpublic void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) {\n\t\t\t\tElement replacedMethodEle = (Element) node;\n\t\t\t\tString name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);\n\t\t\t\tString callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);\n\t\t\t\tReplaceOverride replaceOverride = new ReplaceOverride(name, callback);\n\t\t\t\t// Look for arg-type match elements.\n\t\t\t\tList<Element> argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);\n\t\t\t\tfor (Element argTypeEle : argTypeEles) {\n\t\t\t\t\tString match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);\n\t\t\t\t\tmatch = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle));\n\t\t\t\t\tif (StringUtils.hasText(match)) {\n\t\t\t\t\t\treplaceOverride.addTypeIdentifier(match);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treplaceOverride.setSource(extractSource(replacedMethodEle));\n\t\t\t\toverrides.addOverride(replaceOverride);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseSetElement(collectionEle,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a set element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collectionEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 1145
    },
    "return": "Set<Object>",
    "signature": "public Set<Object> parseSetElement(Element collectionEle, @Nullable BeanDefinition bd)",
    "source_code": "\tpublic Set<Object> parseSetElement(Element collectionEle, @Nullable BeanDefinition bd) {\n\t\tString defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\tNodeList nl = collectionEle.getChildNodes();\n\t\tManagedSet<Object> target = new ManagedSet<>(nl.getLength());\n\t\ttarget.setSource(extractSource(collectionEle));\n\t\ttarget.setElementTypeName(defaultElementType);\n\t\ttarget.setMergeEnabled(parseMergeAttribute(collectionEle));\n\t\tparseCollectionElements(nl, target, bd, defaultElementType);\n\t\treturn target;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseValueElement(ele,defaultTypeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a typed String value Object for the given value element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "defaultTypeName"
    ],
    "position": {
      "column": 1,
      "line": 1072
    },
    "return": "Object",
    "signature": "public Object parseValueElement(Element ele, @Nullable String defaultTypeName)",
    "source_code": "\tpublic Object parseValueElement(Element ele, @Nullable String defaultTypeName) {\n\t\t// It's a literal value.\n\t\tString value = DomUtils.getTextValue(ele);\n\t\tString specifiedTypeName = ele.getAttribute(TYPE_ATTRIBUTE);\n\t\tString typeName = specifiedTypeName;\n\t\tif (!StringUtils.hasText(typeName)) {\n\t\t\ttypeName = defaultTypeName;\n\t\t}\n\t\ttry {\n\t\t\tTypedStringValue typedValue = buildTypedStringValue(value, typeName);\n\t\t\ttypedValue.setSource(extractSource(ele));\n\t\t\ttypedValue.setSpecifiedTypeName(specifiedTypeName);\n\t\t\treturn typedValue;\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\terror(\"Type class [\" + typeName + \"] not found for <value> element\", ele, ex);\n\t\t\treturn value;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#populateDefaults(defaults,parentDefaults,root)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Populate the given DocumentDefaultsDefinition instance with the default lazy-init,\n\t * autowire, dependency check settings, init-method, destroy-method and merge settings.\n\t * Support nested 'beans' element use cases by falling back to {@code parentDefaults}\n\t * in case the defaults are not explicitly set locally.\n\t * @param defaults the defaults to populate\n\t * @param parentDefaults the parent BeanDefinitionParserDelegate (if any) defaults to fall back to\n\t * @param root the root element of the current bean definition document (or nested beans element)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "defaults",
      "parentDefaults",
      "root"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "void",
    "signature": "protected void populateDefaults(DocumentDefaultsDefinition defaults, @Nullable DocumentDefaultsDefinition parentDefaults, Element root)",
    "source_code": "\tprotected void populateDefaults(DocumentDefaultsDefinition defaults, @Nullable DocumentDefaultsDefinition parentDefaults, Element root) {\n\t\tString lazyInit = root.getAttribute(DEFAULT_LAZY_INIT_ATTRIBUTE);\n\t\tif (isDefaultValue(lazyInit)) {\n\t\t\t// Potentially inherited from outer <beans> sections, otherwise falling back to false.\n\t\t\tlazyInit = (parentDefaults != null ? parentDefaults.getLazyInit() : FALSE_VALUE);\n\t\t}\n\t\tdefaults.setLazyInit(lazyInit);\n\n\t\tString merge = root.getAttribute(DEFAULT_MERGE_ATTRIBUTE);\n\t\tif (isDefaultValue(merge)) {\n\t\t\t// Potentially inherited from outer <beans> sections, otherwise falling back to false.\n\t\t\tmerge = (parentDefaults != null ? parentDefaults.getMerge() : FALSE_VALUE);\n\t\t}\n\t\tdefaults.setMerge(merge);\n\n\t\tString autowire = root.getAttribute(DEFAULT_AUTOWIRE_ATTRIBUTE);\n\t\tif (isDefaultValue(autowire)) {\n\t\t\t// Potentially inherited from outer <beans> sections, otherwise falling back to 'no'.\n\t\t\tautowire = (parentDefaults != null ? parentDefaults.getAutowire() : AUTOWIRE_NO_VALUE);\n\t\t}\n\t\tdefaults.setAutowire(autowire);\n\n\t\tif (root.hasAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE)) {\n\t\t\tdefaults.setAutowireCandidates(root.getAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE));\n\t\t}\n\t\telse if (parentDefaults != null) {\n\t\t\tdefaults.setAutowireCandidates(parentDefaults.getAutowireCandidates());\n\t\t}\n\n\t\tif (root.hasAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE)) {\n\t\t\tdefaults.setInitMethod(root.getAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE));\n\t\t}\n\t\telse if (parentDefaults != null) {\n\t\t\tdefaults.setInitMethod(parentDefaults.getInitMethod());\n\t\t}\n\n\t\tif (root.hasAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE)) {\n\t\t\tdefaults.setDestroyMethod(root.getAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE));\n\t\t}\n\t\telse if (parentDefaults != null) {\n\t\t\tdefaults.setDestroyMethod(parentDefaults.getDestroyMethod());\n\t\t}\n\n\t\tdefaults.setSource(this.readerContext.extractSource(root));\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#processBeanDefinition(ele,delegate)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given bean element, parsing the bean definition\n\t * and registering it with the registry.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ele",
      "delegate"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "void",
    "signature": "protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate)",
    "source_code": "\tprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n\t\tBeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n\t\tif (bdHolder != null) {\n\t\t\tbdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n\t\t\ttry {\n\t\t\t\t// Register the final decorated instance.\n\t\t\t\tBeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n\t\t\t}\n\t\t\tcatch (BeanDefinitionStoreException ex) {\n\t\t\t\tgetReaderContext().error(\"Failed to register bean definition with name '\" +\n\t\t\t\t\t\tbdHolder.getBeanName() + \"'\", ele, ex);\n\t\t\t}\n\t\t\t// Send registration event.\n\t\t\tgetReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#registerBeanDefinitions(doc,readerContext)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation parses bean definitions according to the \"spring-beans\" XSD\n\t * (or DTD, historically).\n\t * <p>Opens a DOM Document; then initializes the default settings\n\t * specified at the {@code <beans/>} level; then parses the contained bean definitions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "doc",
      "readerContext"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext)",
    "source_code": "\tpublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n\t\tthis.readerContext = readerContext;\n\t\tdoRegisterBeanDefinitions(doc.getDocumentElement());\n\t}"
  },
  "org.springframework.beans.propertyeditors.<unknown>#createCollection(collectionType,initialCapacity)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a Collection of the given type, with the given\n\t * initial capacity (if supported by the Collection type).\n\t * @param collectionType a sub-interface of Collection\n\t * @param initialCapacity the initial capacity\n\t * @return the new Collection instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "collectionType",
      "initialCapacity"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Collection<Object>",
    "signature": "protected Collection<Object> createCollection(Class<? extends Collection> collectionType, int initialCapacity)",
    "source_code": "\tprotected Collection<Object> createCollection(Class<? extends Collection> collectionType, int initialCapacity) {\n\t\tif (!collectionType.isInterface()) {\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(collectionType).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Could not instantiate collection class: \" + collectionType.getName(), ex);\n\t\t\t}\n\t\t}\n\t\telse if (List.class == collectionType) {\n\t\t\treturn new ArrayList<>(initialCapacity);\n\t\t}\n\t\telse if (SortedSet.class == collectionType) {\n\t\t\treturn new TreeSet<>();\n\t\t}\n\t\telse {\n\t\t\treturn new LinkedHashSet<>(initialCapacity);\n\t\t}\n\t}"
  },
  "org.springframework.beans.propertyeditors.<unknown>#createMap(mapType,initialCapacity)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a Map of the given type, with the given\n\t * initial capacity (if supported by the Map type).\n\t * @param mapType a sub-interface of Map\n\t * @param initialCapacity the initial capacity\n\t * @return the new Map instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapType",
      "initialCapacity"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "Object>",
    "signature": "protected Object> createMap(Class<? extends Map> mapType, int initialCapacity)",
    "source_code": "\tprotected Map<Object, Object> createMap(Class<? extends Map> mapType, int initialCapacity) {\n\t\tif (!mapType.isInterface()) {\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(mapType).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Could not instantiate map class: \" + mapType.getName(), ex);\n\t\t\t}\n\t\t}\n\t\telse if (SortedMap.class == mapType) {\n\t\t\treturn new TreeMap<>();\n\t\t}\n\t\telse {\n\t\t\treturn new LinkedHashMap<>(initialCapacity);\n\t\t}\n\t}"
  },
  "org.springframework.beans.support.<unknown>#compare(o1,o2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o1",
      "o2"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "int",
    "signature": "public int compare(T o1, T o2)",
    "source_code": "\tpublic int compare(T o1, T o2) {\n\t\tObject v1 = getPropertyValue(o1);\n\t\tObject v2 = getPropertyValue(o2);\n\t\tif (this.sortDefinition.isIgnoreCase() && (v1 instanceof String text1) && (v2 instanceof String text2)) {\n\t\t\tv1 = text1.toLowerCase();\n\t\t\tv2 = text2.toLowerCase();\n\t\t}\n\n\t\tint result;\n\n\t\t// Put an object with null property at the end of the sort result.\n\t\ttry {\n\t\t\tif (v1 != null) {\n\t\t\t\tresult = (v2 != null ? ((Comparable<Object>) v1).compareTo(v2) : -1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = (v2 != null ? 1 : 0);\n\t\t\t}\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Could not sort objects [\" + o1 + \"] and [\" + o2 + \"]\", ex);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn (this.sortDefinition.isAscending() ? result : -result);\n\t}"
  },
  "org.springframework.beans.support.<unknown>#registerCustomEditor(requiredType,propertyEditor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given custom property editor for all properties of the given type.\n\t * <p>Typically used in conjunction with the default\n\t * {@link org.springframework.beans.SimpleTypeConverter}; will work with any\n\t * TypeConverter that implements the PropertyEditorRegistry interface as well.\n\t * @param requiredType type of the property\n\t * @param propertyEditor editor to register\n\t * @see #setTypeConverter\n\t * @see org.springframework.beans.PropertyEditorRegistry#registerCustomEditor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "propertyEditor"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor)",
    "source_code": "\tpublic void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor) {\n\t\tTypeConverter converter = getTypeConverter();\n\t\tif (!(converter instanceof PropertyEditorRegistry registry)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"TypeConverter does not implement PropertyEditorRegistry interface: \" + converter);\n\t\t}\n\t\tregistry.registerCustomEditor(requiredType, propertyEditor);\n\t}"
  },
  "org.springframework.beans.support.<unknown>#sort(source,sortDefinition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Sort the given source according to the given sort definition.\n\t * <p>Note: Contained objects have to provide the given property\n\t * in the form of a bean property, i.e. a getXXX method.\n\t * @param source input source\n\t * @param sortDefinition the parameters to sort by\n\t * @throws java.lang.IllegalArgumentException in case of a missing propertyName\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "sortDefinition"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void sort(Object[] source, SortDefinition sortDefinition)",
    "source_code": "\tpublic static void sort(Object[] source, SortDefinition sortDefinition) throws BeansException {\n\t\tif (StringUtils.hasText(sortDefinition.getProperty())) {\n\t\t\tArrays.sort(source, new PropertyComparator<>(sortDefinition));\n\t\t}\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#addCacheMethod(methodName,ops)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute for a cacheable method.\n\t * <p>Method names can be exact matches, or of the pattern \"xxx*\",\n\t * \"*xxx\" or \"*xxx*\" for matching multiple methods.\n\t * @param methodName the name of the method\n\t * @param ops operation associated with the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodName",
      "ops"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "public void addCacheMethod(String methodName, Collection<CacheOperation> ops)",
    "source_code": "\tpublic void addCacheMethod(String methodName, Collection<CacheOperation> ops) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Adding method [\" + methodName + \"] with cache operations [\" + ops + \"]\");\n\t\t}\n\t\tthis.nameMap.put(methodName, ops);\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#configure(errorHandler,keyGenerator,cacheResolver,cacheManager)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure this aspect with the given error handler, key generator and cache resolver/manager\n\t * suppliers, applying the corresponding default if a supplier is not resolvable.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorHandler",
      "keyGenerator",
      "cacheResolver",
      "cacheManager"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void configure(@Nullable Supplier<CacheErrorHandler> errorHandler, @Nullable Supplier<KeyGenerator> keyGenerator,\n\t\t\t@Nullable Supplier<CacheResolver> cacheResolver, @Nullable Supplier<CacheManager> cacheManager)",
    "source_code": "\tpublic void configure(\n\t\t\t@Nullable Supplier<CacheErrorHandler> errorHandler, @Nullable Supplier<KeyGenerator> keyGenerator,\n\t\t\t@Nullable Supplier<CacheResolver> cacheResolver, @Nullable Supplier<CacheManager> cacheManager) {\n\n\t\tthis.errorHandler = new SingletonSupplier<>(errorHandler, SimpleCacheErrorHandler::new);\n\t\tthis.keyGenerator = new SingletonSupplier<>(keyGenerator, SimpleKeyGenerator::new);\n\t\tthis.cacheResolver = new SingletonSupplier<>(cacheResolver,\n\t\t\t\t() -> SimpleCacheResolver.of(SupplierUtils.resolve(cacheManager)));\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#execute(invoker,target,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "target",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "Object",
    "signature": "protected Object execute(CacheOperationInvoker invoker, Object target, Method method, Object[] args)",
    "source_code": "\tprotected Object execute(CacheOperationInvoker invoker, Object target, Method method, Object[] args) {\n\t\t// Check whether aspect is enabled (to cope with cases where the AJ is pulled in automatically)\n\t\tif (this.initialized) {\n\t\t\tClass<?> targetClass = getTargetClass(target);\n\t\t\tCacheOperationSource cacheOperationSource = getCacheOperationSource();\n\t\t\tif (cacheOperationSource != null) {\n\t\t\t\tCollection<CacheOperation> operations = cacheOperationSource.getCacheOperations(method, targetClass);\n\t\t\t\tif (!CollectionUtils.isEmpty(operations)) {\n\t\t\t\t\treturn execute(invoker, method,\n\t\t\t\t\t\t\tnew CacheOperationContexts(operations, method, args, target, targetClass));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn invoker.invoke();\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#getBean(beanName,expectedType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a bean with the specified name and type. Used to resolve services that\n\t * are referenced by name in a {@link CacheOperation}.\n\t * @param beanName the name of the bean, as defined by the operation\n\t * @param expectedType type for the bean\n\t * @return the bean matching that name\n\t * @throws org.springframework.beans.factory.NoSuchBeanDefinitionException if such bean does not exist\n\t * @see CacheOperation#getKeyGenerator()\n\t * @see CacheOperation#getCacheManager()\n\t * @see CacheOperation#getCacheResolver()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "expectedType"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "T",
    "signature": "protected T getBean(String beanName, Class<T> expectedType)",
    "source_code": "\tprotected <T> T getBean(String beanName, Class<T> expectedType) {\n\t\tif (this.beanFactory == null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"BeanFactory must be set on cache aspect for \" + expectedType.getSimpleName() + \" retrieval\");\n\t\t}\n\t\treturn BeanFactoryAnnotationUtils.qualifiedBeanOfType(this.beanFactory, expectedType, beanName);\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#getCacheOperationMetadata(operation,method,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link CacheOperationMetadata} for the specified operation.\n\t * <p>Resolve the {@link CacheResolver} and the {@link KeyGenerator} to be\n\t * used for the operation.\n\t * @param operation the operation\n\t * @param method the method on which the operation is invoked\n\t * @param targetClass the target type\n\t * @return the resolved metadata for the operation\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "operation",
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "CacheOperationMetadata",
    "signature": "protected CacheOperationMetadata getCacheOperationMetadata(CacheOperation operation, Method method, Class<?> targetClass)",
    "source_code": "\tprotected CacheOperationMetadata getCacheOperationMetadata(\n\t\t\tCacheOperation operation, Method method, Class<?> targetClass) {\n\n\t\tCacheOperationCacheKey cacheKey = new CacheOperationCacheKey(operation, method, targetClass);\n\t\tCacheOperationMetadata metadata = this.metadataCache.get(cacheKey);\n\t\tif (metadata == null) {\n\t\t\tKeyGenerator operationKeyGenerator;\n\t\t\tif (StringUtils.hasText(operation.getKeyGenerator())) {\n\t\t\t\toperationKeyGenerator = getBean(operation.getKeyGenerator(), KeyGenerator.class);\n\t\t\t}\n\t\t\telse {\n\t\t\t\toperationKeyGenerator = getKeyGenerator();\n\t\t\t}\n\t\t\tCacheResolver operationCacheResolver;\n\t\t\tif (StringUtils.hasText(operation.getCacheResolver())) {\n\t\t\t\toperationCacheResolver = getBean(operation.getCacheResolver(), CacheResolver.class);\n\t\t\t}\n\t\t\telse if (StringUtils.hasText(operation.getCacheManager())) {\n\t\t\t\tCacheManager cacheManager = getBean(operation.getCacheManager(), CacheManager.class);\n\t\t\t\toperationCacheResolver = new SimpleCacheResolver(cacheManager);\n\t\t\t}\n\t\t\telse {\n\t\t\t\toperationCacheResolver = getCacheResolver();\n\t\t\t\tAssert.state(operationCacheResolver != null, \"No CacheResolver/CacheManager set\");\n\t\t\t}\n\t\t\tmetadata = new CacheOperationMetadata(operation, method, targetClass,\n\t\t\t\t\toperationKeyGenerator, operationCacheResolver);\n\t\t\tthis.metadataCache.put(cacheKey, metadata);\n\t\t}\n\t\treturn metadata;\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#getCacheOperations(method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "Collection<CacheOperation>",
    "signature": "public Collection<CacheOperation> getCacheOperations(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic Collection<CacheOperation> getCacheOperations(Method method, @Nullable Class<?> targetClass) {\n\t\t// look for direct name match\n\t\tString methodName = method.getName();\n\t\tCollection<CacheOperation> ops = this.nameMap.get(methodName);\n\n\t\tif (ops == null) {\n\t\t\t// Look for most specific name match.\n\t\t\tString bestNameMatch = null;\n\t\t\tfor (String mappedName : this.nameMap.keySet()) {\n\t\t\t\tif (isMatch(methodName, mappedName)\n\t\t\t\t\t\t&& (bestNameMatch == null || bestNameMatch.length() <= mappedName.length())) {\n\t\t\t\t\tops = this.nameMap.get(mappedName);\n\t\t\t\t\tbestNameMatch = mappedName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ops;\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#getOperationContext(operation,method,args,target,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "operation",
      "method",
      "args",
      "target",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "CacheOperationContext",
    "signature": "protected CacheOperationContext getOperationContext(CacheOperation operation, Method method, Object[] args, Object target, Class<?> targetClass)",
    "source_code": "\tprotected CacheOperationContext getOperationContext(\n\t\t\tCacheOperation operation, Method method, Object[] args, Object target, Class<?> targetClass) {\n\n\t\tCacheOperationMetadata metadata = getCacheOperationMetadata(operation, method, targetClass);\n\t\treturn new CacheOperationContext(metadata, args, target);\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#isMatch(methodName,mappedName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return if the given method name matches the mapped name.\n\t * <p>The default implementation checks for \"xxx*\", \"*xxx\" and \"*xxx*\" matches,\n\t * as well as direct equality. Can be overridden in subclasses.\n\t * @param methodName the method name of the class\n\t * @param mappedName the name in the descriptor\n\t * @return if the names match\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "mappedName"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "boolean",
    "signature": "protected boolean isMatch(String methodName, String mappedName)",
    "source_code": "\tprotected boolean isMatch(String methodName, String mappedName) {\n\t\treturn PatternMatchUtils.simpleMatch(mappedName, methodName);\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#matches(method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\tCacheOperationSource cas = getCacheOperationSource();\n\t\treturn (cas != null && !CollectionUtils.isEmpty(cas.getCacheOperations(method, targetClass)));\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#methodIdentification(method,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method to return a String representation of this Method\n\t * for use in logging. Can be overridden in subclasses to provide a\n\t * different identifier for the given method.\n\t * @param method the method we're interested in\n\t * @param targetClass class the method is on\n\t * @return log message identifying this method\n\t * @see org.springframework.util.ClassUtils#getQualifiedMethodName\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "String",
    "signature": "protected String methodIdentification(Method method, Class<?> targetClass)",
    "source_code": "\tprotected String methodIdentification(Method method, Class<?> targetClass) {\n\t\tMethod specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);\n\t\treturn ClassUtils.getQualifiedMethodName(specificMethod);\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#setNameMap(Map<String,nameMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a name/attribute map, consisting of method names\n\t * (e.g. \"myMethod\") and CacheOperation instances\n\t * (or Strings to be converted to CacheOperation instances).\n\t * @see CacheOperation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "nameMap"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "public void setNameMap(Map<String, Collection<CacheOperation>> nameMap)",
    "source_code": "\tpublic void setNameMap(Map<String, Collection<CacheOperation>> nameMap) {\n\t\tnameMap.forEach(this::addCacheMethod);\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#matches(method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\tJCacheOperationSource cas = getCacheOperationSource();\n\t\treturn (cas != null && cas.getCacheOperation(method, targetClass) != null);\n\t}"
  },
  "org.springframework.cglib.beans.<unknown>#newInstance(type,require)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "require"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "Object",
    "signature": "public Object newInstance(Class type, int require)",
    "source_code": "            public Object newInstance(Class type, int require);"
  },
  "org.springframework.cglib.beans.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "Object",
    "signature": "public Object put(Object key, Object value)",
    "source_code": "\tpublic Object put(Object key, Object value) {\n        return put(bean, key, value);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#addAllInterfaces(type,list)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "list"
    ],
    "position": {
      "column": 1,
      "line": 410
    },
    "return": "List",
    "signature": "public List addAllInterfaces(Class type, List list)",
    "source_code": "\tpublic static List addAllInterfaces(Class type, List list) {\n\t\tClass superclass = type.getSuperclass();\n\t\tif (superclass != null) {\n\t\t\tlist.addAll(Arrays.asList(type.getInterfaces()));\n\t\t\taddAllInterfaces(superclass, list);\n\t\t}\n\t\treturn list;\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#addAllMethods(type,list)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "list"
    ],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "List",
    "signature": "public List addAllMethods(final Class type, final List list)",
    "source_code": "\tpublic static List addAllMethods(final Class type, final List list) {\n\t\tif (type == Object.class) {\n\t\t\tlist.addAll(OBJECT_METHODS);\n\t\t}\n\t\telse {\n\t\t\tlist.addAll(java.util.Arrays.asList(type.getDeclaredMethods()));\n\t\t}\n\n\t\tClass superclass = type.getSuperclass();\n\t\tif (superclass != null) {\n\t\t\taddAllMethods(superclass, list);\n\t\t}\n\t\tClass[] interfaces = type.getInterfaces();\n\t\tfor (Class element : interfaces) {\n\t\t\taddAllMethods(element, list);\n\t\t}\n\n\t\treturn list;\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#begin_class(version,access,className,superType,interfaces,source)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "version",
      "access",
      "className",
      "superType",
      "interfaces",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void begin_class(int version, final int access, String className, final Type superType, final Type[] interfaces, String source)",
    "source_code": "    public void begin_class(int version, final int access, String className, final Type superType, final Type[] interfaces, String source) {\n        final Type classType = Type.getType(\"L\" + className.replace('.', '/') + \";\");\n        classInfo = new ClassInfo() {\n            @Override\n\t\t\tpublic Type getType() {\n                return classType;\n            }\n            @Override\n\t\t\tpublic Type getSuperType() {\n                return (superType != null) ? superType : Constants.TYPE_OBJECT;\n            }\n            @Override\n\t\t\tpublic Type[] getInterfaces() {\n                return interfaces;\n            }\n            @Override\n\t\t\tpublic int getModifiers() {\n                return access;\n            }\n        };\n        cv.visit(version,\n                 access,\n                 classInfo.getType().getInternalName(),\n                 null,\n                 classInfo.getSuperType().getInternalName(),\n                 TypeUtils.toInternalNames(interfaces));\n        if (source != null) {\n\t\t\tcv.visitSource(source, null);\n\t\t}\n        init();\n    }"
  },
  "org.springframework.cglib.core.<unknown>#begin_method(access,sig,exceptions)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "access",
      "sig",
      "exceptions"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "CodeEmitter",
    "signature": "public CodeEmitter begin_method(int access, Signature sig, Type[] exceptions)",
    "source_code": "    public CodeEmitter begin_method(int access, Signature sig, Type[] exceptions) {\n        if (classInfo == null) {\n\t\t\tthrow new IllegalStateException(\"classInfo is null! \" + this);\n\t\t}\n        MethodVisitor v = cv.visitMethod(access,\n                                         sig.getName(),\n                                         sig.getDescriptor(),\n                                         null,\n                                         TypeUtils.toInternalNames(exceptions));\n        if (sig.equals(Constants.SIG_STATIC) && !TypeUtils.isInterface(getAccess())) {\n            rawStaticInit = v;\n            MethodVisitor wrapped = new MethodVisitor(Constants.ASM_API, v) {\n                @Override\n\t\t\t\tpublic void visitMaxs(int maxStack, int maxLocals) {\n                    // ignore\n                }\n                @Override\n\t\t\t\tpublic void visitInsn(int insn) {\n                    if (insn != Constants.RETURN) {\n                        super.visitInsn(insn);\n                    }\n                }\n            };\n            staticInit = new CodeEmitter(this, wrapped, access, sig, exceptions);\n            if (staticHook == null) {\n                // force static hook creation\n                getStaticHook();\n            } else {\n                staticInit.invoke_static_this(staticHookSig);\n            }\n            return staticInit;\n        } else if (sig.equals(staticHookSig)) {\n            return new CodeEmitter(this, v, access, sig, exceptions) {\n                @Override\n\t\t\t\tpublic boolean isStaticHook() {\n                    return true;\n                }\n            };\n        } else {\n            return new CodeEmitter(this, v, access, sig, exceptions);\n        }\n    }"
  },
  "org.springframework.cglib.core.<unknown>#declare_field(access,name,type,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "access",
      "name",
      "type",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "public void declare_field(int access, String name, Type type, Object value)",
    "source_code": "    public void declare_field(int access, String name, Type type, Object value) {\n        FieldInfo existing = (FieldInfo)fieldInfo.get(name);\n        FieldInfo info = new FieldInfo(access, name, type, value);\n        if (existing != null) {\n            if (!info.equals(existing)) {\n                throw new IllegalArgumentException(\"Field \\\"\" + name + \"\\\" has been declared differently\");\n            }\n        } else {\n            fieldInfo.put(name, info);\n            cv.visitField(access, name, type.getDescriptor(), null, value);\n        }\n    }"
  },
  "org.springframework.cglib.core.<unknown>#defineClass(className,b,loader)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "className",
      "b",
      "loader"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "Class",
    "signature": "public Class defineClass(String className, byte[] b, ClassLoader loader)",
    "source_code": "\tpublic static Class defineClass(String className, byte[] b, ClassLoader loader) throws Exception {\n\t\treturn defineClass(className, b, loader, null, null);\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#defineClass(className,b,loader,protectionDomain)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "className",
      "b",
      "loader",
      "protectionDomain"
    ],
    "position": {
      "column": 1,
      "line": 440
    },
    "return": "Class",
    "signature": "public Class defineClass(String className, byte[] b, ClassLoader loader,\n\t\t\tProtectionDomain protectionDomain)",
    "source_code": "\tpublic static Class defineClass(String className, byte[] b, ClassLoader loader,\n\t\t\tProtectionDomain protectionDomain) throws Exception {\n\n\t\treturn defineClass(className, b, loader, protectionDomain, null);\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#defineClass(className,b,loader,protectionDomain,contextClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "className",
      "b",
      "loader",
      "protectionDomain",
      "contextClass"
    ],
    "position": {
      "column": 1,
      "line": 447
    },
    "return": "Class",
    "signature": "public Class defineClass(String className, byte[] b, ClassLoader loader,\n\t\t\tProtectionDomain protectionDomain, Class<?> contextClass)",
    "source_code": "\tpublic static Class defineClass(String className, byte[] b, ClassLoader loader,\n\t\t\tProtectionDomain protectionDomain, Class<?> contextClass) throws Exception {\n\n\t\tClass c = null;\n\t\tThrowable t = THROWABLE;\n\n\t\tBiConsumer<String, byte[]> handlerToUse = generatedClassHandler;\n\t\tif (handlerToUse != null) {\n\t\t\thandlerToUse.accept(className, b);\n\t\t}\n\n\t\t// Preferred option: JDK 9+ Lookup.defineClass API if ClassLoader matches\n\t\tif (contextClass != null && contextClass.getClassLoader() == loader) {\n\t\t\ttry {\n\t\t\t\tMethodHandles.Lookup lookup = MethodHandles.privateLookupIn(contextClass, MethodHandles.lookup());\n\t\t\t\tc = lookup.defineClass(b);\n\t\t\t}\n\t\t\tcatch (LinkageError | IllegalArgumentException ex) {\n\t\t\t\t// in case of plain LinkageError (class already defined)\n\t\t\t\t// or IllegalArgumentException (class in different package):\n\t\t\t\t// fall through to traditional ClassLoader.defineClass below\n\t\t\t\tt = ex;\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new CodeGenerationException(ex);\n\t\t\t}\n\t\t}\n\n\t\t// Direct defineClass attempt on the target Classloader\n\t\tif (c == null) {\n\t\t\tif (protectionDomain == null) {\n\t\t\t\tprotectionDomain = PROTECTION_DOMAIN;\n\t\t\t}\n\n\t\t\t// Look for publicDefineClass(String name, byte[] b, ProtectionDomain protectionDomain)\n\t\t\ttry {\n\t\t\t\tMethod publicDefineClass = loader.getClass().getMethod(\n\t\t\t\t\t\t\"publicDefineClass\", String.class, byte[].class, ProtectionDomain.class);\n\t\t\t\tc = (Class) publicDefineClass.invoke(loader, className, b, protectionDomain);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tif (!(ex.getTargetException() instanceof UnsupportedOperationException)) {\n\t\t\t\t\tthrow new CodeGenerationException(ex.getTargetException());\n\t\t\t\t}\n\t\t\t\t// in case of UnsupportedOperationException, fall through\n\t\t\t\tt = ex.getTargetException();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// publicDefineClass method not available -> fall through\n\t\t\t\tt = ex;\n\t\t\t}\n\n\t\t\t// Classic option: protected ClassLoader.defineClass method\n\t\t\tif (c == null && classLoaderDefineClassMethod != null) {\n\t\t\t\tObject[] args = new Object[]{className, b, 0, b.length, protectionDomain};\n\t\t\t\ttry {\n\t\t\t\t\tif (!classLoaderDefineClassMethod.isAccessible()) {\n\t\t\t\t\t\tclassLoaderDefineClassMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t\tc = (Class) classLoaderDefineClassMethod.invoke(loader, args);\n\t\t\t\t}\n\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\tthrow new CodeGenerationException(ex.getTargetException());\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t// Fall through if setAccessible fails with InaccessibleObjectException on JDK 9+\n\t\t\t\t\t// (on the module path and/or with a JVM bootstrapped with --illegal-access=deny)\n\t\t\t\t\tif (!ex.getClass().getName().endsWith(\"InaccessibleObjectException\")) {\n\t\t\t\t\t\tthrow new CodeGenerationException(ex);\n\t\t\t\t\t}\n\t\t\t\t\tt = ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Fallback option: JDK 9+ Lookup.defineClass API even if ClassLoader does not match\n\t\tif (c == null && contextClass != null && contextClass.getClassLoader() != loader) {\n\t\t\ttry {\n\t\t\t\tMethodHandles.Lookup lookup = MethodHandles.privateLookupIn(contextClass, MethodHandles.lookup());\n\t\t\t\tc = lookup.defineClass(b);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new CodeGenerationException(ex) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String getMessage() {\n\t\t\t\t\t\treturn \"ClassLoader mismatch for [\" + contextClass.getName() +\n\t\t\t\t\t\t\t\t\"]: JVM should be started with --add-opens=java.base/java.lang=ALL-UNNAMED \" +\n\t\t\t\t\t\t\t\t\"for ClassLoader.defineClass to be accessible on \" + loader.getClass().getName();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new CodeGenerationException(ex);\n\t\t\t}\n\t\t}\n\n\t\t// No defineClass variant available at all?\n\t\tif (c == null) {\n\t\t\tthrow new CodeGenerationException(t);\n\t\t}\n\n\t\t// Force static initializers to run.\n\t\tClass.forName(className, true, loader);\n\t\treturn c;\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#findConstructor(desc,loader)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "desc",
      "loader"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "Constructor",
    "signature": "public Constructor findConstructor(String desc, ClassLoader loader)",
    "source_code": "\tpublic static Constructor findConstructor(String desc, ClassLoader loader) {\n\t\ttry {\n\t\t\tint lparen = desc.indexOf('(');\n\t\t\tString className = desc.substring(0, lparen).trim();\n\t\t\treturn getClass(className, loader).getConstructor(parseTypes(desc, loader));\n\t\t}\n\t\tcatch (ClassNotFoundException | NoSuchMethodException ex) {\n\t\t\tthrow new CodeGenerationException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#findDeclaredMethod(type,methodName,parameterTypes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "methodName",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 374
    },
    "return": "Method",
    "signature": "public Method findDeclaredMethod(final Class type,\n\t\t\tfinal String methodName, final Class[] parameterTypes)",
    "source_code": "\tpublic static Method findDeclaredMethod(final Class type,\n\t\t\tfinal String methodName, final Class[] parameterTypes)\n\t\t\tthrows NoSuchMethodException {\n\n\t\tClass cl = type;\n\t\twhile (cl != null) {\n\t\t\ttry {\n\t\t\t\treturn cl.getDeclaredMethod(methodName, parameterTypes);\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException e) {\n\t\t\t\tcl = cl.getSuperclass();\n\t\t\t}\n\t\t}\n\t\tthrow new NoSuchMethodException(methodName);\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#findMethod(desc,loader)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "desc",
      "loader"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "Method",
    "signature": "public Method findMethod(String desc, ClassLoader loader)",
    "source_code": "\tpublic static Method findMethod(String desc, ClassLoader loader) {\n\t\ttry {\n\t\t\tint lparen = desc.indexOf('(');\n\t\t\tint dot = desc.lastIndexOf('.', lparen);\n\t\t\tString className = desc.substring(0, dot).trim();\n\t\t\tString methodName = desc.substring(dot + 1, lparen).trim();\n\t\t\treturn getClass(className, loader).getDeclaredMethod(methodName, parseTypes(desc, loader));\n\t\t}\n\t\tcatch (ClassNotFoundException | NoSuchMethodException ex) {\n\t\t\tthrow new CodeGenerationException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#findMethods(namesAndDescriptors,methods)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "namesAndDescriptors",
      "methods"
    ],
    "position": {
      "column": 1,
      "line": 636
    },
    "return": "Method[]",
    "signature": "public Method[] findMethods(String[] namesAndDescriptors, Method[] methods)",
    "source_code": "\tpublic static Method[] findMethods(String[] namesAndDescriptors, Method[] methods) {\n\t\tMap map = new HashMap();\n\t\tfor (Method method : methods) {\n\t\t\tmap.put(method.getName() + Type.getMethodDescriptor(method), method);\n\t\t}\n\t\tMethod[] result = new Method[namesAndDescriptors.length / 2];\n\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\tresult[i] = (Method) map.get(namesAndDescriptors[i * 2] + namesAndDescriptors[i * 2 + 1]);\n\t\t\tif (result[i] == null) {\n\t\t\t\t// TODO: error?\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#get(gen,useCache)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "gen",
      "useCache"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "Object",
    "signature": "public Object get(AbstractClassGenerator gen, boolean useCache)",
    "source_code": "\t\tpublic Object get(AbstractClassGenerator gen, boolean useCache) {\n\t\t\tif (!useCache) {\n\t\t\t\treturn gen.generate(ClassLoaderData.this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject cachedValue = generatedClasses.get(gen);\n\t\t\t\treturn gen.unwrapCachedValue(cachedValue);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.cglib.core.<unknown>#getClassName(prefix,source,key,names)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "prefix",
      "source",
      "key",
      "names"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "return": "String",
    "signature": "public String getClassName(String prefix, String source, Object key, Predicate names)",
    "source_code": "    public String getClassName(String prefix, String source, Object key, Predicate names) {\n        if (prefix == null) {\n            prefix = \"org.springframework.cglib.empty.Object\";\n        } else if (prefix.startsWith(\"java\")) {\n            prefix = \"$\" + prefix;\n        }\n        String base =\n            prefix + \"$$\" +\n            source.substring(source.lastIndexOf('.') + 1) +\n            getTag() + \"$$\" +\n            Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode());\n        String attempt = base;\n        int index = 2;\n        while (names.evaluate(attempt)) {\n\t\t\tattempt = base + \"_\" + index++;\n\t\t}\n        return attempt;\n    }"
  },
  "org.springframework.cglib.core.<unknown>#getConstructor(type,parameterTypes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "Constructor",
    "signature": "public Constructor getConstructor(Class type, Class[] parameterTypes)",
    "source_code": "\tpublic static Constructor getConstructor(Class type, Class[] parameterTypes) {\n\t\ttry {\n\t\t\tConstructor constructor = type.getDeclaredConstructor(parameterTypes);\n\t\t\tconstructor.setAccessible(true);\n\t\t\treturn constructor;\n\t\t}\n\t\tcatch (NoSuchMethodException e) {\n\t\t\tthrow new CodeGenerationException(e);\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#getMethodInfo(member,modifiers)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "member",
      "modifiers"
    ],
    "position": {
      "column": 1,
      "line": 578
    },
    "return": "MethodInfo",
    "signature": "public MethodInfo getMethodInfo(final Member member, final int modifiers)",
    "source_code": "\tpublic static MethodInfo getMethodInfo(final Member member, final int modifiers) {\n\t\tfinal Signature sig = getSignature(member);\n\t\treturn new MethodInfo() {\n\t\t\tprivate ClassInfo ci;\n\n\t\t\t@Override\n\t\t\tpublic ClassInfo getClassInfo() {\n\t\t\t\tif (ci == null) {\n\t\t\t\t\tci = ReflectUtils.getClassInfo(member.getDeclaringClass());\n\t\t\t\t}\n\t\t\t\treturn ci;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int getModifiers() {\n\t\t\t\treturn modifiers;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Signature getSignature() {\n\t\t\t\treturn sig;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Type[] getExceptionTypes() {\n\t\t\t\treturn ReflectUtils.getExceptionTypes(member);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#getPropertyMethods(properties,read,write)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "properties",
      "read",
      "write"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "Method[]",
    "signature": "public Method[] getPropertyMethods(PropertyDescriptor[] properties, boolean read, boolean write)",
    "source_code": "\tpublic static Method[] getPropertyMethods(PropertyDescriptor[] properties, boolean read, boolean write) {\n\t\tSet methods = new HashSet();\n\t\tfor (PropertyDescriptor pd : properties) {\n\t\t\tif (read) {\n\t\t\t\tmethods.add(pd.getReadMethod());\n\t\t\t}\n\t\t\tif (write) {\n\t\t\t\tmethods.add(pd.getWriteMethod());\n\t\t\t}\n\t\t}\n\t\tmethods.remove(null);\n\t\treturn (Method[]) methods.toArray(new Method[methods.size()]);\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#newInstance(cstruct,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cstruct",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "Object",
    "signature": "public Object newInstance(final Constructor cstruct, final Object[] args)",
    "source_code": "\tpublic static Object newInstance(final Constructor cstruct, final Object[] args) {\n\t\tboolean flag = cstruct.isAccessible();\n\t\ttry {\n\t\t\tif (!flag) {\n\t\t\t\tcstruct.setAccessible(true);\n\t\t\t}\n\t\t\tObject result = cstruct.newInstance(args);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (InstantiationException | IllegalAccessException e) {\n\t\t\tthrow new CodeGenerationException(e);\n\t\t}\n\t\tcatch (InvocationTargetException e) {\n\t\t\tthrow new CodeGenerationException(e.getTargetException());\n\t\t}\n\t\tfinally {\n\t\t\tif (!flag) {\n\t\t\t\tcstruct.setAccessible(flag);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#newInstance(type,parameterTypes,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "parameterTypes",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "Object",
    "signature": "public Object newInstance(Class type, Class[] parameterTypes, Object[] args)",
    "source_code": "\tpublic static Object newInstance(Class type, Class[] parameterTypes, Object[] args) {\n\t\treturn newInstance(getConstructor(type, parameterTypes), args);\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#setGeneratedClassHandler(BiConsumer<String,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiConsumer<String",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "void",
    "signature": "public void setGeneratedClassHandler(BiConsumer<String, byte[]> handler)",
    "source_code": "\tpublic static void setGeneratedClassHandler(BiConsumer<String, byte[]> handler) {\n\t\tgeneratedClassHandler = handler;\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#visit(version,access,name,signature,superName,interfaces)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "version",
      "access",
      "name",
      "signature",
      "superName",
      "interfaces"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "void",
    "signature": "public void visit(int version,\n                      int access,\n                      String name,\n                      String signature,\n                      String superName,\n                      String[] interfaces)",
    "source_code": "\tpublic void visit(int version,\n                      int access,\n                      String name,\n                      String signature,\n                      String superName,\n                      String[] interfaces) {\n        begin_class(version,\n                    access,\n                    name.replace('/', '.'),\n                    TypeUtils.fromInternalName(superName),\n                    TypeUtils.fromInternalNames(interfaces),\n                    null); // TODO\n    }"
  },
  "org.springframework.cglib.core.<unknown>#visitField(access,name,desc,signature,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "access",
      "name",
      "desc",
      "signature",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "FieldVisitor",
    "signature": "public FieldVisitor visitField(int access,\n                                   String name,\n                                   String desc,\n                                   String signature,\n                                   Object value)",
    "source_code": "\tpublic FieldVisitor visitField(int access,\n                                   String name,\n                                   String desc,\n                                   String signature,\n                                   Object value) {\n        declare_field(access, name, Type.getType(desc), value);\n        return null; // TODO\n    }"
  },
  "org.springframework.cglib.core.<unknown>#visitIincInsn(var,increment)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "var",
      "increment"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "void",
    "signature": "public void visitIincInsn(final int var, final int increment)",
    "source_code": "\tpublic void visitIincInsn(final int var, final int increment) {\n        mv.visitIincInsn(remap(var, 1), increment);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#visitLocalVariable(name,desc,signature,start,end,index)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "desc",
      "signature",
      "start",
      "end",
      "index"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void visitLocalVariable(final String name,\n        final String desc,\n        final String signature,\n        final Label start,\n        final Label end,\n        final int index)",
    "source_code": "\tpublic void visitLocalVariable(\n        final String name,\n        final String desc,\n        final String signature,\n        final Label start,\n        final Label end,\n        final int index)\n    {\n        mv.visitLocalVariable(name, desc, signature, start, end, remap(index));\n    }"
  },
  "org.springframework.cglib.core.<unknown>#visitMaxs(maxStack,maxLocals)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "maxStack",
      "maxLocals"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "public void visitMaxs(final int maxStack, final int maxLocals)",
    "source_code": "\tpublic void visitMaxs(final int maxStack, final int maxLocals) {\n        mv.visitMaxs(maxStack, state.nextLocal);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#visitMethod(access,name,desc,signature,exceptions)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "access",
      "name",
      "desc",
      "signature",
      "exceptions"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "MethodVisitor",
    "signature": "public MethodVisitor visitMethod(int access,\n                                     String name,\n                                     String desc,\n                                     String signature,\n                                     String[] exceptions)",
    "source_code": "\tpublic MethodVisitor visitMethod(int access,\n                                     String name,\n                                     String desc,\n                                     String signature,\n                                     String[] exceptions) {\n        return begin_method(access,\n                            new Signature(name, desc),\n                            TypeUtils.fromInternalNames(exceptions));\n    }"
  },
  "org.springframework.cglib.core.<unknown>#visitVarInsn(opcode,var)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "opcode",
      "var"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void visitVarInsn(final int opcode, final int var)",
    "source_code": "\tpublic void visitVarInsn(final int opcode, final int var) {\n        int size = switch (opcode) {\n\t\t\tcase Opcodes.LLOAD, Opcodes.LSTORE, Opcodes.DLOAD, Opcodes.DSTORE -> 2;\n\t\t\tdefault -> 1;\n\t\t};\n        mv.visitVarInsn(opcode, remap(var, size));\n    }"
  },
  "org.springframework.context.annotation.<unknown>#applyTo(generationContext,beanFactoryInitializationCode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanFactoryInitializationCode"
    ],
    "position": {
      "column": 1,
      "line": 652
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext, BeanFactoryInitializationCode beanFactoryInitializationCode)",
    "source_code": "\t\tpublic void applyTo(GenerationContext generationContext, BeanFactoryInitializationCode beanFactoryInitializationCode) {\n\t\t\tGeneratedMethod generatedMethod = beanFactoryInitializationCode\n\t\t\t\t\t.getMethods()\n\t\t\t\t\t.add(\"processPropertySources\", this::generateAddPropertySourceProcessorMethod);\n\t\t\tbeanFactoryInitializationCode\n\t\t\t\t\t.addInitializer(generatedMethod.toMethodReference());\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#autowireResource(factory,element,requestingBeanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a resource object for the given name and type through autowiring\n\t * based on the given factory.\n\t * @param factory the factory to autowire against\n\t * @param element the descriptor for the annotated field/method\n\t * @param requestingBeanName the name of the requesting bean\n\t * @return the resource object (never {@code null})\n\t * @throws NoSuchBeanDefinitionException if no corresponding target resource found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "factory",
      "element",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 479
    },
    "return": "Object",
    "signature": "protected Object autowireResource(BeanFactory factory, LookupElement element, @Nullable String requestingBeanName)",
    "source_code": "\tprotected Object autowireResource(BeanFactory factory, LookupElement element, @Nullable String requestingBeanName)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tObject resource;\n\t\tSet<String> autowiredBeanNames;\n\t\tString name = element.name;\n\n\t\tif (factory instanceof AutowireCapableBeanFactory autowireCapableBeanFactory) {\n\t\t\tDependencyDescriptor descriptor = element.getDependencyDescriptor();\n\t\t\tif (this.fallbackToDefaultTypeMatch && element.isDefaultName && !factory.containsBean(name)) {\n\t\t\t\tautowiredBeanNames = new LinkedHashSet<>();\n\t\t\t\tresource = autowireCapableBeanFactory.resolveDependency(descriptor, requestingBeanName, autowiredBeanNames, null);\n\t\t\t\tif (resource == null) {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(element.getLookupType(), \"No resolvable resource object\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresource = autowireCapableBeanFactory.resolveBeanByName(name, descriptor);\n\t\t\t\tautowiredBeanNames = Collections.singleton(name);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tresource = factory.getBean(name, element.lookupType);\n\t\t\tautowiredBeanNames = Collections.singleton(name);\n\t\t}\n\n\t\tif (factory instanceof ConfigurableBeanFactory configurableBeanFactory) {\n\t\t\tfor (String autowiredBeanName : autowiredBeanNames) {\n\t\t\t\tif (requestingBeanName != null && configurableBeanFactory.containsBean(autowiredBeanName)) {\n\t\t\t\t\tconfigurableBeanFactory.registerDependentBean(autowiredBeanName, requestingBeanName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn resource;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#buildDefaultBeanName(definition,registry)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Derive a default bean name from the given bean definition.\n\t * <p>The default implementation delegates to {@link #buildDefaultBeanName(BeanDefinition)}.\n\t * @param definition the bean definition to build a bean name for\n\t * @param registry the registry that the given bean definition is being registered with\n\t * @return the default bean name (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "definition",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "String",
    "signature": "protected String buildDefaultBeanName(BeanDefinition definition, BeanDefinitionRegistry registry)",
    "source_code": "\tprotected String buildDefaultBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) {\n\t\treturn buildDefaultBeanName(definition);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#buildLazyResourceProxy(element,requestingBeanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a lazily resolving resource proxy for the given name and type,\n\t * delegating to {@link #getResource} on demand once a method call comes in.\n\t * @param element the descriptor for the annotated field/method\n\t * @param requestingBeanName the name of the requesting bean\n\t * @return the resource object (never {@code null})\n\t * @since 4.2\n\t * @see #getResource\n\t * @see Lazy\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 407
    },
    "return": "Object",
    "signature": "protected Object buildLazyResourceProxy(final LookupElement element, final @Nullable String requestingBeanName)",
    "source_code": "\tprotected Object buildLazyResourceProxy(final LookupElement element, final @Nullable String requestingBeanName) {\n\t\tTargetSource ts = new TargetSource() {\n\t\t\t@Override\n\t\t\tpublic Class<?> getTargetClass() {\n\t\t\t\treturn element.lookupType;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean isStatic() {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Object getTarget() {\n\t\t\t\treturn getResource(element, requestingBeanName);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void releaseTarget(Object target) {\n\t\t\t}\n\t\t};\n\n\t\tProxyFactory pf = new ProxyFactory();\n\t\tpf.setTargetSource(ts);\n\t\tif (element.lookupType.isInterface()) {\n\t\t\tpf.addInterface(element.lookupType);\n\t\t}\n\t\tClassLoader classLoader = (this.beanFactory instanceof ConfigurableBeanFactory configurableBeanFactory ?\n\t\t\t\tconfigurableBeanFactory.getBeanClassLoader() : null);\n\t\treturn pf.getProxy(classLoader);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#checkCandidate(beanName,beanDefinition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check the given candidate's bean name, determining whether the corresponding\n\t * bean definition needs to be registered or conflicts with an existing definition.\n\t * @param beanName the suggested name for the bean\n\t * @param beanDefinition the corresponding bean definition\n\t * @return {@code true} if the bean can be registered as-is;\n\t * {@code false} if it should be skipped because there is an\n\t * existing, compatible bean definition for the specified name\n\t * @throws ConflictingBeanDefinitionException if an existing, incompatible\n\t * bean definition has been found for the specified name\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "boolean",
    "signature": "protected boolean checkCandidate(String beanName, BeanDefinition beanDefinition)",
    "source_code": "\tprotected boolean checkCandidate(String beanName, BeanDefinition beanDefinition) throws IllegalStateException {\n\t\tif (!this.registry.containsBeanDefinition(beanName)) {\n\t\t\treturn true;\n\t\t}\n\t\tBeanDefinition existingDef = this.registry.getBeanDefinition(beanName);\n\t\tBeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition();\n\t\tif (originatingDef != null) {\n\t\t\texistingDef = originatingDef;\n\t\t}\n\t\tif (isCompatible(beanDefinition, existingDef)) {\n\t\t\treturn false;\n\t\t}\n\t\tthrow new ConflictingBeanDefinitionException(\"Annotation-specified bean name '\" + beanName +\n\t\t\t\t\"' for bean class [\" + beanDefinition.getBeanClassName() + \"] conflicts with existing, \" +\n\t\t\t\t\"non-compatible bean definition of same name and class [\" + existingDef.getBeanClassName() + \"]\");\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#createTypeFiltersFor(filterAttributes,environment,resourceLoader,registry)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@linkplain TypeFilter type filters} from the supplied\n\t * {@link AnnotationAttributes}, such as those sourced from\n\t * {@link ComponentScan#includeFilters()} or {@link ComponentScan#excludeFilters()}.\n\t * <p>Each {@link TypeFilter} will be instantiated using an appropriate\n\t * constructor, with {@code BeanClassLoaderAware}, {@code BeanFactoryAware},\n\t * {@code EnvironmentAware}, and {@code ResourceLoaderAware} contracts\n\t * invoked if they are implemented by the type filter.\n\t * @param filterAttributes {@code AnnotationAttributes} for a\n\t * {@link ComponentScan.Filter @Filter} declaration\n\t * @param environment the {@code Environment} to make available to filters\n\t * @param resourceLoader the {@code ResourceLoader} to make available to filters\n\t * @param registry the {@code BeanDefinitionRegistry} to make available to filters\n\t * as a {@link org.springframework.beans.factory.BeanFactory} if applicable\n\t * @return a list of instantiated and configured type filters\n\t * @see TypeFilter\n\t * @see AnnotationTypeFilter\n\t * @see AssignableTypeFilter\n\t * @see AspectJTypeFilter\n\t * @see RegexPatternTypeFilter\n\t * @see org.springframework.beans.factory.BeanClassLoaderAware\n\t * @see org.springframework.beans.factory.BeanFactoryAware\n\t * @see org.springframework.context.EnvironmentAware\n\t * @see org.springframework.context.ResourceLoaderAware\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filterAttributes",
      "environment",
      "resourceLoader",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "List<TypeFilter>",
    "signature": "public List<TypeFilter> createTypeFiltersFor(AnnotationAttributes filterAttributes, Environment environment,\n\t\t\tResourceLoader resourceLoader, BeanDefinitionRegistry registry)",
    "source_code": "\tpublic static List<TypeFilter> createTypeFiltersFor(AnnotationAttributes filterAttributes, Environment environment,\n\t\t\tResourceLoader resourceLoader, BeanDefinitionRegistry registry) {\n\n\t\tList<TypeFilter> typeFilters = new ArrayList<>();\n\t\tFilterType filterType = filterAttributes.getEnum(\"type\");\n\n\t\tfor (Class<?> filterClass : filterAttributes.getClassArray(\"classes\")) {\n\t\t\tswitch (filterType) {\n\t\t\t\tcase ANNOTATION -> {\n\t\t\t\t\tAssert.isAssignable(Annotation.class, filterClass,\n\t\t\t\t\t\t\t\"@ComponentScan ANNOTATION type filter requires an annotation type\");\n\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\tClass<Annotation> annotationType = (Class<Annotation>) filterClass;\n\t\t\t\t\ttypeFilters.add(new AnnotationTypeFilter(annotationType));\n\t\t\t\t}\n\t\t\t\tcase ASSIGNABLE_TYPE -> typeFilters.add(new AssignableTypeFilter(filterClass));\n\t\t\t\tcase CUSTOM -> {\n\t\t\t\t\tAssert.isAssignable(TypeFilter.class, filterClass,\n\t\t\t\t\t\t\t\"@ComponentScan CUSTOM type filter requires a TypeFilter implementation\");\n\t\t\t\t\tTypeFilter filter = ParserStrategyUtils.instantiateClass(filterClass, TypeFilter.class,\n\t\t\t\t\t\t\tenvironment, resourceLoader, registry);\n\t\t\t\t\ttypeFilters.add(filter);\n\t\t\t\t}\n\t\t\t\tdefault ->\n\t\t\t\t\tthrow new IllegalArgumentException(\"Filter type not supported with Class value: \" + filterType);\n\t\t\t}\n\t\t}\n\n\t\tfor (String expression : filterAttributes.getStringArray(\"pattern\")) {\n\t\t\tswitch (filterType) {\n\t\t\t\tcase ASPECTJ -> typeFilters.add(new AspectJTypeFilter(expression, resourceLoader.getClassLoader()));\n\t\t\t\tcase REGEX -> typeFilters.add(new RegexPatternTypeFilter(Pattern.compile(expression)));\n\t\t\t\tdefault ->\n\t\t\t\t\tthrow new IllegalArgumentException(\"Filter type not supported with String pattern: \" + filterType);\n\t\t\t}\n\t\t}\n\n\t\treturn typeFilters;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#doProcessConfigurationClass(configClass,sourceClass,filter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply processing and build a complete {@link ConfigurationClass} by reading the\n\t * annotations, members and methods from the source class. This method can be called\n\t * multiple times as relevant sources are discovered.\n\t * @param configClass the configuration class being build\n\t * @param sourceClass a source class\n\t * @return the superclass, or {@code null} if none found or previously processed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "configClass",
      "sourceClass",
      "filter"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "SourceClass",
    "signature": "protected SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)",
    "source_code": "\tprotected final SourceClass doProcessConfigurationClass(\n\t\t\tConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)\n\t\t\tthrows IOException {\n\n\t\tif (configClass.getMetadata().isAnnotated(Component.class.getName())) {\n\t\t\t// Recursively process any member (nested) classes first\n\t\t\tprocessMemberClasses(configClass, sourceClass, filter);\n\t\t}\n\n\t\t// Process any @PropertySource annotations\n\t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), PropertySources.class,\n\t\t\t\torg.springframework.context.annotation.PropertySource.class)) {\n\t\t\tif (this.propertySourceRegistry != null) {\n\t\t\t\tthis.propertySourceRegistry.processPropertySource(propertySource);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.info(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n\t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t}\n\n\t\t// Process any @ComponentScan annotations\n\t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n\t\tif (!componentScans.isEmpty() &&\n\t\t\t\t!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n\t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n\t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n\t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if needed\n\t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n\t\t\t\t\tBeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();\n\t\t\t\t\tif (bdCand == null) {\n\t\t\t\t\t\tbdCand = holder.getBeanDefinition();\n\t\t\t\t\t}\n\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n\t\t\t\t\t\tparse(bdCand.getBeanClassName(), holder.getBeanName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Process any @Import annotations\n\t\tprocessImports(configClass, sourceClass, getImports(sourceClass), filter, true);\n\n\t\t// Process any @ImportResource annotations\n\t\tAnnotationAttributes importResource =\n\t\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n\t\tif (importResource != null) {\n\t\t\tString[] resources = importResource.getStringArray(\"locations\");\n\t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n\t\t\tfor (String resource : resources) {\n\t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n\t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n\t\t\t}\n\t\t}\n\n\t\t// Process individual @Bean methods\n\t\tSet<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n\t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n\t\t}\n\n\t\t// Process default methods on interfaces\n\t\tprocessInterfaces(configClass, sourceClass);\n\n\t\t// Process superclass, if any\n\t\tif (sourceClass.getMetadata().hasSuperClass()) {\n\t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n\t\t\tif (superclass != null && !superclass.startsWith(\"java\") &&\n\t\t\t\t\t!this.knownSuperclasses.containsKey(superclass)) {\n\t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n\t\t\t\t// Superclass found, return its annotation metadata and recurse\n\t\t\t\treturn sourceClass.getSuperClass();\n\t\t\t}\n\t\t}\n\n\t\t// No superclass -> processing is complete\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#generateBeanName(definition,registry)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "definition",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "String",
    "signature": "public String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry)",
    "source_code": "\tpublic String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) {\n\t\tif (definition instanceof AnnotatedBeanDefinition annotatedBeanDefinition) {\n\t\t\tString beanName = determineBeanNameFromAnnotation(annotatedBeanDefinition);\n\t\t\tif (StringUtils.hasText(beanName)) {\n\t\t\t\t// Explicit bean name found.\n\t\t\t\treturn beanName;\n\t\t\t}\n\t\t}\n\t\t// Fallback: generate a unique default bean name.\n\t\treturn buildDefaultBeanName(definition, registry);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,constructorOrFactoryMethod,allowDirectSupplierShortcut)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "constructorOrFactoryMethod",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 742
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode, Executable constructorOrFactoryMethod,\n\t\t\t\tboolean allowDirectSupplierShortcut)",
    "source_code": "\t\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode, Executable constructorOrFactoryMethod,\n\t\t\t\tboolean allowDirectSupplierShortcut) {\n\t\t\tExecutable executableToUse = proxyExecutable(generationContext.getRuntimeHints(), constructorOrFactoryMethod);\n\t\t\treturn super.generateInstanceSupplierCode(generationContext, beanRegistrationCode,\n\t\t\t\t\texecutableToUse, allowDirectSupplierShortcut);\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#generateSetBeanDefinitionPropertiesCode(generationContext,beanRegistrationCode,beanDefinition,attributeFilter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "beanDefinition",
      "attributeFilter"
    ],
    "position": {
      "column": 1,
      "line": 731
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateSetBeanDefinitionPropertiesCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode, RootBeanDefinition beanDefinition, Predicate<String> attributeFilter)",
    "source_code": "\t\tpublic CodeBlock generateSetBeanDefinitionPropertiesCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode, RootBeanDefinition beanDefinition, Predicate<String> attributeFilter) {\n\t\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\t\tcode.add(super.generateSetBeanDefinitionPropertiesCode(generationContext,\n\t\t\t\t\tbeanRegistrationCode, beanDefinition, attributeFilter));\n\t\t\tcode.addStatement(\"$T.initializeConfigurationClass($T.class)\",\n\t\t\t\t\tConfigurationClassUtils.class, ClassUtils.getUserClass(this.proxyClass));\n\t\t\treturn code.build();\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#getAnnotationAttributes(annType,attribute)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annType",
      "attribute"
    ],
    "position": {
      "column": 1,
      "line": 974
    },
    "return": "Collection<SourceClass>",
    "signature": "public Collection<SourceClass> getAnnotationAttributes(String annType, String attribute)",
    "source_code": "\t\tpublic Collection<SourceClass> getAnnotationAttributes(String annType, String attribute) throws IOException {\n\t\t\tMap<String, Object> annotationAttributes = this.metadata.getAnnotationAttributes(annType, true);\n\t\t\tif (annotationAttributes == null || !annotationAttributes.containsKey(attribute)) {\n\t\t\t\treturn Collections.emptySet();\n\t\t\t}\n\t\t\tString[] classNames = (String[]) annotationAttributes.get(attribute);\n\t\t\tSet<SourceClass> result = new LinkedHashSet<>();\n\t\t\tfor (String className : classNames) {\n\t\t\t\tresult.add(getRelated(className));\n\t\t\t}\n\t\t\treturn result;\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#getResource(element,requestingBeanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the resource object for the given name and type.\n\t * @param element the descriptor for the annotated field/method\n\t * @param requestingBeanName the name of the requesting bean\n\t * @return the resource object (never {@code null})\n\t * @throws NoSuchBeanDefinitionException if no corresponding target resource found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "Object",
    "signature": "protected Object getResource(LookupElement element, @Nullable String requestingBeanName)",
    "source_code": "\tprotected Object getResource(LookupElement element, @Nullable String requestingBeanName)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\t// JNDI lookup to perform?\n\t\tString jndiName = null;\n\t\tif (StringUtils.hasLength(element.mappedName)) {\n\t\t\tjndiName = element.mappedName;\n\t\t}\n\t\telse if (this.alwaysUseJndiLookup) {\n\t\t\tjndiName = element.name;\n\t\t}\n\t\tif (jndiName != null) {\n\t\t\tif (this.jndiFactory == null) {\n\t\t\t\tthrow new NoSuchBeanDefinitionException(element.lookupType,\n\t\t\t\t\t\t\"No JNDI factory configured - specify the 'jndiFactory' property\");\n\t\t\t}\n\t\t\treturn this.jndiFactory.getBean(jndiName, element.lookupType);\n\t\t}\n\n\t\t// Regular resource autowiring\n\t\tif (this.resourceFactory == null) {\n\t\t\tthrow new NoSuchBeanDefinitionException(element.lookupType,\n\t\t\t\t\t\"No resource factory configured - specify the 'resourceFactory' property\");\n\t\t}\n\t\treturn autowireResource(this.resourceFactory, element, requestingBeanName);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#getResourceToInject(target,requestingBeanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 658
    },
    "return": "Object",
    "signature": "protected Object getResourceToInject(Object target, @Nullable String requestingBeanName)",
    "source_code": "\t\tprotected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {\n\t\t\tif (StringUtils.hasLength(this.beanName)) {\n\t\t\t\tif (beanFactory != null && beanFactory.containsBean(this.beanName)) {\n\t\t\t\t\t// Local match found for explicitly specified local bean name.\n\t\t\t\t\tObject bean = beanFactory.getBean(this.beanName, this.lookupType);\n\t\t\t\t\tif (requestingBeanName != null && beanFactory instanceof ConfigurableBeanFactory configurableBeanFactory) {\n\t\t\t\t\t\tconfigurableBeanFactory.registerDependentBean(this.beanName, requestingBeanName);\n\t\t\t\t\t}\n\t\t\t\t\treturn bean;\n\t\t\t\t}\n\t\t\t\telse if (this.isDefaultName && !StringUtils.hasLength(this.mappedName)) {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(this.beanName,\n\t\t\t\t\t\t\t\"Cannot resolve 'beanName' in local BeanFactory. Consider specifying a general 'name' value instead.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// JNDI name lookup - may still go to a local BeanFactory.\n\t\t\treturn getResource(this, requestingBeanName);\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#handle(configClass,importSelector)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Handle the specified {@link DeferredImportSelector}. If deferred import\n\t\t * selectors are being collected, this registers this instance to the list. If\n\t\t * they are being processed, the {@link DeferredImportSelector} is also processed\n\t\t * immediately according to its {@link DeferredImportSelector.Group}.\n\t\t * @param configClass the source configuration class\n\t\t * @param importSelector the selector to handle\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configClass",
      "importSelector"
    ],
    "position": {
      "column": 1,
      "line": 674
    },
    "return": "void",
    "signature": "public void handle(ConfigurationClass configClass, DeferredImportSelector importSelector)",
    "source_code": "\t\tpublic void handle(ConfigurationClass configClass, DeferredImportSelector importSelector) {\n\t\t\tDeferredImportSelectorHolder holder = new DeferredImportSelectorHolder(configClass, importSelector);\n\t\t\tif (this.deferredImportSelectors == null) {\n\t\t\t\tDeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler();\n\t\t\t\thandler.register(holder);\n\t\t\t\thandler.processGroupImports();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.deferredImportSelectors.add(holder);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#intercept(enhancedConfigInstance,beanMethod,beanMethodArgs,cglibMethodProxy)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the\n\t\t * existence of this bean object.\n\t\t * @throws Throwable as a catch-all for any exception that may be thrown when invoking the\n\t\t * super implementation of the proxied method i.e., the actual {@code @Bean} method\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enhancedConfigInstance",
      "beanMethod",
      "beanMethodArgs",
      "cglibMethodProxy"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "Object",
    "signature": "public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,\n\t\t\t\t\tMethodProxy cglibMethodProxy)",
    "source_code": "\t\tpublic Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,\n\t\t\t\t\tMethodProxy cglibMethodProxy) throws Throwable {\n\n\t\t\tConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance);\n\t\t\tString beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod);\n\n\t\t\t// Determine whether this bean is a scoped-proxy\n\t\t\tif (BeanAnnotationHelper.isScopedProxy(beanMethod)) {\n\t\t\t\tString scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName);\n\t\t\t\tif (beanFactory.isCurrentlyInCreation(scopedBeanName)) {\n\t\t\t\t\tbeanName = scopedBeanName;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// To handle the case of an inter-bean method reference, we must explicitly check the\n\t\t\t// container for already cached instances.\n\n\t\t\t// First, check to see if the requested bean is a FactoryBean. If so, create a subclass\n\t\t\t// proxy that intercepts calls to getObject() and returns any cached bean instance.\n\t\t\t// This ensures that the semantics of calling a FactoryBean from within @Bean methods\n\t\t\t// is the same as that of referring to a FactoryBean within XML. See SPR-6602.\n\t\t\tif (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&\n\t\t\t\t\tfactoryContainsBean(beanFactory, beanName)) {\n\t\t\t\tObject factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName);\n\t\t\t\tif (factoryBean instanceof ScopedProxyFactoryBean) {\n\t\t\t\t\t// Scoped proxy factory beans are a special case and should not be further proxied\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// It is a candidate FactoryBean - go ahead with enhancement\n\t\t\t\t\treturn enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isCurrentlyInvokedFactoryMethod(beanMethod)) {\n\t\t\t\t// The factory is calling the bean method in order to instantiate and register the bean\n\t\t\t\t// (i.e. via a getBean() call) -> invoke the super implementation of the method to actually\n\t\t\t\t// create the bean instance.\n\t\t\t\tif (logger.isInfoEnabled() &&\n\t\t\t\t\t\tBeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {\n\t\t\t\t\tlogger.info(String.format(\"@Bean method %s.%s is non-static and returns an object \" +\n\t\t\t\t\t\t\t\t\t\"assignable to Spring's BeanFactoryPostProcessor interface. This will \" +\n\t\t\t\t\t\t\t\t\t\"result in a failure to process annotations such as @Autowired, \" +\n\t\t\t\t\t\t\t\t\t\"@Resource and @PostConstruct within the method's declaring \" +\n\t\t\t\t\t\t\t\t\t\"@Configuration class. Add the 'static' modifier to this method to avoid \" +\n\t\t\t\t\t\t\t\t\t\"these container lifecycle issues; see @Bean javadoc for complete details.\",\n\t\t\t\t\t\t\tbeanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()));\n\t\t\t\t}\n\t\t\t\treturn cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);\n\t\t\t}\n\n\t\t\treturn resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#intercept(obj,method,args,proxy)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj",
      "method",
      "args",
      "proxy"
    ],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "Object",
    "signature": "public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy)",
    "source_code": "\t\tpublic Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n\t\t\tField field = ReflectionUtils.findField(obj.getClass(), BEAN_FACTORY_FIELD);\n\t\t\tAssert.state(field != null, \"Unable to find generated BeanFactory field\");\n\t\t\tfield.set(obj, args[0]);\n\n\t\t\t// Does the actual (non-CGLIB) superclass implement BeanFactoryAware?\n\t\t\t// If so, call its setBeanFactory() method. If not, just exit.\n\t\t\tif (BeanFactoryAware.class.isAssignableFrom(ClassUtils.getUserClass(obj.getClass().getSuperclass()))) {\n\t\t\t\treturn proxy.invokeSuper(obj, args);\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#isCompatible(newDefinition,existingDefinition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given new bean definition is compatible with\n\t * the given existing bean definition.\n\t * <p>The default implementation considers them as compatible when the existing\n\t * bean definition comes from the same source or from a non-scanning source.\n\t * @param newDefinition the new bean definition, originated from scanning\n\t * @param existingDefinition the existing bean definition, potentially an\n\t * explicitly defined one or a previously generated one from scanning\n\t * @return whether the definitions are considered as compatible, with the\n\t * new definition to be skipped in favor of the existing definition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "newDefinition",
      "existingDefinition"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "boolean",
    "signature": "protected boolean isCompatible(BeanDefinition newDefinition, BeanDefinition existingDefinition)",
    "source_code": "\tprotected boolean isCompatible(BeanDefinition newDefinition, BeanDefinition existingDefinition) {\n\t\treturn (!(existingDefinition instanceof ScannedGenericBeanDefinition) ||  // explicitly registered overriding bean\n\t\t\t\t(newDefinition.getSource() != null && newDefinition.getSource().equals(existingDefinition.getSource())) ||  // scanned same file twice\n\t\t\t\tnewDefinition.equals(existingDefinition));  // scanned equivalent class twice\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#isOverriddenByExistingDefinition(beanMethod,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanMethod",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "boolean",
    "signature": "protected boolean isOverriddenByExistingDefinition(BeanMethod beanMethod, String beanName)",
    "source_code": "\tprotected boolean isOverriddenByExistingDefinition(BeanMethod beanMethod, String beanName) {\n\t\tif (!this.registry.containsBeanDefinition(beanName)) {\n\t\t\treturn false;\n\t\t}\n\t\tBeanDefinition existingBeanDef = this.registry.getBeanDefinition(beanName);\n\n\t\t// Is the existing bean definition one that was created from a configuration class?\n\t\t// -> allow the current bean method to override, since both are at second-pass level.\n\t\t// However, if the bean method is an overloaded case on the same configuration class,\n\t\t// preserve the existing bean definition.\n\t\tif (existingBeanDef instanceof ConfigurationClassBeanDefinition ccbd) {\n\t\t\tif (ccbd.getMetadata().getClassName().equals(\n\t\t\t\t\tbeanMethod.getConfigurationClass().getMetadata().getClassName())) {\n\t\t\t\tif (ccbd.getFactoryMethodMetadata().getMethodName().equals(ccbd.getFactoryMethodName())) {\n\t\t\t\t\tccbd.setNonUniqueFactoryMethodName(ccbd.getFactoryMethodMetadata().getMethodName());\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// A bean definition resulting from a component scan can be silently overridden\n\t\t// by an @Bean method, as of 4.2...\n\t\tif (existingBeanDef instanceof ScannedGenericBeanDefinition) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Has the existing bean definition bean marked as a framework-generated bean?\n\t\t// -> allow the current bean method to override it, since it is application-level\n\t\tif (existingBeanDef.getRole() > BeanDefinition.ROLE_APPLICATION) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// At this point, it's a top-level override (probably XML), just having been parsed\n\t\t// before configuration class processing kicks in...\n\t\tif (this.registry instanceof DefaultListableBeanFactory dlbf &&\n\t\t\t\t!dlbf.isAllowBeanDefinitionOverriding()) {\n\t\t\tthrow new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),\n\t\t\t\t\tbeanName, \"@Bean definition illegally overridden by existing bean definition: \" + existingBeanDef);\n\t\t}\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Skipping bean definition for %s: a definition for bean '%s' \" +\n\t\t\t\t\t\"already exists. This top-level bean definition is considered as an override.\",\n\t\t\t\t\tbeanMethod, beanName));\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#isStereotypeWithNameValue(annotationType,metaAnnotationTypes,Map<String,attributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given annotation is a stereotype that is allowed\n\t * to suggest a component name through its annotation {@code value()}.\n\t * @param annotationType the name of the annotation class to check\n\t * @param metaAnnotationTypes the names of meta-annotations on the given annotation\n\t * @param attributes the map of attributes for the given annotation\n\t * @return whether the annotation qualifies as a stereotype with component name\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "annotationType",
      "metaAnnotationTypes",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "boolean",
    "signature": "protected boolean isStereotypeWithNameValue(String annotationType,\n\t\t\tSet<String> metaAnnotationTypes, @Nullable Map<String, Object> attributes)",
    "source_code": "\tprotected boolean isStereotypeWithNameValue(String annotationType,\n\t\t\tSet<String> metaAnnotationTypes, @Nullable Map<String, Object> attributes) {\n\n\t\tboolean isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME) ||\n\t\t\t\tmetaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME) ||\n\t\t\t\tannotationType.equals(\"jakarta.annotation.ManagedBean\") ||\n\t\t\t\tannotationType.equals(\"jakarta.inject.Named\");\n\n\t\treturn (isStereotype && attributes != null && attributes.containsKey(\"value\"));\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#parse(className,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "className",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "protected void parse(@Nullable String className, String beanName)",
    "source_code": "\tprotected final void parse(@Nullable String className, String beanName) throws IOException {\n\t\tAssert.notNull(className, \"No bean class name for configuration class bean definition\");\n\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(className);\n\t\tprocessConfigurationClass(new ConfigurationClass(reader, beanName), DEFAULT_EXCLUSION_FILTER);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#parse(clazz,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "void",
    "signature": "protected void parse(Class<?> clazz, String beanName)",
    "source_code": "\tprotected final void parse(Class<?> clazz, String beanName) throws IOException {\n\t\tprocessConfigurationClass(new ConfigurationClass(clazz, beanName), DEFAULT_EXCLUSION_FILTER);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#parse(metadata,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "metadata",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "void",
    "signature": "protected void parse(AnnotationMetadata metadata, String beanName)",
    "source_code": "\tprotected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {\n\t\tprocessConfigurationClass(new ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessAfterInstantiation(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "boolean",
    "signature": "public boolean postProcessAfterInstantiation(Object bean, String beanName)",
    "source_code": "\tpublic boolean postProcessAfterInstantiation(Object bean, String beanName) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessBeanDefinition(beanDefinition,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply further settings to the given bean definition,\n\t * beyond the contents retrieved from scanning the component class.\n\t * @param beanDefinition the scanned bean definition\n\t * @param beanName the generated bean name for the given bean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanDefinition",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "void",
    "signature": "protected void postProcessBeanDefinition(AbstractBeanDefinition beanDefinition, String beanName)",
    "source_code": "\tprotected void postProcessBeanDefinition(AbstractBeanDefinition beanDefinition, String beanName) {\n\t\tbeanDefinition.applyDefaults(this.beanDefinitionDefaults);\n\t\tif (this.autowireCandidatePatterns != null) {\n\t\t\tbeanDefinition.setAutowireCandidate(PatternMatchUtils.simpleMatch(this.autowireCandidatePatterns, beanName));\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 546
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\t\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) {\n\t\t\tif (bean instanceof ImportAware importAware) {\n\t\t\t\tImportRegistry ir = this.beanFactory.getBean(IMPORT_REGISTRY_BEAN_NAME, ImportRegistry.class);\n\t\t\t\tAnnotationMetadata importingClass = ir.getImportingClassFor(ClassUtils.getUserClass(bean).getName());\n\t\t\t\tif (importingClass != null) {\n\t\t\t\t\timportAware.setImportMetadata(importingClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn bean;\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessBeforeInstantiation(beanClass,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t\tsuper.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);\n\t\tInjectionMetadata metadata = findResourceMetadata(beanName, beanType, null);\n\t\tmetadata.checkConfigMembers(beanDefinition);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessProperties(pvs,bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "PropertyValues",
    "signature": "public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)",
    "source_code": "\tpublic PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n\t\tInjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs);\n\t\ttry {\n\t\t\tmetadata.inject(bean, beanName, pvs);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"Injection of resource dependencies failed\", ex);\n\t\t}\n\t\treturn pvs;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#process(metadata,selector)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadata",
      "selector"
    ],
    "position": {
      "column": 1,
      "line": 817
    },
    "return": "void",
    "signature": "public void process(AnnotationMetadata metadata, DeferredImportSelector selector)",
    "source_code": "\t\tpublic void process(AnnotationMetadata metadata, DeferredImportSelector selector) {\n\t\t\tfor (String importClassName : selector.selectImports(metadata)) {\n\t\t\t\tthis.imports.add(new Entry(metadata, importClassName));\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#processConfigurationClass(configClass,filter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "configClass",
      "filter"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "void",
    "signature": "protected void processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter)",
    "source_code": "\tprotected void processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter) throws IOException {\n\t\tif (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationClass existingClass = this.configurationClasses.get(configClass);\n\t\tif (existingClass != null) {\n\t\t\tif (configClass.isImported()) {\n\t\t\t\tif (existingClass.isImported()) {\n\t\t\t\t\texistingClass.mergeImportedBy(configClass);\n\t\t\t\t}\n\t\t\t\t// Otherwise ignore new imported config class; existing non-imported class overrides it.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Explicit bean definition found, probably replacing an import.\n\t\t\t\t// Let's remove the old one and go with the new one.\n\t\t\t\tthis.configurationClasses.remove(configClass);\n\t\t\t\tthis.knownSuperclasses.values().removeIf(configClass::equals);\n\t\t\t}\n\t\t}\n\n\t\t// Recursively process the configuration class and its superclass hierarchy.\n\t\tSourceClass sourceClass = asSourceClass(configClass, filter);\n\t\tdo {\n\t\t\tsourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);\n\t\t}\n\t\twhile (sourceClass != null);\n\n\t\tthis.configurationClasses.put(configClass, configClass);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "public void registerBean(Class<?> beanClass, @Nullable String name)",
    "source_code": "\tpublic void registerBean(Class<?> beanClass, @Nullable String name) {\n\t\tdoRegisterBean(beanClass, name, null, null, null);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,name,qualifiers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @param qualifiers specific qualifier annotations to consider,\n\t * in addition to qualifiers at the bean class level\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "name",
      "qualifiers"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void registerBean(Class<?> beanClass, @Nullable String name,\n\t\t\tClass<? extends Annotation>... qualifiers)",
    "source_code": "\tpublic void registerBean(Class<?> beanClass, @Nullable String name,\n\t\t\tClass<? extends Annotation>... qualifiers) {\n\n\t\tdoRegisterBean(beanClass, name, qualifiers, null, null);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,name,supplier)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations, using the given supplier for obtaining a new\n\t * instance (possibly declared as a lambda expression or method reference).\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @param supplier a callback for creating an instance of the bean\n\t * (may be {@code null})\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "name",
      "supplier"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, @Nullable String name, @Nullable Supplier<T> supplier)",
    "source_code": "\tpublic <T> void registerBean(Class<T> beanClass, @Nullable String name, @Nullable Supplier<T> supplier) {\n\t\tdoRegisterBean(beanClass, name, null, supplier, null);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,name,supplier,customizers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @param supplier a callback for creating an instance of the bean\n\t * (may be {@code null})\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "name",
      "supplier",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, @Nullable String name, @Nullable Supplier<T> supplier,\n\t\t\tBeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic <T> void registerBean(Class<T> beanClass, @Nullable String name, @Nullable Supplier<T> supplier,\n\t\t\tBeanDefinitionCustomizer... customizers) {\n\n\t\tdoRegisterBean(beanClass, name, null, supplier, customizers);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,qualifiers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param qualifiers specific qualifier annotations to consider,\n\t * in addition to qualifiers at the bean class level\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "qualifiers"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "void",
    "signature": "public void registerBean(Class<?> beanClass, Class<? extends Annotation>... qualifiers)",
    "source_code": "\tpublic void registerBean(Class<?> beanClass, Class<? extends Annotation>... qualifiers) {\n\t\tdoRegisterBean(beanClass, null, qualifiers, null, null);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,supplier)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations, using the given supplier for obtaining a new\n\t * instance (possibly declared as a lambda expression or method reference).\n\t * @param beanClass the class of the bean\n\t * @param supplier a callback for creating an instance of the bean\n\t * (may be {@code null})\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "supplier"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, @Nullable Supplier<T> supplier)",
    "source_code": "\tpublic <T> void registerBean(Class<T> beanClass, @Nullable Supplier<T> supplier) {\n\t\tdoRegisterBean(beanClass, null, null, supplier, null);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBeanDefinition(definitionHolder,registry)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified bean with the given registry.\n\t * <p>Can be overridden in subclasses, e.g. to adapt the registration\n\t * process or to register further bean definitions for each scanned bean.\n\t * @param definitionHolder the bean definition plus bean name for the bean\n\t * @param registry the BeanDefinitionRegistry to register the bean with\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "definitionHolder",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "void",
    "signature": "protected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)",
    "source_code": "\tprotected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {\n\t\tBeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerImport(importingClass,importedClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "importingClass",
      "importedClass"
    ],
    "position": {
      "column": 1,
      "line": 619
    },
    "return": "void",
    "signature": "public void registerImport(AnnotationMetadata importingClass, String importedClass)",
    "source_code": "\t\tpublic void registerImport(AnnotationMetadata importingClass, String importedClass) {\n\t\t\tthis.imports.add(importedClass, importingClass);\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerScope(annotationType,scopeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register an extended JSR-330 scope annotation, mapping it onto a\n\t * specific Spring scope by name.\n\t * @param annotationType the JSR-330 annotation type by name\n\t * @param scopeName the Spring scope name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "scopeName"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void registerScope(String annotationType, String scopeName)",
    "source_code": "\tpublic final void registerScope(String annotationType, String scopeName) {\n\t\tthis.scopeMap.put(annotationType, scopeName);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#shouldSkip(metadata,phase)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if an item should be skipped based on {@code @Conditional} annotations.\n\t * @param metadata the meta data\n\t * @param phase the phase of the call\n\t * @return if the item should be skipped\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadata",
      "phase"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "boolean",
    "signature": "public boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase)",
    "source_code": "\tpublic boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase) {\n\t\tif (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (phase == null) {\n\t\t\tif (metadata instanceof AnnotationMetadata annotationMetadata &&\n\t\t\t\t\tConfigurationClassUtils.isConfigurationCandidate(annotationMetadata)) {\n\t\t\t\treturn shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);\n\t\t\t}\n\t\t\treturn shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);\n\t\t}\n\n\t\tList<Condition> conditions = new ArrayList<>();\n\t\tfor (String[] conditionClasses : getConditionClasses(metadata)) {\n\t\t\tfor (String conditionClass : conditionClasses) {\n\t\t\t\tCondition condition = getCondition(conditionClass, this.context.getClassLoader());\n\t\t\t\tconditions.add(condition);\n\t\t\t}\n\t\t}\n\n\t\tAnnotationAwareOrderComparator.sort(conditions);\n\n\t\tfor (Condition condition : conditions) {\n\t\t\tConfigurationPhase requiredPhase = null;\n\t\t\tif (condition instanceof ConfigurationCondition configurationCondition) {\n\t\t\t\trequiredPhase = configurationCondition.getConfigurationPhase();\n\t\t\t}\n\t\t\tif ((requiredPhase == null || requiredPhase == phase) && !condition.matches(this.context, metadata)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}"
  },
  "org.springframework.context.aot.<unknown>#applyTo(generationContext,beanFactoryInitializationCode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanFactoryInitializationCode"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext, BeanFactoryInitializationCode beanFactoryInitializationCode)",
    "source_code": "\t\tpublic void applyTo(GenerationContext generationContext, BeanFactoryInitializationCode beanFactoryInitializationCode) {\n\t\t\tRuntimeHints runtimeHints = generationContext.getRuntimeHints();\n\t\t\tREGISTRAR.registerRuntimeHints(runtimeHints, this.types);\n\t\t}"
  },
  "org.springframework.context.event.<unknown>#getDetailedErrorMessage(bean,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add additional details such as the bean type and method signature to\n\t * the given error message.\n\t * @param message error message to append the HandlerMethod details to\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "String",
    "signature": "protected String getDetailedErrorMessage(Object bean, String message)",
    "source_code": "\tprotected String getDetailedErrorMessage(Object bean, String message) {\n\t\tStringBuilder sb = new StringBuilder(message).append('\\n');\n\t\tsb.append(\"HandlerMethod details: \\n\");\n\t\tsb.append(\"Bean [\").append(bean.getClass().getName()).append(\"]\\n\");\n\t\tsb.append(\"Method [\").append(this.method.toGenericString()).append(\"]\\n\");\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.context.event.<unknown>#supportsEvent(listener,eventType,sourceType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given listener supports the given event.\n\t * <p>The default implementation detects the {@link SmartApplicationListener}\n\t * and {@link GenericApplicationListener} interfaces. In case of a standard\n\t * {@link ApplicationListener}, a {@link GenericApplicationListenerAdapter}\n\t * will be used to introspect the generically declared type of the target listener.\n\t * @param listener the target listener to check\n\t * @param eventType the event type to check against\n\t * @param sourceType the source type to check against\n\t * @return whether the given listener should be included in the candidates\n\t * for the given event type\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "listener",
      "eventType",
      "sourceType"
    ],
    "position": {
      "column": 1,
      "line": 373
    },
    "return": "boolean",
    "signature": "protected boolean supportsEvent(ApplicationListener<?> listener, ResolvableType eventType, @Nullable Class<?> sourceType)",
    "source_code": "\tprotected boolean supportsEvent(\n\t\t\tApplicationListener<?> listener, ResolvableType eventType, @Nullable Class<?> sourceType) {\n\n\t\tGenericApplicationListener smartListener = (listener instanceof GenericApplicationListener ?\n\t\t\t\t(GenericApplicationListener) listener : new GenericApplicationListenerAdapter(listener));\n\t\treturn (smartListener.supportsEventType(eventType) && smartListener.supportsSourceType(sourceType));\n\t}"
  },
  "org.springframework.context.event.<unknown>#supportsEvent(listenerType,eventType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Filter a listener early through checking its generically declared event\n\t * type before trying to instantiate it.\n\t * <p>If this method returns {@code true} for a given listener as a first pass,\n\t * the listener instance will get retrieved and fully evaluated through a\n\t * {@link #supportsEvent(ApplicationListener, ResolvableType, Class)} call afterwards.\n\t * @param listenerType the listener's type as determined by the BeanFactory\n\t * @param eventType the event type to check\n\t * @return whether the given listener should be included in the candidates\n\t * for the given event type\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "listenerType",
      "eventType"
    ],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "boolean",
    "signature": "protected boolean supportsEvent(Class<?> listenerType, ResolvableType eventType)",
    "source_code": "\tprotected boolean supportsEvent(Class<?> listenerType, ResolvableType eventType) {\n\t\tResolvableType declaredEventType = GenericApplicationListenerAdapter.resolveDeclaredEventType(listenerType);\n\t\treturn (declaredEventType == null || declaredEventType.isAssignableFrom(eventType));\n\t}"
  },
  "org.springframework.context.expression.<unknown>#canRead(context,target,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "return": "boolean",
    "signature": "public boolean canRead(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\treturn (target instanceof BeanExpressionContext bec && bec.containsObject(name));\n\t}"
  },
  "org.springframework.context.expression.<unknown>#canWrite(context,target,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "boolean",
    "signature": "public boolean canWrite(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\treturn false;\n\t}"
  },
  "org.springframework.context.expression.<unknown>#generateCode(propertyName,mv,cf)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "mv",
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf)",
    "source_code": "\tpublic void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf) {\n\t\tString descriptor = cf.lastDescriptor();\n\t\tif (descriptor == null || !descriptor.equals(\"Ljava/util/Map\")) {\n\t\t\tif (descriptor == null) {\n\t\t\t\tcf.loadTarget(mv);\n\t\t\t}\n\t\t\tCodeFlow.insertCheckCast(mv, \"Ljava/util/Map\");\n\t\t}\n\t\tmv.visitLdcInsn(propertyName);\n\t\tmv.visitMethodInsn(INVOKEINTERFACE, \"java/util/Map\", \"get\",\"(Ljava/lang/Object;)Ljava/lang/Object;\",true);\n\t}"
  },
  "org.springframework.context.expression.<unknown>#getExpression(Map<ExpressionKey,cache,elementKey,expression)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link Expression} for the specified SpEL value\n\t * <p>{@link #parseExpression(String) Parse the expression} if it hasn't been already.\n\t * @param cache the cache to use\n\t * @param elementKey the element on which the expression is defined\n\t * @param expression the expression to parse\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<ExpressionKey",
      "cache",
      "elementKey",
      "expression"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "Expression",
    "signature": "protected Expression getExpression(Map<ExpressionKey, Expression> cache,\n\t\t\tAnnotatedElementKey elementKey, String expression)",
    "source_code": "\tprotected Expression getExpression(Map<ExpressionKey, Expression> cache,\n\t\t\tAnnotatedElementKey elementKey, String expression) {\n\n\t\tExpressionKey expressionKey = createKey(elementKey, expression);\n\t\tExpression expr = cache.get(expressionKey);\n\t\tif (expr == null) {\n\t\t\texpr = parseExpression(expression);\n\t\t\tcache.put(expressionKey, expr);\n\t\t}\n\t\treturn expr;\n\t}"
  },
  "org.springframework.context.expression.<unknown>#read(context,target,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "TypedValue",
    "signature": "public TypedValue read(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\tAssert.state(target instanceof BeanExpressionContext, \"Target must be of type BeanExpressionContext\");\n\t\treturn new TypedValue(((BeanExpressionContext) target).getObject(name));\n\t}"
  },
  "org.springframework.context.expression.<unknown>#write(context,target,name,newValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "void",
    "signature": "public void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue)",
    "source_code": "\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue)\n\t\t\tthrows AccessException {\n\n\t\tthrow new AccessException(\"Beans in a BeanFactory are read-only\");\n\t}"
  },
  "org.springframework.context.support.<unknown>#add(name,bean)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "void",
    "signature": "public void add(String name, Lifecycle bean)",
    "source_code": "\t\tpublic void add(String name, Lifecycle bean) {\n\t\t\tthis.members.add(new LifecycleGroupMember(name, bean));\n\t\t\tif (bean instanceof SmartLifecycle) {\n\t\t\t\tthis.smartMemberCount++;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.support.<unknown>#calculateAllFilenames(basename,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Calculate all filenames for the given bundle basename and Locale.\n\t * Will calculate filenames for the given Locale, the system Locale\n\t * (if applicable), and the default file.\n\t * @param basename the basename of the bundle\n\t * @param locale the locale\n\t * @return the List of filenames to check\n\t * @see #setFallbackToSystemLocale\n\t * @see #calculateFilenamesForLocale\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "basename",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "List<String>",
    "signature": "protected List<String> calculateAllFilenames(String basename, Locale locale)",
    "source_code": "\tprotected List<String> calculateAllFilenames(String basename, Locale locale) {\n\t\tMap<Locale, List<String>> localeMap = this.cachedFilenames.get(basename);\n\t\tif (localeMap != null) {\n\t\t\tList<String> filenames = localeMap.get(locale);\n\t\t\tif (filenames != null) {\n\t\t\t\treturn filenames;\n\t\t\t}\n\t\t}\n\n\t\t// Filenames for given Locale\n\t\tList<String> filenames = new ArrayList<>(7);\n\t\tfilenames.addAll(calculateFilenamesForLocale(basename, locale));\n\n\t\t// Filenames for default Locale, if any\n\t\tLocale defaultLocale = getDefaultLocale();\n\t\tif (defaultLocale != null && !defaultLocale.equals(locale)) {\n\t\t\tList<String> fallbackFilenames = calculateFilenamesForLocale(basename, defaultLocale);\n\t\t\tfor (String fallbackFilename : fallbackFilenames) {\n\t\t\t\tif (!filenames.contains(fallbackFilename)) {\n\t\t\t\t\t// Entry for fallback locale that isn't already in filenames list.\n\t\t\t\t\tfilenames.add(fallbackFilename);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Filename for default bundle file\n\t\tfilenames.add(basename);\n\n\t\tif (localeMap == null) {\n\t\t\tlocaleMap = new ConcurrentHashMap<>();\n\t\t\tMap<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap);\n\t\t\tif (existing != null) {\n\t\t\t\tlocaleMap = existing;\n\t\t\t}\n\t\t}\n\t\tlocaleMap.put(locale, filenames);\n\t\treturn filenames;\n\t}"
  },
  "org.springframework.context.support.<unknown>#calculateFilenamesForLocale(basename,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Calculate the filenames for the given bundle basename and Locale,\n\t * appending language code, country code, and variant code.\n\t * <p>For example, basename \"messages\", Locale \"de_AT_oo\" &rarr; \"messages_de_AT_OO\",\n\t * \"messages_de_AT\", \"messages_de\".\n\t * <p>Follows the rules defined by {@link java.util.Locale#toString()}.\n\t * @param basename the basename of the bundle\n\t * @param locale the locale\n\t * @return the List of filenames to check\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "basename",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "List<String>",
    "signature": "protected List<String> calculateFilenamesForLocale(String basename, Locale locale)",
    "source_code": "\tprotected List<String> calculateFilenamesForLocale(String basename, Locale locale) {\n\t\tList<String> result = new ArrayList<>(3);\n\t\tString language = locale.getLanguage();\n\t\tString country = locale.getCountry();\n\t\tString variant = locale.getVariant();\n\t\tStringBuilder temp = new StringBuilder(basename);\n\n\t\ttemp.append('_');\n\t\tif (language.length() > 0) {\n\t\t\ttemp.append(language);\n\t\t\tresult.add(0, temp.toString());\n\t\t}\n\n\t\ttemp.append('_');\n\t\tif (country.length() > 0) {\n\t\t\ttemp.append(country);\n\t\t\tresult.add(0, temp.toString());\n\t\t}\n\n\t\tif (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {\n\t\t\ttemp.append('_').append(variant);\n\t\t\tresult.add(0, temp.toString());\n\t\t}\n\n\t\treturn result;\n\t}"
  },
  "org.springframework.context.support.<unknown>#findAllAnnotationsOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 1323
    },
    "return": "Set<A>",
    "signature": "public Set<A> findAllAnnotationsOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> Set<A> findAllAnnotationsOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().findAllAnnotationsOnBean(beanName, annotationType, allowFactoryBeanInit);\n\t}"
  },
  "org.springframework.context.support.<unknown>#findAnnotationOnBean(beanName,annotationType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 1305
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().findAnnotationOnBean(beanName, annotationType);\n\t}"
  },
  "org.springframework.context.support.<unknown>#findAnnotationOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 1314
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().findAnnotationOnBean(beanName, annotationType, allowFactoryBeanInit);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getBean(name,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1142
    },
    "return": "Object",
    "signature": "public Object getBean(String name, Object... args)",
    "source_code": "\tpublic Object getBean(String name, Object... args) throws BeansException {\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().getBean(name, args);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getBean(name,requiredType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 1136
    },
    "return": "T",
    "signature": "public T getBean(String name, Class<T> requiredType)",
    "source_code": "\tpublic <T> T getBean(String name, Class<T> requiredType) throws BeansException {\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().getBean(name, requiredType);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getBean(requiredType,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1154
    },
    "return": "T",
    "signature": "public T getBean(Class<T> requiredType, Object... args)",
    "source_code": "\tpublic <T> T getBean(Class<T> requiredType, Object... args) throws BeansException {\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().getBean(requiredType, args);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getBeanNamesForType(type,includeNonSingletons,allowEagerInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 1270
    },
    "return": "String[]",
    "signature": "public String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().getBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getBeanProvider(requiredType,allowEagerInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 1246
    },
    "return": "ObjectProvider<T>",
    "signature": "public ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit)",
    "source_code": "\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit) {\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().getBeanProvider(requiredType, allowEagerInit);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getBeansOfType(type,includeNonSingletons,allowEagerInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 1282
    },
    "return": "T>",
    "signature": "public T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic <T> Map<String, T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException {\n\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().getBeansOfType(type, includeNonSingletons, allowEagerInit);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getDefaultMessage(resolvable,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get a default message for the given {@code MessageSourceResolvable}.\n\t * <p>This implementation fully renders the default message if available,\n\t * or just returns the plain default message {@code String} if the primary\n\t * message code is being used as a default message.\n\t * @param resolvable the value object to resolve a default message for\n\t * @param locale the current locale\n\t * @return the default message, or {@code null} if none\n\t * @since 4.3.6\n\t * @see #renderDefaultMessage(String, Object[], Locale)\n\t * @see #getDefaultMessage(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "String",
    "signature": "protected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\tprotected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale) {\n\t\tString defaultMessage = resolvable.getDefaultMessage();\n\t\tString[] codes = resolvable.getCodes();\n\t\tif (defaultMessage != null) {\n\t\t\tif (resolvable instanceof DefaultMessageSourceResolvable defaultMessageSourceResolvable &&\n\t\t\t\t\t!defaultMessageSourceResolvable.shouldRenderDefaultMessage()) {\n\t\t\t\t// Given default message does not contain any argument placeholders\n\t\t\t\t// (and isn't escaped for alwaysUseMessageFormat either) -> return as-is.\n\t\t\t\treturn defaultMessage;\n\t\t\t}\n\t\t\tif (!ObjectUtils.isEmpty(codes) && defaultMessage.equals(codes[0])) {\n\t\t\t\t// Never format a code-as-default-message, even with alwaysUseMessageFormat=true\n\t\t\t\treturn defaultMessage;\n\t\t\t}\n\t\t\treturn renderDefaultMessage(defaultMessage, resolvable.getArguments(), locale);\n\t\t}\n\t\treturn (!ObjectUtils.isEmpty(codes) ? getDefaultMessage(codes[0]) : null);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessage(code,args,defaultMessage,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 1364
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale) {\n\t\treturn getMessageSource().getMessage(code, args, defaultMessage, locale);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessage(code,args,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 1369
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, Locale locale) throws NoSuchMessageException {\n\t\treturn getMessageSource().getMessage(code, args, locale);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessage(resolvable,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 1374
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException {\n\t\treturn getMessageSource().getMessage(resolvable, locale);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessageFormat(code,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 606
    },
    "return": "MessageFormat",
    "signature": "public MessageFormat getMessageFormat(String code, Locale locale)",
    "source_code": "\t\tpublic MessageFormat getMessageFormat(String code, Locale locale) {\n\t\t\tif (this.properties == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tMap<Locale, MessageFormat> localeMap = this.cachedMessageFormats.get(code);\n\t\t\tif (localeMap != null) {\n\t\t\t\tMessageFormat result = localeMap.get(locale);\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString msg = this.properties.getProperty(code);\n\t\t\tif (msg != null) {\n\t\t\t\tif (localeMap == null) {\n\t\t\t\t\tlocaleMap = new ConcurrentHashMap<>();\n\t\t\t\t\tMap<Locale, MessageFormat> existing = this.cachedMessageFormats.putIfAbsent(code, localeMap);\n\t\t\t\t\tif (existing != null) {\n\t\t\t\t\t\tlocaleMap = existing;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMessageFormat result = createMessageFormat(msg, locale);\n\t\t\t\tlocaleMap.put(locale, result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.context.support.<unknown>#getMessageFromParent(code,args,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Try to retrieve the given message from the parent {@code MessageSource}, if any.\n\t * @param code the code to lookup up, such as 'calculator.noRateSet'\n\t * @param args array of arguments that will be filled in for params\n\t * within the message\n\t * @param locale the locale in which to do the lookup\n\t * @return the resolved message, or {@code null} if not found\n\t * @see #getParentMessageSource()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "String",
    "signature": "protected String getMessageFromParent(String code, @Nullable Object[] args, Locale locale)",
    "source_code": "\tprotected String getMessageFromParent(String code, @Nullable Object[] args, Locale locale) {\n\t\tMessageSource parent = getParentMessageSource();\n\t\tif (parent != null) {\n\t\t\tif (parent instanceof AbstractMessageSource abstractMessageSource) {\n\t\t\t\t// Call internal method to avoid getting the default code back\n\t\t\t\t// in case of \"useCodeAsDefaultMessage\" being activated.\n\t\t\t\treturn abstractMessageSource.getMessageInternal(code, args, locale);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Check parent MessageSource, returning null if not found there.\n\t\t\t\t// Covers custom MessageSource impls and DelegatingMessageSource.\n\t\t\t\treturn parent.getMessage(code, args, null, locale);\n\t\t\t}\n\t\t}\n\t\t// Not found in parent either.\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessageInternal(code,args,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given code and arguments as message in the given Locale,\n\t * returning {@code null} if not found. Does <i>not</i> fall back to\n\t * the code as default message. Invoked by {@code getMessage} methods.\n\t * @param code the code to lookup up, such as 'calculator.noRateSet'\n\t * @param args array of arguments that will be filled in for params\n\t * within the message\n\t * @param locale the locale in which to do the lookup\n\t * @return the resolved message, or {@code null} if not found\n\t * @see #getMessage(String, Object[], String, Locale)\n\t * @see #getMessage(String, Object[], Locale)\n\t * @see #getMessage(MessageSourceResolvable, Locale)\n\t * @see #setUseCodeAsDefaultMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "String",
    "signature": "protected String getMessageInternal(@Nullable String code, @Nullable Object[] args, @Nullable Locale locale)",
    "source_code": "\tprotected String getMessageInternal(@Nullable String code, @Nullable Object[] args, @Nullable Locale locale) {\n\t\tif (code == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (locale == null) {\n\t\t\tlocale = Locale.getDefault();\n\t\t}\n\t\tObject[] argsToUse = args;\n\n\t\tif (!isAlwaysUseMessageFormat() && ObjectUtils.isEmpty(args)) {\n\t\t\t// Optimized resolution: no arguments to apply,\n\t\t\t// therefore no MessageFormat needs to be involved.\n\t\t\t// Note that the default implementation still uses MessageFormat;\n\t\t\t// this can be overridden in specific subclasses.\n\t\t\tString message = resolveCodeWithoutArguments(code, locale);\n\t\t\tif (message != null) {\n\t\t\t\treturn message;\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\t// Resolve arguments eagerly, for the case where the message\n\t\t\t// is defined in a parent MessageSource but resolvable arguments\n\t\t\t// are defined in the child MessageSource.\n\t\t\targsToUse = resolveArguments(args, locale);\n\n\t\t\tMessageFormat messageFormat = resolveCode(code, locale);\n\t\t\tif (messageFormat != null) {\n\t\t\t\tsynchronized (messageFormat) {\n\t\t\t\t\treturn messageFormat.format(argsToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check locale-independent common messages for the given message code.\n\t\tProperties commonMessages = getCommonMessages();\n\t\tif (commonMessages != null) {\n\t\t\tString commonMessage = commonMessages.getProperty(code);\n\t\t\tif (commonMessage != null) {\n\t\t\t\treturn formatMessage(commonMessage, args, locale);\n\t\t\t}\n\t\t}\n\n\t\t// Not found -> check parent, if any.\n\t\treturn getMessageFromParent(code, argsToUse, locale);\n\t}"
  },
  "org.springframework.context.support.<unknown>#invokeBeanFactoryPostProcessors(beanFactory,beanFactoryPostProcessors)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "beanFactoryPostProcessors"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors)",
    "source_code": "\tpublic static void invokeBeanFactoryPostProcessors(\n\t\t\tConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {\n\n\t\t// WARNING: Although it may appear that the body of this method can be easily\n\t\t// refactored to avoid the use of multiple loops and multiple lists, the use\n\t\t// of multiple lists and multiple passes over the names of processors is\n\t\t// intentional. We must ensure that we honor the contracts for PriorityOrdered\n\t\t// and Ordered processors. Specifically, we must NOT cause processors to be\n\t\t// instantiated (via getBean() invocations) or registered in the ApplicationContext\n\t\t// in the wrong order.\n\t\t//\n\t\t// Before submitting a pull request (PR) to change this method, please review the\n\t\t// list of all declined PRs involving changes to PostProcessorRegistrationDelegate\n\t\t// to ensure that your proposal does not result in a breaking change:\n\t\t// https://github.com/spring-projects/spring-framework/issues?q=PostProcessorRegistrationDelegate+is%3Aclosed+label%3A%22status%3A+declined%22\n\n\t\t// Invoke BeanDefinitionRegistryPostProcessors first, if any.\n\t\tSet<String> processedBeans = new HashSet<>();\n\n\t\tif (beanFactory instanceof BeanDefinitionRegistry registry) {\n\t\t\tList<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();\n\t\t\tList<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();\n\n\t\t\tfor (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {\n\t\t\t\tif (postProcessor instanceof BeanDefinitionRegistryPostProcessor registryProcessor) {\n\t\t\t\t\tregistryProcessor.postProcessBeanDefinitionRegistry(registry);\n\t\t\t\t\tregistryProcessors.add(registryProcessor);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tregularPostProcessors.add(postProcessor);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans\n\t\t\t// uninitialized to let the bean factory post-processors apply to them!\n\t\t\t// Separate between BeanDefinitionRegistryPostProcessors that implement\n\t\t\t// PriorityOrdered, Ordered, and the rest.\n\t\t\tList<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();\n\n\t\t\t// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.\n\t\t\tString[] postProcessorNames =\n\t\t\t\t\tbeanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n\t\t\tfor (String ppName : postProcessorNames) {\n\t\t\t\tif (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n\t\t\t\t\tprocessedBeans.add(ppName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);\n\t\t\tregistryProcessors.addAll(currentRegistryProcessors);\n\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());\n\t\t\tcurrentRegistryProcessors.clear();\n\n\t\t\t// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.\n\t\t\tpostProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n\t\t\tfor (String ppName : postProcessorNames) {\n\t\t\t\tif (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {\n\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n\t\t\t\t\tprocessedBeans.add(ppName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);\n\t\t\tregistryProcessors.addAll(currentRegistryProcessors);\n\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());\n\t\t\tcurrentRegistryProcessors.clear();\n\n\t\t\t// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.\n\t\t\tboolean reiterate = true;\n\t\t\twhile (reiterate) {\n\t\t\t\treiterate = false;\n\t\t\t\tpostProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n\t\t\t\tfor (String ppName : postProcessorNames) {\n\t\t\t\t\tif (!processedBeans.contains(ppName)) {\n\t\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n\t\t\t\t\t\tprocessedBeans.add(ppName);\n\t\t\t\t\t\treiterate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);\n\t\t\t\tregistryProcessors.addAll(currentRegistryProcessors);\n\t\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());\n\t\t\t\tcurrentRegistryProcessors.clear();\n\t\t\t}\n\n\t\t\t// Now, invoke the postProcessBeanFactory callback of all processors handled so far.\n\t\t\tinvokeBeanFactoryPostProcessors(registryProcessors, beanFactory);\n\t\t\tinvokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);\n\t\t}\n\n\t\telse {\n\t\t\t// Invoke factory processors registered with the context instance.\n\t\t\tinvokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);\n\t\t}\n\n\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans\n\t\t// uninitialized to let the bean factory post-processors apply to them!\n\t\tString[] postProcessorNames =\n\t\t\t\tbeanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);\n\n\t\t// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,\n\t\t// Ordered, and the rest.\n\t\tList<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();\n\t\tList<String> orderedPostProcessorNames = new ArrayList<>();\n\t\tList<String> nonOrderedPostProcessorNames = new ArrayList<>();\n\t\tfor (String ppName : postProcessorNames) {\n\t\t\tif (processedBeans.contains(ppName)) {\n\t\t\t\t// skip - already processed in first phase above\n\t\t\t}\n\t\t\telse if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n\t\t\t\tpriorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\n\t\t\t}\n\t\t\telse if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n\t\t\t\torderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnonOrderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t}\n\n\t\t// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.\n\t\tsortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\t\tinvokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\n\t\t// Next, invoke the BeanFactoryPostProcessors that implement Ordered.\n\t\tList<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());\n\t\tfor (String postProcessorName : orderedPostProcessorNames) {\n\t\t\torderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n\t\t}\n\t\tsortPostProcessors(orderedPostProcessors, beanFactory);\n\t\tinvokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);\n\n\t\t// Finally, invoke all other BeanFactoryPostProcessors.\n\t\tList<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());\n\t\tfor (String postProcessorName : nonOrderedPostProcessorNames) {\n\t\t\tnonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n\t\t}\n\t\tinvokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);\n\n\t\t// Clear cached merged bean definitions since the post-processors might have\n\t\t// modified the original metadata, e.g. replacing placeholders in values...\n\t\tbeanFactory.clearMetadataCache();\n\t}"
  },
  "org.springframework.context.support.<unknown>#invokeMethod(name,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "Object",
    "signature": "public Object invokeMethod(String name, Object args)",
    "source_code": "\tpublic Object invokeMethod(String name, Object args) {\n\t\treturn this.metaClass.invokeMethod(this, name, args);\n\t}"
  },
  "org.springframework.context.support.<unknown>#isTypeMatch(name,typeToMatch)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "typeToMatch"
    ],
    "position": {
      "column": 1,
      "line": 1195
    },
    "return": "boolean",
    "signature": "public boolean isTypeMatch(String name, Class<?> typeToMatch)",
    "source_code": "\tpublic boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException {\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().isTypeMatch(name, typeToMatch);\n\t}"
  },
  "org.springframework.context.support.<unknown>#load(relativeClass,resourceNames)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Load bean definitions from the given Groovy scripts or XML files.\n\t * <p>Note that \".xml\" files will be parsed as XML content; all other kinds\n\t * of resources will be parsed as Groovy scripts.\n\t * @param relativeClass class whose package will be used as a prefix when\n\t * loading each specified resource name\n\t * @param resourceNames relatively-qualified names of resources to load\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativeClass",
      "resourceNames"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "void",
    "signature": "public void load(Class<?> relativeClass, String... resourceNames)",
    "source_code": "\tpublic void load(Class<?> relativeClass, String... resourceNames) {\n\t\tResource[] resources = new Resource[resourceNames.length];\n\t\tfor (int i = 0; i < resourceNames.length; i++) {\n\t\t\tresources[i] = new ClassPathResource(resourceNames[i], relativeClass);\n\t\t}\n\t\tload(resources);\n\t}"
  },
  "org.springframework.context.support.<unknown>#loadProperties(resource,filename)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Load the properties from the given resource.\n\t * @param resource the resource to load from\n\t * @param filename the original bundle filename (basename + Locale)\n\t * @return the populated Properties instance\n\t * @throws IOException if properties loading failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resource",
      "filename"
    ],
    "position": {
      "column": 1,
      "line": 472
    },
    "return": "Properties",
    "signature": "protected Properties loadProperties(Resource resource, String filename)",
    "source_code": "\tprotected Properties loadProperties(Resource resource, String filename) throws IOException {\n\t\tProperties props = newProperties();\n\t\ttry (InputStream is = resource.getInputStream()) {\n\t\t\tString resourceFilename = resource.getFilename();\n\t\t\tif (resourceFilename != null && resourceFilename.endsWith(XML_SUFFIX)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Loading properties [\" + resource.getFilename() + \"]\");\n\t\t\t\t}\n\t\t\t\tthis.propertiesPersister.loadFromXml(props, is);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString encoding = null;\n\t\t\t\tif (this.fileEncodings != null) {\n\t\t\t\t\tencoding = this.fileEncodings.getProperty(filename);\n\t\t\t\t}\n\t\t\t\tif (encoding == null) {\n\t\t\t\t\tencoding = getDefaultEncoding();\n\t\t\t\t}\n\t\t\t\tif (encoding != null) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Loading properties [\" + resource.getFilename() + \"] with encoding '\" + encoding + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tthis.propertiesPersister.load(props, new InputStreamReader(is, encoding));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Loading properties [\" + resource.getFilename() + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tthis.propertiesPersister.load(props, is);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn props;\n\t\t}\n\t}"
  },
  "org.springframework.context.support.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 405
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\t\tpublic Object postProcessAfterInitialization(Object bean, String beanName) {\n\t\t\tif (!(bean instanceof BeanPostProcessor) && !isInfrastructureBean(beanName) &&\n\t\t\t\t\tthis.beanFactory.getBeanPostProcessorCount() < this.beanPostProcessorTargetCount) {\n\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"Bean '\" + beanName + \"' of type [\" + bean.getClass().getName() +\n\t\t\t\t\t\t\t\"] is not eligible for getting processed by all BeanPostProcessors \" +\n\t\t\t\t\t\t\t\"(for example: not eligible for auto-proxying)\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn bean;\n\t\t}"
  },
  "org.springframework.context.support.<unknown>#postProcessBeforeDestruction(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void postProcessBeforeDestruction(Object bean, String beanName)",
    "source_code": "\tpublic void postProcessBeforeDestruction(Object bean, String beanName) {\n\t\tif (bean instanceof ApplicationListener<?> applicationListener) {\n\t\t\ttry {\n\t\t\t\tApplicationEventMulticaster multicaster = this.applicationContext.getApplicationEventMulticaster();\n\t\t\t\tmulticaster.removeApplicationListener(applicationListener);\n\t\t\t\tmulticaster.removeApplicationListenerBean(beanName);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t// ApplicationEventMulticaster not initialized yet - no need to remove a listener\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.support.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 400
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\t\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) {\n\t\t\treturn bean;\n\t\t}"
  },
  "org.springframework.context.support.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t\tif (ApplicationListener.class.isAssignableFrom(beanType)) {\n\t\t\tthis.singletonNames.put(beanName, beanDefinition.isSingleton());\n\t\t}\n\t}"
  },
  "org.springframework.context.support.<unknown>#processProperties(beanFactory,props)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Implemented for compatibility with\n\t * {@link org.springframework.beans.factory.config.PlaceholderConfigurerSupport}.\n\t * @throws UnsupportedOperationException in this implementation\n\t * @deprecated in favor of\n\t * {@link #processProperties(ConfigurableListableBeanFactory, ConfigurablePropertyResolver)}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactory",
      "props"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "protected void processProperties(ConfigurableListableBeanFactory beanFactory, Properties props)",
    "source_code": "\tprotected void processProperties(ConfigurableListableBeanFactory beanFactory, Properties props) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"Call processProperties(ConfigurableListableBeanFactory, ConfigurablePropertyResolver) instead\");\n\t}"
  },
  "org.springframework.context.support.<unknown>#processProperties(beanFactoryToProcess,propertyResolver)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Visit each bean definition in the given bean factory and attempt to replace ${...} property\n\t * placeholders with values from the given properties.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactoryToProcess",
      "propertyResolver"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "void",
    "signature": "protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess,\n\t\t\tfinal ConfigurablePropertyResolver propertyResolver)",
    "source_code": "\tprotected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess,\n\t\t\tfinal ConfigurablePropertyResolver propertyResolver) throws BeansException {\n\n\t\tpropertyResolver.setPlaceholderPrefix(this.placeholderPrefix);\n\t\tpropertyResolver.setPlaceholderSuffix(this.placeholderSuffix);\n\t\tpropertyResolver.setValueSeparator(this.valueSeparator);\n\n\t\tStringValueResolver valueResolver = strVal -> {\n\t\t\tString resolved = (this.ignoreUnresolvablePlaceholders ?\n\t\t\t\t\tpropertyResolver.resolvePlaceholders(strVal) :\n\t\t\t\t\tpropertyResolver.resolveRequiredPlaceholders(strVal));\n\t\t\tif (this.trimValues) {\n\t\t\t\tresolved = resolved.trim();\n\t\t\t}\n\t\t\treturn (resolved.equals(this.nullValue) ? null : resolved);\n\t\t};\n\n\t\tdoProcessProperties(beanFactoryToProcess, valueResolver);\n\t}"
  },
  "org.springframework.context.support.<unknown>#publishEvent(event,eventType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Publish the given event to all listeners.\n\t * @param event the event to publish (may be an {@link ApplicationEvent}\n\t * or a payload object to be turned into a {@link PayloadApplicationEvent})\n\t * @param eventType the resolved event type, if known\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "event",
      "eventType"
    ],
    "position": {
      "column": 1,
      "line": 393
    },
    "return": "void",
    "signature": "protected void publishEvent(Object event, @Nullable ResolvableType eventType)",
    "source_code": "\tprotected void publishEvent(Object event, @Nullable ResolvableType eventType) {\n\t\tAssert.notNull(event, \"Event must not be null\");\n\n\t\t// Decorate event as an ApplicationEvent if necessary\n\t\tApplicationEvent applicationEvent;\n\t\tif (event instanceof ApplicationEvent applEvent) {\n\t\t\tapplicationEvent = applEvent;\n\t\t}\n\t\telse {\n\t\t\tapplicationEvent = new PayloadApplicationEvent<>(this, event, eventType);\n\t\t\tif (eventType == null) {\n\t\t\t\teventType = ((PayloadApplicationEvent<?>) applicationEvent).getResolvableType();\n\t\t\t}\n\t\t}\n\n\t\t// Multicast right now if possible - or lazily once the multicaster is initialized\n\t\tif (this.earlyApplicationEvents != null) {\n\t\t\tthis.earlyApplicationEvents.add(applicationEvent);\n\t\t}\n\t\telse {\n\t\t\tgetApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);\n\t\t}\n\n\t\t// Publish event via parent context as well...\n\t\tif (this.parent != null) {\n\t\t\tif (this.parent instanceof AbstractApplicationContext abstractApplicationContext) {\n\t\t\t\tabstractApplicationContext.publishEvent(event, eventType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.parent.publishEvent(event);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.support.<unknown>#refreshProperties(filename,propHolder)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Refresh the PropertiesHolder for the given bundle filename.\n\t * The holder can be {@code null} if not cached before, or a timed-out cache entry\n\t * (potentially getting re-validated against the current last-modified timestamp).\n\t * @param filename the bundle filename (basename + Locale)\n\t * @param propHolder the current PropertiesHolder for the bundle\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "filename",
      "propHolder"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "PropertiesHolder",
    "signature": "protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder)",
    "source_code": "\tprotected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder) {\n\t\tlong refreshTimestamp = (getCacheMillis() < 0 ? -1 : System.currentTimeMillis());\n\n\t\tResource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX);\n\t\tif (!resource.exists()) {\n\t\t\tresource = this.resourceLoader.getResource(filename + XML_SUFFIX);\n\t\t}\n\n\t\tif (resource.exists()) {\n\t\t\tlong fileTimestamp = -1;\n\t\t\tif (getCacheMillis() >= 0) {\n\t\t\t\t// Last-modified timestamp of file will just be read if caching with timeout.\n\t\t\t\ttry {\n\t\t\t\t\tfileTimestamp = resource.lastModified();\n\t\t\t\t\tif (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Re-caching properties for filename [\" + filename + \"] - file hasn't been modified\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpropHolder.setRefreshTimestamp(refreshTimestamp);\n\t\t\t\t\t\treturn propHolder;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t// Probably a class path resource: cache it forever.\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(resource + \" could not be resolved in the file system - assuming that it hasn't changed\", ex);\n\t\t\t\t\t}\n\t\t\t\t\tfileTimestamp = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tProperties props = loadProperties(resource, filename);\n\t\t\t\tpropHolder = new PropertiesHolder(props, fileTimestamp);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Could not parse properties file [\" + resource.getFilename() + \"]\", ex);\n\t\t\t\t}\n\t\t\t\t// Empty holder representing \"not valid\".\n\t\t\t\tpropHolder = new PropertiesHolder();\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\t// Resource does not exist.\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"No properties file found for [\" + filename + \"] - neither plain properties nor XML\");\n\t\t\t}\n\t\t\t// Empty holder representing \"not found\".\n\t\t\tpropHolder = new PropertiesHolder();\n\t\t}\n\n\t\tpropHolder.setRefreshTimestamp(refreshTimestamp);\n\t\tthis.cachedProperties.put(filename, propHolder);\n\t\treturn propHolder;\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerAlias(beanName,alias)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "alias"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "void",
    "signature": "public void registerAlias(String beanName, String alias)",
    "source_code": "\tpublic void registerAlias(String beanName, String alias) {\n\t\tthis.beanFactory.registerAlias(beanName, alias);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanClass,constructorArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, optionally providing explicit\n\t * constructor arguments for consideration in the autowiring process.\n\t * @param beanClass the class of the bean\n\t * @param constructorArgs custom argument values to be fed into Spring's\n\t * constructor resolution algorithm, resolving either all arguments or just\n\t * specific ones, with the rest to be resolved through regular autowiring\n\t * (may be {@code null} or empty)\n\t * @since 5.2 (since 5.0 on the AnnotationConfigApplicationContext subclass)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "constructorArgs"
    ],
    "position": {
      "column": 1,
      "line": 456
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, Object... constructorArgs)",
    "source_code": "\tpublic <T> void registerBean(Class<T> beanClass, Object... constructorArgs) {\n\t\tregisterBean(null, beanClass, constructorArgs);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanClass,customizers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, optionally customizing its\n\t * bean definition metadata (typically declared as a lambda expression).\n\t * @param beanClass the class of the bean (resolving a public constructor\n\t * to be autowired, possibly simply the default constructor)\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.0\n\t * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 490
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, BeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic final <T> void registerBean(Class<T> beanClass, BeanDefinitionCustomizer... customizers) {\n\t\tregisterBean(null, beanClass, null, customizers);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanClass,supplier,customizers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, using the given supplier for\n\t * obtaining a new instance (typically declared as a lambda expression or\n\t * method reference), optionally customizing its bean definition metadata\n\t * (again typically declared as a lambda expression).\n\t * @param beanClass the class of the bean\n\t * @param supplier a callback for creating an instance of the bean\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.0\n\t * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "supplier",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 523
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, Supplier<T> supplier, BeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic final <T> void registerBean(\n\t\t\tClass<T> beanClass, Supplier<T> supplier, BeanDefinitionCustomizer... customizers) {\n\n\t\tregisterBean(null, beanClass, supplier, customizers);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanName,beanClass,constructorArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, optionally providing explicit\n\t * constructor arguments for consideration in the autowiring process.\n\t * @param beanName the name of the bean (may be {@code null})\n\t * @param beanClass the class of the bean\n\t * @param constructorArgs custom argument values to be fed into Spring's\n\t * constructor resolution algorithm, resolving either all arguments or just\n\t * specific ones, with the rest to be resolved through regular autowiring\n\t * (may be {@code null} or empty)\n\t * @since 5.2 (since 5.0 on the AnnotationConfigApplicationContext subclass)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanClass",
      "constructorArgs"
    ],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "void",
    "signature": "public void registerBean(@Nullable String beanName, Class<T> beanClass, Object... constructorArgs)",
    "source_code": "\tpublic <T> void registerBean(@Nullable String beanName, Class<T> beanClass, Object... constructorArgs) {\n\t\tregisterBean(beanName, beanClass, (Supplier<T>) null,\n\t\t\t\tbd -> {\n\t\t\t\t\tfor (Object arg : constructorArgs) {\n\t\t\t\t\t\tbd.getConstructorArgumentValues().addGenericArgumentValue(arg);\n\t\t\t\t\t}\n\t\t\t\t});\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanName,beanClass,customizers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, optionally customizing its\n\t * bean definition metadata (typically declared as a lambda expression).\n\t * @param beanName the name of the bean (may be {@code null})\n\t * @param beanClass the class of the bean (resolving a public constructor\n\t * to be autowired, possibly simply the default constructor)\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.0\n\t * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanClass",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 505
    },
    "return": "void",
    "signature": "public void registerBean(@Nullable String beanName, Class<T> beanClass, BeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic final <T> void registerBean(\n\t\t\t@Nullable String beanName, Class<T> beanClass, BeanDefinitionCustomizer... customizers) {\n\n\t\tregisterBean(beanName, beanClass, null, customizers);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanName,beanClass,supplier,customizers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, using the given supplier for\n\t * obtaining a new instance (typically declared as a lambda expression or\n\t * method reference), optionally customizing its bean definition metadata\n\t * (again typically declared as a lambda expression).\n\t * <p>This method can be overridden to adapt the registration mechanism for\n\t * all {@code registerBean} methods (since they all delegate to this one).\n\t * @param beanName the name of the bean (may be {@code null})\n\t * @param beanClass the class of the bean\n\t * @param supplier a callback for creating an instance of the bean (in case\n\t * of {@code null}, resolving a public constructor to be autowired instead)\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanClass",
      "supplier",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "void",
    "signature": "public void registerBean(@Nullable String beanName, Class<T> beanClass,\n\t\t\t@Nullable Supplier<T> supplier, BeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic <T> void registerBean(@Nullable String beanName, Class<T> beanClass,\n\t\t\t@Nullable Supplier<T> supplier, BeanDefinitionCustomizer... customizers) {\n\n\t\tClassDerivedBeanDefinition beanDefinition = new ClassDerivedBeanDefinition(beanClass);\n\t\tif (supplier != null) {\n\t\t\tbeanDefinition.setInstanceSupplier(supplier);\n\t\t}\n\t\tfor (BeanDefinitionCustomizer customizer : customizers) {\n\t\t\tcustomizer.customize(beanDefinition);\n\t\t}\n\n\t\tString nameToUse = (beanName != null ? beanName : beanClass.getName());\n\t\tregisterBeanDefinition(nameToUse, beanDefinition);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBeanDefinition(beanName,beanDefinition)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "void",
    "signature": "public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)",
    "source_code": "\tpublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\tthis.beanFactory.registerBeanDefinition(beanName, beanDefinition);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBeanPostProcessors(beanFactory,applicationContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "void",
    "signature": "public void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)",
    "source_code": "\tpublic static void registerBeanPostProcessors(\n\t\t\tConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {\n\n\t\t// WARNING: Although it may appear that the body of this method can be easily\n\t\t// refactored to avoid the use of multiple loops and multiple lists, the use\n\t\t// of multiple lists and multiple passes over the names of processors is\n\t\t// intentional. We must ensure that we honor the contracts for PriorityOrdered\n\t\t// and Ordered processors. Specifically, we must NOT cause processors to be\n\t\t// instantiated (via getBean() invocations) or registered in the ApplicationContext\n\t\t// in the wrong order.\n\t\t//\n\t\t// Before submitting a pull request (PR) to change this method, please review the\n\t\t// list of all declined PRs involving changes to PostProcessorRegistrationDelegate\n\t\t// to ensure that your proposal does not result in a breaking change:\n\t\t// https://github.com/spring-projects/spring-framework/issues?q=PostProcessorRegistrationDelegate+is%3Aclosed+label%3A%22status%3A+declined%22\n\n\t\tString[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);\n\n\t\t// Register BeanPostProcessorChecker that logs an info message when\n\t\t// a bean is created during BeanPostProcessor instantiation, i.e. when\n\t\t// a bean is not eligible for getting processed by all BeanPostProcessors.\n\t\tint beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;\n\t\tbeanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));\n\n\t\t// Separate between BeanPostProcessors that implement PriorityOrdered,\n\t\t// Ordered, and the rest.\n\t\tList<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();\n\t\tList<BeanPostProcessor> internalPostProcessors = new ArrayList<>();\n\t\tList<String> orderedPostProcessorNames = new ArrayList<>();\n\t\tList<String> nonOrderedPostProcessorNames = new ArrayList<>();\n\t\tfor (String ppName : postProcessorNames) {\n\t\t\tif (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n\t\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\t\tpriorityOrderedPostProcessors.add(pp);\n\t\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n\t\t\t\torderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnonOrderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t}\n\n\t\t// First, register the BeanPostProcessors that implement PriorityOrdered.\n\t\tsortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);\n\n\t\t// Next, register the BeanPostProcessors that implement Ordered.\n\t\tList<BeanPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());\n\t\tfor (String ppName : orderedPostProcessorNames) {\n\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\torderedPostProcessors.add(pp);\n\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t}\n\t\t}\n\t\tsortPostProcessors(orderedPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, orderedPostProcessors);\n\n\t\t// Now, register all regular BeanPostProcessors.\n\t\tList<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());\n\t\tfor (String ppName : nonOrderedPostProcessorNames) {\n\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\tnonOrderedPostProcessors.add(pp);\n\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t}\n\t\t}\n\t\tregisterBeanPostProcessors(beanFactory, nonOrderedPostProcessors);\n\n\t\t// Finally, re-register all internal BeanPostProcessors.\n\t\tsortPostProcessors(internalPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, internalPostProcessors);\n\n\t\t// Re-register post-processor for detecting inner beans as ApplicationListeners,\n\t\t// moving it to the end of the processor chain (for picking up proxies etc).\n\t\tbeanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));\n\t}"
  },
  "org.springframework.context.support.<unknown>#resolveArguments(args,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Searches through the given array of objects, finds any MessageSourceResolvable\n\t * objects and resolves them.\n\t * <p>Allows for messages to have MessageSourceResolvables as arguments.\n\t * @param args array of arguments for a message\n\t * @param locale the locale to resolve through\n\t * @return an array of arguments with any MessageSourceResolvables resolved\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "Object[]",
    "signature": "protected Object[] resolveArguments(@Nullable Object[] args, Locale locale)",
    "source_code": "\tprotected Object[] resolveArguments(@Nullable Object[] args, Locale locale) {\n\t\tif (ObjectUtils.isEmpty(args)) {\n\t\t\treturn super.resolveArguments(args, locale);\n\t\t}\n\t\tList<Object> resolvedArgs = new ArrayList<>(args.length);\n\t\tfor (Object arg : args) {\n\t\t\tif (arg instanceof MessageSourceResolvable messageSourceResolvable) {\n\t\t\t\tresolvedArgs.add(getMessage(messageSourceResolvable, locale));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresolvedArgs.add(arg);\n\t\t\t}\n\t\t}\n\t\treturn resolvedArgs.toArray();\n\t}"
  },
  "org.springframework.context.support.<unknown>#resolveCode(code,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses must implement this method to resolve a message.\n\t * <p>Returns a MessageFormat instance rather than a message String,\n\t * to allow for appropriate caching of MessageFormats in subclasses.\n\t * <p><b>Subclasses are encouraged to provide optimized resolution\n\t * for messages without arguments, not involving MessageFormat.</b>\n\t * See the {@link #resolveCodeWithoutArguments} javadoc for details.\n\t * @param code the code of the message to resolve\n\t * @param locale the locale to resolve the code for\n\t * (subclasses are encouraged to support internationalization)\n\t * @return the MessageFormat for the message, or {@code null} if not found\n\t * @see #resolveCodeWithoutArguments(String, java.util.Locale)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "MessageFormat",
    "signature": "protected MessageFormat resolveCode(String code, Locale locale)",
    "source_code": "\tprotected abstract MessageFormat resolveCode(String code, Locale locale);"
  },
  "org.springframework.context.support.<unknown>#resolveCodeWithoutArguments(code,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can override this method to resolve a message without arguments\n\t * in an optimized fashion, i.e. to resolve without involving a MessageFormat.\n\t * <p>The default implementation <i>does</i> use MessageFormat, through\n\t * delegating to the {@link #resolveCode} method. Subclasses are encouraged\n\t * to replace this with optimized resolution.\n\t * <p>Unfortunately, {@code java.text.MessageFormat} is not implemented\n\t * in an efficient fashion. In particular, it does not detect that a message\n\t * pattern doesn't contain argument placeholders in the first place. Therefore,\n\t * it is advisable to circumvent MessageFormat for messages without arguments.\n\t * @param code the code of the message to resolve\n\t * @param locale the locale to resolve the code for\n\t * (subclasses are encouraged to support internationalization)\n\t * @return the message String, or {@code null} if not found\n\t * @see #resolveCode\n\t * @see java.text.MessageFormat\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 367
    },
    "return": "String",
    "signature": "protected String resolveCodeWithoutArguments(String code, Locale locale)",
    "source_code": "\tprotected String resolveCodeWithoutArguments(String code, Locale locale) {\n\t\tMessageFormat messageFormat = resolveCode(code, locale);\n\t\tif (messageFormat != null) {\n\t\t\tsynchronized (messageFormat) {\n\t\t\t\treturn messageFormat.format(new Object[0]);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.support.<unknown>#setProperty(property,newValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "property",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "void",
    "signature": "public void setProperty(String property, Object newValue)",
    "source_code": "\tpublic void setProperty(String property, Object newValue) {\n\t\tif (newValue instanceof BeanDefinition beanDefinition) {\n\t\t\tregisterBeanDefinition(property, beanDefinition);\n\t\t}\n\t\telse {\n\t\t\tthis.metaClass.setProperty(this, property, newValue);\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#compare(o1,o2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o1",
      "o2"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "int",
    "signature": "public int compare(@Nullable Object o1, @Nullable Object o2)",
    "source_code": "\tpublic int compare(@Nullable Object o1, @Nullable Object o2) {\n\t\treturn doCompare(o1, o2, null);\n\t}"
  },
  "org.springframework.core.<unknown>#createApproximateCollection(collection,capacity)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the most approximate collection for the given collection.\n\t * <p><strong>Warning</strong>: Since the parameterized type {@code E} is\n\t * not bound to the type of elements contained in the supplied\n\t * {@code collection}, type safety cannot be guaranteed if the supplied\n\t * {@code collection} is an {@link EnumSet}. In such scenarios, the caller\n\t * is responsible for ensuring that the element type for the supplied\n\t * {@code collection} is an enum type matching type {@code E}. As an\n\t * alternative, the caller may wish to treat the return value as a raw\n\t * collection or collection of {@link Object}.\n\t * @param collection the original collection object, potentially {@code null}\n\t * @param capacity the initial capacity\n\t * @return a new, empty collection instance\n\t * @see #isApproximableCollectionType\n\t * @see java.util.LinkedList\n\t * @see java.util.ArrayList\n\t * @see java.util.EnumSet\n\t * @see java.util.TreeSet\n\t * @see java.util.LinkedHashSet\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "Collection<E>",
    "signature": "public Collection<E> createApproximateCollection(@Nullable Object collection, int capacity)",
    "source_code": "\tpublic static <E> Collection<E> createApproximateCollection(@Nullable Object collection, int capacity) {\n\t\tif (collection instanceof LinkedList) {\n\t\t\treturn new LinkedList<>();\n\t\t}\n\t\telse if (collection instanceof List) {\n\t\t\treturn new ArrayList<>(capacity);\n\t\t}\n\t\telse if (collection instanceof EnumSet enumSet) {\n\t\t\tCollection<E> copy = EnumSet.copyOf(enumSet);\n\t\t\tcopy.clear();\n\t\t\treturn copy;\n\t\t}\n\t\telse if (collection instanceof SortedSet sortedSet) {\n\t\t\treturn new TreeSet<>(sortedSet.comparator());\n\t\t}\n\t\telse {\n\t\t\treturn new LinkedHashSet<>(capacity);\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#createApproximateMap(map,capacity)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the most approximate map for the given map.\n\t * <p><strong>Warning</strong>: Since the parameterized type {@code K} is\n\t * not bound to the type of keys contained in the supplied {@code map},\n\t * type safety cannot be guaranteed if the supplied {@code map} is an\n\t * {@link EnumMap}. In such scenarios, the caller is responsible for\n\t * ensuring that the key type in the supplied {@code map} is an enum type\n\t * matching type {@code K}. As an alternative, the caller may wish to\n\t * treat the return value as a raw map or map keyed by {@link Object}.\n\t * @param map the original map object, potentially {@code null}\n\t * @param capacity the initial capacity\n\t * @return a new, empty map instance\n\t * @see #isApproximableMapType\n\t * @see java.util.EnumMap\n\t * @see java.util.TreeMap\n\t * @see java.util.LinkedHashMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "map",
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "V>",
    "signature": "public V> createApproximateMap(@Nullable Object map, int capacity)",
    "source_code": "\tpublic static <K, V> Map<K, V> createApproximateMap(@Nullable Object map, int capacity) {\n\t\tif (map instanceof EnumMap enumMap) {\n\t\t\tEnumMap copy = new EnumMap(enumMap);\n\t\t\tcopy.clear();\n\t\t\treturn copy;\n\t\t}\n\t\telse if (map instanceof SortedMap sortedMap) {\n\t\t\treturn new TreeMap<>(sortedMap.comparator());\n\t\t}\n\t\telse {\n\t\t\treturn new LinkedHashMap<>(capacity);\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#createCollection(collectionType,capacity)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the most appropriate collection for the given collection type.\n\t * <p>Delegates to {@link #createCollection(Class, Class, int)} with a\n\t * {@code null} element type.\n\t * @param collectionType the desired type of the target collection (never {@code null})\n\t * @param capacity the initial capacity\n\t * @return a new collection instance\n\t * @throws IllegalArgumentException if the supplied {@code collectionType}\n\t * is {@code null} or of type {@link EnumSet}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collectionType",
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "Collection<E>",
    "signature": "public Collection<E> createCollection(Class<?> collectionType, int capacity)",
    "source_code": "\tpublic static <E> Collection<E> createCollection(Class<?> collectionType, int capacity) {\n\t\treturn createCollection(collectionType, null, capacity);\n\t}"
  },
  "org.springframework.core.<unknown>#createCollection(collectionType,elementType,capacity)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the most appropriate collection for the given collection type.\n\t * <p><strong>Warning</strong>: Since the parameterized type {@code E} is\n\t * not bound to the supplied {@code elementType}, type safety cannot be\n\t * guaranteed if the desired {@code collectionType} is {@link EnumSet}.\n\t * In such scenarios, the caller is responsible for ensuring that the\n\t * supplied {@code elementType} is an enum type matching type {@code E}.\n\t * As an alternative, the caller may wish to treat the return value as a\n\t * raw collection or collection of {@link Object}.\n\t * @param collectionType the desired type of the target collection (never {@code null})\n\t * @param elementType the collection's element type, or {@code null} if unknown\n\t * (note: only relevant for {@link EnumSet} creation)\n\t * @param capacity the initial capacity\n\t * @return a new collection instance\n\t * @throws IllegalArgumentException if the supplied {@code collectionType} is\n\t * {@code null}; or if the desired {@code collectionType} is {@link EnumSet} and\n\t * the supplied {@code elementType} is not a subtype of {@link Enum}\n\t * @since 4.1.3\n\t * @see java.util.LinkedHashSet\n\t * @see java.util.ArrayList\n\t * @see java.util.TreeSet\n\t * @see java.util.EnumSet\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collectionType",
      "elementType",
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "Collection<E>",
    "signature": "public Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity)",
    "source_code": "\tpublic static <E> Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity) {\n\t\tAssert.notNull(collectionType, \"Collection type must not be null\");\n\t\tif (LinkedHashSet.class == collectionType || HashSet.class == collectionType ||\n\t\t\t\tSet.class == collectionType || Collection.class == collectionType) {\n\t\t\treturn new LinkedHashSet<>(capacity);\n\t\t}\n\t\telse if (ArrayList.class == collectionType || List.class == collectionType) {\n\t\t\treturn new ArrayList<>(capacity);\n\t\t}\n\t\telse if (LinkedList.class == collectionType) {\n\t\t\treturn new LinkedList<>();\n\t\t}\n\t\telse if (TreeSet.class == collectionType || NavigableSet.class == collectionType\n\t\t\t\t|| SortedSet.class == collectionType) {\n\t\t\treturn new TreeSet<>();\n\t\t}\n\t\telse if (EnumSet.class.isAssignableFrom(collectionType)) {\n\t\t\tAssert.notNull(elementType, \"Cannot create EnumSet for unknown element type\");\n\t\t\treturn EnumSet.noneOf(asEnumType(elementType));\n\t\t}\n\t\telse {\n\t\t\tif (collectionType.isInterface() || !Collection.class.isAssignableFrom(collectionType)) {\n\t\t\t\tthrow new IllegalArgumentException(\"Unsupported Collection type: \" + collectionType.getName());\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn (Collection<E>) ReflectionUtils.accessibleConstructor(collectionType).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Could not instantiate Collection type: \" + collectionType.getName(), ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#createMap(mapType,capacity)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the most appropriate map for the given map type.\n\t * <p>Delegates to {@link #createMap(Class, Class, int)} with a\n\t * {@code null} key type.\n\t * @param mapType the desired type of the target map\n\t * @param capacity the initial capacity\n\t * @return a new map instance\n\t * @throws IllegalArgumentException if the supplied {@code mapType} is\n\t * {@code null} or of type {@link EnumMap}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapType",
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "V>",
    "signature": "public V> createMap(Class<?> mapType, int capacity)",
    "source_code": "\tpublic static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity) {\n\t\treturn createMap(mapType, null, capacity);\n\t}"
  },
  "org.springframework.core.<unknown>#createMap(mapType,keyType,capacity)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the most appropriate map for the given map type.\n\t * <p><strong>Warning</strong>: Since the parameterized type {@code K}\n\t * is not bound to the supplied {@code keyType}, type safety cannot be\n\t * guaranteed if the desired {@code mapType} is {@link EnumMap}. In such\n\t * scenarios, the caller is responsible for ensuring that the {@code keyType}\n\t * is an enum type matching type {@code K}. As an alternative, the caller\n\t * may wish to treat the return value as a raw map or map keyed by\n\t * {@link Object}. Similarly, type safety cannot be enforced if the\n\t * desired {@code mapType} is {@link MultiValueMap}.\n\t * @param mapType the desired type of the target map (never {@code null})\n\t * @param keyType the map's key type, or {@code null} if unknown\n\t * (note: only relevant for {@link EnumMap} creation)\n\t * @param capacity the initial capacity\n\t * @return a new map instance\n\t * @throws IllegalArgumentException if the supplied {@code mapType} is\n\t * {@code null}; or if the desired {@code mapType} is {@link EnumMap} and\n\t * the supplied {@code keyType} is not a subtype of {@link Enum}\n\t * @since 4.1.3\n\t * @see java.util.LinkedHashMap\n\t * @see java.util.TreeMap\n\t * @see org.springframework.util.LinkedMultiValueMap\n\t * @see java.util.EnumMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapType",
      "keyType",
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "V>",
    "signature": "public V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity)",
    "source_code": "\tpublic static <K, V> Map<K, V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity) {\n\t\tAssert.notNull(mapType, \"Map type must not be null\");\n\t\tif (mapType.isInterface()) {\n\t\t\tif (Map.class == mapType) {\n\t\t\t\treturn new LinkedHashMap<>(capacity);\n\t\t\t}\n\t\t\telse if (SortedMap.class == mapType || NavigableMap.class == mapType) {\n\t\t\t\treturn new TreeMap<>();\n\t\t\t}\n\t\t\telse if (MultiValueMap.class == mapType) {\n\t\t\t\treturn new LinkedMultiValueMap();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Unsupported Map interface: \" + mapType.getName());\n\t\t\t}\n\t\t}\n\t\telse if (EnumMap.class == mapType) {\n\t\t\tAssert.notNull(keyType, \"Cannot create EnumMap for unknown key type\");\n\t\t\treturn new EnumMap(asEnumType(keyType));\n\t\t}\n\t\telse {\n\t\t\tif (!Map.class.isAssignableFrom(mapType)) {\n\t\t\t\tthrow new IllegalArgumentException(\"Unsupported Map type: \" + mapType.getName());\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn (Map<K, V>) ReflectionUtils.accessibleConstructor(mapType).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalArgumentException(\"Could not instantiate Map type: \" + mapType.getName(), ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#createSortedProperties(properties,omitComments)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a variant of {@link java.util.Properties} that sorts properties\n\t * alphanumerically based on their keys.\n\t * <p>This can be useful when storing the {@code Properties} instance in a\n\t * properties file, since it allows such files to be generated in a repeatable\n\t * manner with consistent ordering of properties. Comments in generated\n\t * properties files can also be optionally omitted.\n\t * <p>The returned {@code Properties} instance will be populated with\n\t * properties from the supplied {@code properties} object, but default\n\t * properties from the supplied {@code properties} object will not be copied.\n\t * @param properties the {@code Properties} object from which to copy the\n\t * initial properties\n\t * @param omitComments {@code true} if comments should be omitted when\n\t * storing properties in a file\n\t * @return a new {@code Properties} instance\n\t * @since 5.2\n\t * @see #createStringAdaptingProperties()\n\t * @see #createSortedProperties(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "properties",
      "omitComments"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "Properties",
    "signature": "public Properties createSortedProperties(Properties properties, boolean omitComments)",
    "source_code": "\tpublic static Properties createSortedProperties(Properties properties, boolean omitComments) {\n\t\treturn new SortedProperties(properties, omitComments);\n\t}"
  },
  "org.springframework.core.<unknown>#forClass(baseType,implementationClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified base type\n\t * (interface or base class) with a given implementation class.\n\t * <p>For example: {@code ResolvableType.forClass(List.class, MyArrayList.class)}.\n\t * @param baseType the base type (must not be {@code null})\n\t * @param implementationClass the implementation class\n\t * @return a {@link ResolvableType} for the specified base type backed by the\n\t * given implementation class\n\t * @see #forClass(Class)\n\t * @see #forClassWithGenerics(Class, Class...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "baseType",
      "implementationClass"
    ],
    "position": {
      "column": 1,
      "line": 1046
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forClass(Class<?> baseType, Class<?> implementationClass)",
    "source_code": "\tpublic static ResolvableType forClass(Class<?> baseType, Class<?> implementationClass) {\n\t\tAssert.notNull(baseType, \"Base type must not be null\");\n\t\tResolvableType asType = forType(implementationClass).as(baseType);\n\t\treturn (asType == NONE ? forType(baseType) : asType);\n\t}"
  },
  "org.springframework.core.<unknown>#forClassWithGenerics(clazz,generics)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Class} with pre-declared generics.\n\t * @param clazz the class (or interface) to introspect\n\t * @param generics the generics of the class\n\t * @return a {@link ResolvableType} for the specific class and generics\n\t * @see #forClassWithGenerics(Class, Class...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "generics"
    ],
    "position": {
      "column": 1,
      "line": 1076
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forClassWithGenerics(Class<?> clazz, ResolvableType... generics)",
    "source_code": "\tpublic static ResolvableType forClassWithGenerics(Class<?> clazz, ResolvableType... generics) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(generics, \"Generics array must not be null\");\n\t\tTypeVariable<?>[] variables = clazz.getTypeParameters();\n\t\tAssert.isTrue(variables.length == generics.length, () -> \"Mismatched number of generics specified for \" + clazz.toGenericString());\n\n\t\tType[] arguments = new Type[generics.length];\n\t\tfor (int i = 0; i < generics.length; i++) {\n\t\t\tResolvableType generic = generics[i];\n\t\t\tType argument = (generic != null ? generic.getType() : null);\n\t\t\targuments[i] = (argument != null && !(argument instanceof TypeVariable) ? argument : variables[i]);\n\t\t}\n\n\t\tParameterizedType syntheticType = new SyntheticParameterizedType(clazz, arguments);\n\t\treturn forType(syntheticType, new TypeVariablesVariableResolver(variables, generics));\n\t}"
  },
  "org.springframework.core.<unknown>#forConstructorParameter(constructor,parameterIndex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Constructor} parameter.\n\t * @param constructor the source constructor (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @return a {@link ResolvableType} for the specified constructor parameter\n\t * @see #forConstructorParameter(Constructor, int, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constructor",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 1196
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex)",
    "source_code": "\tpublic static ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex) {\n\t\tAssert.notNull(constructor, \"Constructor must not be null\");\n\t\treturn forMethodParameter(new MethodParameter(constructor, parameterIndex));\n\t}"
  },
  "org.springframework.core.<unknown>#forConstructorParameter(constructor,parameterIndex,implementationClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Constructor} parameter\n\t * with a given implementation. Use this variant when the class that declares the\n\t * constructor includes generic parameter variables that are satisfied by the\n\t * implementation class.\n\t * @param constructor the source constructor (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @param implementationClass the implementation class\n\t * @return a {@link ResolvableType} for the specified constructor parameter\n\t * @see #forConstructorParameter(Constructor, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constructor",
      "parameterIndex",
      "implementationClass"
    ],
    "position": {
      "column": 1,
      "line": 1212
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex,\n\t\t\tClass<?> implementationClass)",
    "source_code": "\tpublic static ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex,\n\t\t\tClass<?> implementationClass) {\n\n\t\tAssert.notNull(constructor, \"Constructor must not be null\");\n\t\tMethodParameter methodParameter = new MethodParameter(constructor, parameterIndex, implementationClass);\n\t\treturn forMethodParameter(methodParameter);\n\t}"
  },
  "org.springframework.core.<unknown>#forExecutable(executable,parameterIndex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new MethodParameter for the given method or constructor.\n\t * <p>This is a convenience factory method for scenarios where a\n\t * Method or Constructor reference is treated in a generic fashion.\n\t * @param executable the Method or Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @return the corresponding MethodParameter instance\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executable",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 810
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter forExecutable(Executable executable, int parameterIndex)",
    "source_code": "\tpublic static MethodParameter forExecutable(Executable executable, int parameterIndex) {\n\t\tif (executable instanceof Method method) {\n\t\t\treturn new MethodParameter(method, parameterIndex);\n\t\t}\n\t\telse if (executable instanceof Constructor<?> constructor) {\n\t\t\treturn new MethodParameter(constructor, parameterIndex);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Not a Method/Constructor: \" + executable);\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#forField(field,implementationClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Field} with a given\n\t * implementation.\n\t * <p>Use this variant when the class that declares the field includes generic\n\t * parameter variables that are satisfied by the implementation class.\n\t * @param field the source field\n\t * @param implementationClass the implementation class\n\t * @return a {@link ResolvableType} for the specified field\n\t * @see #forField(Field)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "implementationClass"
    ],
    "position": {
      "column": 1,
      "line": 1135
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forField(Field field, Class<?> implementationClass)",
    "source_code": "\tpublic static ResolvableType forField(Field field, Class<?> implementationClass) {\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\tResolvableType owner = forType(implementationClass).as(field.getDeclaringClass());\n\t\treturn forType(null, new FieldTypeProvider(field), owner.asVariableResolver());\n\t}"
  },
  "org.springframework.core.<unknown>#forField(field,implementationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Field} with a given\n\t * implementation.\n\t * <p>Use this variant when the class that declares the field includes generic\n\t * parameter variables that are satisfied by the implementation type.\n\t * @param field the source field\n\t * @param implementationType the implementation type\n\t * @return a {@link ResolvableType} for the specified field\n\t * @see #forField(Field)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "implementationType"
    ],
    "position": {
      "column": 1,
      "line": 1151
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forField(Field field, @Nullable ResolvableType implementationType)",
    "source_code": "\tpublic static ResolvableType forField(Field field, @Nullable ResolvableType implementationType) {\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\tResolvableType owner = (implementationType != null ? implementationType : NONE);\n\t\towner = owner.as(field.getDeclaringClass());\n\t\treturn forType(null, new FieldTypeProvider(field), owner.asVariableResolver());\n\t}"
  },
  "org.springframework.core.<unknown>#forField(field,nestingLevel)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Field} with the\n\t * given nesting level.\n\t * @param field the source field\n\t * @param nestingLevel the nesting level (1 for the outer level; 2 for a nested\n\t * generic type; etc)\n\t * @see #forField(Field)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 1166
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forField(Field field, int nestingLevel)",
    "source_code": "\tpublic static ResolvableType forField(Field field, int nestingLevel) {\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\treturn forType(null, new FieldTypeProvider(field), null).getNested(nestingLevel);\n\t}"
  },
  "org.springframework.core.<unknown>#forField(field,nestingLevel,implementationClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Field} with a given\n\t * implementation and the given nesting level.\n\t * <p>Use this variant when the class that declares the field includes generic\n\t * parameter variables that are satisfied by the implementation class.\n\t * @param field the source field\n\t * @param nestingLevel the nesting level (1 for the outer level; 2 for a nested\n\t * generic type; etc)\n\t * @param implementationClass the implementation class\n\t * @return a {@link ResolvableType} for the specified field\n\t * @see #forField(Field)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "nestingLevel",
      "implementationClass"
    ],
    "position": {
      "column": 1,
      "line": 1183
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forField(Field field, int nestingLevel, @Nullable Class<?> implementationClass)",
    "source_code": "\tpublic static ResolvableType forField(Field field, int nestingLevel, @Nullable Class<?> implementationClass) {\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\tResolvableType owner = forType(implementationClass).as(field.getDeclaringClass());\n\t\treturn forType(null, new FieldTypeProvider(field), owner.asVariableResolver()).getNested(nestingLevel);\n\t}"
  },
  "org.springframework.core.<unknown>#forMethodOrConstructor(methodOrConstructor,parameterIndex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new MethodParameter for the given method or constructor.\n\t * <p>This is a convenience factory method for scenarios where a\n\t * Method or Constructor reference is treated in a generic fashion.\n\t * @param methodOrConstructor the Method or Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @return the corresponding MethodParameter instance\n\t * @deprecated as of 5.0, in favor of {@link #forExecutable}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodOrConstructor",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 793
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter forMethodOrConstructor(Object methodOrConstructor, int parameterIndex)",
    "source_code": "\tpublic static MethodParameter forMethodOrConstructor(Object methodOrConstructor, int parameterIndex) {\n\t\tif (!(methodOrConstructor instanceof Executable executable)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Given object [\" + methodOrConstructor + \"] is neither a Method nor a Constructor\");\n\t\t}\n\t\treturn forExecutable(executable, parameterIndex);\n\t}"
  },
  "org.springframework.core.<unknown>#forMethodParameter(method,parameterIndex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Method} parameter.\n\t * @param method the source method (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @return a {@link ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(Method, int, Class)\n\t * @see #forMethodParameter(MethodParameter)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 1254
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forMethodParameter(Method method, int parameterIndex)",
    "source_code": "\tpublic static ResolvableType forMethodParameter(Method method, int parameterIndex) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\treturn forMethodParameter(new MethodParameter(method, parameterIndex));\n\t}"
  },
  "org.springframework.core.<unknown>#forMethodParameter(method,parameterIndex,implementationClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Method} parameter with a\n\t * given implementation. Use this variant when the class that declares the method\n\t * includes generic parameter variables that are satisfied by the implementation class.\n\t * @param method the source method (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @param implementationClass the implementation class\n\t * @return a {@link ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(Method, int, Class)\n\t * @see #forMethodParameter(MethodParameter)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "parameterIndex",
      "implementationClass"
    ],
    "position": {
      "column": 1,
      "line": 1270
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forMethodParameter(Method method, int parameterIndex, Class<?> implementationClass)",
    "source_code": "\tpublic static ResolvableType forMethodParameter(Method method, int parameterIndex, Class<?> implementationClass) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tMethodParameter methodParameter = new MethodParameter(method, parameterIndex, implementationClass);\n\t\treturn forMethodParameter(methodParameter);\n\t}"
  },
  "org.springframework.core.<unknown>#forMethodParameter(methodParameter,implementationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link MethodParameter} with a\n\t * given implementation type. Use this variant when the class that declares the method\n\t * includes generic parameter variables that are satisfied by the implementation type.\n\t * @param methodParameter the source method parameter (must not be {@code null})\n\t * @param implementationType the implementation type\n\t * @return a {@link ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(MethodParameter)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodParameter",
      "implementationType"
    ],
    "position": {
      "column": 1,
      "line": 1295
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forMethodParameter(MethodParameter methodParameter,\n\t\t\t@Nullable ResolvableType implementationType)",
    "source_code": "\tpublic static ResolvableType forMethodParameter(MethodParameter methodParameter,\n\t\t\t@Nullable ResolvableType implementationType) {\n\n\t\tAssert.notNull(methodParameter, \"MethodParameter must not be null\");\n\t\timplementationType = (implementationType != null ? implementationType :\n\t\t\t\tforType(methodParameter.getContainingClass()));\n\t\tResolvableType owner = implementationType.as(methodParameter.getDeclaringClass());\n\t\treturn forType(null, new MethodParameterTypeProvider(methodParameter), owner.asVariableResolver()).\n\t\t\t\tgetNested(methodParameter.getNestingLevel(), methodParameter.typeIndexesPerLevel);\n\t}"
  },
  "org.springframework.core.<unknown>#forMethodParameter(methodParameter,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link MethodParameter},\n\t * overriding the target type to resolve with a specific given type.\n\t * @param methodParameter the source method parameter (must not be {@code null})\n\t * @param targetType the type to resolve (a part of the method parameter's type)\n\t * @return a {@link ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(Method, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodParameter",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 1314
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forMethodParameter(MethodParameter methodParameter, @Nullable Type targetType)",
    "source_code": "\tpublic static ResolvableType forMethodParameter(MethodParameter methodParameter, @Nullable Type targetType) {\n\t\tAssert.notNull(methodParameter, \"MethodParameter must not be null\");\n\t\treturn forMethodParameter(methodParameter, targetType, methodParameter.getNestingLevel());\n\t}"
  },
  "org.springframework.core.<unknown>#forMethodReturnType(method,implementationClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Method} return type.\n\t * <p>Use this variant when the class that declares the method includes generic\n\t * parameter variables that are satisfied by the implementation class.\n\t * @param method the source for the method return type\n\t * @param implementationClass the implementation class\n\t * @return a {@link ResolvableType} for the specified method return\n\t * @see #forMethodReturnType(Method)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "implementationClass"
    ],
    "position": {
      "column": 1,
      "line": 1240
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forMethodReturnType(Method method, Class<?> implementationClass)",
    "source_code": "\tpublic static ResolvableType forMethodReturnType(Method method, Class<?> implementationClass) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tMethodParameter methodParameter = new MethodParameter(method, -1, implementationClass);\n\t\treturn forMethodParameter(methodParameter);\n\t}"
  },
  "org.springframework.core.<unknown>#forType(type,owner)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Type} backed by the given\n\t * owner type.\n\t * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}.\n\t * @param type the source type or {@code null}\n\t * @param owner the owner type used to resolve variables\n\t * @return a {@link ResolvableType} for the specified {@link Type} and owner\n\t * @see #forType(Type)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "owner"
    ],
    "position": {
      "column": 1,
      "line": 1369
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forType(@Nullable Type type, @Nullable ResolvableType owner)",
    "source_code": "\tpublic static ResolvableType forType(@Nullable Type type, @Nullable ResolvableType owner) {\n\t\tVariableResolver variableResolver = null;\n\t\tif (owner != null) {\n\t\t\tvariableResolver = owner.asVariableResolver();\n\t\t}\n\t\treturn forType(type, variableResolver);\n\t}"
  },
  "org.springframework.core.<unknown>#getNested(nestingLevel,Map<Integer,typeIndexesPerLevel)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified nesting level.\n\t * <p>The nesting level refers to the specific generic parameter that should be returned.\n\t * A nesting level of 1 indicates this type; 2 indicates the first nested generic;\n\t * 3 the second; and so on. For example, given {@code List<Set<Integer>>} level 1 refers\n\t * to the {@code List}, level 2 the {@code Set}, and level 3 the {@code Integer}.\n\t * <p>The {@code typeIndexesPerLevel} map can be used to reference a specific generic\n\t * for the given level. For example, an index of 0 would refer to a {@code Map} key;\n\t * whereas, 1 would refer to the value. If the map does not contain a value for a\n\t * specific level the last generic will be used (e.g. a {@code Map} value).\n\t * <p>Nesting levels may also apply to array types; for example given\n\t * {@code String[]}, a nesting level of 2 refers to {@code String}.\n\t * <p>If a type does not {@link #hasGenerics() contain} generics the\n\t * {@link #getSuperType() supertype} hierarchy will be considered.\n\t * @param nestingLevel the required nesting level, indexed from 1 for the\n\t * current type, 2 for the first nested generic, 3 for the second and so on\n\t * @param typeIndexesPerLevel a map containing the generic index for a given\n\t * nesting level (may be {@code null})\n\t * @return a {@link ResolvableType} for the nested level, or {@link #NONE}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel",
      "Map<Integer",
      "typeIndexesPerLevel"
    ],
    "position": {
      "column": 1,
      "line": 635
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType getNested(int nestingLevel, @Nullable Map<Integer, Integer> typeIndexesPerLevel)",
    "source_code": "\tpublic ResolvableType getNested(int nestingLevel, @Nullable Map<Integer, Integer> typeIndexesPerLevel) {\n\t\tResolvableType result = this;\n\t\tfor (int i = 2; i <= nestingLevel; i++) {\n\t\t\tif (result.isArray()) {\n\t\t\t\tresult = result.getComponentType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Handle derived types\n\t\t\t\twhile (result != ResolvableType.NONE && !result.hasGenerics()) {\n\t\t\t\t\tresult = result.getSuperType();\n\t\t\t\t}\n\t\t\t\tInteger index = (typeIndexesPerLevel != null ? typeIndexesPerLevel.get(i) : null);\n\t\t\t\tindex = (index == null ? result.getGenerics().length - 1 : index);\n\t\t\t\tresult = result.getGeneric(index);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.core.<unknown>#getQualifiedAttributeName(enclosingClass,attributeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return an attribute name qualified by the given enclosing {@link Class}.\n\t * For example the attribute name '{@code foo}' qualified by {@link Class}\n\t * '{@code com.myapp.SomeClass}' would be '{@code com.myapp.SomeClass.foo}'\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enclosingClass",
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "String",
    "signature": "public String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName)",
    "source_code": "\tpublic static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {\n\t\tAssert.notNull(enclosingClass, \"'enclosingClass' must not be null\");\n\t\tAssert.notNull(attributeName, \"'attributeName' must not be null\");\n\t\treturn enclosingClass.getName() + '.' + attributeName;\n\t}"
  },
  "org.springframework.core.<unknown>#getVariableNameForReturnType(method,resolvedType,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the conventional variable name for the return type of the given\n\t * method, taking the generic collection type, if any, into account, falling\n\t * back on the given return value if the method declaration is not specific\n\t * enough, e.g. {@code Object} return type or untyped collection.\n\t * <p>As of 5.0 this method supports reactive types:<br>\n\t * {@code Mono<com.myapp.Product>} becomes {@code \"productMono\"}<br>\n\t * {@code Flux<com.myapp.MyProduct>} becomes {@code \"myProductFlux\"}<br>\n\t * {@code Observable<com.myapp.MyProduct>} becomes {@code \"myProductObservable\"}<br>\n\t * @param method the method to generate a variable name for\n\t * @param resolvedType the resolved return type of the method\n\t * @param value the return value (may be {@code null} if not available)\n\t * @return the generated variable name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "resolvedType",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "String",
    "signature": "public String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value)",
    "source_code": "\tpublic static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\n\t\tif (Object.class == resolvedType) {\n\t\t\tAssert.notNull(value, \"Cannot generate variable name for an Object return type with null value\");\n\t\t\treturn getVariableName(value);\n\t\t}\n\n\t\tClass<?> valueClass;\n\t\tboolean pluralize = false;\n\t\tString reactiveSuffix = \"\";\n\n\t\tif (resolvedType.isArray()) {\n\t\t\tvalueClass = resolvedType.getComponentType();\n\t\t\tpluralize = true;\n\t\t}\n\t\telse if (Collection.class.isAssignableFrom(resolvedType)) {\n\t\t\tvalueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric();\n\t\t\tif (valueClass == null) {\n\t\t\t\tif (!(value instanceof Collection<?> collection)) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot generate variable name \" +\n\t\t\t\t\t\t\t\"for non-typed Collection return type and a non-Collection value\");\n\t\t\t\t}\n\t\t\t\tif (collection.isEmpty()) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot generate variable name \" +\n\t\t\t\t\t\t\t\"for non-typed Collection return type and an empty Collection value\");\n\t\t\t\t}\n\t\t\t\tObject valueToCheck = peekAhead(collection);\n\t\t\t\tvalueClass = getClassForValue(valueToCheck);\n\t\t\t}\n\t\t\tpluralize = true;\n\t\t}\n\t\telse {\n\t\t\tvalueClass = resolvedType;\n\t\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(valueClass);\n\t\t\tif (adapter != null && !adapter.getDescriptor().isNoValue()) {\n\t\t\t\treactiveSuffix = ClassUtils.getShortName(valueClass);\n\t\t\t\tvalueClass = ResolvableType.forMethodReturnType(method).getGeneric().toClass();\n\t\t\t}\n\t\t}\n\n\t\tString name = ClassUtils.getShortNameAsProperty(valueClass);\n\t\treturn (pluralize ? pluralize(name) : name + reactiveSuffix);\n\t}"
  },
  "org.springframework.core.<unknown>#getVariableNameForReturnType(method,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the conventional variable name for the return type of the given\n\t * method, taking the generic collection type, if any, into account, falling\n\t * back on the given actual return value if the method declaration is not\n\t * specific enough, e.g. {@code Object} return type or untyped collection.\n\t * @param method the method to generate a variable name for\n\t * @param value the return value (may be {@code null} if not available)\n\t * @return the generated variable name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "String",
    "signature": "public String getVariableNameForReturnType(Method method, @Nullable Object value)",
    "source_code": "\tpublic static String getVariableNameForReturnType(Method method, @Nullable Object value) {\n\t\treturn getVariableNameForReturnType(method, method.getReturnType(), value);\n\t}"
  },
  "org.springframework.core.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\tObject other = args[0];\n\t\t\t\t\t// Unwrap proxies for speed\n\t\t\t\t\tif (other instanceof Type otherType) {\n\t\t\t\t\t\tother = unwrap(otherType);\n\t\t\t\t\t}\n\t\t\t\t\treturn ObjectUtils.nullSafeEquals(this.provider.getType(), other);\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\treturn ObjectUtils.nullSafeHashCode(this.provider.getType());\n\t\t\t\tcase \"getTypeProvider\":\n\t\t\t\t\treturn this.provider;\n\t\t\t}\n\n\t\t\tif (Type.class == method.getReturnType() && ObjectUtils.isEmpty(args)) {\n\t\t\t\treturn forTypeProvider(new MethodInvokeTypeProvider(this.provider, method, -1));\n\t\t\t}\n\t\t\telse if (Type[].class == method.getReturnType() && ObjectUtils.isEmpty(args)) {\n\t\t\t\tType[] result = new Type[((Type[]) method.invoke(this.provider.getType())).length];\n\t\t\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\t\t\tresult[i] = forTypeProvider(new MethodInvokeTypeProvider(this.provider, method, i));\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\treturn method.invoke(this.provider.getType(), args);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.<unknown>#resolveType(genericType,contextClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given generic type against the given context class,\n\t * substituting type variables as far as possible.\n\t * @param genericType the (potentially) generic type\n\t * @param contextClass a context class for the target type, for example a class\n\t * in which the target type appears in a method signature (can be {@code null})\n\t * @return the resolved type (possibly the given generic type as-is)\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "genericType",
      "contextClass"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "Type",
    "signature": "public Type resolveType(Type genericType, @Nullable Class<?> contextClass)",
    "source_code": "\tpublic static Type resolveType(Type genericType, @Nullable Class<?> contextClass) {\n\t\tif (contextClass != null) {\n\t\t\tif (genericType instanceof TypeVariable<?> typeVariable) {\n\t\t\t\tResolvableType resolvedTypeVariable = resolveVariable(\n\t\t\t\t\t\ttypeVariable, ResolvableType.forClass(contextClass));\n\t\t\t\tif (resolvedTypeVariable != ResolvableType.NONE) {\n\t\t\t\t\tClass<?> resolved = resolvedTypeVariable.resolve();\n\t\t\t\t\tif (resolved != null) {\n\t\t\t\t\t\treturn resolved;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (genericType instanceof ParameterizedType parameterizedType) {\n\t\t\t\tResolvableType resolvedType = ResolvableType.forType(genericType);\n\t\t\t\tif (resolvedType.hasUnresolvableGenerics()) {\n\t\t\t\t\tClass<?>[] generics = new Class<?>[parameterizedType.getActualTypeArguments().length];\n\t\t\t\t\tType[] typeArguments = parameterizedType.getActualTypeArguments();\n\t\t\t\t\tResolvableType contextType = ResolvableType.forClass(contextClass);\n\t\t\t\t\tfor (int i = 0; i < typeArguments.length; i++) {\n\t\t\t\t\t\tType typeArgument = typeArguments[i];\n\t\t\t\t\t\tif (typeArgument instanceof TypeVariable) {\n\t\t\t\t\t\t\tResolvableType resolvedTypeArgument = resolveVariable(\n\t\t\t\t\t\t\t\t\t(TypeVariable<?>) typeArgument, contextType);\n\t\t\t\t\t\t\tif (resolvedTypeArgument != ResolvableType.NONE) {\n\t\t\t\t\t\t\t\tgenerics[i] = resolvedTypeArgument.resolve();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tgenerics[i] = ResolvableType.forType(typeArgument).resolve();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tgenerics[i] = ResolvableType.forType(typeArgument).resolve();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tClass<?> rawClass = resolvedType.getRawClass();\n\t\t\t\t\tif (rawClass != null) {\n\t\t\t\t\t\treturn ResolvableType.forClassWithGenerics(rawClass, generics).getType();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn genericType;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#asMap(Function<MergedAnnotation<?>,factory,adaptations)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<MergedAnnotation<?>",
      "factory",
      "adaptations"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "T",
    "signature": "public T asMap(Function<MergedAnnotation<?>, T> factory, Adapt... adaptations)",
    "source_code": "\tpublic <T extends Map<String, Object>> T asMap(Function<MergedAnnotation<?>, T> factory, Adapt... adaptations) {\n\t\tT map = factory.apply(this);\n\t\tAssert.state(map != null, \"Factory used to create MergedAnnotation Map must not return null\");\n\t\tAttributeMethods attributes = this.mapping.getAttributes();\n\t\tfor (int i = 0; i < attributes.size(); i++) {\n\t\t\tMethod attribute = attributes.get(i);\n\t\t\tObject value = (isFiltered(attribute.getName()) ? null :\n\t\t\t\t\tgetValue(i, getTypeForMapOptions(attribute, adaptations)));\n\t\t\tif (value != null) {\n\t\t\t\tmap.put(attribute.getName(),\n\t\t\t\t\t\tadaptValueForMapOptions(attribute, value, map.getClass(), factory, adaptations));\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findAnnotation(annotatedElement,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a single {@link Annotation} of {@code annotationType} on the\n\t * supplied {@link AnnotatedElement}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>directly present</em> on the supplied element.\n\t * <p><strong>Warning</strong>: this method operates generically on\n\t * annotated elements. In other words, this method does not execute\n\t * specialized search algorithms for classes or methods. If you require\n\t * the more specific semantics of {@link #findAnnotation(Class, Class)}\n\t * or {@link #findAnnotation(Method, Class)}, invoke one of those methods\n\t * instead.\n\t * @param annotatedElement the {@code AnnotatedElement} on which to find the annotation\n\t * @param annotationType the annotation type to look for, both locally and as a meta-annotation\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 484
    },
    "return": "A",
    "signature": "public A findAnnotation(AnnotatedElement annotatedElement, @Nullable Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A findAnnotation(\n\t\t\tAnnotatedElement annotatedElement, @Nullable Class<A> annotationType) {\n\n\t\tif (annotationType == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {\n\t\t\treturn annotatedElement.getDeclaredAnnotation(annotationType);\n\t\t}\n\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findAnnotation(clazz,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a single {@link Annotation} of {@code annotationType} on the\n\t * supplied {@link Class}, traversing its interfaces, annotations, and\n\t * superclasses if the annotation is not <em>directly present</em> on\n\t * the given class itself.\n\t * <p>This method explicitly handles class-level annotations which are not\n\t * declared as {@link java.lang.annotation.Inherited inherited} <em>as well\n\t * as meta-annotations and annotations on interfaces</em>.\n\t * <p>The algorithm operates as follows:\n\t * <ol>\n\t * <li>Search for the annotation on the given class and return it if found.\n\t * <li>Recursively search through all annotations that the given class declares.\n\t * <li>Recursively search through all interfaces that the given class declares.\n\t * <li>Recursively search through the superclass hierarchy of the given class.\n\t * </ol>\n\t * <p>Note: in this context, the term <em>recursively</em> means that the search\n\t * process continues by returning to step #1 with the current interface,\n\t * annotation, or superclass as the class to look for annotations on.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * @return the first matching annotation, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 559
    },
    "return": "A",
    "signature": "public A findAnnotation(Class<?> clazz, @Nullable Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A findAnnotation(Class<?> clazz, @Nullable Class<A> annotationType) {\n\t\tif (annotationType == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) {\n\t\t\tA annotation = clazz.getDeclaredAnnotation(annotationType);\n\t\t\tif (annotation != null) {\n\t\t\t\treturn annotation;\n\t\t\t}\n\t\t\t// For backwards compatibility, perform a superclass search with plain annotations\n\t\t\t// even if not marked as @Inherited: e.g. a findAnnotation search for @Deprecated\n\t\t\tClass<?> superclass = clazz.getSuperclass();\n\t\t\tif (superclass == null || superclass == Object.class) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn findAnnotation(superclass, annotationType);\n\t\t}\n\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(clazz, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findAnnotation(method,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a single {@link Annotation} of {@code annotationType} on the supplied\n\t * {@link Method}, traversing its super methods (i.e. from superclasses and\n\t * interfaces) if the annotation is not <em>directly present</em> on the given\n\t * method itself.\n\t * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>directly present</em> on the method.\n\t * <p>Annotations on methods are not inherited by default, so we need to handle\n\t * this explicitly.\n\t * @param method the method to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @see #getAnnotation(Method, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 519
    },
    "return": "A",
    "signature": "public A findAnnotation(Method method, @Nullable Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A findAnnotation(Method method, @Nullable Class<A> annotationType) {\n\t\tif (annotationType == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(method)) {\n\t\t\treturn method.getDeclaredAnnotation(annotationType);\n\t\t}\n\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#firstRunOf(MergedAnnotation<A>,valueExtractor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new stateful, single use {@link Predicate} that matches only\n\t * the first run of an extracted value. For example,\n\t * {@code MergedAnnotationPredicates.firstRunOf(MergedAnnotation::distance)}\n\t * will match the first annotation, and any subsequent runs that have the\n\t * same distance.\n\t * <p>NOTE: This predicate only matches the first run. Once the extracted\n\t * value changes, the predicate always returns {@code false}. For example,\n\t * if you have a set of annotations with distances {@code [1, 1, 2, 1]} then\n\t * only the first two will match.\n\t * @param valueExtractor function used to extract the value to check\n\t * @return a {@link Predicate} that matches the first run of the extracted\n\t * values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MergedAnnotation<A>",
      "valueExtractor"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "Predicate<MergedAnnotation<A>>",
    "signature": "public Predicate<MergedAnnotation<A>> firstRunOf(Function<? super MergedAnnotation<A>, ?> valueExtractor)",
    "source_code": "\tpublic static <A extends Annotation> Predicate<MergedAnnotation<A>> firstRunOf(\n\t\t\tFunction<? super MergedAnnotation<A>, ?> valueExtractor) {\n\n\t\treturn new FirstRunOfPredicate<>(valueExtractor);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#forExecutable(executable,parameterIndex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new SynthesizingMethodParameter for the given method or constructor.\n\t * <p>This is a convenience factory method for scenarios where a\n\t * Method or Constructor reference is treated in a generic fashion.\n\t * @param executable the Method or Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @return the corresponding SynthesizingMethodParameter instance\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executable",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "SynthesizingMethodParameter",
    "signature": "public SynthesizingMethodParameter forExecutable(Executable executable, int parameterIndex)",
    "source_code": "\tpublic static SynthesizingMethodParameter forExecutable(Executable executable, int parameterIndex) {\n\t\tif (executable instanceof Method method) {\n\t\t\treturn new SynthesizingMethodParameter(method, parameterIndex);\n\t\t}\n\t\telse if (executable instanceof Constructor<?> constructor) {\n\t\t\treturn new SynthesizingMethodParameter(constructor, parameterIndex);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Not a Method/Constructor: \" + executable);\n\t\t}\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#fromMap(Map<String,map)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return an {@link AnnotationAttributes} instance based on the given map.\n\t * <p>If the map is already an {@code AnnotationAttributes} instance, it\n\t * will be cast and returned immediately without creating a new instance.\n\t * Otherwise a new instance will be created by passing the supplied map\n\t * to the {@link #AnnotationAttributes(Map)} constructor.\n\t * @param map original source of annotation attribute <em>key-value</em> pairs\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 425
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes fromMap(@Nullable Map<String, Object> map)",
    "source_code": "\tpublic static AnnotationAttributes fromMap(@Nullable Map<String, Object> map) {\n\t\tif (map == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (map instanceof AnnotationAttributes annotationAttributes) {\n\t\t\treturn annotationAttributes;\n\t\t}\n\t\treturn new AnnotationAttributes(map);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotation(annotatedElement,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get a single {@link Annotation} of {@code annotationType} from the supplied\n\t * {@link AnnotatedElement}, where the annotation is either <em>present</em> or\n\t * <em>meta-present</em> on the {@code AnnotatedElement}.\n\t * <p>Note that this method supports only a single level of meta-annotations.\n\t * For support for arbitrary levels of meta-annotations, use\n\t * {@link #findAnnotation(AnnotatedElement, Class)} instead.\n\t * @param annotatedElement the {@code AnnotatedElement} from which to get the annotation\n\t * @param annotationType the annotation type to look for, both locally and as a meta-annotation\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @since 3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "A",
    "signature": "public A getAnnotation(AnnotatedElement annotatedElement, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A getAnnotation(AnnotatedElement annotatedElement, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {\n\t\t\treturn annotatedElement.getAnnotation(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(AnnotationUtils::isSingleLevelPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotation(annotation,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get a single {@link Annotation} of {@code annotationType} from the supplied\n\t * annotation: either the given annotation itself or a direct meta-annotation\n\t * thereof.\n\t * <p>Note that this method supports only a single level of meta-annotations.\n\t * For support for arbitrary levels of meta-annotations, use one of the\n\t * {@code find*()} methods instead.\n\t * @param annotation the Annotation to check\n\t * @param annotationType the annotation type to look for, both locally and as a meta-annotation\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotation",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "A",
    "signature": "public A getAnnotation(Annotation annotation, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A getAnnotation(Annotation annotation, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (annotationType.isInstance(annotation)) {\n\t\t\treturn synthesizeAnnotation((A) annotation, annotationType);\n\t\t}\n\t\t// Shortcut: no searchable annotations to be found on plain Java classes and core Spring types...\n\t\tif (AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotation)) {\n\t\t\treturn null;\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(annotation, new Annotation[] {annotation}, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(AnnotationUtils::isSingleLevelPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotation(attributeName,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the annotation of type {@code annotationType} stored under the\n\t * specified {@code attributeName}.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @param annotationType the expected annotation type; never {@code null}\n\t * @return the annotation\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "A",
    "signature": "public A getAnnotation(String attributeName, Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> A getAnnotation(String attributeName, Class<A> annotationType) {\n\t\treturn getRequiredAttribute(attributeName, annotationType);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotation(attributeName,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "MergedAnnotation<T>",
    "signature": "public MergedAnnotation<T> getAnnotation(String attributeName, Class<T> type)",
    "source_code": "\tpublic <T extends Annotation> MergedAnnotation<T> getAnnotation(String attributeName, Class<T> type)\n\t\t\tthrows NoSuchElementException {\n\n\t\tint attributeIndex = getAttributeIndex(attributeName, true);\n\t\tMethod attribute = this.mapping.getAttributes().get(attributeIndex);\n\t\tAssert.notNull(type, \"Type must not be null\");\n\t\tAssert.isAssignable(type, attribute.getReturnType(),\n\t\t\t\t() -> \"Attribute \" + attributeName + \" type mismatch:\");\n\t\treturn (MergedAnnotation<T>) getRequiredValue(attributeIndex, attributeName);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotation(method,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get a single {@link Annotation} of {@code annotationType} from the\n\t * supplied {@link Method}, where the annotation is either <em>present</em>\n\t * or <em>meta-present</em> on the method.\n\t * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\n\t * <p>Note that this method supports only a single level of meta-annotations.\n\t * For support for arbitrary levels of meta-annotations, use\n\t * {@link #findAnnotation(Method, Class)} instead.\n\t * @param method the method to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)\n\t * @see #getAnnotation(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "A",
    "signature": "public A getAnnotation(Method method, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A getAnnotation(Method method, Class<A> annotationType) {\n\t\tMethod resolvedMethod = BridgeMethodResolver.findBridgedMethod(method);\n\t\treturn getAnnotation((AnnotatedElement) resolvedMethod, annotationType);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotationArray(attributeName,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the array of type {@code annotationType} stored under the specified\n\t * {@code attributeName}.\n\t * <p>If the value stored under the specified {@code attributeName} is\n\t * an {@code Annotation}, it will be wrapped in a single-element array\n\t * before returning it.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @param annotationType the expected annotation type; never {@code null}\n\t * @return the annotation array\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 329
    },
    "return": "A[]",
    "signature": "public A[] getAnnotationArray(String attributeName, Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> A[] getAnnotationArray(String attributeName, Class<A> annotationType) {\n\t\tObject array = Array.newInstance(annotationType, 0);\n\t\treturn (A[]) getRequiredAttribute(attributeName, array.getClass());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotationArray(attributeName,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "MergedAnnotation<T>[]",
    "signature": "public MergedAnnotation<T>[] getAnnotationArray(String attributeName, Class<T> type)",
    "source_code": "\tpublic <T extends Annotation> MergedAnnotation<T>[] getAnnotationArray(\n\t\t\tString attributeName, Class<T> type) throws NoSuchElementException {\n\n\t\tint attributeIndex = getAttributeIndex(attributeName, true);\n\t\tMethod attribute = this.mapping.getAttributes().get(attributeIndex);\n\t\tClass<?> componentType = attribute.getReturnType().getComponentType();\n\t\tAssert.notNull(type, \"Type must not be null\");\n\t\tAssert.notNull(componentType, () -> \"Attribute \" + attributeName + \" is not an array\");\n\t\tAssert.isAssignable(type, componentType, () -> \"Attribute \" + attributeName + \" component type mismatch:\");\n\t\treturn (MergedAnnotation<T>[]) getRequiredValue(attributeIndex, attributeName);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotationAttributes(annotatedElement,annotation)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\n\t * <p>Equivalent to calling {@link #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)}\n\t * with the {@code classValuesAsString} and {@code nestedAnnotationsAsMap} parameters\n\t * set to {@code false}.\n\t * @param annotatedElement the element that is annotated with the supplied annotation;\n\t * may be {@code null} if unknown\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @return the annotation attributes (a specialized Map) with attribute names as keys\n\t * and corresponding attribute values as values (never {@code null})\n\t * @since 4.2\n\t * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotation"
    ],
    "position": {
      "column": 1,
      "line": 845
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes getAnnotationAttributes(@Nullable AnnotatedElement annotatedElement, Annotation annotation)",
    "source_code": "\tpublic static AnnotationAttributes getAnnotationAttributes(\n\t\t\t@Nullable AnnotatedElement annotatedElement, Annotation annotation) {\n\n\t\treturn getAnnotationAttributes(annotatedElement, annotation, false, false);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotationAttributes(annotatedElement,annotation,classValuesAsString,nestedAnnotationsAsMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\n\t * <p>This method provides fully recursive annotation reading capabilities on par with\n\t * the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}.\n\t * @param annotatedElement the element that is annotated with the supplied annotation;\n\t * may be {@code null} if unknown\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @param classValuesAsString whether to convert Class references into Strings (for\n\t * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\n\t * or to preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested annotations into\n\t * {@link AnnotationAttributes} maps (for compatibility with\n\t * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as\n\t * {@code Annotation} instances\n\t * @return the annotation attributes (a specialized Map) with attribute names as keys\n\t * and corresponding attribute values as values (never {@code null})\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotation",
      "classValuesAsString",
      "nestedAnnotationsAsMap"
    ],
    "position": {
      "column": 1,
      "line": 869
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes getAnnotationAttributes(@Nullable AnnotatedElement annotatedElement, Annotation annotation,\n\t\t\tboolean classValuesAsString, boolean nestedAnnotationsAsMap)",
    "source_code": "\tpublic static AnnotationAttributes getAnnotationAttributes(\n\t\t\t@Nullable AnnotatedElement annotatedElement, Annotation annotation,\n\t\t\tboolean classValuesAsString, boolean nestedAnnotationsAsMap) {\n\n\t\tAdapt[] adaptations = Adapt.values(classValuesAsString, nestedAnnotationsAsMap);\n\t\treturn MergedAnnotation.from(annotatedElement, annotation)\n\t\t\t\t.withNonMergedAttributes()\n\t\t\t\t.asMap(mergedAnnotation ->\n\t\t\t\t\t\tnew AnnotationAttributes(mergedAnnotation.getType(), true), adaptations);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotationAttributes(annotation,classValuesAsString)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given annotation's attributes as a {@link Map}.\n\t * <p>Equivalent to calling {@link #getAnnotationAttributes(Annotation, boolean, boolean)}\n\t * with the {@code nestedAnnotationsAsMap} parameter set to {@code false}.\n\t * <p>Note: This method actually returns an {@link AnnotationAttributes} instance.\n\t * However, the {@code Map} signature has been preserved for binary compatibility.\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @param classValuesAsString whether to convert Class references into Strings (for\n\t * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\n\t * or to preserve them as Class references\n\t * @return the Map of annotation attributes, with attribute names as keys and\n\t * corresponding attribute values as values (never {@code null})\n\t * @see #getAnnotationAttributes(Annotation, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotation",
      "classValuesAsString"
    ],
    "position": {
      "column": 1,
      "line": 804
    },
    "return": "Object>",
    "signature": "public Object> getAnnotationAttributes(Annotation annotation, boolean classValuesAsString)",
    "source_code": "\tpublic static Map<String, Object> getAnnotationAttributes(\n\t\t\tAnnotation annotation, boolean classValuesAsString) {\n\n\t\treturn getAnnotationAttributes(annotation, classValuesAsString, false);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotationAttributes(annotation,classValuesAsString,nestedAnnotationsAsMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\n\t * <p>This method provides fully recursive annotation reading capabilities on par with\n\t * the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}.\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @param classValuesAsString whether to convert Class references into Strings (for\n\t * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\n\t * or to preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested annotations into\n\t * {@link AnnotationAttributes} maps (for compatibility with\n\t * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as\n\t * {@code Annotation} instances\n\t * @return the annotation attributes (a specialized Map) with attribute names as keys\n\t * and corresponding attribute values as values (never {@code null})\n\t * @since 3.1.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotation",
      "classValuesAsString",
      "nestedAnnotationsAsMap"
    ],
    "position": {
      "column": 1,
      "line": 826
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes getAnnotationAttributes(Annotation annotation, boolean classValuesAsString, boolean nestedAnnotationsAsMap)",
    "source_code": "\tpublic static AnnotationAttributes getAnnotationAttributes(\n\t\t\tAnnotation annotation, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\n\n\t\treturn getAnnotationAttributes(null, annotation, classValuesAsString, nestedAnnotationsAsMap);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAttributeValue(attributeName,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "attributeName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "T",
    "signature": "protected T getAttributeValue(String attributeName, Class<T> type)",
    "source_code": "\tprotected <T> T getAttributeValue(String attributeName, Class<T> type) {\n\t\tint attributeIndex = getAttributeIndex(attributeName, false);\n\t\treturn (attributeIndex != -1 ? getValue(attributeIndex, type) : null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getDeclaredRepeatableAnnotations(annotatedElement,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}\n\t * of {@code annotationType} from the supplied {@link AnnotatedElement},\n\t * where such annotations are either <em>directly present</em>,\n\t * <em>indirectly present</em>, or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}\n\t * with support for automatic detection of a <em>container annotation</em>\n\t * declared via @{@link java.lang.annotation.Repeatable} (when running on\n\t * Java 8 or higher) and with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 416
    },
    "return": "Set<A>",
    "signature": "public Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType) {\n\n\t\treturn getDeclaredRepeatableAnnotations(annotatedElement, annotationType, null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getDeclaredRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}\n\t * of {@code annotationType} from the supplied {@link AnnotatedElement},\n\t * where such annotations are either <em>directly present</em>,\n\t * <em>indirectly present</em>, or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}\n\t * with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @param containerAnnotationType the type of the container that holds\n\t * the annotations; may be {@code null} if a container is not supported\n\t * or if it should be looked up via @{@link java.lang.annotation.Repeatable}\n\t * when running on Java 8 or higher\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType",
      "containerAnnotationType"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "Set<A>",
    "signature": "public Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType) {\n\n\t\tRepeatableContainers repeatableContainers = containerAnnotationType != null ?\n\t\t\t\tRepeatableContainers.of(annotationType, containerAnnotationType) :\n\t\t\t\tRepeatableContainers.standardRepeatables();\n\n\t\treturn MergedAnnotations.from(annotatedElement, SearchStrategy.DIRECT, repeatableContainers)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.map(MergedAnnotation::withNonMergedAttributes)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getDefaultValue(annotation,attributeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the <em>default value</em> of a named attribute, given an annotation instance.\n\t * @param annotation the annotation instance from which to retrieve the default value\n\t * @param attributeName the name of the attribute value to retrieve\n\t * @return the default value of the named attribute, or {@code null} if not found\n\t * @see #getDefaultValue(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotation",
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 1154
    },
    "return": "Object",
    "signature": "public Object getDefaultValue(@Nullable Annotation annotation, @Nullable String attributeName)",
    "source_code": "\tpublic static Object getDefaultValue(@Nullable Annotation annotation, @Nullable String attributeName) {\n\t\treturn (annotation != null ? getDefaultValue(annotation.annotationType(), attributeName) : null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getDefaultValue(annotationType,attributeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the <em>default value</em> of a named attribute, given the\n\t * {@link Class annotation type}.\n\t * @param annotationType the <em>annotation type</em> for which the default value should be retrieved\n\t * @param attributeName the name of the attribute value to retrieve.\n\t * @return the default value of the named attribute, or {@code null} if not found\n\t * @see #getDefaultValue(Annotation, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 1179
    },
    "return": "Object",
    "signature": "public Object getDefaultValue(@Nullable Class<? extends Annotation> annotationType, @Nullable String attributeName)",
    "source_code": "\tpublic static Object getDefaultValue(\n\t\t\t@Nullable Class<? extends Annotation> annotationType, @Nullable String attributeName) {\n\n\t\tif (annotationType == null || !StringUtils.hasText(attributeName)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn MergedAnnotation.of(annotationType).getDefaultValue(attributeName).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getDefaultValue(attributeName,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "Optional<T>",
    "signature": "public Optional<T> getDefaultValue(String attributeName, Class<T> type)",
    "source_code": "\tpublic <T> Optional<T> getDefaultValue(String attributeName, Class<T> type) {\n\t\tint attributeIndex = getAttributeIndex(attributeName, false);\n\t\tif (attributeIndex == -1) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tMethod attribute = this.mapping.getAttributes().get(attributeIndex);\n\t\treturn Optional.ofNullable(adapt(attribute, attribute.getDefaultValue(), type));\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getOrder(type,defaultOrder)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return the order on the specified {@code type}, or the specified\n\t * default value if none can be found.\n\t * <p>Takes care of {@link Order @Order} and {@code @jakarta.annotation.Priority}.\n\t * @param type the type to handle\n\t * @return the priority value, or the specified default order if none can be found\n\t * @see #getPriority(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "defaultOrder"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "Integer",
    "signature": "public Integer getOrder(Class<?> type, @Nullable Integer defaultOrder)",
    "source_code": "\tpublic static Integer getOrder(Class<?> type, @Nullable Integer defaultOrder) {\n\t\tInteger order = getOrder(type);\n\t\treturn (order != null ? order : defaultOrder);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getRepeatableAnnotations(annotatedElement,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the <em>repeatable</em> {@linkplain Annotation annotations} of\n\t * {@code annotationType} from the supplied {@link AnnotatedElement}, where\n\t * such annotations are either <em>present</em>, <em>indirectly present</em>,\n\t * or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}\n\t * with support for automatic detection of a <em>container annotation</em>\n\t * declared via @{@link java.lang.annotation.Repeatable} (when running on\n\t * Java 8 or higher) and with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "Set<A>",
    "signature": "public Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType) {\n\n\t\treturn getRepeatableAnnotations(annotatedElement, annotationType, null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the <em>repeatable</em> {@linkplain Annotation annotations} of\n\t * {@code annotationType} from the supplied {@link AnnotatedElement}, where\n\t * such annotations are either <em>present</em>, <em>indirectly present</em>,\n\t * or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}\n\t * with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @param containerAnnotationType the type of the container that holds\n\t * the annotations; may be {@code null} if a container is not supported\n\t * or if it should be looked up via @{@link java.lang.annotation.Repeatable}\n\t * when running on Java 8 or higher\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType",
      "containerAnnotationType"
    ],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "Set<A>",
    "signature": "public Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType) {\n\n\t\tRepeatableContainers repeatableContainers = (containerAnnotationType != null ?\n\t\t\t\tRepeatableContainers.of(annotationType, containerAnnotationType) :\n\t\t\t\tRepeatableContainers.standardRepeatables());\n\n\t\treturn MergedAnnotations.from(annotatedElement, SearchStrategy.SUPERCLASS, repeatableContainers)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t.map(MergedAnnotation::withNonMergedAttributes)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getValue(annotation,attributeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the <em>value</em> of a named attribute, given an annotation instance.\n\t * @param annotation the annotation instance from which to retrieve the value\n\t * @param attributeName the name of the attribute value to retrieve\n\t * @return the attribute value, or {@code null} if not found unless the attribute\n\t * value cannot be retrieved due to an {@link AnnotationConfigurationException},\n\t * in which case such an exception will be rethrown\n\t * @see #getValue(Annotation)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotation",
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 1047
    },
    "return": "Object",
    "signature": "public Object getValue(@Nullable Annotation annotation, @Nullable String attributeName)",
    "source_code": "\tpublic static Object getValue(@Nullable Annotation annotation, @Nullable String attributeName) {\n\t\tif (annotation == null || !StringUtils.hasText(attributeName)) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\tMethod method = annotation.annotationType().getDeclaredMethod(attributeName);\n\t\t\treturn invokeAnnotationMethod(method, annotation);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\treturn null;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\trethrowAnnotationConfigurationException(ex);\n\t\t\thandleIntrospectionFailure(annotation.getClass(), ex);\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\tpublic Object invoke(Object proxy, Method method, Object[] args) {\n\t\tif (ReflectionUtils.isEqualsMethod(method)) {\n\t\t\treturn annotationEquals(args[0]);\n\t\t}\n\t\tif (ReflectionUtils.isHashCodeMethod(method)) {\n\t\t\treturn annotationHashCode();\n\t\t}\n\t\tif (ReflectionUtils.isToStringMethod(method)) {\n\t\t\treturn annotationToString();\n\t\t}\n\t\tif (isAnnotationTypeMethod(method)) {\n\t\t\treturn this.type;\n\t\t}\n\t\tif (this.attributes.indexOf(method.getName()) != -1) {\n\t\t\treturn getAttributeValue(method);\n\t\t}\n\t\tthrow new AnnotationConfigurationException(String.format(\n\t\t\t\t\"Method [%s] is unsupported for synthesized annotation type [%s]\", method, this.type));\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isAnnotationDeclaredLocally(annotationType,clazz)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether an annotation of the specified {@code annotationType}\n\t * is declared locally (i.e. <em>directly present</em>) on the supplied\n\t * {@code clazz}.\n\t * <p>The supplied {@link Class} may represent any type.\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * <p>Note: This method does <strong>not</strong> determine if the annotation\n\t * is {@linkplain java.lang.annotation.Inherited inherited}.\n\t * @param annotationType the annotation type to look for\n\t * @param clazz the class to check for the annotation on\n\t * @return {@code true} if an annotation of the specified {@code annotationType}\n\t * is <em>directly present</em>\n\t * @see java.lang.Class#getDeclaredAnnotations()\n\t * @see java.lang.Class#getDeclaredAnnotation(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 675
    },
    "return": "boolean",
    "signature": "public boolean isAnnotationDeclaredLocally(Class<? extends Annotation> annotationType, Class<?> clazz)",
    "source_code": "\tpublic static boolean isAnnotationDeclaredLocally(Class<? extends Annotation> annotationType, Class<?> clazz) {\n\t\treturn MergedAnnotations.from(clazz).get(annotationType).isDirectlyPresent();\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isAnnotationInherited(annotationType,clazz)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether an annotation of the specified {@code annotationType}\n\t * is <em>present</em> on the supplied {@code clazz} and is\n\t * {@linkplain java.lang.annotation.Inherited inherited}\n\t * (i.e. not <em>directly present</em>).\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * <p>If the supplied {@code clazz} is an interface, only the interface\n\t * itself will be checked. In accordance with standard meta-annotation\n\t * semantics in Java, the inheritance hierarchy for interfaces will not\n\t * be traversed. See the {@linkplain java.lang.annotation.Inherited javadoc}\n\t * for the {@code @Inherited} meta-annotation for further details regarding\n\t * annotation inheritance.\n\t * @param annotationType the annotation type to look for\n\t * @param clazz the class to check for the annotation on\n\t * @return {@code true} if an annotation of the specified {@code annotationType}\n\t * is <em>present</em> and <em>inherited</em>\n\t * @see Class#isAnnotationPresent(Class)\n\t * @see #isAnnotationDeclaredLocally(Class, Class)\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 700
    },
    "return": "boolean",
    "signature": "public boolean isAnnotationInherited(Class<? extends Annotation> annotationType, Class<?> clazz)",
    "source_code": "\tpublic static boolean isAnnotationInherited(Class<? extends Annotation> annotationType, Class<?> clazz) {\n\t\treturn MergedAnnotations.from(clazz, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.filter(MergedAnnotation::isDirectlyPresent)\n\t\t\t\t.findFirst().orElseGet(MergedAnnotation::missing)\n\t\t\t\t.getAggregateIndex() > 0;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isAnnotationMetaPresent(annotationType,metaAnnotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if an annotation of type {@code metaAnnotationType} is\n\t * <em>meta-present</em> on the supplied {@code annotationType}.\n\t * @param annotationType the annotation type to search on\n\t * @param metaAnnotationType the type of meta-annotation to search for\n\t * @return {@code true} if such an annotation is meta-present\n\t * @since 4.2.1\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "metaAnnotationType"
    ],
    "position": {
      "column": 1,
      "line": 718
    },
    "return": "boolean",
    "signature": "public boolean isAnnotationMetaPresent(Class<? extends Annotation> annotationType,\n\t\t\t@Nullable Class<? extends Annotation> metaAnnotationType)",
    "source_code": "\tpublic static boolean isAnnotationMetaPresent(Class<? extends Annotation> annotationType,\n\t\t\t@Nullable Class<? extends Annotation> metaAnnotationType) {\n\n\t\tif (metaAnnotationType == null) {\n\t\t\treturn false;\n\t\t}\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(metaAnnotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(annotationType)) {\n\t\t\treturn annotationType.isAnnotationPresent(metaAnnotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(annotationType, SearchStrategy.INHERITED_ANNOTATIONS,\n\t\t\t\tRepeatableContainers.none()).isPresent(metaAnnotationType);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isCandidateClass(clazz,annotationName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class is a candidate for carrying the specified annotation\n\t * (at type, method or field level).\n\t * @param clazz the class to introspect\n\t * @param annotationName the fully-qualified name of the searchable annotation type\n\t * @return {@code false} if the class is known to have no such annotations at any level;\n\t * {@code true} otherwise. Callers will usually perform full method/field introspection\n\t * if {@code true} is being returned here.\n\t * @since 5.2\n\t * @see #isCandidateClass(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationName"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "boolean",
    "signature": "public boolean isCandidateClass(Class<?> clazz, String annotationName)",
    "source_code": "\tpublic static boolean isCandidateClass(Class<?> clazz, String annotationName) {\n\t\tif (annotationName.startsWith(\"java.\")) {\n\t\t\treturn true;\n\t\t}\n\t\tif (AnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isCandidateClass(clazz,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class is a candidate for carrying the specified annotation\n\t * (at type, method or field level).\n\t * @param clazz the class to introspect\n\t * @param annotationType the searchable annotation type\n\t * @return {@code false} if the class is known to have no such annotations at any level;\n\t * {@code true} otherwise. Callers will usually perform full method/field introspection\n\t * if {@code true} is being returned here.\n\t * @since 5.2\n\t * @see #isCandidateClass(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "boolean",
    "signature": "public boolean isCandidateClass(Class<?> clazz, Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic static boolean isCandidateClass(Class<?> clazz, Class<? extends Annotation> annotationType) {\n\t\treturn isCandidateClass(clazz, annotationType.getName());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isCandidateClass(clazz,annotationTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class is a candidate for carrying one of the specified\n\t * annotations (at type, method or field level).\n\t * @param clazz the class to introspect\n\t * @param annotationTypes the searchable annotation types\n\t * @return {@code false} if the class is known to have no such annotations at any level;\n\t * {@code true} otherwise. Callers will usually perform full method/field introspection\n\t * if {@code true} is being returned here.\n\t * @since 5.2\n\t * @see #isCandidateClass(Class, Class)\n\t * @see #isCandidateClass(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationTypes"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "boolean",
    "signature": "public boolean isCandidateClass(Class<?> clazz, Collection<Class<? extends Annotation>> annotationTypes)",
    "source_code": "\tpublic static boolean isCandidateClass(Class<?> clazz, Collection<Class<? extends Annotation>> annotationTypes) {\n\t\tfor (Class<? extends Annotation> annotationType : annotationTypes) {\n\t\t\tif (isCandidateClass(clazz, annotationType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#postProcessAnnotationAttributes(annotatedElement,attributes,classValuesAsString)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Post-process the supplied {@link AnnotationAttributes}, preserving nested\n\t * annotations as {@code Annotation} instances.\n\t * <p>Specifically, this method enforces <em>attribute alias</em> semantics\n\t * for annotation attributes that are annotated with {@link AliasFor @AliasFor}\n\t * and replaces default value placeholders with their original default values.\n\t * @param annotatedElement the element that is annotated with an annotation or\n\t * annotation hierarchy from which the supplied attributes were created;\n\t * may be {@code null} if unknown\n\t * @param attributes the annotation attributes to post-process\n\t * @param classValuesAsString whether to convert Class references into Strings (for\n\t * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\n\t * or to preserve them as Class references\n\t * @since 4.3.2\n\t * @see #getDefaultValue(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "attributes",
      "classValuesAsString"
    ],
    "position": {
      "column": 1,
      "line": 948
    },
    "return": "void",
    "signature": "public void postProcessAnnotationAttributes(@Nullable Object annotatedElement,\n\t\t\t@Nullable AnnotationAttributes attributes, boolean classValuesAsString)",
    "source_code": "\tpublic static void postProcessAnnotationAttributes(@Nullable Object annotatedElement,\n\t\t\t@Nullable AnnotationAttributes attributes, boolean classValuesAsString) {\n\n\t\tif (attributes == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (!attributes.validated) {\n\t\t\tClass<? extends Annotation> annotationType = attributes.annotationType();\n\t\t\tif (annotationType == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(annotationType).get(0);\n\t\t\tfor (int i = 0; i < mapping.getMirrorSets().size(); i++) {\n\t\t\t\tMirrorSet mirrorSet = mapping.getMirrorSets().get(i);\n\t\t\t\tint resolved = mirrorSet.resolve(attributes.displayName, attributes,\n\t\t\t\t\t\tAnnotationUtils::getAttributeValueForMirrorResolution);\n\t\t\t\tif (resolved != -1) {\n\t\t\t\t\tMethod attribute = mapping.getAttributes().get(resolved);\n\t\t\t\t\tObject value = attributes.get(attribute.getName());\n\t\t\t\t\tfor (int j = 0; j < mirrorSet.size(); j++) {\n\t\t\t\t\t\tMethod mirror = mirrorSet.get(j);\n\t\t\t\t\t\tif (mirror != attribute) {\n\t\t\t\t\t\t\tattributes.put(mirror.getName(),\n\t\t\t\t\t\t\t\t\tadaptValue(annotatedElement, value, classValuesAsString));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, Object> attributeEntry : attributes.entrySet()) {\n\t\t\tString attributeName = attributeEntry.getKey();\n\t\t\tObject value = attributeEntry.getValue();\n\t\t\tif (value instanceof DefaultValueHolder defaultValueHolder) {\n\t\t\t\tvalue = defaultValueHolder.defaultValue;\n\t\t\t\tattributes.put(attributeName,\n\t\t\t\t\t\tadaptValue(annotatedElement, value, classValuesAsString));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#synthesizeAnnotation(Map<String,attributes,annotationType,annotatedElement)": {
    "deprecated": false,
    "doc": "\t/**\n\t * <em>Synthesize</em> an annotation from the supplied map of annotation\n\t * attributes by wrapping the map in a dynamic proxy that implements an\n\t * annotation of the specified {@code annotationType} and transparently\n\t * enforces <em>attribute alias</em> semantics for annotation attributes\n\t * that are annotated with {@link AliasFor @AliasFor}.\n\t * <p>The supplied map must contain a key-value pair for every attribute\n\t * defined in the supplied {@code annotationType} that is not aliased or\n\t * does not have a default value. Nested maps and nested arrays of maps\n\t * will be recursively synthesized into nested annotations or nested\n\t * arrays of annotations, respectively.\n\t * <p>Note that {@link AnnotationAttributes} is a specialized type of\n\t * {@link Map} that is an ideal candidate for this method's\n\t * {@code attributes} argument.\n\t * @param attributes the map of annotation attributes to synthesize\n\t * @param annotationType the type of annotation to synthesize\n\t * @param annotatedElement the element that is annotated with the annotation\n\t * corresponding to the supplied attributes; may be {@code null} if unknown\n\t * @return the synthesized annotation\n\t * @throws IllegalArgumentException if a required attribute is missing or if an\n\t * attribute is not of the correct type\n\t * @throws AnnotationConfigurationException if invalid configuration of\n\t * {@code @AliasFor} is detected\n\t * @since 4.2\n\t * @see #synthesizeAnnotation(Annotation, AnnotatedElement)\n\t * @see #synthesizeAnnotation(Class)\n\t * @see #getAnnotationAttributes(AnnotatedElement, Annotation)\n\t * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes",
      "annotationType",
      "annotatedElement"
    ],
    "position": {
      "column": 1,
      "line": 1262
    },
    "return": "A",
    "signature": "public A synthesizeAnnotation(Map<String, Object> attributes,\n\t\t\tClass<A> annotationType, @Nullable AnnotatedElement annotatedElement)",
    "source_code": "\tpublic static <A extends Annotation> A synthesizeAnnotation(Map<String, Object> attributes,\n\t\t\tClass<A> annotationType, @Nullable AnnotatedElement annotatedElement) {\n\n\t\ttry {\n\t\t\treturn MergedAnnotation.of(annotatedElement, annotationType, attributes).synthesize();\n\t\t}\n\t\tcatch (NoSuchElementException | IllegalStateException ex) {\n\t\t\tthrow new IllegalArgumentException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#synthesizeAnnotation(annotation,annotatedElement)": {
    "deprecated": false,
    "doc": "\t/**\n\t * <em>Synthesize</em> an annotation from the supplied {@code annotation}\n\t * by wrapping it in a dynamic proxy that transparently enforces\n\t * <em>attribute alias</em> semantics for annotation attributes that are\n\t * annotated with {@link AliasFor @AliasFor}.\n\t * @param annotation the annotation to synthesize\n\t * @param annotatedElement the element that is annotated with the supplied\n\t * annotation; may be {@code null} if unknown\n\t * @return the synthesized annotation if the supplied annotation is\n\t * <em>synthesizable</em>; {@code null} if the supplied annotation is\n\t * {@code null}; otherwise the supplied annotation unmodified\n\t * @throws AnnotationConfigurationException if invalid configuration of\n\t * {@code @AliasFor} is detected\n\t * @since 4.2\n\t * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)\n\t * @see #synthesizeAnnotation(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotation",
      "annotatedElement"
    ],
    "position": {
      "column": 1,
      "line": 1205
    },
    "return": "A",
    "signature": "public A synthesizeAnnotation(A annotation, @Nullable AnnotatedElement annotatedElement)",
    "source_code": "\tpublic static <A extends Annotation> A synthesizeAnnotation(\n\t\t\tA annotation, @Nullable AnnotatedElement annotatedElement) {\n\n\t\tif (isSynthesizedAnnotation(annotation) || AnnotationFilter.PLAIN.matches(annotation)) {\n\t\t\treturn annotation;\n\t\t}\n\t\treturn MergedAnnotation.from(annotatedElement, annotation).synthesize();\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#unique(MergedAnnotation<A>,keyExtractor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new stateful, single use {@link Predicate} that matches\n\t * annotations that are unique based on the extracted key. For example\n\t * {@code MergedAnnotationPredicates.unique(MergedAnnotation::getType)} will\n\t * match the first time a unique type is encountered.\n\t * @param keyExtractor function used to extract the key used to test for\n\t * uniqueness\n\t * @return a {@link Predicate} that matches a unique annotation based on the\n\t * extracted key\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MergedAnnotation<A>",
      "keyExtractor"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "Predicate<MergedAnnotation<A>>",
    "signature": "public Predicate<MergedAnnotation<A>> unique(Function<? super MergedAnnotation<A>, K> keyExtractor)",
    "source_code": "\tpublic static <A extends Annotation, K> Predicate<MergedAnnotation<A>> unique(\n\t\t\tFunction<? super MergedAnnotation<A>, K> keyExtractor) {\n\n\t\treturn new UniquePredicate<>(keyExtractor);\n\t}"
  },
  "org.springframework.core.codec.<unknown>#canDecode(elementType,mimeType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "boolean",
    "signature": "public boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\treturn (ByteBuf.class.isAssignableFrom(elementType.toClass()) &&\n\t\t\t\tsuper.canDecode(elementType, mimeType));\n\t}"
  },
  "org.springframework.core.codec.<unknown>#canEncode(type,mimeType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "boolean",
    "signature": "public boolean canEncode(ResolvableType type, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canEncode(ResolvableType type, @Nullable MimeType mimeType) {\n\t\tClass<?> clazz = type.toClass();\n\t\treturn super.canEncode(type, mimeType) && ByteBuf.class.isAssignableFrom(clazz);\n\t}"
  },
  "org.springframework.core.codec.<unknown>#decode(dataBuffer,elementType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataBuffer",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "ByteBuf",
    "signature": "public ByteBuf decode(DataBuffer dataBuffer, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic ByteBuf decode(DataBuffer dataBuffer, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(Hints.getLogPrefix(hints) + \"Read \" + dataBuffer.readableByteCount() + \" bytes\");\n\t\t}\n\t\tif (dataBuffer instanceof NettyDataBuffer nettyDataBuffer) {\n\t\t\treturn nettyDataBuffer.getNativeBuffer();\n\t\t}\n\t\tByteBuf byteBuf;\n\t\tbyte[] bytes = new byte[dataBuffer.readableByteCount()];\n\t\tdataBuffer.read(bytes);\n\t\tbyteBuf = Unpooled.wrappedBuffer(bytes);\n\t\tDataBufferUtils.release(dataBuffer);\n\t\treturn byteBuf;\n\t}"
  },
  "org.springframework.core.codec.<unknown>#encode(inputStream,bufferFactory,elementType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "bufferFactory",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> encode(Publisher<? extends ByteBuf> inputStream,\n\t\t\tDataBufferFactory bufferFactory, ResolvableType elementType, @Nullable MimeType mimeType,\n\t\t\t@Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Flux<DataBuffer> encode(Publisher<? extends ByteBuf> inputStream,\n\t\t\tDataBufferFactory bufferFactory, ResolvableType elementType, @Nullable MimeType mimeType,\n\t\t\t@Nullable Map<String, Object> hints) {\n\n\t\treturn Flux.from(inputStream).map(byteBuffer ->\n\t\t\t\tencodeValue(byteBuffer, bufferFactory, elementType, mimeType, hints));\n\t}"
  },
  "org.springframework.core.codec.<unknown>#encodeValue(buffer,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "buffer",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer encodeValue(Buffer buffer, DataBufferFactory bufferFactory, ResolvableType valueType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic DataBuffer encodeValue(Buffer buffer, DataBufferFactory bufferFactory, ResolvableType valueType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tif (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {\n\t\t\tString logPrefix = Hints.getLogPrefix(hints);\n\t\t\tlogger.debug(logPrefix + \"Writing \" + buffer.readableBytes() + \" bytes\");\n\t\t}\n\t\tif (bufferFactory instanceof Netty5DataBufferFactory netty5DataBufferFactory) {\n\t\t\treturn netty5DataBufferFactory.wrap(buffer);\n\t\t}\n\t\tbyte[] bytes = new byte[buffer.readableBytes()];\n\t\tbuffer.readBytes(bytes, 0, bytes.length);\n\t\tbuffer.close();\n\t\treturn bufferFactory.wrap(bytes);\n\t}"
  },
  "org.springframework.core.codec.<unknown>#encodeValue(byteBuf,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "byteBuf",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer encodeValue(ByteBuf byteBuf, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic DataBuffer encodeValue(ByteBuf byteBuf, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tif (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {\n\t\t\tString logPrefix = Hints.getLogPrefix(hints);\n\t\t\tlogger.debug(logPrefix + \"Writing \" + byteBuf.readableBytes() + \" bytes\");\n\t\t}\n\t\tif (bufferFactory instanceof NettyDataBufferFactory nettyDataBufferFactory) {\n\t\t\treturn nettyDataBufferFactory.wrap(byteBuf);\n\t\t}\n\t\tbyte[] bytes = new byte[byteBuf.readableBytes()];\n\t\tbyteBuf.readBytes(bytes);\n\t\tbyteBuf.release();\n\t\treturn bufferFactory.wrap(bytes);\n\t}"
  },
  "org.springframework.core.codec.<unknown>#parseSseLines(state,blackhole)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "state",
      "blackhole"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "void",
    "signature": "public void parseSseLines(SseLinesState state, Blackhole blackhole)",
    "source_code": "\tpublic void parseSseLines(SseLinesState state, Blackhole blackhole) {\n\t\tblackhole.consume(state.parseLines().blockLast());\n\t}"
  },
  "org.springframework.core.convert.<unknown>#collection(collectionType,elementTypeDescriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new type descriptor from a {@link java.util.Collection} type.\n\t * <p>Useful for converting to typed Collections.\n\t * <p>For example, a {@code List<String>} could be converted to a\n\t * {@code List<EmailAddress>} by converting to a targetType built with this method.\n\t * The method call to construct such a {@code TypeDescriptor} would look something\n\t * like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class));}\n\t * @param collectionType the collection type, which must implement {@link Collection}.\n\t * @param elementTypeDescriptor a descriptor for the collection's element type,\n\t * used to convert collection elements\n\t * @return the collection type descriptor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collectionType",
      "elementTypeDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 566
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor)",
    "source_code": "\tpublic static TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor) {\n\t\tAssert.notNull(collectionType, \"Collection type must not be null\");\n\t\tif (!Collection.class.isAssignableFrom(collectionType)) {\n\t\t\tthrow new IllegalArgumentException(\"Collection type must be a [java.util.Collection]\");\n\t\t}\n\t\tResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null);\n\t\treturn new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null);\n\t}"
  },
  "org.springframework.core.convert.<unknown>#map(mapType,keyTypeDescriptor,valueTypeDescriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new type descriptor from a {@link java.util.Map} type.\n\t * <p>Useful for converting to typed Maps.\n\t * <p>For example, a {@code Map<String, String>} could be converted to a {@code Map<Id, EmailAddress>}\n\t * by converting to a targetType built with this method:\n\t * The method call to construct such a TypeDescriptor would look something like:\n\t * <pre class=\"code\">\n\t * map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class));\n\t * </pre>\n\t * @param mapType the map type, which must implement {@link Map}\n\t * @param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys\n\t * @param valueTypeDescriptor the map's value type, used to convert map values\n\t * @return the map type descriptor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapType",
      "keyTypeDescriptor",
      "valueTypeDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 589
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor,\n\t\t\t@Nullable TypeDescriptor valueTypeDescriptor)",
    "source_code": "\tpublic static TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor,\n\t\t\t@Nullable TypeDescriptor valueTypeDescriptor) {\n\n\t\tAssert.notNull(mapType, \"Map type must not be null\");\n\t\tif (!Map.class.isAssignableFrom(mapType)) {\n\t\t\tthrow new IllegalArgumentException(\"Map type must be a [java.util.Map]\");\n\t\t}\n\t\tResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null);\n\t\tResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null);\n\t\treturn new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null);\n\t}"
  },
  "org.springframework.core.convert.<unknown>#nested(field,nestingLevel)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a type descriptor for a nested type declared within the field.\n\t * <p>For example, if the field is a {@code List<String>} and the nesting\n\t * level is 1, the nested type descriptor will be {@code String.class}.\n\t * <p>If the field is a {@code List<List<String>>} and the nesting level is\n\t * 2, the nested type descriptor will also be a {@code String.class}.\n\t * <p>If the field is a {@code Map<Integer, String>} and the nesting level\n\t * is 1, the nested type descriptor will be String, derived from the map value.\n\t * <p>If the field is a {@code List<Map<Integer, String>>} and the nesting\n\t * level is 2, the nested type descriptor will be String, derived from the map value.\n\t * <p>Returns {@code null} if a nested type cannot be obtained because it was not\n\t * declared. For example, if the field is a {@code List<?>}, the nested type\n\t * descriptor returned will be {@code null}.\n\t * @param field the field\n\t * @param nestingLevel the nesting level of the collection/array element or\n\t * map key/value declaration within the field\n\t * @return the nested type descriptor at the specified nesting level,\n\t * or {@code null} if it could not be obtained\n\t * @throws IllegalArgumentException if the types up to the specified nesting\n\t * level are not of collection, array, or map types\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 673
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor nested(Field field, int nestingLevel)",
    "source_code": "\tpublic static TypeDescriptor nested(Field field, int nestingLevel) {\n\t\treturn nested(new TypeDescriptor(field), nestingLevel);\n\t}"
  },
  "org.springframework.core.convert.<unknown>#nested(methodParameter,nestingLevel)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a type descriptor for a nested type declared within the method parameter.\n\t * <p>For example, if the methodParameter is a {@code List<String>} and the\n\t * nesting level is 1, the nested type descriptor will be String.class.\n\t * <p>If the methodParameter is a {@code List<List<String>>} and the nesting\n\t * level is 2, the nested type descriptor will also be a String.class.\n\t * <p>If the methodParameter is a {@code Map<Integer, String>} and the nesting\n\t * level is 1, the nested type descriptor will be String, derived from the map value.\n\t * <p>If the methodParameter is a {@code List<Map<Integer, String>>} and the\n\t * nesting level is 2, the nested type descriptor will be String, derived from the map value.\n\t * <p>Returns {@code null} if a nested type cannot be obtained because it was not declared.\n\t * For example, if the method parameter is a {@code List<?>}, the nested type\n\t * descriptor returned will be {@code null}.\n\t * @param methodParameter the method parameter with a nestingLevel of 1\n\t * @param nestingLevel the nesting level of the collection/array element or\n\t * map key/value declaration within the method parameter\n\t * @return the nested type descriptor at the specified nesting level,\n\t * or {@code null} if it could not be obtained\n\t * @throws IllegalArgumentException if the nesting level of the input\n\t * {@link MethodParameter} argument is not 1, or if the types up to the\n\t * specified nesting level are not of collection, array, or map types\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodParameter",
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 643
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel)",
    "source_code": "\tpublic static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {\n\t\tif (methodParameter.getNestingLevel() != 1) {\n\t\t\tthrow new IllegalArgumentException(\"MethodParameter nesting level must be 1: \" +\n\t\t\t\t\t\"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal\");\n\t\t}\n\t\treturn nested(new TypeDescriptor(methodParameter), nestingLevel);\n\t}"
  },
  "org.springframework.core.convert.<unknown>#nested(property,nestingLevel)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a type descriptor for a nested type declared within the property.\n\t * <p>For example, if the property is a {@code List<String>} and the nesting\n\t * level is 1, the nested type descriptor will be {@code String.class}.\n\t * <p>If the property is a {@code List<List<String>>} and the nesting level\n\t * is 2, the nested type descriptor will also be a {@code String.class}.\n\t * <p>If the property is a {@code Map<Integer, String>} and the nesting level\n\t * is 1, the nested type descriptor will be String, derived from the map value.\n\t * <p>If the property is a {@code List<Map<Integer, String>>} and the nesting\n\t * level is 2, the nested type descriptor will be String, derived from the map value.\n\t * <p>Returns {@code null} if a nested type cannot be obtained because it was not\n\t * declared. For example, if the property is a {@code List<?>}, the nested type\n\t * descriptor returned will be {@code null}.\n\t * @param property the property\n\t * @param nestingLevel the nesting level of the collection/array element or\n\t * map key/value declaration within the property\n\t * @return the nested type descriptor at the specified nesting level, or\n\t * {@code null} if it could not be obtained\n\t * @throws IllegalArgumentException if the types up to the specified nesting\n\t * level are not of collection, array, or map types\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "property",
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 699
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor nested(Property property, int nestingLevel)",
    "source_code": "\tpublic static TypeDescriptor nested(Property property, int nestingLevel) {\n\t\treturn nested(new TypeDescriptor(property), nestingLevel);\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#addConverter(Converter<?,converter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Converter<?",
      "converter"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void addConverter(Converter<?, ?> converter)",
    "source_code": "\tpublic void addConverter(Converter<?, ?> converter) {\n\t\tResolvableType[] typeInfo = getRequiredTypeInfo(converter.getClass(), Converter.class);\n\t\tif (typeInfo == null && converter instanceof DecoratingProxy decoratingProxy) {\n\t\t\ttypeInfo = getRequiredTypeInfo(decoratingProxy.getDecoratedClass(), Converter.class);\n\t\t}\n\t\tif (typeInfo == null) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to determine source type <S> and target type <T> for your \" +\n\t\t\t\t\t\"Converter [\" + converter.getClass().getName() + \"]; does the class parameterize those types?\");\n\t\t}\n\t\taddConverter(new ConverterAdapter(converter, typeInfo[0], typeInfo[1]));\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#addConverter(sourceType,targetType,S,converter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType",
      "S",
      "converter"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void addConverter(Class<S> sourceType, Class<T> targetType, Converter<? super S, ? extends T> converter)",
    "source_code": "\tpublic <S, T> void addConverter(Class<S> sourceType, Class<T> targetType, Converter<? super S, ? extends T> converter) {\n\t\taddConverter(new ConverterAdapter(\n\t\t\t\tconverter, ResolvableType.forClass(sourceType), ResolvableType.forClass(targetType)));\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#addConverterFactory(ConverterFactory<?,factory)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ConverterFactory<?",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void addConverterFactory(ConverterFactory<?, ?> factory)",
    "source_code": "\tpublic void addConverterFactory(ConverterFactory<?, ?> factory) {\n\t\tResolvableType[] typeInfo = getRequiredTypeInfo(factory.getClass(), ConverterFactory.class);\n\t\tif (typeInfo == null && factory instanceof DecoratingProxy decoratingProxy) {\n\t\t\ttypeInfo = getRequiredTypeInfo(decoratingProxy.getDecoratedClass(), ConverterFactory.class);\n\t\t}\n\t\tif (typeInfo == null) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to determine source type <S> and target type <T> for your \" +\n\t\t\t\t\t\"ConverterFactory [\" + factory.getClass().getName() + \"]; does the class parameterize those types?\");\n\t\t}\n\t\taddConverter(new ConverterFactoryAdapter(factory,\n\t\t\t\tnew ConvertiblePair(typeInfo[0].toClass(), typeInfo[1].toClass())));\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#canBypassConvert(sourceType,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether conversion between the source type and the target type can be bypassed.\n\t * <p>More precisely, this method will return true if objects of sourceType can be\n\t * converted to the target type by returning the source object unchanged.\n\t * @param sourceType context about the source type to convert from\n\t * (may be {@code null} if source is {@code null})\n\t * @param targetType context about the target type to convert to (required)\n\t * @return {@code true} if conversion can be bypassed; {@code false} otherwise\n\t * @throws IllegalArgumentException if targetType is {@code null}\n\t * @since 3.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "boolean",
    "signature": "public boolean canBypassConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\tpublic boolean canBypassConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tAssert.notNull(targetType, \"Target type to convert to cannot be null\");\n\t\tif (sourceType == null) {\n\t\t\treturn true;\n\t\t}\n\t\tGenericConverter converter = getConverter(sourceType, targetType);\n\t\treturn (converter == NO_OP_CONVERTER);\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#canConvert(sourceType,targetType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "boolean",
    "signature": "public boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\tpublic boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tAssert.notNull(targetType, \"Target type to convert to cannot be null\");\n\t\tif (sourceType == null) {\n\t\t\treturn true;\n\t\t}\n\t\tGenericConverter converter = getConverter(sourceType, targetType);\n\t\treturn (converter != null);\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#convert(source,sourceType,targetType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "Object",
    "signature": "public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\tpublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tboolean byteBufferTarget = targetType.isAssignableTo(BYTE_BUFFER_TYPE);\n\t\tif (source instanceof ByteBuffer buffer) {\n\t\t\treturn (byteBufferTarget ? buffer.duplicate() : convertFromByteBuffer(buffer, targetType));\n\t\t}\n\t\tif (byteBufferTarget) {\n\t\t\treturn convertToByteBuffer(source, sourceType);\n\t\t}\n\t\t// Should not happen\n\t\tthrow new IllegalStateException(\"Unexpected source/target types\");\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#convert(source,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience operation for converting a source object to the specified targetType,\n\t * where the target type is a descriptor that provides additional conversion context.\n\t * Simply delegates to {@link #convert(Object, TypeDescriptor, TypeDescriptor)} and\n\t * encapsulates the construction of the source type descriptor using\n\t * {@link TypeDescriptor#forObject(Object)}.\n\t * @param source the source object\n\t * @param targetType the target type\n\t * @return the converted value\n\t * @throws ConversionException if a conversion exception occurred\n\t * @throws IllegalArgumentException if targetType is {@code null},\n\t * or sourceType is {@code null} but source is not {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "Object",
    "signature": "public Object convert(@Nullable Object source, TypeDescriptor targetType)",
    "source_code": "\tpublic Object convert(@Nullable Object source, TypeDescriptor targetType) {\n\t\treturn convert(source, TypeDescriptor.forObject(source), targetType);\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#convertNullSource(sourceType,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template method to convert a {@code null} source.\n\t * <p>The default implementation returns {@code null} or the Java 8\n\t * {@link java.util.Optional#empty()} instance if the target type is\n\t * {@code java.util.Optional}. Subclasses may override this to return\n\t * custom {@code null} objects for specific target types.\n\t * @param sourceType the source type to convert from\n\t * @param targetType the target type to convert to\n\t * @return the converted null object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "Object",
    "signature": "protected Object convertNullSource(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\tprotected Object convertNullSource(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tif (targetType.getObjectType() == Optional.class) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#find(sourceType,targetType)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Find a {@link GenericConverter} given a source and target type.\n\t\t * <p>This method will attempt to match all possible converters by working\n\t\t * through the class and interface hierarchy of the types.\n\t\t * @param sourceType the source type\n\t\t * @param targetType the target type\n\t\t * @return a matching {@link GenericConverter}, or {@code null} if none found\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 537
    },
    "return": "GenericConverter",
    "signature": "public GenericConverter find(TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\t\tpublic GenericConverter find(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\t// Search the full type hierarchy\n\t\t\tList<Class<?>> sourceCandidates = getClassHierarchy(sourceType.getType());\n\t\t\tList<Class<?>> targetCandidates = getClassHierarchy(targetType.getType());\n\t\t\tfor (Class<?> sourceCandidate : sourceCandidates) {\n\t\t\t\tfor (Class<?> targetCandidate : targetCandidates) {\n\t\t\t\t\tConvertiblePair convertiblePair = new ConvertiblePair(sourceCandidate, targetCandidate);\n\t\t\t\t\tGenericConverter converter = getRegisteredConverter(sourceType, targetType, convertiblePair);\n\t\t\t\t\tif (converter != null) {\n\t\t\t\t\t\treturn converter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.core.convert.support.<unknown>#getConverter(sourceType,targetType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 660
    },
    "return": "GenericConverter",
    "signature": "public GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\t\tpublic GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tfor (GenericConverter converter : this.converters) {\n\t\t\t\tif (!(converter instanceof ConditionalGenericConverter genericConverter) ||\n\t\t\t\t\t\tgenericConverter.matches(sourceType, targetType)) {\n\t\t\t\t\treturn converter;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.core.convert.support.<unknown>#getDefaultConverter(sourceType,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return the default converter if no converter is found for the given sourceType/targetType pair.\n\t * <p>Returns a NO_OP Converter if the source type is assignable to the target type.\n\t * Returns {@code null} otherwise, indicating no suitable converter could be found.\n\t * @param sourceType the source type to convert from\n\t * @param targetType the target type to convert to\n\t * @return the default generic converter that will perform the conversion\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "GenericConverter",
    "signature": "protected GenericConverter getDefaultConverter(TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\tprotected GenericConverter getDefaultConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\treturn (sourceType.isAssignableTo(targetType) ? NO_OP_CONVERTER : null);\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#matches(sourceType,targetType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "boolean",
    "signature": "public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tboolean byteBufferTarget = targetType.isAssignableTo(BYTE_BUFFER_TYPE);\n\t\tif (sourceType.isAssignableTo(BYTE_BUFFER_TYPE)) {\n\t\t\treturn (byteBufferTarget || matchesFromByteBuffer(targetType));\n\t\t}\n\t\treturn (byteBufferTarget && matchesToByteBuffer(sourceType));\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#registerConverters(converters,registry)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given Converter objects with the given target ConverterRegistry.\n\t * @param converters the converter objects: implementing {@link Converter},\n\t * {@link ConverterFactory}, or {@link GenericConverter}\n\t * @param registry the target registry\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "converters",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "void",
    "signature": "public void registerConverters(@Nullable Set<?> converters, ConverterRegistry registry)",
    "source_code": "\tpublic static void registerConverters(@Nullable Set<?> converters, ConverterRegistry registry) {\n\t\tif (converters != null) {\n\t\t\tfor (Object candidate : converters) {\n\t\t\t\tif (candidate instanceof GenericConverter genericConverter) {\n\t\t\t\t\tregistry.addConverter(genericConverter);\n\t\t\t\t}\n\t\t\t\telse if (candidate instanceof Converter<?, ?> converter) {\n\t\t\t\t\tregistry.addConverter(converter);\n\t\t\t\t}\n\t\t\t\telse if (candidate instanceof ConverterFactory<?, ?> converterFactory) {\n\t\t\t\t\tregistry.addConverterFactory(converterFactory);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Each converter object must implement one of the \" +\n\t\t\t\t\t\t\t\"Converter, ConverterFactory, or GenericConverter interfaces\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#remove(sourceType,targetType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 524
    },
    "return": "void",
    "signature": "public void remove(Class<?> sourceType, Class<?> targetType)",
    "source_code": "\t\tpublic void remove(Class<?> sourceType, Class<?> targetType) {\n\t\t\tthis.converters.remove(new ConvertiblePair(sourceType, targetType));\n\t\t}"
  },
  "org.springframework.core.convert.support.<unknown>#removeConvertible(sourceType,targetType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void removeConvertible(Class<?> sourceType, Class<?> targetType)",
    "source_code": "\tpublic void removeConvertible(Class<?> sourceType, Class<?> targetType) {\n\t\tthis.converters.remove(sourceType, targetType);\n\t\tinvalidateCache();\n\t}"
  },
  "org.springframework.core.env.<unknown>#getProperty(key,targetValueType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "targetValueType"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "T",
    "signature": "public T getProperty(String key, Class<T> targetValueType)",
    "source_code": "\tpublic <T> T getProperty(String key, Class<T> targetValueType) {\n\t\treturn getProperty(key, targetValueType, true);\n\t}"
  },
  "org.springframework.core.env.<unknown>#getProperty(key,targetValueType,resolveNestedPlaceholders)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key",
      "targetValueType",
      "resolveNestedPlaceholders"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "T",
    "signature": "protected T getProperty(String key, Class<T> targetValueType, boolean resolveNestedPlaceholders)",
    "source_code": "\tprotected <T> T getProperty(String key, Class<T> targetValueType, boolean resolveNestedPlaceholders) {\n\t\tif (this.propertySources != null) {\n\t\t\tfor (PropertySource<?> propertySource : this.propertySources) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Searching for key '\" + key + \"' in PropertySource '\" +\n\t\t\t\t\t\t\tpropertySource.getName() + \"'\");\n\t\t\t\t}\n\t\t\t\tObject value = propertySource.getProperty(key);\n\t\t\t\tif (value != null) {\n\t\t\t\t\tif (resolveNestedPlaceholders && value instanceof String string) {\n\t\t\t\t\t\tvalue = resolveNestedPlaceholders(string);\n\t\t\t\t\t}\n\t\t\t\t\tlogKeyFound(key, propertySource, value);\n\t\t\t\t\treturn convertValueIfNecessary(value, targetValueType);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Could not find key '\" + key + \"' in any property source\");\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.core.env.<unknown>#logKeyFound(key,propertySource,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Log the given key as found in the given {@link PropertySource}, resulting in\n\t * the given value.\n\t * <p>The default implementation writes a debug log message with key and source.\n\t * As of 4.3.3, this does not log the value anymore in order to avoid accidental\n\t * logging of sensitive settings. Subclasses may override this method to change\n\t * the log level and/or log message, including the property's value if desired.\n\t * @param key the key found\n\t * @param propertySource the {@code PropertySource} that the key has been found in\n\t * @param value the corresponding value\n\t * @since 4.3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key",
      "propertySource",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "protected void logKeyFound(String key, PropertySource<?> propertySource, Object value)",
    "source_code": "\tprotected void logKeyFound(String key, PropertySource<?> propertySource, Object value) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Found key '\" + key + \"' in PropertySource '\" + propertySource.getName() +\n\t\t\t\t\t\"' with value of type \" + value.getClass().getSimpleName());\n\t\t}\n\t}"
  },
  "org.springframework.core.io.<unknown>#invokeVfsMethod(method,target,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "target",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "Object",
    "signature": "protected Object invokeVfsMethod(Method method, @Nullable Object target, Object... args)",
    "source_code": "\tprotected static Object invokeVfsMethod(Method method, @Nullable Object target, Object... args) throws IOException {\n\t\ttry {\n\t\t\treturn method.invoke(target, args);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tThrowable targetEx = ex.getTargetException();\n\t\t\tif (targetEx instanceof IOException ioException) {\n\t\t\t\tthrow ioException;\n\t\t\t}\n\t\t\tReflectionUtils.handleInvocationTargetException(ex);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tReflectionUtils.handleReflectionException(ex);\n\t\t}\n\n\t\tthrow new IllegalStateException(\"Invalid code path reached\");\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#asByteBuffer(index,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 387
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer asByteBuffer(int index, int length)",
    "source_code": "\tpublic ByteBuffer asByteBuffer(int index, int length) {\n\t\tcheckIndex(index, length);\n\n\t\tByteBuffer duplicate = this.byteBuffer.duplicate();\n\t\tduplicate.position(index);\n\t\tduplicate.limit(index + length);\n\t\treturn duplicate.slice();\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#completed(read,attachment)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "read",
      "attachment"
    ],
    "position": {
      "column": 1,
      "line": 998
    },
    "return": "void",
    "signature": "public void completed(Integer read, Attachment attachment)",
    "source_code": "\t\tpublic void completed(Integer read, Attachment attachment) {\n\t\t\tattachment.iterator().close();\n\t\t\tDataBuffer dataBuffer = attachment.dataBuffer();\n\n\t\t\tif (this.state.get().equals(State.DISPOSED)) {\n\t\t\t\trelease(dataBuffer);\n\t\t\t\tcloseChannel(this.channel);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (read == -1) {\n\t\t\t\trelease(dataBuffer);\n\t\t\t\tcloseChannel(this.channel);\n\t\t\t\tthis.state.set(State.DISPOSED);\n\t\t\t\tthis.sink.complete();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.position.addAndGet(read);\n\t\t\tdataBuffer.writePosition(read);\n\t\t\tthis.sink.next(dataBuffer);\n\n\t\t\t// Stay in READING mode if there is demand\n\t\t\tif (this.sink.requestedFromDownstream() > 0) {\n\t\t\t\tread();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Release READING mode and then try again in case of concurrent \"request\"\n\t\t\tif (this.state.compareAndSet(State.READING, State.IDLE)) {\n\t\t\t\ttryRead();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#completed(written,attachment)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "written",
      "attachment"
    ],
    "position": {
      "column": 1,
      "line": 1161
    },
    "return": "void",
    "signature": "public void completed(Integer written, Attachment attachment)",
    "source_code": "\t\tpublic void completed(Integer written, Attachment attachment) {\n\t\t\tDataBuffer.ByteBufferIterator iterator = attachment.iterator();\n\t\t\titerator.close();\n\n\t\t\tlong pos = this.position.addAndGet(written);\n\t\t\tByteBuffer byteBuffer = attachment.byteBuffer();\n\n\t\t\tif (byteBuffer.hasRemaining()) {\n\t\t\t\tthis.channel.write(byteBuffer, pos, attachment, this);\n\t\t\t}\n\t\t\telse if (iterator.hasNext()) {\n\t\t\t\tByteBuffer next = iterator.next();\n\t\t\t\tthis.channel.write(next, pos, attachment, this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.sink.next(attachment.dataBuffer());\n\t\t\t\tthis.writing.set(false);\n\n\t\t\t\tThrowable throwable = this.error.get();\n\t\t\t\tif (throwable != null) {\n\t\t\t\t\tthis.sink.error(throwable);\n\t\t\t\t}\n\t\t\t\telse if (this.completed.get()) {\n\t\t\t\t\tthis.sink.complete();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trequest(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#failed(exc,attachment)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exc",
      "attachment"
    ],
    "position": {
      "column": 1,
      "line": 1193
    },
    "return": "void",
    "signature": "public void failed(Throwable exc, Attachment attachment)",
    "source_code": "\t\tpublic void failed(Throwable exc, Attachment attachment) {\n\t\t\tattachment.iterator().close();\n\n\t\t\tthis.sink.next(attachment.dataBuffer());\n\t\t\tthis.writing.set(false);\n\n\t\t\tthis.sink.error(exc);\n\t\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#indexOf(predicate,fromIndex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "int",
    "signature": "public int indexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\tAssert.notNull(predicate, \"IntPredicate must not be null\");\n\t\tif (fromIndex < 0) {\n\t\t\tfromIndex = 0;\n\t\t}\n\t\telse if (fromIndex >= this.writePosition) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int i = fromIndex; i < this.writePosition; i++) {\n\t\t\tbyte b = this.byteBuffer.get(i);\n\t\t\tif (predicate.test(b)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#join(buffers,maxByteCount)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #join(Publisher)} that behaves the same way up until\n\t * the specified max number of bytes to buffer. Once the limit is exceeded,\n\t * {@link DataBufferLimitException} is raised.\n\t * @param buffers the data buffers that are to be composed\n\t * @param maxByteCount the max number of bytes to buffer, or -1 for unlimited\n\t * @return a buffer with the aggregated content, possibly an empty Mono if\n\t * the max number of bytes to buffer is exceeded.\n\t * @throws DataBufferLimitException if maxByteCount is exceeded\n\t * @since 5.1.11\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "buffers",
      "maxByteCount"
    ],
    "position": {
      "column": 1,
      "line": 592
    },
    "return": "Mono<DataBuffer>",
    "signature": "public Mono<DataBuffer> join(Publisher<? extends DataBuffer> buffers, int maxByteCount)",
    "source_code": "\tpublic static Mono<DataBuffer> join(Publisher<? extends DataBuffer> buffers, int maxByteCount) {\n\t\tAssert.notNull(buffers, \"'buffers' must not be null\");\n\n\t\tif (buffers instanceof Mono mono) {\n\t\t\treturn mono;\n\t\t}\n\n\t\treturn Flux.from(buffers)\n\t\t\t\t.collect(() -> new LimitedDataBufferList(maxByteCount), LimitedDataBufferList::add)\n\t\t\t\t.filter(list -> !list.isEmpty())\n\t\t\t\t.map(list -> list.get(0).factory().join(list))\n\t\t\t\t.doOnDiscard(DataBuffer.class, DataBufferUtils::release);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#lastIndexOf(predicate,fromIndex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "int",
    "signature": "public int lastIndexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\tpublic int lastIndexOf(IntPredicate predicate, int fromIndex) {\n\t\tAssert.notNull(predicate, \"IntPredicate must not be null\");\n\t\tint i = Math.min(fromIndex, this.writePosition - 1);\n\t\tfor (; i >= 0; i--) {\n\t\t\tbyte b = this.byteBuffer.get(i);\n\t\t\tif (predicate.test(b)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#read(destination,offset,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "DefaultDataBuffer",
    "signature": "public DefaultDataBuffer read(byte[] destination, int offset, int length)",
    "source_code": "\tpublic DefaultDataBuffer read(byte[] destination, int offset, int length) {\n\t\tAssert.notNull(destination, \"Byte array must not be null\");\n\t\tassertIndex(this.readPosition <= this.writePosition - length,\n\t\t\t\t\"readPosition %d and length %d should be smaller than writePosition %d\",\n\t\t\t\tthis.readPosition, length, this.writePosition);\n\n\t\tByteBuffer tmp = this.byteBuffer.duplicate();\n\t\tint limit = this.readPosition + length;\n\t\ttmp.clear().position(this.readPosition).limit(limit);\n\t\ttmp.get(destination, offset, length);\n\n\t\tthis.readPosition += length;\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#read(path,bufferFactory,bufferSize,options)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Read bytes from the given file {@code Path} into a {@code Flux} of {@code DataBuffer}s.\n\t * The method ensures that the file is closed when the flux is terminated.\n\t * @param path the path to read bytes from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "bufferFactory",
      "bufferSize",
      "options"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> read(Path path, DataBufferFactory bufferFactory, int bufferSize, OpenOption... options)",
    "source_code": "\tpublic static Flux<DataBuffer> read(\n\t\t\tPath path, DataBufferFactory bufferFactory, int bufferSize, OpenOption... options) {\n\n\t\tAssert.notNull(path, \"Path must not be null\");\n\t\tAssert.notNull(bufferFactory, \"DataBufferFactory must not be null\");\n\t\tAssert.isTrue(bufferSize > 0, \"'bufferSize' must be > 0\");\n\t\tif (options.length > 0) {\n\t\t\tfor (OpenOption option : options) {\n\t\t\t\tAssert.isTrue(!(option == StandardOpenOption.APPEND || option == StandardOpenOption.WRITE),\n\t\t\t\t\t\t() -> \"'\" + option + \"' not allowed\");\n\t\t\t}\n\t\t}\n\n\t\treturn readAsynchronousFileChannel(() -> AsynchronousFileChannel.open(path, options),\n\t\t\t\tbufferFactory, bufferSize);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#read(resource,bufferFactory,bufferSize)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Read the given {@code Resource} into a {@code Flux} of {@code DataBuffer}s.\n\t * <p>If the resource is a file, it is read into an\n\t * {@code AsynchronousFileChannel} and turned to {@code Flux} via\n\t * {@link #readAsynchronousFileChannel(Callable, DataBufferFactory, int)} or else\n\t * fall back to {@link #readByteChannel(Callable, DataBufferFactory, int)}.\n\t * Closes the channel when the flux is terminated.\n\t * @param resource the resource to read from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "bufferFactory",
      "bufferSize"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> read(Resource resource, DataBufferFactory bufferFactory, int bufferSize)",
    "source_code": "\tpublic static Flux<DataBuffer> read(Resource resource, DataBufferFactory bufferFactory, int bufferSize) {\n\t\treturn read(resource, 0, bufferFactory, bufferSize);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#read(resource,position,bufferFactory,bufferSize)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Read the given {@code Resource} into a {@code Flux} of {@code DataBuffer}s\n\t * starting at the given position.\n\t * <p>If the resource is a file, it is read into an\n\t * {@code AsynchronousFileChannel} and turned to {@code Flux} via\n\t * {@link #readAsynchronousFileChannel(Callable, DataBufferFactory, int)} or else\n\t * fall back on {@link #readByteChannel(Callable, DataBufferFactory, int)}.\n\t * Closes the channel when the flux is terminated.\n\t * @param resource the resource to read from\n\t * @param position the position to start reading from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "position",
      "bufferFactory",
      "bufferSize"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> read(Resource resource, long position, DataBufferFactory bufferFactory, int bufferSize)",
    "source_code": "\tpublic static Flux<DataBuffer> read(\n\t\t\tResource resource, long position, DataBufferFactory bufferFactory, int bufferSize) {\n\n\t\ttry {\n\t\t\tif (resource.isFile()) {\n\t\t\t\tFile file = resource.getFile();\n\t\t\t\treturn readAsynchronousFileChannel(\n\t\t\t\t\t\t() -> AsynchronousFileChannel.open(file.toPath(), StandardOpenOption.READ),\n\t\t\t\t\t\tposition, bufferFactory, bufferSize);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ignore) {\n\t\t\t// fallback to resource.readableChannel(), below\n\t\t}\n\t\tFlux<DataBuffer> result = readByteChannel(resource::readableChannel, bufferFactory, bufferSize);\n\t\treturn position == 0 ? result : skipUntilByteCount(result, position);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#readAsynchronousFileChannel(channelSupplier,bufferFactory,bufferSize)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a {@code AsynchronousFileChannel} from the given supplier, and read\n\t * it into a {@code Flux} of {@code DataBuffer}s. Closes the channel when\n\t * the Flux is terminated.\n\t * @param channelSupplier the supplier for the channel to read from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channelSupplier",
      "bufferFactory",
      "bufferSize"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> readAsynchronousFileChannel(Callable<AsynchronousFileChannel> channelSupplier, DataBufferFactory bufferFactory, int bufferSize)",
    "source_code": "\tpublic static Flux<DataBuffer> readAsynchronousFileChannel(\n\t\t\tCallable<AsynchronousFileChannel> channelSupplier, DataBufferFactory bufferFactory, int bufferSize) {\n\n\t\treturn readAsynchronousFileChannel(channelSupplier, 0, bufferFactory, bufferSize);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#readAsynchronousFileChannel(channelSupplier,position,bufferFactory,bufferSize)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain an {@code AsynchronousFileChannel} from the given supplier, and\n\t * read it into a {@code Flux} of {@code DataBuffer}s, starting at the given\n\t * position. Closes the channel when the Flux is terminated.\n\t * @param channelSupplier the supplier for the channel to read from\n\t * @param position the position to start reading from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channelSupplier",
      "position",
      "bufferFactory",
      "bufferSize"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> readAsynchronousFileChannel(Callable<AsynchronousFileChannel> channelSupplier, long position,\n\t\t\tDataBufferFactory bufferFactory, int bufferSize)",
    "source_code": "\tpublic static Flux<DataBuffer> readAsynchronousFileChannel(\n\t\t\tCallable<AsynchronousFileChannel> channelSupplier, long position,\n\t\t\tDataBufferFactory bufferFactory, int bufferSize) {\n\n\t\tAssert.notNull(channelSupplier, \"'channelSupplier' must not be null\");\n\t\tAssert.notNull(bufferFactory, \"'bufferFactory' must not be null\");\n\t\tAssert.isTrue(position >= 0, \"'position' must be >= 0\");\n\t\tAssert.isTrue(bufferSize > 0, \"'bufferSize' must be > 0\");\n\n\t\tFlux<DataBuffer> flux = Flux.using(channelSupplier,\n\t\t\t\tchannel -> Flux.create(sink -> {\n\t\t\t\t\tReadCompletionHandler handler =\n\t\t\t\t\t\t\tnew ReadCompletionHandler(channel, sink, position, bufferFactory, bufferSize);\n\t\t\t\t\tsink.onCancel(handler::cancel);\n\t\t\t\t\tsink.onRequest(handler::request);\n\t\t\t\t}),\n\t\t\t\tchannel -> {\n\t\t\t\t\t// Do not close channel from here, rather wait for the current read callback\n\t\t\t\t\t// and then complete after releasing the DataBuffer.\n\t\t\t\t});\n\n\t\treturn flux.doOnDiscard(DataBuffer.class, DataBufferUtils::release);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#readByteChannel(channelSupplier,bufferFactory,bufferSize)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a {@link ReadableByteChannel} from the given supplier, and read\n\t * it into a {@code Flux} of {@code DataBuffer}s. Closes the channel when\n\t * the Flux is terminated.\n\t * @param channelSupplier the supplier for the channel to read from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channelSupplier",
      "bufferFactory",
      "bufferSize"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> readByteChannel(Callable<ReadableByteChannel> channelSupplier, DataBufferFactory bufferFactory, int bufferSize)",
    "source_code": "\tpublic static Flux<DataBuffer> readByteChannel(\n\t\t\tCallable<ReadableByteChannel> channelSupplier, DataBufferFactory bufferFactory, int bufferSize) {\n\n\t\tAssert.notNull(channelSupplier, \"'channelSupplier' must not be null\");\n\t\tAssert.notNull(bufferFactory, \"'bufferFactory' must not be null\");\n\t\tAssert.isTrue(bufferSize > 0, \"'bufferSize' must be > 0\");\n\n\t\treturn Flux.using(channelSupplier,\n\t\t\t\tchannel -> Flux.generate(new ReadableByteChannelGenerator(channel, bufferFactory, bufferSize)),\n\t\t\t\tDataBufferUtils::closeChannel);\n\n\t\t// No doOnDiscard as operators used do not cache\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#readInputStream(inputStreamSupplier,bufferFactory,bufferSize)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain an {@link InputStream} from the given supplier, and read it into a\n\t * {@code Flux} of {@code DataBuffer}s. Closes the input stream when the\n\t * Flux is terminated.\n\t * @param inputStreamSupplier the supplier for the input stream to read from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStreamSupplier",
      "bufferFactory",
      "bufferSize"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> readInputStream(Callable<InputStream> inputStreamSupplier, DataBufferFactory bufferFactory, int bufferSize)",
    "source_code": "\tpublic static Flux<DataBuffer> readInputStream(\n\t\t\tCallable<InputStream> inputStreamSupplier, DataBufferFactory bufferFactory, int bufferSize) {\n\n\t\tAssert.notNull(inputStreamSupplier, \"'inputStreamSupplier' must not be null\");\n\t\treturn readByteChannel(() -> Channels.newChannel(inputStreamSupplier.call()), bufferFactory, bufferSize);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#skipUntilByteCount(publisher,maxByteCount)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Skip buffers from the given {@link Publisher} until the total\n\t * {@linkplain DataBuffer#readableByteCount() byte count} reaches\n\t * the given maximum byte count, or until the publisher is complete.\n\t * @param publisher the publisher to filter\n\t * @param maxByteCount the maximum byte count\n\t * @return a flux with the remaining part of the given publisher\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "maxByteCount"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> skipUntilByteCount(Publisher<T> publisher, long maxByteCount)",
    "source_code": "\tpublic static <T extends DataBuffer> Flux<T> skipUntilByteCount(Publisher<T> publisher, long maxByteCount) {\n\t\tAssert.notNull(publisher, \"Publisher must not be null\");\n\t\tAssert.isTrue(maxByteCount >= 0, \"'maxByteCount' must be >= 0\");\n\n\t\treturn Flux.defer(() -> {\n\t\t\tAtomicLong countDown = new AtomicLong(maxByteCount);\n\t\t\treturn Flux.from(publisher)\n\t\t\t\t\t.skipUntil(buffer -> {\n\t\t\t\t\t\tlong remainder = countDown.addAndGet(-buffer.readableByteCount());\n\t\t\t\t\t\treturn remainder < 0;\n\t\t\t\t\t})\n\t\t\t\t\t.map(buffer -> {\n\t\t\t\t\t\tlong remainder = countDown.get();\n\t\t\t\t\t\tif (remainder < 0) {\n\t\t\t\t\t\t\tcountDown.set(0);\n\t\t\t\t\t\t\tint start = buffer.readableByteCount() + (int)remainder;\n\t\t\t\t\t\t\tDataBuffer split = buffer.split(start);\n\t\t\t\t\t\t\trelease(split);\n\t\t\t\t\t\t\treturn buffer;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn buffer;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t}).doOnDiscard(DataBuffer.class, DataBufferUtils::release);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#slice(index,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "DefaultDataBuffer",
    "signature": "public DefaultDataBuffer slice(int index, int length)",
    "source_code": "\tpublic DefaultDataBuffer slice(int index, int length) {\n\t\tcheckIndex(index, length);\n\t\tint oldPosition = this.byteBuffer.position();\n\t\ttry {\n\t\t\tthis.byteBuffer.position(index);\n\t\t\tByteBuffer slice = this.byteBuffer.slice();\n\t\t\tslice.limit(length);\n\t\t\treturn new SlicedDefaultDataBuffer(slice, this.dataBufferFactory, length);\n\t\t}\n\t\tfinally {\n\t\t\tthis.byteBuffer.position(oldPosition);\n\t\t}\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#takeUntilByteCount(publisher,maxByteCount)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Relay buffers from the given {@link Publisher} until the total\n\t * {@linkplain DataBuffer#readableByteCount() byte count} reaches\n\t * the given maximum byte count, or until the publisher is complete.\n\t * @param publisher the publisher to filter\n\t * @param maxByteCount the maximum byte count\n\t * @return a flux whose maximum byte count is {@code maxByteCount}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "maxByteCount"
    ],
    "position": {
      "column": 1,
      "line": 421
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> takeUntilByteCount(Publisher<T> publisher, long maxByteCount)",
    "source_code": "\tpublic static <T extends DataBuffer> Flux<T> takeUntilByteCount(Publisher<T> publisher, long maxByteCount) {\n\t\tAssert.notNull(publisher, \"Publisher must not be null\");\n\t\tAssert.isTrue(maxByteCount >= 0, \"'maxByteCount' must be >= 0\");\n\n\t\treturn Flux.defer(() -> {\n\t\t\tAtomicLong countDown = new AtomicLong(maxByteCount);\n\t\t\treturn Flux.from(publisher)\n\t\t\t\t\t.map(buffer -> {\n\t\t\t\t\t\tlong remainder = countDown.addAndGet(-buffer.readableByteCount());\n\t\t\t\t\t\tif (remainder < 0) {\n\t\t\t\t\t\t\tint index = buffer.readableByteCount() + (int) remainder;\n\t\t\t\t\t\t\tDataBuffer split = buffer.split(index);\n\t\t\t\t\t\t\trelease(buffer);\n\t\t\t\t\t\t\treturn (T)split;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn buffer;\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.takeUntil(buffer -> countDown.get() <= 0);\n\t\t});\n\n\t\t// No doOnDiscard as operators used do not cache (and drop) buffers\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#toByteBuffer(index,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer toByteBuffer(int index, int length)",
    "source_code": "\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\tcheckIndex(index, length);\n\n\t\tByteBuffer copy = allocate(length, this.byteBuffer.isDirect());\n\t\tByteBuffer readOnly = this.byteBuffer.asReadOnlyBuffer();\n\t\treadOnly.clear().position(index).limit(index + length);\n\t\tcopy.put(readOnly);\n\t\treturn copy.flip();\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#toByteBuffer(srcPos,dest,destPos,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "srcPos",
      "dest",
      "destPos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "void",
    "signature": "public void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length)",
    "source_code": "\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\tcheckIndex(srcPos, length);\n\t\tAssert.notNull(dest, \"Dest must not be null\");\n\n\t\tdest = dest.duplicate().clear();\n\t\tdest.put(destPos, this.byteBuffer, srcPos, length);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#toString(index,length,charset)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "String",
    "signature": "public String toString(int index, int length, Charset charset)",
    "source_code": "\tpublic String toString(int index, int length, Charset charset) {\n\t\tcheckIndex(index, length);\n\t\tAssert.notNull(charset, \"Charset must not be null\");\n\n\t\tbyte[] bytes;\n\t\tint offset;\n\n\t\tif (this.byteBuffer.hasArray()) {\n\t\t\tbytes = this.byteBuffer.array();\n\t\t\toffset = this.byteBuffer.arrayOffset() + index;\n\t\t}\n\t\telse {\n\t\t\tbytes = new byte[length];\n\t\t\toffset = 0;\n\t\t\tByteBuffer duplicate = this.byteBuffer.duplicate();\n\t\t\tduplicate.clear().position(index).limit(index + length);\n\t\t\tduplicate.get(bytes, 0, length);\n\t\t}\n\t\treturn new String(bytes, offset, length, charset);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#touch(dataBuffer,hint)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Associate the given hint with the data buffer if it is a pooled buffer\n\t * and supports leak tracking.\n\t * @param dataBuffer the data buffer to attach the hint to\n\t * @param hint the hint to attach\n\t * @return the input buffer\n\t * @since 5.3.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataBuffer",
      "hint"
    ],
    "position": {
      "column": 1,
      "line": 505
    },
    "return": "T",
    "signature": "public T touch(T dataBuffer, Object hint)",
    "source_code": "\tpublic static <T extends DataBuffer> T touch(T dataBuffer, Object hint) {\n\t\tif (dataBuffer instanceof TouchableDataBuffer touchableDataBuffer) {\n\t\t\treturn (T) touchableDataBuffer.touch(hint);\n\t\t}\n\t\telse {\n\t\t\treturn dataBuffer;\n\t\t}\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(charSequence,charset)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charSequence",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(CharSequence charSequence, Charset charset)",
    "source_code": "\tpublic DataBuffer write(CharSequence charSequence, Charset charset) {\n\t\tAssert.notNull(charSequence, \"CharSequence must not be null\");\n\t\tAssert.notNull(charset, \"Charset must not be null\");\n\n\t\tthis.buffer.writeCharSequence(charSequence, charset);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(source,channel)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write the given stream of {@link DataBuffer DataBuffers} to the given\n\t * {@code AsynchronousFileChannel}. Does <strong>not</strong> close the\n\t * channel when the flux is terminated, and does <strong>not</strong>\n\t * {@linkplain #release(DataBuffer) release} the data buffers in the source.\n\t * If releasing is required, then subscribe to the returned {@code Flux}\n\t * with a {@link #releaseConsumer()}.\n\t * <p>Note that the writing process does not start until the returned\n\t * {@code Flux} is subscribed to.\n\t * @param source the stream of data buffers to be written\n\t * @param channel the channel to write to\n\t * @return a Flux containing the same buffers as in {@code source}, that\n\t * starts the writing process when subscribed to, and that publishes any\n\t * writing errors and the completion signal\n\t * @since 5.0.10\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "channel"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> write(Publisher<DataBuffer> source, AsynchronousFileChannel channel)",
    "source_code": "\tpublic static Flux<DataBuffer> write(Publisher<DataBuffer> source, AsynchronousFileChannel channel) {\n\t\treturn write(source, channel, 0);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(source,channel,position)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write the given stream of {@link DataBuffer DataBuffers} to the given\n\t * {@code AsynchronousFileChannel}. Does <strong>not</strong> close the channel\n\t * when the flux is terminated, and does <strong>not</strong>\n\t * {@linkplain #release(DataBuffer) release} the data buffers in the source.\n\t * If releasing is required, then subscribe to the returned {@code Flux} with a\n\t * {@link #releaseConsumer()}.\n\t * <p>Note that the writing process does not start until the returned\n\t * {@code Flux} is subscribed to.\n\t * @param source the stream of data buffers to be written\n\t * @param channel the channel to write to\n\t * @param position the file position where writing is to begin; must be non-negative\n\t * @return a flux containing the same buffers as in {@code source}, that\n\t * starts the writing process when subscribed to, and that publishes any\n\t * writing errors and the completion signal\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "channel",
      "position"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> write(Publisher<? extends DataBuffer> source, AsynchronousFileChannel channel, long position)",
    "source_code": "\tpublic static Flux<DataBuffer> write(\n\t\t\tPublisher<? extends DataBuffer> source, AsynchronousFileChannel channel, long position) {\n\n\t\tAssert.notNull(source, \"'source' must not be null\");\n\t\tAssert.notNull(channel, \"'channel' must not be null\");\n\t\tAssert.isTrue(position >= 0, \"'position' must be >= 0\");\n\n\t\tFlux<DataBuffer> flux = Flux.from(source);\n\t\treturn Flux.create(sink -> {\n\t\t\tWriteCompletionHandler handler = new WriteCompletionHandler(sink, channel, position);\n\t\t\tsink.onDispose(handler);\n\t\t\tflux.subscribe(handler);\n\t\t});\n\n\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(source,destination,options)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write the given stream of {@link DataBuffer DataBuffers} to the given\n\t * file {@link Path}. The optional {@code options} parameter specifies\n\t * how the file is created or opened (defaults to\n\t * {@link StandardOpenOption#CREATE CREATE},\n\t * {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and\n\t * {@link StandardOpenOption#WRITE WRITE}).\n\t * @param source the stream of data buffers to be written\n\t * @param destination the path to the file\n\t * @param options the options specifying how the file is opened\n\t * @return a {@link Mono} that indicates completion or error\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "destination",
      "options"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<DataBuffer> source, Path destination, OpenOption... options)",
    "source_code": "\tpublic static Mono<Void> write(Publisher<DataBuffer> source, Path destination, OpenOption... options) {\n\t\tAssert.notNull(source, \"Source must not be null\");\n\t\tAssert.notNull(destination, \"Destination must not be null\");\n\n\t\tSet<OpenOption> optionSet = checkWriteOptions(options);\n\n\t\treturn Mono.create(sink -> {\n\t\t\ttry {\n\t\t\t\tAsynchronousFileChannel channel = AsynchronousFileChannel.open(destination, optionSet, null);\n\t\t\t\tsink.onDispose(() -> closeChannel(channel));\n\t\t\t\twrite(source, channel).subscribe(DataBufferUtils::release,\n\t\t\t\t\t\tsink::error,\n\t\t\t\t\t\tsink::success,\n\t\t\t\t\t\tContext.of(sink.contextView()));\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tsink.error(ex);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(source,offset,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "DefaultDataBuffer",
    "signature": "public DefaultDataBuffer write(byte[] source, int offset, int length)",
    "source_code": "\tpublic DefaultDataBuffer write(byte[] source, int offset, int length) {\n\t\tAssert.notNull(source, \"Byte array must not be null\");\n\t\tensureWritable(length);\n\n\t\tByteBuffer tmp = this.byteBuffer.duplicate();\n\t\tint limit = this.writePosition + length;\n\t\ttmp.clear().position(this.writePosition).limit(limit);\n\t\ttmp.put(source, offset, length);\n\n\t\tthis.writePosition += length;\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(source,outputStream)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write the given stream of {@link DataBuffer DataBuffers} to the given\n\t * {@code OutputStream}. Does <strong>not</strong> close the output stream\n\t * when the flux is terminated, and does <strong>not</strong>\n\t * {@linkplain #release(DataBuffer) release} the data buffers in the source.\n\t * If releasing is required, then subscribe to the returned {@code Flux}\n\t * with a {@link #releaseConsumer()}.\n\t * <p>Note that the writing process does not start until the returned\n\t * {@code Flux} is subscribed to.\n\t * @param source the stream of data buffers to be written\n\t * @param outputStream the output stream to write to\n\t * @return a Flux containing the same buffers as in {@code source}, that\n\t * starts the writing process when subscribed to, and that publishes any\n\t * writing errors and the completion signal\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "outputStream"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> write(Publisher<DataBuffer> source, OutputStream outputStream)",
    "source_code": "\tpublic static Flux<DataBuffer> write(Publisher<DataBuffer> source, OutputStream outputStream) {\n\t\tAssert.notNull(source, \"'source' must not be null\");\n\t\tAssert.notNull(outputStream, \"'outputStream' must not be null\");\n\n\t\tWritableByteChannel channel = Channels.newChannel(outputStream);\n\t\treturn write(source, channel);\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#PropertySourceDescriptor(locations,ignoreResourceNotFound,name,propertySourceFactory,encoding)": {
    "deprecated": false,
    "doc": "/**\n * Describe a {@link PropertySource}.\n *\n * @param locations the locations to consider\n * @param ignoreResourceNotFound whether to fail if a location does not exist\n * @param name the name of the property source, or {@code null} to infer one\n * @param propertySourceFactory the {@link PropertySourceFactory} to use, or\n * {@code null} to use the default\n * @param encoding the encoding, or {@code null} to use the default encoding\n * @author Stephane Nicoll\n * @since 6.0\n */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locations",
      "ignoreResourceNotFound",
      "name",
      "propertySourceFactory",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "return": "record",
    "signature": "public record PropertySourceDescriptor(List<String> locations, boolean ignoreResourceNotFound,\n\t\t@Nullable String name, @Nullable Class<? extends PropertySourceFactory> propertySourceFactory,\n\t\t@Nullable String encoding)",
    "source_code": "public record PropertySourceDescriptor(List<String> locations, boolean ignoreResourceNotFound,\n\t\t@Nullable String name, @Nullable Class<? extends PropertySourceFactory> propertySourceFactory,\n\t\t@Nullable String encoding) {\n\n\t/**\n\t * Create a descriptor with the specified locations.\n\t * @param locations the locations to consider\n\t */\n\tpublic PropertySourceDescriptor(String... locations) {\n\t\tthis(Arrays.asList(locations), false, null, null, null);\n\t}\n\n}"
  },
  "org.springframework.core.io.support.<unknown>#addAllClassLoaderJarRoots(classLoader,result)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Search all {@link URLClassLoader} URLs for jar file references and add them to the\n\t * given set of resources in the form of pointers to the root of the jar file content.\n\t * @param classLoader the ClassLoader to search (including its ancestors)\n\t * @param result the set of resources to add jar roots to\n\t * @since 4.1.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "classLoader",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 419
    },
    "return": "void",
    "signature": "protected void addAllClassLoaderJarRoots(@Nullable ClassLoader classLoader, Set<Resource> result)",
    "source_code": "\tprotected void addAllClassLoaderJarRoots(@Nullable ClassLoader classLoader, Set<Resource> result) {\n\t\tif (classLoader instanceof URLClassLoader urlClassLoader) {\n\t\t\ttry {\n\t\t\t\tfor (URL url : urlClassLoader.getURLs()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tUrlResource jarResource = (ResourceUtils.URL_PROTOCOL_JAR.equals(url.getProtocol()) ?\n\t\t\t\t\t\t\t\tnew UrlResource(url) :\n\t\t\t\t\t\t\t\tnew UrlResource(ResourceUtils.JAR_URL_PREFIX + url + ResourceUtils.JAR_URL_SEPARATOR));\n\t\t\t\t\t\tif (jarResource.exists()) {\n\t\t\t\t\t\t\tresult.add(jarResource);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (MalformedURLException ex) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Cannot search for matching files underneath [\" + url +\n\t\t\t\t\t\t\t\t\t\"] because it cannot be converted to a valid 'jar:' URL: \" + ex.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Cannot introspect jar files since ClassLoader [\" + classLoader +\n\t\t\t\t\t\t\t\"] does not support 'getURLs()': \" + ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (classLoader == ClassLoader.getSystemClassLoader()) {\n\t\t\t// \"java.class.path\" manifest evaluation...\n\t\t\taddClassPathManifestEntries(result);\n\t\t}\n\n\t\tif (classLoader != null) {\n\t\t\ttry {\n\t\t\t\t// Hierarchy traversal...\n\t\t\t\taddAllClassLoaderJarRoots(classLoader.getParent(), result);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Cannot introspect jar files in parent ClassLoader since [\" + classLoader +\n\t\t\t\t\t\t\t\"] does not support 'getParent()': \" + ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#doFindPathMatchingFileResources(rootDirResource,subPattern)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find all resources in the file system of the supplied root directory that\n\t * match the given location sub pattern via the Ant-style PathMatcher.\n\t * @param rootDirResource the root directory as a Resource\n\t * @param subPattern the sub pattern to match (below the root directory)\n\t * @return a mutable Set of matching Resource instances\n\t * @throws IOException in case of I/O errors\n\t * @see org.springframework.util.PathMatcher\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rootDirResource",
      "subPattern"
    ],
    "position": {
      "column": 1,
      "line": 743
    },
    "return": "Set<Resource>",
    "signature": "protected Set<Resource> doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)",
    "source_code": "\tprotected Set<Resource> doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)\n\t\t\tthrows IOException {\n\n\t\tURI rootDirUri;\n\t\ttry {\n\t\t\trootDirUri = rootDirResource.getURI();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"Failed to resolve %s as URI: %s\".formatted(rootDirResource, ex));\n\t\t\t}\n\t\t\treturn Collections.emptySet();\n\t\t}\n\n\t\tPath rootPath = null;\n\t\tif (rootDirUri.isAbsolute() && !rootDirUri.isOpaque()) {\n\t\t\t// Prefer Path resolution from URI if possible\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\trootPath = Path.of(rootDirUri);\n\t\t\t\t}\n\t\t\t\tcatch (FileSystemNotFoundException ex) {\n\t\t\t\t\t// If the file system was not found, assume it's a custom file system that needs to be installed.\n\t\t\t\t\tFileSystems.newFileSystem(rootDirUri, Map.of(), ClassUtils.getDefaultClassLoader());\n\t\t\t\t\trootPath = Path.of(rootDirUri);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Failed to resolve %s in file system: %s\".formatted(rootDirUri, ex));\n\t\t\t\t}\n\t\t\t\t// Fallback via Resource.getFile() below\n\t\t\t}\n\t\t}\n\t\tif (rootPath == null) {\n\t\t\t// Resource.getFile() resolution as a fallback -\n\t\t\t// for custom URI formats and custom Resource implementations\n\t\t\trootPath = Path.of(rootDirResource.getFile().getAbsolutePath());\n\t\t}\n\n\t\tString rootDir = StringUtils.cleanPath(rootPath.toString());\n\t\tif (!rootDir.endsWith(\"/\")) {\n\t\t\trootDir += \"/\";\n\t\t}\n\n\t\tPath rootPathForPattern = rootPath;\n\t\tString resourcePattern = rootDir + StringUtils.cleanPath(subPattern);\n\t\tPredicate<Path> isMatchingFile = path -> (!path.equals(rootPathForPattern) &&\n\t\t\t\tgetPathMatcher().match(resourcePattern, StringUtils.cleanPath(path.toString())));\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Searching directory [%s] for files matching pattern [%s]\"\n\t\t\t\t\t.formatted(rootPath.toAbsolutePath(), subPattern));\n\t\t}\n\n\t\tSet<Resource> result = new LinkedHashSet<>();\n\t\ttry (Stream<Path> files = Files.walk(rootPath)) {\n\t\t\tfiles.filter(isMatchingFile).sorted().forEach(file -> {\n\t\t\t\ttry {\n\t\t\t\t\tresult.add(new FileSystemResource(file));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Failed to convert file %s to an org.springframework.core.io.Resource: %s\"\n\t\t\t\t\t\t\t\t.formatted(file, ex));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Failed to complete search in directory [%s] for files matching pattern [%s]: %s\"\n\t\t\t\t\t\t.formatted(rootPath.toAbsolutePath(), subPattern, ex));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#doFindPathMatchingJarResources(rootDirResource,rootDirUrl,subPattern)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find all resources in jar files that match the given location pattern\n\t * via the Ant-style PathMatcher.\n\t * @param rootDirResource the root directory as Resource\n\t * @param rootDirUrl the pre-resolved root directory URL\n\t * @param subPattern the sub pattern to match (below the root directory)\n\t * @return a mutable Set of matching Resource instances\n\t * @throws IOException in case of I/O errors\n\t * @since 4.3\n\t * @see java.net.JarURLConnection\n\t * @see org.springframework.util.PathMatcher\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rootDirResource",
      "rootDirUrl",
      "subPattern"
    ],
    "position": {
      "column": 1,
      "line": 638
    },
    "return": "Set<Resource>",
    "signature": "protected Set<Resource> doFindPathMatchingJarResources(Resource rootDirResource, URL rootDirUrl, String subPattern)",
    "source_code": "\tprotected Set<Resource> doFindPathMatchingJarResources(Resource rootDirResource, URL rootDirUrl, String subPattern)\n\t\t\tthrows IOException {\n\n\t\tURLConnection con = rootDirUrl.openConnection();\n\t\tJarFile jarFile;\n\t\tString jarFileUrl;\n\t\tString rootEntryPath;\n\t\tboolean closeJarFile;\n\n\t\tif (con instanceof JarURLConnection jarCon) {\n\t\t\t// Should usually be the case for traditional JAR files.\n\t\t\tResourceUtils.useCachesIfNecessary(jarCon);\n\t\t\tjarFile = jarCon.getJarFile();\n\t\t\tjarFileUrl = jarCon.getJarFileURL().toExternalForm();\n\t\t\tJarEntry jarEntry = jarCon.getJarEntry();\n\t\t\trootEntryPath = (jarEntry != null ? jarEntry.getName() : \"\");\n\t\t\tcloseJarFile = !jarCon.getUseCaches();\n\t\t}\n\t\telse {\n\t\t\t// No JarURLConnection -> need to resort to URL file parsing.\n\t\t\t// We'll assume URLs of the format \"jar:path!/entry\", with the protocol\n\t\t\t// being arbitrary as long as following the entry format.\n\t\t\t// We'll also handle paths with and without leading \"file:\" prefix.\n\t\t\tString urlFile = rootDirUrl.getFile();\n\t\t\ttry {\n\t\t\t\tint separatorIndex = urlFile.indexOf(ResourceUtils.WAR_URL_SEPARATOR);\n\t\t\t\tif (separatorIndex == -1) {\n\t\t\t\t\tseparatorIndex = urlFile.indexOf(ResourceUtils.JAR_URL_SEPARATOR);\n\t\t\t\t}\n\t\t\t\tif (separatorIndex != -1) {\n\t\t\t\t\tjarFileUrl = urlFile.substring(0, separatorIndex);\n\t\t\t\t\trootEntryPath = urlFile.substring(separatorIndex + 2);  // both separators are 2 chars\n\t\t\t\t\tjarFile = getJarFile(jarFileUrl);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjarFile = new JarFile(urlFile);\n\t\t\t\t\tjarFileUrl = urlFile;\n\t\t\t\t\trootEntryPath = \"\";\n\t\t\t\t}\n\t\t\t\tcloseJarFile = true;\n\t\t\t}\n\t\t\tcatch (ZipException ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Skipping invalid jar classpath entry [\" + urlFile + \"]\");\n\t\t\t\t}\n\t\t\t\treturn Collections.emptySet();\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Looking for matching resources in jar file [\" + jarFileUrl + \"]\");\n\t\t\t}\n\t\t\tif (StringUtils.hasLength(rootEntryPath) && !rootEntryPath.endsWith(\"/\")) {\n\t\t\t\t// Root entry path must end with slash to allow for proper matching.\n\t\t\t\t// The Sun JRE does not return a slash here, but BEA JRockit does.\n\t\t\t\trootEntryPath = rootEntryPath + \"/\";\n\t\t\t}\n\t\t\tSet<Resource> result = new LinkedHashSet<>(8);\n\t\t\tfor (Enumeration<JarEntry> entries = jarFile.entries(); entries.hasMoreElements();) {\n\t\t\t\tJarEntry entry = entries.nextElement();\n\t\t\t\tString entryPath = entry.getName();\n\t\t\t\tif (entryPath.startsWith(rootEntryPath)) {\n\t\t\t\t\tString relativePath = entryPath.substring(rootEntryPath.length());\n\t\t\t\t\tif (getPathMatcher().match(subPattern, relativePath)) {\n\t\t\t\t\t\tresult.add(rootDirResource.createRelative(relativePath));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tfinally {\n\t\t\tif (closeJarFile) {\n\t\t\t\tjarFile.close();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#findMatchingResources(rootDirUrl,locationPattern,pathMatcher)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootDirUrl",
      "locationPattern",
      "pathMatcher"
    ],
    "position": {
      "column": 1,
      "line": 918
    },
    "return": "Set<Resource>",
    "signature": "public Set<Resource> findMatchingResources(URL rootDirUrl, String locationPattern, PathMatcher pathMatcher)",
    "source_code": "\t\tpublic static Set<Resource> findMatchingResources(\n\t\t\t\tURL rootDirUrl, String locationPattern, PathMatcher pathMatcher) throws IOException {\n\n\t\t\tObject root = VfsPatternUtils.findRoot(rootDirUrl);\n\t\t\tPatternVirtualFileVisitor visitor =\n\t\t\t\t\tnew PatternVirtualFileVisitor(VfsPatternUtils.getPath(root), locationPattern, pathMatcher);\n\t\t\tVfsPatternUtils.visit(root, visitor);\n\t\t\treturn visitor.getResources();\n\t\t}"
  },
  "org.springframework.core.io.support.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 952
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tString methodName = method.getName();\n\t\t\tif (Object.class == method.getDeclaringClass()) {\n\t\t\t\tif (methodName.equals(\"equals\")) {\n\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\t}\n\t\t\t\telse if (methodName.equals(\"hashCode\")) {\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (\"getAttributes\".equals(methodName)) {\n\t\t\t\treturn getAttributes();\n\t\t\t}\n\t\t\telse if (\"visit\".equals(methodName)) {\n\t\t\t\tvisit(args[0]);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse if (\"toString\".equals(methodName)) {\n\t\t\t\treturn toString();\n\t\t\t}\n\n\t\t\tthrow new IllegalStateException(\"Unexpected method invocation: \" + method);\n\t\t}"
  },
  "org.springframework.core.style.<unknown>#styleMap(Map<K,map)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a styled version of the supplied {@link Map}.\n\t * @return a styled version of the supplied map\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<K",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "String",
    "signature": "protected String styleMap(Map<K, V> map)",
    "source_code": "\tprotected <K, V> String styleMap(Map<K, V> map) {\n\t\tif (map.isEmpty()) {\n\t\t\treturn EMPTY_MAP;\n\t\t}\n\n\t\tStringJoiner result = new StringJoiner(\", \", \"[\", \"]\");\n\t\tfor (Map.Entry<K, V> entry : map.entrySet()) {\n\t\t\tresult.add(styleMapEntry(entry));\n\t\t}\n\t\treturn MAP + result;\n\t}"
  },
  "org.springframework.core.style.<unknown>#styleMapEntry(Map.Entry<?,entry)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a styled version of the supplied {@link Map.Entry}.\n\t * @return a styled version of the supplied map entry\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map.Entry<?",
      "entry"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "String",
    "signature": "protected String styleMapEntry(Map.Entry<?, ?> entry)",
    "source_code": "\tprotected String styleMapEntry(Map.Entry<?, ?> entry) {\n\t\treturn style(entry.getKey()) + \" -> \" + style(entry.getValue());\n\t}"
  },
  "org.springframework.core.task.support.<unknown>#doExecute(concurrentExecutor,taskDecorator,runnable)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually execute the given {@code Runnable} (which may be a user-supplied task\n\t * or a wrapper around a user-supplied task) with the given executor.\n\t * @param concurrentExecutor the underlying JDK concurrent executor to delegate to\n\t * @param taskDecorator the specified decorator to be applied, if any\n\t * @param runnable the runnable to execute\n\t * @throws RejectedExecutionException if the given runnable cannot be accepted\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "concurrentExecutor",
      "taskDecorator",
      "runnable"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "void",
    "signature": "protected void doExecute(Executor concurrentExecutor, @Nullable TaskDecorator taskDecorator, Runnable runnable)",
    "source_code": "\tprotected void doExecute(Executor concurrentExecutor, @Nullable TaskDecorator taskDecorator, Runnable runnable)\n\t\t\tthrows RejectedExecutionException{\n\n\t\tconcurrentExecutor.execute(taskDecorator != null ? taskDecorator.decorate(runnable) : runnable);\n\t}"
  },
  "org.springframework.core.task.support.<unknown>#execute(task,startTimeout)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "startTimeout"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void execute(Runnable task, long startTimeout)",
    "source_code": "\tpublic void execute(Runnable task, long startTimeout) {\n\t\texecute(task);\n\t}"
  },
  "org.springframework.core.test.tools.<unknown>#getFileForOutput(location,packageName,relativeName,sibling)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "packageName",
      "relativeName",
      "sibling"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "FileObject",
    "signature": "public FileObject getFileForOutput(Location location, String packageName,\n\t\t\tString relativeName, FileObject sibling)",
    "source_code": "\tpublic FileObject getFileForOutput(Location location, String packageName,\n\t\t\tString relativeName, FileObject sibling) {\n\t\tResourceFile resourceFile = this.resourceFiles.get(relativeName);\n\t\tif (resourceFile != null) {\n\t\t\treturn new DynamicResourceFileObject(relativeName, resourceFile.getContent());\n\t\t}\n\t\treturn this.dynamicResourceFiles.computeIfAbsent(relativeName, DynamicResourceFileObject::new);\n\t}"
  },
  "org.springframework.core.test.tools.<unknown>#getJavaFileForOutput(location,className,kind,sibling)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "className",
      "kind",
      "sibling"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "JavaFileObject",
    "signature": "public JavaFileObject getJavaFileForOutput(Location location, String className,\n\t\t\tJavaFileObject.Kind kind, FileObject sibling)",
    "source_code": "\tpublic JavaFileObject getJavaFileForOutput(Location location, String className,\n\t\t\tJavaFileObject.Kind kind, FileObject sibling) throws IOException {\n\t\tif (kind == JavaFileObject.Kind.CLASS) {\n\t\t\tClassFile classFile = this.classFiles.get(className);\n\t\t\tif (classFile != null) {\n\t\t\t\treturn new DynamicClassFileObject(className, classFile.getContent());\n\t\t\t}\n\t\t\treturn this.dynamicClassFiles.computeIfAbsent(className, DynamicClassFileObject::new);\n\t\t}\n\t\treturn super.getJavaFileForOutput(location, className, kind, sibling);\n\t}"
  },
  "org.springframework.core.test.tools.<unknown>#inferBinaryName(location,file)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "file"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "String",
    "signature": "public String inferBinaryName(Location location, JavaFileObject file)",
    "source_code": "\tpublic String inferBinaryName(Location location, JavaFileObject file) {\n\t\tif (file instanceof DynamicClassFileObject dynamicClassFileObject) {\n\t\t\treturn dynamicClassFileObject.getClassName();\n\t\t}\n\t\treturn super.inferBinaryName(location, file);\n\t}"
  },
  "org.springframework.core.test.tools.<unknown>#list(location,packageName,kinds,recurse)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "packageName",
      "kinds",
      "recurse"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "Iterable<JavaFileObject>",
    "signature": "public Iterable<JavaFileObject> list(Location location, String packageName,\n\t\t\tSet<Kind> kinds, boolean recurse)",
    "source_code": "\tpublic Iterable<JavaFileObject> list(Location location, String packageName,\n\t\t\tSet<Kind> kinds, boolean recurse) throws IOException {\n\t\tList<JavaFileObject> result = new ArrayList<>();\n\t\tif (kinds.contains(Kind.CLASS)) {\n\t\t\tfor (ClassFile candidate : this.classFiles) {\n\t\t\t\tString existingPackageName = ClassUtils.getPackageName(candidate.getName());\n\t\t\t\tif (existingPackageName.equals(packageName) || (recurse && existingPackageName.startsWith(packageName + \".\"))) {\n\t\t\t\t\tresult.add(new DynamicClassFileObject(candidate.getName(), candidate.getContent()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (DynamicClassFileObject candidate : this.dynamicClassFiles.values()) {\n\t\t\t\tString existingPackageName = ClassUtils.getPackageName(candidate.getClassName());\n\t\t\t\tif (existingPackageName.equals(packageName) || (recurse && existingPackageName.startsWith(packageName + \".\"))) {\n\t\t\t\t\tresult.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsuper.list(location, packageName, kinds, recurse).forEach(result::add);\n\t\treturn result;\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#removeEldestEntry(Map.Entry<Resource,eldest)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map.Entry<Resource",
      "eldest"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "boolean",
    "signature": "protected boolean removeEldestEntry(Map.Entry<Resource, MetadataReader> eldest)",
    "source_code": "\t\tprotected boolean removeEldestEntry(Map.Entry<Resource, MetadataReader> eldest) {\n\t\t\treturn size() > this.cacheLimit;\n\t\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#visit(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "public void visit(String name, Object value)",
    "source_code": "\t\tpublic void visit(String name, Object value) {\n\t\t\tif (value instanceof Type type) {\n\t\t\t\tvalue = type.getClassName();\n\t\t\t}\n\t\t\tthis.elements.add(value);\n\t\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#visitAnnotation(name,descriptor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "AnnotationVisitor",
    "signature": "public AnnotationVisitor visitAnnotation(String name, String descriptor)",
    "source_code": "\t\tpublic AnnotationVisitor visitAnnotation(String name, String descriptor) {\n\t\t\treturn MergedAnnotationReadingVisitor.this.visitAnnotation(descriptor, this.elements::add);\n\t\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#visitEnum(descriptor,value,consumer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "value",
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "void",
    "signature": "public void visitEnum(String descriptor, String value, Consumer<E> consumer)",
    "source_code": "\tpublic <E extends Enum<E>> void visitEnum(String descriptor, String value, Consumer<E> consumer) {\n\t\tString className = Type.getType(descriptor).getClassName();\n\t\tClass<E> type = (Class<E>) ClassUtils.resolveClassName(className, this.classLoader);\n\t\tconsumer.accept(Enum.valueOf(type, value));\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#visitEnum(name,descriptor,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "descriptor",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "void",
    "signature": "public void visitEnum(String name, String descriptor, String value)",
    "source_code": "\t\tpublic void visitEnum(String name, String descriptor, String value) {\n\t\t\tMergedAnnotationReadingVisitor.this.visitEnum(descriptor, value, this.elements::add);\n\t\t}"
  },
  "org.springframework.expression.spel.<unknown>#areBoxingCompatible(desc1,desc2)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether boxing/unboxing can get from one type to the other.\n\t * <p>Assumes at least one of the types is in boxed form (i.e. single char descriptor).\n\t * @return {@code true} if it is possible to get (via boxing) from one descriptor to the other\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "desc1",
      "desc2"
    ],
    "position": {
      "column": 1,
      "line": 552
    },
    "return": "boolean",
    "signature": "public boolean areBoxingCompatible(String desc1, String desc2)",
    "source_code": "\tpublic static boolean areBoxingCompatible(String desc1, String desc2) {\n\t\tif (desc1.equals(desc2)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (desc1.length() == 1) {\n\t\t\treturn checkPairs(desc1, desc2);\n\t\t}\n\t\telse if (desc2.length() == 1) {\n\t\t\treturn checkPairs(desc2, desc1);\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertAnyNecessaryTypeConversionBytecodes(mv,targetDescriptor,stackDescriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Insert any necessary numeric conversion bytecodes based upon what is on the\n\t * stack and the desired target type.\n\t * @param mv the method visitor into which instructions should be placed\n\t * @param targetDescriptor the (primitive) descriptor of the target type\n\t * @param stackDescriptor the descriptor of the operand on top of the stack\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "targetDescriptor",
      "stackDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "void",
    "signature": "public void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor)",
    "source_code": "\tpublic static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {\n\t\tif (!CodeFlow.isPrimitive(stackDescriptor)) {\n\t\t\treturn;\n\t\t}\n\t\tchar stackTop = stackDescriptor.charAt(0);\n\t\tswitch (stackTop){\n\t\t\tcase 'I', 'B', 'S', 'C' -> {\n\t\t\t\tswitch (targetDescriptor) {\n\t\t\t\t\tcase 'D' -> mv.visitInsn(I2D);\n\t\t\t\t\tcase 'F' -> mv.visitInsn(I2F);\n\t\t\t\t\tcase 'J' -> mv.visitInsn(I2L);\n\t\t\t\t\tcase 'I' -> { /* no-op */ }\n\t\t\t\t\tdefault ->\n\t\t\t\t\t\tthrow new IllegalStateException(\"Cannot get from \" + stackTop + \" to \" + targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 'J' -> {\n\t\t\t\tswitch (targetDescriptor) {\n\t\t\t\t\tcase 'D' -> mv.visitInsn(L2D);\n\t\t\t\t\tcase 'F' -> mv.visitInsn(L2F);\n\t\t\t\t\tcase 'J' -> { /* no-op */ }\n\t\t\t\t\tcase 'I' -> mv.visitInsn(L2I);\n\t\t\t\t\tdefault ->\n\t\t\t\t\t\tthrow new IllegalStateException(\"Cannot get from \" + stackTop + \" to \" + targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 'F' -> {\n\t\t\t\tswitch (targetDescriptor) {\n\t\t\t\t\tcase 'D' -> mv.visitInsn(F2D);\n\t\t\t\t\tcase 'F' -> { /* no-op */ }\n\t\t\t\t\tcase 'J' -> mv.visitInsn(F2L);\n\t\t\t\t\tcase 'I' -> mv.visitInsn(F2I);\n\t\t\t\t\tdefault ->\n\t\t\t\t\t\tthrow new IllegalStateException(\"Cannot get from \" + stackTop + \" to \" + targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 'D' -> {\n\t\t\t\tswitch (targetDescriptor) {\n\t\t\t\t\tcase 'D' -> { /* no-op */ }\n\t\t\t\t\tcase 'F' -> mv.visitInsn(D2F);\n\t\t\t\t\tcase 'J' -> mv.visitInsn(D2L);\n\t\t\t\t\tcase 'I' -> mv.visitInsn(D2I);\n\t\t\t\t\tdefault ->\n\t\t\t\t\t\tthrow new IllegalStateException(\"Cannot get from \" + stackDescriptor + \" to \" + targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertArrayStore(mv,arrayElementType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Produce appropriate bytecode to store a stack item in an array. The\n\t * instruction to use varies depending on whether the type\n\t * is a primitive or reference type.\n\t * @param mv where to insert the bytecode\n\t * @param arrayElementType the type of the array elements\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "arrayElementType"
    ],
    "position": {
      "column": 1,
      "line": 831
    },
    "return": "void",
    "signature": "public void insertArrayStore(MethodVisitor mv, String arrayElementType)",
    "source_code": "\tpublic static void insertArrayStore(MethodVisitor mv, String arrayElementType) {\n\t\tif (arrayElementType.length() == 1) {\n\t\t\tswitch (arrayElementType.charAt(0)) {\n\t\t\t\tcase 'B', 'Z' -> mv.visitInsn(BASTORE);\n\t\t\t\tcase 'I' -> mv.visitInsn(IASTORE);\n\t\t\t\tcase 'J' -> mv.visitInsn(LASTORE);\n\t\t\t\tcase 'F' -> mv.visitInsn(FASTORE);\n\t\t\t\tcase 'D' -> mv.visitInsn(DASTORE);\n\t\t\t\tcase 'C' -> mv.visitInsn(CASTORE);\n\t\t\t\tcase 'S' -> mv.visitInsn(SASTORE);\n\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected array type \" + arrayElementType.charAt(0));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmv.visitInsn(AASTORE);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertBoxIfNecessary(mv,ch)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the appropriate boxing instruction for a specific type (if it needs\n\t * boxing) and insert the instruction into the supplied visitor.\n\t * @param mv the method visitor for the new instructions\n\t * @param ch the descriptor of the type that might need boxing\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "ch"
    ],
    "position": {
      "column": 1,
      "line": 688
    },
    "return": "void",
    "signature": "public void insertBoxIfNecessary(MethodVisitor mv, char ch)",
    "source_code": "\tpublic static void insertBoxIfNecessary(MethodVisitor mv, char ch) {\n\t\tswitch (ch) {\n\t\t\tcase 'Z' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Boolean\", \"valueOf\", \"(Z)Ljava/lang/Boolean;\", false);\n\t\t\tcase 'B' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Byte\", \"valueOf\", \"(B)Ljava/lang/Byte;\", false);\n\t\t\tcase 'C' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Character\", \"valueOf\", \"(C)Ljava/lang/Character;\", false);\n\t\t\tcase 'D' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Double\", \"valueOf\", \"(D)Ljava/lang/Double;\", false);\n\t\t\tcase 'F' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Float\", \"valueOf\", \"(F)Ljava/lang/Float;\", false);\n\t\t\tcase 'I' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Integer\", \"valueOf\", \"(I)Ljava/lang/Integer;\", false);\n\t\t\tcase 'J' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Long\", \"valueOf\", \"(J)Ljava/lang/Long;\", false);\n\t\t\tcase 'S' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Short\", \"valueOf\", \"(S)Ljava/lang/Short;\", false);\n\t\t\tcase 'L', 'V', '[' -> {\n\t\t\t\t// no box needed\n\t\t\t}\n\t\t\tdefault -> throw new IllegalArgumentException(\"Boxing should not be attempted for descriptor '\" + ch + \"'\");\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertBoxIfNecessary(mv,descriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the appropriate boxing instruction for a specific type (if it needs\n\t * boxing) and insert the instruction into the supplied visitor.\n\t * @param mv the method visitor for the new instructions\n\t * @param descriptor the descriptor of a type that may or may not need boxing\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 676
    },
    "return": "void",
    "signature": "public void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor)",
    "source_code": "\tpublic static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor) {\n\t\tif (descriptor != null && descriptor.length() == 1) {\n\t\t\tinsertBoxIfNecessary(mv, descriptor.charAt(0));\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertCheckCast(mv,descriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Insert the appropriate CHECKCAST instruction for the supplied descriptor.\n\t * @param mv the method visitor into which the instruction should be inserted\n\t * @param descriptor the descriptor of the type to cast to\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 651
    },
    "return": "void",
    "signature": "public void insertCheckCast(MethodVisitor mv, @Nullable String descriptor)",
    "source_code": "\tpublic static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor) {\n\t\tif (descriptor != null && descriptor.length() != 1) {\n\t\t\tif (descriptor.charAt(0) == '[') {\n\t\t\t\tif (isPrimitiveArray(descriptor)) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor + \";\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!descriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\t// This is chopping off the 'L' to leave us with \"java/lang/String\"\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor.substring(1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertNewArrayCode(mv,size,arrayType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Produce the correct bytecode to build an array. The opcode to use and the\n\t * signature to pass along with the opcode can vary depending on the signature\n\t * of the array type.\n\t * @param mv the method visitor into which code should be inserted\n\t * @param size the size of the array\n\t * @param arrayType the type of the array\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "size",
      "arrayType"
    ],
    "position": {
      "column": 1,
      "line": 891
    },
    "return": "void",
    "signature": "public void insertNewArrayCode(MethodVisitor mv, int size, String arrayType)",
    "source_code": "\tpublic static void insertNewArrayCode(MethodVisitor mv, int size, String arrayType) {\n\t\tinsertOptimalLoad(mv, size);\n\t\tif (arrayType.length() == 1) {\n\t\t\tmv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arrayType));\n\t\t}\n\t\telse {\n\t\t\tif (arrayType.charAt(0) == '[') {\n\t\t\t\t// Handling the nested array case here.\n\t\t\t\t// If vararg is [[I then we want [I and not [I;\n\t\t\t\tif (CodeFlow.isReferenceTypeArray(arrayType)) {\n\t\t\t\t\tmv.visitTypeInsn(ANEWARRAY, arrayType + \";\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmv.visitTypeInsn(ANEWARRAY, arrayType);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmv.visitTypeInsn(ANEWARRAY, arrayType.substring(1));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertNumericUnboxOrPrimitiveTypeCoercion(mv,stackDescriptor,targetDescriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * For use in mathematical operators, handles converting from a (possibly boxed)\n\t * number on the stack to a primitive numeric type.\n\t * <p>For example, from an Integer to a double, just need to call 'Number.doubleValue()'\n\t * but from an int to a double, need to use the bytecode 'i2d'.\n\t * @param mv the method visitor when instructions should be appended\n\t * @param stackDescriptor a descriptor of the operand on the stack\n\t * @param targetDescriptor a primitive type descriptor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "stackDescriptor",
      "targetDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 922
    },
    "return": "void",
    "signature": "public void insertNumericUnboxOrPrimitiveTypeCoercion(MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor)",
    "source_code": "\tpublic static void insertNumericUnboxOrPrimitiveTypeCoercion(\n\t\t\tMethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor) {\n\n\t\tif (!CodeFlow.isPrimitive(stackDescriptor)) {\n\t\t\tCodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor);\n\t\t}\n\t\telse {\n\t\t\tCodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertOptimalLoad(mv,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the optimal instruction for loading a number on the stack.\n\t * @param mv where to insert the bytecode\n\t * @param value the value to be loaded\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 809
    },
    "return": "void",
    "signature": "public void insertOptimalLoad(MethodVisitor mv, int value)",
    "source_code": "\tpublic static void insertOptimalLoad(MethodVisitor mv, int value) {\n\t\tif (value < 6) {\n\t\t\tmv.visitInsn(ICONST_0+value);\n\t\t}\n\t\telse if (value < Byte.MAX_VALUE) {\n\t\t\tmv.visitIntInsn(BIPUSH, value);\n\t\t}\n\t\telse if (value < Short.MAX_VALUE) {\n\t\t\tmv.visitIntInsn(SIPUSH, value);\n\t\t}\n\t\telse {\n\t\t\tmv.visitLdcInsn(value);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertUnboxInsns(mv,ch,stackDescriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Insert any necessary cast and value call to convert from a boxed type to a\n\t * primitive value.\n\t * @param mv the method visitor into which instructions should be inserted\n\t * @param ch the primitive type desired as output\n\t * @param stackDescriptor the descriptor of the type on top of the stack\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "ch",
      "stackDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "void",
    "signature": "public void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor)",
    "source_code": "\tpublic static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor) {\n\t\tif (stackDescriptor == null) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (ch) {\n\t\t\tcase 'Z' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Boolean\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Boolean\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Boolean\", \"booleanValue\", \"()Z\", false);\n\t\t\t}\n\t\t\tcase 'B' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Byte\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Byte\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Byte\", \"byteValue\", \"()B\", false);\n\t\t\t}\n\t\t\tcase 'C' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Character\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Character\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Character\", \"charValue\", \"()C\", false);\n\t\t\t}\n\t\t\tcase 'D' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Double\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Double\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Double\", \"doubleValue\", \"()D\", false);\n\t\t\t}\n\t\t\tcase 'F' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Float\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Float\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Float\", \"floatValue\", \"()F\", false);\n\t\t\t}\n\t\t\tcase 'I' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Integer\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Integer\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Integer\", \"intValue\", \"()I\", false);\n\t\t\t}\n\t\t\tcase 'J' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Long\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Long\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Long\", \"longValue\", \"()J\", false);\n\t\t\t}\n\t\t\tcase 'S' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Short\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Short\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Short\", \"shortValue\", \"()S\", false);\n\t\t\t}\n\t\t\tdefault ->\n\t\t\t\tthrow new IllegalArgumentException(\"Unboxing should not be attempted for descriptor '\" + ch + \"'\");\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertUnboxNumberInsns(mv,targetDescriptor,stackDescriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * For numbers, use the appropriate method on the number to convert it to the primitive type requested.\n\t * @param mv the method visitor into which instructions should be inserted\n\t * @param targetDescriptor the primitive type desired as output\n\t * @param stackDescriptor the descriptor of the type on top of the stack\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "targetDescriptor",
      "stackDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "void",
    "signature": "public void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor)",
    "source_code": "\tpublic static void insertUnboxNumberInsns(\n\t\t\tMethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor) {\n\n\t\tif (stackDescriptor == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (targetDescriptor) {\n\t\t\tcase 'D' -> {\n\t\t\t\tif (stackDescriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Number\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Number\", \"doubleValue\", \"()D\", false);\n\t\t\t}\n\t\t\tcase 'F' -> {\n\t\t\t\tif (stackDescriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Number\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Number\", \"floatValue\", \"()F\", false);\n\t\t\t}\n\t\t\tcase 'J' -> {\n\t\t\t\tif (stackDescriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Number\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Number\", \"longValue\", \"()J\", false);\n\t\t\t}\n\t\t\tcase 'I' -> {\n\t\t\t\tif (stackDescriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Number\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Number\", \"intValue\", \"()I\", false);\n\t\t\t}\n\t\t\t// does not handle Z, B, C, S\n\t\t\tdefault ->\n\t\t\t\tthrow new IllegalArgumentException(\"Unboxing should not be attempted for descriptor '\" + targetDescriptor + \"'\");\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#checkNumericCompatibility(leftDeclaredDescriptor,rightDeclaredDescriptor,leftActualDescriptor,rightActualDescriptor)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return an object that indicates whether the input descriptors are compatible.\n\t\t * <p>A declared descriptor is what could statically be determined (e.g. from looking\n\t\t * at the return value of a property accessor method) whilst an actual descriptor\n\t\t * is the type of an actual object that was returned, which may differ.\n\t\t * <p>For generic types with unbound type variables, the declared descriptor\n\t\t * discovered may be 'Object' but from the actual descriptor it is possible to\n\t\t * observe that the objects are really numeric values (e.g. ints).\n\t\t * @param leftDeclaredDescriptor the statically determinable left descriptor\n\t\t * @param rightDeclaredDescriptor the statically determinable right descriptor\n\t\t * @param leftActualDescriptor the dynamic/runtime left object descriptor\n\t\t * @param rightActualDescriptor the dynamic/runtime right object descriptor\n\t\t * @return a DescriptorComparison object indicating the type of compatibility, if any\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "leftDeclaredDescriptor",
      "rightDeclaredDescriptor",
      "leftActualDescriptor",
      "rightActualDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "DescriptorComparison",
    "signature": "public DescriptorComparison checkNumericCompatibility(@Nullable String leftDeclaredDescriptor, @Nullable String rightDeclaredDescriptor,\n\t\t\t\t@Nullable String leftActualDescriptor, @Nullable String rightActualDescriptor)",
    "source_code": "\t\tpublic static DescriptorComparison checkNumericCompatibility(\n\t\t\t\t@Nullable String leftDeclaredDescriptor, @Nullable String rightDeclaredDescriptor,\n\t\t\t\t@Nullable String leftActualDescriptor, @Nullable String rightActualDescriptor) {\n\n\t\t\tString ld = leftDeclaredDescriptor;\n\t\t\tString rd = rightDeclaredDescriptor;\n\n\t\t\tboolean leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld);\n\t\t\tboolean rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd);\n\n\t\t\t// If the declared descriptors aren't providing the information, try the actual descriptors\n\t\t\tif (!leftNumeric && !ObjectUtils.nullSafeEquals(ld, leftActualDescriptor)) {\n\t\t\t\tld = leftActualDescriptor;\n\t\t\t\tleftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld);\n\t\t\t}\n\t\t\tif (!rightNumeric && !ObjectUtils.nullSafeEquals(rd, rightActualDescriptor)) {\n\t\t\t\trd = rightActualDescriptor;\n\t\t\t\trightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd);\n\t\t\t}\n\n\t\t\tif (leftNumeric && rightNumeric) {\n\t\t\t\tif (CodeFlow.areBoxingCompatible(ld, rd)) {\n\t\t\t\t\treturn new DescriptorComparison(true, true, CodeFlow.toPrimitiveTargetDesc(ld));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn DescriptorComparison.INCOMPATIBLE_NUMBERS;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn DescriptorComparison.NOT_NUMBERS;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#equalityCheck(context,left,right)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform an equality check for the given operand values.\n\t * <p>This method is not just used for reflective comparisons in subclasses\n\t * but also from compiled expression code, which is why it needs to be\n\t * declared as {@code public static} here.\n\t * @param context the current evaluation context\n\t * @param left the left-hand operand value\n\t * @param right the right-hand operand value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "left",
      "right"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "boolean",
    "signature": "public boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right)",
    "source_code": "\tpublic static boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right) {\n\t\tif (left instanceof Number leftNumber && right instanceof Number rightNumber) {\n\t\t\tif (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {\n\t\t\t\tBigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class);\n\t\t\t\tBigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class);\n\t\t\t\treturn (leftBigDecimal.compareTo(rightBigDecimal) == 0);\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Double || rightNumber instanceof Double) {\n\t\t\t\treturn (leftNumber.doubleValue() == rightNumber.doubleValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Float || rightNumber instanceof Float) {\n\t\t\t\treturn (leftNumber.floatValue() == rightNumber.floatValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {\n\t\t\t\tBigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class);\n\t\t\t\tBigInteger rightBigInteger = NumberUtils.convertNumberToTargetClass(rightNumber, BigInteger.class);\n\t\t\t\treturn (leftBigInteger.compareTo(rightBigInteger) == 0);\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Long || rightNumber instanceof Long) {\n\t\t\t\treturn (leftNumber.longValue() == rightNumber.longValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Integer || rightNumber instanceof Integer) {\n\t\t\t\treturn (leftNumber.intValue() == rightNumber.intValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Short || rightNumber instanceof Short) {\n\t\t\t\treturn (leftNumber.shortValue() == rightNumber.shortValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Byte || rightNumber instanceof Byte) {\n\t\t\t\treturn (leftNumber.byteValue() == rightNumber.byteValue());\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Unknown Number subtypes -> best guess is double comparison\n\t\t\t\treturn (leftNumber.doubleValue() == rightNumber.doubleValue());\n\t\t\t}\n\t\t}\n\n\t\tif (left instanceof CharSequence && right instanceof CharSequence) {\n\t\t\treturn left.toString().equals(right.toString());\n\t\t}\n\n\t\tif (left instanceof Boolean && right instanceof Boolean) {\n\t\t\treturn left.equals(right);\n\t\t}\n\n\t\tif (ObjectUtils.nullSafeEquals(left, right)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (context.getTypeComparator().canCompare(left, right)) {\n\t\t\treturn context.getTypeComparator().compare(left, right) == 0;\n\t\t}\n\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#generateCode(mv,cf)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Generate the bytecode for this node into the supplied visitor. Context info about\n\t * the current expression being compiled is available in the codeflow object, e.g.\n\t * including information about the type of the object currently on the stack.\n\t * @param mv the ASM MethodVisitor into which code should be generated\n\t * @param cf a context object with info about what is on the stack\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "void",
    "signature": "public void generateCode(MethodVisitor mv, CodeFlow cf)",
    "source_code": "\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tthrow new IllegalStateException(getClass().getName() +\" has no generateCode(..) method\");\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#generateCode(mv,codeflow)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "codeflow"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void generateCode(MethodVisitor mv, CodeFlow codeflow)",
    "source_code": "\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n\t\tfinal String constantFieldName = \"inlineList$\" + codeflow.nextFieldId();\n\t\tfinal String className = codeflow.getClassName();\n\n\t\tcodeflow.registerNewField((cw, cflow) ->\n\t\t\t\tcw.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, constantFieldName, \"Ljava/util/List;\", null, null));\n\n\t\tcodeflow.registerNewClinit((mVisitor, cflow) ->\n\t\t\t\tgenerateClinitCode(className, constantFieldName, mVisitor, cflow, false));\n\n\t\tmv.visitFieldInsn(GETSTATIC, className, constantFieldName, \"Ljava/util/List;\");\n\t\tcodeflow.pushDescriptor(\"Ljava/util/List\");\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#generateCodeForArgument(mv,cf,argument,paramDesc)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Ask an argument to generate its bytecode and then follow it up\n\t * with any boxing/unboxing/checkcasting to ensure it matches the expected parameter descriptor.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "cf",
      "argument",
      "paramDesc"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "void",
    "signature": "protected void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc)",
    "source_code": "\tprotected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc) {\n\t\tcf.enterCompilationScope();\n\t\targument.generateCode(mv, cf);\n\t\tString lastDesc = cf.lastDescriptor();\n\t\tAssert.state(lastDesc != null, \"No last descriptor\");\n\t\tboolean primitiveOnStack = CodeFlow.isPrimitive(lastDesc);\n\t\t// Check if need to box it for the method reference?\n\t\tif (primitiveOnStack && paramDesc.charAt(0) == 'L') {\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, lastDesc.charAt(0));\n\t\t}\n\t\telse if (paramDesc.length() == 1 && !primitiveOnStack) {\n\t\t\tCodeFlow.insertUnboxInsns(mv, paramDesc.charAt(0), lastDesc);\n\t\t}\n\t\telse if (!paramDesc.equals(lastDesc)) {\n\t\t\t// This would be unnecessary in the case of subtyping (e.g. method takes Number but Integer passed in)\n\t\t\tCodeFlow.insertCheckCast(mv, paramDesc);\n\t\t}\n\t\tcf.exitCompilationScope();\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#generateCodeForArguments(mv,cf,member,arguments)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Generate code that handles building the argument values for the specified method.\n\t * This method will take account of whether the invoked method is a varargs method\n\t * and if it is then the argument values will be appropriately packaged into an array.\n\t * @param mv the method visitor where code should be generated\n\t * @param cf the current codeflow\n\t * @param member the method or constructor for which arguments are being setup\n\t * @param arguments the expression nodes for the expression supplied argument values\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "cf",
      "member",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "protected void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments)",
    "source_code": "\tprotected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {\n\t\tString[] paramDescriptors = null;\n\t\tboolean isVarargs = false;\n\t\tif (member instanceof Constructor<?> ctor) {\n\t\t\tparamDescriptors = CodeFlow.toDescriptors(ctor.getParameterTypes());\n\t\t\tisVarargs = ctor.isVarArgs();\n\t\t}\n\t\telse { // Method\n\t\t\tMethod method = (Method)member;\n\t\t\tparamDescriptors = CodeFlow.toDescriptors(method.getParameterTypes());\n\t\t\tisVarargs = method.isVarArgs();\n\t\t}\n\t\tif (isVarargs) {\n\t\t\t// The final parameter may or may not need packaging into an array, or nothing may\n\t\t\t// have been passed to satisfy the varargs and so something needs to be built.\n\t\t\tint p = 0; // Current supplied argument being processed\n\t\t\tint childCount = arguments.length;\n\n\t\t\t// Fulfill all the parameter requirements except the last one\n\t\t\tfor (p = 0; p < paramDescriptors.length - 1; p++) {\n\t\t\t\tgenerateCodeForArgument(mv, cf, arguments[p], paramDescriptors[p]);\n\t\t\t}\n\n\t\t\tSpelNodeImpl lastChild = (childCount == 0 ? null : arguments[childCount - 1]);\n\t\t\tString arrayType = paramDescriptors[paramDescriptors.length - 1];\n\t\t\t// Determine if the final passed argument is already suitably packaged in array\n\t\t\t// form to be passed to the method\n\t\t\tif (lastChild != null && arrayType.equals(lastChild.getExitDescriptor())) {\n\t\t\t\tgenerateCodeForArgument(mv, cf, lastChild, paramDescriptors[p]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tarrayType = arrayType.substring(1); // trim the leading '[', may leave other '['\n\t\t\t\t// build array big enough to hold remaining arguments\n\t\t\t\tCodeFlow.insertNewArrayCode(mv, childCount - p, arrayType);\n\t\t\t\t// Package up the remaining arguments into the array\n\t\t\t\tint arrayindex = 0;\n\t\t\t\twhile (p < childCount) {\n\t\t\t\t\tSpelNodeImpl child = arguments[p];\n\t\t\t\t\tmv.visitInsn(DUP);\n\t\t\t\t\tCodeFlow.insertOptimalLoad(mv, arrayindex++);\n\t\t\t\t\tgenerateCodeForArgument(mv, cf, child, arrayType);\n\t\t\t\t\tCodeFlow.insertArrayStore(mv, arrayType);\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < paramDescriptors.length;i++) {\n\t\t\t\tgenerateCodeForArgument(mv, cf, arguments[i], paramDescriptors[i]);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#generateComparisonCode(mv,cf,compInstruction1,compInstruction2)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Numeric comparison operators share very similar generated code, only differing in\n\t * two comparison instructions.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "cf",
      "compInstruction1",
      "compInstruction2"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2)",
    "source_code": "\tprotected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2) {\n\t\tSpelNodeImpl left = getLeftOperand();\n\t\tSpelNodeImpl right = getRightOperand();\n\t\tString leftDesc = left.exitTypeDescriptor;\n\t\tString rightDesc = right.exitTypeDescriptor;\n\t\tLabel elseTarget = new Label();\n\t\tLabel endOfIf = new Label();\n\t\tboolean unboxLeft = !CodeFlow.isPrimitive(leftDesc);\n\t\tboolean unboxRight = !CodeFlow.isPrimitive(rightDesc);\n\t\tDescriptorComparison dc = DescriptorComparison.checkNumericCompatibility(\n\t\t\t\tleftDesc, rightDesc, this.leftActualDescriptor, this.rightActualDescriptor);\n\t\tchar targetType = dc.compatibleType;  // CodeFlow.toPrimitiveTargetDesc(leftDesc);\n\n\t\tcf.enterCompilationScope();\n\t\tleft.generateCode(mv, cf);\n\t\tcf.exitCompilationScope();\n\t\tif (CodeFlow.isPrimitive(leftDesc)) {\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, leftDesc);\n\t\t\tunboxLeft = true;\n\t\t}\n\n\t\tcf.enterCompilationScope();\n\t\tright.generateCode(mv, cf);\n\t\tcf.exitCompilationScope();\n\t\tif (CodeFlow.isPrimitive(rightDesc)) {\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, rightDesc);\n\t\t\tunboxRight = true;\n\t\t}\n\n\t\t// This code block checks whether the left or right operand is null and handles\n\t\t// those cases before letting the original code (that only handled actual numbers) run\n\t\tLabel rightIsNonNull = new Label();\n\t\tmv.visitInsn(DUP);  // stack: left/right/right\n\t\tmv.visitJumpInsn(IFNONNULL, rightIsNonNull);  // stack: left/right\n\t\t// here: RIGHT==null LEFT==unknown\n\t\tmv.visitInsn(SWAP);  // right/left\n\t\tLabel leftNotNullRightIsNull = new Label();\n\t\tmv.visitJumpInsn(IFNONNULL, leftNotNullRightIsNull);  // stack: right\n\t\t// here: RIGHT==null LEFT==null\n\t\tmv.visitInsn(POP);  // stack: <nothing>\n\t\t// load 0 or 1 depending on comparison instruction\n\t\tswitch (compInstruction1) {\n\t\tcase IFGE: // OpLT\n\t\tcase IFLE: // OpGT\n\t\t\tmv.visitInsn(ICONST_0);  // false - null is not < or > null\n\t\t\tbreak;\n\t\tcase IFGT: // OpLE\n\t\tcase IFLT: // OpGE\n\t\t\tmv.visitInsn(ICONST_1);  // true - null is <= or >= null\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"Unsupported: \" + compInstruction1);\n\t\t}\n\t\tmv.visitJumpInsn(GOTO, endOfIf);\n\t\tmv.visitLabel(leftNotNullRightIsNull);  // stack: right\n\t\t// RIGHT==null LEFT!=null\n\t\tmv.visitInsn(POP);  // stack: <nothing>\n\t\t// load 0 or 1 depending on comparison instruction\n\t\tswitch (compInstruction1) {\n\t\tcase IFGE: // OpLT\n\t\tcase IFGT: // OpLE\n\t\t\tmv.visitInsn(ICONST_0);  // false - something is not < or <= null\n\t\t\tbreak;\n\t\tcase IFLE: // OpGT\n\t\tcase IFLT: // OpGE\n\t\t\tmv.visitInsn(ICONST_1);  // true - something is > or >= null\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"Unsupported: \" + compInstruction1);\n\t\t}\n\t\tmv.visitJumpInsn(GOTO, endOfIf);\n\n\t\tmv.visitLabel(rightIsNonNull);  // stack: left/right\n\t\t// here: RIGHT!=null LEFT==unknown\n\t\tmv.visitInsn(SWAP);  // stack: right/left\n\t\tmv.visitInsn(DUP);  // stack: right/left/left\n\t\tLabel neitherRightNorLeftAreNull = new Label();\n\t\tmv.visitJumpInsn(IFNONNULL, neitherRightNorLeftAreNull);  // stack: right/left\n\t\t// here: RIGHT!=null LEFT==null\n\t\tmv.visitInsn(POP2);  // stack: <nothing>\n\t\tswitch (compInstruction1) {\n\t\tcase IFGE: // OpLT\n\t\tcase IFGT: // OpLE\n\t\t\tmv.visitInsn(ICONST_1);  // true - null is < or <= something\n\t\t\tbreak;\n\t\tcase IFLE: // OpGT\n\t\tcase IFLT: // OpGE\n\t\t\tmv.visitInsn(ICONST_0);  // false - null is not > or >= something\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"Unsupported: \" + compInstruction1);\n\t\t}\n\t\tmv.visitJumpInsn(GOTO, endOfIf);\n\t\tmv.visitLabel(neitherRightNorLeftAreNull);  // stack: right/left\n\t\t// neither were null so unbox and proceed with numeric comparison\n\t\tif (unboxLeft) {\n\t\t\tCodeFlow.insertUnboxInsns(mv, targetType, leftDesc);\n\t\t}\n\t\t// What we just unboxed might be a double slot item (long/double)\n\t\t// so can't just use SWAP\n\t\t// stack: right/left(1or2slots)\n\t\tif (targetType == 'D' || targetType == 'J') {\n\t\t\tmv.visitInsn(DUP2_X1);\n\t\t\tmv.visitInsn(POP2);\n\t\t}\n\t\telse {\n\t\t\tmv.visitInsn(SWAP);\n\t\t}\n\t\t// stack: left(1or2)/right\n\t\tif (unboxRight) {\n\t\t\tCodeFlow.insertUnboxInsns(mv, targetType, rightDesc);\n\t\t}\n\n\t\t// assert: SpelCompiler.boxingCompatible(leftDesc, rightDesc)\n\t\tif (targetType == 'D') {\n\t\t\tmv.visitInsn(DCMPG);\n\t\t\tmv.visitJumpInsn(compInstruction1, elseTarget);\n\t\t}\n\t\telse if (targetType == 'F') {\n\t\t\tmv.visitInsn(FCMPG);\n\t\t\tmv.visitJumpInsn(compInstruction1, elseTarget);\n\t\t}\n\t\telse if (targetType == 'J') {\n\t\t\tmv.visitInsn(LCMP);\n\t\t\tmv.visitJumpInsn(compInstruction1, elseTarget);\n\t\t}\n\t\telse if (targetType == 'I') {\n\t\t\tmv.visitJumpInsn(compInstruction2, elseTarget);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Unexpected descriptor \" + leftDesc);\n\t\t}\n\n\t\t// Other numbers are not yet supported (isCompilable will not have returned true)\n\t\tmv.visitInsn(ICONST_1);\n\t\tmv.visitJumpInsn(GOTO,endOfIf);\n\t\tmv.visitLabel(elseTarget);\n\t\tmv.visitInsn(ICONST_0);\n\t\tmv.visitLabel(endOfIf);\n\t\tcf.pushDescriptor(\"Z\");\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#getValue(state,desiredReturnType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "state",
      "desiredReturnType"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "T",
    "signature": "protected T getValue(ExpressionState state, Class<T> desiredReturnType)",
    "source_code": "\tprotected final <T> T getValue(ExpressionState state, Class<T> desiredReturnType) throws EvaluationException {\n\t\treturn ExpressionUtils.convertTypedValue(state.getEvaluationContext(), getValueInternal(state), desiredReturnType);\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#isSuitable(value,target,argumentTypes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "target",
      "argumentTypes"
    ],
    "position": {
      "column": 1,
      "line": 419
    },
    "return": "boolean",
    "signature": "public boolean isSuitable(Object value, @Nullable TypeDescriptor target, List<TypeDescriptor> argumentTypes)",
    "source_code": "\t\tpublic boolean isSuitable(Object value, @Nullable TypeDescriptor target, List<TypeDescriptor> argumentTypes) {\n\t\t\treturn ((this.staticClass == null || this.staticClass == value) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.target, target) && this.argumentTypes.equals(argumentTypes));\n\t\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#isWritableProperty(name,contextObject,evalContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "contextObject",
      "evalContext"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "boolean",
    "signature": "public boolean isWritableProperty(String name, TypedValue contextObject, EvaluationContext evalContext)",
    "source_code": "\tpublic boolean isWritableProperty(String name, TypedValue contextObject, EvaluationContext evalContext)\n\t\t\tthrows EvaluationException {\n\n\t\tObject value = contextObject.getValue();\n\t\tif (value != null) {\n\t\t\tList<PropertyAccessor> accessorsToTry =\n\t\t\t\t\tgetPropertyAccessorsToTry(contextObject.getValue(), evalContext.getPropertyAccessors());\n\t\t\tfor (PropertyAccessor accessor : accessorsToTry) {\n\t\t\t\ttry {\n\t\t\t\t\tif (accessor.canWrite(evalContext, value, name)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (AccessException ex) {\n\t\t\t\t\t// let others try\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#setValue(expressionState,newValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expressionState",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void setValue(ExpressionState expressionState, @Nullable Object newValue)",
    "source_code": "\tpublic void setValue(ExpressionState expressionState, @Nullable Object newValue) throws EvaluationException {\n\t\tthrow new SpelEvaluationException(getStartPosition(), SpelMessage.SETVALUE_NOT_SUPPORTED, getClass());\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#setValue(state,newValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "state",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "void",
    "signature": "public void setValue(ExpressionState state, @Nullable Object newValue)",
    "source_code": "\tpublic void setValue(ExpressionState state, @Nullable Object newValue) throws EvaluationException {\n\t\tgetValueRef(state).setValue(newValue);\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#subSequence(start,end)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "start",
      "end"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "CharSequence",
    "signature": "public CharSequence subSequence(int start, int end)",
    "source_code": "\t\tpublic CharSequence subSequence(int start, int end) {\n\t\t\treturn new MatcherInput(this.value.subSequence(start, end), this.access);\n\t\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#canCompare(left,right)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "left",
      "right"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "return": "boolean",
    "signature": "public boolean canCompare(@Nullable Object left, @Nullable Object right)",
    "source_code": "\tpublic boolean canCompare(@Nullable Object left, @Nullable Object right) {\n\t\tif (left == null || right == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (left instanceof Number && right instanceof Number) {\n\t\t\treturn true;\n\t\t}\n\t\tif (left instanceof Comparable && right instanceof Comparable) {\n\t\t\tClass<?> ancestor = ClassUtils.determineCommonAncestor(left.getClass(), right.getClass());\n\t\t\treturn ancestor != null && Comparable.class.isAssignableFrom(ancestor);\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#canRead(context,target,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 654
    },
    "return": "boolean",
    "signature": "public boolean canRead(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\t\tif (target == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tClass<?> type = (target instanceof Class<?> clazz ? clazz : target.getClass());\n\t\t\tif (type.isArray()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\tString getterName = \"get\" + StringUtils.capitalize(name);\n\t\t\t\tif (getterName.equals(method.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tgetterName = \"is\" + StringUtils.capitalize(name);\n\t\t\t\tif (getterName.equals(method.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.member.getName().equals(name);\n\t\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#canWrite(context,target,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 702
    },
    "return": "boolean",
    "signature": "public boolean canWrite(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) {\n\t\t\tthrow new UnsupportedOperationException(\"Should not be called on an OptimalPropertyAccessor\");\n\t\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#compare(left,right)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "left",
      "right"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "int",
    "signature": "public int compare(@Nullable Object left, @Nullable Object right)",
    "source_code": "\tpublic int compare(@Nullable Object left, @Nullable Object right) throws SpelEvaluationException {\n\t\t// If one is null, check if the other is\n\t\tif (left == null) {\n\t\t\treturn (right == null ? 0 : -1);\n\t\t}\n\t\telse if (right == null) {\n\t\t\treturn 1;  // left cannot be null at this point\n\t\t}\n\n\t\t// Basic number comparisons\n\t\tif (left instanceof Number leftNumber && right instanceof Number rightNumber) {\n\t\t\tif (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {\n\t\t\t\tBigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class);\n\t\t\t\tBigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class);\n\t\t\t\treturn leftBigDecimal.compareTo(rightBigDecimal);\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Double || rightNumber instanceof Double) {\n\t\t\t\treturn Double.compare(leftNumber.doubleValue(), rightNumber.doubleValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Float || rightNumber instanceof Float) {\n\t\t\t\treturn Float.compare(leftNumber.floatValue(), rightNumber.floatValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {\n\t\t\t\tBigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class);\n\t\t\t\tBigInteger rightBigInteger = NumberUtils.convertNumberToTargetClass(rightNumber, BigInteger.class);\n\t\t\t\treturn leftBigInteger.compareTo(rightBigInteger);\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Long || rightNumber instanceof Long) {\n\t\t\t\treturn Long.compare(leftNumber.longValue(), rightNumber.longValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Integer || rightNumber instanceof Integer) {\n\t\t\t\treturn Integer.compare(leftNumber.intValue(), rightNumber.intValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Short || rightNumber instanceof Short) {\n\t\t\t\treturn Short.compare(leftNumber.shortValue(), rightNumber.shortValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Byte || rightNumber instanceof Byte) {\n\t\t\t\treturn Byte.compare(leftNumber.byteValue(), rightNumber.byteValue());\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Unknown Number subtype -> best guess is double multiplication\n\t\t\t\treturn Double.compare(leftNumber.doubleValue(), rightNumber.doubleValue());\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (left instanceof Comparable) {\n\t\t\t\treturn ((Comparable<Object>) left).compareTo(right);\n\t\t\t}\n\t\t}\n\t\tcatch (ClassCastException ex) {\n\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.NOT_COMPARABLE, left.getClass(), right.getClass());\n\t\t}\n\n\t\tthrow new SpelEvaluationException(SpelMessage.NOT_COMPARABLE, left.getClass(), right.getClass());\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#createOptimalAccessor(context,target,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to create an optimized property accessor tailored for a property of a\n\t * particular name on a particular class. The general ReflectivePropertyAccessor\n\t * will always work but is not optimal due to the need to lookup which reflective\n\t * member (method/field) to use each time read() is called. This method will just\n\t * return the ReflectivePropertyAccessor instance if it is unable to build a more\n\t * optimal accessor.\n\t * <p>Note: An optimal accessor is currently only usable for read attempts.\n\t * Do not call this method if you need a read-write accessor.\n\t * @see OptimalPropertyAccessor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 511
    },
    "return": "PropertyAccessor",
    "signature": "public PropertyAccessor createOptimalAccessor(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\tpublic PropertyAccessor createOptimalAccessor(EvaluationContext context, @Nullable Object target, String name) {\n\t\t// Don't be clever for arrays or a null target...\n\t\tif (target == null) {\n\t\t\treturn this;\n\t\t}\n\t\tClass<?> type = (target instanceof Class<?> clazz ? clazz : target.getClass());\n\t\tif (type.isArray()) {\n\t\t\treturn this;\n\t\t}\n\n\t\tPropertyCacheKey cacheKey = new PropertyCacheKey(type, name, target instanceof Class);\n\t\tInvokerPair invocationTarget = this.readerCache.get(cacheKey);\n\n\t\tif (invocationTarget == null || invocationTarget.member instanceof Method) {\n\t\t\tMethod method = (Method) (invocationTarget != null ? invocationTarget.member : null);\n\t\t\tif (method == null) {\n\t\t\t\tmethod = findGetterForProperty(name, type, target);\n\t\t\t\tif (method != null) {\n\t\t\t\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(new MethodParameter(method, -1));\n\t\t\t\t\tmethod = ClassUtils.getInterfaceMethodIfPossible(method, type);\n\t\t\t\t\tinvocationTarget = new InvokerPair(method, typeDescriptor);\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tthis.readerCache.put(cacheKey, invocationTarget);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (method != null) {\n\t\t\t\treturn new OptimalPropertyAccessor(invocationTarget);\n\t\t\t}\n\t\t}\n\n\t\tif (invocationTarget == null || invocationTarget.member instanceof Field) {\n\t\t\tField field = (invocationTarget != null ? (Field) invocationTarget.member : null);\n\t\t\tif (field == null) {\n\t\t\t\tfield = findField(name, type, target instanceof Class);\n\t\t\t\tif (field != null) {\n\t\t\t\t\tinvocationTarget = new InvokerPair(field, new TypeDescriptor(field));\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tthis.readerCache.put(cacheKey, invocationTarget);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (field != null) {\n\t\t\t\treturn new OptimalPropertyAccessor(invocationTarget);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#findField(name,clazz,mustBeStatic)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a field of a certain name on a specified class.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "clazz",
      "mustBeStatic"
    ],
    "position": {
      "column": 1,
      "line": 476
    },
    "return": "Field",
    "signature": "protected Field findField(String name, Class<?> clazz, boolean mustBeStatic)",
    "source_code": "\tprotected Field findField(String name, Class<?> clazz, boolean mustBeStatic) {\n\t\tField[] fields = clazz.getFields();\n\t\tfor (Field field : fields) {\n\t\t\tif (field.getName().equals(name) && (!mustBeStatic || Modifier.isStatic(field.getModifiers()))) {\n\t\t\t\treturn field;\n\t\t\t}\n\t\t}\n\t\t// We'll search superclasses and implemented interfaces explicitly,\n\t\t// although it shouldn't be necessary - however, see SPR-10125.\n\t\tif (clazz.getSuperclass() != null) {\n\t\t\tField field = findField(name, clazz.getSuperclass(), mustBeStatic);\n\t\t\tif (field != null) {\n\t\t\t\treturn field;\n\t\t\t}\n\t\t}\n\t\tfor (Class<?> implementedInterface : clazz.getInterfaces()) {\n\t\t\tField field = findField(name, implementedInterface, mustBeStatic);\n\t\t\tif (field != null) {\n\t\t\t\treturn field;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#findGetterForProperty(propertyName,clazz,mustBeStatic)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a getter method for the specified property.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertyName",
      "clazz",
      "mustBeStatic"
    ],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "Method",
    "signature": "protected Method findGetterForProperty(String propertyName, Class<?> clazz, boolean mustBeStatic)",
    "source_code": "\tprotected Method findGetterForProperty(String propertyName, Class<?> clazz, boolean mustBeStatic) {\n\t\tMethod method = findMethodForProperty(getPropertyMethodSuffixes(propertyName),\n\t\t\t\t\"get\", clazz, mustBeStatic, 0, ANY_TYPES);\n\t\tif (method == null) {\n\t\t\tmethod = findMethodForProperty(getPropertyMethodSuffixes(propertyName),\n\t\t\t\t\t\"is\", clazz, mustBeStatic, 0, BOOLEAN_TYPES);\n\t\t\tif (method == null) {\n\t\t\t\t// Record-style plain accessor method, e.g. name()\n\t\t\t\tmethod = findMethodForProperty(new String[] {propertyName},\n\t\t\t\t\t\t\"\", clazz, mustBeStatic, 0, ANY_TYPES);\n\t\t\t}\n\t\t}\n\t\treturn method;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#findSetterForProperty(propertyName,clazz,mustBeStatic)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a setter method for the specified property.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertyName",
      "clazz",
      "mustBeStatic"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "Method",
    "signature": "protected Method findSetterForProperty(String propertyName, Class<?> clazz, boolean mustBeStatic)",
    "source_code": "\tprotected Method findSetterForProperty(String propertyName, Class<?> clazz, boolean mustBeStatic) {\n\t\treturn findMethodForProperty(getPropertyMethodSuffixes(propertyName),\n\t\t\t\t\"set\", clazz, mustBeStatic, 1, ANY_TYPES);\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#generateCode(propertyName,mv,cf)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "mv",
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 728
    },
    "return": "void",
    "signature": "public void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf)",
    "source_code": "\t\tpublic void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf) {\n\t\t\tboolean isStatic = Modifier.isStatic(this.member.getModifiers());\n\t\t\tString descriptor = cf.lastDescriptor();\n\t\t\tString classDesc = this.member.getDeclaringClass().getName().replace('.', '/');\n\n\t\t\tif (!isStatic) {\n\t\t\t\tif (descriptor == null) {\n\t\t\t\t\tcf.loadTarget(mv);\n\t\t\t\t}\n\t\t\t\tif (descriptor == null || !classDesc.equals(descriptor.substring(1))) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, classDesc);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (descriptor != null) {\n\t\t\t\t\t// A static field/method call will not consume what is on the stack,\n\t\t\t\t\t// it needs to be popped off.\n\t\t\t\t\tmv.visitInsn(POP);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\tboolean isInterface = method.getDeclaringClass().isInterface();\n\t\t\t\tint opcode = (isStatic ? INVOKESTATIC : isInterface ? INVOKEINTERFACE : INVOKEVIRTUAL);\n\t\t\t\tmv.visitMethodInsn(opcode, classDesc, method.getName(),\n\t\t\t\t\t\tCodeFlow.createSignatureDescriptor(method), isInterface);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmv.visitFieldInsn((isStatic ? GETSTATIC : GETFIELD), classDesc, this.member.getName(),\n\t\t\t\t\t\tCodeFlow.toJvmDescriptor(((Field) this.member).getType()));\n\t\t\t}\n\t\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#isCandidateForInvocation(method,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given {@code Method} is a candidate for method resolution\n\t * on an instance of the given target class.\n\t * <p>The default implementation considers any method as a candidate, even for\n\t * static methods sand non-user-declared methods on the {@link Object} base class.\n\t * @param method the Method to evaluate\n\t * @param targetClass the concrete target class that is being introspected\n\t * @since 4.3.15\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "boolean",
    "signature": "protected boolean isCandidateForInvocation(Method method, Class<?> targetClass)",
    "source_code": "\tprotected boolean isCandidateForInvocation(Method method, Class<?> targetClass) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#isCandidateForProperty(method,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given {@code Method} is a candidate for property access\n\t * on an instance of the given target class.\n\t * <p>The default implementation considers any method as a candidate, even for\n\t * non-user-declared properties on the {@link Object} base class.\n\t * @param method the Method to evaluate\n\t * @param targetClass the concrete target class that is being introspected\n\t * @since 4.3.15\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 434
    },
    "return": "boolean",
    "signature": "protected boolean isCandidateForProperty(Method method, Class<?> targetClass)",
    "source_code": "\tprotected boolean isCandidateForProperty(Method method, Class<?> targetClass) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#read(context,target,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 677
    },
    "return": "TypedValue",
    "signature": "public TypedValue read(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tObject value = method.invoke(target);\n\t\t\t\t\treturn new TypedValue(value, this.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access property '\" + name + \"' through getter method\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tField field = (Field) this.member;\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tObject value = field.get(target);\n\t\t\t\t\treturn new TypedValue(value, this.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access field '\" + name + \"'\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#registerMethodFilter(type,filter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a filter for methods on the given type.\n\t * @param type the type to filter on\n\t * @param filter the corresponding method filter,\n\t * or {@code null} to clear any filter for the given type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "filter"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void registerMethodFilter(Class<?> type, @Nullable MethodFilter filter)",
    "source_code": "\tpublic void registerMethodFilter(Class<?> type, @Nullable MethodFilter filter) {\n\t\tif (this.filters == null) {\n\t\t\tthis.filters = new HashMap<>();\n\t\t}\n\t\tif (filter != null) {\n\t\t\tthis.filters.put(type, filter);\n\t\t}\n\t\telse {\n\t\t\tthis.filters.remove(type);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#resolve(context,targetObject,name,argumentTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Locate a method on a type. There are three kinds of match that might occur:\n\t * <ol>\n\t * <li>an exact match where the types of the arguments match the types of the constructor\n\t * <li>an in-exact match where the types we are looking for are subtypes of those defined on the constructor\n\t * <li>a match where we are able to convert the arguments into those expected by the constructor,\n\t * according to the registered type converter\n\t * </ol>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "targetObject",
      "name",
      "argumentTypes"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "MethodExecutor",
    "signature": "public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,\n\t\t\tList<TypeDescriptor> argumentTypes)",
    "source_code": "\tpublic MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,\n\t\t\tList<TypeDescriptor> argumentTypes) throws AccessException {\n\n\t\ttry {\n\t\t\tTypeConverter typeConverter = context.getTypeConverter();\n\t\t\tClass<?> type = (targetObject instanceof Class<?> clazz ? clazz : targetObject.getClass());\n\t\t\tArrayList<Method> methods = new ArrayList<>(getMethods(type, targetObject));\n\n\t\t\t// If a filter is registered for this type, call it\n\t\t\tMethodFilter filter = (this.filters != null ? this.filters.get(type) : null);\n\t\t\tif (filter != null) {\n\t\t\t\tList<Method> filtered = filter.filter(methods);\n\t\t\t\tmethods = (filtered instanceof ArrayList ? (ArrayList<Method>) filtered : new ArrayList<>(filtered));\n\t\t\t}\n\n\t\t\t// Sort methods into a sensible order\n\t\t\tif (methods.size() > 1) {\n\t\t\t\tmethods.sort((m1, m2) -> {\n\t\t\t\t\tint m1pl = m1.getParameterCount();\n\t\t\t\t\tint m2pl = m2.getParameterCount();\n\t\t\t\t\t// vararg methods go last\n\t\t\t\t\tif (m1pl == m2pl) {\n\t\t\t\t\t\tif (!m1.isVarArgs() && m2.isVarArgs()) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (m1.isVarArgs() && !m2.isVarArgs()) {\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn Integer.compare(m1pl, m2pl);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Resolve any bridge methods\n\t\t\tfor (int i = 0; i < methods.size(); i++) {\n\t\t\t\tmethods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)));\n\t\t\t}\n\n\t\t\t// Remove duplicate methods (possible due to resolved bridge methods)\n\t\t\tSet<Method> methodsToIterate = new LinkedHashSet<>(methods);\n\n\t\t\tMethod closeMatch = null;\n\t\t\tint closeMatchDistance = Integer.MAX_VALUE;\n\t\t\tMethod matchRequiringConversion = null;\n\t\t\tboolean multipleOptions = false;\n\n\t\t\tfor (Method method : methodsToIterate) {\n\t\t\t\tif (method.getName().equals(name)) {\n\t\t\t\t\tint paramCount = method.getParameterCount();\n\t\t\t\t\tList<TypeDescriptor> paramDescriptors = new ArrayList<>(paramCount);\n\t\t\t\t\tfor (int i = 0; i < paramCount; i++) {\n\t\t\t\t\t\tparamDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)));\n\t\t\t\t\t}\n\t\t\t\t\tReflectionHelper.ArgumentsMatchInfo matchInfo = null;\n\t\t\t\t\tif (method.isVarArgs() && argumentTypes.size() >= (paramCount - 1)) {\n\t\t\t\t\t\t// *sigh* complicated\n\t\t\t\t\t\tmatchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter);\n\t\t\t\t\t}\n\t\t\t\t\telse if (paramCount == argumentTypes.size()) {\n\t\t\t\t\t\t// Name and parameter number match, check the arguments\n\t\t\t\t\t\tmatchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter);\n\t\t\t\t\t}\n\t\t\t\t\tif (matchInfo != null) {\n\t\t\t\t\t\tif (matchInfo.isExactMatch()) {\n\t\t\t\t\t\t\treturn new ReflectiveMethodExecutor(method, type);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (matchInfo.isCloseMatch()) {\n\t\t\t\t\t\t\tif (this.useDistance) {\n\t\t\t\t\t\t\t\tint matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes);\n\t\t\t\t\t\t\t\tif (closeMatch == null || matchDistance < closeMatchDistance) {\n\t\t\t\t\t\t\t\t\t// This is a better match...\n\t\t\t\t\t\t\t\t\tcloseMatch = method;\n\t\t\t\t\t\t\t\t\tcloseMatchDistance = matchDistance;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Take this as a close match if there isn't one already\n\t\t\t\t\t\t\t\tif (closeMatch == null) {\n\t\t\t\t\t\t\t\t\tcloseMatch = method;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (matchInfo.isMatchRequiringConversion()) {\n\t\t\t\t\t\t\tif (matchRequiringConversion != null) {\n\t\t\t\t\t\t\t\tmultipleOptions = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmatchRequiringConversion = method;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (closeMatch != null) {\n\t\t\t\treturn new ReflectiveMethodExecutor(closeMatch, type);\n\t\t\t}\n\t\t\telse if (matchRequiringConversion != null) {\n\t\t\t\tif (multipleOptions) {\n\t\t\t\t\tthrow new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name);\n\t\t\t\t}\n\t\t\t\treturn new ReflectiveMethodExecutor(matchRequiringConversion, type);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (EvaluationException ex) {\n\t\t\tthrow new AccessException(\"Failed to resolve method\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#write(context,target,name,newValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 707
    },
    "return": "void",
    "signature": "public void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue)",
    "source_code": "\t\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue) {\n\t\t\tthrow new UnsupportedOperationException(\"Should not be called on an OptimalPropertyAccessor\");\n\t\t}"
  },
  "org.springframework.format.support.<unknown>#addFormatterForFieldType(fieldType,formatter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fieldType",
      "formatter"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void addFormatterForFieldType(Class<?> fieldType, Formatter<?> formatter)",
    "source_code": "\tpublic void addFormatterForFieldType(Class<?> fieldType, Formatter<?> formatter) {\n\t\taddConverter(new PrinterConverter(fieldType, formatter, this));\n\t\taddConverter(new ParserConverter(fieldType, formatter, this));\n\t}"
  },
  "org.springframework.format.support.<unknown>#addFormatterForFieldType(fieldType,printer,parser)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fieldType",
      "printer",
      "parser"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void addFormatterForFieldType(Class<?> fieldType, Printer<?> printer, Parser<?> parser)",
    "source_code": "\tpublic void addFormatterForFieldType(Class<?> fieldType, Printer<?> printer, Parser<?> parser) {\n\t\taddConverter(new PrinterConverter(fieldType, printer, this));\n\t\taddConverter(new ParserConverter(fieldType, parser, this));\n\t}"
  },
  "org.springframework.format.support.<unknown>#convert(source,sourceType,targetType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "Object",
    "signature": "public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\t\tpublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tAnnotation ann = targetType.getAnnotation(this.annotationType);\n\t\t\tif (ann == null) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Expected [\" + this.annotationType.getName() + \"] to be present on \" + targetType);\n\t\t\t}\n\t\t\tAnnotationConverterKey converterKey = new AnnotationConverterKey(ann, targetType.getObjectType());\n\t\t\tGenericConverter converter = cachedParsers.get(converterKey);\n\t\t\tif (converter == null) {\n\t\t\t\tParser<?> parser = this.annotationFormatterFactory.getParser(\n\t\t\t\t\t\tconverterKey.getAnnotation(), converterKey.getFieldType());\n\t\t\t\tconverter = new ParserConverter(this.fieldType, parser, FormattingConversionService.this);\n\t\t\t\tcachedParsers.put(converterKey, converter);\n\t\t\t}\n\t\t\treturn converter.convert(source, sourceType, targetType);\n\t\t}"
  },
  "org.springframework.format.support.<unknown>#matches(sourceType,targetType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "boolean",
    "signature": "public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\treturn targetType.hasAnnotation(this.annotationType);\n\t\t}"
  },
  "org.springframework.http.<unknown>#add(headerName,headerValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given, single header value under the given name.\n\t * @param headerName the header name\n\t * @param headerValue the header value\n\t * @throws UnsupportedOperationException if adding headers is not supported\n\t * @see #put(String, List)\n\t * @see #set(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 1723
    },
    "return": "void",
    "signature": "public void add(String headerName, @Nullable String headerValue)",
    "source_code": "\tpublic void add(String headerName, @Nullable String headerValue) {\n\t\tthis.headers.add(headerName, headerValue);\n\t}"
  },
  "org.springframework.http.<unknown>#addAll(MultiValueMap<String,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1733
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tthis.headers.addAll(values);\n\t}"
  },
  "org.springframework.http.<unknown>#addAll(key,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1728
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tthis.headers.addAll(key, values);\n\t}"
  },
  "org.springframework.http.<unknown>#checkParameters(parameter,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "void",
    "signature": "protected void checkParameters(String parameter, String value)",
    "source_code": "\tprotected void checkParameters(String parameter, String value) {\n\t\tsuper.checkParameters(parameter, value);\n\t\tif (PARAM_QUALITY_FACTOR.equals(parameter)) {\n\t\t\tString unquotedValue = unquote(value);\n\t\t\tdouble d = Double.parseDouble(unquotedValue);\n\t\t\tAssert.isTrue(d >= 0D && d <= 1D,\n\t\t\t\t\t() -> \"Invalid quality value \\\"\" + unquotedValue + \"\\\": should be between 0.0 and 1.0\");\n\t\t}\n\t}"
  },
  "org.springframework.http.<unknown>#compareParameters(mediaType1,mediaType2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mediaType1",
      "mediaType2"
    ],
    "position": {
      "column": 1,
      "line": 958
    },
    "return": "int",
    "signature": "protected int compareParameters(MediaType mediaType1, MediaType mediaType2)",
    "source_code": "\t\tprotected int compareParameters(MediaType mediaType1, MediaType mediaType2) {\n\t\t\tdouble quality1 = mediaType1.getQualityValue();\n\t\t\tdouble quality2 = mediaType2.getQualityValue();\n\t\t\tint qualityComparison = Double.compare(quality2, quality1);\n\t\t\tif (qualityComparison != 0) {\n\t\t\t\treturn qualityComparison;  // audio/*;q=0.7 < audio/*;q=0.3\n\t\t\t}\n\t\t\treturn super.compareParameters(mediaType1, mediaType2);\n\t\t}"
  },
  "org.springframework.http.<unknown>#createByteRange(firstBytePos,lastBytePos)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@code HttpRange} from the given fist to last position.\n\t * @param firstBytePos the first byte position\n\t * @param lastBytePos the last byte position\n\t * @return a byte range that ranges from {@code firstPos} till {@code lastPos}\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7233#section-2.1\">Byte Ranges</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "firstBytePos",
      "lastBytePos"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "HttpRange",
    "signature": "public HttpRange createByteRange(long firstBytePos, long lastBytePos)",
    "source_code": "\tpublic static HttpRange createByteRange(long firstBytePos, long lastBytePos) {\n\t\treturn new ByteRange(firstBytePos, lastBytePos);\n\t}"
  },
  "org.springframework.http.<unknown>#encodeBasicAuth(username,password,charset)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given username and password into Basic Authentication credentials.\n\t * <p>The encoded credentials returned by this method can be supplied to\n\t * {@link #setBasicAuth(String)} to set the Basic Authentication header.\n\t * @param username the username\n\t * @param password the password\n\t * @param charset the charset to use to convert the credentials into an octet\n\t * sequence. Defaults to {@linkplain StandardCharsets#ISO_8859_1 ISO-8859-1}.\n\t * @throws IllegalArgumentException if {@code username} or {@code password}\n\t * contains characters that cannot be encoded to the given charset\n\t * @since 5.2\n\t * @see #setBasicAuth(String)\n\t * @see #setBasicAuth(String, String)\n\t * @see #setBasicAuth(String, String, Charset)\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7617\">RFC 7617</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 1928
    },
    "return": "String",
    "signature": "public String encodeBasicAuth(String username, String password, @Nullable Charset charset)",
    "source_code": "\tpublic static String encodeBasicAuth(String username, String password, @Nullable Charset charset) {\n\t\tAssert.notNull(username, \"Username must not be null\");\n\t\tAssert.doesNotContain(username, \":\", \"Username must not contain a colon\");\n\t\tAssert.notNull(password, \"Password must not be null\");\n\t\tif (charset == null) {\n\t\t\tcharset = StandardCharsets.ISO_8859_1;\n\t\t}\n\n\t\tCharsetEncoder encoder = charset.newEncoder();\n\t\tif (!encoder.canEncode(username) || !encoder.canEncode(password)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Username or password contains characters that cannot be encoded to \" + charset.displayName());\n\t\t}\n\n\t\tString credentialsString = username + \":\" + password;\n\t\tbyte[] encodedBytes = Base64.getEncoder().encode(credentialsString.getBytes(charset));\n\t\treturn new String(encodedBytes, charset);\n\t}"
  },
  "org.springframework.http.<unknown>#filename(filename,charset)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filename",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 791
    },
    "return": "Builder",
    "signature": "public Builder filename(String filename, Charset charset)",
    "source_code": "\t\tpublic Builder filename(String filename, Charset charset) {\n\t\t\tAssert.hasText(filename, \"No filename\");\n\t\t\tthis.filename = filename;\n\t\t\tthis.charset = charset;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.<unknown>#forStatusAndDetail(status,detail)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@code ProblemDetail} instance with the given status and detail.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status",
      "detail"
    ],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "ProblemDetail",
    "signature": "public ProblemDetail forStatusAndDetail(HttpStatusCode status, String detail)",
    "source_code": "\tpublic static ProblemDetail forStatusAndDetail(HttpStatusCode status, String detail) {\n\t\tAssert.notNull(status, \"HttpStatusCode is required\");\n\t\tProblemDetail problemDetail = forStatus(status.value());\n\t\tproblemDetail.setDetail(detail);\n\t\treturn problemDetail;\n\t}"
  },
  "org.springframework.http.<unknown>#formatHeaders(MultiValueMap<String,headers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Helps to format HTTP header values, as HTTP header values themselves can\n\t * contain comma-separated values, can become confusing with regular\n\t * {@link Map} formatting that also uses commas between entries.\n\t * @param headers the headers to format\n\t * @return the headers to a String\n\t * @since 5.1.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 1901
    },
    "return": "String",
    "signature": "public String formatHeaders(MultiValueMap<String, String> headers)",
    "source_code": "\tpublic static String formatHeaders(MultiValueMap<String, String> headers) {\n\t\treturn headers.entrySet().stream()\n\t\t\t\t.map(entry -> {\n\t\t\t\t\tList<String> values = entry.getValue();\n\t\t\t\t\treturn entry.getKey() + \":\" + (values.size() == 1 ?\n\t\t\t\t\t\t\t\"\\\"\" + values.get(0) + \"\\\"\" :\n\t\t\t\t\t\t\tvalues.stream().map(s -> \"\\\"\" + s + \"\\\"\").collect(Collectors.joining(\", \")));\n\t\t\t\t})\n\t\t\t\t.collect(Collectors.joining(\", \", \"[\", \"]\"));\n\t}"
  },
  "org.springframework.http.<unknown>#from(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Factory method to obtain a builder for a server-defined cookie that starts\n\t * with a name-value pair and may also include attributes.\n\t * @param name the cookie name\n\t * @param value the cookie value\n\t * @return a builder to create the cookie with\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "ResponseCookieBuilder",
    "signature": "public ResponseCookieBuilder from(final String name, final String value)",
    "source_code": "\tpublic static ResponseCookieBuilder from(final String name, final String value) {\n\t\treturn new DefaultResponseCookieBuilder(name, value, false);\n\t}"
  },
  "org.springframework.http.<unknown>#fromClientResponse(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Factory method to obtain a builder for a server-defined cookie. Unlike\n\t * {@link #from(String, String)} this option assumes input from a remote\n\t * server, which can be handled more leniently, e.g. ignoring an empty domain\n\t * name with double quotes.\n\t * @param name the cookie name\n\t * @param value the cookie value\n\t * @return a builder to create the cookie with\n\t * @since 5.2.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "ResponseCookieBuilder",
    "signature": "public ResponseCookieBuilder fromClientResponse(final String name, final String value)",
    "source_code": "\tpublic static ResponseCookieBuilder fromClientResponse(final String name, final String value) {\n\t\treturn new DefaultResponseCookieBuilder(name, value, true);\n\t}"
  },
  "org.springframework.http.<unknown>#header(headerName,headerValues)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 541
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic BodyBuilder header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tthis.headers.add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1790
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\treturn this.headers.put(key, value);\n\t}"
  },
  "org.springframework.http.<unknown>#putAll(String,map)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 1800
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tthis.headers.putAll(map);\n\t}"
  },
  "org.springframework.http.<unknown>#readOnlyHttpHeaders(MultiValueMap<String,headers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply a read-only {@code HttpHeaders} wrapper around the given headers, if necessary.\n\t * <p>Also caches the parsed representations of the \"Accept\" and \"Content-Type\" headers.\n\t * @param headers the headers to expose\n\t * @return a read-only variant of the headers, or the original headers as-is\n\t * (in case it happens to be a read-only {@code HttpHeaders} instance already)\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 1862
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders readOnlyHttpHeaders(MultiValueMap<String, String> headers)",
    "source_code": "\tpublic static HttpHeaders readOnlyHttpHeaders(MultiValueMap<String, String> headers) {\n\t\treturn (headers instanceof HttpHeaders httpHeaders ? readOnlyHttpHeaders(httpHeaders) :\n\t\t\t\tnew ReadOnlyHttpHeaders(headers));\n\t}"
  },
  "org.springframework.http.<unknown>#set(headerName,headerValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given, single header value under the given name.\n\t * @param headerName the header name\n\t * @param headerValue the header value\n\t * @throws UnsupportedOperationException if adding headers is not supported\n\t * @see #put(String, List)\n\t * @see #add(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 1746
    },
    "return": "void",
    "signature": "public void set(String headerName, @Nullable String headerValue)",
    "source_code": "\tpublic void set(String headerName, @Nullable String headerValue) {\n\t\tthis.headers.set(headerName, headerValue);\n\t}"
  },
  "org.springframework.http.<unknown>#setAll(Map<String,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1751
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tthis.headers.setAll(values);\n\t}"
  },
  "org.springframework.http.<unknown>#setBasicAuth(username,password)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value of the {@linkplain #AUTHORIZATION Authorization} header to\n\t * Basic Authentication based on the given username and password.\n\t * <p>Note that this method only supports characters in the\n\t * {@link StandardCharsets#ISO_8859_1 ISO-8859-1} character set.\n\t * @param username the username\n\t * @param password the password\n\t * @throws IllegalArgumentException if either {@code user} or\n\t * {@code password} contain characters that cannot be encoded to ISO-8859-1\n\t * @since 5.1\n\t * @see #setBasicAuth(String)\n\t * @see #setBasicAuth(String, String, Charset)\n\t * @see #encodeBasicAuth(String, String, Charset)\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7617\">RFC 7617</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 781
    },
    "return": "void",
    "signature": "public void setBasicAuth(String username, String password)",
    "source_code": "\tpublic void setBasicAuth(String username, String password) {\n\t\tsetBasicAuth(username, password, null);\n\t}"
  },
  "org.springframework.http.<unknown>#setBasicAuth(username,password,charset)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value of the {@linkplain #AUTHORIZATION Authorization} header to\n\t * Basic Authentication based on the given username and password.\n\t * @param username the username\n\t * @param password the password\n\t * @param charset the charset to use to convert the credentials into an octet\n\t * sequence. Defaults to {@linkplain StandardCharsets#ISO_8859_1 ISO-8859-1}.\n\t * @throws IllegalArgumentException if {@code username} or {@code password}\n\t * contains characters that cannot be encoded to the given charset\n\t * @since 5.1\n\t * @see #setBasicAuth(String)\n\t * @see #setBasicAuth(String, String)\n\t * @see #encodeBasicAuth(String, String, Charset)\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7617\">RFC 7617</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 800
    },
    "return": "void",
    "signature": "public void setBasicAuth(String username, String password, @Nullable Charset charset)",
    "source_code": "\tpublic void setBasicAuth(String username, String password, @Nullable Charset charset) {\n\t\tsetBasicAuth(encodeBasicAuth(username, password, charset));\n\t}"
  },
  "org.springframework.http.<unknown>#setContentDispositionFormData(name,filename)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@code Content-Disposition} header when creating a\n\t * {@code \"multipart/form-data\"} request.\n\t * <p>Applications typically would not set this header directly but\n\t * rather prepare a {@code MultiValueMap<String, Object>}, containing an\n\t * Object or a {@link org.springframework.core.io.Resource} for each part,\n\t * and then pass that to the {@code RestTemplate} or {@code WebClient}.\n\t * @param name the control name\n\t * @param filename the filename (may be {@code null})\n\t * @see #getContentDisposition()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "filename"
    ],
    "position": {
      "column": 1,
      "line": 892
    },
    "return": "void",
    "signature": "public void setContentDispositionFormData(String name, @Nullable String filename)",
    "source_code": "\tpublic void setContentDispositionFormData(String name, @Nullable String filename) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tContentDisposition.Builder disposition = ContentDisposition.formData().name(name);\n\t\tif (StringUtils.hasText(filename)) {\n\t\t\tdisposition.filename(filename);\n\t\t}\n\t\tsetContentDisposition(disposition.build());\n\t}"
  },
  "org.springframework.http.<unknown>#setDate(headerName,date)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given date under the given header name after formatting it as a string\n\t * using the RFC-1123 date-time formatter. The equivalent of\n\t * {@link #set(String, String)} but for date headers.\n\t * @since 3.2.4\n\t * @see #setZonedDateTime(String, ZonedDateTime)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "date"
    ],
    "position": {
      "column": 1,
      "line": 1447
    },
    "return": "void",
    "signature": "public void setDate(String headerName, long date)",
    "source_code": "\tpublic void setDate(String headerName, long date) {\n\t\tsetInstant(headerName, Instant.ofEpochMilli(date));\n\t}"
  },
  "org.springframework.http.<unknown>#setInstant(headerName,date)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given date under the given header name after formatting it as a string\n\t * using the RFC-1123 date-time formatter. The equivalent of\n\t * {@link #set(String, String)} but for date headers.\n\t * @since 5.1.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "date"
    ],
    "position": {
      "column": 1,
      "line": 1436
    },
    "return": "void",
    "signature": "public void setInstant(String headerName, Instant date)",
    "source_code": "\tpublic void setInstant(String headerName, Instant date) {\n\t\tsetZonedDateTime(headerName, ZonedDateTime.ofInstant(date, GMT));\n\t}"
  },
  "org.springframework.http.<unknown>#setProperty(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a \"dynamic\" property to be added to a generic {@link #getProperties()\n\t * properties map}.\n\t * <p>When Jackson JSON is present on the classpath, any properties set here\n\t * are rendered as top level key-value pairs in the output JSON. Otherwise,\n\t * they are rendered as a {@code \"properties\"} sub-map.\n\t * @param name the property name\n\t * @param value the property value, possibly {@code null} if the intent is\n\t * to include a property with its value set to \"null\"\n\t * @see org.springframework.http.converter.json.ProblemDetailJacksonMixin\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "void",
    "signature": "public void setProperty(String name, @Nullable Object value)",
    "source_code": "\tpublic void setProperty(String name, @Nullable Object value) {\n\t\tthis.properties = (this.properties != null ? this.properties : new LinkedHashMap<>());\n\t\tthis.properties.put(name, value);\n\t}"
  },
  "org.springframework.http.<unknown>#setZonedDateTime(headerName,date)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given date under the given header name after formatting it as a string\n\t * using the RFC-1123 date-time formatter. The equivalent of\n\t * {@link #set(String, String)} but for date headers.\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "date"
    ],
    "position": {
      "column": 1,
      "line": 1426
    },
    "return": "void",
    "signature": "public void setZonedDateTime(String headerName, ZonedDateTime date)",
    "source_code": "\tpublic void setZonedDateTime(String headerName, ZonedDateTime date) {\n\t\tset(headerName, DATE_FORMATTER.format(date));\n\t}"
  },
  "org.springframework.http.<unknown>#toResourceRegions(ranges,resource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert each {@code HttpRange} into a {@code ResourceRegion}, selecting the\n\t * appropriate segment of the given {@code Resource} using HTTP Range information.\n\t * @param ranges the list of ranges\n\t * @param resource the resource to select the regions from\n\t * @return the list of regions for the given resource\n\t * @throws IllegalArgumentException if the sum of all ranges exceeds the resource length\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ranges",
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "List<ResourceRegion>",
    "signature": "public List<ResourceRegion> toResourceRegions(List<HttpRange> ranges, Resource resource)",
    "source_code": "\tpublic static List<ResourceRegion> toResourceRegions(List<HttpRange> ranges, Resource resource) {\n\t\tif (CollectionUtils.isEmpty(ranges)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tList<ResourceRegion> regions = new ArrayList<>(ranges.size());\n\t\tfor (HttpRange range : ranges) {\n\t\t\tregions.add(range.toResourceRegion(resource));\n\t\t}\n\t\tif (ranges.size() > 1) {\n\t\t\tlong length = getLengthFor(resource);\n\t\t\tlong total = 0;\n\t\t\tfor (ResourceRegion region : regions) {\n\t\t\t\ttotal += region.getCount();\n\t\t\t}\n\t\t\tif (total >= length) {\n\t\t\t\tthrow new IllegalArgumentException(\"The sum of all ranges (\" + total +\n\t\t\t\t\t\t\") should be less than the resource length (\" + length + \")\");\n\t\t\t}\n\t\t}\n\t\treturn regions;\n\t}"
  },
  "org.springframework.http.client.<unknown>#asyncPart(name,publisher,elementClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a part from {@link Publisher} content.\n\t * @param name the name of the part to add\n\t * @param publisher a Publisher of content for the part\n\t * @param elementClass the type of elements contained in the publisher\n\t * @return builder that allows for further customization of part headers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder asyncPart(String name, P publisher, Class<T> elementClass)",
    "source_code": "\tpublic <T, P extends Publisher<T>> PartBuilder asyncPart(String name, P publisher, Class<T> elementClass) {\n\t\tAssert.hasLength(name, \"'name' must not be empty\");\n\t\tAssert.notNull(publisher, \"'publisher' must not be null\");\n\t\tAssert.notNull(elementClass, \"'elementClass' must not be null\");\n\n\t\tPublisherPartBuilder<T, P> builder = new PublisherPartBuilder<>(name, null, publisher, elementClass);\n\t\tthis.parts.add(name, builder);\n\t\treturn builder;\n\t}"
  },
  "org.springframework.http.client.<unknown>#asyncPart(name,publisher,typeReference)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #asyncPart(String, Publisher, Class)} with a\n\t * {@link ParameterizedTypeReference} for the element type information.\n\t * @param name the name of the part to add\n\t * @param publisher the part contents\n\t * @param typeReference the type of elements contained in the publisher\n\t * @return builder that allows for further customization of part headers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "typeReference"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder asyncPart(String name, P publisher, ParameterizedTypeReference<T> typeReference)",
    "source_code": "\tpublic <T, P extends Publisher<T>> PartBuilder asyncPart(\n\t\t\tString name, P publisher, ParameterizedTypeReference<T> typeReference) {\n\n\t\tAssert.hasLength(name, \"'name' must not be empty\");\n\t\tAssert.notNull(publisher, \"'publisher' must not be null\");\n\t\tAssert.notNull(typeReference, \"'typeReference' must not be null\");\n\n\t\tPublisherPartBuilder<T, P> builder = new PublisherPartBuilder<>(name, null, publisher, typeReference);\n\t\tthis.parts.add(name, builder);\n\t\treturn builder;\n\t}"
  },
  "org.springframework.http.client.<unknown>#createHttpContext(httpMethod,uri)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template methods that creates a {@link HttpContext} for the given HTTP method and URI.\n\t * <p>The default implementation returns {@code null}.\n\t * @param httpMethod the HTTP method\n\t * @param uri the URI\n\t * @return the http context\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "httpMethod",
      "uri"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "HttpContext",
    "signature": "protected HttpContext createHttpContext(HttpMethod httpMethod, URI uri)",
    "source_code": "\tprotected HttpContext createHttpContext(HttpMethod httpMethod, URI uri) {\n\t\treturn (this.httpContextFactory != null ? this.httpContextFactory.apply(httpMethod, uri) : null);\n\t}"
  },
  "org.springframework.http.client.<unknown>#createHttpUriRequest(httpMethod,uri)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a Commons HttpMethodBase object for the given HTTP method and URI specification.\n\t * @param httpMethod the HTTP method\n\t * @param uri the URI\n\t * @return the Commons HttpMethodBase object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "httpMethod",
      "uri"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "ClassicHttpRequest",
    "signature": "protected ClassicHttpRequest createHttpUriRequest(HttpMethod httpMethod, URI uri)",
    "source_code": "\tprotected ClassicHttpRequest createHttpUriRequest(HttpMethod httpMethod, URI uri) {\n\t\tif (HttpMethod.GET.equals(httpMethod)) {\n\t\t\treturn new HttpGet(uri);\n\t\t}\n\t\telse if (HttpMethod.HEAD.equals(httpMethod)) {\n\t\t\treturn new HttpHead(uri);\n\t\t}\n\t\telse if (HttpMethod.POST.equals(httpMethod)) {\n\t\t\treturn new HttpPost(uri);\n\t\t}\n\t\telse if (HttpMethod.PUT.equals(httpMethod)) {\n\t\t\treturn new HttpPut(uri);\n\t\t}\n\t\telse if (HttpMethod.PATCH.equals(httpMethod)) {\n\t\t\treturn new HttpPatch(uri);\n\t\t}\n\t\telse if (HttpMethod.DELETE.equals(httpMethod)) {\n\t\t\treturn new HttpDelete(uri);\n\t\t}\n\t\telse if (HttpMethod.OPTIONS.equals(httpMethod)) {\n\t\t\treturn new HttpOptions(uri);\n\t\t}\n\t\telse if (HttpMethod.TRACE.equals(httpMethod)) {\n\t\t\treturn new HttpTrace(uri);\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Invalid HTTP method: \" + httpMethod);\n\t}"
  },
  "org.springframework.http.client.<unknown>#createRequest(uri,httpMethod)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri",
      "httpMethod"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "ClientHttpRequest",
    "signature": "public ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod)",
    "source_code": "\tpublic ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) throws IOException {\n\t\tHttpClient client = getHttpClient();\n\n\t\tClassicHttpRequest httpRequest = createHttpUriRequest(httpMethod, uri);\n\t\tpostProcessHttpRequest(httpRequest);\n\t\tHttpContext context = createHttpContext(httpMethod, uri);\n\t\tif (context == null) {\n\t\t\tcontext = HttpClientContext.create();\n\t\t}\n\n\t\t// Request configuration not set in the context\n\t\tif (context.getAttribute(HttpClientContext.REQUEST_CONFIG) == null) {\n\t\t\t// Use request configuration given by the user, when available\n\t\t\tRequestConfig config = null;\n\t\t\tif (httpRequest instanceof Configurable configurable) {\n\t\t\t\tconfig = configurable.getConfig();\n\t\t\t}\n\t\t\tif (config == null) {\n\t\t\t\tconfig = createRequestConfig(client);\n\t\t\t}\n\t\t\tif (config != null) {\n\t\t\t\tcontext.setAttribute(HttpClientContext.REQUEST_CONFIG, config);\n\t\t\t}\n\t\t}\n\n\t\tif (this.bufferRequestBody) {\n\t\t\treturn new HttpComponentsClientHttpRequest(client, httpRequest, context);\n\t\t}\n\t\telse {\n\t\t\treturn new HttpComponentsStreamingClientHttpRequest(client, httpRequest, context);\n\t\t}\n\t}"
  },
  "org.springframework.http.client.<unknown>#execute(request,body)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "body"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "ClientHttpResponse",
    "signature": "public ClientHttpResponse execute(HttpRequest request, byte[] body)",
    "source_code": "\t\tpublic ClientHttpResponse execute(HttpRequest request, byte[] body) throws IOException {\n\t\t\tif (this.iterator.hasNext()) {\n\t\t\t\tClientHttpRequestInterceptor nextInterceptor = this.iterator.next();\n\t\t\t\treturn nextInterceptor.intercept(request, body, this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tHttpMethod method = request.getMethod();\n\t\t\t\tClientHttpRequest delegate = requestFactory.createRequest(request.getURI(), method);\n\t\t\t\trequest.getHeaders().forEach((key, value) -> delegate.getHeaders().addAll(key, value));\n\t\t\t\tif (body.length > 0) {\n\t\t\t\t\tif (delegate instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\t\t\t\tstreamingOutputMessage.setBody(outputStream -> StreamUtils.copy(body, outputStream));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tStreamUtils.copy(body, delegate.getBody());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn delegate.execute();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.client.<unknown>#executeInternal(headers,bufferedOutput)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headers",
      "bufferedOutput"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "ClientHttpResponse",
    "signature": "protected ClientHttpResponse executeInternal(HttpHeaders headers, byte[] bufferedOutput)",
    "source_code": "\tprotected final ClientHttpResponse executeInternal(HttpHeaders headers, byte[] bufferedOutput) throws IOException {\n\t\tInterceptingRequestExecution requestExecution = new InterceptingRequestExecution();\n\t\treturn requestExecution.execute(this, bufferedOutput);\n\t}"
  },
  "org.springframework.http.client.<unknown>#header(headerName,headerValues)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic PartBuilder header(String headerName, String... headerValues) {\n\t\t\tinitHeadersIfNecessary().addAll(headerName, Arrays.asList(headerValues));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.<unknown>#part(name,part)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a part where the Object may be:\n\t * <ul>\n\t * <li>String -- form field\n\t * <li>{@link org.springframework.core.io.Resource Resource} -- file part\n\t * <li>Object -- content to be encoded (e.g. to JSON)\n\t * <li>{@link HttpEntity} -- part content and headers although generally it's\n\t * easier to add headers through the returned builder\n\t * <li>{@link Part} -- a part from a server request\n\t * </ul>\n\t * @param name the name of the part to add\n\t * @param part the part data\n\t * @return builder that allows for further customization of part headers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "part"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder part(String name, Object part)",
    "source_code": "\tpublic PartBuilder part(String name, Object part) {\n\t\treturn part(name, part, null);\n\t}"
  },
  "org.springframework.http.client.<unknown>#part(name,part,contentType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #part(String, Object)} that also accepts a MediaType.\n\t * @param name the name of the part to add\n\t * @param part the part data\n\t * @param contentType the media type to help with encoding the part\n\t * @return builder that allows for further customization of part headers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "part",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder part(String name, Object part, @Nullable MediaType contentType)",
    "source_code": "\tpublic PartBuilder part(String name, Object part, @Nullable MediaType contentType) {\n\t\tAssert.hasLength(name, \"'name' must not be empty\");\n\t\tAssert.notNull(part, \"'part' must not be null\");\n\n\t\tif (part instanceof Part partObject) {\n\t\t\tPartBuilder builder = asyncPart(name, partObject.content(), DataBuffer.class);\n\t\t\tif (!partObject.headers().isEmpty()) {\n\t\t\t\tbuilder.headers(headers -> {\n\t\t\t\t\theaders.putAll(partObject.headers());\n\t\t\t\t\tString filename = headers.getContentDisposition().getFilename();\n\t\t\t\t\t// reset to parameter name\n\t\t\t\t\theaders.setContentDispositionFormData(name, filename);\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (contentType != null) {\n\t\t\t\tbuilder.contentType(contentType);\n\t\t\t}\n\t\t\treturn builder;\n\t\t}\n\n\t\tif (part instanceof PublisherEntity<?,?> publisherEntity) {\n\t\t\tPublisherPartBuilder<?, ?> builder = new PublisherPartBuilder<>(name, publisherEntity);\n\t\t\tif (contentType != null) {\n\t\t\t\tbuilder.contentType(contentType);\n\t\t\t}\n\t\t\tthis.parts.add(name, builder);\n\t\t\treturn builder;\n\t\t}\n\n\t\tObject partBody;\n\t\tHttpHeaders partHeaders = null;\n\t\tif (part instanceof HttpEntity<?> httpEntity) {\n\t\t\tpartBody = httpEntity.getBody();\n\t\t\tpartHeaders = new HttpHeaders();\n\t\t\tpartHeaders.putAll(httpEntity.getHeaders());\n\t\t}\n\t\telse {\n\t\t\tpartBody = part;\n\t\t}\n\n\t\tif (partBody instanceof Publisher) {\n\t\t\tthrow new IllegalArgumentException(\"\"\"\n\t\t\t\t\tUse asyncPart(String, Publisher, Class) \\\n\t\t\t\t\tor asyncPart(String, Publisher, ParameterizedTypeReference) \\\n\t\t\t\t\tor MultipartBodyBuilder.PublisherEntity\"\"\");\n\t\t}\n\n\t\tDefaultPartBuilder builder = new DefaultPartBuilder(name, partHeaders, partBody);\n\t\tif (contentType != null) {\n\t\t\tbuilder.contentType(contentType);\n\t\t}\n\t\tthis.parts.add(name, builder);\n\t\treturn builder;\n\t}"
  },
  "org.springframework.http.client.<unknown>#setHttpContextFactory(BiFunction<HttpMethod,URI,httpContextFactory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a factory to pre-create the {@link HttpContext} for each request.\n\t * <p>This may be useful for example in mutual TLS authentication where a\n\t * different {@code RestTemplate} for each client certificate such that\n\t * all calls made through a given {@code RestTemplate} instance as associated\n\t * for the same client identity. {@link HttpClientContext#setUserToken(Object)}\n\t * can be used to specify a fixed user token for all requests.\n\t * @param httpContextFactory the context factory to use\n\t * @since 5.2.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiFunction<HttpMethod",
      "URI",
      "httpContextFactory"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "public void setHttpContextFactory(BiFunction<HttpMethod, URI, HttpContext> httpContextFactory)",
    "source_code": "\tpublic void setHttpContextFactory(BiFunction<HttpMethod, URI, HttpContext> httpContextFactory) {\n\t\tthis.httpContextFactory = httpContextFactory;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#add(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(\"Immutable headers\");\n\t\t}\n\t\tmutableHttpFields.add(key, value);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#addAll(MultiValueMap<String,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#addAll(key,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#completed(Message<HttpResponse,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Message<HttpResponse",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "public void completed(Message<HttpResponse, Publisher<ByteBuffer>> result)",
    "source_code": "\t\tpublic void completed(Message<HttpResponse, Publisher<ByteBuffer>> result) {\n\t\t\tHttpComponentsClientHttpResponse response =\n\t\t\t\t\tnew HttpComponentsClientHttpResponse(this.dataBufferFactory, result, this.context);\n\t\t\tthis.sink.success(response);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#connect(method,uri,ClientHttpRequest,requestCallback)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uri",
      "ClientHttpRequest",
      "requestCallback"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Mono<ClientHttpResponse>",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n\n\t\tHttpClientContext context = this.contextProvider.apply(method, uri);\n\n\t\tif (context.getCookieStore() == null) {\n\t\t\tcontext.setCookieStore(new BasicCookieStore());\n\t\t}\n\n\t\tHttpComponentsClientHttpRequest request = new HttpComponentsClientHttpRequest(method, uri,\n\t\t\t\tcontext, this.dataBufferFactory);\n\n\t\treturn requestCallback.apply(request).then(Mono.defer(() -> execute(request, context)));\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(\"Immutable headers\");\n\t\t}\n\t\tList<String> oldValues = get(key);\n\t\tmutableHttpFields.put(key, value);\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#put(key,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> values)",
    "source_code": "\tpublic List<String> put(String key, List<String> values) {\n\t\tList<String> oldValues = remove(key);\n\t\tvalues.forEach(value -> add(key, value));\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#putAll(String,map)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#set(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(\"Immutable headers\");\n\t\t}\n\t\tmutableHttpFields.put(key, value);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#setAll(Map<String,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#addHeaders(message,resource,contentType,Map<String,hints)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Adds the default headers for the given resource to the given message.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "resource",
      "contentType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "void",
    "signature": "public void addHeaders(ReactiveHttpOutputMessage message, Resource resource, @Nullable MediaType contentType, Map<String, Object> hints)",
    "source_code": "\tpublic void addHeaders(ReactiveHttpOutputMessage message, Resource resource, @Nullable MediaType contentType, Map<String, Object> hints) {\n\t\tHttpHeaders headers = message.getHeaders();\n\t\tMediaType resourceMediaType = getResourceMediaType(contentType, resource, hints);\n\t\theaders.setContentType(resourceMediaType);\n\n\t\tif (headers.getContentLength() < 0) {\n\t\t\tlong length = lengthOf(resource);\n\t\t\tif (length != -1) {\n\t\t\t\theaders.setContentLength(length);\n\t\t\t}\n\t\t}\n\t\tif (message instanceof ServerHttpResponse) {\n\t\t\t// server side\n\t\t\theaders.set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.<unknown>#canRead(elementType,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "boolean",
    "signature": "public boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\treturn this.decoder.canDecode(elementType, mediaType);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#canWrite(elementType,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "boolean",
    "signature": "public boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\treturn this.encoder.canEncode(elementType, mediaType);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#getReadHints(actualType,elementType,request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get additional hints for decoding for example based on the server request\n\t * or annotations from controller method parameters. By default, delegate to\n\t * the decoder if it is an instance of {@link HttpMessageDecoder}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "actualType",
      "elementType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "Object>",
    "signature": "protected Object> getReadHints(ResolvableType actualType,\n\t\t\tResolvableType elementType, ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected Map<String, Object> getReadHints(ResolvableType actualType,\n\t\t\tResolvableType elementType, ServerHttpRequest request, ServerHttpResponse response) {\n\n\t\tif (this.decoder instanceof HttpMessageDecoder<?> httpMessageDecoder) {\n\t\t\treturn httpMessageDecoder.getDecodeHints(actualType, elementType, request, response);\n\t\t}\n\t\treturn Hints.none();\n\t}"
  },
  "org.springframework.http.codec.<unknown>#getReadHints(elementType,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get additional hints for decoding based on the input HTTP message.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "elementType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "Object>",
    "signature": "protected Object> getReadHints(ResolvableType elementType, ReactiveHttpInputMessage message)",
    "source_code": "\tprotected Map<String, Object> getReadHints(ResolvableType elementType, ReactiveHttpInputMessage message) {\n\t\treturn Hints.none();\n\t}"
  },
  "org.springframework.http.codec.<unknown>#getWriteHints(streamType,elementType,mediaType,request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get additional hints for encoding for example based on the server request\n\t * or annotations from controller method parameters. By default, delegate to\n\t * the encoder if it is an instance of {@link HttpMessageEncoder}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "streamType",
      "elementType",
      "mediaType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "Object>",
    "signature": "protected Object> getWriteHints(ResolvableType streamType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected Map<String, Object> getWriteHints(ResolvableType streamType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response) {\n\n\t\tif (this.encoder instanceof HttpMessageEncoder<?> httpMessageEncoder) {\n\t\t\treturn httpMessageEncoder.getEncodeHints(streamType, elementType, mediaType, request, response);\n\t\t}\n\t\treturn Hints.none();\n\t}"
  },
  "org.springframework.http.codec.<unknown>#read(actualType,elementType,request,response,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "actualType",
      "elementType",
      "request",
      "response",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> read(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response, Map<String, Object> hints)",
    "source_code": "\tpublic Flux<T> read(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response, Map<String, Object> hints) {\n\n\t\tMap<String, Object> allHints = Hints.merge(hints,\n\t\t\t\tgetReadHints(actualType, elementType, request, response));\n\n\t\treturn read(elementType, request, allHints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#read(elementType,message,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {\n\t\tMediaType contentType = getContentType(message);\n\t\tMap<String, Object> allHints = Hints.merge(hints, getReadHints(elementType, message));\n\t\treturn this.decoder.decode(message.getBody(), elementType, contentType, allHints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#readMono(actualType,elementType,request,response,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "actualType",
      "elementType",
      "request",
      "response",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> readMono(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<T> readMono(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response, Map<String, Object> hints) {\n\n\t\tMap<String, Object> allHints = Hints.merge(hints,\n\t\t\t\tgetReadHints(actualType, elementType, request, response));\n\n\t\treturn readMono(elementType, request, allHints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#readMono(elementType,message,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {\n\t\tMediaType contentType = getContentType(message);\n\t\tMap<String, Object> allHints = Hints.merge(hints, getReadHints(elementType, message));\n\t\treturn this.decoder.decodeToMono(message.getBody(), elementType, contentType, allHints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#write(input,actualType,elementType,mediaType,request,response,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "actualType",
      "elementType",
      "mediaType",
      "request",
      "response",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<?> input, ResolvableType actualType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tMap<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<?> input, ResolvableType actualType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tMap<String, Object> hints) {\n\n\t\tMap<String, Object> allHints = Hints.merge(hints,\n\t\t\t\tgetEncodeHints(actualType, elementType, mediaType, request, response));\n\n\t\treturn write(input, elementType, mediaType, response, allHints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#write(input,elementType,mediaType,message,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "elementType",
      "mediaType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<?> input, ResolvableType elementType, @Nullable MediaType mediaType,\n\t\t\tReactiveHttpOutputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<?> input, ResolvableType elementType, @Nullable MediaType mediaType,\n\t\t\tReactiveHttpOutputMessage message, Map<String, Object> hints) {\n\n\t\tmediaType = (mediaType != null && mediaType.getCharset() != null ? mediaType : DEFAULT_MEDIA_TYPE);\n\t\tDataBufferFactory bufferFactory = message.bufferFactory();\n\n\t\tmessage.getHeaders().setContentType(mediaType);\n\t\treturn message.writeAndFlushWith(encode(input, elementType, mediaType, bufferFactory, hints));\n\t}"
  },
  "org.springframework.http.codec.<unknown>#write(inputStream,actualType,elementType,mediaType,request,response,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "actualType",
      "elementType",
      "mediaType",
      "request",
      "response",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<? extends T> inputStream, ResolvableType actualType,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ServerHttpRequest request,\n\t\t\tServerHttpResponse response, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<? extends T> inputStream, ResolvableType actualType,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ServerHttpRequest request,\n\t\t\tServerHttpResponse response, Map<String, Object> hints) {\n\n\t\tMap<String, Object> allHints = Hints.merge(hints,\n\t\t\t\tgetWriteHints(actualType, elementType, mediaType, request, response));\n\n\t\treturn write(inputStream, elementType, mediaType, response, allHints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#write(inputStream,elementType,mediaType,message,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "elementType",
      "mediaType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<? extends T> inputStream, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<? extends T> inputStream, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints) {\n\n\t\tMediaType contentType = updateContentType(message, mediaType);\n\n\t\tFlux<DataBuffer> body = this.encoder.encode(\n\t\t\t\tinputStream, message.bufferFactory(), elementType, contentType, hints);\n\n\t\tif (inputStream instanceof Mono) {\n\t\t\treturn body\n\t\t\t\t\t.singleOrEmpty()\n\t\t\t\t\t.switchIfEmpty(Mono.defer(() -> {\n\t\t\t\t\t\tmessage.getHeaders().setContentLength(0);\n\t\t\t\t\t\treturn message.setComplete().then(Mono.empty());\n\t\t\t\t\t}))\n\t\t\t\t\t.flatMap(buffer -> {\n\t\t\t\t\t\tHints.touchDataBuffer(buffer, hints, logger);\n\t\t\t\t\t\tmessage.getHeaders().setContentLength(buffer.readableByteCount());\n\t\t\t\t\t\treturn message.writeWith(Mono.just(buffer)\n\t\t\t\t\t\t\t\t.doOnDiscard(DataBuffer.class, DataBufferUtils::release));\n\t\t\t\t\t})\n\t\t\t\t\t.doOnDiscard(DataBuffer.class, DataBufferUtils::release);\n\t\t}\n\n\t\tif (isStreamingMediaType(contentType)) {\n\t\t\treturn message.writeAndFlushWith(body.map(buffer -> {\n\t\t\t\tHints.touchDataBuffer(buffer, hints, logger);\n\t\t\t\treturn Mono.just(buffer).doOnDiscard(DataBuffer.class, DataBufferUtils::release);\n\t\t\t}));\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tbody = body.doOnNext(buffer -> Hints.touchDataBuffer(buffer, hints, logger));\n\t\t}\n\t\treturn message.writeWith(body);\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#canDecode(elementType,mimeType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "boolean",
    "signature": "public boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\tObjectMapper mapper = selectObjectMapper(elementType, mimeType);\n\t\tif (mapper == null) {\n\t\t\treturn false;\n\t\t}\n\t\tJavaType javaType = mapper.constructType(elementType.getType());\n\t\t// Skip String: CharSequenceDecoder + \"*/*\" comes after\n\t\tif (CharSequence.class.isAssignableFrom(elementType.toClass()) || !supportsMimeType(mimeType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!logger.isDebugEnabled()) {\n\t\t\treturn mapper.canDeserialize(javaType);\n\t\t}\n\t\telse {\n\t\t\tAtomicReference<Throwable> causeRef = new AtomicReference<>();\n\t\t\tif (mapper.canDeserialize(javaType, causeRef)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tlogWarningIfNecessary(javaType, causeRef.get());\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#canEncode(elementType,mimeType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "boolean",
    "signature": "public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\tif (!supportsMimeType(mimeType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (mimeType != null && mimeType.getCharset() != null) {\n\t\t\tCharset charset = mimeType.getCharset();\n\t\t\tif (!ENCODINGS.containsKey(charset.name())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tObjectMapper mapper = selectObjectMapper(elementType, mimeType);\n\t\tif (mapper == null) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?> clazz = elementType.toClass();\n\t\tif (String.class.isAssignableFrom(elementType.resolve(clazz))) {\n\t\t\treturn false;\n\t\t}\n\t\tif (Object.class == clazz) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!logger.isDebugEnabled()) {\n\t\t\treturn mapper.canSerialize(clazz);\n\t\t}\n\t\telse {\n\t\t\tAtomicReference<Throwable> causeRef = new AtomicReference<>();\n\t\t\tif (mapper.canSerialize(clazz, causeRef)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tlogWarningIfNecessary(clazz, causeRef.get());\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#customizeReader(reader,elementType,Map<String,hints)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can use this method to customize {@link ObjectReader} used\n\t * for reading values.\n\t * @param reader the reader instance to customize\n\t * @param elementType the target type of element values to read to\n\t * @param hints a map with serialization hints;\n\t * the Reactor Context, when available, may be accessed under the key\n\t * {@code ContextView.class.getName()}\n\t * @return the customized {@code ObjectReader} to use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "reader",
      "elementType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "ObjectReader",
    "signature": "protected ObjectReader customizeReader(ObjectReader reader, ResolvableType elementType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected ObjectReader customizeReader(\n\t\t\tObjectReader reader, ResolvableType elementType, @Nullable Map<String, Object> hints) {\n\n\t\treturn reader;\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#customizeWriter(writer,mimeType,elementType,Map<String,hints)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can use this method to customize the {@link ObjectWriter} used\n\t * for writing values.\n\t * @param writer the writer instance to customize\n\t * @param mimeType the selected MIME type\n\t * @param elementType the type of element values to write\n\t * @param hints a map with serialization hints; the Reactor Context, when\n\t * available, may be accessed under the key\n\t * {@code ContextView.class.getName()}\n\t * @return the customized {@code ObjectWriter} to use\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "writer",
      "mimeType",
      "elementType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "ObjectWriter",
    "signature": "protected ObjectWriter customizeWriter(ObjectWriter writer, @Nullable MimeType mimeType,\n\t\t\tResolvableType elementType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected ObjectWriter customizeWriter(ObjectWriter writer, @Nullable MimeType mimeType,\n\t\t\tResolvableType elementType, @Nullable Map<String, Object> hints) {\n\n\t\treturn writer;\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#decode(dataBuffer,targetType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataBuffer",
      "targetType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "Object",
    "signature": "public Object decode(DataBuffer dataBuffer, ResolvableType targetType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Object decode(DataBuffer dataBuffer, ResolvableType targetType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) throws DecodingException {\n\n\t\tObjectMapper mapper = selectObjectMapper(targetType, mimeType);\n\t\tif (mapper == null) {\n\t\t\tthrow new IllegalStateException(\"No ObjectMapper for \" + targetType);\n\t\t}\n\n\t\ttry {\n\t\t\tObjectReader objectReader = createObjectReader(mapper, targetType, hints);\n\t\t\tObject value = objectReader.readValue(dataBuffer.asInputStream());\n\t\t\tlogValue(value, hints);\n\t\t\treturn value;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow processException(ex);\n\t\t}\n\t\tfinally {\n\t\t\tDataBufferUtils.release(dataBuffer);\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#decode(input,elementType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "Flux<Object>",
    "signature": "public Flux<Object> decode(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Flux<Object> decode(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tObjectMapper mapper = selectObjectMapper(elementType, mimeType);\n\t\tif (mapper == null) {\n\t\t\treturn Flux.error(new IllegalStateException(\"No ObjectMapper for \" + elementType));\n\t\t}\n\n\t\tboolean forceUseOfBigDecimal = mapper.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);\n\t\tif (BigDecimal.class.equals(elementType.getType())) {\n\t\t\tforceUseOfBigDecimal = true;\n\t\t}\n\n\t\tFlux<DataBuffer> processed = processInput(input, elementType, mimeType, hints);\n\t\tFlux<TokenBuffer> tokens = Jackson2Tokenizer.tokenize(processed, mapper.getFactory(), mapper,\n\t\t\t\ttrue, forceUseOfBigDecimal, getMaxInMemorySize());\n\n\t\treturn Flux.deferContextual(contextView -> {\n\n\t\t\tMap<String, Object> hintsToUse = contextView.isEmpty() ? hints :\n\t\t\t\t\tHints.merge(hints, ContextView.class.getName(), contextView);\n\n\t\t\tObjectReader reader = createObjectReader(mapper, elementType, hintsToUse);\n\n\t\t\treturn tokens.handle((tokenBuffer, sink) -> {\n\t\t\t\ttry {\n\t\t\t\t\tObject value = reader.readValue(tokenBuffer.asParser(mapper));\n\t\t\t\t\tlogValue(value, hints);\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\tsink.next(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\tsink.error(processException(ex));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#decodeToMono(input,elementType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "Mono<Object>",
    "signature": "public Mono<Object> decodeToMono(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Object> decodeToMono(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\treturn Mono.deferContextual(contextView -> {\n\n\t\t\tMap<String, Object> hintsToUse = contextView.isEmpty() ? hints :\n\t\t\t\t\tHints.merge(hints, ContextView.class.getName(), contextView);\n\n\t\t\treturn DataBufferUtils.join(input, this.maxInMemorySize).flatMap(dataBuffer ->\n\t\t\t\t\tMono.justOrEmpty(decode(dataBuffer, elementType, mimeType, hintsToUse)));\n\t\t});\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#encode(inputStream,bufferFactory,elementType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "bufferFactory",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> encode(Publisher<?> inputStream, DataBufferFactory bufferFactory,\n\t\t\tResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Flux<DataBuffer> encode(Publisher<?> inputStream, DataBufferFactory bufferFactory,\n\t\t\tResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tAssert.notNull(inputStream, \"'inputStream' must not be null\");\n\t\tAssert.notNull(bufferFactory, \"'bufferFactory' must not be null\");\n\t\tAssert.notNull(elementType, \"'elementType' must not be null\");\n\n\t\treturn Flux.deferContextual(contextView -> {\n\n\t\t\tMap<String, Object> hintsToUse = contextView.isEmpty() ? hints :\n\t\t\t\t\tHints.merge(hints, ContextView.class.getName(), contextView);\n\n\t\t\tif (inputStream instanceof Mono) {\n\t\t\t\treturn Mono.from(inputStream)\n\t\t\t\t\t\t.map(value -> encodeValue(value, bufferFactory, elementType, mimeType, hintsToUse))\n\t\t\t\t\t\t.flux();\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tObjectMapper mapper = selectObjectMapper(elementType, mimeType);\n\t\t\t\tif (mapper == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"No ObjectMapper for \" + elementType);\n\t\t\t\t}\n\n\t\t\t\tObjectWriter writer = createObjectWriter(mapper, elementType, mimeType, null, hintsToUse);\n\t\t\t\tByteArrayBuilder byteBuilder = new ByteArrayBuilder(writer.getFactory()._getBufferRecycler());\n\t\t\t\tJsonEncoding encoding = getJsonEncoding(mimeType);\n\t\t\t\tJsonGenerator generator = mapper.getFactory().createGenerator(byteBuilder, encoding);\n\t\t\t\tSequenceWriter sequenceWriter = writer.writeValues(generator);\n\n\t\t\t\tbyte[] separator = getStreamingMediaTypeSeparator(mimeType);\n\t\t\t\tFlux<DataBuffer> dataBufferFlux;\n\n\t\t\t\tif (separator != null) {\n\t\t\t\t\tdataBufferFlux = Flux.from(inputStream).map(value -> encodeStreamingValue(\n\t\t\t\t\t\t\tvalue, bufferFactory, hintsToUse, sequenceWriter, byteBuilder, EMPTY_BYTES, separator));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tJsonArrayJoinHelper helper = new JsonArrayJoinHelper();\n\n\t\t\t\t\t// Do not prepend JSON array prefix until first signal is known, onNext vs onError\n\t\t\t\t\t// Keeps response not committed for error handling\n\n\t\t\t\t\tdataBufferFlux = Flux.from(inputStream)\n\t\t\t\t\t\t\t.map(value -> {\n\t\t\t\t\t\t\t\tbyte[] prefix = helper.getPrefix();\n\t\t\t\t\t\t\t\tbyte[] delimiter = helper.getDelimiter();\n\n\t\t\t\t\t\t\t\tDataBuffer dataBuffer = encodeStreamingValue(\n\t\t\t\t\t\t\t\t\t\tvalue, bufferFactory, hintsToUse, sequenceWriter, byteBuilder,\n\t\t\t\t\t\t\t\t\t\tdelimiter, EMPTY_BYTES);\n\n\t\t\t\t\t\t\t\treturn (prefix.length > 0 ?\n\t\t\t\t\t\t\t\t\t\tbufferFactory.join(List.of(bufferFactory.wrap(prefix), dataBuffer)) :\n\t\t\t\t\t\t\t\t\t\tdataBuffer);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.switchIfEmpty(Mono.fromCallable(() -> bufferFactory.wrap(helper.getPrefix())))\n\t\t\t\t\t\t\t.concatWith(Mono.fromCallable(() -> bufferFactory.wrap(helper.getSuffix())));\n\t\t\t\t}\n\n\t\t\t\treturn dataBufferFlux\n\t\t\t\t\t\t.doOnNext(dataBuffer ->\tHints.touchDataBuffer(dataBuffer, hintsToUse, logger))\n\t\t\t\t\t\t.doAfterTerminate(() -> {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tbyteBuilder.release();\n\t\t\t\t\t\t\t\tgenerator.close();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t\t\t\tlogger.error(\"Could not close Encoder resources\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\treturn Flux.error(ex);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#encodeValue(value,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tClass<?> jsonView = null;\n\t\tFilterProvider filters = null;\n\t\tif (value instanceof MappingJacksonValue mappingJacksonValue) {\n\t\t\tvalue = mappingJacksonValue.getValue();\n\t\t\tvalueType = ResolvableType.forInstance(value);\n\t\t\tjsonView = mappingJacksonValue.getSerializationView();\n\t\t\tfilters = mappingJacksonValue.getFilters();\n\t\t}\n\n\t\tObjectMapper mapper = selectObjectMapper(valueType, mimeType);\n\t\tif (mapper == null) {\n\t\t\tthrow new IllegalStateException(\"No ObjectMapper for \" + valueType);\n\t\t}\n\n\t\tObjectWriter writer = createObjectWriter(mapper, valueType, mimeType, jsonView, hints);\n\t\tif (filters != null) {\n\t\t\twriter = writer.with(filters);\n\t\t}\n\n\t\tByteArrayBuilder byteBuilder = new ByteArrayBuilder(writer.getFactory()._getBufferRecycler());\n\t\ttry {\n\t\t\tJsonEncoding encoding = getJsonEncoding(mimeType);\n\n\t\t\tlogValue(hints, value);\n\n\t\t\ttry (JsonGenerator generator = mapper.getFactory().createGenerator(byteBuilder, encoding)) {\n\t\t\t\twriter.writeValue(generator, value);\n\t\t\t\tgenerator.flush();\n\t\t\t}\n\t\t\tcatch (InvalidDefinitionException ex) {\n\t\t\t\tthrow new CodecException(\"Type definition error: \" + ex.getType(), ex);\n\t\t\t}\n\t\t\tcatch (JsonProcessingException ex) {\n\t\t\t\tthrow new EncodingException(\"JSON encoding error: \" + ex.getOriginalMessage(), ex);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Unexpected I/O error while writing to byte array builder\", ex);\n\t\t\t}\n\n\t\t\tbyte[] bytes = byteBuilder.toByteArray();\n\t\t\tDataBuffer buffer = bufferFactory.allocateBuffer(bytes.length);\n\t\t\tbuffer.write(bytes);\n\t\t\tHints.touchDataBuffer(buffer, hints, logger);\n\n\t\t\treturn buffer;\n\t\t}\n\t\tfinally {\n\t\t\tbyteBuilder.release();\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#getAnnotation(parameter,annotType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "annotType"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "A",
    "signature": "protected A getAnnotation(MethodParameter parameter, Class<A> annotType)",
    "source_code": "\tprotected abstract <A extends Annotation> A getAnnotation(MethodParameter parameter, Class<A> annotType);"
  },
  "org.springframework.http.codec.json.<unknown>#getDecodeHints(actualType,elementType,request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "actualType",
      "elementType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "Object>",
    "signature": "public Object> getDecodeHints(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tpublic Map<String, Object> getDecodeHints(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response) {\n\n\t\treturn getHints(actualType);\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#getEncodeHints(actualType,elementType,mediaType,request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "actualType",
      "elementType",
      "mediaType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 419
    },
    "return": "Object>",
    "signature": "public Object> getEncodeHints(@Nullable ResolvableType actualType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tpublic Map<String, Object> getEncodeHints(@Nullable ResolvableType actualType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response) {\n\n\t\treturn (actualType != null ? getHints(actualType) : Hints.none());\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#getJavaType(type,contextClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "contextClass"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "JavaType",
    "signature": "protected JavaType getJavaType(Type type, @Nullable Class<?> contextClass)",
    "source_code": "\tprotected JavaType getJavaType(Type type, @Nullable Class<?> contextClass) {\n\t\treturn this.defaultObjectMapper.constructType(GenericTypeResolver.resolveType(type, contextClass));\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#logWarningIfNecessary(type,cause)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether to log the given exception coming from a\n\t * {@link ObjectMapper#canDeserialize} / {@link ObjectMapper#canSerialize} check.\n\t * @param type the class that Jackson tested for (de-)serializability\n\t * @param cause the Jackson-thrown exception to evaluate\n\t * (typically a {@link JsonMappingException})\n\t * @since 5.3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "void",
    "signature": "protected void logWarningIfNecessary(Type type, @Nullable Throwable cause)",
    "source_code": "\tprotected void logWarningIfNecessary(Type type, @Nullable Throwable cause) {\n\t\tif (cause == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tString msg = \"Failed to evaluate Jackson \" + (type instanceof JavaType ? \"de\" : \"\") +\n\t\t\t\t\t\"serialization for type [\" + type + \"]\";\n\t\t\tlogger.debug(msg, cause);\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#processInput(input,elementType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Process the input publisher into a flux. Default implementation returns\n\t * {@link Flux#from(Publisher)}, but subclasses can choose to customize\n\t * this behavior.\n\t * @param input the {@code DataBuffer} input stream to process\n\t * @param elementType the expected type of elements in the output stream\n\t * @param mimeType the MIME type associated with the input stream (optional)\n\t * @param hints additional information about how to do encode\n\t * @return the processed flux\n\t * @since 5.1.14\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "input",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "Flux<DataBuffer>",
    "signature": "protected Flux<DataBuffer> processInput(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected Flux<DataBuffer> processInput(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\treturn Flux.from(input);\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#registerObjectMappersForType(clazz,Consumer<Map<MimeType,registrar)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link ObjectMapper} instances to use for the given\n\t * {@link Class}. This is useful when you want to deviate from the\n\t * {@link #getObjectMapper() default} ObjectMapper or have the\n\t * {@code ObjectMapper} vary by {@code MediaType}.\n\t * <p><strong>Note:</strong> Use of this method effectively turns off use of\n\t * the default {@link #getObjectMapper() ObjectMapper} and supported\n\t * {@link #getMimeTypes() MimeTypes} for the given class. Therefore it is\n\t * important for the mappings configured here to\n\t * {@link MediaType#includes(MediaType) include} every MediaType that must\n\t * be supported for the given class.\n\t * @param clazz the type of Object to register ObjectMapper instances for\n\t * @param registrar a consumer to populate or otherwise update the\n\t * MediaType-to-ObjectMapper associations for the given Class\n\t * @since 5.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "Consumer<Map<MimeType",
      "registrar"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "void",
    "signature": "public void registerObjectMappersForType(Class<?> clazz, Consumer<Map<MimeType, ObjectMapper>> registrar)",
    "source_code": "\tpublic void registerObjectMappersForType(Class<?> clazz, Consumer<Map<MimeType, ObjectMapper>> registrar) {\n\t\tif (this.objectMapperRegistrations == null) {\n\t\t\tthis.objectMapperRegistrations = new LinkedHashMap<>();\n\t\t}\n\t\tMap<MimeType, ObjectMapper> registrations =\n\t\t\t\tthis.objectMapperRegistrations.computeIfAbsent(clazz, c -> new LinkedHashMap<>());\n\t\tregistrar.accept(registrations);\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#selectObjectMapper(targetType,targetMimeType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Select an ObjectMapper to use, either the main ObjectMapper or another\n\t * if the handling for the given Class has been customized through\n\t * {@link #registerObjectMappersForType(Class, Consumer)}.\n\t * @since 5.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetType",
      "targetMimeType"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "ObjectMapper",
    "signature": "protected ObjectMapper selectObjectMapper(ResolvableType targetType, @Nullable MimeType targetMimeType)",
    "source_code": "\tprotected ObjectMapper selectObjectMapper(ResolvableType targetType, @Nullable MimeType targetMimeType) {\n\t\tif (targetMimeType == null || CollectionUtils.isEmpty(this.objectMapperRegistrations)) {\n\t\t\treturn this.defaultObjectMapper;\n\t\t}\n\t\tClass<?> targetClass = targetType.toClass();\n\t\tfor (Map.Entry<Class<?>, Map<MimeType, ObjectMapper>> typeEntry : getObjectMapperRegistrations().entrySet()) {\n\t\t\tif (typeEntry.getKey().isAssignableFrom(targetClass)) {\n\t\t\t\tfor (Map.Entry<MimeType, ObjectMapper> objectMapperEntry : typeEntry.getValue().entrySet()) {\n\t\t\t\t\tif (objectMapperEntry.getKey().includes(targetMimeType)) {\n\t\t\t\t\t\treturn objectMapperEntry.getValue();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// No matching registrations\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t// No registrations\n\t\treturn this.defaultObjectMapper;\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#tokenize(dataBuffers,jsonFactory,objectMapper,tokenizeArrays,forceUseOfBigDecimal,maxInMemorySize)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Tokenize the given {@code Flux<DataBuffer>} into {@code Flux<TokenBuffer>}.\n\t * @param dataBuffers the source data buffers\n\t * @param jsonFactory the factory to use\n\t * @param objectMapper the current mapper instance\n\t * @param tokenizeArrays if {@code true} and the \"top level\" JSON object is\n\t * an array, each element is returned individually immediately after it is received\n\t * @param forceUseOfBigDecimal if {@code true}, any floating point values encountered\n\t * in source will use {@link java.math.BigDecimal}\n\t * @param maxInMemorySize maximum memory size\n\t * @return the resulting token buffers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataBuffers",
      "jsonFactory",
      "objectMapper",
      "tokenizeArrays",
      "forceUseOfBigDecimal",
      "maxInMemorySize"
    ],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "Flux<TokenBuffer>",
    "signature": "public Flux<TokenBuffer> tokenize(Flux<DataBuffer> dataBuffers, JsonFactory jsonFactory,\n\t\t\tObjectMapper objectMapper, boolean tokenizeArrays, boolean forceUseOfBigDecimal, int maxInMemorySize)",
    "source_code": "\tpublic static Flux<TokenBuffer> tokenize(Flux<DataBuffer> dataBuffers, JsonFactory jsonFactory,\n\t\t\tObjectMapper objectMapper, boolean tokenizeArrays, boolean forceUseOfBigDecimal, int maxInMemorySize) {\n\n\t\ttry {\n\t\t\tJsonParser parser;\n\t\t\tif (jsonFactory.getFormatName().equals(SmileFactory.FORMAT_NAME_SMILE)) {\n\t\t\t\t// ByteBufferFeeder is not supported for Smile\n\t\t\t\tparser = jsonFactory.createNonBlockingByteArrayParser();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparser = jsonFactory.createNonBlockingByteBufferParser();\n\t\t\t}\n\t\t\tDeserializationContext context = objectMapper.getDeserializationContext();\n\t\t\tif (context instanceof DefaultDeserializationContext) {\n\t\t\t\tcontext = ((DefaultDeserializationContext) context).createInstance(\n\t\t\t\t\t\tobjectMapper.getDeserializationConfig(), parser, objectMapper.getInjectableValues());\n\t\t\t}\n\t\t\tJackson2Tokenizer tokenizer =\n\t\t\t\t\tnew Jackson2Tokenizer(parser, context, tokenizeArrays, forceUseOfBigDecimal, maxInMemorySize);\n\t\t\treturn dataBuffers.concatMapIterable(tokenizer::tokenize).concatWith(tokenizer.endOfInput());\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\treturn Flux.error(ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#canRead(elementType,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "boolean",
    "signature": "public boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\tif (MULTIPART_VALUE_TYPE.isAssignableFrom(elementType)) {\n\t\t\tif (mediaType == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (MediaType supportedMediaType : MIME_TYPES) {\n\t\t\t\tif (supportedMediaType.isCompatibleWith(mediaType)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#canWrite(elementType,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "boolean",
    "signature": "public boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\tif (Part.class.isAssignableFrom(elementType.toClass())) {\n\t\t\tif (mediaType == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (MediaType supportedMediaType : getWritableMediaTypes()) {\n\t\t\t\tif (supportedMediaType.isCompatibleWith(mediaType)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#read(elementType,message,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "Part>>",
    "signature": "public Part>> read(ResolvableType elementType,\n\t\t\tReactiveHttpInputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Flux<MultiValueMap<String, Part>> read(ResolvableType elementType,\n\t\t\tReactiveHttpInputMessage message, Map<String, Object> hints) {\n\n\t\treturn Flux.from(readMono(elementType, message, hints));\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#readMono(elementType,inputMessage,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "inputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Part>>",
    "signature": "public Part>> readMono(ResolvableType elementType,\n\t\t\tReactiveHttpInputMessage inputMessage, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<MultiValueMap<String, Part>> readMono(ResolvableType elementType,\n\t\t\tReactiveHttpInputMessage inputMessage, Map<String, Object> hints) {\n\n\n\t\tMap<String, Object> allHints = Hints.merge(hints, Hints.SUPPRESS_LOGGING_HINT, true);\n\n\t\treturn this.partReader.read(elementType, inputMessage, allHints)\n\t\t\t\t.collectMultimap(Part::name)\n\t\t\t\t.doOnNext(map ->\n\t\t\t\t\tLogFormatUtils.traceDebug(logger, traceOn -> Hints.getLogPrefix(hints) + \"Parsed \" +\n\t\t\t\t\t\t\t(isEnableLoggingRequestDetails() ?\n\t\t\t\t\t\t\t\t\tLogFormatUtils.formatValue(map, !traceOn) :\n\t\t\t\t\t\t\t\t\t\"parts \" + map.keySet() + \" (content masked)\"))\n\t\t\t\t)\n\t\t\t\t.map(this::toMultiValueMap);\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#write(parts,elementType,mediaType,outputMessage,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parts",
      "elementType",
      "mediaType",
      "outputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<? extends Part> parts,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ReactiveHttpOutputMessage outputMessage,\n\t\t\tMap<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<? extends Part> parts,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ReactiveHttpOutputMessage outputMessage,\n\t\t\tMap<String, Object> hints) {\n\n\t\tbyte[] boundary = generateMultipartBoundary();\n\n\t\tmediaType = getMultipartMediaType(mediaType, boundary);\n\t\toutputMessage.getHeaders().setContentType(mediaType);\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(Hints.getLogPrefix(hints) + \"Encoding Publisher<Part>\");\n\t\t}\n\n\t\tFlux<DataBuffer> body = Flux.from(parts)\n\t\t\t\t.concatMap(part -> encodePart(boundary, part, outputMessage.bufferFactory()))\n\t\t\t\t.concatWith(generateLastLine(boundary, outputMessage.bufferFactory()))\n\t\t\t\t.doOnDiscard(DataBuffer.class, DataBufferUtils::release);\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tbody = body.doOnNext(buffer -> Hints.touchDataBuffer(buffer, hints, logger));\n\t\t}\n\n\t\treturn outputMessage.writeWith(body);\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#addCodec(codecs,codec)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize a codec and add it to the List.\n\t * @since 5.1.13\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "codecs",
      "codec"
    ],
    "position": {
      "column": 1,
      "line": 466
    },
    "return": "void",
    "signature": "protected void addCodec(List<T> codecs, T codec)",
    "source_code": "\tprotected <T> void addCodec(List<T> codecs, T codec) {\n\t\tinitCodec(codec);\n\t\tcodecs.add(codec);\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#registerWithDefaultConfig(codec,configConsumer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codec",
      "configConsumer"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void registerWithDefaultConfig(Object codec, Consumer<DefaultCodecConfig> configConsumer)",
    "source_code": "\t\tpublic void registerWithDefaultConfig(Object codec, Consumer<DefaultCodecConfig> configConsumer) {\n\t\t\taddCodec(codec, false);\n\t\t\tthis.defaultConfigConsumers.add(configConsumer);\n\t\t}"
  },
  "org.springframework.http.converter.<unknown>#addDefaultHeaders(headers,t,contentType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add default headers to the output message.\n\t * <p>This implementation delegates to {@link #getDefaultContentType(Object)} if a\n\t * content type was not provided, set if necessary the default character set, calls\n\t * {@link #getContentLength}, and sets the corresponding headers.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headers",
      "t",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "void",
    "signature": "protected void addDefaultHeaders(HttpHeaders headers, T t, @Nullable MediaType contentType)",
    "source_code": "\tprotected void addDefaultHeaders(HttpHeaders headers, T t, @Nullable MediaType contentType) throws IOException {\n\t\tif (headers.getContentType() == null) {\n\t\t\tMediaType contentTypeToUse = contentType;\n\t\t\tif (contentType == null || !contentType.isConcrete()) {\n\t\t\t\tcontentTypeToUse = getDefaultContentType(t);\n\t\t\t}\n\t\t\telse if (MediaType.APPLICATION_OCTET_STREAM.equals(contentType)) {\n\t\t\t\tMediaType mediaType = getDefaultContentType(t);\n\t\t\t\tcontentTypeToUse = (mediaType != null ? mediaType : contentTypeToUse);\n\t\t\t}\n\t\t\tif (contentTypeToUse != null) {\n\t\t\t\tif (contentTypeToUse.getCharset() == null) {\n\t\t\t\t\tCharset defaultCharset = getDefaultCharset();\n\t\t\t\t\tif (defaultCharset != null) {\n\t\t\t\t\t\tcontentTypeToUse = new MediaType(contentTypeToUse, defaultCharset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\theaders.setContentType(contentTypeToUse);\n\t\t\t}\n\t\t}\n\t\tif (headers.getContentLength() < 0 && !headers.containsKey(HttpHeaders.TRANSFER_ENCODING)) {\n\t\t\tLong contentLength = getContentLength(t, headers.getContentType());\n\t\t\tif (contentLength != null) {\n\t\t\t\theaders.setContentLength(contentLength);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#canRead(clazz,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "boolean",
    "signature": "public boolean canRead(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.<unknown>#canRead(type,contextClass,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "contextClass",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "boolean",
    "signature": "public boolean canRead(Type type, @Nullable Class<?> contextClass, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(Type type, @Nullable Class<?> contextClass, @Nullable MediaType mediaType) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.<unknown>#canWrite(clazz,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "boolean",
    "signature": "public boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn canWrite(clazz, null, mediaType);\n\t}"
  },
  "org.springframework.http.converter.<unknown>#canWrite(type,clazz,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "boolean",
    "signature": "public boolean canWrite(@Nullable Type type, @Nullable Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(@Nullable Type type, @Nullable Class<?> clazz, @Nullable MediaType mediaType) {\n\t\tif (!(type instanceof ParameterizedType parameterizedType)) {\n\t\t\treturn (type instanceof Class<?> c && ResourceRegion.class.isAssignableFrom(c));\n\t\t}\n\t\tif (!(parameterizedType.getRawType() instanceof Class<?> rawType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(Collection.class.isAssignableFrom(rawType))) {\n\t\t\treturn false;\n\t\t}\n\t\tif (parameterizedType.getActualTypeArguments().length != 1) {\n\t\t\treturn false;\n\t\t}\n\t\tType typeArgument = parameterizedType.getActualTypeArguments()[0];\n\t\tif (!(typeArgument instanceof Class<?> typeArgumentClass)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn ResourceRegion.class.isAssignableFrom(typeArgumentClass);\n\t}"
  },
  "org.springframework.http.converter.<unknown>#getContentLength(t,contentType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the content length for the given type.\n\t * <p>By default, this returns {@code null}, meaning that the content length is unknown.\n\t * Can be overridden in subclasses.\n\t * @param t the type to return the content length for\n\t * @return the content length, or {@code null} if not known\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "Long",
    "signature": "protected Long getContentLength(T t, @Nullable MediaType contentType)",
    "source_code": "\tprotected Long getContentLength(T t, @Nullable MediaType contentType) throws IOException {\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.converter.<unknown>#read(MultiValueMap<String,clazz,inputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "String>",
    "signature": "public String> read(@Nullable Class<? extends MultiValueMap<String, ?>> clazz,\n\t\t\tHttpInputMessage inputMessage)",
    "source_code": "\tpublic MultiValueMap<String, String> read(@Nullable Class<? extends MultiValueMap<String, ?>> clazz,\n\t\t\tHttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {\n\n\t\tMediaType contentType = inputMessage.getHeaders().getContentType();\n\t\tCharset charset = (contentType != null && contentType.getCharset() != null ?\n\t\t\t\tcontentType.getCharset() : this.charset);\n\t\tString body = StreamUtils.copyToString(inputMessage.getBody(), charset);\n\n\t\tString[] pairs = StringUtils.tokenizeToStringArray(body, \"&\");\n\t\tMultiValueMap<String, String> result = new LinkedMultiValueMap<>(pairs.length);\n\t\tfor (String pair : pairs) {\n\t\t\tint idx = pair.indexOf('=');\n\t\t\tif (idx == -1) {\n\t\t\t\tresult.add(URLDecoder.decode(pair, charset), null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString name = URLDecoder.decode(pair.substring(0, idx), charset);\n\t\t\t\tString value = URLDecoder.decode(pair.substring(idx + 1), charset);\n\t\t\t\tresult.add(name, value);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.http.converter.<unknown>#read(clazz,inputMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation simple delegates to {@link #readInternal(Class, HttpInputMessage)}.\n\t * Future implementations might add some default behavior, however.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "T",
    "signature": "public T read(Class<? extends T> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tpublic final T read(Class<? extends T> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\treturn readInternal(clazz, inputMessage);\n\t}"
  },
  "org.springframework.http.converter.<unknown>#read(type,contextClass,inputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "contextClass",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "Object",
    "signature": "public Object read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)",
    "source_code": "\tpublic Object read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.http.converter.<unknown>#readInternal(clazz,inputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "ResourceRegion",
    "signature": "protected ResourceRegion readInternal(Class<?> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tprotected ResourceRegion readInternal(Class<?> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.http.converter.<unknown>#serializeForm(MultiValueMap<String,formData,charset)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "MultiValueMap<String",
      "formData",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "String",
    "signature": "protected String serializeForm(MultiValueMap<String, Object> formData, Charset charset)",
    "source_code": "\tprotected String serializeForm(MultiValueMap<String, Object> formData, Charset charset) {\n\t\tStringBuilder builder = new StringBuilder();\n\t\tformData.forEach((name, values) -> {\n\t\t\t\tif (name == null) {\n\t\t\t\t\tAssert.isTrue(CollectionUtils.isEmpty(values), () -> \"Null name in form data: \" + formData);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvalues.forEach(value -> {\n\t\t\t\t\tif (builder.length() != 0) {\n\t\t\t\t\t\tbuilder.append('&');\n\t\t\t\t\t}\n\t\t\t\t\tbuilder.append(URLEncoder.encode(name, charset));\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\tbuilder.append('=');\n\t\t\t\t\t\tbuilder.append(URLEncoder.encode(String.valueOf(value), charset));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t});\n\n\t\treturn builder.toString();\n\t}"
  },
  "org.springframework.http.converter.<unknown>#write(MultiValueMap<String,map,contentType,outputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "map",
      "contentType",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "void",
    "signature": "public void write(MultiValueMap<String, ?> map, @Nullable MediaType contentType, HttpOutputMessage outputMessage)",
    "source_code": "\tpublic void write(MultiValueMap<String, ?> map, @Nullable MediaType contentType, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tif (isMultipart(map, contentType)) {\n\t\t\twriteMultipart((MultiValueMap<String, Object>) map, contentType, outputMessage);\n\t\t}\n\t\telse {\n\t\t\twriteForm((MultiValueMap<String, Object>) map, contentType, outputMessage);\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#write(image,contentType,outputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "image",
      "contentType",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void write(final BufferedImage image, @Nullable final MediaType contentType,\n\t\t\tfinal HttpOutputMessage outputMessage)",
    "source_code": "\tpublic void write(final BufferedImage image, @Nullable final MediaType contentType,\n\t\t\tfinal HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tfinal MediaType selectedContentType = getContentType(contentType);\n\t\toutputMessage.getHeaders().setContentType(selectedContentType);\n\n\t\tif (outputMessage instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\tstreamingOutputMessage.setBody(outputStream -> writeInternal(image, selectedContentType, outputStream));\n\t\t}\n\t\telse {\n\t\t\twriteInternal(image, selectedContentType, outputMessage.getBody());\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#write(t,contentType,outputMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation sets the default headers by calling {@link #addDefaultHeaders},\n\t * and then calls {@link #writeInternal}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t",
      "contentType",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void write(final T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage)",
    "source_code": "\tpublic final void write(final T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tfinal HttpHeaders headers = outputMessage.getHeaders();\n\t\taddDefaultHeaders(headers, t, contentType);\n\n\t\tif (outputMessage instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\tstreamingOutputMessage.setBody(outputStream -> writeInternal(t, new HttpOutputMessage() {\n\t\t\t\t@Override\n\t\t\t\tpublic OutputStream getBody() {\n\t\t\t\t\treturn outputStream;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\t\treturn headers;\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t\telse {\n\t\t\twriteInternal(t, outputMessage);\n\t\t\toutputMessage.getBody().flush();\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#write(t,type,contentType,outputMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation sets the default headers by calling {@link #addDefaultHeaders},\n\t * and then calls {@link #writeInternal}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t",
      "type",
      "contentType",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void write(final T t, @Nullable final Type type, @Nullable MediaType contentType,\n\t\t\tHttpOutputMessage outputMessage)",
    "source_code": "\tpublic final void write(final T t, @Nullable final Type type, @Nullable MediaType contentType,\n\t\t\tHttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {\n\n\t\tfinal HttpHeaders headers = outputMessage.getHeaders();\n\t\taddDefaultHeaders(headers, t, contentType);\n\n\t\tif (outputMessage instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\tstreamingOutputMessage.setBody(outputStream -> writeInternal(t, type, new HttpOutputMessage() {\n\t\t\t\t@Override\n\t\t\t\tpublic OutputStream getBody() {\n\t\t\t\t\treturn outputStream;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\t\treturn headers;\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t\telse {\n\t\t\twriteInternal(t, type, outputMessage);\n\t\t\toutputMessage.getBody().flush();\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#writeInternal(object,type,outputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "type",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "protected void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage)",
    "source_code": "\tprotected void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tif (object instanceof ResourceRegion resourceRegion) {\n\t\t\twriteResourceRegion(resourceRegion, outputMessage);\n\t\t}\n\t\telse {\n\t\t\tCollection<ResourceRegion> regions = (Collection<ResourceRegion>) object;\n\t\t\tif (regions.size() == 1) {\n\t\t\t\twriteResourceRegion(regions.iterator().next(), outputMessage);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twriteResourceRegionCollection(regions, outputMessage);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#writeInternal(t,outputMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method that writes the actual body. Invoked from {@link #write}.\n\t * @param t the object to write to the output message\n\t * @param outputMessage the HTTP output message to write to\n\t * @throws IOException in case of I/O errors\n\t * @throws HttpMessageNotWritableException in case of conversion errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "void",
    "signature": "protected void writeInternal(T t, HttpOutputMessage outputMessage)",
    "source_code": "\tprotected abstract void writeInternal(T t, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException;\n\n}"
  },
  "org.springframework.http.converter.<unknown>#writeInternal(t,type,outputMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method that writes the actual body. Invoked from {@link #write}.\n\t * @param t the object to write to the output message\n\t * @param type the type of object to write (may be {@code null})\n\t * @param outputMessage the HTTP output message to write to\n\t * @throws IOException in case of I/O errors\n\t * @throws HttpMessageNotWritableException in case of conversion errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "type",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "protected void writeInternal(T t, @Nullable Type type, HttpOutputMessage outputMessage)",
    "source_code": "\tprotected abstract void writeInternal(T t, @Nullable Type type, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException;\n\n}"
  },
  "org.springframework.http.converter.<unknown>#writeResourceRegion(region,outputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "region",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "protected void writeResourceRegion(ResourceRegion region, HttpOutputMessage outputMessage)",
    "source_code": "\tprotected void writeResourceRegion(ResourceRegion region, HttpOutputMessage outputMessage) throws IOException {\n\t\tAssert.notNull(region, \"ResourceRegion must not be null\");\n\t\tHttpHeaders responseHeaders = outputMessage.getHeaders();\n\n\t\tlong start = region.getPosition();\n\t\tlong end = start + region.getCount() - 1;\n\t\tlong resourceLength = region.getResource().contentLength();\n\t\tend = Math.min(end, resourceLength - 1);\n\t\tlong rangeLength = end - start + 1;\n\t\tresponseHeaders.add(\"Content-Range\", \"bytes \" + start + '-' + end + '/' + resourceLength);\n\t\tresponseHeaders.setContentLength(rangeLength);\n\n\t\tInputStream in = region.getResource().getInputStream();\n\t\t// We cannot use try-with-resources here for the InputStream, since we have\n\t\t// custom handling of the close() method in a finally-block.\n\t\ttry {\n\t\t\tStreamUtils.copyRange(in, outputMessage.getBody(), start, end);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tin.close();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#annotationIntrospector(Function<AnnotationIntrospector,pairingFunction)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Alternative to {@link #annotationIntrospector(AnnotationIntrospector)}\n\t * that allows combining with rather than replacing the currently set\n\t * introspector, e.g. via\n\t * {@link AnnotationIntrospectorPair#pair(AnnotationIntrospector, AnnotationIntrospector)}.\n\t * @param pairingFunction a function to apply to the currently set\n\t * introspector (possibly {@code null}); the result of the function becomes\n\t * the new introspector.\n\t * @since 5.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<AnnotationIntrospector",
      "pairingFunction"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder annotationIntrospector(Function<AnnotationIntrospector, AnnotationIntrospector> pairingFunction)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder annotationIntrospector(\n\t\t\tFunction<AnnotationIntrospector, AnnotationIntrospector> pairingFunction) {\n\n\t\tthis.annotationIntrospector = pairingFunction.apply(this.annotationIntrospector);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#canRead(clazz,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "boolean",
    "signature": "public boolean canRead(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn canRead(clazz, null, mediaType);\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#canRead(type,contextClass,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "contextClass",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 253
    },
    "return": "boolean",
    "signature": "public boolean canRead(Type type, @Nullable Class<?> contextClass, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(Type type, @Nullable Class<?> contextClass, @Nullable MediaType mediaType) {\n\t\tif (!canRead(mediaType)) {\n\t\t\treturn false;\n\t\t}\n\t\tJavaType javaType = getJavaType(type, contextClass);\n\t\tObjectMapper objectMapper = selectObjectMapper(javaType.getRawClass(), mediaType);\n\t\tif (objectMapper == null) {\n\t\t\treturn false;\n\t\t}\n\t\tAtomicReference<Throwable> causeRef = new AtomicReference<>();\n\t\tif (objectMapper.canDeserialize(javaType, causeRef)) {\n\t\t\treturn true;\n\t\t}\n\t\tlogWarningIfNecessary(javaType, causeRef.get());\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#canWrite(clazz,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "boolean",
    "signature": "public boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\tif (!canWrite(mediaType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (mediaType != null && mediaType.getCharset() != null) {\n\t\t\tCharset charset = mediaType.getCharset();\n\t\t\tif (!ENCODINGS.containsKey(charset.name())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tObjectMapper objectMapper = selectObjectMapper(clazz, mediaType);\n\t\tif (objectMapper == null) {\n\t\t\treturn false;\n\t\t}\n\t\tAtomicReference<Throwable> causeRef = new AtomicReference<>();\n\t\tif (objectMapper.canSerialize(clazz, causeRef)) {\n\t\t\treturn true;\n\t\t}\n\t\tlogWarningIfNecessary(clazz, causeRef.get());\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#create(defaultUseWrapper,factory)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultUseWrapper",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 935
    },
    "return": "ObjectMapper",
    "signature": "public ObjectMapper create(boolean defaultUseWrapper, @Nullable JsonFactory factory)",
    "source_code": "\t\tpublic ObjectMapper create(boolean defaultUseWrapper, @Nullable JsonFactory factory) {\n\t\t\tJacksonXmlModule module = new JacksonXmlModule();\n\t\t\tmodule.setDefaultUseWrapper(defaultUseWrapper);\n\t\t\tif (factory != null) {\n\t\t\t\treturn new XmlMapper((XmlFactory) factory, module);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new XmlMapper(new XmlFactory(StaxUtils.createDefensiveInputFactory()), module);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.converter.json.<unknown>#customizeReader(reader,javaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can use this method to customize {@link ObjectReader} used\n\t * for reading values.\n\t * @param reader the reader instance to customize\n\t * @param javaType the target type of element values to read to\n\t * @return the customized {@link ObjectReader}\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "reader",
      "javaType"
    ],
    "position": {
      "column": 1,
      "line": 418
    },
    "return": "ObjectReader",
    "signature": "protected ObjectReader customizeReader(ObjectReader reader, JavaType javaType)",
    "source_code": "\tprotected ObjectReader customizeReader(ObjectReader reader, JavaType javaType) {\n\t\treturn reader;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#customizeWriter(writer,javaType,contentType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can use this method to customize {@link ObjectWriter} used\n\t * for writing values.\n\t * @param writer the writer instance to customize\n\t * @param javaType the type of element values to write\n\t * @param contentType the selected media type\n\t * @return the customized {@link ObjectWriter}\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "writer",
      "javaType",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 505
    },
    "return": "ObjectWriter",
    "signature": "protected ObjectWriter customizeWriter(ObjectWriter writer, @Nullable JavaType javaType, @Nullable MediaType contentType)",
    "source_code": "\tprotected ObjectWriter customizeWriter(\n\t\t\tObjectWriter writer, @Nullable JavaType javaType, @Nullable MediaType contentType) {\n\n\t\treturn writer;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#deserializerByType(type,deserializer)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a custom deserializer for the given type.\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "deserializer"
    ],
    "position": {
      "column": 1,
      "line": 407
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder deserializerByType(Class<?> type, JsonDeserializer<?> deserializer)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder deserializerByType(Class<?> type, JsonDeserializer<?> deserializer) {\n\t\tthis.deserializers.put(type, deserializer);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#deserializersByType(Map<Class<?>,deserializers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure custom deserializers for the given types.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "deserializers"
    ],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder deserializersByType(Map<Class<?>, JsonDeserializer<?>> deserializers)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder deserializersByType(Map<Class<?>, JsonDeserializer<?>> deserializers) {\n\t\tthis.deserializers.putAll(deserializers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#getContentLength(object,contentType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 564
    },
    "return": "Long",
    "signature": "protected Long getContentLength(Object object, @Nullable MediaType contentType)",
    "source_code": "\tprotected Long getContentLength(Object object, @Nullable MediaType contentType) throws IOException {\n\t\tif (object instanceof MappingJacksonValue mappingJacksonValue) {\n\t\t\tobject = mappingJacksonValue.getValue();\n\t\t}\n\t\treturn super.getContentLength(object, contentType);\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#getJavaType(type,contextClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Jackson {@link JavaType} for the specified type and context class.\n\t * @param type the generic type to return the Jackson JavaType for\n\t * @param contextClass a context class for the target type, for example a class\n\t * in which the target type appears in a method signature (can be {@code null})\n\t * @return the Jackson JavaType\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "contextClass"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "JavaType",
    "signature": "protected JavaType getJavaType(Type type, @Nullable Class<?> contextClass)",
    "source_code": "\tprotected JavaType getJavaType(Type type, @Nullable Class<?> contextClass) {\n\t\treturn this.defaultObjectMapper.constructType(GenericTypeResolver.resolveType(type, contextClass));\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#logWarningIfNecessary(type,cause)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether to log the given exception coming from a\n\t * {@link ObjectMapper#canDeserialize} / {@link ObjectMapper#canSerialize} check.\n\t * @param type the class that Jackson tested for (de-)serializability\n\t * @param cause the Jackson-thrown exception to evaluate\n\t * (typically a {@link JsonMappingException})\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "void",
    "signature": "protected void logWarningIfNecessary(Type type, @Nullable Throwable cause)",
    "source_code": "\tprotected void logWarningIfNecessary(Type type, @Nullable Throwable cause) {\n\t\tif (cause == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Do not log warning for serializer not found (note: different message wording on Jackson 2.9)\n\t\tboolean debugLevel = (cause instanceof JsonMappingException && cause.getMessage().startsWith(\"Cannot find\"));\n\n\t\tif (debugLevel ? logger.isDebugEnabled() : logger.isWarnEnabled()) {\n\t\t\tString msg = \"Failed to evaluate Jackson \" + (type instanceof JavaType ? \"de\" : \"\") +\n\t\t\t\t\t\"serialization for type [\" + type + \"]\";\n\t\t\tif (debugLevel) {\n\t\t\t\tlogger.debug(msg, cause);\n\t\t\t}\n\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\tlogger.warn(msg, cause);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.warn(msg + \": \" + cause);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#mixIn(target,mixinSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add mix-in annotations to use for augmenting specified class or interface.\n\t * @param target class (or interface) whose annotations to effectively override\n\t * @param mixinSource class (or interface) whose annotations are to be \"added\"\n\t * to target's annotations as value\n\t * @since 4.1.2\n\t * @see com.fasterxml.jackson.databind.ObjectMapper#addMixIn(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "mixinSource"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder mixIn(Class<?> target, Class<?> mixinSource)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder mixIn(Class<?> target, Class<?> mixinSource) {\n\t\tthis.mixIns.put(target, mixinSource);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#mixIns(Map<Class<?>,mixIns)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add mix-in annotations to use for augmenting specified class or interface.\n\t * @param mixIns a Map of entries with target classes (or interface) whose annotations\n\t * to effectively override as key and mix-in classes (or interface) whose\n\t * annotations are to be \"added\" to target's annotations as value.\n\t * @since 4.1.2\n\t * @see com.fasterxml.jackson.databind.ObjectMapper#addMixIn(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "mixIns"
    ],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder mixIns(Map<Class<?>, Class<?>> mixIns)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder mixIns(Map<Class<?>, Class<?>> mixIns) {\n\t\tthis.mixIns.putAll(mixIns);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#read(type,contextClass,inputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "contextClass",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 350
    },
    "return": "Object",
    "signature": "public Object read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)",
    "source_code": "\tpublic Object read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tJavaType javaType = getJavaType(type, contextClass);\n\t\treturn readJavaType(javaType, inputMessage);\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#readInternal(clazz,inputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 358
    },
    "return": "Object",
    "signature": "protected Object readInternal(Class<?> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tprotected Object readInternal(Class<?> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tJavaType javaType = getJavaType(clazz, null);\n\t\treturn readJavaType(javaType, inputMessage);\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#registerObjectMappersForType(clazz,Consumer<Map<MediaType,registrar)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link ObjectMapper} instances to use for the given\n\t * {@link Class}. This is useful when you want to deviate from the\n\t * {@link #getObjectMapper() default} ObjectMapper or have the\n\t * {@code ObjectMapper} vary by {@code MediaType}.\n\t * <p><strong>Note:</strong> Use of this method effectively turns off use of\n\t * the default {@link #getObjectMapper() ObjectMapper} and\n\t * {@link #setSupportedMediaTypes(List) supportedMediaTypes} for the given\n\t * class. Therefore it is important for the mappings configured here to\n\t * {@link MediaType#includes(MediaType) include} every MediaType that must\n\t * be supported for the given class.\n\t * @param clazz the type of Object to register ObjectMapper instances for\n\t * @param registrar a consumer to populate or otherwise update the\n\t * MediaType-to-ObjectMapper associations for the given Class\n\t * @since 5.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "Consumer<Map<MediaType",
      "registrar"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "void",
    "signature": "public void registerObjectMappersForType(Class<?> clazz, Consumer<Map<MediaType, ObjectMapper>> registrar)",
    "source_code": "\tpublic void registerObjectMappersForType(Class<?> clazz, Consumer<Map<MediaType, ObjectMapper>> registrar) {\n\t\tif (this.objectMapperRegistrations == null) {\n\t\t\tthis.objectMapperRegistrations = new LinkedHashMap<>();\n\t\t}\n\t\tMap<MediaType, ObjectMapper> registrations =\n\t\t\t\tthis.objectMapperRegistrations.computeIfAbsent(clazz, c -> new LinkedHashMap<>());\n\t\tregistrar.accept(registrations);\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#serializerByType(type,serializer)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a custom serializer for the given type.\n\t * @since 4.1.2\n\t * @see #serializers(JsonSerializer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "serializer"
    ],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder serializerByType(Class<?> type, JsonSerializer<?> serializer)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder serializerByType(Class<?> type, JsonSerializer<?> serializer) {\n\t\tthis.serializers.put(type, serializer);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#serializersByType(Map<Class<?>,serializers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure custom serializers for the given types.\n\t * @see #serializers(JsonSerializer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "serializers"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder serializersByType(Map<Class<?>, JsonSerializer<?>> serializers)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder serializersByType(Map<Class<?>, JsonSerializer<?>> serializers) {\n\t\tthis.serializers.putAll(serializers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#visibility(accessor,visibility)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify visibility to limit what kind of properties are auto-detected.\n\t * @since 5.1\n\t * @see com.fasterxml.jackson.annotation.PropertyAccessor\n\t * @see com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "accessor",
      "visibility"
    ],
    "position": {
      "column": 1,
      "line": 488
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder visibility(PropertyAccessor accessor, JsonAutoDetect.Visibility visibility)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder visibility(PropertyAccessor accessor, JsonAutoDetect.Visibility visibility) {\n\t\tthis.visibilities.put(accessor, visibility);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#writeInternal(object,type,outputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "type",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 440
    },
    "return": "void",
    "signature": "protected void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage)",
    "source_code": "\tprotected void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n\t\tJsonEncoding encoding = getJsonEncoding(contentType);\n\n\t\tClass<?> clazz = (object instanceof MappingJacksonValue mappingJacksonValue ?\n\t\t\t\tmappingJacksonValue.getValue().getClass() : object.getClass());\n\t\tObjectMapper objectMapper = selectObjectMapper(clazz, contentType);\n\t\tAssert.state(objectMapper != null, () -> \"No ObjectMapper for \" + clazz.getName());\n\n\t\tOutputStream outputStream = StreamUtils.nonClosing(outputMessage.getBody());\n\t\ttry (JsonGenerator generator = objectMapper.getFactory().createGenerator(outputStream, encoding)) {\n\t\t\twritePrefix(generator, object);\n\n\t\t\tObject value = object;\n\t\t\tClass<?> serializationView = null;\n\t\t\tFilterProvider filters = null;\n\t\t\tJavaType javaType = null;\n\n\t\t\tif (object instanceof MappingJacksonValue mappingJacksonValue) {\n\t\t\t\tvalue = mappingJacksonValue.getValue();\n\t\t\t\tserializationView = mappingJacksonValue.getSerializationView();\n\t\t\t\tfilters = mappingJacksonValue.getFilters();\n\t\t\t}\n\t\t\tif (type != null && TypeUtils.isAssignable(type, value.getClass())) {\n\t\t\t\tjavaType = getJavaType(type, null);\n\t\t\t}\n\n\t\t\tObjectWriter objectWriter = (serializationView != null ?\n\t\t\t\t\tobjectMapper.writerWithView(serializationView) : objectMapper.writer());\n\t\t\tif (filters != null) {\n\t\t\t\tobjectWriter = objectWriter.with(filters);\n\t\t\t}\n\t\t\tif (javaType != null && (javaType.isContainerType() || javaType.isTypeOrSubTypeOf(Optional.class))) {\n\t\t\t\tobjectWriter = objectWriter.forType(javaType);\n\t\t\t}\n\t\t\tSerializationConfig config = objectWriter.getConfig();\n\t\t\tif (contentType != null && contentType.isCompatibleWith(MediaType.TEXT_EVENT_STREAM) &&\n\t\t\t\t\tconfig.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n\t\t\t\tobjectWriter = objectWriter.with(this.ssePrettyPrinter);\n\t\t\t}\n\t\t\tobjectWriter = customizeWriter(objectWriter, javaType, contentType);\n\t\t\tobjectWriter.writeValue(generator, value);\n\n\t\t\twriteSuffix(generator, object);\n\t\t\tgenerator.flush();\n\t\t}\n\t\tcatch (InvalidDefinitionException ex) {\n\t\t\tthrow new HttpMessageConversionException(\"Type definition error: \" + ex.getType(), ex);\n\t\t}\n\t\tcatch (JsonProcessingException ex) {\n\t\t\tthrow new HttpMessageNotWritableException(\"Could not write JSON: \" + ex.getOriginalMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#writePrefix(generator,object)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write a prefix before the main content.\n\t * @param generator the generator to use for writing content.\n\t * @param object the object to write to the output message.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "generator",
      "object"
    ],
    "position": {
      "column": 1,
      "line": 516
    },
    "return": "void",
    "signature": "protected void writePrefix(JsonGenerator generator, Object object)",
    "source_code": "\tprotected void writePrefix(JsonGenerator generator, Object object) throws IOException {\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#writeSuffix(generator,object)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write a suffix after the main content.\n\t * @param generator the generator to use for writing content.\n\t * @param object the object to write to the output message.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "generator",
      "object"
    ],
    "position": {
      "column": 1,
      "line": 524
    },
    "return": "void",
    "signature": "protected void writeSuffix(JsonGenerator generator, Object object)",
    "source_code": "\tprotected void writeSuffix(JsonGenerator generator, Object object) throws IOException {\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#canRead(clazz,mediaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Always returns {@code false} since Jaxb2CollectionHttpMessageConverter\n\t * required generic type information in order to read a Collection.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "boolean",
    "signature": "public boolean canRead(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#canRead(type,contextClass,mediaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>Jaxb2CollectionHttpMessageConverter can read a generic\n\t * {@link Collection} where the generic type is a JAXB type annotated with\n\t * {@link XmlRootElement} or {@link XmlType}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "contextClass",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "boolean",
    "signature": "public boolean canRead(Type type, @Nullable Class<?> contextClass, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(Type type, @Nullable Class<?> contextClass, @Nullable MediaType mediaType) {\n\t\tif (!(type instanceof ParameterizedType parameterizedType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(parameterizedType.getRawType() instanceof Class<?> rawType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(Collection.class.isAssignableFrom(rawType))) {\n\t\t\treturn false;\n\t\t}\n\t\tif (parameterizedType.getActualTypeArguments().length != 1) {\n\t\t\treturn false;\n\t\t}\n\t\tType typeArgument = parameterizedType.getActualTypeArguments()[0];\n\t\tif (!(typeArgument instanceof Class<?> typeArgumentClass)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (typeArgumentClass.isAnnotationPresent(XmlRootElement.class) ||\n\t\t\t\ttypeArgumentClass.isAnnotationPresent(XmlType.class)) && canRead(mediaType);\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#canWrite(clazz,mediaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Always returns {@code false} since Jaxb2CollectionHttpMessageConverter\n\t * does not convert collections to XML.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "boolean",
    "signature": "public boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#canWrite(type,clazz,mediaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Always returns {@code false} since Jaxb2CollectionHttpMessageConverter\n\t * does not convert collections to XML.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "boolean",
    "signature": "public boolean canWrite(@Nullable Type type, @Nullable Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(@Nullable Type type, @Nullable Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#read(type,contextClass,inputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "contextClass",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "T",
    "signature": "public T read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)",
    "source_code": "\tpublic T read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tParameterizedType parameterizedType = (ParameterizedType) type;\n\t\tT result = createCollection((Class<?>) parameterizedType.getRawType());\n\t\tClass<?> elementClass = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n\n\t\ttry {\n\t\t\tUnmarshaller unmarshaller = createUnmarshaller(elementClass);\n\t\t\tXMLStreamReader streamReader = this.inputFactory.createXMLStreamReader(inputMessage.getBody());\n\t\t\tint event = moveToFirstChildOfRootElement(streamReader);\n\n\t\t\twhile (event != XMLStreamReader.END_DOCUMENT) {\n\t\t\t\tif (elementClass.isAnnotationPresent(XmlRootElement.class)) {\n\t\t\t\t\tresult.add(unmarshaller.unmarshal(streamReader));\n\t\t\t\t}\n\t\t\t\telse if (elementClass.isAnnotationPresent(XmlType.class)) {\n\t\t\t\t\tresult.add(unmarshaller.unmarshal(streamReader, elementClass).getValue());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// should not happen, since we check in canRead(Type)\n\t\t\t\t\tthrow new HttpMessageNotReadableException(\n\t\t\t\t\t\t\t\"Cannot unmarshal to [\" + elementClass + \"]\", inputMessage);\n\t\t\t\t}\n\t\t\t\tevent = moveToNextElement(streamReader);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tcatch (XMLStreamException ex) {\n\t\t\tthrow new HttpMessageNotReadableException(\n\t\t\t\t\t\"Failed to read XML stream: \" + ex.getMessage(), ex, inputMessage);\n\t\t}\n\t\tcatch (UnmarshalException ex) {\n\t\t\tthrow new HttpMessageNotReadableException(\n\t\t\t\t\t\"Could not unmarshal to [\" + elementClass + \"]: \" + ex, ex, inputMessage);\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow new HttpMessageConversionException(\"Invalid JAXB setup: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#readFromSource(clazz,headers,source)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "headers",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "T",
    "signature": "protected T readFromSource(Class<? extends T> clazz, HttpHeaders headers, Source source)",
    "source_code": "\tprotected T readFromSource(Class<? extends T> clazz, HttpHeaders headers, Source source) throws Exception {\n\t\t// should not be called, since we return false for canRead(Class)\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#write(t,type,contentType,outputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t",
      "type",
      "contentType",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "void",
    "signature": "public void write(T t, @Nullable Type type, @Nullable MediaType contentType, HttpOutputMessage outputMessage)",
    "source_code": "\tpublic void write(T t, @Nullable Type type, @Nullable MediaType contentType, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#writeToResult(o,headers,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "o",
      "headers",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "void",
    "signature": "protected void writeToResult(Object o, HttpHeaders headers, Result result)",
    "source_code": "\tprotected void writeToResult(Object o, HttpHeaders headers, Result result) throws Exception {\n\t\ttry {\n\t\t\tClass<?> clazz = ClassUtils.getUserClass(o);\n\t\t\tMarshaller marshaller = createMarshaller(clazz);\n\t\t\tsetCharset(headers.getContentType(), marshaller);\n\t\t\tmarshaller.marshal(o, result);\n\t\t}\n\t\tcatch (MarshalException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow new HttpMessageConversionException(\"Invalid JAXB setup: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#writeToResult(t,headers,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "headers",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "void",
    "signature": "protected void writeToResult(T t, HttpHeaders headers, Result result)",
    "source_code": "\tprotected void writeToResult(T t, HttpHeaders headers, Result result) throws Exception {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#add(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tthis.headers.addValue(key).setString(value);\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#addAll(MultiValueMap<String,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#addAll(key,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#createRequest(request,asyncContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "asyncContext"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "ServletServerHttpRequest",
    "signature": "protected ServletServerHttpRequest createRequest(HttpServletRequest request, AsyncContext asyncContext)",
    "source_code": "\tprotected ServletServerHttpRequest createRequest(HttpServletRequest request, AsyncContext asyncContext)\n\t\t\tthrows IOException, URISyntaxException {\n\n\t\tAssert.state(getServletPath() != null, \"Servlet path is not initialized\");\n\t\treturn new TomcatServerHttpRequest(\n\t\t\t\trequest, asyncContext, getServletPath(), getDataBufferFactory(), getBufferSize());\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#createRequest(request,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "ServletServerHttpRequest",
    "signature": "protected ServletServerHttpRequest createRequest(HttpServletRequest request, AsyncContext context)",
    "source_code": "\tprotected ServletServerHttpRequest createRequest(HttpServletRequest request, AsyncContext context)\n\t\t\tthrows IOException, URISyntaxException {\n\n\t\tif (jetty11Present) {\n\t\t\tAssert.state(getServletPath() != null, \"Servlet path is not initialized\");\n\t\t\treturn new Jetty11ServerHttpRequest(\n\t\t\t\t\trequest, context, getServletPath(), getDataBufferFactory(), getBufferSize());\n\t\t}\n\t\telse {\n\t\t\treturn super.createRequest(request, context);\n\t\t}\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#createResponse(response,asyncContext,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "asyncContext",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "ServletServerHttpResponse",
    "signature": "protected ServletServerHttpResponse createResponse(HttpServletResponse response,\n\t\t\tAsyncContext asyncContext, ServletServerHttpRequest request)",
    "source_code": "\tprotected ServletServerHttpResponse createResponse(HttpServletResponse response,\n\t\t\tAsyncContext asyncContext, ServletServerHttpRequest request) throws IOException {\n\n\t\treturn new TomcatServerHttpResponse(\n\t\t\t\tresponse, asyncContext, getDataBufferFactory(), getBufferSize(), request);\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#createResponse(response,context,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "context",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "ServletServerHttpResponse",
    "signature": "protected ServletServerHttpResponse createResponse(HttpServletResponse response,\n\t\t\tAsyncContext context, ServletServerHttpRequest request)",
    "source_code": "\tprotected ServletServerHttpResponse createResponse(HttpServletResponse response,\n\t\t\tAsyncContext context, ServletServerHttpRequest request) throws IOException {\n\n\t\tif (jetty11Present) {\n\t\t\treturn new Jetty11ServerHttpResponse(\n\t\t\t\t\tresponse, context, getDataBufferFactory(), getBufferSize(), request);\n\t\t}\n\t\t/* Jetty 12: see spring-web.gradle\n\t\telse if (jetty12Present) {\n\t\t\treturn new Jetty12ServerHttpResponse(\n\t\t\t\t\tresponse, context, getDataBufferFactory(), getBufferSize(), request);\n\t\t}\n\t\t*/\n\t\telse {\n\t\t\treturn super.createResponse(response, context, request);\n\t\t}\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\tList<String> previousValues = get(key);\n\t\tthis.headers.removeHeader(key);\n\t\tvalue.forEach(v -> this.headers.addValue(key).setString(v));\n\t\treturn previousValues;\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#putAll(String,map)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#set(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tthis.headers.setValue(key).setString(value);\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#setAll(Map<String,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#writeWith(file,position,count)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "file",
      "position",
      "count"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> writeWith(Path file, long position, long count)",
    "source_code": "\tpublic Mono<Void> writeWith(Path file, long position, long count) {\n\t\treturn doCommit(() -> this.response.sendFile(file, position, count).then());\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#batchUpdate(sql,batchArgs)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "batchArgs"
    ],
    "position": {
      "column": 1,
      "line": 1077
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, List<Object[]> batchArgs)",
    "source_code": "\tpublic int[] batchUpdate(String sql, List<Object[]> batchArgs) throws DataAccessException {\n\t\treturn batchUpdate(sql, batchArgs, new int[0]);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#batchUpdate(sql,batchArgs,argTypes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "batchArgs",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 1082
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, List<Object[]> batchArgs, final int[] argTypes)",
    "source_code": "\tpublic int[] batchUpdate(String sql, List<Object[]> batchArgs, final int[] argTypes) throws DataAccessException {\n\t\tif (batchArgs.isEmpty()) {\n\t\t\treturn new int[0];\n\t\t}\n\n\t\treturn batchUpdate(\n\t\t\t\tsql,\n\t\t\t\tnew BatchPreparedStatementSetter() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n\t\t\t\t\t\tObject[] values = batchArgs.get(i);\n\t\t\t\t\t\tint colIndex = 0;\n\t\t\t\t\t\tfor (Object value : values) {\n\t\t\t\t\t\t\tcolIndex++;\n\t\t\t\t\t\t\tif (value instanceof SqlParameterValue paramValue) {\n\t\t\t\t\t\t\t\tStatementCreatorUtils.setParameterValue(ps, colIndex, paramValue, paramValue.getValue());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tint colType;\n\t\t\t\t\t\t\t\tif (argTypes.length < colIndex) {\n\t\t\t\t\t\t\t\t\tcolType = SqlTypeValue.TYPE_UNKNOWN;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tcolType = argTypes[colIndex - 1];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tStatementCreatorUtils.setParameterValue(ps, colIndex, colType, value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int getBatchSize() {\n\t\t\t\t\t\treturn batchArgs.size();\n\t\t\t\t\t}\n\t\t\t\t});\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#batchUpdate(sql,batchArgs,batchSize,pss)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "batchArgs",
      "batchSize",
      "pss"
    ],
    "position": {
      "column": 1,
      "line": 1119
    },
    "return": "int[][]",
    "signature": "public int[][] batchUpdate(String sql, final Collection<T> batchArgs, final int batchSize,\n\t\t\tfinal ParameterizedPreparedStatementSetter<T> pss)",
    "source_code": "\tpublic <T> int[][] batchUpdate(String sql, final Collection<T> batchArgs, final int batchSize,\n\t\t\tfinal ParameterizedPreparedStatementSetter<T> pss) throws DataAccessException {\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Executing SQL batch update [\" + sql + \"] with a batch size of \" + batchSize);\n\t\t}\n\t\tint[][] result = execute(sql, (PreparedStatementCallback<int[][]>) ps -> {\n\t\t\tList<int[]> rowsAffected = new ArrayList<>();\n\t\t\ttry {\n\t\t\t\tboolean batchSupported = JdbcUtils.supportsBatchUpdates(ps.getConnection());\n\t\t\t\tint n = 0;\n\t\t\t\tfor (T obj : batchArgs) {\n\t\t\t\t\tpss.setValues(ps, obj);\n\t\t\t\t\tn++;\n\t\t\t\t\tif (batchSupported) {\n\t\t\t\t\t\tps.addBatch();\n\t\t\t\t\t\tif (n % batchSize == 0 || n == batchArgs.size()) {\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tint batchIdx = (n % batchSize == 0) ? n / batchSize : (n / batchSize) + 1;\n\t\t\t\t\t\t\t\tint items = n - ((n % batchSize == 0) ? n / batchSize - 1 : (n / batchSize)) * batchSize;\n\t\t\t\t\t\t\t\tlogger.trace(\"Sending SQL batch update #\" + batchIdx + \" with \" + items + \" items\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trowsAffected.add(ps.executeBatch());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint i = ps.executeUpdate();\n\t\t\t\t\t\trowsAffected.add(new int[] {i});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint[][] result1 = new int[rowsAffected.size()][];\n\t\t\t\tfor (int i = 0; i < result1.length; i++) {\n\t\t\t\t\tresult1[i] = rowsAffected.get(i);\n\t\t\t\t}\n\t\t\t\treturn result1;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (pss instanceof ParameterDisposer parameterDisposer) {\n\t\t\t\t\tparameterDisposer.cleanupParameters();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tAssert.state(result != null, \"No result array\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#batchUpdate(sql,pss)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "pss"
    ],
    "position": {
      "column": 1,
      "line": 1029
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, final BatchPreparedStatementSetter pss)",
    "source_code": "\tpublic int[] batchUpdate(String sql, final BatchPreparedStatementSetter pss) throws DataAccessException {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Executing SQL batch update [\" + sql + \"]\");\n\t\t}\n\n\t\tint[] result = execute(sql, (PreparedStatementCallback<int[]>) ps -> {\n\t\t\ttry {\n\t\t\t\tint batchSize = pss.getBatchSize();\n\t\t\t\tInterruptibleBatchPreparedStatementSetter ipss =\n\t\t\t\t\t\t(pss instanceof InterruptibleBatchPreparedStatementSetter ibpss ? ibpss : null);\n\t\t\t\tif (JdbcUtils.supportsBatchUpdates(ps.getConnection())) {\n\t\t\t\t\tfor (int i = 0; i < batchSize; i++) {\n\t\t\t\t\t\tpss.setValues(ps, i);\n\t\t\t\t\t\tif (ipss != null && ipss.isBatchExhausted(i)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tps.addBatch();\n\t\t\t\t\t}\n\t\t\t\t\treturn ps.executeBatch();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tList<Integer> rowsAffected = new ArrayList<>();\n\t\t\t\t\tfor (int i = 0; i < batchSize; i++) {\n\t\t\t\t\t\tpss.setValues(ps, i);\n\t\t\t\t\t\tif (ipss != null && ipss.isBatchExhausted(i)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trowsAffected.add(ps.executeUpdate());\n\t\t\t\t\t}\n\t\t\t\t\tint[] rowsAffectedArray = new int[rowsAffected.size()];\n\t\t\t\t\tfor (int i = 0; i < rowsAffectedArray.length; i++) {\n\t\t\t\t\t\trowsAffectedArray[i] = rowsAffected.get(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn rowsAffectedArray;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (pss instanceof ParameterDisposer parameterDisposer) {\n\t\t\t\t\tparameterDisposer.cleanupParameters();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tAssert.state(result != null, \"No result array\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#call(csc,declaredParameters)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "csc",
      "declaredParameters"
    ],
    "position": {
      "column": 1,
      "line": 1222
    },
    "return": "Object>",
    "signature": "public Object> call(CallableStatementCreator csc, List<SqlParameter> declaredParameters)",
    "source_code": "\tpublic Map<String, Object> call(CallableStatementCreator csc, List<SqlParameter> declaredParameters)\n\t\t\tthrows DataAccessException {\n\n\t\tfinal List<SqlParameter> updateCountParameters = new ArrayList<>();\n\t\tfinal List<SqlParameter> resultSetParameters = new ArrayList<>();\n\t\tfinal List<SqlParameter> callParameters = new ArrayList<>();\n\n\t\tfor (SqlParameter parameter : declaredParameters) {\n\t\t\tif (parameter.isResultsParameter()) {\n\t\t\t\tif (parameter instanceof SqlReturnResultSet) {\n\t\t\t\t\tresultSetParameters.add(parameter);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tupdateCountParameters.add(parameter);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcallParameters.add(parameter);\n\t\t\t}\n\t\t}\n\n\t\tMap<String, Object> result = execute(csc, cs -> {\n\t\t\tboolean retVal = cs.execute();\n\t\t\tint updateCount = cs.getUpdateCount();\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"CallableStatement.execute() returned '\" + retVal + \"'\");\n\t\t\t\tlogger.trace(\"CallableStatement.getUpdateCount() returned \" + updateCount);\n\t\t\t}\n\t\t\tMap<String, Object> resultsMap = createResultsMap();\n\t\t\tif (retVal || updateCount != -1) {\n\t\t\t\tresultsMap.putAll(extractReturnedResults(cs, updateCountParameters, resultSetParameters, updateCount));\n\t\t\t}\n\t\t\tresultsMap.putAll(extractOutputParameters(cs, callParameters));\n\t\t\treturn resultsMap;\n\t\t});\n\n\t\tAssert.state(result != null, \"No result map\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#constructMappedInstance(rs,tc)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Construct an instance of the mapped class for the current row.\n\t * @param rs the ResultSet to map (pre-initialized for the current row)\n\t * @param tc a TypeConverter with this RowMapper's conversion service\n\t * @return a corresponding instance of the mapped class\n\t * @throws SQLException if an SQLException is encountered\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "tc"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "T",
    "signature": "protected T constructMappedInstance(ResultSet rs, TypeConverter tc)",
    "source_code": "\tprotected T constructMappedInstance(ResultSet rs, TypeConverter tc) throws SQLException  {\n\t\tAssert.state(this.mappedClass != null, \"Mapped class was not specified\");\n\t\treturn BeanUtils.instantiateClass(this.mappedClass);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#convertValueToRequiredType(value,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given column value to the specified required type.\n\t * Only called if the extracted column value does not match already.\n\t * <p>If the required type is String, the value will simply get stringified\n\t * via {@code toString()}. In case of a Number, the value will be\n\t * converted into a Number, either through number conversion or through\n\t * String parsing (depending on the value type). Otherwise, the value will\n\t * be converted to a required type using the {@link ConversionService}.\n\t * @param value the column value as extracted from {@code getColumnValue()}\n\t * (never {@code null})\n\t * @param requiredType the type that each result object is expected to match\n\t * (never {@code null})\n\t * @return the converted value\n\t * @see #getColumnValue(java.sql.ResultSet, int, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "Object",
    "signature": "protected Object convertValueToRequiredType(Object value, Class<?> requiredType)",
    "source_code": "\tprotected Object convertValueToRequiredType(Object value, Class<?> requiredType) {\n\t\tif (String.class == requiredType) {\n\t\t\treturn value.toString();\n\t\t}\n\t\telse if (Number.class.isAssignableFrom(requiredType)) {\n\t\t\tif (value instanceof Number number) {\n\t\t\t\t// Convert original Number to target Number class.\n\t\t\t\treturn NumberUtils.convertNumberToTargetClass(number, (Class<Number>) requiredType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Convert stringified value to target Number class.\n\t\t\t\treturn NumberUtils.parseNumber(value.toString(),(Class<Number>) requiredType);\n\t\t\t}\n\t\t}\n\t\telse if (this.conversionService != null && this.conversionService.canConvert(value.getClass(), requiredType)) {\n\t\t\treturn this.conversionService.convert(value, requiredType);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Value [\" + value + \"] is of type [\" + value.getClass().getName() +\n\t\t\t\t\t\"] and cannot be converted to required type [\" + requiredType.getName() + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#doSetValue(ps,parameterPosition,argType,argValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for the prepared statement's specified parameter position using the passed in\n\t * value and type. This method can be overridden by subclasses if needed.\n\t * @param ps the PreparedStatement\n\t * @param parameterPosition index of the parameter position\n\t * @param argType the argument type\n\t * @param argValue the argument value\n\t * @throws SQLException if thrown by PreparedStatement methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ps",
      "parameterPosition",
      "argType",
      "argValue"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "void",
    "signature": "protected void doSetValue(PreparedStatement ps, int parameterPosition, int argType, Object argValue)",
    "source_code": "\tprotected void doSetValue(PreparedStatement ps, int parameterPosition, int argType, Object argValue)\n\t\t\tthrows SQLException {\n\n\t\tStatementCreatorUtils.setParameterValue(ps, parameterPosition, argType, argValue);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#doSetValue(ps,parameterPosition,argValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for prepared statements specified parameter index using the passed in value.\n\t * This method can be overridden by subclasses if needed.\n\t * @param ps the PreparedStatement\n\t * @param parameterPosition index of the parameter position\n\t * @param argValue the value to set\n\t * @throws SQLException if thrown by PreparedStatement methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ps",
      "parameterPosition",
      "argValue"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "void",
    "signature": "protected void doSetValue(PreparedStatement ps, int parameterPosition, Object argValue)",
    "source_code": "\tprotected void doSetValue(PreparedStatement ps, int parameterPosition, Object argValue) throws SQLException {\n\t\tif (argValue instanceof SqlParameterValue paramValue) {\n\t\t\tStatementCreatorUtils.setParameterValue(ps, parameterPosition, paramValue, paramValue.getValue());\n\t\t}\n\t\telse {\n\t\t\tStatementCreatorUtils.setParameterValue(ps, parameterPosition, SqlTypeValue.TYPE_UNKNOWN, argValue);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#execute(callString,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callString",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1217
    },
    "return": "T",
    "signature": "public T execute(String callString, CallableStatementCallback<T> action)",
    "source_code": "\tpublic <T> T execute(String callString, CallableStatementCallback<T> action) throws DataAccessException {\n\t\treturn execute(new SimpleCallableStatementCreator(callString), action);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#execute(csc,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "csc",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1173
    },
    "return": "T",
    "signature": "public T execute(CallableStatementCreator csc, CallableStatementCallback<T> action)",
    "source_code": "\tpublic <T> T execute(CallableStatementCreator csc, CallableStatementCallback<T> action)\n\t\t\tthrows DataAccessException {\n\n\t\tAssert.notNull(csc, \"CallableStatementCreator must not be null\");\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tString sql = getSql(csc);\n\t\t\tlogger.debug(\"Calling stored procedure\" + (sql != null ? \" [\" + sql  + \"]\" : \"\"));\n\t\t}\n\n\t\tConnection con = DataSourceUtils.getConnection(obtainDataSource());\n\t\tCallableStatement cs = null;\n\t\ttry {\n\t\t\tcs = csc.createCallableStatement(con);\n\t\t\tapplyStatementSettings(cs);\n\t\t\tT result = action.doInCallableStatement(cs);\n\t\t\thandleWarnings(cs);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\t// Release Connection early, to avoid potential connection pool deadlock\n\t\t\t// in the case when the exception translator hasn't been initialized yet.\n\t\t\tif (csc instanceof ParameterDisposer parameterDisposer) {\n\t\t\t\tparameterDisposer.cleanupParameters();\n\t\t\t}\n\t\t\tString sql = getSql(csc);\n\t\t\tcsc = null;\n\t\t\tJdbcUtils.closeStatement(cs);\n\t\t\tcs = null;\n\t\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t\t\tcon = null;\n\t\t\tthrow translateException(\"CallableStatementCallback\", sql, ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (csc instanceof ParameterDisposer parameterDisposer) {\n\t\t\t\tparameterDisposer.cleanupParameters();\n\t\t\t}\n\t\t\tJdbcUtils.closeStatement(cs);\n\t\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#execute(psc,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 682
    },
    "return": "T",
    "signature": "public T execute(PreparedStatementCreator psc, PreparedStatementCallback<T> action)",
    "source_code": "\tpublic <T> T execute(PreparedStatementCreator psc, PreparedStatementCallback<T> action)\n\t\t\tthrows DataAccessException {\n\n\t\treturn execute(psc, action, true);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#execute(sql,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "T",
    "signature": "public T execute(String sql, PreparedStatementCallback<T> action)",
    "source_code": "\tpublic <T> T execute(String sql, PreparedStatementCallback<T> action) throws DataAccessException {\n\t\treturn execute(new SimplePreparedStatementCreator(sql), action, true);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#extractOutputParameters(cs,parameters)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extract output parameters from the completed stored procedure.\n\t * @param cs the JDBC wrapper for the stored procedure\n\t * @param parameters parameter list for the stored procedure\n\t * @return a Map that contains returned results\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cs",
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 1332
    },
    "return": "Object>",
    "signature": "protected Object> extractOutputParameters(CallableStatement cs, List<SqlParameter> parameters)",
    "source_code": "\tprotected Map<String, Object> extractOutputParameters(CallableStatement cs, List<SqlParameter> parameters)\n\t\t\tthrows SQLException {\n\n\t\tMap<String, Object> results = CollectionUtils.newLinkedHashMap(parameters.size());\n\t\tint sqlColIndex = 1;\n\t\tfor (SqlParameter param : parameters) {\n\t\t\tif (param instanceof SqlOutParameter outParam) {\n\t\t\t\tAssert.state(outParam.getName() != null, \"Anonymous parameters not allowed\");\n\t\t\t\tSqlReturnType returnType = outParam.getSqlReturnType();\n\t\t\t\tif (returnType != null) {\n\t\t\t\t\tObject out = returnType.getTypeValue(cs, sqlColIndex, outParam.getSqlType(), outParam.getTypeName());\n\t\t\t\t\tresults.put(outParam.getName(), out);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tObject out = cs.getObject(sqlColIndex);\n\t\t\t\t\tif (out instanceof ResultSet resultSet) {\n\t\t\t\t\t\tif (outParam.isResultSetSupported()) {\n\t\t\t\t\t\t\tresults.putAll(processResultSet(resultSet, outParam));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tString rsName = outParam.getName();\n\t\t\t\t\t\t\tSqlReturnResultSet rsParam = new SqlReturnResultSet(rsName, getColumnMapRowMapper());\n\t\t\t\t\t\t\tresults.putAll(processResultSet(resultSet, rsParam));\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"Added default SqlReturnResultSet parameter named '\" + rsName + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresults.put(outParam.getName(), out);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(param.isResultsParameter())) {\n\t\t\t\tsqlColIndex++;\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#extractReturnedResults(cs,updateCountParameters,resultSetParameters,updateCount)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extract returned ResultSets from the completed stored procedure.\n\t * @param cs a JDBC wrapper for the stored procedure\n\t * @param updateCountParameters the parameter list of declared update count parameters for the stored procedure\n\t * @param resultSetParameters the parameter list of declared resultSet parameters for the stored procedure\n\t * @return a Map that contains returned results\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cs",
      "updateCountParameters",
      "resultSetParameters",
      "updateCount"
    ],
    "position": {
      "column": 1,
      "line": 1269
    },
    "return": "Object>",
    "signature": "protected Object> extractReturnedResults(CallableStatement cs,\n\t\t\t@Nullable List<SqlParameter> updateCountParameters, @Nullable List<SqlParameter> resultSetParameters,\n\t\t\tint updateCount)",
    "source_code": "\tprotected Map<String, Object> extractReturnedResults(CallableStatement cs,\n\t\t\t@Nullable List<SqlParameter> updateCountParameters, @Nullable List<SqlParameter> resultSetParameters,\n\t\t\tint updateCount) throws SQLException {\n\n\t\tMap<String, Object> results = new LinkedHashMap<>(4);\n\t\tint rsIndex = 0;\n\t\tint updateIndex = 0;\n\t\tboolean moreResults;\n\t\tif (!this.skipResultsProcessing) {\n\t\t\tdo {\n\t\t\t\tif (updateCount == -1) {\n\t\t\t\t\tif (resultSetParameters != null && resultSetParameters.size() > rsIndex) {\n\t\t\t\t\t\tSqlReturnResultSet declaredRsParam = (SqlReturnResultSet) resultSetParameters.get(rsIndex);\n\t\t\t\t\t\tresults.putAll(processResultSet(cs.getResultSet(), declaredRsParam));\n\t\t\t\t\t\trsIndex++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!this.skipUndeclaredResults) {\n\t\t\t\t\t\t\tString rsName = RETURN_RESULT_SET_PREFIX + (rsIndex + 1);\n\t\t\t\t\t\t\tSqlReturnResultSet undeclaredRsParam = new SqlReturnResultSet(rsName, getColumnMapRowMapper());\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"Added default SqlReturnResultSet parameter named '\" + rsName + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresults.putAll(processResultSet(cs.getResultSet(), undeclaredRsParam));\n\t\t\t\t\t\t\trsIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (updateCountParameters != null && updateCountParameters.size() > updateIndex) {\n\t\t\t\t\t\tSqlReturnUpdateCount ucParam = (SqlReturnUpdateCount) updateCountParameters.get(updateIndex);\n\t\t\t\t\t\tString declaredUcName = ucParam.getName();\n\t\t\t\t\t\tresults.put(declaredUcName, updateCount);\n\t\t\t\t\t\tupdateIndex++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!this.skipUndeclaredResults) {\n\t\t\t\t\t\t\tString undeclaredName = RETURN_UPDATE_COUNT_PREFIX + (updateIndex + 1);\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"Added default SqlReturnUpdateCount parameter named '\" + undeclaredName + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresults.put(undeclaredName, updateCount);\n\t\t\t\t\t\t\tupdateIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmoreResults = cs.getMoreResults();\n\t\t\t\tupdateCount = cs.getUpdateCount();\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"CallableStatement.getUpdateCount() returned \" + updateCount);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (moreResults || updateCount != -1);\n\t\t}\n\t\treturn results;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#getColumnValue(rs,index)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC object value for the specified column, using the most\n\t * appropriate value type. Called if no required type has been specified.\n\t * <p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},\n\t * which uses the {@code ResultSet.getObject(index)} method. Additionally,\n\t * it includes a \"hack\" to get around Oracle returning a non-standard object for\n\t * their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}\n\t * javadoc for details.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @return the Object value\n\t * @throws SQLException in case of extraction failure\n\t * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "index"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "Object",
    "signature": "protected Object getColumnValue(ResultSet rs, int index)",
    "source_code": "\tprotected Object getColumnValue(ResultSet rs, int index) throws SQLException {\n\t\treturn JdbcUtils.getResultSetValue(rs, index);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#getColumnValue(rs,index,paramType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC object value for the specified column.\n\t * <p>The default implementation calls\n\t * {@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}.\n\t * Subclasses may override this to check specific value types upfront,\n\t * or to post-process values return from {@code getResultSetValue}.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @param paramType the target parameter type\n\t * @return the Object value\n\t * @throws SQLException in case of extraction failure\n\t * @since 5.3\n\t * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "index",
      "paramType"
    ],
    "position": {
      "column": 1,
      "line": 438
    },
    "return": "Object",
    "signature": "protected Object getColumnValue(ResultSet rs, int index, Class<?> paramType)",
    "source_code": "\tprotected Object getColumnValue(ResultSet rs, int index, Class<?> paramType) throws SQLException {\n\t\treturn JdbcUtils.getResultSetValue(rs, index, paramType);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#getColumnValue(rs,index,pd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC object value for the specified column.\n\t * <p>The default implementation delegates to\n\t * {@link #getColumnValue(ResultSet, int, Class)}.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @param pd the bean property that each result object is expected to match\n\t * @return the Object value\n\t * @throws SQLException in case of extraction failure\n\t * @see #getColumnValue(ResultSet, int, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "index",
      "pd"
    ],
    "position": {
      "column": 1,
      "line": 419
    },
    "return": "Object",
    "signature": "protected Object getColumnValue(ResultSet rs, int index, PropertyDescriptor pd)",
    "source_code": "\tprotected Object getColumnValue(ResultSet rs, int index, PropertyDescriptor pd) throws SQLException {\n\t\treturn JdbcUtils.getResultSetValue(rs, index, pd.getPropertyType());\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#getColumnValue(rs,index,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC object value for the specified column.\n\t * <p>The default implementation calls\n\t * {@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}.\n\t * If no required type has been specified, this method delegates to\n\t * {@code getColumnValue(rs, index)}, which basically calls\n\t * {@code ResultSet.getObject(index)} but applies some additional\n\t * default conversion to appropriate value types.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @param requiredType the type that each result object is expected to match\n\t * (or {@code null} if none specified)\n\t * @return the Object value\n\t * @throws SQLException in case of extraction failure\n\t * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)\n\t * @see #getColumnValue(java.sql.ResultSet, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "index",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "Object",
    "signature": "protected Object getColumnValue(ResultSet rs, int index, @Nullable Class<?> requiredType)",
    "source_code": "\tprotected Object getColumnValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {\n\t\tif (requiredType != null) {\n\t\t\treturn JdbcUtils.getResultSetValue(rs, index, requiredType);\n\t\t}\n\t\telse {\n\t\t\t// No required type specified -> perform default extraction.\n\t\t\treturn getColumnValue(rs, index);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1580
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on ConnectionProxy interface coming in...\n\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of PersistenceManager proxy.\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\tcase \"close\":\n\t\t\t\t\t// Handle close method: suppress, not valid.\n\t\t\t\t\treturn null;\n\t\t\t\tcase \"isClosed\":\n\t\t\t\t\treturn false;\n\t\t\t\tcase \"getTargetConnection\":\n\t\t\t\t\t// Handle getTargetConnection method: return underlying Connection.\n\t\t\t\t\treturn this.target;\n\t\t\t\tcase \"unwrap\":\n\t\t\t\t\treturn (((Class<?>) args[0]).isInstance(proxy) ? proxy : this.target.unwrap((Class<?>) args[0]));\n\t\t\t\tcase \"isWrapperFor\":\n\t\t\t\t\treturn (((Class<?>) args[0]).isInstance(proxy) || this.target.isWrapperFor((Class<?>) args[0]));\n\t\t\t}\n\n\t\t\t// Invoke method on target Connection.\n\t\t\ttry {\n\t\t\t\tObject retVal = method.invoke(this.target, args);\n\n\t\t\t\t// If return value is a JDBC Statement, apply statement settings\n\t\t\t\t// (fetch size, max rows, transaction timeout).\n\t\t\t\tif (retVal instanceof Statement statement) {\n\t\t\t\t\tapplyStatementSettings(statement);\n\t\t\t\t}\n\n\t\t\t\treturn retVal;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jdbc.core.<unknown>#mapRow(rs,rowNum)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extract a value for the single column in the current row.\n\t * <p>Validates that there is only one column selected,\n\t * then delegates to {@code getColumnValue()} and also\n\t * {@code convertValueToRequiredType}, if necessary.\n\t * @see java.sql.ResultSetMetaData#getColumnCount()\n\t * @see #getColumnValue(java.sql.ResultSet, int, Class)\n\t * @see #convertValueToRequiredType(Object, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "rowNum"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "T",
    "signature": "public T mapRow(ResultSet rs, int rowNum)",
    "source_code": "\tpublic T mapRow(ResultSet rs, int rowNum) throws SQLException {\n\t\t// Validate column count.\n\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\tint nrOfColumns = rsmd.getColumnCount();\n\t\tif (nrOfColumns != 1) {\n\t\t\tthrow new IncorrectResultSetColumnCountException(1, nrOfColumns);\n\t\t}\n\n\t\t// Extract column value from JDBC ResultSet.\n\t\tObject result = getColumnValue(rs, 1, this.requiredType);\n\t\tif (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {\n\t\t\t// Extracted value does not match already: try to convert it.\n\t\t\ttry {\n\t\t\t\treturn (T) convertValueToRequiredType(result, this.requiredType);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tthrow new TypeMismatchDataAccessException(\n\t\t\t\t\t\t\"Type mismatch affecting row number \" + rowNum + \" and column type '\" +\n\t\t\t\t\t\trsmd.getColumnTypeName(1) + \"': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn (T) result;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#mapRow(rs,rowNumber)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extract the values for all columns in the current row.\n\t * <p>Utilizes public setters and result set meta-data.\n\t * @see java.sql.ResultSetMetaData\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "rowNumber"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "T",
    "signature": "public T mapRow(ResultSet rs, int rowNumber)",
    "source_code": "\tpublic T mapRow(ResultSet rs, int rowNumber) throws SQLException {\n\t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n\t\tinitBeanWrapper(bw);\n\n\t\tT mappedObject = constructMappedInstance(rs, bw);\n\t\tbw.setBeanInstance(mappedObject);\n\n\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\tint columnCount = rsmd.getColumnCount();\n\t\tSet<String> populatedProperties = (isCheckFullyPopulated() ? new HashSet<>() : null);\n\n\t\tfor (int index = 1; index <= columnCount; index++) {\n\t\t\tString column = JdbcUtils.lookupColumnName(rsmd, index);\n\t\t\tString property = lowerCaseName(StringUtils.delete(column, \" \"));\n\t\t\tPropertyDescriptor pd = (this.mappedProperties != null ? this.mappedProperties.get(property) : null);\n\t\t\tif (pd != null) {\n\t\t\t\ttry {\n\t\t\t\t\tObject value = getColumnValue(rs, index, pd);\n\t\t\t\t\tif (rowNumber == 0 && logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Mapping column '\" + column + \"' to property '\" + pd.getName() +\n\t\t\t\t\t\t\t\t\"' of type '\" + ClassUtils.getQualifiedName(pd.getPropertyType()) + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbw.setPropertyValue(pd.getName(), value);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\t\t\tif (value == null && this.primitivesDefaultedForNullValue) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tString propertyType = ClassUtils.getQualifiedName(pd.getPropertyType());\n\t\t\t\t\t\t\t\tlogger.debug(\"\"\"\n\t\t\t\t\t\t\t\t\t\tIgnoring intercepted TypeMismatchException for row %d and column '%s' \\\n\t\t\t\t\t\t\t\t\t\twith null value when setting property '%s' of type '%s' on object: %s\"\n\t\t\t\t\t\t\t\t\t\t\"\"\".formatted(rowNumber, column, pd.getName(), propertyType, mappedObject), ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (populatedProperties != null) {\n\t\t\t\t\t\tpopulatedProperties.add(pd.getName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NotWritablePropertyException ex) {\n\t\t\t\t\tthrow new DataRetrievalFailureException(\n\t\t\t\t\t\t\t\"Unable to map column '\" + column + \"' to property '\" + pd.getName() + \"'\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (populatedProperties != null && !populatedProperties.equals(this.mappedPropertyNames)) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\"Given ResultSet does not contain all properties \" +\n\t\t\t\t\t\"necessary to populate object of \" + this.mappedClass + \": \" + this.mappedPropertyNames);\n\t\t}\n\n\t\treturn mappedObject;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#newArgTypePreparedStatementSetter(args,argTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new arg-type-based PreparedStatementSetter using the args and types passed in.\n\t * <p>By default, we'll create an {@link ArgumentTypePreparedStatementSetter}.\n\t * This method allows for the creation to be overridden by subclasses.\n\t * @param args object array with arguments\n\t * @param argTypes int array of SQLTypes for the associated arguments\n\t * @return the new PreparedStatementSetter to use\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "args",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 1489
    },
    "return": "PreparedStatementSetter",
    "signature": "protected PreparedStatementSetter newArgTypePreparedStatementSetter(Object[] args, int[] argTypes)",
    "source_code": "\tprotected PreparedStatementSetter newArgTypePreparedStatementSetter(Object[] args, int[] argTypes) {\n\t\treturn new ArgumentTypePreparedStatementSetter(args, argTypes);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#newInstance(mappedClass,conversionService)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param conversionService the {@link ConversionService} for binding\n\t * JDBC values to bean properties, or {@code null} for none\n\t * @since 5.2.3\n\t * @see #newInstance(Class)\n\t * @see #setConversionService\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 461
    },
    "return": "BeanPropertyRowMapper<T>",
    "signature": "public BeanPropertyRowMapper<T> newInstance(Class<T> mappedClass, @Nullable ConversionService conversionService)",
    "source_code": "\tpublic static <T> BeanPropertyRowMapper<T> newInstance(\n\t\t\tClass<T> mappedClass, @Nullable ConversionService conversionService) {\n\n\t\tBeanPropertyRowMapper<T> rowMapper = newInstance(mappedClass);\n\t\trowMapper.setConversionService(conversionService);\n\t\treturn rowMapper;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#newInstance(requiredType,conversionService)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new {@code SingleColumnRowMapper}.\n\t * @param requiredType the type that each result object is expected to match\n\t * @param conversionService the {@link ConversionService} for converting a\n\t * fetched value, or {@code null} for none\n\t * @since 5.0.4\n\t * @see #newInstance(Class)\n\t * @see #setConversionService\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "SingleColumnRowMapper<T>",
    "signature": "public SingleColumnRowMapper<T> newInstance(Class<T> requiredType, @Nullable ConversionService conversionService)",
    "source_code": "\tpublic static <T> SingleColumnRowMapper<T> newInstance(\n\t\t\tClass<T> requiredType, @Nullable ConversionService conversionService) {\n\n\t\tSingleColumnRowMapper<T> rowMapper = newInstance(requiredType);\n\t\trowMapper.setConversionService(conversionService);\n\t\treturn rowMapper;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#newPreparedStatementCreator(sqlToUse,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new PreparedStatementCreator for the given parameters.\n\t * @param sqlToUse the actual SQL statement to use (if different from\n\t * the factory's, for example because of named parameter expanding)\n\t * @param params the parameter array (may be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sqlToUse",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "PreparedStatementCreator",
    "signature": "public PreparedStatementCreator newPreparedStatementCreator(String sqlToUse, @Nullable Object[] params)",
    "source_code": "\tpublic PreparedStatementCreator newPreparedStatementCreator(String sqlToUse, @Nullable Object[] params) {\n\t\treturn new PreparedStatementCreatorImpl(\n\t\t\t\tsqlToUse, params != null ? Arrays.asList(params) : Collections.emptyList());\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#processResultSet(rs,param)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given ResultSet from a stored procedure.\n\t * @param rs the ResultSet to process\n\t * @param param the corresponding stored procedure parameter\n\t * @return a Map that contains returned results\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "param"
    ],
    "position": {
      "column": 1,
      "line": 1378
    },
    "return": "Object>",
    "signature": "protected Object> processResultSet(@Nullable ResultSet rs, ResultSetSupportingSqlParameter param)",
    "source_code": "\tprotected Map<String, Object> processResultSet(\n\t\t\t@Nullable ResultSet rs, ResultSetSupportingSqlParameter param) throws SQLException {\n\n\t\tif (rs != null) {\n\t\t\ttry {\n\t\t\t\tif (param.getRowMapper() != null) {\n\t\t\t\t\tRowMapper<?> rowMapper = param.getRowMapper();\n\t\t\t\t\tObject data = (new RowMapperResultSetExtractor<>(rowMapper)).extractData(rs);\n\t\t\t\t\treturn Collections.singletonMap(param.getName(), data);\n\t\t\t\t}\n\t\t\t\telse if (param.getRowCallbackHandler() != null) {\n\t\t\t\t\tRowCallbackHandler rch = param.getRowCallbackHandler();\n\t\t\t\t\t(new RowCallbackHandlerResultSetExtractor(rch)).extractData(rs);\n\t\t\t\t\treturn Collections.singletonMap(param.getName(),\n\t\t\t\t\t\t\t\"ResultSet returned from stored procedure was processed\");\n\t\t\t\t}\n\t\t\t\telse if (param.getResultSetExtractor() != null) {\n\t\t\t\t\tObject data = param.getResultSetExtractor().extractData(rs);\n\t\t\t\t\treturn Collections.singletonMap(param.getName(), data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t}\n\t\t}\n\t\treturn Collections.emptyMap();\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(psc,pss,rse)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Query using a prepared statement, allowing for a PreparedStatementCreator\n\t * and a PreparedStatementSetter. Most other query methods use this method,\n\t * but application code will always work with either a creator or a setter.\n\t * @param psc a callback that creates a PreparedStatement given a Connection\n\t * @param pss a callback that knows how to set values on the prepared statement.\n\t * If this is {@code null}, the SQL will be assumed to contain no bind parameters.\n\t * @param rse a callback that will extract results\n\t * @return an arbitrary result object, as returned by the ResultSetExtractor\n\t * @throws DataAccessException if there is any problem\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "pss",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 706
    },
    "return": "T",
    "signature": "public T query(PreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss, final ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> T query(\n\t\t\tPreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss, final ResultSetExtractor<T> rse)\n\t\t\tthrows DataAccessException {\n\n\t\tAssert.notNull(rse, \"ResultSetExtractor must not be null\");\n\t\tlogger.debug(\"Executing prepared SQL query\");\n\n\t\treturn execute(psc, new PreparedStatementCallback<T>() {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T doInPreparedStatement(PreparedStatement ps) throws SQLException {\n\t\t\t\tResultSet rs = null;\n\t\t\t\ttry {\n\t\t\t\t\tif (pss != null) {\n\t\t\t\t\t\tpss.setValues(ps);\n\t\t\t\t\t}\n\t\t\t\t\trs = ps.executeQuery();\n\t\t\t\t\treturn rse.extractData(rs);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t\t\tif (pss instanceof ParameterDisposer parameterDisposer) {\n\t\t\t\t\t\tparameterDisposer.cleanupParameters();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(psc,rch)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 767
    },
    "return": "void",
    "signature": "public void query(PreparedStatementCreator psc, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(PreparedStatementCreator psc, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(psc, new RowCallbackHandlerResultSetExtractor(rch));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(psc,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 793
    },
    "return": "List<T>",
    "signature": "public List<T> query(PreparedStatementCreator psc, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(PreparedStatementCreator psc, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn result(query(psc, new RowMapperResultSetExtractor<>(rowMapper)));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(psc,rse)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 737
    },
    "return": "T",
    "signature": "public T query(PreparedStatementCreator psc, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> T query(PreparedStatementCreator psc, ResultSetExtractor<T> rse) throws DataAccessException {\n\t\treturn query(psc, null, rse);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,args,argTypes,rch)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 777
    },
    "return": "void",
    "signature": "public void query(String sql, Object[] args, int[] argTypes, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, Object[] args, int[] argTypes, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(sql, newArgTypePreparedStatementSetter(args, argTypes), rch);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,args,argTypes,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 803
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, Object[] args, int[] argTypes, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, Object[] args, int[] argTypes, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn result(query(sql, args, argTypes, new RowMapperResultSetExtractor<>(rowMapper)));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,args,argTypes,rse)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 749
    },
    "return": "T",
    "signature": "public T query(String sql, Object[] args, int[] argTypes, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> T query(String sql, Object[] args, int[] argTypes, ResultSetExtractor<T> rse) throws DataAccessException {\n\t\treturn query(sql, newArgTypePreparedStatementSetter(args, argTypes), rse);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,args,rch)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 783
    },
    "return": "void",
    "signature": "public void query(String sql, @Nullable Object[] args, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, @Nullable Object[] args, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(sql, newArgPreparedStatementSetter(args), rch);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,args,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 809
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, @Nullable Object[] args, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, @Nullable Object[] args, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn result(query(sql, args, new RowMapperResultSetExtractor<>(rowMapper)));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,args,rse)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 756
    },
    "return": "T",
    "signature": "public T query(String sql, @Nullable Object[] args, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> T query(String sql, @Nullable Object[] args, ResultSetExtractor<T> rse) throws DataAccessException {\n\t\treturn query(sql, newArgPreparedStatementSetter(args), rse);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,pss,rch)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "pss",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 772
    },
    "return": "void",
    "signature": "public void query(String sql, @Nullable PreparedStatementSetter pss, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, @Nullable PreparedStatementSetter pss, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(sql, pss, new RowCallbackHandlerResultSetExtractor(rch));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,pss,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "pss",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 798
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn result(query(sql, pss, new RowMapperResultSetExtractor<>(rowMapper)));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,pss,rse)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "pss",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 743
    },
    "return": "T",
    "signature": "public T query(String sql, @Nullable PreparedStatementSetter pss, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> T query(String sql, @Nullable PreparedStatementSetter pss, ResultSetExtractor<T> rse) throws DataAccessException {\n\t\treturn query(new SimplePreparedStatementCreator(sql), pss, rse);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rch)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 469
    },
    "return": "void",
    "signature": "public void query(String sql, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(sql, new RowCallbackHandlerResultSetExtractor(rch));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rch,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rch",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 788
    },
    "return": "void",
    "signature": "public void query(String sql, RowCallbackHandler rch, @Nullable Object... args)",
    "source_code": "\tpublic void query(String sql, RowCallbackHandler rch, @Nullable Object... args) throws DataAccessException {\n\t\tquery(sql, newArgPreparedStatementSetter(args), rch);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 474
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn result(query(sql, new RowMapperResultSetExtractor<>(rowMapper)));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rowMapper,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 814
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, RowMapper<T> rowMapper, @Nullable Object... args)",
    "source_code": "\tpublic <T> List<T> query(String sql, RowMapper<T> rowMapper, @Nullable Object... args) throws DataAccessException {\n\t\treturn result(query(sql, args, new RowMapperResultSetExtractor<>(rowMapper)));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rse)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "T",
    "signature": "public T query(final String sql, final ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> T query(final String sql, final ResultSetExtractor<T> rse) throws DataAccessException {\n\t\tAssert.notNull(sql, \"SQL must not be null\");\n\t\tAssert.notNull(rse, \"ResultSetExtractor must not be null\");\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Executing SQL query [\" + sql + \"]\");\n\t\t}\n\n\t\t/**\n\t\t * Callback to execute the query.\n\t\t */\n\t\tclass QueryStatementCallback implements StatementCallback<T>, SqlProvider {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T doInStatement(Statement stmt) throws SQLException {\n\t\t\t\tResultSet rs = null;\n\t\t\t\ttry {\n\t\t\t\t\trs = stmt.executeQuery(sql);\n\t\t\t\t\treturn rse.extractData(rs);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getSql() {\n\t\t\t\treturn sql;\n\t\t\t}\n\t\t}\n\n\t\treturn execute(new QueryStatementCallback(), true);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rse,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rse",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 762
    },
    "return": "T",
    "signature": "public T query(String sql, ResultSetExtractor<T> rse, @Nullable Object... args)",
    "source_code": "\tpublic <T> T query(String sql, ResultSetExtractor<T> rse, @Nullable Object... args) throws DataAccessException {\n\t\treturn query(sql, newArgPreparedStatementSetter(args), rse);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForList(sql,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 941
    },
    "return": "Object>>",
    "signature": "public Object>> queryForList(String sql, @Nullable Object... args)",
    "source_code": "\tpublic List<Map<String, Object>> queryForList(String sql, @Nullable Object... args) throws DataAccessException {\n\t\treturn query(sql, args, getColumnMapRowMapper());\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForList(sql,args,argTypes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 936
    },
    "return": "Object>>",
    "signature": "public Object>> queryForList(String sql, Object[] args, int[] argTypes)",
    "source_code": "\tpublic List<Map<String, Object>> queryForList(String sql, Object[] args, int[] argTypes) throws DataAccessException {\n\t\treturn query(sql, args, argTypes, getColumnMapRowMapper());\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForList(sql,args,argTypes,elementType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes",
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 920
    },
    "return": "List<T>",
    "signature": "public List<T> queryForList(String sql, Object[] args, int[] argTypes, Class<T> elementType)",
    "source_code": "\tpublic <T> List<T> queryForList(String sql, Object[] args, int[] argTypes, Class<T> elementType) throws DataAccessException {\n\t\treturn query(sql, args, argTypes, getSingleColumnRowMapper(elementType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForList(sql,args,elementType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 926
    },
    "return": "List<T>",
    "signature": "public List<T> queryForList(String sql, @Nullable Object[] args, Class<T> elementType)",
    "source_code": "\tpublic <T> List<T> queryForList(String sql, @Nullable Object[] args, Class<T> elementType) throws DataAccessException {\n\t\treturn query(sql, args, getSingleColumnRowMapper(elementType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForList(sql,elementType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 519
    },
    "return": "List<T>",
    "signature": "public List<T> queryForList(String sql, Class<T> elementType)",
    "source_code": "\tpublic <T> List<T> queryForList(String sql, Class<T> elementType) throws DataAccessException {\n\t\treturn query(sql, getSingleColumnRowMapper(elementType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForList(sql,elementType,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "elementType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 931
    },
    "return": "List<T>",
    "signature": "public List<T> queryForList(String sql, Class<T> elementType, @Nullable Object... args)",
    "source_code": "\tpublic <T> List<T> queryForList(String sql, Class<T> elementType, @Nullable Object... args) throws DataAccessException {\n\t\treturn query(sql, args, getSingleColumnRowMapper(elementType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForMap(sql,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 915
    },
    "return": "Object>",
    "signature": "public Object> queryForMap(String sql, @Nullable Object... args)",
    "source_code": "\tpublic Map<String, Object> queryForMap(String sql, @Nullable Object... args) throws DataAccessException {\n\t\treturn result(queryForObject(sql, args, getColumnMapRowMapper()));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForMap(sql,args,argTypes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 910
    },
    "return": "Object>",
    "signature": "public Object> queryForMap(String sql, Object[] args, int[] argTypes)",
    "source_code": "\tpublic Map<String, Object> queryForMap(String sql, Object[] args, int[] argTypes) throws DataAccessException {\n\t\treturn result(queryForObject(sql, args, argTypes, getColumnMapRowMapper()));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,args,argTypes,requiredType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 892
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, Object[] args, int[] argTypes, Class<T> requiredType)",
    "source_code": "\tpublic <T> T queryForObject(String sql, Object[] args, int[] argTypes, Class<T> requiredType)\n\t\t\tthrows DataAccessException {\n\n\t\treturn queryForObject(sql, args, argTypes, getSingleColumnRowMapper(requiredType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,args,argTypes,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 868
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, Object[] args, int[] argTypes, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> T queryForObject(String sql, Object[] args, int[] argTypes, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException {\n\n\t\tList<T> results = query(sql, args, argTypes, new RowMapperResultSetExtractor<>(rowMapper, 1));\n\t\treturn DataAccessUtils.nullableSingleResult(results);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,args,requiredType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 900
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, @Nullable Object[] args, Class<T> requiredType)",
    "source_code": "\tpublic <T> T queryForObject(String sql, @Nullable Object[] args, Class<T> requiredType) throws DataAccessException {\n\t\treturn queryForObject(sql, args, getSingleColumnRowMapper(requiredType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,args,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 878
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, @Nullable Object[] args, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> T queryForObject(String sql, @Nullable Object[] args, RowMapper<T> rowMapper) throws DataAccessException {\n\t\tList<T> results = query(sql, args, new RowMapperResultSetExtractor<>(rowMapper, 1));\n\t\treturn DataAccessUtils.nullableSingleResult(results);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,requiredType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 514
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, Class<T> requiredType)",
    "source_code": "\tpublic <T> T queryForObject(String sql, Class<T> requiredType) throws DataAccessException {\n\t\treturn queryForObject(sql, getSingleColumnRowMapper(requiredType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,requiredType,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 905
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, Class<T> requiredType, @Nullable Object... args)",
    "source_code": "\tpublic <T> T queryForObject(String sql, Class<T> requiredType, @Nullable Object... args) throws DataAccessException {\n\t\treturn queryForObject(sql, args, getSingleColumnRowMapper(requiredType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 507
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> T queryForObject(String sql, RowMapper<T> rowMapper) throws DataAccessException {\n\t\tList<T> results = query(sql, rowMapper);\n\t\treturn DataAccessUtils.nullableSingleResult(results);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,rowMapper,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 885
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, RowMapper<T> rowMapper, @Nullable Object... args)",
    "source_code": "\tpublic <T> T queryForObject(String sql, RowMapper<T> rowMapper, @Nullable Object... args) throws DataAccessException {\n\t\tList<T> results = query(sql, args, new RowMapperResultSetExtractor<>(rowMapper, 1));\n\t\treturn DataAccessUtils.nullableSingleResult(results);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForRowSet(sql,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 951
    },
    "return": "SqlRowSet",
    "signature": "public SqlRowSet queryForRowSet(String sql, @Nullable Object... args)",
    "source_code": "\tpublic SqlRowSet queryForRowSet(String sql, @Nullable Object... args) throws DataAccessException {\n\t\treturn result(query(sql, args, new SqlRowSetResultSetExtractor()));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForRowSet(sql,args,argTypes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 946
    },
    "return": "SqlRowSet",
    "signature": "public SqlRowSet queryForRowSet(String sql, Object[] args, int[] argTypes)",
    "source_code": "\tpublic SqlRowSet queryForRowSet(String sql, Object[] args, int[] argTypes) throws DataAccessException {\n\t\treturn result(query(sql, args, argTypes, new SqlRowSetResultSetExtractor()));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForStream(psc,pss,rowMapper)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Query using a prepared statement, allowing for a PreparedStatementCreator\n\t * and a PreparedStatementSetter. Most other query methods use this method,\n\t * but application code will always work with either a creator or a setter.\n\t * @param psc a callback that creates a PreparedStatement given a Connection\n\t * @param pss a callback that knows how to set values on the prepared statement.\n\t * If this is {@code null}, the SQL will be assumed to contain no bind parameters.\n\t * @param rowMapper a callback that will map one object per row\n\t * @return the result Stream, containing mapped objects, needing to be\n\t * closed once fully processed (e.g. through a try-with-resources clause)\n\t * @throws DataAccessException if the query fails\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "pss",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 831
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(PreparedStatementCreator psc, @Nullable PreparedStatementSetter pss,\n\t\t\tRowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(PreparedStatementCreator psc, @Nullable PreparedStatementSetter pss,\n\t\t\tRowMapper<T> rowMapper) throws DataAccessException {\n\n\t\treturn result(execute(psc, ps -> {\n\t\t\tif (pss != null) {\n\t\t\t\tpss.setValues(ps);\n\t\t\t}\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tConnection con = ps.getConnection();\n\t\t\treturn new ResultSetSpliterator<>(rs, rowMapper).stream().onClose(() -> {\n\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t\tif (pss instanceof ParameterDisposer parameterDisposer) {\n\t\t\t\t\tparameterDisposer.cleanupParameters();\n\t\t\t\t}\n\t\t\t\tJdbcUtils.closeStatement(ps);\n\t\t\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t\t\t});\n\t\t}, false));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForStream(psc,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 852
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(PreparedStatementCreator psc, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(PreparedStatementCreator psc, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn queryForStream(psc, null, rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForStream(sql,pss,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "pss",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 857
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn queryForStream(new SimplePreparedStatementCreator(sql), pss, rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForStream(sql,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 479
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(String sql, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(String sql, RowMapper<T> rowMapper) throws DataAccessException {\n\t\tclass StreamStatementCallback implements StatementCallback<Stream<T>>, SqlProvider {\n\t\t\t@Override\n\t\t\tpublic Stream<T> doInStatement(Statement stmt) throws SQLException {\n\t\t\t\tResultSet rs = stmt.executeQuery(sql);\n\t\t\t\tConnection con = stmt.getConnection();\n\t\t\t\treturn new ResultSetSpliterator<>(rs, rowMapper).stream().onClose(() -> {\n\t\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t\t\tJdbcUtils.closeStatement(stmt);\n\t\t\t\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t\t\t\t});\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getSql() {\n\t\t\t\treturn sql;\n\t\t\t}\n\t\t}\n\n\t\treturn result(execute(new StreamStatementCallback(), false));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForStream(sql,rowMapper,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 862
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(String sql, RowMapper<T> rowMapper, @Nullable Object... args)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(String sql, RowMapper<T> rowMapper, @Nullable Object... args) throws DataAccessException {\n\t\treturn queryForStream(new SimplePreparedStatementCreator(sql), newArgPreparedStatementSetter(args), rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#setParameterValue(ps,paramIndex,param,inValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for a parameter. The method used is based on the SQL type\n\t * of the parameter and we can handle complex types like arrays and LOBs.\n\t * @param ps the prepared statement or callable statement\n\t * @param paramIndex index of the parameter we are setting\n\t * @param param the parameter as it is declared including type\n\t * @param inValue the value to set\n\t * @throws SQLException if thrown by PreparedStatement methods\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "param",
      "inValue"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param,\n\t\t\t@Nullable Object inValue)",
    "source_code": "\tpublic static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param,\n\t\t\t@Nullable Object inValue) throws SQLException {\n\n\t\tsetParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#setParameterValue(ps,paramIndex,sqlType,inValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for a parameter. The method used is based on the SQL type\n\t * of the parameter and we can handle complex types like arrays and LOBs.\n\t * @param ps the prepared statement or callable statement\n\t * @param paramIndex index of the parameter we are setting\n\t * @param sqlType the SQL type of the parameter\n\t * @param inValue the value to set (plain value or an SqlTypeValue)\n\t * @throws SQLException if thrown by PreparedStatement methods\n\t * @see SqlTypeValue\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "sqlType",
      "inValue"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "void",
    "signature": "public void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType,\n\t\t\t@Nullable Object inValue)",
    "source_code": "\tpublic static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType,\n\t\t\t@Nullable Object inValue) throws SQLException {\n\n\t\tsetParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#setParameterValue(ps,paramIndex,sqlType,typeName,inValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for a parameter. The method used is based on the SQL type\n\t * of the parameter and we can handle complex types like arrays and LOBs.\n\t * @param ps the prepared statement or callable statement\n\t * @param paramIndex index of the parameter we are setting\n\t * @param sqlType the SQL type of the parameter\n\t * @param typeName the type name of the parameter\n\t * (optional, only used for SQL NULL and SqlTypeValue)\n\t * @param inValue the value to set (plain value or an SqlTypeValue)\n\t * @throws SQLException if thrown by PreparedStatement methods\n\t * @see SqlTypeValue\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "sqlType",
      "typeName",
      "inValue"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,\n\t\t\t@Nullable Object inValue)",
    "source_code": "\tpublic static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,\n\t\t\t@Nullable Object inValue) throws SQLException {\n\n\t\tsetParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#setValues(ps,i)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "i"
    ],
    "position": {
      "column": 1,
      "line": 1091
    },
    "return": "void",
    "signature": "public void setValues(PreparedStatement ps, int i)",
    "source_code": "\t\t\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n\t\t\t\t\t\tObject[] values = batchArgs.get(i);\n\t\t\t\t\t\tint colIndex = 0;\n\t\t\t\t\t\tfor (Object value : values) {\n\t\t\t\t\t\t\tcolIndex++;\n\t\t\t\t\t\t\tif (value instanceof SqlParameterValue paramValue) {\n\t\t\t\t\t\t\t\tStatementCreatorUtils.setParameterValue(ps, colIndex, paramValue, paramValue.getValue());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tint colType;\n\t\t\t\t\t\t\t\tif (argTypes.length < colIndex) {\n\t\t\t\t\t\t\t\t\tcolType = SqlTypeValue.TYPE_UNKNOWN;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tcolType = argTypes[colIndex - 1];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tStatementCreatorUtils.setParameterValue(ps, colIndex, colType, value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}"
  },
  "org.springframework.jdbc.core.<unknown>#translateException(task,sql,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Translate the given {@link SQLException} into a generic {@link DataAccessException}.\n\t * @param task readable text describing the task being attempted\n\t * @param sql the SQL query or update that caused the problem (may be {@code null})\n\t * @param ex the offending {@code SQLException}\n\t * @return a DataAccessException wrapping the {@code SQLException} (never {@code null})\n\t * @since 5.0\n\t * @see #getExceptionTranslator()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "sql",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 1537
    },
    "return": "DataAccessException",
    "signature": "protected DataAccessException translateException(String task, @Nullable String sql, SQLException ex)",
    "source_code": "\tprotected DataAccessException translateException(String task, @Nullable String sql, SQLException ex) {\n\t\tDataAccessException dae = getExceptionTranslator().translate(task, sql, ex);\n\t\treturn (dae != null ? dae : new UncategorizedSQLException(task, sql, ex));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#update(psc,generatedKeyHolder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "generatedKeyHolder"
    ],
    "position": {
      "column": 1,
      "line": 985
    },
    "return": "int",
    "signature": "public int update(final PreparedStatementCreator psc, final KeyHolder generatedKeyHolder)",
    "source_code": "\tpublic int update(final PreparedStatementCreator psc, final KeyHolder generatedKeyHolder)\n\t\t\tthrows DataAccessException {\n\n\t\tAssert.notNull(generatedKeyHolder, \"KeyHolder must not be null\");\n\t\tlogger.debug(\"Executing SQL update and returning generated keys\");\n\n\t\treturn updateCount(execute(psc, ps -> {\n\t\t\tint rows = ps.executeUpdate();\n\t\t\tList<Map<String, Object>> generatedKeys = generatedKeyHolder.getKeyList();\n\t\t\tgeneratedKeys.clear();\n\t\t\tResultSet keys = ps.getGeneratedKeys();\n\t\t\tif (keys != null) {\n\t\t\t\ttry {\n\t\t\t\t\tRowMapperResultSetExtractor<Map<String, Object>> rse =\n\t\t\t\t\t\t\tnew RowMapperResultSetExtractor<>(getColumnMapRowMapper(), 1);\n\t\t\t\t\tgeneratedKeys.addAll(result(rse.extractData(keys)));\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tJdbcUtils.closeResultSet(keys);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"SQL update affected \" + rows + \" rows and returned \" + generatedKeys.size() + \" keys\");\n\t\t\t}\n\t\t\treturn rows;\n\t\t}, true));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#update(psc,pss)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "psc",
      "pss"
    ],
    "position": {
      "column": 1,
      "line": 955
    },
    "return": "int",
    "signature": "protected int update(final PreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss)",
    "source_code": "\tprotected int update(final PreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss)\n\t\t\tthrows DataAccessException {\n\n\t\tlogger.debug(\"Executing prepared SQL update\");\n\n\t\treturn updateCount(execute(psc, ps -> {\n\t\t\ttry {\n\t\t\t\tif (pss != null) {\n\t\t\t\t\tpss.setValues(ps);\n\t\t\t\t}\n\t\t\t\tint rows = ps.executeUpdate();\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"SQL update affected \" + rows + \" rows\");\n\t\t\t\t}\n\t\t\t\treturn rows;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (pss instanceof ParameterDisposer parameterDisposer) {\n\t\t\t\t\tparameterDisposer.cleanupParameters();\n\t\t\t\t}\n\t\t\t}\n\t\t}, true));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#update(sql,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1024
    },
    "return": "int",
    "signature": "public int update(String sql, @Nullable Object... args)",
    "source_code": "\tpublic int update(String sql, @Nullable Object... args) throws DataAccessException {\n\t\treturn update(sql, newArgPreparedStatementSetter(args));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#update(sql,args,argTypes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 1019
    },
    "return": "int",
    "signature": "public int update(String sql, Object[] args, int[] argTypes)",
    "source_code": "\tpublic int update(String sql, Object[] args, int[] argTypes) throws DataAccessException {\n\t\treturn update(sql, newArgTypePreparedStatementSetter(args, argTypes));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#update(sql,pss)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "pss"
    ],
    "position": {
      "column": 1,
      "line": 1014
    },
    "return": "int",
    "signature": "public int update(String sql, @Nullable PreparedStatementSetter pss)",
    "source_code": "\tpublic int update(String sql, @Nullable PreparedStatementSetter pss) throws DataAccessException {\n\t\treturn update(new SimplePreparedStatementCreator(sql), pss);\n\t}"
  },
  "org.springframework.jdbc.core.metadata.<unknown>#createReturnResultSetParameter(parameterName,rowMapper)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a ReturnResultSetParameter/SqlOutParameter depending on the support provided\n\t * by the JDBC driver used for the database in use.\n\t * @param parameterName the name of the parameter (also used as the name of the List returned in the output)\n\t * @param rowMapper a RowMapper implementation used to map the data returned in the result set\n\t * @return the appropriate SqlParameter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterName",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "SqlParameter",
    "signature": "public SqlParameter createReturnResultSetParameter(String parameterName, RowMapper<?> rowMapper)",
    "source_code": "\tpublic SqlParameter createReturnResultSetParameter(String parameterName, RowMapper<?> rowMapper) {\n\t\tCallMetaDataProvider provider = obtainMetaDataProvider();\n\t\tif (provider.isReturnResultSetSupported()) {\n\t\t\treturn new SqlReturnResultSet(parameterName, rowMapper);\n\t\t}\n\t\telse {\n\t\t\tif (provider.isRefCursorSupported()) {\n\t\t\t\treturn new SqlOutParameter(parameterName, provider.getRefCursorSqlType(), rowMapper);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\"Return of a ResultSet from a stored procedure is not supported\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#buildSqlParameterList(parsedSql,paramSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters.\n\t * This is necessary in order to reuse existing methods on JdbcTemplate.\n\t * The SqlParameter for a named parameter is placed in the correct position in the\n\t * resulting list based on the parsed SQL statement info.\n\t * @param parsedSql the parsed SQL statement\n\t * @param paramSource the source for named parameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parsedSql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 440
    },
    "return": "List<SqlParameter>",
    "signature": "public List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource)",
    "source_code": "\tpublic static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {\n\t\tList<String> paramNames = parsedSql.getParameterNames();\n\t\tList<SqlParameter> params = new ArrayList<>(paramNames.size());\n\t\tfor (String paramName : paramNames) {\n\t\t\tparams.add(new SqlParameter(\n\t\t\t\t\tparamName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)));\n\t\t}\n\t\treturn params;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#buildSqlTypeArray(parsedSql,paramSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert parameter types from an SqlParameterSource into a corresponding int array.\n\t * This is necessary in order to reuse existing methods on JdbcTemplate.\n\t * Any named parameter types are placed in the correct position in the\n\t * Object array based on the parsed SQL statement info.\n\t * @param parsedSql the parsed SQL statement\n\t * @param paramSource the source for named parameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parsedSql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 422
    },
    "return": "int[]",
    "signature": "public int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource)",
    "source_code": "\tpublic static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {\n\t\tint[] sqlTypes = new int[parsedSql.getTotalParameterCount()];\n\t\tList<String> paramNames = parsedSql.getParameterNames();\n\t\tfor (int i = 0; i < paramNames.size(); i++) {\n\t\t\tString paramName = paramNames.get(i);\n\t\t\tsqlTypes[i] = paramSource.getSqlType(paramName);\n\t\t}\n\t\treturn sqlTypes;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#buildValueArray(parsedSql,paramSource,declaredParams)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a Map of named parameter values to a corresponding array.\n\t * @param parsedSql the parsed SQL statement\n\t * @param paramSource the source for named parameters\n\t * @param declaredParams the List of declared SqlParameter objects\n\t * (may be {@code null}). If specified, the parameter metadata will\n\t * be built into the value array in the form of SqlParameterValue objects.\n\t * @return the array of values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parsedSql",
      "paramSource",
      "declaredParams"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "Object[]",
    "signature": "public Object[] buildValueArray(ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams)",
    "source_code": "\tpublic static Object[] buildValueArray(\n\t\t\tParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams) {\n\n\t\tObject[] paramArray = new Object[parsedSql.getTotalParameterCount()];\n\t\tif (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"Not allowed to mix named and traditional ? placeholders. You have \" +\n\t\t\t\t\tparsedSql.getNamedParameterCount() + \" named parameter(s) and \" +\n\t\t\t\t\tparsedSql.getUnnamedParameterCount() + \" traditional placeholder(s) in statement: \" +\n\t\t\t\t\tparsedSql.getOriginalSql());\n\t\t}\n\t\tList<String> paramNames = parsedSql.getParameterNames();\n\t\tfor (int i = 0; i < paramNames.size(); i++) {\n\t\t\tString paramName = paramNames.get(i);\n\t\t\ttry {\n\t\t\t\tSqlParameter param = findParameter(declaredParams, paramName, i);\n\t\t\t\tObject paramValue = paramSource.getValue(paramName);\n\t\t\t\tif (paramValue instanceof SqlParameterValue) {\n\t\t\t\t\tparamArray[i] = paramValue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparamArray[i] = (param != null ? new SqlParameterValue(param, paramValue) :\n\t\t\t\t\t\t\tSqlParameterSourceUtils.getTypedValue(paramSource, paramName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\"No value supplied for the SQL parameter '\" + paramName + \"': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn paramArray;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#buildValueArray(sql,Map<String,paramMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a Map of named parameter values to a corresponding array.\n\t * <p>This is a shortcut version of\n\t * {@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}.\n\t * @param sql the SQL statement\n\t * @param paramMap the Map of parameters\n\t * @return the array of values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 492
    },
    "return": "Object[]",
    "signature": "public Object[] buildValueArray(String sql, Map<String, ?> paramMap)",
    "source_code": "\tpublic static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {\n\t\tParsedSql parsedSql = parseSqlStatement(sql);\n\t\treturn buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#registerSqlType(paramName,sqlType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register an SQL type for the given parameter.\n\t * @param paramName the name of the parameter\n\t * @param sqlType the SQL type of the parameter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "sqlType"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "void",
    "signature": "public void registerSqlType(String paramName, int sqlType)",
    "source_code": "\tpublic void registerSqlType(String paramName, int sqlType) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.sqlTypes.put(paramName, sqlType);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#registerTypeName(paramName,typeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register an SQL type for the given parameter.\n\t * @param paramName the name of the parameter\n\t * @param typeName the type name of the parameter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "typeName"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void registerTypeName(String paramName, String typeName)",
    "source_code": "\tpublic void registerTypeName(String paramName, String typeName) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.typeNames.put(paramName, typeName);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#substituteNamedParameters(parsedSql,paramSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the SQL statement and locate any placeholders or named parameters. Named\n\t * parameters are substituted for a JDBC placeholder, and any select list is expanded\n\t * to the required number of placeholders. Select lists may contain an array of\n\t * objects, and in that case the placeholders will be grouped and enclosed with\n\t * parentheses. This allows for the use of \"expression lists\" in the SQL statement\n\t * like: <br /><br />\n\t * {@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}\n\t * <p>The parameter values passed in are used to determine the number of placeholders to\n\t * be used for a select list. Select lists should be limited to 100 or fewer elements.\n\t * A larger number of elements is not guaranteed to be supported by the database and\n\t * is strictly vendor-dependent.\n\t * @param parsedSql the parsed representation of the SQL statement\n\t * @param paramSource the source for named parameters\n\t * @return the SQL statement with substituted parameters\n\t * @see #parseSqlStatement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parsedSql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "String",
    "signature": "public String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource)",
    "source_code": "\tpublic static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource) {\n\t\tString originalSql = parsedSql.getOriginalSql();\n\t\tList<String> paramNames = parsedSql.getParameterNames();\n\t\tif (paramNames.isEmpty()) {\n\t\t\treturn originalSql;\n\t\t}\n\n\t\tStringBuilder actualSql = new StringBuilder(originalSql.length());\n\t\tint lastIndex = 0;\n\t\tfor (int i = 0; i < paramNames.size(); i++) {\n\t\t\tString paramName = paramNames.get(i);\n\t\t\tint[] indexes = parsedSql.getParameterIndexes(i);\n\t\t\tint startIndex = indexes[0];\n\t\t\tint endIndex = indexes[1];\n\t\t\tactualSql.append(originalSql, lastIndex, startIndex);\n\t\t\tif (paramSource != null && paramSource.hasValue(paramName)) {\n\t\t\t\tObject value = paramSource.getValue(paramName);\n\t\t\t\tif (value instanceof SqlParameterValue sqlParameterValue) {\n\t\t\t\t\tvalue = sqlParameterValue.getValue();\n\t\t\t\t}\n\t\t\t\tif (value instanceof Iterable<?> iterable) {\n\t\t\t\t\tIterator<?> entryIter = iterable.iterator();\n\t\t\t\t\tint k = 0;\n\t\t\t\t\twhile (entryIter.hasNext()) {\n\t\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\t\tactualSql.append(\", \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tObject entryItem = entryIter.next();\n\t\t\t\t\t\tif (entryItem instanceof Object[] expressionList) {\n\t\t\t\t\t\t\tactualSql.append('(');\n\t\t\t\t\t\t\tfor (int m = 0; m < expressionList.length; m++) {\n\t\t\t\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\t\t\t\tactualSql.append(\", \");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tactualSql.append('?');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tactualSql.append(')');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tactualSql.append('?');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tactualSql.append('?');\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tactualSql.append('?');\n\t\t\t}\n\t\t\tlastIndex = endIndex;\n\t\t}\n\t\tactualSql.append(originalSql, lastIndex, originalSql.length());\n\t\treturn actualSql.toString();\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#substituteNamedParameters(sql,paramSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the SQL statement and locate any placeholders or named parameters.\n\t * Named parameters are substituted for a JDBC placeholder and any select list\n\t * is expanded to the required number of placeholders.\n\t * <p>This is a shortcut version of\n\t * {@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}.\n\t * @param sql the SQL statement\n\t * @param paramSource the source for named parameters\n\t * @return the SQL statement with substituted parameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 479
    },
    "return": "String",
    "signature": "public String substituteNamedParameters(String sql, SqlParameterSource paramSource)",
    "source_code": "\tpublic static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {\n\t\tParsedSql parsedSql = parseSqlStatement(sql);\n\t\treturn substituteNamedParameters(parsedSql, paramSource);\n\t}"
  },
  "org.springframework.jdbc.core.support.<unknown>#setTypeValue(ps,paramIndex,sqlType,typeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the specified content via the LobCreator.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "sqlType",
      "typeName"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "public void setTypeValue(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)",
    "source_code": "\tpublic void setTypeValue(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)\n\t\t\tthrows SQLException {\n\n\t\tif (sqlType == Types.BLOB) {\n\t\t\tif (this.content instanceof byte[] || this.content == null) {\n\t\t\t\tthis.lobCreator.setBlobAsBytes(ps, paramIndex, (byte[]) this.content);\n\t\t\t}\n\t\t\telse if (this.content instanceof String string) {\n\t\t\t\tthis.lobCreator.setBlobAsBytes(ps, paramIndex, string.getBytes());\n\t\t\t}\n\t\t\telse if (this.content instanceof InputStream inputStream) {\n\t\t\t\tthis.lobCreator.setBlobAsBinaryStream(ps, paramIndex, inputStream, this.length);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Content type [\" + this.content.getClass().getName() + \"] not supported for BLOB columns\");\n\t\t\t}\n\t\t}\n\t\telse if (sqlType == Types.CLOB) {\n\t\t\tif (this.content instanceof String || this.content == null) {\n\t\t\t\tthis.lobCreator.setClobAsString(ps, paramIndex, (String) this.content);\n\t\t\t}\n\t\t\telse if (this.content instanceof InputStream inputStream) {\n\t\t\t\tthis.lobCreator.setClobAsAsciiStream(ps, paramIndex, inputStream, this.length);\n\t\t\t}\n\t\t\telse if (this.content instanceof Reader reader) {\n\t\t\t\tthis.lobCreator.setClobAsCharacterStream(ps, paramIndex, reader, this.length);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Content type [\" + this.content.getClass().getName() + \"] not supported for CLOB columns\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"SqlLobValue only supports SQL types BLOB and CLOB\");\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#applyTimeout(stmt,dataSource,timeout)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the specified timeout - overridden by the current transaction timeout,\n\t * if any - to the given JDBC Statement object.\n\t * @param stmt the JDBC Statement object\n\t * @param dataSource the DataSource that the Connection was obtained from\n\t * @param timeout the timeout to apply (or 0 for no timeout outside of a transaction)\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.Statement#setQueryTimeout\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "stmt",
      "dataSource",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "void",
    "signature": "public void applyTimeout(Statement stmt, @Nullable DataSource dataSource, int timeout)",
    "source_code": "\tpublic static void applyTimeout(Statement stmt, @Nullable DataSource dataSource, int timeout) throws SQLException {\n\t\tAssert.notNull(stmt, \"No Statement specified\");\n\t\tConnectionHolder holder = null;\n\t\tif (dataSource != null) {\n\t\t\tholder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);\n\t\t}\n\t\tif (holder != null && holder.hasTimeout()) {\n\t\t\t// Remaining transaction timeout overrides specified value.\n\t\t\tstmt.setQueryTimeout(holder.getTimeToLiveInSeconds());\n\t\t}\n\t\telse if (timeout >= 0) {\n\t\t\t// No current transaction timeout -> apply specified value.\n\t\t\tstmt.setQueryTimeout(timeout);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#applyTransactionTimeout(stmt,dataSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the current transaction timeout, if any,\n\t * to the given JDBC Statement object.\n\t * @param stmt the JDBC Statement object\n\t * @param dataSource the DataSource that the Connection was obtained from\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.Statement#setQueryTimeout\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "stmt",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "void",
    "signature": "public void applyTransactionTimeout(Statement stmt, @Nullable DataSource dataSource)",
    "source_code": "\tpublic static void applyTransactionTimeout(Statement stmt, @Nullable DataSource dataSource) throws SQLException {\n\t\tapplyTimeout(stmt, dataSource, -1);\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#doBegin(transaction,definition)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "void",
    "signature": "protected void doBegin(Object transaction, TransactionDefinition definition)",
    "source_code": "\tprotected void doBegin(Object transaction, TransactionDefinition definition) {\n\t\tDataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;\n\t\tConnection con = null;\n\n\t\ttry {\n\t\t\tif (!txObject.hasConnectionHolder() ||\n\t\t\t\t\ttxObject.getConnectionHolder().isSynchronizedWithTransaction()) {\n\t\t\t\tConnection newCon = obtainDataSource().getConnection();\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Acquired Connection [\" + newCon + \"] for JDBC transaction\");\n\t\t\t\t}\n\t\t\t\ttxObject.setConnectionHolder(new ConnectionHolder(newCon), true);\n\t\t\t}\n\n\t\t\ttxObject.getConnectionHolder().setSynchronizedWithTransaction(true);\n\t\t\tcon = txObject.getConnectionHolder().getConnection();\n\n\t\t\tInteger previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);\n\t\t\ttxObject.setPreviousIsolationLevel(previousIsolationLevel);\n\t\t\ttxObject.setReadOnly(definition.isReadOnly());\n\n\t\t\t// Switch to manual commit if necessary. This is very expensive in some JDBC drivers,\n\t\t\t// so we don't want to do it unnecessarily (for example if we've explicitly\n\t\t\t// configured the connection pool to set it already).\n\t\t\tif (con.getAutoCommit()) {\n\t\t\t\ttxObject.setMustRestoreAutoCommit(true);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Switching JDBC Connection [\" + con + \"] to manual commit\");\n\t\t\t\t}\n\t\t\t\tcon.setAutoCommit(false);\n\t\t\t}\n\n\t\t\tprepareTransactionalConnection(con, definition);\n\t\t\ttxObject.getConnectionHolder().setTransactionActive(true);\n\n\t\t\tint timeout = determineTimeout(definition);\n\t\t\tif (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\t\ttxObject.getConnectionHolder().setTimeoutInSeconds(timeout);\n\t\t\t}\n\n\t\t\t// Bind the connection holder to the thread.\n\t\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\t\tTransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());\n\t\t\t}\n\t\t}\n\n\t\tcatch (Throwable ex) {\n\t\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\t\tDataSourceUtils.releaseConnection(con, obtainDataSource());\n\t\t\t\ttxObject.setConnectionHolder(null, false);\n\t\t\t}\n\t\t\tthrow new CannotCreateTransactionException(\"Could not open JDBC Connection for transaction\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#doCloseConnection(con,dataSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Close the Connection, unless a {@link SmartDataSource} doesn't want us to.\n\t * @param con the Connection to close if necessary\n\t * @param dataSource the DataSource that the Connection was obtained from\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see Connection#close()\n\t * @see SmartDataSource#shouldClose(Connection)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 404
    },
    "return": "void",
    "signature": "public void doCloseConnection(Connection con, @Nullable DataSource dataSource)",
    "source_code": "\tpublic static void doCloseConnection(Connection con, @Nullable DataSource dataSource) throws SQLException {\n\t\tif (!(dataSource instanceof SmartDataSource smartDataSource) || smartDataSource.shouldClose(con)) {\n\t\t\tcon.close();\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#doReleaseConnection(con,dataSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually close the given Connection, obtained from the given DataSource.\n\t * Same as {@link #releaseConnection}, but throwing the original SQLException.\n\t * <p>Directly accessed by {@link TransactionAwareDataSourceProxy}.\n\t * @param con the Connection to close if necessary\n\t * (if this is {@code null}, the call will be ignored)\n\t * @param dataSource the DataSource that the Connection was obtained from\n\t * (may be {@code null})\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see #doGetConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "void",
    "signature": "public void doReleaseConnection(@Nullable Connection con, @Nullable DataSource dataSource)",
    "source_code": "\tpublic static void doReleaseConnection(@Nullable Connection con, @Nullable DataSource dataSource) throws SQLException {\n\t\tif (con == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (dataSource != null) {\n\t\t\tConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);\n\t\t\tif (conHolder != null && connectionEquals(conHolder, con)) {\n\t\t\t\t// It's the transactional Connection: Don't close it.\n\t\t\t\tconHolder.released();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tdoCloseConnection(con, dataSource);\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#doResume(transaction,suspendedResources)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "void",
    "signature": "protected void doResume(@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected void doResume(@Nullable Object transaction, Object suspendedResources) {\n\t\tTransactionSynchronizationManager.bindResource(obtainDataSource(), suspendedResources);\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on ConnectionProxy interface coming in...\n\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\t// Only considered as equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of Connection proxy.\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\tcase \"toString\":\n\t\t\t\t\t// Allow for differentiating between the proxy and the raw Connection.\n\t\t\t\t\tStringBuilder sb = new StringBuilder(\"Transaction-aware proxy for target Connection \");\n\t\t\t\t\tif (this.target != null) {\n\t\t\t\t\t\tsb.append('[').append(this.target.toString()).append(']');\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsb.append(\" from DataSource [\").append(this.targetDataSource).append(']');\n\t\t\t\t\t}\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tcase \"close\":\n\t\t\t\t\t// Handle close method: only close if not within a transaction.\n\t\t\t\t\tDataSourceUtils.doReleaseConnection(this.target, this.targetDataSource);\n\t\t\t\t\tthis.closed = true;\n\t\t\t\t\treturn null;\n\t\t\t\tcase \"isClosed\":\n\t\t\t\t\treturn this.closed;\n\t\t\t\tcase \"unwrap\":\n\t\t\t\t\tif (((Class<?>) args[0]).isInstance(proxy)) {\n\t\t\t\t\t\treturn proxy;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"isWrapperFor\":\n\t\t\t\t\tif (((Class<?>) args[0]).isInstance(proxy)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (this.target == null) {\n\t\t\t\tif (method.getName().equals(\"getWarnings\") || method.getName().equals(\"clearWarnings\")) {\n\t\t\t\t\t// Avoid creation of target Connection on pre-close cleanup (e.g. Hibernate Session)\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (this.closed) {\n\t\t\t\t\tthrow new SQLException(\"Connection handle already closed\");\n\t\t\t\t}\n\t\t\t\tif (shouldObtainFixedConnection(this.targetDataSource)) {\n\t\t\t\t\tthis.target = DataSourceUtils.doGetConnection(this.targetDataSource);\n\t\t\t\t}\n\t\t\t}\n\t\t\tConnection actualTarget = this.target;\n\t\t\tif (actualTarget == null) {\n\t\t\t\tactualTarget = DataSourceUtils.doGetConnection(this.targetDataSource);\n\t\t\t}\n\n\t\t\tif (method.getName().equals(\"getTargetConnection\")) {\n\t\t\t\t// Handle getTargetConnection method: return underlying Connection.\n\t\t\t\treturn actualTarget;\n\t\t\t}\n\n\t\t\t// Invoke method on target Connection.\n\t\t\ttry {\n\t\t\t\tObject retVal = method.invoke(actualTarget, args);\n\n\t\t\t\t// If return value is a Statement, apply transaction timeout.\n\t\t\t\t// Applies to createStatement, prepareStatement, prepareCall.\n\t\t\t\tif (retVal instanceof Statement statement) {\n\t\t\t\t\tDataSourceUtils.applyTransactionTimeout(statement, this.targetDataSource);\n\t\t\t\t}\n\n\t\t\t\treturn retVal;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (actualTarget != this.target) {\n\t\t\t\t\tDataSourceUtils.doReleaseConnection(actualTarget, this.targetDataSource);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#isConnectionTransactional(con,dataSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given JDBC Connection is transactional, that is,\n\t * bound to the current thread by Spring's transaction facilities.\n\t * @param con the Connection to check\n\t * @param dataSource the DataSource that the Connection was obtained from\n\t * (may be {@code null})\n\t * @return whether the Connection is transactional\n\t * @see #getConnection(DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "boolean",
    "signature": "public boolean isConnectionTransactional(Connection con, @Nullable DataSource dataSource)",
    "source_code": "\tpublic static boolean isConnectionTransactional(Connection con, @Nullable DataSource dataSource) {\n\t\tif (dataSource == null) {\n\t\t\treturn false;\n\t\t}\n\t\tConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);\n\t\treturn (conHolder != null && connectionEquals(conHolder, con));\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#prepareConnectionForTransaction(con,definition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the given Connection with the given transaction semantics.\n\t * @param con the Connection to prepare\n\t * @param definition the transaction definition to apply\n\t * @return the previous isolation level, if any\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see #resetConnectionAfterTransaction\n\t * @see Connection#setTransactionIsolation\n\t * @see Connection#setReadOnly\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "Integer",
    "signature": "public Integer prepareConnectionForTransaction(Connection con, @Nullable TransactionDefinition definition)",
    "source_code": "\tpublic static Integer prepareConnectionForTransaction(Connection con, @Nullable TransactionDefinition definition)\n\t\t\tthrows SQLException {\n\n\t\tAssert.notNull(con, \"No Connection specified\");\n\n\t\tboolean debugEnabled = logger.isDebugEnabled();\n\t\t// Set read-only flag.\n\t\tif (definition != null && definition.isReadOnly()) {\n\t\t\ttry {\n\t\t\t\tif (debugEnabled) {\n\t\t\t\t\tlogger.debug(\"Setting JDBC Connection [\" + con + \"] read-only\");\n\t\t\t\t}\n\t\t\t\tcon.setReadOnly(true);\n\t\t\t}\n\t\t\tcatch (SQLException | RuntimeException ex) {\n\t\t\t\tThrowable exToCheck = ex;\n\t\t\t\twhile (exToCheck != null) {\n\t\t\t\t\tif (exToCheck.getClass().getSimpleName().contains(\"Timeout\")) {\n\t\t\t\t\t\t// Assume it's a connection timeout that would otherwise get lost: e.g. from JDBC 4.0\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t\texToCheck = exToCheck.getCause();\n\t\t\t\t}\n\t\t\t\t// \"read-only not supported\" SQLException -> ignore, it's just a hint anyway\n\t\t\t\tlogger.debug(\"Could not set JDBC Connection read-only\", ex);\n\t\t\t}\n\t\t}\n\n\t\t// Apply specific isolation level, if any.\n\t\tInteger previousIsolationLevel = null;\n\t\tif (definition != null && definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {\n\t\t\tif (debugEnabled) {\n\t\t\t\tlogger.debug(\"Changing isolation level of JDBC Connection [\" + con + \"] to \" +\n\t\t\t\t\t\tdefinition.getIsolationLevel());\n\t\t\t}\n\t\t\tint currentIsolation = con.getTransactionIsolation();\n\t\t\tif (currentIsolation != definition.getIsolationLevel()) {\n\t\t\t\tpreviousIsolationLevel = currentIsolation;\n\t\t\t\tcon.setTransactionIsolation(definition.getIsolationLevel());\n\t\t\t}\n\t\t}\n\n\t\treturn previousIsolationLevel;\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#prepareTransactionalConnection(con,definition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the transactional {@code Connection} right after transaction begin.\n\t * <p>The default implementation executes a \"SET TRANSACTION READ ONLY\" statement\n\t * if the {@link #setEnforceReadOnly \"enforceReadOnly\"} flag is set to {@code true}\n\t * and the transaction definition indicates a read-only transaction.\n\t * <p>The \"SET TRANSACTION READ ONLY\" is understood by Oracle, MySQL and Postgres\n\t * and may work with other databases as well. If you'd like to adapt this treatment,\n\t * override this method accordingly.\n\t * @param con the transactional JDBC Connection\n\t * @param definition the current transaction definition\n\t * @throws SQLException if thrown by JDBC API\n\t * @since 4.3.7\n\t * @see #setEnforceReadOnly\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "void",
    "signature": "protected void prepareTransactionalConnection(Connection con, TransactionDefinition definition)",
    "source_code": "\tprotected void prepareTransactionalConnection(Connection con, TransactionDefinition definition)\n\t\t\tthrows SQLException {\n\n\t\tif (isEnforceReadOnly() && definition.isReadOnly()) {\n\t\t\ttry (Statement stmt = con.createStatement()) {\n\t\t\t\tstmt.executeUpdate(\"SET TRANSACTION READ ONLY\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#releaseConnection(con,dataSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Close the given Connection, obtained from the given DataSource,\n\t * if it is not managed externally (that is, not bound to the thread).\n\t * @param con the Connection to close if necessary\n\t * (if this is {@code null}, the call will be ignored)\n\t * @param dataSource the DataSource that the Connection was obtained from\n\t * (may be {@code null})\n\t * @see #getConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 358
    },
    "return": "void",
    "signature": "public void releaseConnection(@Nullable Connection con, @Nullable DataSource dataSource)",
    "source_code": "\tpublic static void releaseConnection(@Nullable Connection con, @Nullable DataSource dataSource) {\n\t\ttry {\n\t\t\tdoReleaseConnection(con, dataSource);\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tlogger.debug(\"Could not close JDBC Connection\", ex);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.debug(\"Unexpected exception on closing JDBC Connection\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#resetConnectionAfterTransaction(con,previousIsolationLevel)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Reset the given Connection after a transaction,\n\t * regarding read-only flag and isolation level.\n\t * @param con the Connection to reset\n\t * @param previousIsolationLevel the isolation level to restore, if any\n\t * @deprecated as of 5.1.11, in favor of\n\t * {@link #resetConnectionAfterTransaction(Connection, Integer, boolean)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "previousIsolationLevel"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "void",
    "signature": "public void resetConnectionAfterTransaction(Connection con, @Nullable Integer previousIsolationLevel)",
    "source_code": "\tpublic static void resetConnectionAfterTransaction(Connection con, @Nullable Integer previousIsolationLevel) {\n\t\tAssert.notNull(con, \"No Connection specified\");\n\t\ttry {\n\t\t\t// Reset transaction isolation to previous value, if changed for the transaction.\n\t\t\tif (previousIsolationLevel != null) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Resetting isolation level of JDBC Connection [\" +\n\t\t\t\t\t\t\tcon + \"] to \" + previousIsolationLevel);\n\t\t\t\t}\n\t\t\t\tcon.setTransactionIsolation(previousIsolationLevel);\n\t\t\t}\n\n\t\t\t// Reset read-only flag.\n\t\t\tif (con.isReadOnly()) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Resetting read-only flag of JDBC Connection [\" + con + \"]\");\n\t\t\t\t}\n\t\t\t\tcon.setReadOnly(false);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.debug(\"Could not reset JDBC Connection after transaction\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#resetConnectionAfterTransaction(con,previousIsolationLevel,resetReadOnly)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Reset the given Connection after a transaction,\n\t * regarding read-only flag and isolation level.\n\t * @param con the Connection to reset\n\t * @param previousIsolationLevel the isolation level to restore, if any\n\t * @param resetReadOnly whether to reset the connection's read-only flag\n\t * @since 5.2.1\n\t * @see #prepareConnectionForTransaction\n\t * @see Connection#setTransactionIsolation\n\t * @see Connection#setReadOnly\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "previousIsolationLevel",
      "resetReadOnly"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "void",
    "signature": "public void resetConnectionAfterTransaction(Connection con, @Nullable Integer previousIsolationLevel, boolean resetReadOnly)",
    "source_code": "\tpublic static void resetConnectionAfterTransaction(\n\t\t\tConnection con, @Nullable Integer previousIsolationLevel, boolean resetReadOnly) {\n\n\t\tAssert.notNull(con, \"No Connection specified\");\n\t\tboolean debugEnabled = logger.isDebugEnabled();\n\t\ttry {\n\t\t\t// Reset transaction isolation to previous value, if changed for the transaction.\n\t\t\tif (previousIsolationLevel != null) {\n\t\t\t\tif (debugEnabled) {\n\t\t\t\t\tlogger.debug(\"Resetting isolation level of JDBC Connection [\" +\n\t\t\t\t\t\t\tcon + \"] to \" + previousIsolationLevel);\n\t\t\t\t}\n\t\t\t\tcon.setTransactionIsolation(previousIsolationLevel);\n\t\t\t}\n\n\t\t\t// Reset read-only flag if we originally switched it to true on transaction begin.\n\t\t\tif (resetReadOnly) {\n\t\t\t\tif (debugEnabled) {\n\t\t\t\t\tlogger.debug(\"Resetting read-only flag of JDBC Connection [\" + con + \"]\");\n\t\t\t\t}\n\t\t\t\tcon.setReadOnly(false);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.debug(\"Could not reset JDBC Connection after transaction\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#setConnectionHolder(connectionHolder,newConnectionHolder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connectionHolder",
      "newConnectionHolder"
    ],
    "position": {
      "column": 1,
      "line": 449
    },
    "return": "void",
    "signature": "public void setConnectionHolder(@Nullable ConnectionHolder connectionHolder, boolean newConnectionHolder)",
    "source_code": "\t\tpublic void setConnectionHolder(@Nullable ConnectionHolder connectionHolder, boolean newConnectionHolder) {\n\t\t\tsuper.setConnectionHolder(connectionHolder);\n\t\t\tthis.newConnectionHolder = newConnectionHolder;\n\t\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#translateException(task,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Translate the given JDBC commit/rollback exception to a common Spring\n\t * exception to propagate from the {@link #commit}/{@link #rollback} call.\n\t * <p>The default implementation throws a {@link TransactionSystemException}.\n\t * Subclasses may specifically identify concurrency failures etc.\n\t * @param task the task description (commit or rollback)\n\t * @param ex the SQLException thrown from commit/rollback\n\t * @return the translated exception to throw, either a\n\t * {@link org.springframework.dao.DataAccessException} or a\n\t * {@link org.springframework.transaction.TransactionException}\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 434
    },
    "return": "RuntimeException",
    "signature": "protected RuntimeException translateException(String task, SQLException ex)",
    "source_code": "\tprotected RuntimeException translateException(String task, SQLException ex) {\n\t\treturn new TransactionSystemException(task + \" failed\", ex);\n\t}"
  },
  "org.springframework.jdbc.datasource.embedded.<unknown>#getConnection(username,password)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "Connection",
    "signature": "public Connection getConnection(String username, String password)",
    "source_code": "\t\tpublic Connection getConnection(String username, String password) throws SQLException {\n\t\t\treturn this.dataSource.getConnection(username, password);\n\t\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#containsSqlScriptDelimiters(script,delimiter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the provided SQL script contains the specified delimiter.\n\t * <p>This method is intended to be used to find the string delimiting each\n\t * SQL statement &mdash; for example, a ';' character.\n\t * <p>Any occurrence of the delimiter within the script will be ignored if it\n\t * is within a <em>literal</em> block of text enclosed in single quotes\n\t * ({@code '}) or double quotes ({@code \"}), if it is escaped with a backslash\n\t * ({@code \\}), or if it is within a single-line comment or block comment.\n\t * @param script the SQL script to search within\n\t * @param delimiter the statement delimiter to search for\n\t * @see #DEFAULT_COMMENT_PREFIXES\n\t * @see #DEFAULT_BLOCK_COMMENT_START_DELIMITER\n\t * @see #DEFAULT_BLOCK_COMMENT_END_DELIMITER\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "boolean",
    "signature": "public boolean containsSqlScriptDelimiters(String script, String delimiter)",
    "source_code": "\tpublic static boolean containsSqlScriptDelimiters(String script, String delimiter) {\n\t\treturn containsStatementSeparator(null, script, delimiter, DEFAULT_COMMENT_PREFIXES,\n\t\t\tDEFAULT_BLOCK_COMMENT_START_DELIMITER, DEFAULT_BLOCK_COMMENT_END_DELIMITER);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#executeSqlScript(connection,resource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the given SQL script using default settings for statement\n\t * separators, comment delimiters, and exception handling flags.\n\t * <p>Statement separators and comments will be removed before executing\n\t * individual statements within the supplied script.\n\t * <p><strong>Warning</strong>: this method does <em>not</em> release the\n\t * provided {@link Connection}.\n\t * @param connection the JDBC connection to use to execute the script; already\n\t * configured and ready to use\n\t * @param resource the resource (potentially associated with a specific encoding)\n\t * to load the SQL script from\n\t * @throws ScriptException if an error occurred while executing the SQL script\n\t * @see #executeSqlScript(Connection, EncodedResource, boolean, boolean, String, String, String, String)\n\t * @see #DEFAULT_STATEMENT_SEPARATOR\n\t * @see #DEFAULT_COMMENT_PREFIX\n\t * @see #DEFAULT_BLOCK_COMMENT_START_DELIMITER\n\t * @see #DEFAULT_BLOCK_COMMENT_END_DELIMITER\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#getConnection\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#releaseConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connection",
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void executeSqlScript(Connection connection, EncodedResource resource)",
    "source_code": "\tpublic static void executeSqlScript(Connection connection, EncodedResource resource) throws ScriptException {\n\t\texecuteSqlScript(connection, resource, false, false, DEFAULT_COMMENT_PREFIX, DEFAULT_STATEMENT_SEPARATOR,\n\t\t\t\tDEFAULT_BLOCK_COMMENT_START_DELIMITER, DEFAULT_BLOCK_COMMENT_END_DELIMITER);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#executeSqlScript(connection,resource,continueOnError,ignoreFailedDrops,commentPrefix,separator,blockCommentStartDelimiter,blockCommentEndDelimiter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the given SQL script.\n\t * <p>Statement separators and comments will be removed before executing\n\t * individual statements within the supplied script.\n\t * <p><strong>Warning</strong>: this method does <em>not</em> release the\n\t * provided {@link Connection}.\n\t * @param connection the JDBC connection to use to execute the script; already\n\t * configured and ready to use\n\t * @param resource the resource (potentially associated with a specific encoding)\n\t * to load the SQL script from\n\t * @param continueOnError whether to continue without throwing an exception\n\t * in the event of an error\n\t * @param ignoreFailedDrops whether to continue in the event of specifically\n\t * an error on a {@code DROP} statement\n\t * @param commentPrefix the prefix that identifies single-line comments in the\n\t * SQL script (typically \"--\")\n\t * @param separator the script statement separator; defaults to\n\t * {@value #DEFAULT_STATEMENT_SEPARATOR} if not specified and falls back to\n\t * {@value #FALLBACK_STATEMENT_SEPARATOR} as a last resort; may be set to\n\t * {@value #EOF_STATEMENT_SEPARATOR} to signal that the script contains a\n\t * single statement without a separator\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @throws ScriptException if an error occurred while executing the SQL script\n\t * @see #DEFAULT_STATEMENT_SEPARATOR\n\t * @see #FALLBACK_STATEMENT_SEPARATOR\n\t * @see #EOF_STATEMENT_SEPARATOR\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#getConnection\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#releaseConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connection",
      "resource",
      "continueOnError",
      "ignoreFailedDrops",
      "commentPrefix",
      "separator",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError,\n\t\t\tboolean ignoreFailedDrops, String commentPrefix, @Nullable String separator,\n\t\t\tString blockCommentStartDelimiter, String blockCommentEndDelimiter)",
    "source_code": "\tpublic static void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError,\n\t\t\tboolean ignoreFailedDrops, String commentPrefix, @Nullable String separator,\n\t\t\tString blockCommentStartDelimiter, String blockCommentEndDelimiter) throws ScriptException {\n\n\t\texecuteSqlScript(connection, resource, continueOnError, ignoreFailedDrops,\n\t\t\t\tnew String[] { commentPrefix }, separator, blockCommentStartDelimiter,\n\t\t\t\tblockCommentEndDelimiter);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#executeSqlScript(connection,resource,continueOnError,ignoreFailedDrops,commentPrefixes,separator,blockCommentStartDelimiter,blockCommentEndDelimiter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the given SQL script.\n\t * <p>Statement separators and comments will be removed before executing\n\t * individual statements within the supplied script.\n\t * <p><strong>Warning</strong>: this method does <em>not</em> release the\n\t * provided {@link Connection}.\n\t * @param connection the JDBC connection to use to execute the script; already\n\t * configured and ready to use\n\t * @param resource the resource (potentially associated with a specific encoding)\n\t * to load the SQL script from\n\t * @param continueOnError whether to continue without throwing an exception\n\t * in the event of an error\n\t * @param ignoreFailedDrops whether to continue in the event of specifically\n\t * an error on a {@code DROP} statement\n\t * @param commentPrefixes the prefixes that identify single-line comments in the\n\t * SQL script (typically \"--\")\n\t * @param separator the script statement separator; defaults to\n\t * {@value #DEFAULT_STATEMENT_SEPARATOR} if not specified and falls back to\n\t * {@value #FALLBACK_STATEMENT_SEPARATOR} as a last resort; may be set to\n\t * {@value #EOF_STATEMENT_SEPARATOR} to signal that the script contains a\n\t * single statement without a separator\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @throws ScriptException if an error occurred while executing the SQL script\n\t * @since 5.2\n\t * @see #DEFAULT_STATEMENT_SEPARATOR\n\t * @see #FALLBACK_STATEMENT_SEPARATOR\n\t * @see #EOF_STATEMENT_SEPARATOR\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#getConnection\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#releaseConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connection",
      "resource",
      "continueOnError",
      "ignoreFailedDrops",
      "commentPrefixes",
      "separator",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "void",
    "signature": "public void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError,\n\t\t\tboolean ignoreFailedDrops, String[] commentPrefixes, @Nullable String separator,\n\t\t\tString blockCommentStartDelimiter, String blockCommentEndDelimiter)",
    "source_code": "\tpublic static void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError,\n\t\t\tboolean ignoreFailedDrops, String[] commentPrefixes, @Nullable String separator,\n\t\t\tString blockCommentStartDelimiter, String blockCommentEndDelimiter) throws ScriptException {\n\n\t\ttry {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Executing SQL script from \" + resource);\n\t\t\t}\n\t\t\tlong startTime = System.currentTimeMillis();\n\n\t\t\tString script;\n\t\t\ttry {\n\t\t\t\tscript = readScript(resource, separator, commentPrefixes, blockCommentEndDelimiter);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new CannotReadScriptException(resource, ex);\n\t\t\t}\n\n\t\t\tif (separator == null) {\n\t\t\t\tseparator = DEFAULT_STATEMENT_SEPARATOR;\n\t\t\t}\n\t\t\tif (!EOF_STATEMENT_SEPARATOR.equals(separator) &&\n\t\t\t\t\t!containsStatementSeparator(resource, script, separator, commentPrefixes,\n\t\t\t\t\t\tblockCommentStartDelimiter, blockCommentEndDelimiter)) {\n\t\t\t\tseparator = FALLBACK_STATEMENT_SEPARATOR;\n\t\t\t}\n\n\t\t\tList<String> statements = new ArrayList<>();\n\t\t\tsplitSqlScript(resource, script, separator, commentPrefixes, blockCommentStartDelimiter,\n\t\t\t\t\tblockCommentEndDelimiter, statements);\n\n\t\t\tint stmtNumber = 0;\n\t\t\tStatement stmt = connection.createStatement();\n\t\t\ttry {\n\t\t\t\tfor (String statement : statements) {\n\t\t\t\t\tstmtNumber++;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tstmt.execute(statement);\n\t\t\t\t\t\tint rowsAffected = stmt.getUpdateCount();\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(rowsAffected + \" returned as update count for SQL: \" + statement);\n\t\t\t\t\t\t\tSQLWarning warningToLog = stmt.getWarnings();\n\t\t\t\t\t\t\twhile (warningToLog != null) {\n\t\t\t\t\t\t\t\tlogger.debug(\"SQLWarning ignored: SQL state '\" + warningToLog.getSQLState() +\n\t\t\t\t\t\t\t\t\t\t\"', error code '\" + warningToLog.getErrorCode() +\n\t\t\t\t\t\t\t\t\t\t\"', message [\" + warningToLog.getMessage() + \"]\");\n\t\t\t\t\t\t\t\twarningToLog = warningToLog.getNextWarning();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException ex) {\n\t\t\t\t\t\tboolean dropStatement = StringUtils.startsWithIgnoreCase(statement.trim(), \"drop\");\n\t\t\t\t\t\tif (continueOnError || (dropStatement && ignoreFailedDrops)) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(ScriptStatementFailedException.buildErrorMessage(statement, stmtNumber, resource), ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new ScriptStatementFailedException(statement, stmtNumber, resource, ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttry {\n\t\t\t\t\tstmt.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tlogger.trace(\"Could not close JDBC Statement\", ex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong elapsedTime = System.currentTimeMillis() - startTime;\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Executed SQL script from \" + resource + \" in \" + elapsedTime + \" ms.\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (ex instanceof ScriptException scriptException) {\n\t\t\t\tthrow scriptException;\n\t\t\t}\n\t\t\tthrow new UncategorizedScriptException(\n\t\t\t\t\"Failed to execute database script from resource [\" + resource + \"]\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#readScript(lineNumberReader,commentPrefix,separator,blockCommentEndDelimiter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Read a script from the provided {@code LineNumberReader}, using the supplied\n\t * comment prefix and statement separator, and build a {@code String} containing\n\t * the lines.\n\t * <p>Lines <em>beginning</em> with the comment prefix are excluded from the\n\t * results; however, line comments anywhere else &mdash; for example, within\n\t * a statement &mdash; will be included in the results.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @param commentPrefix the prefix that identifies comments in the SQL script\n\t * (typically \"--\")\n\t * @param separator the statement separator in the SQL script (typically \";\")\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @return a {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lineNumberReader",
      "commentPrefix",
      "separator",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "String",
    "signature": "public String readScript(LineNumberReader lineNumberReader, @Nullable String commentPrefix,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter)",
    "source_code": "\tpublic static String readScript(LineNumberReader lineNumberReader, @Nullable String commentPrefix,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter) throws IOException {\n\n\t\tString[] commentPrefixes = (commentPrefix != null) ? new String[] { commentPrefix } : null;\n\t\treturn readScript(lineNumberReader, commentPrefixes, separator, blockCommentEndDelimiter);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#readScript(lineNumberReader,commentPrefixes,separator,blockCommentEndDelimiter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Read a script from the provided {@code LineNumberReader}, using the supplied\n\t * comment prefixes and statement separator, and build a {@code String} containing\n\t * the lines.\n\t * <p>Lines <em>beginning</em> with one of the comment prefixes are excluded\n\t * from the results; however, line comments anywhere else &mdash; for example,\n\t * within a statement &mdash; will be included in the results.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @param commentPrefixes the prefixes that identify comments in the SQL script\n\t * (typically \"--\")\n\t * @param separator the statement separator in the SQL script (typically \";\")\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @return a {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t * @since 5.2\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lineNumberReader",
      "commentPrefixes",
      "separator",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "String",
    "signature": "public String readScript(LineNumberReader lineNumberReader, @Nullable String[] commentPrefixes,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter)",
    "source_code": "\tpublic static String readScript(LineNumberReader lineNumberReader, @Nullable String[] commentPrefixes,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter) throws IOException {\n\n\t\tString currentStatement = lineNumberReader.readLine();\n\t\tStringBuilder scriptBuilder = new StringBuilder();\n\t\twhile (currentStatement != null) {\n\t\t\tif ((blockCommentEndDelimiter != null && currentStatement.contains(blockCommentEndDelimiter)) ||\n\t\t\t\t(commentPrefixes != null && !startsWithAny(currentStatement, commentPrefixes, 0))) {\n\t\t\t\tif (scriptBuilder.length() > 0) {\n\t\t\t\t\tscriptBuilder.append('\\n');\n\t\t\t\t}\n\t\t\t\tscriptBuilder.append(currentStatement);\n\t\t\t}\n\t\t\tcurrentStatement = lineNumberReader.readLine();\n\t\t}\n\t\tappendSeparatorToScriptIfNecessary(scriptBuilder, separator);\n\t\treturn scriptBuilder.toString();\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#splitSqlScript(resource,script,separator,commentPrefix,blockCommentStartDelimiter,blockCommentEndDelimiter,statements)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within the script, the provided {@code commentPrefix} will be honored:\n\t * any text beginning with the comment prefix and extending to the end of the\n\t * line will be omitted from the output. Similarly, the provided\n\t * {@code blockCommentStartDelimiter} and {@code blockCommentEndDelimiter}\n\t * delimiters will be honored: any text enclosed in a block comment will be\n\t * omitted from the output. In addition, multiple adjacent whitespace characters\n\t * will be collapsed into a single space.\n\t * @param resource the resource from which the script was read\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param commentPrefix the prefix that identifies SQL line comments\n\t * (typically \"--\")\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "script",
      "separator",
      "commentPrefix",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 595
    },
    "return": "void",
    "signature": "public void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String commentPrefix, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String commentPrefix, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements) throws ScriptException {\n\n\t\tAssert.hasText(commentPrefix, \"'commentPrefix' must not be null or empty\");\n\t\tsplitSqlScript(resource, script, separator, new String[] { commentPrefix },\n\t\t\t\tblockCommentStartDelimiter, blockCommentEndDelimiter, statements);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#splitSqlScript(resource,script,separator,commentPrefixes,blockCommentStartDelimiter,blockCommentEndDelimiter,statements)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within the script, the provided {@code commentPrefixes} will be honored:\n\t * any text beginning with one of the comment prefixes and extending to the\n\t * end of the line will be omitted from the output. Similarly, the provided\n\t * {@code blockCommentStartDelimiter} and {@code blockCommentEndDelimiter}\n\t * delimiters will be honored: any text enclosed in a block comment will be\n\t * omitted from the output. In addition, multiple adjacent whitespace characters\n\t * will be collapsed into a single space.\n\t * @param resource the resource from which the script was read\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param commentPrefixes the prefixes that identify SQL line comments\n\t * (typically \"--\")\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @since 5.2\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "script",
      "separator",
      "commentPrefixes",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "void",
    "signature": "public void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String[] commentPrefixes, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String[] commentPrefixes, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements) throws ScriptException {\n\n\t\tAssert.hasText(script, \"'script' must not be null or empty\");\n\t\tAssert.notNull(separator, \"'separator' must not be null\");\n\t\tAssert.notEmpty(commentPrefixes, \"'commentPrefixes' must not be null or empty\");\n\t\tfor (String commentPrefix : commentPrefixes) {\n\t\t\tAssert.hasText(commentPrefix, \"'commentPrefixes' must not contain null or empty elements\");\n\t\t}\n\t\tAssert.hasText(blockCommentStartDelimiter, \"'blockCommentStartDelimiter' must not be null or empty\");\n\t\tAssert.hasText(blockCommentEndDelimiter, \"'blockCommentEndDelimiter' must not be null or empty\");\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean inSingleQuote = false;\n\t\tboolean inDoubleQuote = false;\n\t\tboolean inEscape = false;\n\n\t\tfor (int i = 0; i < script.length(); i++) {\n\t\t\tchar c = script.charAt(i);\n\t\t\tif (inEscape) {\n\t\t\t\tinEscape = false;\n\t\t\t\tsb.append(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// MySQL style escapes\n\t\t\tif (c == '\\\\') {\n\t\t\t\tinEscape = true;\n\t\t\t\tsb.append(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!inDoubleQuote && (c == '\\'')) {\n\t\t\t\tinSingleQuote = !inSingleQuote;\n\t\t\t}\n\t\t\telse if (!inSingleQuote && (c == '\"')) {\n\t\t\t\tinDoubleQuote = !inDoubleQuote;\n\t\t\t}\n\t\t\tif (!inSingleQuote && !inDoubleQuote) {\n\t\t\t\tif (script.startsWith(separator, i)) {\n\t\t\t\t\t// We've reached the end of the current statement\n\t\t\t\t\tif (sb.length() > 0) {\n\t\t\t\t\t\tstatements.add(sb.toString());\n\t\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t\t}\n\t\t\t\t\ti += separator.length() - 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (startsWithAny(script, commentPrefixes, i)) {\n\t\t\t\t\t// Skip over any content from the start of the comment to the EOL\n\t\t\t\t\tint indexOfNextNewline = script.indexOf('\\n', i);\n\t\t\t\t\tif (indexOfNextNewline > i) {\n\t\t\t\t\t\ti = indexOfNextNewline;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// If there's no EOL, we must be at the end of the script, so stop here.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (script.startsWith(blockCommentStartDelimiter, i)) {\n\t\t\t\t\t// Skip over any block comments\n\t\t\t\t\tint indexOfCommentEnd = script.indexOf(blockCommentEndDelimiter, i);\n\t\t\t\t\tif (indexOfCommentEnd > i) {\n\t\t\t\t\t\ti = indexOfCommentEnd + blockCommentEndDelimiter.length() - 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new ScriptParseException(\n\t\t\t\t\t\t\t\t\"Missing block comment end delimiter: \" + blockCommentEndDelimiter, resource);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (c == ' ' || c == '\\r' || c == '\\n' || c == '\\t') {\n\t\t\t\t\t// Avoid multiple adjacent whitespace characters\n\t\t\t\t\tif (sb.length() > 0 && sb.charAt(sb.length() - 1) != ' ') {\n\t\t\t\t\t\tc = ' ';\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(c);\n\t\t}\n\n\t\tif (StringUtils.hasText(sb)) {\n\t\t\tstatements.add(sb.toString());\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#splitSqlScript(script,separator,statements)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the\n\t * provided {@code List}.\n\t * <p>Within the script, {@value #DEFAULT_COMMENT_PREFIX} will be used as the\n\t * comment prefix; any text beginning with the comment prefix and extending to\n\t * the end of the line will be omitted from the output. Similarly,\n\t * {@value #DEFAULT_BLOCK_COMMENT_START_DELIMITER} and\n\t * {@value #DEFAULT_BLOCK_COMMENT_END_DELIMITER} will be used as the\n\t * <em>start</em> and <em>end</em> block comment delimiters: any text enclosed\n\t * in a block comment will be omitted from the output. In addition, multiple\n\t * adjacent whitespace characters will be collapsed into a single space.\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @see #splitSqlScript(String, char, List)\n\t * @see #splitSqlScript(EncodedResource, String, String, String, String, String, List)\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "separator",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "void",
    "signature": "public void splitSqlScript(String script, String separator, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(String script, String separator, List<String> statements) throws ScriptException {\n\t\tsplitSqlScript(null, script, separator, DEFAULT_COMMENT_PREFIX, DEFAULT_BLOCK_COMMENT_START_DELIMITER,\n\t\t\t\tDEFAULT_BLOCK_COMMENT_END_DELIMITER, statements);\n\t}"
  },
  "org.springframework.jdbc.datasource.lookup.<unknown>#getConnection(username,password)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "Connection",
    "signature": "public Connection getConnection(String username, String password)",
    "source_code": "\tpublic Connection getConnection(String username, String password) throws SQLException {\n\t\treturn determineTargetDataSource().getConnection(username, password);\n\t}"
  },
  "org.springframework.jdbc.datasource.lookup.<unknown>#setTargetDataSources(Map<Object,targetDataSources)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the map of target DataSources, with the lookup key as key.\n\t * The mapped value can either be a corresponding {@link javax.sql.DataSource}\n\t * instance or a data source name String (to be resolved via a\n\t * {@link #setDataSourceLookup DataSourceLookup}).\n\t * <p>The key can be of arbitrary type; this class implements the\n\t * generic lookup process only. The concrete key representation will\n\t * be handled by {@link #resolveSpecifiedLookupKey(Object)} and\n\t * {@link #determineCurrentLookupKey()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Object",
      "targetDataSources"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "public void setTargetDataSources(Map<Object, Object> targetDataSources)",
    "source_code": "\tpublic void setTargetDataSources(Map<Object, Object> targetDataSources) {\n\t\tthis.targetDataSources = targetDataSources;\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#mapRow(rs,rowNum)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation of this method extracts a single value from the\n\t * single row returned by the function. If there are a different number\n\t * of rows returned, this is treated as an error.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "rowNum"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "T",
    "signature": "protected T mapRow(ResultSet rs, int rowNum)",
    "source_code": "\tprotected T mapRow(ResultSet rs, int rowNum) throws SQLException {\n\t\treturn this.rowMapper.mapRow(rs, rowNum);\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#createCustomException(task,sql,sqlEx,exceptionClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a custom {@link DataAccessException}, based on a given exception\n\t * class from a {@link CustomSQLErrorCodesTranslation} definition.\n\t * @param task readable text describing the task being attempted\n\t * @param sql the SQL query or update that caused the problem (may be {@code null})\n\t * @param sqlEx the offending SQLException\n\t * @param exceptionClass the exception class to use, as defined in the\n\t * {@link CustomSQLErrorCodesTranslation} definition\n\t * @return {@code null} if the custom exception could not be created, otherwise\n\t * the resulting {@link DataAccessException}. This exception should include the\n\t * {@code sqlEx} parameter as a nested root cause.\n\t * @see CustomSQLErrorCodesTranslation#setExceptionClass\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "sql",
      "sqlEx",
      "exceptionClass"
    ],
    "position": {
      "column": 1,
      "line": 329
    },
    "return": "DataAccessException",
    "signature": "protected DataAccessException createCustomException(String task, @Nullable String sql, SQLException sqlEx, Class<?> exceptionClass)",
    "source_code": "\tprotected DataAccessException createCustomException(\n\t\t\tString task, @Nullable String sql, SQLException sqlEx, Class<?> exceptionClass) {\n\n\t\t// Find appropriate constructor for the given exception class\n\t\ttry {\n\t\t\tint constructorType = 0;\n\t\t\tConstructor<?>[] constructors = exceptionClass.getConstructors();\n\t\t\tfor (Constructor<?> constructor : constructors) {\n\t\t\t\tClass<?>[] parameterTypes = constructor.getParameterTypes();\n\t\t\t\tif (parameterTypes.length == 1 && String.class == parameterTypes[0] &&\n\t\t\t\t\t\tconstructorType < MESSAGE_ONLY_CONSTRUCTOR) {\n\t\t\t\t\tconstructorType = MESSAGE_ONLY_CONSTRUCTOR;\n\t\t\t\t}\n\t\t\t\tif (parameterTypes.length == 2 && String.class == parameterTypes[0] &&\n\t\t\t\t\t\tThrowable.class == parameterTypes[1] &&\n\t\t\t\t\t\tconstructorType < MESSAGE_THROWABLE_CONSTRUCTOR) {\n\t\t\t\t\tconstructorType = MESSAGE_THROWABLE_CONSTRUCTOR;\n\t\t\t\t}\n\t\t\t\tif (parameterTypes.length == 2 && String.class == parameterTypes[0] &&\n\t\t\t\t\t\tSQLException.class == parameterTypes[1] &&\n\t\t\t\t\t\tconstructorType < MESSAGE_SQLEX_CONSTRUCTOR) {\n\t\t\t\t\tconstructorType = MESSAGE_SQLEX_CONSTRUCTOR;\n\t\t\t\t}\n\t\t\t\tif (parameterTypes.length == 3 && String.class == parameterTypes[0] &&\n\t\t\t\t\t\tString.class == parameterTypes[1] && Throwable.class == parameterTypes[2] &&\n\t\t\t\t\t\tconstructorType < MESSAGE_SQL_THROWABLE_CONSTRUCTOR) {\n\t\t\t\t\tconstructorType = MESSAGE_SQL_THROWABLE_CONSTRUCTOR;\n\t\t\t\t}\n\t\t\t\tif (parameterTypes.length == 3 && String.class == parameterTypes[0] &&\n\t\t\t\t\t\tString.class == parameterTypes[1] && SQLException.class == parameterTypes[2] &&\n\t\t\t\t\t\tconstructorType < MESSAGE_SQL_SQLEX_CONSTRUCTOR) {\n\t\t\t\t\tconstructorType = MESSAGE_SQL_SQLEX_CONSTRUCTOR;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// invoke constructor\n\t\t\tConstructor<?> exceptionConstructor;\n\t\t\treturn switch (constructorType) {\n\t\t\t\tcase MESSAGE_SQL_SQLEX_CONSTRUCTOR -> {\n\t\t\t\t\tClass<?>[] messageAndSqlAndSqlExArgsClass = new Class<?>[] {String.class, String.class, SQLException.class};\n\t\t\t\t\tObject[] messageAndSqlAndSqlExArgs = new Object[] {task, sql, sqlEx};\n\t\t\t\t\texceptionConstructor = exceptionClass.getConstructor(messageAndSqlAndSqlExArgsClass);\n\t\t\t\t\tyield (DataAccessException) exceptionConstructor.newInstance(messageAndSqlAndSqlExArgs);\n\t\t\t\t}\n\t\t\t\tcase MESSAGE_SQL_THROWABLE_CONSTRUCTOR -> {\n\t\t\t\t\tClass<?>[] messageAndSqlAndThrowableArgsClass = new Class<?>[] {String.class, String.class, Throwable.class};\n\t\t\t\t\tObject[] messageAndSqlAndThrowableArgs = new Object[] {task, sql, sqlEx};\n\t\t\t\t\texceptionConstructor = exceptionClass.getConstructor(messageAndSqlAndThrowableArgsClass);\n\t\t\t\t\tyield (DataAccessException) exceptionConstructor.newInstance(messageAndSqlAndThrowableArgs);\n\t\t\t\t}\n\t\t\t\tcase MESSAGE_SQLEX_CONSTRUCTOR -> {\n\t\t\t\t\tClass<?>[] messageAndSqlExArgsClass = new Class<?>[] {String.class, SQLException.class};\n\t\t\t\t\tObject[] messageAndSqlExArgs = new Object[] {task + \": \" + sqlEx.getMessage(), sqlEx};\n\t\t\t\t\texceptionConstructor = exceptionClass.getConstructor(messageAndSqlExArgsClass);\n\t\t\t\t\tyield (DataAccessException) exceptionConstructor.newInstance(messageAndSqlExArgs);\n\t\t\t\t}\n\t\t\t\tcase MESSAGE_THROWABLE_CONSTRUCTOR -> {\n\t\t\t\t\tClass<?>[] messageAndThrowableArgsClass = new Class<?>[] {String.class, Throwable.class};\n\t\t\t\t\tObject[] messageAndThrowableArgs = new Object[] {task + \": \" + sqlEx.getMessage(), sqlEx};\n\t\t\t\t\texceptionConstructor = exceptionClass.getConstructor(messageAndThrowableArgsClass);\n\t\t\t\t\tyield (DataAccessException)exceptionConstructor.newInstance(messageAndThrowableArgs);\n\t\t\t\t}\n\t\t\t\tcase MESSAGE_ONLY_CONSTRUCTOR -> {\n\t\t\t\t\tClass<?>[] messageOnlyArgsClass = new Class<?>[] {String.class};\n\t\t\t\t\tObject[] messageOnlyArgs = new Object[] {task + \": \" + sqlEx.getMessage()};\n\t\t\t\t\texceptionConstructor = exceptionClass.getConstructor(messageOnlyArgsClass);\n\t\t\t\t\tyield (DataAccessException) exceptionConstructor.newInstance(messageOnlyArgs);\n\t\t\t\t}\n\t\t\t\tdefault -> {\n\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\tlogger.warn(\"Unable to find appropriate constructor of custom exception class [\" +\n\t\t\t\t\t\t\t\texceptionClass.getName() + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tyield null;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Unable to instantiate custom exception class [\" + exceptionClass.getName() + \"]\", ex);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#customTranslate(task,sql,sqlEx)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can override this method to attempt a custom mapping from\n\t * {@link SQLException} to {@link DataAccessException}.\n\t * @param task readable text describing the task being attempted\n\t * @param sql the SQL query or update that caused the problem (may be {@code null})\n\t * @param sqlEx the offending SQLException\n\t * @return {@code null} if no custom translation applies, otherwise a {@link DataAccessException}\n\t * resulting from custom translation. This exception should include the {@code sqlEx} parameter\n\t * as a nested root cause. This implementation always returns {@code null}, meaning that the\n\t * translator always falls back to the default error codes.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "sql",
      "sqlEx"
    ],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "DataAccessException",
    "signature": "protected DataAccessException customTranslate(String task, @Nullable String sql, SQLException sqlEx)",
    "source_code": "\tprotected DataAccessException customTranslate(String task, @Nullable String sql, SQLException sqlEx) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#doTranslate(task,sql,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "sql",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "DataAccessException",
    "signature": "protected DataAccessException doTranslate(String task, @Nullable String sql, SQLException ex)",
    "source_code": "\tprotected DataAccessException doTranslate(String task, @Nullable String sql, SQLException ex) {\n\t\tSQLException sqlEx = ex;\n\t\tif (sqlEx instanceof BatchUpdateException && sqlEx.getNextException() != null) {\n\t\t\tSQLException nestedSqlEx = sqlEx.getNextException();\n\t\t\tif (nestedSqlEx.getErrorCode() > 0 || nestedSqlEx.getSQLState() != null) {\n\t\t\t\tsqlEx = nestedSqlEx;\n\t\t\t}\n\t\t}\n\n\t\t// First, try custom translation from overridden method.\n\t\tDataAccessException dae = customTranslate(task, sql, sqlEx);\n\t\tif (dae != null) {\n\t\t\treturn dae;\n\t\t}\n\n\t\t// Next, try the custom SQLException translator, if available.\n\t\tSQLErrorCodes sqlErrorCodes = getSqlErrorCodes();\n\t\tif (sqlErrorCodes != null) {\n\t\t\tSQLExceptionTranslator customTranslator = sqlErrorCodes.getCustomSqlExceptionTranslator();\n\t\t\tif (customTranslator != null) {\n\t\t\t\tDataAccessException customDex = customTranslator.translate(task, sql, sqlEx);\n\t\t\t\tif (customDex != null) {\n\t\t\t\t\treturn customDex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check SQLErrorCodes with corresponding error code, if available.\n\t\tif (sqlErrorCodes != null) {\n\t\t\tString errorCode;\n\t\t\tif (sqlErrorCodes.isUseSqlStateForTranslation()) {\n\t\t\t\terrorCode = sqlEx.getSQLState();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Try to find SQLException with actual error code, looping through the causes.\n\t\t\t\t// E.g. applicable to java.sql.DataTruncation as of JDK 1.6.\n\t\t\t\tSQLException current = sqlEx;\n\t\t\t\twhile (current.getErrorCode() == 0 && current.getCause() instanceof SQLException sqlException) {\n\t\t\t\t\tcurrent = sqlException;\n\t\t\t\t}\n\t\t\t\terrorCode = Integer.toString(current.getErrorCode());\n\t\t\t}\n\n\t\t\tif (errorCode != null) {\n\t\t\t\t// Look for defined custom translations first.\n\t\t\t\tCustomSQLErrorCodesTranslation[] customTranslations = sqlErrorCodes.getCustomTranslations();\n\t\t\t\tif (customTranslations != null) {\n\t\t\t\t\tfor (CustomSQLErrorCodesTranslation customTranslation : customTranslations) {\n\t\t\t\t\t\tif (Arrays.binarySearch(customTranslation.getErrorCodes(), errorCode) >= 0 &&\n\t\t\t\t\t\t\t\tcustomTranslation.getExceptionClass() != null) {\n\t\t\t\t\t\t\tDataAccessException customException = createCustomException(\n\t\t\t\t\t\t\t\t\ttask, sql, sqlEx, customTranslation.getExceptionClass());\n\t\t\t\t\t\t\tif (customException != null) {\n\t\t\t\t\t\t\t\tlogTranslation(task, sql, sqlEx, true);\n\t\t\t\t\t\t\t\treturn customException;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Next, look for grouped error codes.\n\t\t\t\tif (Arrays.binarySearch(sqlErrorCodes.getBadSqlGrammarCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new BadSqlGrammarException(task, (sql != null ? sql : \"\"), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getInvalidResultSetAccessCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new InvalidResultSetAccessException(task, (sql != null ? sql : \"\"), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getDuplicateKeyCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new DuplicateKeyException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getDataIntegrityViolationCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new DataIntegrityViolationException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getPermissionDeniedCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new PermissionDeniedDataAccessException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getDataAccessResourceFailureCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new DataAccessResourceFailureException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getTransientDataAccessResourceCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new TransientDataAccessResourceException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getCannotAcquireLockCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new CannotAcquireLockException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getDeadlockLoserCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new org.springframework.dao.DeadlockLoserDataAccessException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getCannotSerializeTransactionCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new org.springframework.dao.CannotSerializeTransactionException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// We couldn't identify it more precisely - let's hand it over to the SQLState fallback translator.\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tString codes;\n\t\t\tif (sqlErrorCodes != null && sqlErrorCodes.isUseSqlStateForTranslation()) {\n\t\t\t\tcodes = \"SQL state '\" + sqlEx.getSQLState() + \"', error code '\" + sqlEx.getErrorCode();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcodes = \"Error code '\" + sqlEx.getErrorCode() + \"'\";\n\t\t\t}\n\t\t\tlogger.debug(\"Unable to translate SQLException with \" + codes + \", will now try the fallback translator\");\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#extractDatabaseMetaData(dataSource,action)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extract database meta-data via the given DatabaseMetaDataCallback.\n\t * <p>This method will open a connection to the database and retrieve its meta-data.\n\t * Since this method is called before the exception translation feature is configured\n\t * for a DataSource, this method can not rely on SQLException translation itself.\n\t * <p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked\n\t * exception and any calling code should catch and handle this exception. You can just\n\t * log the error and hope for the best, but there is probably a more serious error that\n\t * will reappear when you try to access the database again.\n\t * @param dataSource the DataSource to extract meta-data for\n\t * @param action callback that will do the actual work\n\t * @return object containing the extracted information, as returned by\n\t * the DatabaseMetaDataCallback's {@code processMetaData} method\n\t * @throws MetaDataAccessException if meta-data access failed\n\t * @see java.sql.DatabaseMetaData\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataSource",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "T",
    "signature": "public T extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback<T> action)",
    "source_code": "\tpublic static <T> T extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback<T> action)\n\t\t\tthrows MetaDataAccessException {\n\n\t\tConnection con = null;\n\t\ttry {\n\t\t\tcon = DataSourceUtils.getConnection(dataSource);\n\t\t\tDatabaseMetaData metaData;\n\t\t\ttry {\n\t\t\t\tmetaData = con.getMetaData();\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\tif (DataSourceUtils.isConnectionTransactional(con, dataSource)) {\n\t\t\t\t\t// Probably a closed thread-bound Connection - retry against fresh Connection\n\t\t\t\t\tDataSourceUtils.releaseConnection(con, dataSource);\n\t\t\t\t\tcon = null;\n\t\t\t\t\tlogger.debug(\"Failed to obtain DatabaseMetaData from transactional Connection - \" +\n\t\t\t\t\t\t\t\"retrying against fresh Connection\", ex);\n\t\t\t\t\tcon = dataSource.getConnection();\n\t\t\t\t\tmetaData = con.getMetaData();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (metaData == null) {\n\t\t\t\t// should only happen in test environments\n\t\t\t\tthrow new MetaDataAccessException(\"DatabaseMetaData returned by Connection [\" + con + \"] was null\");\n\t\t\t}\n\t\t\treturn action.processMetaData(metaData);\n\t\t}\n\t\tcatch (CannotGetJdbcConnectionException ex) {\n\t\t\tthrow new MetaDataAccessException(\"Could not get Connection for extracting meta-data\", ex);\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tthrow new MetaDataAccessException(\"Error while extracting DatabaseMetaData\", ex);\n\t\t}\n\t\tcatch (AbstractMethodError err) {\n\t\t\tthrow new MetaDataAccessException(\n\t\t\t\t\t\"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver\", err);\n\t\t}\n\t\tfinally {\n\t\t\tDataSourceUtils.releaseConnection(con, dataSource);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#extractDatabaseMetaData(dataSource,metaDataMethodName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Call the specified method on DatabaseMetaData for the given DataSource,\n\t * and extract the invocation result.\n\t * @param dataSource the DataSource to extract meta-data for\n\t * @param metaDataMethodName the name of the DatabaseMetaData method to call\n\t * @return the object returned by the specified DatabaseMetaData method\n\t * @throws MetaDataAccessException if we couldn't access the DatabaseMetaData\n\t * or failed to invoke the specified method\n\t * @see java.sql.DatabaseMetaData\n\t * @deprecated as of 5.2.9, in favor of\n\t * {@link #extractDatabaseMetaData(DataSource, DatabaseMetaDataCallback)}\n\t * with a lambda expression or method reference and a generically typed result\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataSource",
      "metaDataMethodName"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "T",
    "signature": "public T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)",
    "source_code": "\tpublic static <T> T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)\n\t\t\tthrows MetaDataAccessException {\n\n\t\treturn (T) extractDatabaseMetaData(dataSource,\n\t\t\t\tdbmd -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn DatabaseMetaData.class.getMethod(metaDataMethodName).invoke(dbmd);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\tthrow new MetaDataAccessException(\"No method named '\" + metaDataMethodName +\n\t\t\t\t\t\t\t\t\"' found on DatabaseMetaData instance [\" + dbmd + \"]\", ex);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\t\t\tthrow new MetaDataAccessException(\n\t\t\t\t\t\t\t\t\"Could not access DatabaseMetaData method '\" + metaDataMethodName + \"'\", ex);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\t\tif (ex.getTargetException() instanceof SQLException sqlException) {\n\t\t\t\t\t\t\tthrow sqlException;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new MetaDataAccessException(\n\t\t\t\t\t\t\t\t\"Invocation of DatabaseMetaData method '\" + metaDataMethodName + \"' failed\", ex);\n\t\t\t\t\t}\n\t\t\t\t});\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#getResultSetValue(rs,index)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC column value from a ResultSet, using the most appropriate\n\t * value type. The returned value should be a detached value object, not having\n\t * any ties to the active ResultSet: in particular, it should not be a Blob or\n\t * Clob object but rather a byte array or String representation, respectively.\n\t * <p>Uses the {@code getObject(index)} method, but includes additional \"hacks\"\n\t * to get around Oracle 10g returning a non-standard object for its TIMESTAMP\n\t * datatype and a {@code java.sql.Date} for DATE columns leaving out the\n\t * time portion: These columns will explicitly be extracted as standard\n\t * {@code java.sql.Timestamp} object.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @return the value object\n\t * @throws SQLException if thrown by the JDBC API\n\t * @see java.sql.Blob\n\t * @see java.sql.Clob\n\t * @see java.sql.Timestamp\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "index"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "Object",
    "signature": "public Object getResultSetValue(ResultSet rs, int index)",
    "source_code": "\tpublic static Object getResultSetValue(ResultSet rs, int index) throws SQLException {\n\t\tObject obj = rs.getObject(index);\n\t\tString className = null;\n\t\tif (obj != null) {\n\t\t\tclassName = obj.getClass().getName();\n\t\t}\n\t\tif (obj instanceof Blob blob) {\n\t\t\tobj = blob.getBytes(1, (int) blob.length());\n\t\t}\n\t\telse if (obj instanceof Clob clob) {\n\t\t\tobj = clob.getSubString(1, (int) clob.length());\n\t\t}\n\t\telse if (\"oracle.sql.TIMESTAMP\".equals(className) || \"oracle.sql.TIMESTAMPTZ\".equals(className)) {\n\t\t\tobj = rs.getTimestamp(index);\n\t\t}\n\t\telse if (className != null && className.startsWith(\"oracle.sql.DATE\")) {\n\t\t\tString metaDataClassName = rs.getMetaData().getColumnClassName(index);\n\t\t\tif (\"java.sql.Timestamp\".equals(metaDataClassName) || \"oracle.sql.TIMESTAMP\".equals(metaDataClassName)) {\n\t\t\t\tobj = rs.getTimestamp(index);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tobj = rs.getDate(index);\n\t\t\t}\n\t\t}\n\t\telse if (obj instanceof java.sql.Date) {\n\t\t\tif (\"java.sql.Timestamp\".equals(rs.getMetaData().getColumnClassName(index))) {\n\t\t\t\tobj = rs.getTimestamp(index);\n\t\t\t}\n\t\t}\n\t\treturn obj;\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#getResultSetValue(rs,index,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC column value from a ResultSet, using the specified value type.\n\t * <p>Uses the specifically typed ResultSet accessor methods, falling back to\n\t * {@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types.\n\t * <p>Note that the returned value may not be assignable to the specified\n\t * required type, in case of an unknown type. Calling code needs to deal\n\t * with this case appropriately, e.g. throwing a corresponding exception.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @param requiredType the required value type (may be {@code null})\n\t * @return the value object (possibly not of the specified required type,\n\t * with further conversion steps necessary)\n\t * @throws SQLException if thrown by the JDBC API\n\t * @see #getResultSetValue(ResultSet, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "index",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "Object",
    "signature": "public Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType)",
    "source_code": "\tpublic static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {\n\t\tif (requiredType == null) {\n\t\t\treturn getResultSetValue(rs, index);\n\t\t}\n\n\t\tObject value;\n\n\t\t// Explicitly extract typed value, as far as possible.\n\t\tif (String.class == requiredType) {\n\t\t\treturn rs.getString(index);\n\t\t}\n\t\telse if (boolean.class == requiredType || Boolean.class == requiredType) {\n\t\t\tvalue = rs.getBoolean(index);\n\t\t}\n\t\telse if (byte.class == requiredType || Byte.class == requiredType) {\n\t\t\tvalue = rs.getByte(index);\n\t\t}\n\t\telse if (short.class == requiredType || Short.class == requiredType) {\n\t\t\tvalue = rs.getShort(index);\n\t\t}\n\t\telse if (int.class == requiredType || Integer.class == requiredType) {\n\t\t\tvalue = rs.getInt(index);\n\t\t}\n\t\telse if (long.class == requiredType || Long.class == requiredType) {\n\t\t\tvalue = rs.getLong(index);\n\t\t}\n\t\telse if (float.class == requiredType || Float.class == requiredType) {\n\t\t\tvalue = rs.getFloat(index);\n\t\t}\n\t\telse if (double.class == requiredType || Double.class == requiredType ||\n\t\t\t\tNumber.class == requiredType) {\n\t\t\tvalue = rs.getDouble(index);\n\t\t}\n\t\telse if (BigDecimal.class == requiredType) {\n\t\t\treturn rs.getBigDecimal(index);\n\t\t}\n\t\telse if (java.sql.Date.class == requiredType) {\n\t\t\treturn rs.getDate(index);\n\t\t}\n\t\telse if (java.sql.Time.class == requiredType) {\n\t\t\treturn rs.getTime(index);\n\t\t}\n\t\telse if (java.sql.Timestamp.class == requiredType || java.util.Date.class == requiredType) {\n\t\t\treturn rs.getTimestamp(index);\n\t\t}\n\t\telse if (byte[].class == requiredType) {\n\t\t\treturn rs.getBytes(index);\n\t\t}\n\t\telse if (Blob.class == requiredType) {\n\t\t\treturn rs.getBlob(index);\n\t\t}\n\t\telse if (Clob.class == requiredType) {\n\t\t\treturn rs.getClob(index);\n\t\t}\n\t\telse if (requiredType.isEnum()) {\n\t\t\t// Enums can either be represented through a String or an enum index value:\n\t\t\t// leave enum type conversion up to the caller (e.g. a ConversionService)\n\t\t\t// but make sure that we return nothing other than a String or an Integer.\n\t\t\tObject obj = rs.getObject(index);\n\t\t\tif (obj instanceof String) {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t\telse if (obj instanceof Number number) {\n\t\t\t\t// Defensively convert any Number to an Integer (as needed by our\n\t\t\t\t// ConversionService's IntegerToEnumConverterFactory) for use as index\n\t\t\t\treturn NumberUtils.convertNumberToTargetClass(number, Integer.class);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// e.g. on Postgres: getObject returns a PGObject but we need a String\n\t\t\t\treturn rs.getString(index);\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\t// Some unknown type desired -> rely on getObject.\n\t\t\ttry {\n\t\t\t\treturn rs.getObject(index, requiredType);\n\t\t\t}\n\t\t\tcatch (AbstractMethodError err) {\n\t\t\t\tlogger.debug(\"JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method\", err);\n\t\t\t}\n\t\t\tcatch (SQLFeatureNotSupportedException ex) {\n\t\t\t\tlogger.debug(\"JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method\", ex);\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\tlogger.debug(\"JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method\", ex);\n\t\t\t}\n\n\t\t\t// Corresponding SQL types for JSR-310 / Joda-Time types, left up\n\t\t\t// to the caller to convert them (e.g. through a ConversionService).\n\t\t\tString typeName = requiredType.getSimpleName();\n\t\t\tif (\"LocalDate\".equals(typeName)) {\n\t\t\t\treturn rs.getDate(index);\n\t\t\t}\n\t\t\telse if (\"LocalTime\".equals(typeName)) {\n\t\t\t\treturn rs.getTime(index);\n\t\t\t}\n\t\t\telse if (\"LocalDateTime\".equals(typeName)) {\n\t\t\t\treturn rs.getTimestamp(index);\n\t\t\t}\n\n\t\t\t// Fall back to getObject without type specification, again\n\t\t\t// left up to the caller to convert the value if necessary.\n\t\t\treturn getResultSetValue(rs, index);\n\t\t}\n\n\t\t// Perform was-null check if necessary (for results that the JDBC driver returns as primitives).\n\t\treturn (rs.wasNull() ? null : value);\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#lookupColumnName(resultSetMetaData,columnIndex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the column name to use. The column name is determined based on a\n\t * lookup using ResultSetMetaData.\n\t * <p>This method implementation takes into account recent clarifications\n\t * expressed in the JDBC 4.0 specification:\n\t * <p><i>columnLabel - the label for the column specified with the SQL AS clause.\n\t * If the SQL AS clause was not specified, then the label is the name of the column</i>.\n\t * @param resultSetMetaData the current meta-data to use\n\t * @param columnIndex the index of the column for the lookup\n\t * @return the column name to use\n\t * @throws SQLException in case of lookup failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resultSetMetaData",
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "String",
    "signature": "public String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex)",
    "source_code": "\tpublic static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {\n\t\tString name = resultSetMetaData.getColumnLabel(columnIndex);\n\t\tif (!StringUtils.hasLength(name)) {\n\t\t\tname = resultSetMetaData.getColumnName(columnIndex);\n\t\t}\n\t\treturn name;\n\t}"
  },
  "org.springframework.jms.annotation.<unknown>#createInvocableHandlerMethod(bean,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "InvocableHandlerMethod",
    "signature": "public InvocableHandlerMethod createInvocableHandlerMethod(Object bean, Method method)",
    "source_code": "\t\tpublic InvocableHandlerMethod createInvocableHandlerMethod(Object bean, Method method) {\n\t\t\treturn getMessageHandlerMethodFactory().createInvocableHandlerMethod(bean, method);\n\t\t}"
  },
  "org.springframework.jms.annotation.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (bean instanceof AopInfrastructureBean || bean instanceof JmsListenerContainerFactory ||\n\t\t\t\tbean instanceof JmsListenerEndpointRegistry) {\n\t\t\t// Ignore AOP infrastructure such as scoped proxies.\n\t\t\treturn bean;\n\t\t}\n\n\t\tClass<?> targetClass = AopProxyUtils.ultimateTargetClass(bean);\n\t\tif (!this.nonAnnotatedClasses.contains(targetClass) &&\n\t\t\t\tAnnotationUtils.isCandidateClass(targetClass, JmsListener.class)) {\n\t\t\tMap<Method, Set<JmsListener>> annotatedMethods = MethodIntrospector.selectMethods(targetClass,\n\t\t\t\t\t(MethodIntrospector.MetadataLookup<Set<JmsListener>>) method -> {\n\t\t\t\t\t\tSet<JmsListener> listenerMethods = AnnotatedElementUtils.getMergedRepeatableAnnotations(\n\t\t\t\t\t\t\t\tmethod, JmsListener.class, JmsListeners.class);\n\t\t\t\t\t\treturn (!listenerMethods.isEmpty() ? listenerMethods : null);\n\t\t\t\t\t});\n\t\t\tif (annotatedMethods.isEmpty()) {\n\t\t\t\tthis.nonAnnotatedClasses.add(targetClass);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"No @JmsListener annotations found on bean type: \" + targetClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Non-empty set of methods\n\t\t\t\tannotatedMethods.forEach((method, listeners) ->\n\t\t\t\t\t\tlisteners.forEach(listener -> processJmsListener(listener, method, bean)));\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(annotatedMethods.size() + \" @JmsListener methods processed on bean '\" + beanName +\n\t\t\t\t\t\t\t\"': \" + annotatedMethods);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.jms.annotation.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.jms.annotation.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t}"
  },
  "org.springframework.jms.annotation.<unknown>#processJmsListener(jmsListener,mostSpecificMethod,bean)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given {@link JmsListener} annotation on the given method,\n\t * registering a corresponding endpoint for the given bean instance.\n\t * @param jmsListener the annotation to process\n\t * @param mostSpecificMethod the annotated method\n\t * @param bean the instance to invoke the method on\n\t * @see #createMethodJmsListenerEndpoint()\n\t * @see JmsListenerEndpointRegistrar#registerEndpoint\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jmsListener",
      "mostSpecificMethod",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "protected void processJmsListener(JmsListener jmsListener, Method mostSpecificMethod, Object bean)",
    "source_code": "\tprotected void processJmsListener(JmsListener jmsListener, Method mostSpecificMethod, Object bean) {\n\t\tMethod invocableMethod = AopUtils.selectInvocableMethod(mostSpecificMethod, bean.getClass());\n\n\t\tMethodJmsListenerEndpoint endpoint = createMethodJmsListenerEndpoint();\n\t\tendpoint.setBean(bean);\n\t\tendpoint.setMethod(invocableMethod);\n\t\tendpoint.setMostSpecificMethod(mostSpecificMethod);\n\t\tendpoint.setMessageHandlerMethodFactory(this.messageHandlerMethodFactory);\n\t\tendpoint.setEmbeddedValueResolver(this.embeddedValueResolver);\n\t\tendpoint.setBeanFactory(this.beanFactory);\n\t\tendpoint.setId(getEndpointId(jmsListener));\n\t\tendpoint.setDestination(resolve(jmsListener.destination()));\n\t\tif (StringUtils.hasText(jmsListener.selector())) {\n\t\t\tendpoint.setSelector(resolve(jmsListener.selector()));\n\t\t}\n\t\tif (StringUtils.hasText(jmsListener.subscription())) {\n\t\t\tendpoint.setSubscription(resolve(jmsListener.subscription()));\n\t\t}\n\t\tif (StringUtils.hasText(jmsListener.concurrency())) {\n\t\t\tendpoint.setConcurrency(resolve(jmsListener.concurrency()));\n\t\t}\n\n\t\tJmsListenerContainerFactory<?> factory = null;\n\t\tString containerFactoryBeanName = resolve(jmsListener.containerFactory());\n\t\tif (StringUtils.hasText(containerFactoryBeanName)) {\n\t\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to obtain container factory by bean name\");\n\t\t\ttry {\n\t\t\t\tfactory = this.beanFactory.getBean(containerFactoryBeanName, JmsListenerContainerFactory.class);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\tthrow new BeanInitializationException(\"Could not register JMS listener endpoint on [\" +\n\t\t\t\t\t\tmostSpecificMethod + \"], no \" + JmsListenerContainerFactory.class.getSimpleName() +\n\t\t\t\t\t\t\" with id '\" + containerFactoryBeanName + \"' was found in the application context\", ex);\n\t\t\t}\n\t\t}\n\n\t\tthis.registrar.registerEndpoint(endpoint, factory);\n\t}"
  },
  "org.springframework.jms.config.<unknown>#createListenerContainer(endpoint,factory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create and start a new container using the specified factory.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "endpoint",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "MessageListenerContainer",
    "signature": "protected MessageListenerContainer createListenerContainer(JmsListenerEndpoint endpoint,\n\t\t\tJmsListenerContainerFactory<?> factory)",
    "source_code": "\tprotected MessageListenerContainer createListenerContainer(JmsListenerEndpoint endpoint,\n\t\t\tJmsListenerContainerFactory<?> factory) {\n\n\t\tMessageListenerContainer listenerContainer = factory.createListenerContainer(endpoint);\n\n\t\tif (listenerContainer instanceof InitializingBean initializingBean) {\n\t\t\ttry {\n\t\t\t\tinitializingBean.afterPropertiesSet();\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new BeanInitializationException(\"Failed to initialize message listener container\", ex);\n\t\t\t}\n\t\t}\n\n\t\tint containerPhase = listenerContainer.getPhase();\n\t\tif (containerPhase < Integer.MAX_VALUE) {  // a custom phase value\n\t\t\tif (this.phase < Integer.MAX_VALUE && this.phase != containerPhase) {\n\t\t\t\tthrow new IllegalStateException(\"Encountered phase mismatch between container factory definitions: \" +\n\t\t\t\t\t\tthis.phase + \" vs \" + containerPhase);\n\t\t\t}\n\t\t\tthis.phase = listenerContainer.getPhase();\n\t\t}\n\n\t\treturn listenerContainer;\n\t}"
  },
  "org.springframework.jms.config.<unknown>#registerEndpoint(endpoint,factory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a new {@link JmsListenerEndpoint} alongside the\n\t * {@link JmsListenerContainerFactory} to use to create the underlying container.\n\t * <p>The {@code factory} may be {@code null} if the default factory should be\n\t * used for the supplied endpoint.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "void",
    "signature": "public void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory)",
    "source_code": "\tpublic void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory) {\n\t\tAssert.notNull(endpoint, \"Endpoint must not be null\");\n\t\tAssert.hasText(endpoint.getId(), \"Endpoint id must be set\");\n\n\t\t// Factory may be null, we defer the resolution right before actually creating the container\n\t\tJmsListenerEndpointDescriptor descriptor = new JmsListenerEndpointDescriptor(endpoint, factory);\n\n\t\tsynchronized (this.mutex) {\n\t\t\tif (this.startImmediately) {  // register and start immediately\n\t\t\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(descriptor.endpoint,\n\t\t\t\t\t\tresolveContainerFactory(descriptor), true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.endpointDescriptors.add(descriptor);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.<unknown>#registerListenerContainer(endpoint,factory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a message listener container for the given {@link JmsListenerEndpoint}.\n\t * <p>This create the necessary infrastructure to honor that endpoint\n\t * with regard to its configuration.\n\t * @param endpoint the endpoint to add\n\t * @param factory the listener factory to use\n\t * @see #registerListenerContainer(JmsListenerEndpoint, JmsListenerContainerFactory, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void registerListenerContainer(JmsListenerEndpoint endpoint, JmsListenerContainerFactory<?> factory)",
    "source_code": "\tpublic void registerListenerContainer(JmsListenerEndpoint endpoint, JmsListenerContainerFactory<?> factory) {\n\t\tregisterListenerContainer(endpoint, factory, false);\n\t}"
  },
  "org.springframework.jms.config.<unknown>#registerListenerContainer(endpoint,factory,startImmediately)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a message listener container for the given {@link JmsListenerEndpoint}.\n\t * <p>This create the necessary infrastructure to honor that endpoint\n\t * with regard to its configuration.\n\t * <p>The {@code startImmediately} flag determines if the container should be\n\t * started immediately.\n\t * @param endpoint the endpoint to add\n\t * @param factory the listener factory to use\n\t * @param startImmediately start the container immediately if necessary\n\t * @see #getListenerContainers()\n\t * @see #getListenerContainer(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint",
      "factory",
      "startImmediately"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "public void registerListenerContainer(JmsListenerEndpoint endpoint, JmsListenerContainerFactory<?> factory,\n\t\t\tboolean startImmediately)",
    "source_code": "\tpublic void registerListenerContainer(JmsListenerEndpoint endpoint, JmsListenerContainerFactory<?> factory,\n\t\t\tboolean startImmediately) {\n\n\t\tAssert.notNull(endpoint, \"Endpoint must not be null\");\n\t\tAssert.notNull(factory, \"Factory must not be null\");\n\t\tString id = endpoint.getId();\n\t\tAssert.hasText(id, \"Endpoint id must be set\");\n\n\t\tsynchronized (this.listenerContainers) {\n\t\t\tif (this.listenerContainers.containsKey(id)) {\n\t\t\t\tthrow new IllegalStateException(\"Another endpoint is already registered with id '\" + id + \"'\");\n\t\t\t}\n\t\t\tMessageListenerContainer container = createListenerContainer(endpoint, factory);\n\t\t\tthis.listenerContainers.put(id, container);\n\t\t\tif (startImmediately) {\n\t\t\t\tstartIfNecessary(container);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createConnection(username,password)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "Connection",
    "signature": "public Connection createConnection(String username, String password)",
    "source_code": "\tpublic Connection createConnection(String username, String password) throws JMSException {\n\t\treturn obtainTargetConnectionFactory().createConnection(username, password);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createContext(userName,password)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userName",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "JMSContext",
    "signature": "public JMSContext createContext(String userName, String password)",
    "source_code": "\tpublic JMSContext createContext(String userName, String password) {\n\t\treturn obtainTargetConnectionFactory().createContext(userName, password);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createContext(userName,password,sessionMode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userName",
      "password",
      "sessionMode"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "JMSContext",
    "signature": "public JMSContext createContext(String userName, String password, int sessionMode)",
    "source_code": "\tpublic JMSContext createContext(String userName, String password, int sessionMode) {\n\t\treturn obtainTargetConnectionFactory().createContext(userName, password, sessionMode);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createQueueConnection(username,password)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "QueueConnection",
    "signature": "public QueueConnection createQueueConnection(String username, String password)",
    "source_code": "\tpublic QueueConnection createQueueConnection(String username, String password) throws JMSException {\n\t\tConnectionFactory target = obtainTargetConnectionFactory();\n\t\tif (target instanceof QueueConnectionFactory queueFactory) {\n\t\t\treturn queueFactory.createQueueConnection(username, password);\n\t\t}\n\t\telse {\n\t\t\tConnection con = target.createConnection(username, password);\n\t\t\tif (!(con instanceof QueueConnection queueConnection)) {\n\t\t\t\tthrow new jakarta.jms.IllegalStateException(\"'targetConnectionFactory' is not a QueueConnectionFactory\");\n\t\t\t}\n\t\t\treturn queueConnection;\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createSession(con,mode)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a default Session for this ConnectionFactory,\n\t * adapting to JMS 1.0.2 style queue/topic mode if necessary.\n\t * @param con the JMS Connection to operate on\n\t * @param mode the Session acknowledgement mode\n\t * ({@code Session.TRANSACTED} or one of the common modes)\n\t * @return the newly created Session\n\t * @throws JMSException if thrown by the JMS API\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con",
      "mode"
    ],
    "position": {
      "column": 1,
      "line": 470
    },
    "return": "Session",
    "signature": "protected Session createSession(Connection con, Integer mode)",
    "source_code": "\tprotected Session createSession(Connection con, Integer mode) throws JMSException {\n\t\t// Determine JMS API arguments...\n\t\tboolean transacted = (mode == Session.SESSION_TRANSACTED);\n\t\tint ackMode = (transacted ? Session.AUTO_ACKNOWLEDGE : mode);\n\t\t// Now actually call the appropriate JMS factory method...\n\t\tif (Boolean.FALSE.equals(this.pubSubMode) && con instanceof QueueConnection queueConnection) {\n\t\t\treturn queueConnection.createQueueSession(transacted, ackMode);\n\t\t}\n\t\telse if (Boolean.TRUE.equals(this.pubSubMode) && con instanceof TopicConnection topicConnection) {\n\t\t\treturn topicConnection.createTopicSession(transacted, ackMode);\n\t\t}\n\t\telse {\n\t\t\treturn con.createSession(transacted, ackMode);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createTopicConnection(username,password)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "TopicConnection",
    "signature": "public TopicConnection createTopicConnection(String username, String password)",
    "source_code": "\tpublic TopicConnection createTopicConnection(String username, String password) throws JMSException {\n\t\tConnectionFactory target = obtainTargetConnectionFactory();\n\t\tif (target instanceof TopicConnectionFactory topicFactory) {\n\t\t\treturn topicFactory.createTopicConnection(username, password);\n\t\t}\n\t\telse {\n\t\t\tConnection con = target.createConnection(username, password);\n\t\t\tif (!(con instanceof TopicConnection topicConnection)) {\n\t\t\t\tthrow new jakarta.jms.IllegalStateException(\"'targetConnectionFactory' is not a TopicConnectionFactory\");\n\t\t\t}\n\t\t\treturn topicConnection;\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doBegin(transaction,definition)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "void",
    "signature": "protected void doBegin(Object transaction, TransactionDefinition definition)",
    "source_code": "\tprotected void doBegin(Object transaction, TransactionDefinition definition) {\n\t\tif (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {\n\t\t\tthrow new InvalidIsolationLevelException(\"JMS does not support an isolation level concept\");\n\t\t}\n\n\t\tConnectionFactory connectionFactory = obtainConnectionFactory();\n\t\tJmsTransactionObject txObject = (JmsTransactionObject) transaction;\n\t\tConnection con = null;\n\t\tSession session = null;\n\t\ttry {\n\t\t\tJmsResourceHolder resourceHolder;\n\t\t\tif (this.lazyResourceRetrieval) {\n\t\t\t\tresourceHolder = new LazyJmsResourceHolder(connectionFactory);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcon = createConnection();\n\t\t\t\tsession = createSession(con);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Created JMS transaction on Session [\" + session + \"] from Connection [\" + con + \"]\");\n\t\t\t\t}\n\t\t\t\tresourceHolder = new JmsResourceHolder(connectionFactory, con, session);\n\t\t\t}\n\t\t\tresourceHolder.setSynchronizedWithTransaction(true);\n\t\t\tint timeout = determineTimeout(definition);\n\t\t\tif (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\t\tresourceHolder.setTimeoutInSeconds(timeout);\n\t\t\t}\n\t\t\ttxObject.setResourceHolder(resourceHolder);\n\t\t\tTransactionSynchronizationManager.bindResource(connectionFactory, resourceHolder);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (session != null) {\n\t\t\t\ttry {\n\t\t\t\t\tsession.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (con != null) {\n\t\t\t\ttry {\n\t\t\t\t\tcon.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new CannotCreateTransactionException(\"Could not create JMS transaction\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doCreateConnection(username,password)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation delegates to the {@code createConnection(username, password)}\n\t * method of the target ConnectionFactory, passing in the specified user credentials.\n\t * If the specified username is empty, it will simply delegate to the standard\n\t * {@code createConnection()} method of the target ConnectionFactory.\n\t * @param username the username to use\n\t * @param password the password to use\n\t * @return the Connection\n\t * @see jakarta.jms.ConnectionFactory#createConnection(String, String)\n\t * @see jakarta.jms.ConnectionFactory#createConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "Connection",
    "signature": "protected Connection doCreateConnection(@Nullable String username, @Nullable String password)",
    "source_code": "\tprotected Connection doCreateConnection(@Nullable String username, @Nullable String password) throws JMSException {\n\t\tConnectionFactory target = obtainTargetConnectionFactory();\n\t\tif (StringUtils.hasLength(username)) {\n\t\t\treturn target.createConnection(username, password);\n\t\t}\n\t\telse {\n\t\t\treturn target.createConnection();\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doCreateQueueConnection(username,password)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation delegates to the {@code createQueueConnection(username, password)}\n\t * method of the target QueueConnectionFactory, passing in the specified user credentials.\n\t * If the specified username is empty, it will simply delegate to the standard\n\t * {@code createQueueConnection()} method of the target ConnectionFactory.\n\t * @param username the username to use\n\t * @param password the password to use\n\t * @return the Connection\n\t * @see jakarta.jms.QueueConnectionFactory#createQueueConnection(String, String)\n\t * @see jakarta.jms.QueueConnectionFactory#createQueueConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "QueueConnection",
    "signature": "protected QueueConnection doCreateQueueConnection(@Nullable String username, @Nullable String password)",
    "source_code": "\tprotected QueueConnection doCreateQueueConnection(\n\t\t\t@Nullable String username, @Nullable String password) throws JMSException {\n\n\t\tConnectionFactory target = obtainTargetConnectionFactory();\n\t\tif (!(target instanceof QueueConnectionFactory queueFactory)) {\n\t\t\tthrow new jakarta.jms.IllegalStateException(\"'targetConnectionFactory' is not a QueueConnectionFactory\");\n\t\t}\n\t\tif (StringUtils.hasLength(username)) {\n\t\t\treturn queueFactory.createQueueConnection(username, password);\n\t\t}\n\t\telse {\n\t\t\treturn queueFactory.createQueueConnection();\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doCreateTopicConnection(username,password)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation delegates to the {@code createTopicConnection(username, password)}\n\t * method of the target TopicConnectionFactory, passing in the specified user credentials.\n\t * If the specified username is empty, it will simply delegate to the standard\n\t * {@code createTopicConnection()} method of the target ConnectionFactory.\n\t * @param username the username to use\n\t * @param password the password to use\n\t * @return the Connection\n\t * @see jakarta.jms.TopicConnectionFactory#createTopicConnection(String, String)\n\t * @see jakarta.jms.TopicConnectionFactory#createTopicConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "TopicConnection",
    "signature": "protected TopicConnection doCreateTopicConnection(@Nullable String username, @Nullable String password)",
    "source_code": "\tprotected TopicConnection doCreateTopicConnection(\n\t\t\t@Nullable String username, @Nullable String password) throws JMSException {\n\n\t\tConnectionFactory target = obtainTargetConnectionFactory();\n\t\tif (!(target instanceof TopicConnectionFactory topicFactory)) {\n\t\t\tthrow new jakarta.jms.IllegalStateException(\"'targetConnectionFactory' is not a TopicConnectionFactory\");\n\t\t}\n\t\tif (StringUtils.hasLength(username)) {\n\t\t\treturn topicFactory.createTopicConnection(username, password);\n\t\t}\n\t\telse {\n\t\t\treturn topicFactory.createTopicConnection();\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doGetTransactionalSession(connectionFactory,resourceFactory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS Session that is synchronized with the current transaction, if any.\n\t * <p>This {@code doGetTransactionalSession} variant always starts the underlying\n\t * JMS Connection, assuming that the Session will be used for receiving messages.\n\t * @param connectionFactory the JMS ConnectionFactory to bind for\n\t * (used as TransactionSynchronizationManager key)\n\t * @param resourceFactory the ResourceFactory to use for extracting or creating\n\t * JMS resources\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t * @see #doGetTransactionalSession(jakarta.jms.ConnectionFactory, ResourceFactory, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connectionFactory",
      "resourceFactory"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "Session",
    "signature": "public Session doGetTransactionalSession(ConnectionFactory connectionFactory, ResourceFactory resourceFactory)",
    "source_code": "\tpublic static Session doGetTransactionalSession(\n\t\t\tConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException {\n\n\t\treturn doGetTransactionalSession(connectionFactory, resourceFactory, true);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doGetTransactionalSession(connectionFactory,resourceFactory,startConnection)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS Session that is synchronized with the current transaction, if any.\n\t * @param connectionFactory the JMS ConnectionFactory to bind for\n\t * (used as TransactionSynchronizationManager key)\n\t * @param resourceFactory the ResourceFactory to use for extracting or creating\n\t * JMS resources\n\t * @param startConnection whether the underlying JMS Connection approach should be\n\t * started in order to allow for receiving messages. Note that a reused Connection\n\t * may already have been started before, even if this flag is {@code false}.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connectionFactory",
      "resourceFactory",
      "startConnection"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "Session",
    "signature": "public Session doGetTransactionalSession(ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection)",
    "source_code": "\tpublic static Session doGetTransactionalSession(\n\t\t\tConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection)\n\t\t\tthrows JMSException {\n\n\t\tAssert.notNull(connectionFactory, \"ConnectionFactory must not be null\");\n\t\tAssert.notNull(resourceFactory, \"ResourceFactory must not be null\");\n\n\t\tJmsResourceHolder resourceHolder =\n\t\t\t\t(JmsResourceHolder) TransactionSynchronizationManager.getResource(connectionFactory);\n\t\tif (resourceHolder != null) {\n\t\t\tSession session = resourceFactory.getSession(resourceHolder);\n\t\t\tif (session != null) {\n\t\t\t\tif (startConnection) {\n\t\t\t\t\tConnection con = resourceFactory.getConnection(resourceHolder);\n\t\t\t\t\tif (con != null) {\n\t\t\t\t\t\tcon.start();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn session;\n\t\t\t}\n\t\t\tif (resourceHolder.isFrozen()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tif (!TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\treturn null;\n\t\t}\n\t\tJmsResourceHolder resourceHolderToUse = resourceHolder;\n\t\tif (resourceHolderToUse == null) {\n\t\t\tresourceHolderToUse = new JmsResourceHolder(connectionFactory);\n\t\t}\n\t\tConnection con = resourceFactory.getConnection(resourceHolderToUse);\n\t\tSession session = null;\n\t\ttry {\n\t\t\tboolean isExistingCon = (con != null);\n\t\t\tif (!isExistingCon) {\n\t\t\t\tcon = resourceFactory.createConnection();\n\t\t\t\tresourceHolderToUse.addConnection(con);\n\t\t\t}\n\t\t\tsession = resourceFactory.createSession(con);\n\t\t\tresourceHolderToUse.addSession(session, con);\n\t\t\tif (startConnection) {\n\t\t\t\tcon.start();\n\t\t\t}\n\t\t}\n\t\tcatch (JMSException ex) {\n\t\t\tif (session != null) {\n\t\t\t\ttry {\n\t\t\t\t\tsession.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (con != null) {\n\t\t\t\ttry {\n\t\t\t\t\tcon.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t\tif (resourceHolderToUse != resourceHolder) {\n\t\t\tTransactionSynchronizationManager.registerSynchronization(\n\t\t\t\t\tnew JmsResourceSynchronization(resourceHolderToUse, connectionFactory,\n\t\t\t\t\t\t\tresourceFactory.isSynchedLocalTransactionAllowed()));\n\t\t\tresourceHolderToUse.setSynchronizedWithTransaction(true);\n\t\t\tTransactionSynchronizationManager.bindResource(connectionFactory, resourceHolderToUse);\n\t\t}\n\t\treturn session;\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doResume(transaction,suspendedResources)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "protected void doResume(@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected void doResume(@Nullable Object transaction, Object suspendedResources) {\n\t\tTransactionSynchronizationManager.bindResource(obtainConnectionFactory(), suspendedResources);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getCachedSessionProxy(target,sessionList)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Wrap the given Session with a proxy that delegates every method call to it\n\t * but adapts close calls. This is useful for allowing application code to\n\t * handle a special framework Session just like an ordinary Session.\n\t * @param target the original Session to wrap\n\t * @param sessionList the List of cached Sessions that the given Session belongs to\n\t * @return the wrapped Session\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "sessionList"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "Session",
    "signature": "protected Session getCachedSessionProxy(Session target, Deque<Session> sessionList)",
    "source_code": "\tprotected Session getCachedSessionProxy(Session target, Deque<Session> sessionList) {\n\t\tList<Class<?>> classes = new ArrayList<>(3);\n\t\tclasses.add(SessionProxy.class);\n\t\tif (target instanceof QueueSession) {\n\t\t\tclasses.add(QueueSession.class);\n\t\t}\n\t\tif (target instanceof TopicSession) {\n\t\t\tclasses.add(TopicSession.class);\n\t\t}\n\t\treturn (Session) Proxy.newProxyInstance(SessionProxy.class.getClassLoader(),\n\t\t\t\tClassUtils.toClassArray(classes), new CachedSessionInvocationHandler(target, sessionList));\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getSession(con,mode)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for obtaining a (potentially cached) Session.\n\t * <p>The default implementation always returns {@code null}.\n\t * Subclasses may override this for exposing specific Session handles,\n\t * possibly delegating to {@link #createSession} for the creation of raw\n\t * Session objects that will then get wrapped and returned from here.\n\t * @param con the JMS Connection to operate on\n\t * @param mode the Session acknowledgement mode\n\t * ({@code Session.TRANSACTED} or one of the common modes)\n\t * @return the Session to use, or {@code null} to indicate\n\t * creation of a raw standard Session\n\t * @throws JMSException if thrown by the JMS API\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con",
      "mode"
    ],
    "position": {
      "column": 1,
      "line": 457
    },
    "return": "Session",
    "signature": "protected Session getSession(Connection con, Integer mode)",
    "source_code": "\tprotected Session getSession(Connection con, Integer mode) throws JMSException {\n\t\treturn null;\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getSession(sessionType,connection)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionType",
      "connection"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "S",
    "signature": "public S getSession(Class<S> sessionType, @Nullable Connection connection)",
    "source_code": "\t\tpublic <S extends Session> S getSession(Class<S> sessionType, @Nullable Connection connection) {\n\t\t\tinitializeSession();\n\t\t\treturn super.getSession(sessionType, connection);\n\t\t}"
  },
  "org.springframework.jms.connection.<unknown>#getTransactionalQueueSession(cf,existingCon,synchedLocalTransactionAllowed)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS QueueSession that is synchronized with the current transaction, if any.\n\t * <p>Mainly intended for use with the JMS 1.0.2 API.\n\t * @param cf the ConnectionFactory to obtain a Session for\n\t * @param existingCon the existing JMS Connection to obtain a Session for\n\t * (may be {@code null})\n\t * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction\n\t * that is synchronized with a Spring-managed transaction (where the main transaction\n\t * might be a JDBC-based one for a specific DataSource, for example), with the JMS\n\t * transaction committing right after the main transaction. If not allowed, the given\n\t * ConnectionFactory needs to handle transaction enlistment underneath the covers.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cf",
      "existingCon",
      "synchedLocalTransactionAllowed"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "QueueSession",
    "signature": "public QueueSession getTransactionalQueueSession(final QueueConnectionFactory cf,\n\t\t\t@Nullable final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed)",
    "source_code": "\tpublic static QueueSession getTransactionalQueueSession(final QueueConnectionFactory cf,\n\t\t\t@Nullable final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed)\n\t\t\tthrows JMSException {\n\n\t\treturn (QueueSession) doGetTransactionalSession(cf, new ResourceFactory() {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Session getSession(JmsResourceHolder holder) {\n\t\t\t\treturn holder.getSession(QueueSession.class, existingCon);\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Connection getConnection(JmsResourceHolder holder) {\n\t\t\t\treturn (existingCon != null ? existingCon : holder.getConnection(QueueConnection.class));\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Connection createConnection() throws JMSException {\n\t\t\t\treturn cf.createQueueConnection();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Session createSession(Connection con) throws JMSException {\n\t\t\t\treturn ((QueueConnection) con).createQueueSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean isSynchedLocalTransactionAllowed() {\n\t\t\t\treturn synchedLocalTransactionAllowed;\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getTransactionalSession(cf,existingCon,synchedLocalTransactionAllowed)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS Session that is synchronized with the current transaction, if any.\n\t * @param cf the ConnectionFactory to obtain a Session for\n\t * @param existingCon the existing JMS Connection to obtain a Session for\n\t * (may be {@code null})\n\t * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction\n\t * that is synchronized with a Spring-managed transaction (where the main transaction\n\t * might be a JDBC-based one for a specific DataSource, for example), with the JMS\n\t * transaction committing right after the main transaction. If not allowed, the given\n\t * ConnectionFactory needs to handle transaction enlistment underneath the covers.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cf",
      "existingCon",
      "synchedLocalTransactionAllowed"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "Session",
    "signature": "public Session getTransactionalSession(final ConnectionFactory cf,\n\t\t\t@Nullable final Connection existingCon, final boolean synchedLocalTransactionAllowed)",
    "source_code": "\tpublic static Session getTransactionalSession(final ConnectionFactory cf,\n\t\t\t@Nullable final Connection existingCon, final boolean synchedLocalTransactionAllowed)\n\t\t\tthrows JMSException {\n\n\t\treturn doGetTransactionalSession(cf, new ResourceFactory() {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Session getSession(JmsResourceHolder holder) {\n\t\t\t\treturn holder.getSession(Session.class, existingCon);\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Connection getConnection(JmsResourceHolder holder) {\n\t\t\t\treturn (existingCon != null ? existingCon : holder.getConnection());\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Connection createConnection() throws JMSException {\n\t\t\t\treturn cf.createConnection();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Session createSession(Connection con) throws JMSException {\n\t\t\t\treturn con.createSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean isSynchedLocalTransactionAllowed() {\n\t\t\t\treturn synchedLocalTransactionAllowed;\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getTransactionalTopicSession(cf,existingCon,synchedLocalTransactionAllowed)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS TopicSession that is synchronized with the current transaction, if any.\n\t * <p>Mainly intended for use with the JMS 1.0.2 API.\n\t * @param cf the ConnectionFactory to obtain a Session for\n\t * @param existingCon the existing JMS Connection to obtain a Session for\n\t * (may be {@code null})\n\t * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction\n\t * that is synchronized with a Spring-managed transaction (where the main transaction\n\t * might be a JDBC-based one for a specific DataSource, for example), with the JMS\n\t * transaction committing right after the main transaction. If not allowed, the given\n\t * ConnectionFactory needs to handle transaction enlistment underneath the covers.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cf",
      "existingCon",
      "synchedLocalTransactionAllowed"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "TopicSession",
    "signature": "public TopicSession getTransactionalTopicSession(final TopicConnectionFactory cf,\n\t\t\t@Nullable final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed)",
    "source_code": "\tpublic static TopicSession getTransactionalTopicSession(final TopicConnectionFactory cf,\n\t\t\t@Nullable final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed)\n\t\t\tthrows JMSException {\n\n\t\treturn (TopicSession) doGetTransactionalSession(cf, new ResourceFactory() {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Session getSession(JmsResourceHolder holder) {\n\t\t\t\treturn holder.getSession(TopicSession.class, existingCon);\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Connection getConnection(JmsResourceHolder holder) {\n\t\t\t\treturn (existingCon != null ? existingCon : holder.getConnection(TopicConnection.class));\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Connection createConnection() throws JMSException {\n\t\t\t\treturn cf.createTopicConnection();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Session createSession(Connection con) throws JMSException {\n\t\t\t\treturn ((TopicConnection) con).createTopicSession(\n\t\t\t\t\t\tsynchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean isSynchedLocalTransactionAllowed() {\n\t\t\t\treturn synchedLocalTransactionAllowed;\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 546
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\tObject other = args[0];\n\t\t\t\t\tif (proxy == other) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (other == null || !Proxy.isProxyClass(other.getClass())) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tInvocationHandler otherHandler = Proxy.getInvocationHandler(other);\n\t\t\t\t\treturn (otherHandler instanceof SharedConnectionInvocationHandler sharedHandler &&\n\t\t\t\t\t\t\tfactory() == sharedHandler.factory());\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of containing SingleConnectionFactory.\n\t\t\t\t\treturn System.identityHashCode(factory());\n\t\t\t\tcase \"toString\":\n\t\t\t\t\treturn \"Shared JMS Connection: \" + getConnection();\n\t\t\t\tcase \"setClientID\":\n\t\t\t\t\t// Handle setClientID method: throw exception if not compatible.\n\t\t\t\t\tString currentClientId = getConnection().getClientID();\n\t\t\t\t\tif (currentClientId != null && currentClientId.equals(args[0])) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new jakarta.jms.IllegalStateException(\n\t\t\t\t\t\t\t\t\"setClientID call not supported on proxy for shared Connection. \" +\n\t\t\t\t\t\t\t\t\"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n\t\t\t\t\t}\n\t\t\t\tcase \"setExceptionListener\":\n\t\t\t\t\t// Handle setExceptionListener method: add to the chain.\n\t\t\t\t\tsynchronized (connectionMonitor) {\n\t\t\t\t\t\tif (aggregatedExceptionListener != null) {\n\t\t\t\t\t\t\tExceptionListener listener = (ExceptionListener) args[0];\n\t\t\t\t\t\t\tif (listener != this.localExceptionListener) {\n\t\t\t\t\t\t\t\tif (this.localExceptionListener != null) {\n\t\t\t\t\t\t\t\t\taggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (listener != null) {\n\t\t\t\t\t\t\t\t\taggregatedExceptionListener.delegates.add(listener);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.localExceptionListener = listener;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new jakarta.jms.IllegalStateException(\n\t\t\t\t\t\t\t\t\t\"setExceptionListener call not supported on proxy for shared Connection. \" +\n\t\t\t\t\t\t\t\t\t\"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" +\n\t\t\t\t\t\t\t\t\t\"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \" +\n\t\t\t\t\t\t\t\t\t\"which will allow for registering further ExceptionListeners to the recovery chain.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase \"getExceptionListener\":\n\t\t\t\t\tsynchronized (connectionMonitor) {\n\t\t\t\t\t\tif (this.localExceptionListener != null) {\n\t\t\t\t\t\t\treturn this.localExceptionListener;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn getExceptionListener();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase \"start\":\n\t\t\t\t\tlocalStart();\n\t\t\t\t\treturn null;\n\t\t\t\tcase \"stop\":\n\t\t\t\t\tlocalStop();\n\t\t\t\t\treturn null;\n\t\t\t\tcase \"close\":\n\t\t\t\t\tlocalStop();\n\t\t\t\t\tsynchronized (connectionMonitor) {\n\t\t\t\t\t\tif (this.localExceptionListener != null) {\n\t\t\t\t\t\t\tif (aggregatedExceptionListener != null) {\n\t\t\t\t\t\t\t\taggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.localExceptionListener = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\tcase \"createSession\":\n\t\t\t\tcase \"createQueueSession\":\n\t\t\t\tcase \"createTopicSession\":\n\t\t\t\t\t// Default: JMS 2.0 createSession() method\n\t\t\t\t\tInteger mode = Session.AUTO_ACKNOWLEDGE;\n\t\t\t\t\tif (!ObjectUtils.isEmpty(args)) {\n\t\t\t\t\t\tif (args.length == 1) {\n\t\t\t\t\t\t\t// JMS 2.0 createSession(int) method\n\t\t\t\t\t\t\tmode = (Integer) args[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (args.length == 2) {\n\t\t\t\t\t\t\t// JMS 1.1 createSession(boolean, int) method\n\t\t\t\t\t\t\tboolean transacted = (Boolean) args[0];\n\t\t\t\t\t\t\tInteger ackMode = (Integer) args[1];\n\t\t\t\t\t\t\tmode = (transacted ? Session.SESSION_TRANSACTED : ackMode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSession session = getSession(getConnection(), mode);\n\t\t\t\t\tif (session != null) {\n\t\t\t\t\t\tif (!method.getReturnType().isInstance(session)) {\n\t\t\t\t\t\t\tString msg = \"JMS Session does not implement specific domain: \" + session;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tsession.close();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t\t\tlogger.trace(\"Failed to close newly obtained JMS Session\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthrow new jakarta.jms.IllegalStateException(msg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn session;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\treturn method.invoke(getConnection(), args);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jms.connection.<unknown>#isSessionTransactional(session,cf)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given JMS Session is transactional, that is,\n\t * bound to the current thread by Spring's transaction facilities.\n\t * @param session the JMS Session to check\n\t * @param cf the JMS ConnectionFactory that the Session originated from\n\t * @return whether the Session is transactional\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "boolean",
    "signature": "public boolean isSessionTransactional(@Nullable Session session, @Nullable ConnectionFactory cf)",
    "source_code": "\tpublic static boolean isSessionTransactional(@Nullable Session session, @Nullable ConnectionFactory cf) {\n\t\tif (session == null || cf == null) {\n\t\t\treturn false;\n\t\t}\n\t\tJmsResourceHolder resourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(cf);\n\t\treturn (resourceHolder != null && resourceHolder.containsSession(session));\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#releaseConnection(con,cf,started)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Release the given Connection, stopping it (if necessary) and eventually closing it.\n\t * <p>Checks {@link SmartConnectionFactory#shouldStop}, if available.\n\t * This is essentially a more sophisticated version of\n\t * {@link org.springframework.jms.support.JmsUtils#closeConnection}.\n\t * @param con the Connection to release\n\t * (if this is {@code null}, the call will be ignored)\n\t * @param cf the ConnectionFactory that the Connection was obtained from\n\t * (may be {@code null})\n\t * @param started whether the Connection might have been started by the application\n\t * @see SmartConnectionFactory#shouldStop\n\t * @see org.springframework.jms.support.JmsUtils#closeConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "cf",
      "started"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "public void releaseConnection(@Nullable Connection con, @Nullable ConnectionFactory cf, boolean started)",
    "source_code": "\tpublic static void releaseConnection(@Nullable Connection con, @Nullable ConnectionFactory cf, boolean started) {\n\t\tif (con == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (started && cf instanceof SmartConnectionFactory smartFactory && smartFactory.shouldStop(con)) {\n\t\t\ttry {\n\t\t\t\tcon.stop();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.debug(\"Could not stop JMS Connection before closing it\", ex);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tcon.close();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.debug(\"Could not close JMS Connection\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#releaseResource(resourceHolder,resourceKey)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourceHolder",
      "resourceKey"
    ],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "void",
    "signature": "protected void releaseResource(JmsResourceHolder resourceHolder, Object resourceKey)",
    "source_code": "\t\tprotected void releaseResource(JmsResourceHolder resourceHolder, Object resourceKey) {\n\t\t\tresourceHolder.closeAll();\n\t\t}"
  },
  "org.springframework.jms.connection.<unknown>#setCredentialsForCurrentThread(username,password)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set user credentials for this proxy and the current thread.\n\t * The given username and password will be applied to all subsequent\n\t * {@code createConnection()} calls on this ConnectionFactory proxy.\n\t * <p>This will override any statically specified user credentials,\n\t * that is, values of the \"username\" and \"password\" bean properties.\n\t * @param username the username to apply\n\t * @param password the password to apply\n\t * @see #removeCredentialsFromCurrentThread\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void setCredentialsForCurrentThread(String username, String password)",
    "source_code": "\tpublic void setCredentialsForCurrentThread(String username, String password) {\n\t\tthis.threadBoundCredentials.set(new JmsUserCredentials(username, password));\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browse(queue,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queue",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 984
    },
    "return": "T",
    "signature": "public T browse(Queue queue, BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browse(Queue queue, BrowserCallback<T> action) throws JmsException {\n\t\treturn browseSelected(queue, null, action);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browse(queueName,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queueName",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 990
    },
    "return": "T",
    "signature": "public T browse(String queueName, BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browse(String queueName, BrowserCallback<T> action) throws JmsException {\n\t\treturn browseSelected(queueName, null, action);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browseSelected(messageSelector,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSelector",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 996
    },
    "return": "T",
    "signature": "public T browseSelected(String messageSelector, BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browseSelected(String messageSelector, BrowserCallback<T> action) throws JmsException {\n\t\tQueue defaultQueue = getDefaultQueue();\n\t\tif (defaultQueue != null) {\n\t\t\treturn browseSelected(defaultQueue, messageSelector, action);\n\t\t}\n\t\telse {\n\t\t\treturn browseSelected(getRequiredDefaultDestinationName(), messageSelector, action);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browseSelected(queue,messageSelector,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queue",
      "messageSelector",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1008
    },
    "return": "T",
    "signature": "public T browseSelected(final Queue queue, @Nullable final String messageSelector, final BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browseSelected(final Queue queue, @Nullable final String messageSelector, final BrowserCallback<T> action)\n\t\t\tthrows JmsException {\n\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tQueueBrowser browser = createBrowser(session, queue, messageSelector);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, browser);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeQueueBrowser(browser);\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browseSelected(queueName,messageSelector,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queueName",
      "messageSelector",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1025
    },
    "return": "T",
    "signature": "public T browseSelected(final String queueName, @Nullable final String messageSelector, final BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browseSelected(final String queueName, @Nullable final String messageSelector, final BrowserCallback<T> action)\n\t\t\tthrows JmsException {\n\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tQueue queue = (Queue) getDestinationResolver().resolveDestinationName(session, queueName, false);\n\t\t\tQueueBrowser browser = createBrowser(session, queue, messageSelector);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, browser);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeQueueBrowser(browser);\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destination,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 655
    },
    "return": "void",
    "signature": "public void convertAndSend(Destination destination, final Object message)",
    "source_code": "\tpublic void convertAndSend(Destination destination, final Object message) throws JmsException {\n\t\tsend(destination, session -> getRequiredMessageConverter().toMessage(message, session));\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destination,message,postProcessor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "message",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 676
    },
    "return": "void",
    "signature": "public void convertAndSend(Destination destination, final Object message, final MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(\n\t\t\tDestination destination, final Object message, final MessagePostProcessor postProcessor)\n\t\t\tthrows JmsException {\n\n\t\tsend(destination, session -> {\n\t\t\tMessage msg = getRequiredMessageConverter().toMessage(message, session);\n\t\t\treturn postProcessor.postProcessMessage(msg);\n\t\t});\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destinationName,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 660
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, final Object message)",
    "source_code": "\tpublic void convertAndSend(String destinationName, final Object message) throws JmsException {\n\t\tsend(destinationName, session -> getRequiredMessageConverter().toMessage(message, session));\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destinationName,message,postProcessor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "message",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 687
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, final Object message, final MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(\n\t\t\tString destinationName, final Object message, final MessagePostProcessor postProcessor)\n\t\tthrows JmsException {\n\n\t\tsend(destinationName, session -> {\n\t\t\tMessage msg = getRequiredMessageConverter().toMessage(message, session);\n\t\t\treturn postProcessor.postProcessMessage(msg);\n\t\t});\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(message,postProcessor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 665
    },
    "return": "void",
    "signature": "public void convertAndSend(Object message, MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(Object message, MessagePostProcessor postProcessor) throws JmsException {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\tconvertAndSend(defaultDestination, message, postProcessor);\n\t\t}\n\t\telse {\n\t\t\tconvertAndSend(getRequiredDefaultDestinationName(), message, postProcessor);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#createBrowser(session,queue,messageSelector)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MessageProducer for the given Session and Destination,\n\t * configuring it to disable message ids and/or timestamps (if necessary).\n\t * <p>Delegates to {@link #doCreateProducer} for creation of the raw\n\t * JMS MessageProducer.\n\t * @param session the JMS Session to create a QueueBrowser for\n\t * @param queue the JMS Queue to create a QueueBrowser for\n\t * @param messageSelector the message selector for this consumer (can be {@code null})\n\t * @return the new JMS QueueBrowser\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setMessageIdEnabled\n\t * @see #setMessageTimestampEnabled\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "queue",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 1154
    },
    "return": "QueueBrowser",
    "signature": "protected QueueBrowser createBrowser(Session session, Queue queue, @Nullable String messageSelector)",
    "source_code": "\tprotected QueueBrowser createBrowser(Session session, Queue queue, @Nullable String messageSelector)\n\t\t\tthrows JMSException {\n\n\t\treturn session.createBrowser(queue, messageSelector);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#createConsumer(session,destination,messageSelector)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MessageConsumer for the given Session and Destination.\n\t * <p>This implementation uses JMS 1.1 API.\n\t * @param session the JMS Session to create a MessageConsumer for\n\t * @param destination the JMS Destination to create a MessageConsumer for\n\t * @param messageSelector the message selector for this consumer (can be {@code null})\n\t * @return the new JMS MessageConsumer\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 1127
    },
    "return": "MessageConsumer",
    "signature": "protected MessageConsumer createConsumer(Session session, Destination destination, @Nullable String messageSelector)",
    "source_code": "\tprotected MessageConsumer createConsumer(Session session, Destination destination, @Nullable String messageSelector)\n\t\t\tthrows JMSException {\n\n\t\t// Only pass in the NoLocal flag in case of a Topic:\n\t\t// Some JMS providers, such as WebSphere MQ 6.0, throw IllegalStateException\n\t\t// in case of the NoLocal flag being specified for a Queue.\n\t\tif (isPubSubDomain()) {\n\t\t\treturn session.createConsumer(destination, messageSelector, isPubSubNoLocal());\n\t\t}\n\t\telse {\n\t\t\treturn session.createConsumer(destination, messageSelector);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#createProducer(session,destination)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MessageProducer for the given Session and Destination,\n\t * configuring it to disable message ids and/or timestamps (if necessary).\n\t * <p>Delegates to {@link #doCreateProducer} for creation of the raw\n\t * JMS MessageProducer.\n\t * @param session the JMS Session to create a MessageProducer for\n\t * @param destination the JMS Destination to create a MessageProducer for\n\t * @return the new JMS MessageProducer\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setMessageIdEnabled\n\t * @see #setMessageTimestampEnabled\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 1095
    },
    "return": "MessageProducer",
    "signature": "protected MessageProducer createProducer(Session session, @Nullable Destination destination)",
    "source_code": "\tprotected MessageProducer createProducer(Session session, @Nullable Destination destination) throws JMSException {\n\t\tMessageProducer producer = doCreateProducer(session, destination);\n\t\tif (!isMessageIdEnabled()) {\n\t\t\tproducer.setDisableMessageID(true);\n\t\t}\n\t\tif (!isMessageTimestampEnabled()) {\n\t\t\tproducer.setDisableMessageTimestamp(true);\n\t\t}\n\t\treturn producer;\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doCreateProducer(session,destination)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a raw JMS MessageProducer for the given Session and Destination.\n\t * <p>This implementation uses JMS 1.1 API.\n\t * @param session the JMS Session to create a MessageProducer for\n\t * @param destination the JMS Destination to create a MessageProducer for\n\t * @return the new JMS MessageProducer\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 1114
    },
    "return": "MessageProducer",
    "signature": "protected MessageProducer doCreateProducer(Session session, @Nullable Destination destination)",
    "source_code": "\tprotected MessageProducer doCreateProducer(Session session, @Nullable Destination destination) throws JMSException {\n\t\treturn session.createProducer(destination);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doReceive(session,consumer)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually receive a JMS message.\n\t * @param session the JMS Session to operate on\n\t * @param consumer the JMS MessageConsumer to receive with\n\t * @return the JMS Message received, or {@code null} if none\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 776
    },
    "return": "Message",
    "signature": "protected Message doReceive(Session session, MessageConsumer consumer)",
    "source_code": "\tprotected Message doReceive(Session session, MessageConsumer consumer) throws JMSException {\n\t\ttry {\n\t\t\t// Use transaction timeout (if available).\n\t\t\tlong timeout = getReceiveTimeout();\n\t\t\tConnectionFactory connectionFactory = getConnectionFactory();\n\t\t\tJmsResourceHolder resourceHolder = null;\n\t\t\tif (connectionFactory != null) {\n\t\t\t\tresourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(connectionFactory);\n\t\t\t}\n\t\t\tif (resourceHolder != null && resourceHolder.hasTimeout()) {\n\t\t\t\ttimeout = Math.min(timeout, resourceHolder.getTimeToLiveInMillis());\n\t\t\t}\n\t\t\tMessage message = receiveFromConsumer(consumer, timeout);\n\t\t\tif (session.getTransacted()) {\n\t\t\t\t// Commit necessary - but avoid commit call within a JTA transaction.\n\t\t\t\tif (isSessionLocallyTransacted(session)) {\n\t\t\t\t\t// Transacted session created by this template -> commit.\n\t\t\t\t\tJmsUtils.commitIfNecessary(session);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (isClientAcknowledge(session)) {\n\t\t\t\t// Manually acknowledge message, if any.\n\t\t\t\tif (message != null) {\n\t\t\t\t\tmessage.acknowledge();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn message;\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageConsumer(consumer);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doReceive(session,destination,messageSelector)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Receive a JMS message.\n\t * @param session the JMS Session to operate on\n\t * @param destination the JMS Destination to receive from\n\t * @param messageSelector the message selector for this consumer (can be {@code null})\n\t * @return the JMS Message received, or {@code null} if none\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 762
    },
    "return": "Message",
    "signature": "protected Message doReceive(Session session, Destination destination, @Nullable String messageSelector)",
    "source_code": "\tprotected Message doReceive(Session session, Destination destination, @Nullable String messageSelector)\n\t\t\tthrows JMSException {\n\n\t\treturn doReceive(session, createConsumer(session, destination, messageSelector));\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doSend(producer,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually send the given JMS message.\n\t * @param producer the JMS MessageProducer to send with\n\t * @param message the JMS Message to send\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "producer",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 626
    },
    "return": "void",
    "signature": "protected void doSend(MessageProducer producer, Message message)",
    "source_code": "\tprotected void doSend(MessageProducer producer, Message message) throws JMSException {\n\t\tif (this.deliveryDelay >= 0) {\n\t\t\tproducer.setDeliveryDelay(this.deliveryDelay);\n\t\t}\n\t\tif (isExplicitQosEnabled()) {\n\t\t\tproducer.send(message, getDeliveryMode(), getPriority(), getTimeToLive());\n\t\t}\n\t\telse {\n\t\t\tproducer.send(message);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doSend(session,destination,messageCreator)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Send the given JMS message.\n\t * @param session the JMS Session to operate on\n\t * @param destination the JMS Destination to send to\n\t * @param messageCreator callback to create a JMS Message\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 598
    },
    "return": "void",
    "signature": "protected void doSend(Session session, Destination destination, MessageCreator messageCreator)",
    "source_code": "\tprotected void doSend(Session session, Destination destination, MessageCreator messageCreator)\n\t\t\tthrows JMSException {\n\n\t\tAssert.notNull(messageCreator, \"MessageCreator must not be null\");\n\t\tMessageProducer producer = createProducer(session, destination);\n\t\ttry {\n\t\t\tMessage message = messageCreator.createMessage(session);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Sending created message: \" + message);\n\t\t\t}\n\t\t\tdoSend(producer, message);\n\t\t\t// Check commit - avoid commit call within a JTA transaction.\n\t\t\tif (session.getTransacted() && isSessionLocallyTransacted(session)) {\n\t\t\t\t// Transacted session created by this template -> commit.\n\t\t\t\tJmsUtils.commitIfNecessary(session);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doSendAndReceive(session,destination,messageCreator)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Send a request message to the given {@link Destination} and block until\n\t * a reply has been received on a temporary queue created on-the-fly.\n\t * <p>Return the response message or {@code null} if no message has\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 907
    },
    "return": "Message",
    "signature": "protected Message doSendAndReceive(Session session, Destination destination, MessageCreator messageCreator)",
    "source_code": "\tprotected Message doSendAndReceive(Session session, Destination destination, MessageCreator messageCreator)\n\t\t\tthrows JMSException {\n\n\t\tAssert.notNull(messageCreator, \"MessageCreator must not be null\");\n\t\tTemporaryQueue responseQueue = null;\n\t\tMessageProducer producer = null;\n\t\tMessageConsumer consumer = null;\n\t\ttry {\n\t\t\tMessage requestMessage = messageCreator.createMessage(session);\n\t\t\tresponseQueue = session.createTemporaryQueue();\n\t\t\tproducer = session.createProducer(destination);\n\t\t\tconsumer = session.createConsumer(responseQueue);\n\t\t\trequestMessage.setJMSReplyTo(responseQueue);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Sending created message: \" + requestMessage);\n\t\t\t}\n\t\t\tdoSend(producer, requestMessage);\n\t\t\treturn receiveFromConsumer(consumer, getReceiveTimeout());\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageConsumer(consumer);\n\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t\tif (responseQueue != null) {\n\t\t\t\tresponseQueue.delete();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#execute(action,startConnection)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the action specified by the given action object within a\n\t * JMS Session. Generalized version of {@code execute(SessionCallback)},\n\t * allowing the JMS Connection to be started on the fly.\n\t * <p>Use {@code execute(SessionCallback)} for the general case.\n\t * Starting the JMS Connection is just necessary for receiving messages,\n\t * which is preferably achieved through the {@code receive} methods.\n\t * @param action callback object that exposes the Session\n\t * @param startConnection whether to start the Connection\n\t * @return the result object from working with the Session\n\t * @throws JmsException if there is any problem\n\t * @see #execute(SessionCallback)\n\t * @see #receive\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "action",
      "startConnection"
    ],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "T",
    "signature": "public T execute(SessionCallback<T> action, boolean startConnection)",
    "source_code": "\tpublic <T> T execute(SessionCallback<T> action, boolean startConnection) throws JmsException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\tConnection conToClose = null;\n\t\tSession sessionToClose = null;\n\t\ttry {\n\t\t\tSession sessionToUse = ConnectionFactoryUtils.doGetTransactionalSession(\n\t\t\t\t\tobtainConnectionFactory(), this.transactionalResourceFactory, startConnection);\n\t\t\tif (sessionToUse == null) {\n\t\t\t\tconToClose = createConnection();\n\t\t\t\tsessionToClose = createSession(conToClose);\n\t\t\t\tif (startConnection) {\n\t\t\t\t\tconToClose.start();\n\t\t\t\t}\n\t\t\t\tsessionToUse = sessionToClose;\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Executing callback on JMS Session: \" + sessionToUse);\n\t\t\t}\n\t\t\treturn action.doInJms(sessionToUse);\n\t\t}\n\t\tcatch (JMSException ex) {\n\t\t\tthrow convertJmsAccessException(ex);\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeSession(sessionToClose);\n\t\t\tConnectionFactoryUtils.releaseConnection(conToClose, getConnectionFactory(), startConnection);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#execute(destination,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 529
    },
    "return": "T",
    "signature": "public T execute(final @Nullable Destination destination, final ProducerCallback<T> action)",
    "source_code": "\tpublic <T> T execute(final @Nullable Destination destination, final ProducerCallback<T> action) throws JmsException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tMessageProducer producer = createProducer(session, destination);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, producer);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t\t}\n\t\t}, false);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#execute(destinationName,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "T",
    "signature": "public T execute(final String destinationName, final ProducerCallback<T> action)",
    "source_code": "\tpublic <T> T execute(final String destinationName, final ProducerCallback<T> action) throws JmsException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\tMessageProducer producer = createProducer(session, destination);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, producer);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t\t}\n\t\t}, false);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#receiveSelected(destination,messageSelector)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 740
    },
    "return": "Message",
    "signature": "public Message receiveSelected(final Destination destination, @Nullable final String messageSelector)",
    "source_code": "\tpublic Message receiveSelected(final Destination destination, @Nullable final String messageSelector) throws JmsException {\n\t\treturn execute(session -> doReceive(session, destination, messageSelector), true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#receiveSelected(destinationName,messageSelector)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 746
    },
    "return": "Message",
    "signature": "public Message receiveSelected(final String destinationName, @Nullable final String messageSelector)",
    "source_code": "\tpublic Message receiveSelected(final String destinationName, @Nullable final String messageSelector) throws JmsException {\n\t\treturn execute(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\treturn doReceive(session, destination, messageSelector);\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#receiveSelectedAndConvert(destination,messageSelector)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 840
    },
    "return": "Object",
    "signature": "public Object receiveSelectedAndConvert(Destination destination, String messageSelector)",
    "source_code": "\tpublic Object receiveSelectedAndConvert(Destination destination, String messageSelector) throws JmsException {\n\t\treturn doConvertFromMessage(receiveSelected(destination, messageSelector));\n\t}"
  },
  "org.springframework.jms.core.<unknown>#receiveSelectedAndConvert(destinationName,messageSelector)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 846
    },
    "return": "Object",
    "signature": "public Object receiveSelectedAndConvert(String destinationName, String messageSelector)",
    "source_code": "\tpublic Object receiveSelectedAndConvert(String destinationName, String messageSelector) throws JmsException {\n\t\treturn doConvertFromMessage(receiveSelected(destinationName, messageSelector));\n\t}"
  },
  "org.springframework.jms.core.<unknown>#send(destination,messageCreator)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 575
    },
    "return": "void",
    "signature": "public void send(final Destination destination, final MessageCreator messageCreator)",
    "source_code": "\tpublic void send(final Destination destination, final MessageCreator messageCreator) throws JmsException {\n\t\texecute(session -> {\n\t\t\tdoSend(session, destination, messageCreator);\n\t\t\treturn null;\n\t\t}, false);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#send(destinationName,messageCreator)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 583
    },
    "return": "void",
    "signature": "public void send(final String destinationName, final MessageCreator messageCreator)",
    "source_code": "\tpublic void send(final String destinationName, final MessageCreator messageCreator) throws JmsException {\n\t\texecute(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\tdoSend(session, destination, messageCreator);\n\t\t\treturn null;\n\t\t}, false);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#sendAndReceive(destination,messageCreator)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 887
    },
    "return": "Message",
    "signature": "public Message sendAndReceive(final Destination destination, final MessageCreator messageCreator)",
    "source_code": "\tpublic Message sendAndReceive(final Destination destination, final MessageCreator messageCreator) throws JmsException {\n\t\treturn executeLocal(session -> doSendAndReceive(session, destination, messageCreator), true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#sendAndReceive(destinationName,messageCreator)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 893
    },
    "return": "Message",
    "signature": "public Message sendAndReceive(final String destinationName, final MessageCreator messageCreator)",
    "source_code": "\tpublic Message sendAndReceive(final String destinationName, final MessageCreator messageCreator) throws JmsException {\n\t\treturn executeLocal(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\treturn doSendAndReceive(session, destination, messageCreator);\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#commitIfNecessary(session,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a commit or message acknowledgement, as appropriate.\n\t * @param session the JMS Session to commit\n\t * @param message the Message to acknowledge\n\t * @throws jakarta.jms.JMSException in case of commit failure\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 770
    },
    "return": "void",
    "signature": "protected void commitIfNecessary(Session session, @Nullable Message message)",
    "source_code": "\tprotected void commitIfNecessary(Session session, @Nullable Message message) throws JMSException {\n\t\t// Commit session or acknowledge message.\n\t\tif (session.getTransacted()) {\n\t\t\t// Commit necessary - but avoid commit call within a JTA transaction.\n\t\t\tif (isSessionLocallyTransacted(session)) {\n\t\t\t\t// Transacted session created by this container -> commit.\n\t\t\t\tJmsUtils.commitIfNecessary(session);\n\t\t\t}\n\t\t}\n\t\telse if (message != null && isClientAcknowledge(session)) {\n\t\t\tmessage.acknowledge();\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#createConsumer(session,destination)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MessageConsumer for the given Session and Destination.\n\t * <p>This implementation uses JMS 1.1 API.\n\t * @param session the JMS Session to create a MessageConsumer for\n\t * @param destination the JMS Destination to create a MessageConsumer for\n\t * @return the new JMS MessageConsumer\n\t * @throws jakarta.jms.JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 855
    },
    "return": "MessageConsumer",
    "signature": "protected MessageConsumer createConsumer(Session session, Destination destination)",
    "source_code": "\tprotected MessageConsumer createConsumer(Session session, Destination destination) throws JMSException {\n\t\tif (isPubSubDomain() && destination instanceof Topic topic) {\n\t\t\tif (isSubscriptionShared()) {\n\t\t\t\treturn (isSubscriptionDurable() ?\n\t\t\t\t\t\tsession.createSharedDurableConsumer(topic, getSubscriptionName(), getMessageSelector()) :\n\t\t\t\t\t\tsession.createSharedConsumer(topic, getSubscriptionName(), getMessageSelector()));\n\t\t\t}\n\t\t\telse if (isSubscriptionDurable()) {\n\t\t\t\treturn session.createDurableSubscriber(\n\t\t\t\t\t\ttopic, getSubscriptionName(), getMessageSelector(), isPubSubNoLocal());\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Only pass in the NoLocal flag in case of a Topic (pub-sub mode):\n\t\t\t\t// Some JMS providers, such as WebSphere MQ 6.0, throw IllegalStateException\n\t\t\t\t// in case of the NoLocal flag being specified for a Queue.\n\t\t\t\treturn session.createConsumer(destination, getMessageSelector(), isPubSubNoLocal());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn session.createConsumer(destination, getMessageSelector());\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#doExecuteListener(session,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the specified listener,\n\t * committing or rolling back the transaction afterwards (if necessary).\n\t * @param session the JMS Session to operate on\n\t * @param message the received JMS Message\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #invokeListener\n\t * @see #commitIfNecessary\n\t * @see #rollbackOnExceptionIfNecessary\n\t * @see #convertJmsAccessException\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 663
    },
    "return": "void",
    "signature": "protected void doExecuteListener(Session session, Message message)",
    "source_code": "\tprotected void doExecuteListener(Session session, Message message) throws JMSException {\n\t\tif (!isAcceptMessagesWhileStopping() && !isRunning()) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Rejecting received message because of the listener container \" +\n\t\t\t\t\t\t\"having been stopped in the meantime: \" + message);\n\t\t\t}\n\t\t\trollbackIfNecessary(session);\n\t\t\tthrow new MessageRejectedWhileStoppingException();\n\t\t}\n\n\t\ttry {\n\t\t\tinvokeListener(session, message);\n\t\t}\n\t\tcatch (JMSException | RuntimeException | Error ex) {\n\t\t\trollbackOnExceptionIfNecessary(session, ex);\n\t\t\tthrow ex;\n\t\t}\n\t\tcommitIfNecessary(session, message);\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#doInvokeListener(listener,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified listener as standard JMS MessageListener.\n\t * <p>Default implementation performs a plain invocation of the\n\t * {@code onMessage} method.\n\t * @param listener the JMS MessageListener to invoke\n\t * @param message the received JMS Message\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see jakarta.jms.MessageListener#onMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "listener",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 760
    },
    "return": "void",
    "signature": "protected void doInvokeListener(MessageListener listener, Message message)",
    "source_code": "\tprotected void doInvokeListener(MessageListener listener, Message message) throws JMSException {\n\t\tlistener.onMessage(message);\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#doInvokeListener(listener,session,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified listener as Spring SessionAwareMessageListener,\n\t * exposing a new JMS Session (potentially with its own transaction)\n\t * to the listener if demanded.\n\t * @param listener the Spring SessionAwareMessageListener to invoke\n\t * @param session the JMS Session to operate on\n\t * @param message the received JMS Message\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see SessionAwareMessageListener\n\t * @see #setExposeListenerSession\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "listener",
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 722
    },
    "return": "void",
    "signature": "protected void doInvokeListener(SessionAwareMessageListener listener, Session session, Message message)",
    "source_code": "\tprotected void doInvokeListener(SessionAwareMessageListener listener, Session session, Message message)\n\t\t\tthrows JMSException {\n\n\t\tConnection conToClose = null;\n\t\tSession sessionToClose = null;\n\t\ttry {\n\t\t\tSession sessionToUse = session;\n\t\t\tif (!isExposeListenerSession()) {\n\t\t\t\t// We need to expose a separate Session.\n\t\t\t\tconToClose = createConnection();\n\t\t\t\tsessionToClose = createSession(conToClose);\n\t\t\t\tsessionToUse = sessionToClose;\n\t\t\t}\n\t\t\t// Actually invoke the message listener...\n\t\t\tlistener.onMessage(message, sessionToUse);\n\t\t\t// Clean up specially exposed Session, if any.\n\t\t\tif (sessionToUse != session) {\n\t\t\t\tif (sessionToUse.getTransacted() && isSessionLocallyTransacted(sessionToUse)) {\n\t\t\t\t\t// Transacted session created by this container -> commit.\n\t\t\t\t\tJmsUtils.commitIfNecessary(sessionToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeSession(sessionToClose);\n\t\t\tJmsUtils.closeConnection(conToClose);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#doReceiveAndExecute(invoker,session,consumer,status)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually execute the listener for a message received from the given consumer,\n\t * fetching all requires resources and invoking the listener.\n\t * @param session the JMS Session to work on\n\t * @param consumer the MessageConsumer to work on\n\t * @param status the TransactionStatus (may be {@code null})\n\t * @return whether a message has been received\n\t * @throws JMSException if thrown by JMS methods\n\t * @see #doExecuteListener(jakarta.jms.Session, jakarta.jms.Message)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "session",
      "consumer",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "boolean",
    "signature": "protected boolean doReceiveAndExecute(Object invoker, @Nullable Session session,\n\t\t\t@Nullable MessageConsumer consumer, @Nullable TransactionStatus status)",
    "source_code": "\tprotected boolean doReceiveAndExecute(Object invoker, @Nullable Session session,\n\t\t\t@Nullable MessageConsumer consumer, @Nullable TransactionStatus status) throws JMSException {\n\n\t\tConnection conToClose = null;\n\t\tSession sessionToClose = null;\n\t\tMessageConsumer consumerToClose = null;\n\t\ttry {\n\t\t\tSession sessionToUse = session;\n\t\t\tboolean transactional = false;\n\t\t\tif (sessionToUse == null) {\n\t\t\t\tsessionToUse = ConnectionFactoryUtils.doGetTransactionalSession(\n\t\t\t\t\t\tobtainConnectionFactory(), this.transactionalResourceFactory, true);\n\t\t\t\ttransactional = (sessionToUse != null);\n\t\t\t}\n\t\t\tif (sessionToUse == null) {\n\t\t\t\tConnection conToUse;\n\t\t\t\tif (sharedConnectionEnabled()) {\n\t\t\t\t\tconToUse = getSharedConnection();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconToUse = createConnection();\n\t\t\t\t\tconToClose = conToUse;\n\t\t\t\t\tconToUse.start();\n\t\t\t\t}\n\t\t\t\tsessionToUse = createSession(conToUse);\n\t\t\t\tsessionToClose = sessionToUse;\n\t\t\t}\n\t\t\tMessageConsumer consumerToUse = consumer;\n\t\t\tif (consumerToUse == null) {\n\t\t\t\tconsumerToUse = createListenerConsumer(sessionToUse);\n\t\t\t\tconsumerToClose = consumerToUse;\n\t\t\t}\n\t\t\tMessage message = receiveMessage(consumerToUse);\n\t\t\tif (message != null) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Received message of type [\" + message.getClass() + \"] from consumer [\" +\n\t\t\t\t\t\t\tconsumerToUse + \"] of \" + (transactional ? \"transactional \" : \"\") + \"session [\" +\n\t\t\t\t\t\t\tsessionToUse + \"]\");\n\t\t\t\t}\n\t\t\t\tmessageReceived(invoker, sessionToUse);\n\t\t\t\tboolean exposeResource = (!transactional && isExposeListenerSession() &&\n\t\t\t\t\t\t!TransactionSynchronizationManager.hasResource(obtainConnectionFactory()));\n\t\t\t\tif (exposeResource) {\n\t\t\t\t\tTransactionSynchronizationManager.bindResource(\n\t\t\t\t\t\t\tobtainConnectionFactory(), new LocallyExposedJmsResourceHolder(sessionToUse));\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tdoExecuteListener(sessionToUse, message);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tif (status != null) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Rolling back transaction because of listener exception thrown: \" + ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstatus.setRollbackOnly();\n\t\t\t\t\t}\n\t\t\t\t\thandleListenerException(ex);\n\t\t\t\t\t// Rethrow JMSException to indicate an infrastructure problem\n\t\t\t\t\t// that may have to trigger recovery...\n\t\t\t\t\tif (ex instanceof JMSException jmsException) {\n\t\t\t\t\t\tthrow jmsException;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tif (exposeResource) {\n\t\t\t\t\t\tTransactionSynchronizationManager.unbindResource(obtainConnectionFactory());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Indicate that a message has been received.\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Consumer [\" + consumerToUse + \"] of \" + (transactional ? \"transactional \" : \"\") +\n\t\t\t\t\t\t\t\"session [\" + sessionToUse + \"] did not receive a message\");\n\t\t\t\t}\n\t\t\t\tnoMessageReceived(invoker, sessionToUse);\n\t\t\t\t// Nevertheless call commit, in order to reset the transaction timeout (if any).\n\t\t\t\tif (shouldCommitAfterNoMessageReceived(sessionToUse)) {\n\t\t\t\t\tcommitIfNecessary(sessionToUse, null);\n\t\t\t\t}\n\t\t\t\t// Indicate that no message has been received.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageConsumer(consumerToClose);\n\t\t\tJmsUtils.closeSession(sessionToClose);\n\t\t\tConnectionFactoryUtils.releaseConnection(conToClose, getConnectionFactory(), true);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#executeListener(session,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the specified listener,\n\t * committing or rolling back the transaction afterwards (if necessary).\n\t * @param session the JMS Session to operate on\n\t * @param message the received JMS Message\n\t * @see #invokeListener\n\t * @see #commitIfNecessary\n\t * @see #rollbackOnExceptionIfNecessary\n\t * @see #handleListenerException\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 643
    },
    "return": "void",
    "signature": "protected void executeListener(Session session, Message message)",
    "source_code": "\tprotected void executeListener(Session session, Message message) {\n\t\ttry {\n\t\t\tdoExecuteListener(session, message);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\thandleListenerException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#handleListenerSetupFailure(ex,alreadyRecovered)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the given exception that arose during setup of a listener.\n\t * Called for every such exception in every concurrent listener.\n\t * <p>The default implementation logs the exception at warn level\n\t * if not recovered yet, and at debug level if already recovered.\n\t * Can be overridden in subclasses.\n\t * @param ex the exception to handle\n\t * @param alreadyRecovered whether a previously executing listener\n\t * already recovered from the present listener setup failure\n\t * (this usually indicates a follow-up failure than can be ignored\n\t * other than for debug log purposes)\n\t * @see #recoverAfterListenerSetupFailure()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "alreadyRecovered"
    ],
    "position": {
      "column": 1,
      "line": 915
    },
    "return": "void",
    "signature": "protected void handleListenerSetupFailure(Throwable ex, boolean alreadyRecovered)",
    "source_code": "\tprotected void handleListenerSetupFailure(Throwable ex, boolean alreadyRecovered) {\n\t\tif (ex instanceof JMSException jmsException) {\n\t\t\tinvokeExceptionListener(jmsException);\n\t\t}\n\t\tif (ex instanceof SharedConnectionNotInitializedException) {\n\t\t\tif (!alreadyRecovered) {\n\t\t\t\tlogger.debug(\"JMS message listener invoker needs to establish shared Connection\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Recovery during active operation..\n\t\t\tif (alreadyRecovered) {\n\t\t\t\tlogger.debug(\"Setup of JMS message listener invoker failed - already recovered by other invoker\", ex);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tStringBuilder msg = new StringBuilder();\n\t\t\t\tmsg.append(\"Setup of JMS message listener invoker failed for destination '\");\n\t\t\t\tmsg.append(getDestinationDescription()).append(\"' - trying to recover. Cause: \");\n\t\t\t\tmsg.append(ex instanceof JMSException jmsException ? JmsUtils.buildExceptionMessage(jmsException) :\n\t\t\t\t\t\tex.getMessage());\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.warn(msg, ex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.warn(msg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#invokeListener(session,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified listener: either as standard JMS MessageListener\n\t * or (preferably) as Spring SessionAwareMessageListener.\n\t * @param session the JMS Session to operate on\n\t * @param message the received JMS Message\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setMessageListener\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 692
    },
    "return": "void",
    "signature": "protected void invokeListener(Session session, Message message)",
    "source_code": "\tprotected void invokeListener(Session session, Message message) throws JMSException {\n\t\tObject listener = getMessageListener();\n\n\t\tif (listener instanceof SessionAwareMessageListener sessionAwareMessageListener) {\n\t\t\tdoInvokeListener(sessionAwareMessageListener, session, message);\n\t\t}\n\t\telse if (listener instanceof MessageListener msgListener) {\n\t\t\tdoInvokeListener(msgListener, message);\n\t\t}\n\t\telse if (listener != null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Only MessageListener and SessionAwareMessageListener supported: \" + listener);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"No message listener specified - see property 'messageListener'\");\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#messageReceived(invoker,session)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Tries scheduling a new invoker, since we know messages are coming in...\n\t * @see #scheduleNewInvokerIfAppropriate()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 786
    },
    "return": "void",
    "signature": "protected void messageReceived(Object invoker, Session session)",
    "source_code": "\tprotected void messageReceived(Object invoker, Session session) {\n\t\t((AsyncMessageListenerInvoker) invoker).setIdle(false);\n\t\tscheduleNewInvokerIfAppropriate();\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#noMessageReceived(invoker,session)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Marks the affected invoker as idle.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 795
    },
    "return": "void",
    "signature": "protected void noMessageReceived(Object invoker, Session session)",
    "source_code": "\tprotected void noMessageReceived(Object invoker, Session session) {\n\t\t((AsyncMessageListenerInvoker) invoker).setIdle(true);\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#receiveAndExecute(invoker,session,consumer)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the listener for a message received from the given consumer,\n\t * wrapping the entire operation in an external transaction if demanded.\n\t * @param session the JMS Session to work on\n\t * @param consumer the MessageConsumer to work on\n\t * @return whether a message has been received\n\t * @throws JMSException if thrown by JMS methods\n\t * @see #doReceiveAndExecute\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "session",
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "boolean",
    "signature": "protected boolean receiveAndExecute(Object invoker, @Nullable Session session, @Nullable MessageConsumer consumer)",
    "source_code": "\tprotected boolean receiveAndExecute(\n\t\t\tObject invoker, @Nullable Session session, @Nullable MessageConsumer consumer)\n\t\t\tthrows JMSException {\n\n\t\tif (this.transactionManager != null) {\n\t\t\t// Execute receive within transaction.\n\t\t\tTransactionStatus status = this.transactionManager.getTransaction(this.transactionDefinition);\n\t\t\tboolean messageReceived;\n\t\t\ttry {\n\t\t\t\tmessageReceived = doReceiveAndExecute(invoker, session, consumer, status);\n\t\t\t}\n\t\t\tcatch (JMSException | RuntimeException | Error ex) {\n\t\t\t\trollbackOnException(this.transactionManager, status, ex);\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthis.transactionManager.commit(status);\n\t\t\t}\n\t\t\tcatch (TransactionException ex) {\n\t\t\t\t// Propagate transaction system exceptions as infrastructure problems.\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (RuntimeException ex) {\n\t\t\t\t// Typically a late persistence exception from a listener-used resource\n\t\t\t\t// -> handle it as listener exception, not as an infrastructure problem.\n\t\t\t\t// E.g. a database locking failure should not lead to listener shutdown.\n\t\t\t\thandleListenerException(ex);\n\t\t\t}\n\t\t\treturn messageReceived;\n\t\t}\n\n\t\telse {\n\t\t\t// Execute receive outside of transaction.\n\t\t\treturn doReceiveAndExecute(invoker, session, consumer, null);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#rollbackOnExceptionIfNecessary(session,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a rollback, handling rollback exceptions properly.\n\t * @param session the JMS Session to rollback\n\t * @param ex the thrown application exception or error\n\t * @throws jakarta.jms.JMSException in case of a rollback error\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 807
    },
    "return": "void",
    "signature": "protected void rollbackOnExceptionIfNecessary(Session session, Throwable ex)",
    "source_code": "\tprotected void rollbackOnExceptionIfNecessary(Session session, Throwable ex) throws JMSException {\n\t\ttry {\n\t\t\tif (session.getTransacted()) {\n\t\t\t\tif (isSessionLocallyTransacted(session)) {\n\t\t\t\t\t// Transacted session created by this container -> rollback.\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Initiating transaction rollback on application exception\", ex);\n\t\t\t\t\t}\n\t\t\t\t\tJmsUtils.rollbackIfNecessary(session);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (isClientAcknowledge(session)) {\n\t\t\t\tsession.recover();\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalStateException ex2) {\n\t\t\tlogger.debug(\"Could not roll back because Session already closed\", ex2);\n\t\t}\n\t\tcatch (JMSException | RuntimeException | Error ex2) {\n\t\t\tlogger.error(\"Application exception overridden by rollback error\", ex);\n\t\t\tthrow ex2;\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#buildMessage(session,result)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Build a JMS message to be sent as response based on the given result object.\n\t * @param session the JMS Session to operate on\n\t * @param result the content of the message, as returned from the listener method\n\t * @return the JMS {@code Message} (never {@code null})\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setMessageConverter\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "Message",
    "signature": "protected Message buildMessage(Session session, Object result)",
    "source_code": "\tprotected Message buildMessage(Session session, Object result) throws JMSException {\n\t\tObject content = preProcessResponse(result instanceof JmsResponse<?> jmsResponse ?\n\t\t\t\tjmsResponse.getResponse() : result);\n\n\t\tMessageConverter converter = getMessageConverter();\n\t\tif (converter != null) {\n\t\t\tif (content instanceof org.springframework.messaging.Message) {\n\t\t\t\treturn this.messagingMessageConverter.toMessage(content, session);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn converter.toMessage(content, session);\n\t\t\t}\n\t\t}\n\n\t\tif (!(content instanceof Message message)) {\n\t\t\tthrow new MessageConversionException(\n\t\t\t\t\t\"No MessageConverter specified - cannot handle message [\" + content + \"]\");\n\t\t}\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#createMessageForPayload(payload,session,conversionHint)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "session",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 488
    },
    "return": "Message",
    "signature": "protected Message createMessageForPayload(Object payload, Session session, @Nullable Object conversionHint)",
    "source_code": "\t\tprotected Message createMessageForPayload(Object payload, Session session, @Nullable Object conversionHint)\n\t\t\t\tthrows JMSException {\n\n\t\t\tMessageConverter converter = getMessageConverter();\n\t\t\tif (converter == null) {\n\t\t\t\tthrow new IllegalStateException(\"No message converter, cannot handle '\" + payload + \"'\");\n\t\t\t}\n\t\t\tif (converter instanceof SmartMessageConverter smartMessageConverter) {\n\t\t\t\treturn smartMessageConverter.toMessage(payload, session, conversionHint);\n\n\t\t\t}\n\t\t\treturn converter.toMessage(payload, session);\n\t\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#forDestination(result,destination)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link JmsResponse} targeting the specified {@link Destination}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result",
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "JmsResponse<T>",
    "signature": "public JmsResponse<T> forDestination(T result, Destination destination)",
    "source_code": "\tpublic static <T> JmsResponse<T> forDestination(T result, Destination destination) {\n\t\tAssert.notNull(destination, \"Destination must not be null\");\n\t\treturn new JmsResponse<>(result, destination);\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#forQueue(result,queueName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link JmsResponse} targeting the queue with the specified name.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result",
      "queueName"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "JmsResponse<T>",
    "signature": "public JmsResponse<T> forQueue(T result, String queueName)",
    "source_code": "\tpublic static <T> JmsResponse<T> forQueue(T result, String queueName) {\n\t\tAssert.notNull(queueName, \"Queue name must not be null\");\n\t\treturn new JmsResponse<>(result, new DestinationNameHolder(queueName, false));\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#forTopic(result,topicName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link JmsResponse} targeting the topic with the specified name.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result",
      "topicName"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "JmsResponse<T>",
    "signature": "public JmsResponse<T> forTopic(T result, String topicName)",
    "source_code": "\tpublic static <T> JmsResponse<T> forTopic(T result, String topicName) {\n\t\tAssert.notNull(topicName, \"Topic name must not be null\");\n\t\treturn new JmsResponse<>(result, new DestinationNameHolder(topicName, true));\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#getListenerMethodName(originalMessage,extractedMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the name of the listener method that is supposed to\n\t * handle the given message.\n\t * <p>The default implementation simply returns the configured\n\t * default listener method, if any.\n\t * @param originalMessage the JMS request message\n\t * @param extractedMessage the converted JMS request message,\n\t * to be passed into the listener method as argument\n\t * @return the name of the listener method (never {@code null})\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setDefaultListenerMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "originalMessage",
      "extractedMessage"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "String",
    "signature": "protected String getListenerMethodName(Message originalMessage, Object extractedMessage)",
    "source_code": "\tprotected String getListenerMethodName(Message originalMessage, Object extractedMessage) throws JMSException {\n\t\treturn getDefaultListenerMethod();\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#getResponseDestination(request,response,session)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine a response destination for the given message.\n\t * <p>The default implementation first checks the JMS Reply-To\n\t * {@link Destination} of the supplied request; if that is not {@code null}\n\t * it is returned; if it is {@code null}, then the configured\n\t * {@link #resolveDefaultResponseDestination default response destination}\n\t * is returned; if this too is {@code null}, then an\n\t * {@link jakarta.jms.InvalidDestinationException} is thrown.\n\t * @param request the original incoming JMS message\n\t * @param response the outgoing JMS message about to be sent\n\t * @param session the JMS Session to operate on\n\t * @return the response destination (never {@code null})\n\t * @throws JMSException if thrown by JMS API methods\n\t * @throws jakarta.jms.InvalidDestinationException if no {@link Destination} can be determined\n\t * @see #setDefaultResponseDestination\n\t * @see jakarta.jms.Message#getJMSReplyTo()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "Destination",
    "signature": "protected Destination getResponseDestination(Message request, Message response, Session session)",
    "source_code": "\tprotected Destination getResponseDestination(Message request, Message response, Session session)\n\t\t\tthrows JMSException {\n\n\t\tDestination replyTo = request.getJMSReplyTo();\n\t\tif (replyTo == null) {\n\t\t\treplyTo = resolveDefaultResponseDestination(session);\n\t\t\tif (replyTo == null) {\n\t\t\t\tthrow new InvalidDestinationException(\"Cannot determine response destination: \" +\n\t\t\t\t\t\t\"Request message does not contain reply-to destination, and no default response destination set.\");\n\t\t\t}\n\t\t}\n\t\treturn replyTo;\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#handleResult(result,request,session)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the given result object returned from the listener method,\n\t * sending a response message back.\n\t * @param result the result object to handle (never {@code null})\n\t * @param request the original request message\n\t * @param session the JMS Session to operate on (may be {@code null})\n\t * @throws ReplyFailureException if the response message could not be sent\n\t * @see #buildMessage\n\t * @see #postProcessResponse\n\t * @see #getResponseDestination\n\t * @see #sendResponse\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "result",
      "request",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "void",
    "signature": "protected void handleResult(Object result, Message request, @Nullable Session session)",
    "source_code": "\tprotected void handleResult(Object result, Message request, @Nullable Session session) {\n\t\tif (session != null) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Listener method returned result [\" + result +\n\t\t\t\t\t\t\"] - generating response message for it\");\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tMessage response = buildMessage(session, result);\n\t\t\t\tpostProcessResponse(request, response);\n\t\t\t\tDestination destination = getResponseDestination(request, response, session, result);\n\t\t\t\tsendResponse(session, destination, response);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new ReplyFailureException(\"Failed to send reply with payload [\" + result + \"]\", ex);\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\t// No JMS Session available\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Listener method returned result [\" + result +\n\t\t\t\t\t\t\"]: not generating response message for it because of no JMS Session given\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#invokeListenerMethod(methodName,arguments)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified listener method.\n\t * @param methodName the name of the listener method\n\t * @param arguments the message arguments to be passed in\n\t * @return the result returned from the listener method\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #getListenerMethodName\n\t * @see #buildListenerArguments\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "Object",
    "signature": "protected Object invokeListenerMethod(String methodName, Object[] arguments)",
    "source_code": "\tprotected Object invokeListenerMethod(String methodName, Object[] arguments) throws JMSException {\n\t\ttry {\n\t\t\tMethodInvoker methodInvoker = new MethodInvoker();\n\t\t\tmethodInvoker.setTargetObject(getDelegate());\n\t\t\tmethodInvoker.setTargetMethod(methodName);\n\t\t\tmethodInvoker.setArguments(arguments);\n\t\t\tmethodInvoker.prepare();\n\t\t\treturn methodInvoker.invoke();\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tThrowable targetEx = ex.getTargetException();\n\t\t\tif (targetEx instanceof JMSException jmsException) {\n\t\t\t\tthrow jmsException;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new ListenerExecutionFailedException(\n\t\t\t\t\t\t\"Listener method '\" + methodName + \"' threw exception\", targetEx);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new ListenerExecutionFailedException(\"Failed to invoke target method '\" + methodName +\n\t\t\t\t\t\"' with arguments \" + ObjectUtils.nullSafeToString(arguments), ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#onMessage(jmsMessage,session)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jmsMessage",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void onMessage(jakarta.jms.Message jmsMessage, @Nullable Session session)",
    "source_code": "\tpublic void onMessage(jakarta.jms.Message jmsMessage, @Nullable Session session) throws JMSException {\n\t\tMessage<?> message = toMessagingMessage(jmsMessage);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Processing [\" + message + \"]\");\n\t\t}\n\t\tObject result = invokeHandler(jmsMessage, session, message);\n\t\tif (result != null) {\n\t\t\thandleResult(result, jmsMessage, session);\n\t\t}\n\t\telse {\n\t\t\tlogger.trace(\"No result object given - no result to handle\");\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#onMessage(message,session)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "void",
    "signature": "public void onMessage(Message message, @Nullable Session session)",
    "source_code": "\tpublic abstract void onMessage(Message message, @Nullable Session session) throws JMSException;"
  },
  "org.springframework.jms.listener.adapter.<unknown>#postProcessProducer(producer,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Post-process the given message producer before using it to send the response.\n\t * <p>The default implementation is empty.\n\t * @param producer the JMS message producer that will be used to send the message\n\t * @param response the outgoing JMS message about to be sent\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "producer",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "void",
    "signature": "protected void postProcessProducer(MessageProducer producer, Message response)",
    "source_code": "\tprotected void postProcessProducer(MessageProducer producer, Message response) throws JMSException {\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#postProcessResponse(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Post-process the given response message before it will be sent.\n\t * <p>The default implementation sets the response's correlation id\n\t * to the request message's correlation id, if any; otherwise to the\n\t * request message id.\n\t * @param request the original incoming JMS message\n\t * @param response the outgoing JMS message about to be sent\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see jakarta.jms.Message#setJMSCorrelationID\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "void",
    "signature": "protected void postProcessResponse(Message request, Message response)",
    "source_code": "\tprotected void postProcessResponse(Message request, Message response) throws JMSException {\n\t\tString correlation = request.getJMSCorrelationID();\n\t\tif (correlation == null) {\n\t\t\tcorrelation = request.getJMSMessageID();\n\t\t}\n\t\tresponse.setJMSCorrelationID(correlation);\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#resolveDestination(destinationResolver,session)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the {@link Destination} to use for this instance. The {@link DestinationResolver}\n\t * and {@link Session} can be used to resolve a destination at runtime.\n\t * @param destinationResolver the destination resolver to use if necessary\n\t * @param session the session to use, if necessary\n\t * @return the {@link Destination} to use\n\t * @throws JMSException if the DestinationResolver failed to resolve the destination\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationResolver",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "Destination",
    "signature": "public Destination resolveDestination(DestinationResolver destinationResolver, Session session)",
    "source_code": "\tpublic Destination resolveDestination(DestinationResolver destinationResolver, Session session)\n\t\t\tthrows JMSException {\n\n\t\tif (this.destination instanceof Destination dest) {\n\t\t\treturn dest;\n\t\t}\n\t\tif (this.destination instanceof DestinationNameHolder nameHolder) {\n\t\t\treturn destinationResolver.resolveDestinationName(session,\n\t\t\t\t\tnameHolder.destinationName, nameHolder.pubSubDomain);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#sendResponse(session,destination,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Send the given response message to the given destination.\n\t * @param response the JMS message to send\n\t * @param destination the JMS destination to send to\n\t * @param session the JMS session to operate on\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #postProcessProducer\n\t * @see jakarta.jms.Session#createProducer\n\t * @see jakarta.jms.MessageProducer#send\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "void",
    "signature": "protected void sendResponse(Session session, Destination destination, Message response)",
    "source_code": "\tprotected void sendResponse(Session session, Destination destination, Message response) throws JMSException {\n\t\tMessageProducer producer = session.createProducer(destination);\n\t\ttry {\n\t\t\tpostProcessProducer(producer, response);\n\t\t\tQosSettings settings = getResponseQosSettings();\n\t\t\tif (settings != null) {\n\t\t\t\tproducer.send(response, settings.getDeliveryMode(), settings.getPriority(),\n\t\t\t\t\t\tsettings.getTimeToLive());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tproducer.send(response);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.<unknown>#closeConnection(con,stop)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Close the given JMS Connection and ignore any thrown exception.\n\t * <p>This is useful for typical {@code finally} blocks in manual JMS code.\n\t * @param con the JMS Connection to close (may be {@code null})\n\t * @param stop whether to call {@code stop()} before closing\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "stop"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "public void closeConnection(@Nullable Connection con, boolean stop)",
    "source_code": "\tpublic static void closeConnection(@Nullable Connection con, boolean stop) {\n\t\tif (con != null) {\n\t\t\ttry {\n\t\t\t\tif (stop) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcon.stop();\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tcon.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcon.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (jakarta.jms.IllegalStateException ex) {\n\t\t\t\tlogger.debug(\"Ignoring Connection state exception - assuming already closed: \" + ex);\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tlogger.debug(\"Could not close JMS Connection\", ex);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// We don't trust the JMS provider: It might throw RuntimeException or Error.\n\t\t\t\tlogger.debug(\"Unexpected exception on closing JMS Connection\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.<unknown>#fromHeaders(headers,jmsMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headers",
      "jmsMessage"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "public void fromHeaders(MessageHeaders headers, jakarta.jms.Message jmsMessage)",
    "source_code": "\tpublic void fromHeaders(MessageHeaders headers, jakarta.jms.Message jmsMessage) {\n\t\ttry {\n\t\t\tObject jmsCorrelationId = headers.get(JmsHeaders.CORRELATION_ID);\n\t\t\tif (jmsCorrelationId instanceof Number) {\n\t\t\t\tjmsCorrelationId = jmsCorrelationId.toString();\n\t\t\t}\n\t\t\tif (jmsCorrelationId instanceof String correlationId) {\n\t\t\t\ttry {\n\t\t\t\t\tjmsMessage.setJMSCorrelationID(correlationId);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tlogger.debug(\"Failed to set JMSCorrelationID - skipping\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tDestination jmsReplyTo = getHeaderIfAvailable(headers, JmsHeaders.REPLY_TO, Destination.class);\n\t\t\tif (jmsReplyTo != null) {\n\t\t\t\ttry {\n\t\t\t\t\tjmsMessage.setJMSReplyTo(jmsReplyTo);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tlogger.debug(\"Failed to set JMSReplyTo - skipping\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tString jmsType = getHeaderIfAvailable(headers, JmsHeaders.TYPE, String.class);\n\t\t\tif (jmsType != null) {\n\t\t\t\ttry {\n\t\t\t\t\tjmsMessage.setJMSType(jmsType);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tlogger.debug(\"Failed to set JMSType - skipping\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Map.Entry<String, Object> entry : headers.entrySet()) {\n\t\t\t\tString headerName = entry.getKey();\n\t\t\t\tif (StringUtils.hasText(headerName) && !headerName.startsWith(JmsHeaders.PREFIX)) {\n\t\t\t\t\tObject value = entry.getValue();\n\t\t\t\t\tif (value != null && SUPPORTED_PROPERTY_TYPES.contains(value.getClass())) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString propertyName = fromHeaderName(headerName);\n\t\t\t\t\t\t\tjmsMessage.setObjectProperty(propertyName, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (headerName.startsWith(\"JMSX\")) {\n\t\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.trace(\"Skipping reserved header '\" + headerName +\n\t\t\t\t\t\t\t\t\t\t\t\"' since it cannot be set by client\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Failed to map message header '\" + headerName + \"' to JMS property\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Error occurred while mapping from MessageHeaders to JMS properties\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#convertFromBytesMessage(message,targetJavaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a BytesMessage to a Java Object with the specified type.\n\t * @param message the input message\n\t * @param targetJavaType the target type\n\t * @return the message converted to an object\n\t * @throws JMSException if thrown by JMS\n\t * @throws IOException in case of I/O errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetJavaType"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "Object",
    "signature": "protected Object convertFromBytesMessage(BytesMessage message, JavaType targetJavaType)",
    "source_code": "\tprotected Object convertFromBytesMessage(BytesMessage message, JavaType targetJavaType)\n\t\t\tthrows JMSException, IOException {\n\n\t\tString encoding = this.encoding;\n\t\tif (this.encodingPropertyName != null && message.propertyExists(this.encodingPropertyName)) {\n\t\t\tencoding = message.getStringProperty(this.encodingPropertyName);\n\t\t}\n\t\tbyte[] bytes = new byte[(int) message.getBodyLength()];\n\t\tmessage.readBytes(bytes);\n\t\tif (encoding != null) {\n\t\t\ttry {\n\t\t\t\tString body = new String(bytes, encoding);\n\t\t\t\treturn this.objectMapper.readValue(body, targetJavaType);\n\t\t\t}\n\t\t\tcatch (UnsupportedEncodingException ex) {\n\t\t\t\tthrow new MessageConversionException(\"Cannot convert bytes to String\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Jackson internally performs encoding detection, falling back to UTF-8.\n\t\t\treturn this.objectMapper.readValue(bytes, targetJavaType);\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#convertFromMessage(message,targetJavaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that allows for custom message mapping.\n\t * Invoked when {@link #setTargetType} is not {@link MessageType#TEXT} or\n\t * {@link MessageType#BYTES}.\n\t * <p>The default implementation throws an {@link IllegalArgumentException}.\n\t * @param message the input message\n\t * @param targetJavaType the target type\n\t * @return the message converted to an object\n\t * @throws JMSException if thrown by JMS\n\t * @throws IOException in case of I/O errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetJavaType"
    ],
    "position": {
      "column": 1,
      "line": 420
    },
    "return": "Object",
    "signature": "protected Object convertFromMessage(Message message, JavaType targetJavaType)",
    "source_code": "\tprotected Object convertFromMessage(Message message, JavaType targetJavaType)\n\t\t\tthrows JMSException, IOException {\n\n\t\tthrow new IllegalArgumentException(\"Unsupported message type [\" + message.getClass() +\n\t\t\t\t\"]. MappingJacksonMessageConverter by default only supports TextMessages and BytesMessages.\");\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#convertFromTextMessage(message,targetJavaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a TextMessage to a Java Object with the specified type.\n\t * @param message the input message\n\t * @param targetJavaType the target type\n\t * @return the message converted to an object\n\t * @throws JMSException if thrown by JMS\n\t * @throws IOException in case of I/O errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetJavaType"
    ],
    "position": {
      "column": 1,
      "line": 370
    },
    "return": "Object",
    "signature": "protected Object convertFromTextMessage(TextMessage message, JavaType targetJavaType)",
    "source_code": "\tprotected Object convertFromTextMessage(TextMessage message, JavaType targetJavaType)\n\t\t\tthrows JMSException, IOException {\n\n\t\tString body = message.getText();\n\t\treturn this.objectMapper.readValue(body, targetJavaType);\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#createMessageForByteArray(bytes,session)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS BytesMessage for the given byte array.\n\t * @param bytes the byte array to convert\n\t * @param session current JMS session\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @see jakarta.jms.Session#createBytesMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bytes",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "BytesMessage",
    "signature": "protected BytesMessage createMessageForByteArray(byte[] bytes, Session session)",
    "source_code": "\tprotected BytesMessage createMessageForByteArray(byte[] bytes, Session session) throws JMSException {\n\t\tBytesMessage message = session.createBytesMessage();\n\t\tmessage.writeBytes(bytes);\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#createMessageForMap(Map<?,map,session)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MapMessage for the given Map.\n\t * @param map the Map to convert\n\t * @param session current JMS session\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @see jakarta.jms.Session#createMapMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<?",
      "map",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "MapMessage",
    "signature": "protected MapMessage createMessageForMap(Map<?, ?> map, Session session)",
    "source_code": "\tprotected MapMessage createMessageForMap(Map<?, ?> map, Session session) throws JMSException {\n\t\tMapMessage message = session.createMapMessage();\n\t\tfor (Map.Entry<?, ?> entry : map.entrySet()) {\n\t\t\tObject key = entry.getKey();\n\t\t\tif (!(key instanceof String str)) {\n\t\t\t\tthrow new MessageConversionException(\"Cannot convert non-String key of type [\" +\n\t\t\t\t\t\tObjectUtils.nullSafeClassName(key) + \"] to JMS MapMessage entry\");\n\t\t\t}\n\t\t\tmessage.setObject(str, entry.getValue());\n\t\t}\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#createMessageForSerializable(object,session)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS ObjectMessage for the given Serializable object.\n\t * @param object the Serializable object to convert\n\t * @param session current JMS session\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @see jakarta.jms.Session#createObjectMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "ObjectMessage",
    "signature": "protected ObjectMessage createMessageForSerializable(Serializable object, Session session)",
    "source_code": "\tprotected ObjectMessage createMessageForSerializable(Serializable object, Session session) throws JMSException {\n\t\treturn session.createObjectMessage(object);\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#createMessageForString(text,session)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS TextMessage for the given String.\n\t * @param text the String to convert\n\t * @param session current JMS session\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @see jakarta.jms.Session#createTextMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "text",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "TextMessage",
    "signature": "protected TextMessage createMessageForString(String text, Session session)",
    "source_code": "\tprotected TextMessage createMessageForString(String text, Session session) throws JMSException {\n\t\treturn session.createTextMessage(text);\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#mapToBytesMessage(object,session,objectWriter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Map the given object to a {@link BytesMessage}.\n\t * @param object the object to be mapped\n\t * @param session current JMS session\n\t * @param objectWriter the writer to use\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @since 4.3\n\t * @see Session#createBytesMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "objectWriter"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "BytesMessage",
    "signature": "protected BytesMessage mapToBytesMessage(Object object, Session session, ObjectWriter objectWriter)",
    "source_code": "\tprotected BytesMessage mapToBytesMessage(Object object, Session session, ObjectWriter objectWriter)\n\t\t\tthrows JMSException, IOException {\n\n\t\tByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n\t\tif (this.encoding != null) {\n\t\t\tOutputStreamWriter writer = new OutputStreamWriter(bos, this.encoding);\n\t\t\tobjectWriter.writeValue(writer, object);\n\t\t}\n\t\telse {\n\t\t\t// Jackson usually defaults to UTF-8 but can also go straight to bytes, e.g. for Smile.\n\t\t\t// We use a direct byte array argument for the latter case to work as well.\n\t\t\tobjectWriter.writeValue(bos, object);\n\t\t}\n\n\t\tBytesMessage message = session.createBytesMessage();\n\t\tmessage.writeBytes(bos.toByteArray());\n\t\tif (this.encodingPropertyName != null) {\n\t\t\tmessage.setStringProperty(this.encodingPropertyName,\n\t\t\t\t\t(this.encoding != null ? this.encoding : DEFAULT_ENCODING));\n\t\t}\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#mapToMessage(object,session,objectWriter,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that allows for custom message mapping.\n\t * Invoked when {@link #setTargetType} is not {@link MessageType#TEXT} or\n\t * {@link MessageType#BYTES}.\n\t * <p>The default implementation throws an {@link IllegalArgumentException}.\n\t * @param object the object to marshal\n\t * @param session the JMS Session\n\t * @param objectWriter the writer to use\n\t * @param targetType the target message type (other than TEXT or BYTES)\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "objectWriter",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "Message",
    "signature": "protected Message mapToMessage(Object object, Session session, ObjectWriter objectWriter, MessageType targetType)",
    "source_code": "\tprotected Message mapToMessage(Object object, Session session, ObjectWriter objectWriter, MessageType targetType)\n\t\t\tthrows JMSException, IOException {\n\n\t\tthrow new IllegalArgumentException(\"Unsupported message type [\" + targetType +\n\t\t\t\t\"]. MappingJackson2MessageConverter by default only supports TextMessages and BytesMessages.\");\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#mapToTextMessage(object,session,objectWriter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Map the given object to a {@link TextMessage}.\n\t * @param object the object to be mapped\n\t * @param session current JMS session\n\t * @param objectWriter the writer to use\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @since 4.3\n\t * @see Session#createBytesMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "objectWriter"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "TextMessage",
    "signature": "protected TextMessage mapToTextMessage(Object object, Session session, ObjectWriter objectWriter)",
    "source_code": "\tprotected TextMessage mapToTextMessage(Object object, Session session, ObjectWriter objectWriter)\n\t\t\tthrows JMSException, IOException {\n\n\t\tStringWriter writer = new StringWriter(1024);\n\t\tobjectWriter.writeValue(writer, object);\n\t\treturn session.createTextMessage(writer.toString());\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#marshalToBytesMessage(object,session,marshaller)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Marshal the given object to a {@link BytesMessage}.\n\t * @param object the object to be marshalled\n\t * @param session current JMS session\n\t * @param marshaller the marshaller to use\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @throws XmlMappingException in case of OXM mapping errors\n\t * @see Session#createBytesMessage\n\t * @see Marshaller#marshal(Object, Result)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "marshaller"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "BytesMessage",
    "signature": "protected BytesMessage marshalToBytesMessage(Object object, Session session, Marshaller marshaller)",
    "source_code": "\tprotected BytesMessage marshalToBytesMessage(Object object, Session session, Marshaller marshaller)\n\t\t\tthrows JMSException, IOException, XmlMappingException {\n\n\t\tByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n\t\tStreamResult streamResult = new StreamResult(bos);\n\t\tmarshaller.marshal(object, streamResult);\n\t\tBytesMessage message = session.createBytesMessage();\n\t\tmessage.writeBytes(bos.toByteArray());\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#marshalToMessage(object,session,marshaller,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that allows for custom message marshalling.\n\t * Invoked when {@link #setTargetType} is not {@link MessageType#TEXT} or\n\t * {@link MessageType#BYTES}.\n\t * <p>The default implementation throws an {@link IllegalArgumentException}.\n\t * @param object the object to marshal\n\t * @param session the JMS session\n\t * @param marshaller the marshaller to use\n\t * @param targetType the target message type (other than TEXT or BYTES)\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @throws XmlMappingException in case of OXM mapping errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "marshaller",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "Message",
    "signature": "protected Message marshalToMessage(Object object, Session session, Marshaller marshaller, MessageType targetType)",
    "source_code": "\tprotected Message marshalToMessage(Object object, Session session, Marshaller marshaller, MessageType targetType)\n\t\t\tthrows JMSException, IOException, XmlMappingException {\n\n\t\tthrow new IllegalArgumentException(\"Unsupported message type [\" + targetType +\n\t\t\t\t\"]. MarshallingMessageConverter by default only supports TextMessages and BytesMessages.\");\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#marshalToTextMessage(object,session,marshaller)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Marshal the given object to a {@link TextMessage}.\n\t * @param object the object to be marshalled\n\t * @param session current JMS session\n\t * @param marshaller the marshaller to use\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @throws XmlMappingException in case of OXM mapping errors\n\t * @see Session#createTextMessage\n\t * @see Marshaller#marshal(Object, Result)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "marshaller"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "TextMessage",
    "signature": "protected TextMessage marshalToTextMessage(Object object, Session session, Marshaller marshaller)",
    "source_code": "\tprotected TextMessage marshalToTextMessage(Object object, Session session, Marshaller marshaller)\n\t\t\tthrows JMSException, IOException, XmlMappingException {\n\n\t\tStringWriter writer = new StringWriter(1024);\n\t\tResult result = new StreamResult(writer);\n\t\tmarshaller.marshal(object, result);\n\t\treturn session.createTextMessage(writer.toString());\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#setTypeIdMappings(Map<String,typeIdMappings)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify mappings from type ids to Java classes, if desired.\n\t * This allows for synthetic ids in the type id message property,\n\t * instead of transferring Java class names.\n\t * <p>Default is no custom mappings, i.e. transferring raw Java class names.\n\t * @param typeIdMappings a Map with type id values as keys and Java classes as values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "typeIdMappings"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void setTypeIdMappings(Map<String, Class<?>> typeIdMappings)",
    "source_code": "\tpublic void setTypeIdMappings(Map<String, Class<?>> typeIdMappings) {\n\t\tthis.idClassMappings = new HashMap<>();\n\t\ttypeIdMappings.forEach((id, clazz) -> {\n\t\t\tthis.idClassMappings.put(id, clazz);\n\t\t\tthis.classIdMappings.put(clazz, id);\n\t\t});\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#setTypeIdOnMessage(object,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a type id for the given payload object on the given JMS Message.\n\t * <p>The default implementation consults the configured type id mapping and\n\t * sets the resulting value (either a mapped id or the raw Java class name)\n\t * into the configured type id message property.\n\t * @param object the payload object to set a type id for\n\t * @param message the JMS Message on which to set the type id property\n\t * @throws JMSException if thrown by JMS methods\n\t * @see #getJavaTypeForMessage(jakarta.jms.Message)\n\t * @see #setTypeIdPropertyName(String)\n\t * @see #setTypeIdMappings(java.util.Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "void",
    "signature": "protected void setTypeIdOnMessage(Object object, Message message)",
    "source_code": "\tprotected void setTypeIdOnMessage(Object object, Message message) throws JMSException {\n\t\tif (this.typeIdPropertyName != null) {\n\t\t\tString typeId = this.classIdMappings.get(object.getClass());\n\t\t\tif (typeId == null) {\n\t\t\t\ttypeId = object.getClass().getName();\n\t\t\t}\n\t\t\tmessage.setStringProperty(this.typeIdPropertyName, typeId);\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#toMessage(object,session)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation creates a TextMessage for a String, a\n\t * BytesMessage for a byte array, a MapMessage for a Map,\n\t * and an ObjectMessage for a Serializable object.\n\t * @see #createMessageForString\n\t * @see #createMessageForByteArray\n\t * @see #createMessageForMap\n\t * @see #createMessageForSerializable\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "Message",
    "signature": "public Message toMessage(Object object, Session session)",
    "source_code": "\tpublic Message toMessage(Object object, Session session) throws JMSException, MessageConversionException {\n\t\tif (object instanceof Message message) {\n\t\t\treturn message;\n\t\t}\n\t\telse if (object instanceof String text) {\n\t\t\treturn createMessageForString(text, session);\n\t\t}\n\t\telse if (object instanceof byte[] bytes) {\n\t\t\treturn createMessageForByteArray(bytes, session);\n\t\t}\n\t\telse if (object instanceof Map<?, ?> map) {\n\t\t\treturn createMessageForMap(map, session);\n\t\t}\n\t\telse if (object instanceof Serializable serializable) {\n\t\t\treturn createMessageForSerializable(serializable, session);\n\t\t}\n\t\telse {\n\t\t\tthrow new MessageConversionException(\"Cannot convert object of type [\" +\n\t\t\t\t\tObjectUtils.nullSafeClassName(object) + \"] to JMS message. Supported message \" +\n\t\t\t\t\t\"payloads are: String, byte array, Map<String,?>, Serializable object.\");\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#toMessage(object,session,conversionHint)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "session",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "Message",
    "signature": "public Message toMessage(Object object, Session session, @Nullable Object conversionHint)",
    "source_code": "\tpublic Message toMessage(Object object, Session session, @Nullable Object conversionHint)\n\t\t\tthrows JMSException, MessageConversionException {\n\n\t\treturn toMessage(object, session, getSerializationView(conversionHint));\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#toMessage(object,session,jsonView)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a Java object to a JMS Message using the specified json view\n\t * and the supplied session  to create the message object.\n\t * @param object the object to convert\n\t * @param session the Session to use for creating a JMS Message\n\t * @param jsonView the view to use to filter the content\n\t * @return the JMS Message\n\t * @throws jakarta.jms.JMSException if thrown by JMS API methods\n\t * @throws MessageConversionException in case of conversion failure\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "session",
      "jsonView"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "Message",
    "signature": "public Message toMessage(Object object, Session session, @Nullable Class<?> jsonView)",
    "source_code": "\tpublic Message toMessage(Object object, Session session, @Nullable Class<?> jsonView)\n\t\t\tthrows JMSException, MessageConversionException {\n\n\t\tif (jsonView != null) {\n\t\t\treturn toMessage(object, session, this.objectMapper.writerWithView(jsonView));\n\t\t}\n\t\telse {\n\t\t\treturn toMessage(object, session, this.objectMapper.writer());\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#toMessage(object,session,objectWriter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "objectWriter"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "Message",
    "signature": "protected Message toMessage(Object object, Session session, ObjectWriter objectWriter)",
    "source_code": "\tprotected Message toMessage(Object object, Session session, ObjectWriter objectWriter)\n\t\t\tthrows JMSException, MessageConversionException {\n\n\t\tMessage message;\n\t\ttry {\n\t\t\tmessage = switch (this.targetType) {\n\t\t\t\tcase TEXT -> mapToTextMessage(object, session, objectWriter);\n\t\t\t\tcase BYTES -> mapToBytesMessage(object, session, objectWriter);\n\t\t\t\tdefault -> mapToMessage(object, session, objectWriter, this.targetType);\n\t\t\t};\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new MessageConversionException(\"Could not map JSON object [\" + object + \"]\", ex);\n\t\t}\n\t\tsetTypeIdOnMessage(object, message);\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#unmarshalFromBytesMessage(message,unmarshaller)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Unmarshal the given {@link BytesMessage} into an object.\n\t * @param message the message\n\t * @param unmarshaller the unmarshaller to use\n\t * @return the unmarshalled object\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @throws XmlMappingException in case of OXM mapping errors\n\t * @see Unmarshaller#unmarshal(Source)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "unmarshaller"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "Object",
    "signature": "protected Object unmarshalFromBytesMessage(BytesMessage message, Unmarshaller unmarshaller)",
    "source_code": "\tprotected Object unmarshalFromBytesMessage(BytesMessage message, Unmarshaller unmarshaller)\n\t\t\tthrows JMSException, IOException, XmlMappingException {\n\n\t\tbyte[] bytes = new byte[(int) message.getBodyLength()];\n\t\tmessage.readBytes(bytes);\n\t\tByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n\t\tStreamSource source = new StreamSource(bis);\n\t\treturn unmarshaller.unmarshal(source);\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#unmarshalFromMessage(message,unmarshaller)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that allows for custom message unmarshalling.\n\t * Invoked when {@link #fromMessage(Message)} is invoked with a message\n\t * that is not a {@link TextMessage} or {@link BytesMessage}.\n\t * <p>The default implementation throws an {@link IllegalArgumentException}.\n\t * @param message the message\n\t * @param unmarshaller the unmarshaller to use\n\t * @return the unmarshalled object\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @throws XmlMappingException in case of OXM mapping errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "unmarshaller"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "Object",
    "signature": "protected Object unmarshalFromMessage(Message message, Unmarshaller unmarshaller)",
    "source_code": "\tprotected Object unmarshalFromMessage(Message message, Unmarshaller unmarshaller)\n\t\t\tthrows JMSException, IOException, XmlMappingException {\n\n\t\tthrow new IllegalArgumentException(\"Unsupported message type [\" + message.getClass() +\n\t\t\t\t\"]. MarshallingMessageConverter by default only supports TextMessages and BytesMessages.\");\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#unmarshalFromTextMessage(message,unmarshaller)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Unmarshal the given {@link TextMessage} into an object.\n\t * @param message the message\n\t * @param unmarshaller the unmarshaller to use\n\t * @return the unmarshalled object\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @throws XmlMappingException in case of OXM mapping errors\n\t * @see Unmarshaller#unmarshal(Source)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "unmarshaller"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "Object",
    "signature": "protected Object unmarshalFromTextMessage(TextMessage message, Unmarshaller unmarshaller)",
    "source_code": "\tprotected Object unmarshalFromTextMessage(TextMessage message, Unmarshaller unmarshaller)\n\t\t\tthrows JMSException, IOException, XmlMappingException {\n\n\t\tSource source = new StreamSource(new StringReader(message.getText()));\n\t\treturn unmarshaller.unmarshal(source);\n\t}"
  },
  "org.springframework.jmx.access.<unknown>#convertResultValueIfNecessary(result,parameter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given result object (from attribute access or operation invocation)\n\t * to the specified target class for returning from the proxy method.\n\t * @param result the result object as returned by the {@code MBeanServer}\n\t * @param parameter the method parameter of the proxy method that's been invoked\n\t * @return the converted result object, or the passed-in object if no conversion\n\t * is necessary\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "result",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 556
    },
    "return": "Object",
    "signature": "protected Object convertResultValueIfNecessary(@Nullable Object result, MethodParameter parameter)",
    "source_code": "\tprotected Object convertResultValueIfNecessary(@Nullable Object result, MethodParameter parameter) {\n\t\tClass<?> targetClass = parameter.getParameterType();\n\t\ttry {\n\t\t\tif (result == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (ClassUtils.isAssignableValue(targetClass, result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (result instanceof CompositeData) {\n\t\t\t\tMethod fromMethod = targetClass.getMethod(\"from\", CompositeData.class);\n\t\t\t\treturn ReflectionUtils.invokeMethod(fromMethod, null, result);\n\t\t\t}\n\t\t\telse if (result instanceof CompositeData[] array) {\n\t\t\t\tif (targetClass.isArray()) {\n\t\t\t\t\treturn convertDataArrayToTargetArray(array, targetClass);\n\t\t\t\t}\n\t\t\t\telse if (Collection.class.isAssignableFrom(targetClass)) {\n\t\t\t\t\tClass<?> elementType =\n\t\t\t\t\t\t\tResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric();\n\t\t\t\t\tif (elementType != null) {\n\t\t\t\t\t\treturn convertDataArrayToTargetCollection(array, targetClass, elementType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (result instanceof TabularData) {\n\t\t\t\tMethod fromMethod = targetClass.getMethod(\"from\", TabularData.class);\n\t\t\t\treturn ReflectionUtils.invokeMethod(fromMethod, null, result);\n\t\t\t}\n\t\t\telse if (result instanceof TabularData[] array) {\n\t\t\t\tif (targetClass.isArray()) {\n\t\t\t\t\treturn convertDataArrayToTargetArray(array, targetClass);\n\t\t\t\t}\n\t\t\t\telse if (Collection.class.isAssignableFrom(targetClass)) {\n\t\t\t\t\tClass<?> elementType =\n\t\t\t\t\t\t\tResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric();\n\t\t\t\t\tif (elementType != null) {\n\t\t\t\t\t\treturn convertDataArrayToTargetCollection(array, targetClass, elementType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new InvocationFailureException(\n\t\t\t\t\t\"Incompatible result value [\" + result + \"] for target type [\" + targetClass.getName() + \"]\");\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\tthrow new InvocationFailureException(\n\t\t\t\t\t\"Could not obtain 'from(CompositeData)' / 'from(TabularData)' method on target type [\" +\n\t\t\t\t\t\t\ttargetClass.getName() + \"] for conversion of MXBean data structure [\" + result + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.jmx.access.<unknown>#handleConnectFailure(invocation,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Refresh the connection and retry the MBean invocation if possible.\n\t * <p>If not configured to refresh on connect failure, this method\n\t * simply rethrows the original exception.\n\t * @param invocation the invocation that failed\n\t * @param ex the exception raised on remote invocation\n\t * @return the result value of the new invocation, if succeeded\n\t * @throws Throwable an exception raised by the new invocation,\n\t * if it failed as well\n\t * @see #setRefreshOnConnectFailure\n\t * @see #doInvoke\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invocation",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "Object",
    "signature": "protected Object handleConnectFailure(MethodInvocation invocation, Exception ex)",
    "source_code": "\tprotected Object handleConnectFailure(MethodInvocation invocation, Exception ex) throws Throwable {\n\t\tif (this.refreshOnConnectFailure) {\n\t\t\tString msg = \"Could not connect to JMX server - retrying\";\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.warn(msg, ex);\n\t\t\t}\n\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(msg);\n\t\t\t}\n\t\t\tprepare();\n\t\t\treturn doInvoke(invocation);\n\t\t}\n\t\telse {\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.jmx.access.<unknown>#setEnvironment(Map<String,environment)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the environment for the JMX connector.\n\t * @see javax.management.remote.JMXConnectorFactory#connect(javax.management.remote.JMXServiceURL, java.util.Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "environment"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "public void setEnvironment(@Nullable Map<String, ?> environment)",
    "source_code": "\tpublic void setEnvironment(@Nullable Map<String, ?> environment) {\n\t\tthis.environment = environment;\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#createAndConfigureMBean(managedResource,beanKey)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Creates an MBean that is configured with the appropriate management\n\t * interface for the supplied managed resource.\n\t * @param managedResource the resource that is to be exported as an MBean\n\t * @param beanKey the key associated with the managed bean\n\t * @see #createModelMBean()\n\t * @see #getMBeanInfo(Object, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "managedResource",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 816
    },
    "return": "ModelMBean",
    "signature": "protected ModelMBean createAndConfigureMBean(Object managedResource, String beanKey)",
    "source_code": "\tprotected ModelMBean createAndConfigureMBean(Object managedResource, String beanKey)\n\t\t\tthrows MBeanExportException {\n\t\ttry {\n\t\t\tModelMBean mbean = createModelMBean();\n\t\t\tmbean.setModelMBeanInfo(getMBeanInfo(managedResource, beanKey));\n\t\t\tmbean.setManagedResource(managedResource, MR_TYPE_OBJECT_REFERENCE);\n\t\t\treturn mbean;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new MBeanExportException(\"Could not create ModelMBean for managed resource [\" +\n\t\t\t\t\tmanagedResource + \"] with key '\" + beanKey + \"'\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#getObjectName(bean,beanKey)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the {@code ObjectName} for a bean.\n\t * <p>If the bean implements the {@code SelfNaming} interface, then the\n\t * {@code ObjectName} will be retrieved using {@code SelfNaming.getObjectName()}.\n\t * Otherwise, the configured {@code ObjectNamingStrategy} is used.\n\t * @param bean the name of the bean in the {@code BeanFactory}\n\t * @param beanKey the key associated with the bean in the beans map\n\t * @return the {@code ObjectName} for the supplied bean\n\t * @throws javax.management.MalformedObjectNameException\n\t * if the retrieved {@code ObjectName} is malformed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 750
    },
    "return": "ObjectName",
    "signature": "protected ObjectName getObjectName(Object bean, @Nullable String beanKey)",
    "source_code": "\tprotected ObjectName getObjectName(Object bean, @Nullable String beanKey) throws MalformedObjectNameException {\n\t\tif (bean instanceof SelfNaming) {\n\t\t\treturn ((SelfNaming) bean).getObjectName();\n\t\t}\n\t\telse {\n\t\t\treturn this.namingStrategy.getObjectName(bean, beanKey);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#isBeanDefinitionLazyInit(beanFactory,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the specified bean definition should be considered as lazy-init.\n\t * @param beanFactory the bean factory that is supposed to contain the bean definition\n\t * @param beanName the name of the bean to check\n\t * @see org.springframework.beans.factory.config.ConfigurableListableBeanFactory#getBeanDefinition\n\t * @see org.springframework.beans.factory.config.BeanDefinition#isLazyInit\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactory",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "boolean",
    "signature": "protected boolean isBeanDefinitionLazyInit(ListableBeanFactory beanFactory, String beanName)",
    "source_code": "\tprotected boolean isBeanDefinitionLazyInit(ListableBeanFactory beanFactory, String beanName) {\n\t\treturn (beanFactory instanceof ConfigurableListableBeanFactory && beanFactory.containsBeanDefinition(beanName) &&\n\t\t\t\t((ConfigurableListableBeanFactory) beanFactory).getBeanDefinition(beanName).isLazyInit());\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#registerBeanNameOrInstance(mapValue,beanKey)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register an individual bean with the {@link #setServer MBeanServer}.\n\t * <p>This method is responsible for deciding <strong>how</strong> a bean\n\t * should be exposed to the {@code MBeanServer}. Specifically, if the\n\t * supplied {@code mapValue} is the name of a bean that is configured\n\t * for lazy initialization, then a proxy to the resource is registered with\n\t * the {@code MBeanServer} so that the lazy load behavior is\n\t * honored. If the bean is already an MBean then it will be registered\n\t * directly with the {@code MBeanServer} without any intervention. For\n\t * all other beans or bean names, the resource itself is registered with\n\t * the {@code MBeanServer} directly.\n\t * @param mapValue the value configured for this bean in the beans map;\n\t * may be either the {@code String} name of a bean, or the bean itself\n\t * @param beanKey the key associated with this bean in the beans map\n\t * @return the {@code ObjectName} under which the resource was registered\n\t * @throws MBeanExportException if the export failed\n\t * @see #setBeans\n\t * @see #registerBeanInstance\n\t * @see #registerLazyInit\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapValue",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 588
    },
    "return": "ObjectName",
    "signature": "protected ObjectName registerBeanNameOrInstance(Object mapValue, String beanKey)",
    "source_code": "\tprotected ObjectName registerBeanNameOrInstance(Object mapValue, String beanKey) throws MBeanExportException {\n\t\ttry {\n\t\t\tif (mapValue instanceof String beanName) {\n\t\t\t\t// Bean name pointing to a potentially lazy-init bean in the factory.\n\t\t\t\tif (this.beanFactory == null) {\n\t\t\t\t\tthrow new MBeanExportException(\"Cannot resolve bean names if not running in a BeanFactory\");\n\t\t\t\t}\n\t\t\t\tif (isBeanDefinitionLazyInit(this.beanFactory, beanName)) {\n\t\t\t\t\tObjectName objectName = registerLazyInit(beanName, beanKey);\n\t\t\t\t\treplaceNotificationListenerBeanNameKeysIfNecessary(beanName, objectName);\n\t\t\t\t\treturn objectName;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tObject bean = this.beanFactory.getBean(beanName);\n\t\t\t\t\tObjectName objectName = registerBeanInstance(bean, beanKey);\n\t\t\t\t\treplaceNotificationListenerBeanNameKeysIfNecessary(beanName, objectName);\n\t\t\t\t\treturn objectName;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Plain bean instance -> register it directly.\n\t\t\t\tif (this.beanFactory != null) {\n\t\t\t\t\tMap<String, ?> beansOfSameType =\n\t\t\t\t\t\t\tthis.beanFactory.getBeansOfType(mapValue.getClass(), false, this.allowEagerInit);\n\t\t\t\t\tfor (Map.Entry<String, ?> entry : beansOfSameType.entrySet()) {\n\t\t\t\t\t\tif (entry.getValue() == mapValue) {\n\t\t\t\t\t\t\tString beanName = entry.getKey();\n\t\t\t\t\t\t\tObjectName objectName = registerBeanInstance(mapValue, beanKey);\n\t\t\t\t\t\t\treplaceNotificationListenerBeanNameKeysIfNecessary(beanName, objectName);\n\t\t\t\t\t\t\treturn objectName;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn registerBeanInstance(mapValue, beanKey);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new UnableToRegisterMBeanException(\n\t\t\t\t\t\"Unable to register MBean [\" + mapValue + \"] with key '\" + beanKey + \"'\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#registerManagedResource(managedResource,objectName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "managedResource",
      "objectName"
    ],
    "position": {
      "column": 1,
      "line": 480
    },
    "return": "void",
    "signature": "public void registerManagedResource(Object managedResource, ObjectName objectName)",
    "source_code": "\tpublic void registerManagedResource(Object managedResource, ObjectName objectName) throws MBeanExportException {\n\t\tAssert.notNull(managedResource, \"Managed resource must not be null\");\n\t\tAssert.notNull(objectName, \"ObjectName must not be null\");\n\t\ttry {\n\t\t\tif (isMBean(managedResource.getClass())) {\n\t\t\t\tdoRegister(managedResource, objectName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tModelMBean mbean = createAndConfigureMBean(managedResource, managedResource.getClass().getName());\n\t\t\t\tdoRegister(mbean, objectName);\n\t\t\t\tinjectNotificationPublisherIfNecessary(managedResource, mbean, objectName);\n\t\t\t}\n\t\t}\n\t\tcatch (JMException ex) {\n\t\t\tthrow new UnableToRegisterMBeanException(\n\t\t\t\t\t\"Unable to register MBean [\" + managedResource + \"] with object name [\" + objectName + \"]\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#setBeans(Map<String,beans)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Supply a {@code Map} of beans to be registered with the JMX\n\t * {@code MBeanServer}.\n\t * <p>The String keys are the basis for the creation of JMX object names.\n\t * By default, a JMX {@code ObjectName} will be created straight\n\t * from the given key. This can be customized through specifying a\n\t * custom {@code NamingStrategy}.\n\t * <p>Both bean instances and bean names are allowed as values.\n\t * Bean instances are typically linked in through bean references.\n\t * Bean names will be resolved as beans in the current factory, respecting\n\t * lazy-init markers (that is, not triggering initialization of such beans).\n\t * @param beans a Map with JMX names as keys and bean instances or bean names\n\t * as values\n\t * @see #setNamingStrategy\n\t * @see org.springframework.jmx.export.naming.KeyNamingStrategy\n\t * @see javax.management.ObjectName#ObjectName(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "beans"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void setBeans(Map<String, Object> beans)",
    "source_code": "\tpublic void setBeans(Map<String, Object> beans) {\n\t\tthis.beans = beans;\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#setNotificationListenerMappings(Map<?,listeners)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link NotificationListener NotificationListeners} to register\n\t * with the {@link javax.management.MBeanServer}.\n\t * <P>The key of each entry in the {@code Map} is a {@link String}\n\t * representation of the {@link javax.management.ObjectName} or the bean\n\t * name of the MBean the listener should be registered for. Specifying an\n\t * asterisk ({@code *}) for a key will cause the listener to be\n\t * associated with all MBeans registered by this class at startup time.\n\t * <p>The value of each entry is the\n\t * {@link javax.management.NotificationListener} to register. For more\n\t * advanced options such as registering\n\t * {@link javax.management.NotificationFilter NotificationFilters} and\n\t * handback objects see {@link #setNotificationListeners(NotificationListenerBean[])}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "listeners"
    ],
    "position": {
      "column": 1,
      "line": 371
    },
    "return": "void",
    "signature": "public void setNotificationListenerMappings(Map<?, ? extends NotificationListener> listeners)",
    "source_code": "\tpublic void setNotificationListenerMappings(Map<?, ? extends NotificationListener> listeners) {\n\t\tAssert.notNull(listeners, \"'listeners' must not be null\");\n\t\tList<NotificationListenerBean> notificationListeners =\n\t\t\t\tnew ArrayList<>(listeners.size());\n\n\t\tlisteners.forEach((key, listener) -> {\n\t\t\t// Get the listener from the map value.\n\t\t\tNotificationListenerBean bean = new NotificationListenerBean(listener);\n\t\t\t// Get the ObjectName from the map key.\n\t\t\tif (key != null && !WILDCARD.equals(key)) {\n\t\t\t\t// This listener is mapped to a specific ObjectName.\n\t\t\t\tbean.setMappedObjectName(key);\n\t\t\t}\n\t\t\tnotificationListeners.add(bean);\n\t\t});\n\n\t\tthis.notificationListeners = notificationListeners.toArray(new NotificationListenerBean[0]);\n\t}"
  },
  "org.springframework.jmx.export.assembler.<unknown>#getNotificationInfo(managedBean,beanKey)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "managedBean",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "ModelMBeanNotificationInfo[]",
    "signature": "protected ModelMBeanNotificationInfo[] getNotificationInfo(Object managedBean, String beanKey)",
    "source_code": "\tprotected ModelMBeanNotificationInfo[] getNotificationInfo(Object managedBean, String beanKey) {\n\t\tModelMBeanNotificationInfo[] result = null;\n\t\tif (StringUtils.hasText(beanKey)) {\n\t\t\tresult = this.notificationInfoMappings.get(beanKey);\n\t\t}\n\t\tif (result == null) {\n\t\t\tresult = this.notificationInfos;\n\t\t}\n\t\treturn (result != null ? result : new ModelMBeanNotificationInfo[0]);\n\t}"
  },
  "org.springframework.jmx.export.assembler.<unknown>#setNotificationInfoMappings(Map<String,notificationInfoMappings)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "notificationInfoMappings"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "void",
    "signature": "public void setNotificationInfoMappings(Map<String, Object> notificationInfoMappings)",
    "source_code": "\tpublic void setNotificationInfoMappings(Map<String, Object> notificationInfoMappings) {\n\t\tnotificationInfoMappings.forEach((beanKey, result) ->\n\t\t\t\tthis.notificationInfoMappings.put(beanKey, extractNotificationMetadata(result)));\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addAttachment(attachmentFilename,dataSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attachment to the MimeMessage, taking the content from a\n\t * {@code jakarta.activation.DataSource}.\n\t * <p>Note that the InputStream returned by the DataSource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * @param attachmentFilename the name of the attachment as it will\n\t * appear in the mail (the content type will be determined by this)\n\t * @param dataSource the {@code jakarta.activation.DataSource} to take\n\t * the content from, determining the InputStream and the content type\n\t * @throws MessagingException in case of errors\n\t * @see #addAttachment(String, org.springframework.core.io.InputStreamSource)\n\t * @see #addAttachment(String, java.io.File)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attachmentFilename",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 1016
    },
    "return": "void",
    "signature": "public void addAttachment(String attachmentFilename, DataSource dataSource)",
    "source_code": "\tpublic void addAttachment(String attachmentFilename, DataSource dataSource) throws MessagingException {\n\t\tAssert.notNull(attachmentFilename, \"Attachment filename must not be null\");\n\t\tAssert.notNull(dataSource, \"DataSource must not be null\");\n\t\ttry {\n\t\t\tMimeBodyPart mimeBodyPart = new MimeBodyPart();\n\t\t\tmimeBodyPart.setDisposition(Part.ATTACHMENT);\n\t\t\tmimeBodyPart.setFileName(isEncodeFilenames() ?\n\t\t\t\t\tMimeUtility.encodeText(attachmentFilename) : attachmentFilename);\n\t\t\tmimeBodyPart.setDataHandler(new DataHandler(dataSource));\n\t\t\tgetRootMimeMultipart().addBodyPart(mimeBodyPart);\n\t\t}\n\t\tcatch (UnsupportedEncodingException ex) {\n\t\t\tthrow new MessagingException(\"Failed to encode attachment filename\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addAttachment(attachmentFilename,file)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attachment to the MimeMessage, taking the content from a\n\t * {@code java.io.File}.\n\t * <p>The content type will be determined by the name of the given\n\t * content file. Do not use this for temporary files with arbitrary\n\t * filenames (possibly ending in \".tmp\" or the like)!\n\t * @param attachmentFilename the name of the attachment as it will\n\t * appear in the mail\n\t * @param file the File resource to take the content from\n\t * @throws MessagingException in case of errors\n\t * @see #addAttachment(String, org.springframework.core.io.InputStreamSource)\n\t * @see #addAttachment(String, jakarta.activation.DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attachmentFilename",
      "file"
    ],
    "position": {
      "column": 1,
      "line": 1045
    },
    "return": "void",
    "signature": "public void addAttachment(String attachmentFilename, File file)",
    "source_code": "\tpublic void addAttachment(String attachmentFilename, File file) throws MessagingException {\n\t\tAssert.notNull(file, \"File must not be null\");\n\t\tFileDataSource dataSource = new FileDataSource(file);\n\t\tdataSource.setFileTypeMap(getFileTypeMap());\n\t\taddAttachment(attachmentFilename, dataSource);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addAttachment(attachmentFilename,inputStreamSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attachment to the MimeMessage, taking the content from an\n\t * {@code org.springframework.core.io.InputStreamResource}.\n\t * <p>The content type will be determined by the given filename for\n\t * the attachment. Thus, any content source will be fine, including\n\t * temporary files with arbitrary filenames.\n\t * <p>Note that the InputStream returned by the InputStreamSource\n\t * implementation needs to be a <i>fresh one on each call</i>, as\n\t * JavaMail will invoke {@code getInputStream()} multiple times.\n\t * @param attachmentFilename the name of the attachment as it will\n\t * appear in the mail\n\t * @param inputStreamSource the resource to take the content from\n\t * (all of Spring's Resource implementations can be passed in here)\n\t * @throws MessagingException in case of errors\n\t * @see #addAttachment(String, java.io.File)\n\t * @see #addAttachment(String, jakarta.activation.DataSource)\n\t * @see org.springframework.core.io.Resource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attachmentFilename",
      "inputStreamSource"
    ],
    "position": {
      "column": 1,
      "line": 1070
    },
    "return": "void",
    "signature": "public void addAttachment(String attachmentFilename, InputStreamSource inputStreamSource)",
    "source_code": "\tpublic void addAttachment(String attachmentFilename, InputStreamSource inputStreamSource)\n\t\t\tthrows MessagingException {\n\n\t\tString contentType = getFileTypeMap().getContentType(attachmentFilename);\n\t\taddAttachment(attachmentFilename, inputStreamSource, contentType);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addAttachment(attachmentFilename,inputStreamSource,contentType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attachment to the MimeMessage, taking the content from an\n\t * {@code org.springframework.core.io.InputStreamResource}.\n\t * <p>Note that the InputStream returned by the InputStreamSource\n\t * implementation needs to be a <i>fresh one on each call</i>, as\n\t * JavaMail will invoke {@code getInputStream()} multiple times.\n\t * @param attachmentFilename the name of the attachment as it will\n\t * appear in the mail\n\t * @param inputStreamSource the resource to take the content from\n\t * (all of Spring's Resource implementations can be passed in here)\n\t * @param contentType the content type to use for the element\n\t * @throws MessagingException in case of errors\n\t * @see #addAttachment(String, java.io.File)\n\t * @see #addAttachment(String, jakarta.activation.DataSource)\n\t * @see org.springframework.core.io.Resource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attachmentFilename",
      "inputStreamSource",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 1093
    },
    "return": "void",
    "signature": "public void addAttachment(String attachmentFilename, InputStreamSource inputStreamSource, String contentType)",
    "source_code": "\tpublic void addAttachment(\n\t\t\tString attachmentFilename, InputStreamSource inputStreamSource, String contentType)\n\t\t\tthrows MessagingException {\n\n\t\tAssert.notNull(inputStreamSource, \"InputStreamSource must not be null\");\n\t\tif (inputStreamSource instanceof Resource resource && resource.isOpen()) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Passed-in Resource contains an open stream: invalid argument. \" +\n\t\t\t\t\t\"JavaMail requires an InputStreamSource that creates a fresh stream for every call.\");\n\t\t}\n\t\tDataSource dataSource = createDataSource(inputStreamSource, contentType, attachmentFilename);\n\t\taddAttachment(attachmentFilename, dataSource);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addBcc(bcc,personal)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bcc",
      "personal"
    ],
    "position": {
      "column": 1,
      "line": 727
    },
    "return": "void",
    "signature": "public void addBcc(String bcc, String personal)",
    "source_code": "\tpublic void addBcc(String bcc, String personal) throws MessagingException, UnsupportedEncodingException {\n\t\tAssert.notNull(bcc, \"Bcc address must not be null\");\n\t\taddBcc(getEncoding() != null ?\n\t\t\tnew InternetAddress(bcc, personal, getEncoding()) :\n\t\t\tnew InternetAddress(bcc, personal));\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addCc(cc,personal)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cc",
      "personal"
    ],
    "position": {
      "column": 1,
      "line": 682
    },
    "return": "void",
    "signature": "public void addCc(String cc, String personal)",
    "source_code": "\tpublic void addCc(String cc, String personal) throws MessagingException, UnsupportedEncodingException {\n\t\tAssert.notNull(cc, \"Cc address must not be null\");\n\t\taddCc(getEncoding() != null ?\n\t\t\tnew InternetAddress(cc, personal, getEncoding()) :\n\t\t\tnew InternetAddress(cc, personal));\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,dataSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from a\n\t * {@code jakarta.activation.DataSource}.\n\t * <p>Note that the InputStream returned by the DataSource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@link #setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: e.g. \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param dataSource the {@code jakarta.activation.DataSource} to take\n\t * the content from, determining the InputStream and the content type\n\t * @throws MessagingException in case of errors\n\t * @see #addInline(String, java.io.File)\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 907
    },
    "return": "void",
    "signature": "public void addInline(String contentId, DataSource dataSource)",
    "source_code": "\tpublic void addInline(String contentId, DataSource dataSource) throws MessagingException {\n\t\tAssert.notNull(contentId, \"Content ID must not be null\");\n\t\tAssert.notNull(dataSource, \"DataSource must not be null\");\n\t\tMimeBodyPart mimeBodyPart = new MimeBodyPart();\n\t\tmimeBodyPart.setDisposition(Part.INLINE);\n\t\tmimeBodyPart.setContentID(\"<\" + contentId + \">\");\n\t\tmimeBodyPart.setDataHandler(new DataHandler(dataSource));\n\t\tgetMimeMultipart().addBodyPart(mimeBodyPart);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,file)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from a\n\t * {@code java.io.File}.\n\t * <p>The content type will be determined by the name of the given\n\t * content file. Do not use this for temporary files with arbitrary\n\t * filenames (possibly ending in \".tmp\" or the like)!\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@link #setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: e.g. \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param file the File resource to take the content from\n\t * @throws MessagingException in case of errors\n\t * @see #setText\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t * @see #addInline(String, jakarta.activation.DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "file"
    ],
    "position": {
      "column": 1,
      "line": 934
    },
    "return": "void",
    "signature": "public void addInline(String contentId, File file)",
    "source_code": "\tpublic void addInline(String contentId, File file) throws MessagingException {\n\t\tAssert.notNull(file, \"File must not be null\");\n\t\tFileDataSource dataSource = new FileDataSource(file);\n\t\tdataSource.setFileTypeMap(getFileTypeMap());\n\t\taddInline(contentId, dataSource);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,inputStreamSource,contentType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from an\n\t * {@code org.springframework.core.InputStreamResource}, and\n\t * specifying the content type explicitly.\n\t * <p>You can determine the content type for any given filename via a Java\n\t * Activation Framework's FileTypeMap, for example the one held by this helper.\n\t * <p>Note that the InputStream returned by the InputStreamSource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@code setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: e.g. \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param inputStreamSource the resource to take the content from\n\t * @param contentType the content type to use for the element\n\t * @throws MessagingException in case of errors\n\t * @see #setText\n\t * @see #getFileTypeMap\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t * @see #addInline(String, jakarta.activation.DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "inputStreamSource",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 989
    },
    "return": "void",
    "signature": "public void addInline(String contentId, InputStreamSource inputStreamSource, String contentType)",
    "source_code": "\tpublic void addInline(String contentId, InputStreamSource inputStreamSource, String contentType)\n\t\t\tthrows MessagingException {\n\n\t\tAssert.notNull(inputStreamSource, \"InputStreamSource must not be null\");\n\t\tif (inputStreamSource instanceof Resource resource && resource.isOpen()) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Passed-in Resource contains an open stream: invalid argument. \" +\n\t\t\t\t\t\"JavaMail requires an InputStreamSource that creates a fresh stream for every call.\");\n\t\t}\n\t\tDataSource dataSource = createDataSource(inputStreamSource, contentType, \"inline\");\n\t\taddInline(contentId, dataSource);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,resource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from a\n\t * {@code org.springframework.core.io.Resource}.\n\t * <p>The content type will be determined by the name of the given\n\t * content file. Do not use this for temporary files with arbitrary\n\t * filenames (possibly ending in \".tmp\" or the like)!\n\t * <p>Note that the InputStream returned by the Resource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@link #setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: e.g. \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param resource the resource to take the content from\n\t * @throws MessagingException in case of errors\n\t * @see #setText\n\t * @see #addInline(String, java.io.File)\n\t * @see #addInline(String, jakarta.activation.DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 961
    },
    "return": "void",
    "signature": "public void addInline(String contentId, Resource resource)",
    "source_code": "\tpublic void addInline(String contentId, Resource resource) throws MessagingException {\n\t\tAssert.notNull(resource, \"Resource must not be null\");\n\t\tString contentType = getFileTypeMap().getContentType(resource.getFilename());\n\t\taddInline(contentId, resource, contentType);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addTo(to,personal)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "to",
      "personal"
    ],
    "position": {
      "column": 1,
      "line": 637
    },
    "return": "void",
    "signature": "public void addTo(String to, String personal)",
    "source_code": "\tpublic void addTo(String to, String personal) throws MessagingException, UnsupportedEncodingException {\n\t\tAssert.notNull(to, \"To address must not be null\");\n\t\taddTo(getEncoding() != null ?\n\t\t\tnew InternetAddress(to, personal, getEncoding()) :\n\t\t\tnew InternetAddress(to, personal));\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#createDataSource(inputStreamSource,contentType,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create an Activation Framework DataSource for the given InputStreamSource.\n\t * @param inputStreamSource the InputStreamSource (typically a Spring Resource)\n\t * @param contentType the content type\n\t * @param name the name of the DataSource\n\t * @return the Activation Framework DataSource\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "inputStreamSource",
      "contentType",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 1114
    },
    "return": "DataSource",
    "signature": "protected DataSource createDataSource(final InputStreamSource inputStreamSource, final String contentType, final String name)",
    "source_code": "\tprotected DataSource createDataSource(\n\t\tfinal InputStreamSource inputStreamSource, final String contentType, final String name) {\n\n\t\treturn new DataSource() {\n\t\t\t@Override\n\t\t\tpublic InputStream getInputStream() throws IOException {\n\t\t\t\treturn inputStreamSource.getInputStream();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic OutputStream getOutputStream() {\n\t\t\t\tthrow new UnsupportedOperationException(\"Read-only jakarta.activation.DataSource\");\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getContentType() {\n\t\t\t\treturn contentType;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getName() {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#createMimeMultiparts(mimeMessage,multipartMode)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the MimeMultipart objects to use, which will be used\n\t * to store attachments on the one hand and text(s) and inline elements\n\t * on the other hand.\n\t * <p>Texts and inline elements can either be stored in the root element\n\t * itself (MULTIPART_MODE_MIXED, MULTIPART_MODE_RELATED) or in a nested element\n\t * rather than the root element directly (MULTIPART_MODE_MIXED_RELATED).\n\t * <p>By default, the root MimeMultipart element will be of type \"mixed\"\n\t * (MULTIPART_MODE_MIXED) or \"related\" (MULTIPART_MODE_RELATED).\n\t * The main multipart element will either be added as nested element of\n\t * type \"related\" (MULTIPART_MODE_MIXED_RELATED) or be identical to the root\n\t * element itself (MULTIPART_MODE_MIXED, MULTIPART_MODE_RELATED).\n\t * @param mimeMessage the MimeMessage object to add the root MimeMultipart\n\t * object to\n\t * @param multipartMode the multipart mode, as passed into the constructor\n\t * (MIXED, RELATED, MIXED_RELATED, or NO)\n\t * @throws MessagingException if multipart creation failed\n\t * @see #setMimeMultiparts\n\t * @see #MULTIPART_MODE_NO\n\t * @see #MULTIPART_MODE_MIXED\n\t * @see #MULTIPART_MODE_RELATED\n\t * @see #MULTIPART_MODE_MIXED_RELATED\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mimeMessage",
      "multipartMode"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "void",
    "signature": "protected void createMimeMultiparts(MimeMessage mimeMessage, int multipartMode)",
    "source_code": "\tprotected void createMimeMultiparts(MimeMessage mimeMessage, int multipartMode) throws MessagingException {\n\t\tswitch (multipartMode) {\n\t\t\tcase MULTIPART_MODE_NO -> setMimeMultiparts(null, null);\n\t\t\tcase MULTIPART_MODE_MIXED -> {\n\t\t\t\tMimeMultipart mixedMultipart = new MimeMultipart(MULTIPART_SUBTYPE_MIXED);\n\t\t\t\tmimeMessage.setContent(mixedMultipart);\n\t\t\t\tsetMimeMultiparts(mixedMultipart, mixedMultipart);\n\t\t\t}\n\t\t\tcase MULTIPART_MODE_RELATED -> {\n\t\t\t\tMimeMultipart relatedMultipart = new MimeMultipart(MULTIPART_SUBTYPE_RELATED);\n\t\t\t\tmimeMessage.setContent(relatedMultipart);\n\t\t\t\tsetMimeMultiparts(relatedMultipart, relatedMultipart);\n\t\t\t}\n\t\t\tcase MULTIPART_MODE_MIXED_RELATED -> {\n\t\t\t\tMimeMultipart rootMixedMultipart = new MimeMultipart(MULTIPART_SUBTYPE_MIXED);\n\t\t\t\tmimeMessage.setContent(rootMixedMultipart);\n\t\t\t\tMimeMultipart nestedRelatedMultipart = new MimeMultipart(MULTIPART_SUBTYPE_RELATED);\n\t\t\t\tMimeBodyPart relatedBodyPart = new MimeBodyPart();\n\t\t\t\trelatedBodyPart.setContent(nestedRelatedMultipart);\n\t\t\t\trootMixedMultipart.addBodyPart(relatedBodyPart);\n\t\t\t\tsetMimeMultiparts(rootMixedMultipart, nestedRelatedMultipart);\n\t\t\t}\n\t\t\tdefault ->\n\t\t\t\tthrow new IllegalArgumentException(\"Only multipart modes MIXED_RELATED, RELATED and NO supported\");\n\t\t}\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#setFrom(from,personal)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "from",
      "personal"
    ],
    "position": {
      "column": 1,
      "line": 575
    },
    "return": "void",
    "signature": "public void setFrom(String from, String personal)",
    "source_code": "\tpublic void setFrom(String from, String personal) throws MessagingException, UnsupportedEncodingException {\n\t\tAssert.notNull(from, \"From address must not be null\");\n\t\tsetFrom(getEncoding() != null ?\n\t\t\tnew InternetAddress(from, personal, getEncoding()) : new InternetAddress(from, personal));\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#setMimeMultiparts(root,main)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given MimeMultipart objects for use by this MimeMessageHelper.\n\t * @param root the root MimeMultipart object, which attachments will be added to;\n\t * or {@code null} to indicate no multipart at all\n\t * @param main the main MimeMultipart object, which text(s) and inline elements\n\t * will be added to (can be the same as the root multipart object, or an element\n\t * nested underneath the root multipart element)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "root",
      "main"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "void",
    "signature": "protected void setMimeMultiparts(@Nullable MimeMultipart root, @Nullable MimeMultipart main)",
    "source_code": "\tprotected final void setMimeMultiparts(@Nullable MimeMultipart root, @Nullable MimeMultipart main) {\n\t\tthis.rootMimeMultipart = root;\n\t\tthis.mimeMultipart = main;\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#setReplyTo(replyTo,personal)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "replyTo",
      "personal"
    ],
    "position": {
      "column": 1,
      "line": 592
    },
    "return": "void",
    "signature": "public void setReplyTo(String replyTo, String personal)",
    "source_code": "\tpublic void setReplyTo(String replyTo, String personal) throws MessagingException, UnsupportedEncodingException {\n\t\tAssert.notNull(replyTo, \"Reply-to address must not be null\");\n\t\tInternetAddress replyToAddress = (getEncoding() != null) ?\n\t\t\t\tnew InternetAddress(replyTo, personal, getEncoding()) : new InternetAddress(replyTo, personal);\n\t\tsetReplyTo(replyToAddress);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#setText(plainText,htmlText)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given plain text and HTML text as alternatives, offering\n\t * both options to the email client. Requires multipart mode.\n\t * <p><b>NOTE:</b> Invoke {@link #addInline} <i>after</i> {@code setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param plainText the plain text for the message\n\t * @param htmlText the HTML text for the message\n\t * @throws MessagingException in case of errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "plainText",
      "htmlText"
    ],
    "position": {
      "column": 1,
      "line": 836
    },
    "return": "void",
    "signature": "public void setText(String plainText, String htmlText)",
    "source_code": "\tpublic void setText(String plainText, String htmlText) throws MessagingException {\n\t\tAssert.notNull(plainText, \"Plain text must not be null\");\n\t\tAssert.notNull(htmlText, \"HTML text must not be null\");\n\n\t\tMimeMultipart messageBody = new MimeMultipart(MULTIPART_SUBTYPE_ALTERNATIVE);\n\t\tgetMainPart().setContent(messageBody, CONTENT_TYPE_ALTERNATIVE);\n\n\t\t// Create the plain text part of the message.\n\t\tMimeBodyPart plainTextPart = new MimeBodyPart();\n\t\tsetPlainTextToMimePart(plainTextPart, plainText);\n\t\tmessageBody.addBodyPart(plainTextPart);\n\n\t\t// Create the HTML text part of the message.\n\t\tMimeBodyPart htmlTextPart = new MimeBodyPart();\n\t\tsetHtmlTextToMimePart(htmlTextPart, htmlText);\n\t\tmessageBody.addBodyPart(htmlTextPart);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#setText(text,html)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given text directly as content in non-multipart mode\n\t * or as default body part in multipart mode.\n\t * The \"html\" flag determines the content type to apply.\n\t * <p><b>NOTE:</b> Invoke {@link #addInline} <i>after</i> {@code setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param text the text for the message\n\t * @param html whether to apply content type \"text/html\" for an\n\t * HTML mail, using default content type (\"text/plain\") else\n\t * @throws MessagingException in case of errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "html"
    ],
    "position": {
      "column": 1,
      "line": 810
    },
    "return": "void",
    "signature": "public void setText(String text, boolean html)",
    "source_code": "\tpublic void setText(String text, boolean html) throws MessagingException {\n\t\tAssert.notNull(text, \"Text must not be null\");\n\t\tMimePart partToUse;\n\t\tif (isMultipart()) {\n\t\t\tpartToUse = getMainPart();\n\t\t}\n\t\telse {\n\t\t\tpartToUse = this.mimeMessage;\n\t\t}\n\t\tif (html) {\n\t\t\tsetHtmlTextToMimePart(partToUse, text);\n\t\t}\n\t\telse {\n\t\t\tsetPlainTextToMimePart(partToUse, text);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#canConvertFrom(message,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "boolean",
    "signature": "protected boolean canConvertFrom(Message<?> message, @Nullable Class<?> targetClass)",
    "source_code": "\tprotected boolean canConvertFrom(Message<?> message, @Nullable Class<?> targetClass) {\n\t\tif (targetClass == null || !supportsMimeType(message.getHeaders())) {\n\t\t\treturn false;\n\t\t}\n\t\tJavaType javaType = this.objectMapper.constructType(targetClass);\n\t\tAtomicReference<Throwable> causeRef = new AtomicReference<>();\n\t\tif (this.objectMapper.canDeserialize(javaType, causeRef)) {\n\t\t\treturn true;\n\t\t}\n\t\tlogWarningIfNecessary(javaType, causeRef.get());\n\t\treturn false;\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#canConvertTo(payload,headers)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "boolean",
    "signature": "protected boolean canConvertTo(Object payload, @Nullable MessageHeaders headers)",
    "source_code": "\tprotected boolean canConvertTo(Object payload, @Nullable MessageHeaders headers) {\n\t\tif (!supportsMimeType(headers)) {\n\t\t\treturn false;\n\t\t}\n\t\tAtomicReference<Throwable> causeRef = new AtomicReference<>();\n\t\tif (this.objectMapper.canSerialize(payload.getClass(), causeRef)) {\n\t\t\treturn true;\n\t\t}\n\t\tlogWarningIfNecessary(payload.getClass(), causeRef.get());\n\t\treturn false;\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#convertFromInternal(message,targetClass,conversionHint)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetClass",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "Object",
    "signature": "protected Object convertFromInternal(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint)",
    "source_code": "\tprotected Object convertFromInternal(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint) {\n\t\tJavaType javaType = this.objectMapper.constructType(getResolvedType(targetClass, conversionHint));\n\t\tObject payload = message.getPayload();\n\t\tClass<?> view = getSerializationView(conversionHint);\n\t\ttry {\n\t\t\tif (ClassUtils.isAssignableValue(targetClass, payload)) {\n\t\t\t\treturn payload;\n\t\t\t}\n\t\t\telse if (payload instanceof byte[]) {\n\t\t\t\tif (view != null) {\n\t\t\t\t\treturn this.objectMapper.readerWithView(view).forType(javaType).readValue((byte[]) payload);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn this.objectMapper.readValue((byte[]) payload, javaType);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Assuming a text-based source payload\n\t\t\t\tif (view != null) {\n\t\t\t\t\treturn this.objectMapper.readerWithView(view).forType(javaType).readValue(payload.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn this.objectMapper.readValue(payload.toString(), javaType);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new MessageConversionException(message, \"Could not read JSON: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#convertToInternal(payload,headers,conversionHint)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "headers",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "Object",
    "signature": "protected Object convertToInternal(Object payload, @Nullable MessageHeaders headers,\n\t\t\t@Nullable Object conversionHint)",
    "source_code": "\tprotected Object convertToInternal(Object payload, @Nullable MessageHeaders headers,\n\t\t\t@Nullable Object conversionHint) {\n\n\t\ttry {\n\t\t\tClass<?> view = getSerializationView(conversionHint);\n\t\t\tif (byte[].class == getSerializedPayloadClass()) {\n\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream(1024);\n\t\t\t\tJsonEncoding encoding = getJsonEncoding(getMimeType(headers));\n\t\t\t\ttry (JsonGenerator generator = this.objectMapper.getFactory().createGenerator(out, encoding)) {\n\t\t\t\t\tif (view != null) {\n\t\t\t\t\t\tthis.objectMapper.writerWithView(view).writeValue(generator, payload);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.objectMapper.writeValue(generator, payload);\n\t\t\t\t\t}\n\t\t\t\t\tpayload = out.toByteArray();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Assuming a text-based target payload\n\t\t\t\tWriter writer = new StringWriter(1024);\n\t\t\t\tif (view != null) {\n\t\t\t\t\tthis.objectMapper.writerWithView(view).writeValue(writer, payload);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.objectMapper.writeValue(writer, payload);\n\t\t\t\t}\n\t\t\t\tpayload = writer.toString();\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new MessageConversionException(\"Could not write JSON: \" + ex.getMessage(), ex);\n\t\t}\n\t\treturn payload;\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#fromMessage(message,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "Object",
    "signature": "public Object fromMessage(Message<?> message, Class<?> targetClass)",
    "source_code": "\tpublic final Object fromMessage(Message<?> message, Class<?> targetClass) {\n\t\treturn fromMessage(message, targetClass, null);\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#fromMessage(message,targetClass,conversionHint)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "targetClass",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "Object",
    "signature": "public Object fromMessage(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint)",
    "source_code": "\tpublic final Object fromMessage(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint) {\n\t\tif (!canConvertFrom(message, targetClass)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn convertFromInternal(message, targetClass, conversionHint);\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#logWarningIfNecessary(type,cause)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether to log the given exception coming from a\n\t * {@link ObjectMapper#canDeserialize} / {@link ObjectMapper#canSerialize} check.\n\t * @param type the class that Jackson tested for (de-)serializability\n\t * @param cause the Jackson-thrown exception to evaluate\n\t * (typically a {@link JsonMappingException})\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "void",
    "signature": "protected void logWarningIfNecessary(Type type, @Nullable Throwable cause)",
    "source_code": "\tprotected void logWarningIfNecessary(Type type, @Nullable Throwable cause) {\n\t\tif (cause == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Do not log warning for serializer not found (note: different message wording on Jackson 2.9)\n\t\tboolean debugLevel = (cause instanceof JsonMappingException && cause.getMessage().startsWith(\"Cannot find\"));\n\n\t\tif (debugLevel ? logger.isDebugEnabled() : logger.isWarnEnabled()) {\n\t\t\tString msg = \"Failed to evaluate Jackson \" + (type instanceof JavaType ? \"de\" : \"\") +\n\t\t\t\t\t\"serialization for type [\" + type + \"]\";\n\t\t\tif (debugLevel) {\n\t\t\t\tlogger.debug(msg, cause);\n\t\t\t}\n\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\tlogger.warn(msg, cause);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.warn(msg + \": \" + cause);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.<unknown>#assertTargetBean(method,targetBean,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the target bean class is an instance of the class where the given\n\t * method is declared. In some cases the actual endpoint instance at request-\n\t * processing time may be a JDK dynamic proxy (lazy initialization, prototype\n\t * beans, and others). Endpoint classes that require proxying should prefer\n\t * class-based proxy mechanisms.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetBean",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 353
    },
    "return": "void",
    "signature": "protected void assertTargetBean(Method method, Object targetBean, Object[] args)",
    "source_code": "\tprotected void assertTargetBean(Method method, Object targetBean, Object[] args) {\n\t\tClass<?> methodDeclaringClass = method.getDeclaringClass();\n\t\tClass<?> targetBeanClass = targetBean.getClass();\n\t\tif (!methodDeclaringClass.isAssignableFrom(targetBeanClass)) {\n\t\t\tString text = \"The mapped handler method class '\" + methodDeclaringClass.getName() +\n\t\t\t\t\t\"' is not an instance of the actual endpoint bean class '\" +\n\t\t\t\t\ttargetBeanClass.getName() + \"'. If the endpoint requires proxying \" +\n\t\t\t\t\t\"(e.g. due to @Transactional), please use class-based proxying.\";\n\t\t\tthrow new IllegalStateException(formatInvokeError(text, args));\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.<unknown>#compareTo(other,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "int",
    "signature": "public int compareTo(CompositeMessageCondition other, Message<?> message)",
    "source_code": "\tpublic int compareTo(CompositeMessageCondition other, Message<?> message) {\n\t\tcheckCompatible(other);\n\t\tList<MessageCondition<?>> otherConditions = other.getMessageConditions();\n\t\tfor (int i = 0; i < this.messageConditions.size(); i++) {\n\t\t\tint result = compare (this.messageConditions.get(i), otherConditions.get(i), message);\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}"
  },
  "org.springframework.messaging.handler.<unknown>#findProvidedArgument(parameter,providedArgs)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "Object",
    "signature": "protected Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs)",
    "source_code": "\tprotected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\n\t\tif (!ObjectUtils.isEmpty(providedArgs)) {\n\t\t\tfor (Object providedArg : providedArgs) {\n\t\t\t\tif (parameter.getParameterType().isInstance(providedArg)) {\n\t\t\t\t\treturn providedArg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.handler.<unknown>#formatArgumentError(param,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "param",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "String",
    "signature": "protected String formatArgumentError(MethodParameter param, String message)",
    "source_code": "\tprotected static String formatArgumentError(MethodParameter param, String message) {\n\t\treturn \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" +\n\t\t\t\tparam.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\n\t}"
  },
  "org.springframework.messaging.handler.<unknown>#formatInvokeError(text,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "text",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "String",
    "signature": "protected String formatInvokeError(String text, Object[] args)",
    "source_code": "\tprotected String formatInvokeError(String text, Object[] args) {\n\n\t\tString formattedArgs = IntStream.range(0, args.length)\n\t\t\t\t.mapToObj(i -> (args[i] != null ?\n\t\t\t\t\t\t\"[\" + i + \"] [type=\" + args[i].getClass().getName() + \"] [value=\" + args[i] + \"]\" :\n\t\t\t\t\t\t\"[\" + i + \"] [null]\"))\n\t\t\t\t.collect(Collectors.joining(\",\\n\", \" \", \" \"));\n\n\t\treturn text + \"\\n\" +\n\t\t\t\t\"Endpoint [\" + getBeanType().getName() + \"]\\n\" +\n\t\t\t\t\"Method [\" + getBridgedMethod().toGenericString() + \"] \" +\n\t\t\t\t\"with argument values:\\n\" + formattedArgs;\n\t}"
  },
  "org.springframework.messaging.handler.annotation.<unknown>#registerMethodHints(hints,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "void",
    "signature": "protected void registerMethodHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerMethodHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tregisterParameterHints(hints, method);\n\t\tregisterReturnValueHints(hints, method);\n\t}"
  },
  "org.springframework.messaging.handler.annotation.<unknown>#registerParameterHints(hints,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "protected void registerParameterHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerParameterHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tfor (Parameter parameter : method.getParameters()) {\n\t\t\tMethodParameter methodParameter = MethodParameter.forParameter(parameter);\n\t\t\tif (Message.class.isAssignableFrom(methodParameter.getParameterType())) {\n\t\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, getMessageType(methodParameter));\n\t\t\t}\n\t\t\telse if (couldBePayload(methodParameter)) {\n\t\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, methodParameter.getGenericParameterType());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.annotation.<unknown>#registerReflectionHints(hints,element)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "void",
    "signature": "public void registerReflectionHints(ReflectionHints hints, AnnotatedElement element)",
    "source_code": "\tpublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tif (element instanceof Class<?> type) {\n\t\t\tregisterTypeHints(hints, type);\n\t\t}\n\t\telse if (element instanceof Method method) {\n\t\t\tregisterMethodHints(hints, method);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.annotation.<unknown>#registerReturnValueHints(hints,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "protected void registerReturnValueHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerReturnValueHints(ReflectionHints hints, Method method) {\n\t\tMethodParameter returnType = MethodParameter.forExecutable(method, -1);\n\t\tthis.bindingRegistrar.registerReflectionHints(hints, returnType.getGenericParameterType());\n\t}"
  },
  "org.springframework.messaging.handler.annotation.<unknown>#registerTypeHints(hints,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "protected void registerTypeHints(ReflectionHints hints, Class<?> type)",
    "source_code": "\tprotected void registerTypeHints(ReflectionHints hints, Class<?> type) {\n\t\thints.registerType(type);\n\t}"
  },
  "org.springframework.messaging.handler.annotation.reactive.<unknown>#getMappingForMethod(method,handlerType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "CompositeMessageCondition",
    "signature": "protected CompositeMessageCondition getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected CompositeMessageCondition getMappingForMethod(Method method, Class<?> handlerType) {\n\t\tCompositeMessageCondition methodCondition = getCondition(method);\n\t\tif (methodCondition != null) {\n\t\t\tCompositeMessageCondition typeCondition = getCondition(handlerType);\n\t\t\tif (typeCondition != null) {\n\t\t\t\treturn typeCondition.combine(methodCondition);\n\t\t\t}\n\t\t}\n\t\treturn methodCondition;\n\t}"
  },
  "org.springframework.messaging.handler.annotation.reactive.<unknown>#getMatchingMapping(mapping,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "CompositeMessageCondition",
    "signature": "protected CompositeMessageCondition getMatchingMapping(CompositeMessageCondition mapping, Message<?> message)",
    "source_code": "\tprotected CompositeMessageCondition getMatchingMapping(CompositeMessageCondition mapping, Message<?> message) {\n\t\treturn mapping.getMatchingCondition(message);\n\t}"
  },
  "org.springframework.messaging.handler.annotation.reactive.<unknown>#handleMatch(mapping,handlerMethod,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "handlerMethod",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> handleMatch(CompositeMessageCondition mapping, HandlerMethod handlerMethod, Message<?> message)",
    "source_code": "\tprotected Mono<Void> handleMatch(\n\t\t\tCompositeMessageCondition mapping, HandlerMethod handlerMethod, Message<?> message) {\n\n\t\tSet<String> patterns = mapping.getCondition(DestinationPatternsMessageCondition.class).getPatterns();\n\t\tif (!CollectionUtils.isEmpty(patterns)) {\n\t\t\tString pattern = patterns.iterator().next();\n\t\t\tRouteMatcher.Route destination = getDestination(message);\n\t\t\tAssert.state(destination != null, \"Missing destination header\");\n\t\t\tMap<String, String> vars = obtainRouteMatcher().matchAndExtract(pattern, destination);\n\t\t\tif (!CollectionUtils.isEmpty(vars)) {\n\t\t\t\tMessageHeaderAccessor mha = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class);\n\t\t\t\tAssert.state(mha != null && mha.isMutable(), \"Mutable MessageHeaderAccessor required\");\n\t\t\t\tmha.setHeader(DestinationVariableMethodArgumentResolver.DESTINATION_TEMPLATE_VARIABLES_HEADER, vars);\n\t\t\t}\n\t\t}\n\t\treturn super.handleMatch(mapping, handlerMethod, message);\n\t}"
  },
  "org.springframework.messaging.handler.annotation.support.<unknown>#resolveArgument(parameter,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Object",
    "signature": "public Object resolveArgument(MethodParameter parameter, Message<?> message)",
    "source_code": "\tpublic Object resolveArgument(MethodParameter parameter, Message<?> message) throws Exception {\n\t\tPayload ann = parameter.getParameterAnnotation(Payload.class);\n\t\tif (ann != null && StringUtils.hasText(ann.expression())) {\n\t\t\tthrow new IllegalStateException(\"@Payload SpEL expressions not supported by this resolver\");\n\t\t}\n\n\t\tboolean isOptionalTargetClass = (parameter.getParameterType() == Optional.class);\n\t\tObject payload = message.getPayload();\n\t\tif (isEmptyPayload(payload)) {\n\t\t\tif ((ann == null || ann.required()) && !isOptionalTargetClass) {\n\t\t\t\tString paramName = getParameterName(parameter);\n\t\t\t\tBindingResult bindingResult = new BeanPropertyBindingResult(payload, paramName);\n\t\t\t\tbindingResult.addError(new ObjectError(paramName, \"Payload value must not be empty\"));\n\t\t\t\tthrow new MethodArgumentNotValidException(message, parameter, bindingResult);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (isOptionalTargetClass ? Optional.empty() : null);\n\t\t\t}\n\t\t}\n\n\t\tif (payload instanceof Optional<?> optional) {\n\t\t\tpayload = optional.get();\n\t\t\tmessage = MessageBuilder.createMessage(payload, message.getHeaders());\n\t\t}\n\n\t\tClass<?> targetClass = resolveTargetClass(parameter, message);\n\t\tClass<?> payloadClass = payload.getClass();\n\t\tif (ClassUtils.isAssignable(targetClass, payloadClass)) {\n\t\t\tvalidate(message, parameter, payload);\n\t\t\treturn (isOptionalTargetClass ? Optional.of(payload) : payload);\n\t\t}\n\t\telse {\n\t\t\tif (this.converter instanceof SmartMessageConverter smartConverter) {\n\t\t\t\tpayload = smartConverter.fromMessage(message, targetClass, parameter);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpayload = this.converter.fromMessage(message, targetClass);\n\t\t\t}\n\t\t\tif (payload == null) {\n\t\t\t\tthrow new MessageConversionException(message, \"Cannot convert from [\" +\n\t\t\t\t\t\tpayloadClass.getName() + \"] to [\" + targetClass.getName() + \"] for \" + message);\n\t\t\t}\n\t\t\tvalidate(message, parameter, payload);\n\t\t\treturn (isOptionalTargetClass ? Optional.of(payload) : payload);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.annotation.support.<unknown>#validate(message,parameter,target)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the payload if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param message the currently processed message\n\t * @param parameter the method parameter\n\t * @param target the target payload object\n\t * @throws MethodArgumentNotValidException in case of binding errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "parameter",
      "target"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "void",
    "signature": "protected void validate(Message<?> message, MethodParameter parameter, Object target)",
    "source_code": "\tprotected void validate(Message<?> message, MethodParameter parameter, Object target) {\n\t\tif (this.validator == null) {\n\t\t\treturn;\n\t\t}\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tValidated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class);\n\t\t\tif (validatedAnn != null || ann.annotationType().getSimpleName().startsWith(\"Valid\")) {\n\t\t\t\tObject hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann));\n\t\t\t\tObject[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] {hints});\n\t\t\t\tBeanPropertyBindingResult bindingResult =\n\t\t\t\t\t\tnew BeanPropertyBindingResult(target, getParameterName(parameter));\n\t\t\t\tif (!ObjectUtils.isEmpty(validationHints) && this.validator instanceof SmartValidator) {\n\t\t\t\t\t((SmartValidator) this.validator).validate(target, bindingResult, validationHints);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.validator.validate(target, bindingResult);\n\t\t\t\t}\n\t\t\t\tif (bindingResult.hasErrors()) {\n\t\t\t\t\tthrow new MethodArgumentNotValidException(message, parameter, bindingResult);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#accept(result,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 718
    },
    "return": "void",
    "signature": "public void accept(@Nullable Object result, @Nullable Throwable ex)",
    "source_code": "\t\tpublic void accept(@Nullable Object result, @Nullable Throwable ex) {\n\t\t\tif (result != null) {\n\t\t\t\ttry {\n\t\t\t\t\tMethodParameter returnType = this.handlerMethod.getAsyncReturnValueType(result);\n\t\t\t\t\treturnValueHandlers.handleReturnValue(result, returnType, this.message);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable throwable) {\n\t\t\t\t\thandleFailure(throwable);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ex != null) {\n\t\t\t\thandleFailure(ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#compare(match1,match2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "match1",
      "match2"
    ],
    "position": {
      "column": 1,
      "line": 700
    },
    "return": "int",
    "signature": "public int compare(Match match1, Match match2)",
    "source_code": "\t\tpublic int compare(Match match1, Match match2) {\n\t\t\treturn this.comparator.compare(match1.mapping, match2.mapping);\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#createHandlerMethod(handler,method)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a HandlerMethod instance from an Object handler that is either a handler\n\t * instance or a String-based bean name.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod createHandlerMethod(Object handler, Method method)",
    "source_code": "\tprotected HandlerMethod createHandlerMethod(Object handler, Method method) {\n\t\tHandlerMethod handlerMethod;\n\t\tif (handler instanceof String beanName) {\n\t\t\tApplicationContext context = getApplicationContext();\n\t\t\tAssert.state(context != null, \"ApplicationContext is required for resolving handler bean names\");\n\t\t\thandlerMethod = new HandlerMethod(beanName, context.getAutowireCapableBeanFactory(), method);\n\t\t}\n\t\telse {\n\t\t\thandlerMethod = new HandlerMethod(handler, method);\n\t\t}\n\t\treturn handlerMethod;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#getExceptionHandlerMethod(handlerMethod,exception)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find an {@code @MessageExceptionHandler} method for the given exception.\n\t * The default implementation searches methods in the class hierarchy of the\n\t * HandlerMethod first and if not found, it continues searching for additional\n\t * {@code @MessageExceptionHandler} methods among the configured\n\t * {@linkplain org.springframework.messaging.handler.MessagingAdviceBean\n\t * MessagingAdviceBean}, if any.\n\t * @param handlerMethod the method where the exception was raised\n\t * @param exception the raised exception\n\t * @return a method to handle the exception, or {@code null}\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handlerMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 631
    },
    "return": "InvocableHandlerMethod",
    "signature": "protected InvocableHandlerMethod getExceptionHandlerMethod(HandlerMethod handlerMethod, Exception exception)",
    "source_code": "\tprotected InvocableHandlerMethod getExceptionHandlerMethod(HandlerMethod handlerMethod, Exception exception) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Searching methods to handle \" + exception.getClass().getSimpleName());\n\t\t}\n\t\tClass<?> beanType = handlerMethod.getBeanType();\n\t\tAbstractExceptionHandlerMethodResolver resolver = this.exceptionHandlerCache.get(beanType);\n\t\tif (resolver == null) {\n\t\t\tresolver = createExceptionHandlerMethodResolverFor(beanType);\n\t\t\tthis.exceptionHandlerCache.put(beanType, resolver);\n\t\t}\n\t\tMethod method = resolver.resolveMethod(exception);\n\t\tif (method != null) {\n\t\t\treturn new InvocableHandlerMethod(handlerMethod.getBean(), method);\n\t\t}\n\t\tfor (Map.Entry<MessagingAdviceBean, AbstractExceptionHandlerMethodResolver> entry : this.exceptionHandlerAdviceCache.entrySet()) {\n\t\t\tMessagingAdviceBean advice = entry.getKey();\n\t\t\tif (advice.isApplicableToBeanType(beanType)) {\n\t\t\t\tresolver = entry.getValue();\n\t\t\t\tmethod = resolver.resolveMethod(exception);\n\t\t\t\tif (method != null) {\n\t\t\t\t\treturn new InvocableHandlerMethod(advice.resolveBean(), method);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#getMappingForMethod(method,handlerType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Provide the mapping for a handler method.\n\t * @param method the method to provide a mapping for\n\t * @param handlerType the handler type, possibly a subtype of the method's declaring class\n\t * @return the mapping, or {@code null} if the method is not mapped\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "T",
    "signature": "protected T getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected abstract T getMappingForMethod(Method method, Class<?> handlerType);"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#getMatchingMapping(mapping,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check if a mapping matches the current message and return a possibly\n\t * new mapping with conditions relevant to the current request.\n\t * @param mapping the mapping to get a match for\n\t * @param message the message being handled\n\t * @return the match or {@code null} if there is no match\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "T",
    "signature": "protected T getMatchingMapping(T mapping, Message<?> message)",
    "source_code": "\tprotected abstract T getMatchingMapping(T mapping, Message<?> message);"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#handleMatch(mapping,handlerMethod,lookupDestination,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "handlerMethod",
      "lookupDestination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 556
    },
    "return": "void",
    "signature": "protected void handleMatch(T mapping, HandlerMethod handlerMethod, String lookupDestination, Message<?> message)",
    "source_code": "\tprotected void handleMatch(T mapping, HandlerMethod handlerMethod, String lookupDestination, Message<?> message) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Invoking \" + handlerMethod.getShortLogMessage());\n\t\t}\n\t\thandlerMethod = handlerMethod.createWithResolvedBean();\n\t\tInvocableHandlerMethod invocable = new InvocableHandlerMethod(handlerMethod);\n\t\tif (this.handlerMethodLogger != null) {\n\t\t\tinvocable.setLogger(this.handlerMethodLogger);\n\t\t}\n\t\tinvocable.setMessageMethodArgumentResolvers(this.argumentResolvers);\n\t\ttry {\n\t\t\tObject returnValue = invocable.invoke(message);\n\t\t\tMethodParameter returnType = handlerMethod.getReturnType();\n\t\t\tif (void.class == returnType.getParameterType()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (returnValue != null && this.returnValueHandlers.isAsyncReturnValue(returnValue, returnType)) {\n\t\t\t\tCompletableFuture<?> future = this.returnValueHandlers.toCompletableFuture(returnValue, returnType);\n\t\t\t\tif (future != null) {\n\t\t\t\t\tfuture.whenComplete(new ReturnValueListenableFutureCallback(invocable, message));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.returnValueHandlers.handleReturnValue(returnValue, returnType, message);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tprocessHandlerMethodException(handlerMethod, ex, message);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tException handlingException =\n\t\t\t\t\tnew MessageHandlingException(message, \"Unexpected handler method invocation error\", ex);\n\t\t\tprocessHandlerMethodException(handlerMethod, handlingException, message);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#handleMessageInternal(message,lookupDestination)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "lookupDestination"
    ],
    "position": {
      "column": 1,
      "line": 488
    },
    "return": "void",
    "signature": "protected void handleMessageInternal(Message<?> message, String lookupDestination)",
    "source_code": "\tprotected void handleMessageInternal(Message<?> message, String lookupDestination) {\n\t\tList<Match> matches = new ArrayList<>();\n\n\t\tList<T> mappingsByUrl = this.destinationLookup.get(lookupDestination);\n\t\tif (mappingsByUrl != null) {\n\t\t\taddMatchesToCollection(mappingsByUrl, message, matches);\n\t\t}\n\t\tif (matches.isEmpty()) {\n\t\t\t// No direct hits, go through all mappings\n\t\t\tSet<T> allMappings = this.handlerMethods.keySet();\n\t\t\taddMatchesToCollection(allMappings, message, matches);\n\t\t}\n\t\tif (matches.isEmpty()) {\n\t\t\thandleNoMatch(this.handlerMethods.keySet(), lookupDestination, message);\n\t\t\treturn;\n\t\t}\n\n\t\tComparator<Match> comparator = new MatchComparator(getMappingComparator(message));\n\t\tmatches.sort(comparator);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Found \" + matches.size() + \" handler methods: \" + matches);\n\t\t}\n\n\t\tMatch bestMatch = matches.get(0);\n\t\tif (matches.size() > 1) {\n\t\t\tMatch secondBestMatch = matches.get(1);\n\t\t\tif (comparator.compare(bestMatch, secondBestMatch) == 0) {\n\t\t\t\tMethod m1 = bestMatch.handlerMethod.getMethod();\n\t\t\t\tMethod m2 = secondBestMatch.handlerMethod.getMethod();\n\t\t\t\tthrow new IllegalStateException(\"Ambiguous handler methods mapped for destination '\" +\n\t\t\t\t\t\tlookupDestination + \"': {\" + m1 + \", \" + m2 + \"}\");\n\t\t\t}\n\t\t}\n\n\t\thandleMatch(bestMatch.mapping, bestMatch.handlerMethod, lookupDestination, message);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#handleNoMatch(ts,lookupDestination,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ts",
      "lookupDestination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "void",
    "signature": "protected void handleNoMatch(Set<T> ts, String lookupDestination, Message<?> message)",
    "source_code": "\tprotected void handleNoMatch(Set<T> ts, String lookupDestination, Message<?> message) {\n\t\tlogger.debug(\"No matching message handler methods.\");\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#handleReturnValue(returnValue,returnType,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)\n\t\t\tthrows Exception {\n\n\t\tHandlerMethodReturnValueHandler handler = getReturnValueHandler(returnType);\n\t\tif (handler == null) {\n\t\t\tthrow new IllegalStateException(\"No handler for return value type: \" + returnType.getParameterType());\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Processing return value with \" + handler);\n\t\t}\n\t\thandler.handleReturnValue(returnValue, returnType, message);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#isAsyncReturnValue(returnValue,returnType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "boolean",
    "signature": "public boolean isAsyncReturnValue(Object returnValue, MethodParameter returnType)",
    "source_code": "\tpublic boolean isAsyncReturnValue(Object returnValue, MethodParameter returnType) {\n\t\tHandlerMethodReturnValueHandler handler = getReturnValueHandler(returnType);\n\t\treturn (handler instanceof AsyncHandlerMethodReturnValueHandler asyncHandler &&\n\t\t\t\tasyncHandler.isAsyncReturnValue(returnValue, returnType));\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#processHandlerMethodException(handlerMethod,exception,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handlerMethod",
      "exception",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 592
    },
    "return": "void",
    "signature": "protected void processHandlerMethodException(HandlerMethod handlerMethod, Exception exception, Message<?> message)",
    "source_code": "\tprotected void processHandlerMethodException(HandlerMethod handlerMethod, Exception exception, Message<?> message) {\n\t\tInvocableHandlerMethod invocable = getExceptionHandlerMethod(handlerMethod, exception);\n\t\tif (invocable == null) {\n\t\t\tlogger.error(\"Unhandled exception from message handler method\", exception);\n\t\t\treturn;\n\t\t}\n\t\tinvocable.setMessageMethodArgumentResolvers(this.argumentResolvers);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Invoking \" + invocable.getShortLogMessage());\n\t\t}\n\t\ttry {\n\t\t\tThrowable cause = exception.getCause();\n\t\t\tObject returnValue = (cause != null ?\n\t\t\t\t\tinvocable.invoke(message, exception, cause, handlerMethod) :\n\t\t\t\t\tinvocable.invoke(message, exception, handlerMethod));\n\t\t\tMethodParameter returnType = invocable.getReturnType();\n\t\t\tif (void.class == returnType.getParameterType()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.returnValueHandlers.handleReturnValue(returnValue, returnType, message);\n\t\t}\n\t\tcatch (Throwable ex2) {\n\t\t\tlogger.error(\"Error while processing handler method exception\", ex2);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#registerExceptionHandlerAdvice(bean,resolver)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can invoke this method to populate the MessagingAdviceBean cache\n\t * (e.g. to support \"global\" {@code @MessageExceptionHandler}).\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 421
    },
    "return": "void",
    "signature": "protected void registerExceptionHandlerAdvice(MessagingAdviceBean bean, AbstractExceptionHandlerMethodResolver resolver)",
    "source_code": "\tprotected void registerExceptionHandlerAdvice(\n\t\t\tMessagingAdviceBean bean, AbstractExceptionHandlerMethodResolver resolver) {\n\n\t\tthis.exceptionHandlerAdviceCache.put(bean, resolver);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#registerHandlerMethod(handler,method,mapping)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a handler method and its unique mapping.\n\t * @param handler the bean name of the handler or the handler instance\n\t * @param method the method to register\n\t * @param mapping the mapping conditions associated with the handler method\n\t * @throws IllegalStateException if another method was already registered\n\t * under the same mapping\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "void",
    "signature": "protected void registerHandlerMethod(Object handler, Method method, T mapping)",
    "source_code": "\tprotected void registerHandlerMethod(Object handler, Method method, T mapping) {\n\t\tAssert.notNull(mapping, \"Mapping must not be null\");\n\t\tHandlerMethod newHandlerMethod = createHandlerMethod(handler, method);\n\t\tHandlerMethod oldHandlerMethod = this.handlerMethods.get(mapping);\n\n\t\tif (oldHandlerMethod != null && !oldHandlerMethod.equals(newHandlerMethod)) {\n\t\t\tthrow new IllegalStateException(\"Ambiguous mapping found. Cannot map '\" + newHandlerMethod.getBean() +\n\t\t\t\t\t\"' bean method \\n\" + newHandlerMethod + \"\\nto \" + mapping + \": There is already '\" +\n\t\t\t\t\toldHandlerMethod.getBean() + \"' bean method\\n\" + oldHandlerMethod + \" mapped.\");\n\t\t}\n\n\t\tthis.handlerMethods.put(mapping, newHandlerMethod);\n\n\t\tfor (String pattern : getDirectLookupDestinations(mapping)) {\n\t\t\tthis.destinationLookup.add(pattern, mapping);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#invoke(message,providedArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method for the given exchange.\n\t * @param message the current message\n\t * @param providedArgs optional list of argument values to match by type\n\t * @return a Mono with the result from the invocation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "Mono<Object>",
    "signature": "public Mono<Object> invoke(Message<?> message, Object... providedArgs)",
    "source_code": "\tpublic Mono<Object> invoke(Message<?> message, Object... providedArgs) {\n\t\treturn getMethodArgumentValues(message, providedArgs).flatMap(args -> {\n\t\t\tObject value;\n\t\t\tboolean isSuspendingFunction = false;\n\t\t\ttry {\n\t\t\t\tMethod method = getBridgedMethod();\n\t\t\t\tif (KotlinDetector.isSuspendingFunction(method)) {\n\t\t\t\t\tisSuspendingFunction = true;\n\t\t\t\t\tvalue = CoroutinesUtils.invokeSuspendingFunction(method, getBean(), args);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvalue = method.invoke(getBean(), args);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tassertTargetBean(getBridgedMethod(), getBean(), args);\n\t\t\t\tString text = (ex.getMessage() != null ? ex.getMessage() : \"Illegal argument\");\n\t\t\t\treturn Mono.error(new IllegalStateException(formatInvokeError(text, args), ex));\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\treturn Mono.error(ex.getTargetException());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// Unlikely to ever get here, but it must be handled...\n\t\t\t\treturn Mono.error(new IllegalStateException(formatInvokeError(\"Invocation failure\", args), ex));\n\t\t\t}\n\n\t\t\tMethodParameter returnType = getReturnType();\n\t\t\tClass<?> reactiveType = (isSuspendingFunction ? value.getClass() : returnType.getParameterType());\n\t\t\tReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(reactiveType);\n\t\t\treturn (isAsyncVoidReturnType(returnType, adapter) ?\n\t\t\t\t\tMono.from(adapter.toPublisher(value)) : Mono.justOrEmpty(value));\n\t\t});\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#createPayload(data,metadata)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a Payload from the given metadata and data.\n\t * <p>If at least one is {@link NettyDataBuffer} then {@link ByteBufPayload}\n\t * is created with either obtaining the underlying native {@link ByteBuf}\n\t * or using {@link Unpooled#wrappedBuffer(ByteBuffer...)} if necessary.\n\t * Otherwise, if both are {@link DefaultDataBuffer}, then\n\t * {@link DefaultPayload} is created.\n\t * @param data the data part for the payload\n\t * @param metadata the metadata part for the payload\n\t * @return the created payload\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "data",
      "metadata"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "Payload",
    "signature": "public Payload createPayload(DataBuffer data, DataBuffer metadata)",
    "source_code": "\tpublic static Payload createPayload(DataBuffer data, DataBuffer metadata) {\n\t\treturn data instanceof NettyDataBuffer || metadata instanceof NettyDataBuffer ?\n\t\t\t\tByteBufPayload.create(asByteBuf(data), asByteBuf(metadata)) :\n\t\t\t\tDefaultPayload.create(asByteBuffer(data), asByteBuffer(metadata));\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#metadata(metadata,mimeType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a metadata entry. If called more than once or in addition to route,\n\t * composite metadata must be in use.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadata",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "MetadataEncoder",
    "signature": "public MetadataEncoder metadata(Object metadata, @Nullable MimeType mimeType)",
    "source_code": "\tpublic MetadataEncoder metadata(Object metadata, @Nullable MimeType mimeType) {\n\t\tif (this.isComposite) {\n\t\t\tAssert.notNull(mimeType, \"MimeType is required for composite metadata entries.\");\n\t\t}\n\t\telse if (mimeType == null) {\n\t\t\tmimeType = this.metadataMimeType;\n\t\t}\n\t\telse if (!this.metadataMimeType.equals(mimeType)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Mime type is optional when not using composite metadata, but it was provided \" +\n\t\t\t\t\t\t\t\"and does not match the connection metadata mime type '\" + this.metadataMimeType + \"'.\");\n\t\t}\n\t\tReactiveAdapter adapter = this.strategies.reactiveAdapterRegistry().getAdapter(metadata.getClass());\n\t\tif (adapter != null) {\n\t\t\tObject originalMetadata = metadata;\n\t\t\tAssert.isTrue(!adapter.isMultiValue(), () -> \"Expected single value: \" + originalMetadata);\n\t\t\tmetadata = Mono.from(adapter.toPublisher(metadata)).defaultIfEmpty(NO_VALUE);\n\t\t\tthis.hasAsyncValues = true;\n\t\t}\n\t\tthis.metadataEntries.add(new MetadataEntry(metadata, mimeType));\n\t\tassertMetadataEntryCount();\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#metadataAndOrRoute(Map<Object,metadata,route,vars)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add route and/or metadata, both optional.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Object",
      "metadata",
      "route",
      "vars"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "MetadataEncoder",
    "signature": "public MetadataEncoder metadataAndOrRoute(@Nullable Map<Object, MimeType> metadata,\n\t\t\t@Nullable String route, @Nullable Object[] vars)",
    "source_code": "\tpublic MetadataEncoder metadataAndOrRoute(@Nullable Map<Object, MimeType> metadata,\n\t\t\t@Nullable String route, @Nullable Object[] vars) {\n\n\t\tif (route != null) {\n\t\t\tthis.route = expand(route, vars != null ? vars : new Object[0]);\n\t\t}\n\t\tif (!CollectionUtils.isEmpty(metadata)) {\n\t\t\tfor (Map.Entry<Object, MimeType> entry : metadata.entrySet()) {\n\t\t\t\tmetadata(entry.getKey(), entry.getValue());\n\t\t\t}\n\t\t}\n\t\tassertMetadataEntryCount();\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#retainDataAndReleasePayload(payload,bufferFactory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Use this method to slice, retain and wrap the data portion of the\n\t * {@code Payload}, and also to release the {@code Payload}. This assumes\n\t * the Payload metadata has been read by now and ensures downstream code\n\t * need only be aware of {@code DataBuffer}s.\n\t * @param payload the payload to process\n\t * @param bufferFactory the DataBufferFactory to wrap with\n\t * @return the created {@code DataBuffer} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload",
      "bufferFactory"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer retainDataAndReleasePayload(Payload payload, DataBufferFactory bufferFactory)",
    "source_code": "\tpublic static DataBuffer retainDataAndReleasePayload(Payload payload, DataBufferFactory bufferFactory) {\n\t\ttry {\n\t\t\tif (bufferFactory instanceof NettyDataBufferFactory) {\n\t\t\t\tByteBuf byteBuf = payload.sliceData().retain();\n\t\t\t\treturn ((NettyDataBufferFactory) bufferFactory).wrap(byteBuf);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn bufferFactory.wrap(payload.getData());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (payload.refCnt() > 0) {\n\t\t\t\tpayload.release();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#route(route,routeVars)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the route to a remote handler as described in\n\t * {@link RSocketRequester#route(String, Object...)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "route",
      "routeVars"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "MetadataEncoder",
    "signature": "public MetadataEncoder route(String route, Object... routeVars)",
    "source_code": "\tpublic MetadataEncoder route(String route, Object... routeVars) {\n\t\tthis.route = expand(route, routeVars);\n\t\tassertMetadataEntryCount();\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.<unknown>#compareTo(other,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "int",
    "signature": "public int compareTo(RSocketFrameTypeMessageCondition other, Message<?> message)",
    "source_code": "\tpublic int compareTo(RSocketFrameTypeMessageCondition other, Message<?> message) {\n\t\treturn other.frameTypes.size() - this.frameTypes.size();\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.<unknown>#getCondition(cardinalityIn,cardinalityOut)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a condition for matching the RSocket request interaction type with\n\t * that is selected based on the declared request and response cardinality\n\t * of some handler method.\n\t * <p>The table below shows the selections made:\n\t * <table>\n\t * <tr>\n\t * <th>Request Cardinality</th>\n\t * <th>Response Cardinality</th>\n\t * <th>Interaction Types</th>\n\t * </tr>\n\t * <tr>\n\t * <td>0,1</td>\n\t * <td>0</td>\n\t * <td>Fire-And-Forget, Request-Response</td>\n\t * </tr>\n\t * <tr>\n\t * <td>0,1</td>\n\t * <td>1</td>\n\t * <td>Request-Response</td>\n\t * </tr>\n\t * <tr>\n\t * <td>0,1</td>\n\t * <td>2</td>\n\t * <td>Request-Stream</td>\n\t * </tr>\n\t * <tr>\n\t * <td>2</td>\n\t * <td>Any</td>\n\t * <td>Request-Channel</td>\n\t * </tr>\n\t * </table>\n\t * @param cardinalityIn -- the request cardinality: 1 for a single payload,\n\t * 2 for many payloads, and 0 if input is not handled.\n\t * @param cardinalityOut -- the response cardinality: 0 for no output\n\t * payloads, 1 for a single payload, and 2 for many payloads.\n\t * @return a condition to use for matching the interaction type\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cardinalityIn",
      "cardinalityOut"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "RSocketFrameTypeMessageCondition",
    "signature": "public RSocketFrameTypeMessageCondition getCondition(int cardinalityIn, int cardinalityOut)",
    "source_code": "\tpublic static RSocketFrameTypeMessageCondition getCondition(int cardinalityIn, int cardinalityOut) {\n\t\treturn switch (cardinalityIn) {\n\t\t\tcase 0, 1 -> switch (cardinalityOut) {\n\t\t\t\tcase 0 -> REQUEST_FNF_OR_RESPONSE_CONDITION;\n\t\t\t\tcase 1 -> REQUEST_RESPONSE_CONDITION;\n\t\t\t\tcase 2 -> REQUEST_STREAM_CONDITION;\n\t\t\t\tdefault -> throw new IllegalStateException(\"Invalid response cardinality: \" + cardinalityOut);\n\t\t\t};\n\t\t\tcase 2 -> REQUEST_CHANNEL_CONDITION;\n\t\t\tdefault -> throw new IllegalStateException(\"Invalid request cardinality: \" + cardinalityIn);\n\t\t};\n\t}"
  },
  "org.springframework.messaging.rsocket.service.<unknown>#registerMethodHints(hints,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "void",
    "signature": "protected void registerMethodHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerMethodHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tfor (Parameter parameter : method.getParameters()) {\n\t\t\t// Also register non-annotated parameters to handle metadata\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints,\n\t\t\t\t\tMethodParameter.forParameter(parameter).getGenericParameterType());\n\t\t}\n\t\tregisterReturnTypeHints(hints, MethodParameter.forExecutable(method, -1));\n\t}"
  },
  "org.springframework.messaging.rsocket.service.<unknown>#registerReflectionHints(hints,element)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "void",
    "signature": "public void registerReflectionHints(ReflectionHints hints, AnnotatedElement element)",
    "source_code": "\tpublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tif (element instanceof Method method) {\n\t\t\tthis.registerMethodHints(hints, method);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.rsocket.service.<unknown>#registerReturnTypeHints(hints,returnTypeParameter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "returnTypeParameter"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "protected void registerReturnTypeHints(ReflectionHints hints, MethodParameter returnTypeParameter)",
    "source_code": "\tprotected void registerReturnTypeHints(ReflectionHints hints, MethodParameter returnTypeParameter) {\n\t\tif (!void.class.equals(returnTypeParameter.getParameterType())) {\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, returnTypeParameter.getGenericParameterType());\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#addSubscription(sessionId,subscription)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "void",
    "signature": "public void addSubscription(String sessionId, Subscription subscription)",
    "source_code": "\t\tpublic void addSubscription(String sessionId, Subscription subscription) {\n\t\t\tSessionInfo info = this.sessions.computeIfAbsent(sessionId, _sessionId -> new SessionInfo());\n\t\t\tinfo.addSubscription(subscription);\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#addSubscriptionInternal(sessionId,subscriptionId,destination,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sessionId",
      "subscriptionId",
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "protected void addSubscriptionInternal(String sessionId, String subscriptionId, String destination, Message<?> message)",
    "source_code": "\tprotected void addSubscriptionInternal(\n\t\t\tString sessionId, String subscriptionId, String destination, Message<?> message) {\n\n\t\tboolean isPattern = this.pathMatcher.isPattern(destination);\n\t\tExpression expression = getSelectorExpression(message.getHeaders());\n\t\tSubscription subscription = new Subscription(subscriptionId, destination, isPattern, expression);\n\n\t\tthis.sessionRegistry.addSubscription(sessionId, subscription);\n\t\tthis.destinationCache.updateAfterNewSubscription(sessionId, subscription);\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#afterMessageHandled(message,ch,handler,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "ch",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "void",
    "signature": "public void afterMessageHandled(Message<?> message, MessageChannel ch, MessageHandler handler, @Nullable Exception ex)",
    "source_code": "\t\tpublic void afterMessageHandled(\n\t\t\t\tMessage<?> message, MessageChannel ch, MessageHandler handler, @Nullable Exception ex) {\n\n\t\t\tRunnable task = getNextMessageTask(message);\n\t\t\tif (task != null) {\n\t\t\t\ttask.run();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#canRead(context,target,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 502
    },
    "return": "boolean",
    "signature": "public boolean canRead(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) {\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#canWrite(context,target,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 535
    },
    "return": "boolean",
    "signature": "public boolean canWrite(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) {\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#configureInterceptor(channel,preserveOrder)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Install or remove an {@link ExecutorChannelInterceptor} that invokes a\n\t * completion task, if found in the headers of the message.\n\t * @param channel the channel to configure\n\t * @param preserveOrder whether preserve the order or publication; when\n\t * \"true\" an interceptor is inserted, when \"false\" it removed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channel",
      "preserveOrder"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void configureInterceptor(MessageChannel channel, boolean preserveOrder)",
    "source_code": "\tpublic static void configureInterceptor(MessageChannel channel, boolean preserveOrder) {\n\t\tif (preserveOrder) {\n\t\t\tAssert.isInstanceOf(ExecutorSubscribableChannel.class, channel,\n\t\t\t\t\t\"An ExecutorSubscribableChannel is required for 'preservePublishOrder'\");\n\t\t\tExecutorSubscribableChannel execChannel = (ExecutorSubscribableChannel) channel;\n\t\t\tif (execChannel.getInterceptors().stream().noneMatch(i -> i instanceof CallbackInterceptor)) {\n\t\t\t\texecChannel.addInterceptor(0, new CallbackInterceptor());\n\t\t\t}\n\t\t}\n\t\telse if (channel instanceof ExecutorSubscribableChannel execChannel) {\n\t\t\texecChannel.getInterceptors().stream().filter(i -> i instanceof CallbackInterceptor)\n\t\t\t\t\t.findFirst().map(execChannel::removeInterceptor);\n\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#find(serverState,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "serverState",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "String>",
    "signature": "public String> find(ServerState serverState, FindRequest request)",
    "source_code": "\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#findSubscriptionsInternal(destination,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "String>",
    "signature": "protected String> findSubscriptionsInternal(String destination, Message<?> message)",
    "source_code": "\tprotected MultiValueMap<String, String> findSubscriptionsInternal(String destination, Message<?> message) {\n\t\tMultiValueMap<String, String> allMatches = this.destinationCache.getSubscriptions(destination);\n\t\tif (!this.selectorHeaderInUse) {\n\t\t\treturn allMatches;\n\t\t}\n\t\tMultiValueMap<String, String> result = new LinkedMultiValueMap<>(allMatches.size());\n\t\tallMatches.forEach((sessionId, subscriptionIds) -> {\n\t\t\tSessionInfo info = this.sessionRegistry.getSession(sessionId);\n\t\t\tif (info != null) {\n\t\t\t\tfor (String subscriptionId : subscriptionIds) {\n\t\t\t\t\tSubscription subscription = info.getSubscription(subscriptionId);\n\t\t\t\t\tif (subscription != null && evaluateExpression(subscription.getSelector(), message)) {\n\t\t\t\t\t\tresult.add(sessionId, subscription.getId());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#forEachSubscription(BiConsumer<String,consumer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiConsumer<String",
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 393
    },
    "return": "void",
    "signature": "public void forEachSubscription(BiConsumer<String, Subscription> consumer)",
    "source_code": "\t\tpublic void forEachSubscription(BiConsumer<String, Subscription> consumer) {\n\t\t\tthis.sessions.forEach((sessionId, info) ->\n\t\t\t\tinfo.getSubscriptions().forEach(subscription -> consumer.accept(sessionId, subscription)));\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#read(context,target,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 508
    },
    "return": "TypedValue",
    "signature": "public TypedValue read(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) {\n\t\t\tObject value;\n\t\t\tif (target instanceof Message) {\n\t\t\t\tvalue = name.equals(\"headers\") ? ((Message) target).getHeaders() : null;\n\t\t\t}\n\t\t\telse if (target instanceof MessageHeaders headers) {\n\t\t\t\tSimpMessageHeaderAccessor accessor =\n\t\t\t\t\t\tMessageHeaderAccessor.getAccessor(headers, SimpMessageHeaderAccessor.class);\n\t\t\t\tAssert.state(accessor != null, \"No SimpMessageHeaderAccessor\");\n\t\t\t\tif (\"destination\".equalsIgnoreCase(name)) {\n\t\t\t\t\tvalue = accessor.getDestination();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvalue = accessor.getFirstNativeHeader(name);\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\tvalue = headers.get(name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Should never happen...\n\t\t\t\tthrow new IllegalStateException(\"Expected Message or MessageHeaders.\");\n\t\t\t}\n\t\t\treturn new TypedValue(value);\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#registerSubscriptions(sessionId,destination)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void registerSubscriptions(String sessionId, String destination)",
    "source_code": "\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#registerUnregister(serverState,request,blackhole)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "serverState",
      "request",
      "blackhole"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole)",
    "source_code": "\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#removeSubscriptionInternal(sessionId,subscriptionId,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sessionId",
      "subscriptionId",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "void",
    "signature": "protected void removeSubscriptionInternal(String sessionId, String subscriptionId, Message<?> message)",
    "source_code": "\tprotected void removeSubscriptionInternal(String sessionId, String subscriptionId, Message<?> message) {\n\t\tSessionInfo info = this.sessionRegistry.getSession(sessionId);\n\t\tif (info != null) {\n\t\t\tSubscription subscription = info.removeSubscription(subscriptionId);\n\t\t\tif (subscription != null) {\n\t\t\t\tthis.destinationCache.updateAfterRemovedSubscription(sessionId, subscription);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#send(message,timeout)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "boolean",
    "signature": "public boolean send(Message<?> message, long timeout)",
    "source_code": "\tpublic boolean send(Message<?> message, long timeout) {\n\t\tthis.messages.add(message);\n\t\ttrySend();\n\t\treturn true;\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#updateAfterNewSubscription(sessionId,subscription)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "void",
    "signature": "public void updateAfterNewSubscription(String sessionId, Subscription subscription)",
    "source_code": "\t\tpublic void updateAfterNewSubscription(String sessionId, Subscription subscription) {\n\t\t\tif (subscription.isPattern()) {\n\t\t\t\tfor (String cachedDestination : this.destinationCache.keySet()) {\n\t\t\t\t\tif (pathMatcher.match(subscription.getDestination(), cachedDestination)) {\n\t\t\t\t\t\taddToDestination(cachedDestination, sessionId, subscription.getId());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddToDestination(subscription.getDestination(), sessionId, subscription.getId());\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#updateAfterRemovedSession(sessionId,info)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "info"
    ],
    "position": {
      "column": 1,
      "line": 374
    },
    "return": "void",
    "signature": "public void updateAfterRemovedSession(String sessionId, SessionInfo info)",
    "source_code": "\t\tpublic void updateAfterRemovedSession(String sessionId, SessionInfo info) {\n\t\t\tfor (Subscription subscription : info.getSubscriptions()) {\n\t\t\t\tupdateAfterRemovedSubscription(sessionId, subscription);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#updateAfterRemovedSubscription(sessionId,subscription)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "void",
    "signature": "public void updateAfterRemovedSubscription(String sessionId, Subscription subscription)",
    "source_code": "\t\tpublic void updateAfterRemovedSubscription(String sessionId, Subscription subscription) {\n\t\t\tif (subscription.isPattern()) {\n\t\t\t\tString subscriptionId = subscription.getId();\n\t\t\t\tthis.destinationCache.forEach((destination, sessionIdToSubscriptionIds) -> {\n\t\t\t\t\tList<String> subscriptionIds = sessionIdToSubscriptionIds.get(sessionId);\n\t\t\t\t\tif (subscriptionIds != null && subscriptionIds.contains(subscriptionId)) {\n\t\t\t\t\t\tremoveInternal(destination, sessionId, subscriptionId);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tremoveInternal(subscription.getDestination(), sessionId, subscription.getId());\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#write(context,target,name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 540
    },
    "return": "void",
    "signature": "public void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object value)",
    "source_code": "\t\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object value) {\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#encode(Map<String,headers,payload)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Encodes the given payload and headers into a {@code byte[]}.\n\t * @param headers the headers\n\t * @param payload the payload\n\t * @return the encoded message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headers",
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "byte[]",
    "signature": "public byte[] encode(Map<String, Object> headers, byte[] payload)",
    "source_code": "\tpublic byte[] encode(Map<String, Object> headers, byte[] payload) {\n\t\tAssert.notNull(headers, \"'headers' is required\");\n\t\tAssert.notNull(payload, \"'payload' is required\");\n\n\t\tif (SimpMessageType.HEARTBEAT.equals(SimpMessageHeaderAccessor.getMessageType(headers))) {\n\t\t\tlogger.trace(\"Encoding heartbeat\");\n\t\t\treturn StompDecoder.HEARTBEAT_PAYLOAD;\n\t\t}\n\n\t\tStompCommand command = StompHeaderAccessor.getCommand(headers);\n\t\tif (command == null) {\n\t\t\tthrow new IllegalStateException(\"Missing STOMP command: \" + headers);\n\t\t}\n\n\t\tResult result = new DefaultResult();\n\t\tresult.add(command.toString().getBytes(StandardCharsets.UTF_8));\n\t\tresult.add(LINE_FEED_BYTE);\n\t\twriteHeaders(command, headers, payload, result);\n\t\tresult.add(LINE_FEED_BYTE);\n\t\tresult.add(payload);\n\t\tresult.add((byte) 0);\n\t\treturn result.toByteArray();\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#removeEldestEntry(Map.Entry<String,eldest)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map.Entry<String",
      "eldest"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "boolean",
    "signature": "protected boolean removeEldestEntry(Map.Entry<String, byte[]> eldest)",
    "source_code": "\t\t\t\tprotected boolean removeEldestEntry(Map.Entry<String, byte[]> eldest) {\n\t\t\t\t\tif (size() > HEADER_KEY_CACHE_LIMIT) {\n\t\t\t\t\t\theaderKeyAccessCache.remove(eldest.getKey());\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}"
  },
  "org.springframework.messaging.simp.user.<unknown>#init(expirationPeriod,sessionLookup)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expirationPeriod",
      "sessionLookup"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "void",
    "signature": "public void init(long expirationPeriod, SessionLookup sessionLookup)",
    "source_code": "\t\tpublic void init(long expirationPeriod, SessionLookup sessionLookup) {\n\t\t\tthis.expirationTime = System.currentTimeMillis() + expirationPeriod;\n\t\t\tfor (TransferSimpUser user : this.users.values()) {\n\t\t\t\tuser.afterDeserialization(sessionLookup);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.user.<unknown>#setUserMap(Map<String,users)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "users"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "void",
    "signature": "public void setUserMap(Map<String, TransferSimpUser> users)",
    "source_code": "\t\tpublic void setUserMap(Map<String, TransferSimpUser> users) {\n\t\t\tthis.users = users;\n\t\t}"
  },
  "org.springframework.messaging.support.<unknown>#copyHeaders(Map<String,headersToCopy)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the name-value pairs from the provided Map. This operation will overwrite any\n\t * existing values. Use {@link #copyHeadersIfAbsent(Map)} to avoid overwriting\n\t * values. Note that the 'id' and 'timestamp' header values will never be overwritten.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headersToCopy"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> copyHeaders(@Nullable Map<String, ?> headersToCopy)",
    "source_code": "\tpublic MessageBuilder<T> copyHeaders(@Nullable Map<String, ?> headersToCopy) {\n\t\tthis.headerAccessor.copyHeaders(headersToCopy);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#copyHeadersIfAbsent(Map<String,headersToCopy)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the name-value pairs from the provided Map. This operation will <em>not</em>\n\t * overwrite any existing values.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headersToCopy"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> copyHeadersIfAbsent(@Nullable Map<String, ?> headersToCopy)",
    "source_code": "\tpublic MessageBuilder<T> copyHeadersIfAbsent(@Nullable Map<String, ?> headersToCopy) {\n\t\tthis.headerAccessor.copyHeadersIfAbsent(headersToCopy);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#createMessage(payload,messageHeaders)": {
    "deprecated": false,
    "doc": "\t/**\n\t * A shortcut factory method for creating a message with the given payload\n\t * and {@code MessageHeaders}.\n\t * <p><strong>Note:</strong> the given {@code MessageHeaders} instance is used\n\t * directly in the new message, i.e. it is not copied.\n\t * @param payload the payload to use (never {@code null})\n\t * @param messageHeaders the headers to use (never {@code null})\n\t * @return the created message\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload",
      "messageHeaders"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "Message<T>",
    "signature": "public Message<T> createMessage(@Nullable T payload, MessageHeaders messageHeaders)",
    "source_code": "\tpublic static <T> Message<T> createMessage(@Nullable T payload, MessageHeaders messageHeaders) {\n\t\tAssert.notNull(payload, \"Payload must not be null\");\n\t\tAssert.notNull(messageHeaders, \"MessageHeaders must not be null\");\n\t\tif (payload instanceof Throwable throwable) {\n\t\t\treturn (Message<T>) new ErrorMessage(throwable, messageHeaders);\n\t\t}\n\t\telse {\n\t\t\treturn new GenericMessage<>(payload, messageHeaders);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#getAccessor(message,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return the original {@code MessageHeaderAccessor} used to create the headers\n\t * of the given {@code Message}, or {@code null} if that's not available or if\n\t * its type does not match the required type.\n\t * <p>This is for cases where the existence of an accessor is strongly expected\n\t * (followed up with an assertion) or where an accessor will be created otherwise.\n\t * @param message the message to get an accessor for\n\t * @param requiredType the required accessor type (or {@code null} for any)\n\t * @return an accessor instance of the specified type, or {@code null} if none\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 583
    },
    "return": "T",
    "signature": "public T getAccessor(Message<?> message, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic static <T extends MessageHeaderAccessor> T getAccessor(Message<?> message, @Nullable Class<T> requiredType) {\n\t\treturn getAccessor(message.getHeaders(), requiredType);\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#getAccessor(messageHeaders,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * A variation of {@link #getAccessor(org.springframework.messaging.Message, Class)}\n\t * with a {@code MessageHeaders} instance instead of a {@code Message}.\n\t * <p>This is for cases when a full message may not have been created yet.\n\t * @param messageHeaders the message headers to get an accessor for\n\t * @param requiredType the required accessor type (or {@code null} for any)\n\t * @return an accessor instance of the specified type, or {@code null} if none\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageHeaders",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 598
    },
    "return": "T",
    "signature": "public T getAccessor(MessageHeaders messageHeaders, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic static <T extends MessageHeaderAccessor> T getAccessor(\n\t\t\tMessageHeaders messageHeaders, @Nullable Class<T> requiredType) {\n\n\t\tif (messageHeaders instanceof MutableMessageHeaders mutableHeaders) {\n\t\t\tMessageHeaderAccessor headerAccessor = mutableHeaders.getAccessor();\n\t\t\tif (requiredType == null || requiredType.isInstance(headerAccessor))  {\n\t\t\t\treturn (T) headerAccessor;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#setHeader(headerName,headerValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for the given header name. If the provided value is {@code null},\n\t * the header will be removed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> setHeader(String headerName, @Nullable Object headerValue)",
    "source_code": "\tpublic MessageBuilder<T> setHeader(String headerName, @Nullable Object headerValue) {\n\t\tthis.headerAccessor.setHeader(headerName, headerValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#setHeader(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for the given header name.\n\t * <p>If the provided value is {@code null}, the header will be removed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "void",
    "signature": "public void setHeader(String name, @Nullable Object value)",
    "source_code": "\tpublic void setHeader(String name, @Nullable Object value) {\n\t\tif (isReadOnly(name)) {\n\t\t\tthrow new IllegalArgumentException(\"'\" + name + \"' header is read-only\");\n\t\t}\n\t\tverifyType(name, value);\n\t\tif (value != null) {\n\t\t\t// Modify header if necessary\n\t\t\tif (!ObjectUtils.nullSafeEquals(value, getHeader(name))) {\n\t\t\t\tthis.modified = true;\n\t\t\t\tthis.headers.getRawHeaders().put(name, value);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Remove header if available\n\t\t\tif (this.headers.containsKey(name)) {\n\t\t\t\tthis.modified = true;\n\t\t\t\tthis.headers.getRawHeaders().remove(name);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#setHeaderIfAbsent(headerName,headerValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for the given header name only if the header name is not already\n\t * associated with a value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> setHeaderIfAbsent(String headerName, Object headerValue)",
    "source_code": "\tpublic MessageBuilder<T> setHeaderIfAbsent(String headerName, Object headerValue) {\n\t\tthis.headerAccessor.setHeaderIfAbsent(headerName, headerValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#setHeaderIfAbsent(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for the given header name only if the header name is not\n\t * already associated with a value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "void",
    "signature": "public void setHeaderIfAbsent(String name, Object value)",
    "source_code": "\tpublic void setHeaderIfAbsent(String name, Object value) {\n\t\tif (getHeader(name) == null) {\n\t\t\tsetHeader(name, value);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#verifyType(headerName,headerValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "void",
    "signature": "protected void verifyType(@Nullable String headerName, @Nullable Object headerValue)",
    "source_code": "\tprotected void verifyType(@Nullable String headerName, @Nullable Object headerValue) {\n\t\tif (headerName != null && headerValue != null) {\n\t\t\tif (MessageHeaders.ERROR_CHANNEL.equals(headerName) ||\n\t\t\t\t\tMessageHeaders.REPLY_CHANNEL.endsWith(headerName)) {\n\t\t\t\tif (!(headerValue instanceof MessageChannel || headerValue instanceof String)) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\"'\" + headerName + \"' header value must be a MessageChannel or String\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.mock.http.client.reactive.<unknown>#setBody(body,charset)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void setBody(String body, Charset charset)",
    "source_code": "\tpublic void setBody(String body, Charset charset) {\n\t\tDataBuffer buffer = toDataBuffer(body, charset);\n\t\tthis.body = Flux.just(buffer);\n\t}"
  },
  "org.springframework.mock.web.<unknown>#addDateHeader(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 611
    },
    "return": "void",
    "signature": "public void addDateHeader(String name, long value)",
    "source_code": "\tpublic void addDateHeader(String name, long value) {\n\t\taddHeaderValue(name, formatDate(value));\n\t}"
  },
  "org.springframework.mock.web.<unknown>#addHeader(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an HTTP header entry for the given name.\n\t * <p>While this method can take any {@code Object} as a parameter,\n\t * it is recommended to use the following types:\n\t * <ul>\n\t * <li>String or any Object to be converted using {@code toString()}; see {@link #getHeader}.</li>\n\t * <li>String, Number, or Date for date headers; see {@link #getDateHeader}.</li>\n\t * <li>String or Number for integer headers; see {@link #getIntHeader}.</li>\n\t * <li>{@code String[]} or {@code Collection<String>} for multiple values; see {@link #getHeaders}.</li>\n\t * </ul>\n\t * @see #getHeaderNames\n\t * @see #getHeaders\n\t * @see #getHeader\n\t * @see #getDateHeader\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1050
    },
    "return": "void",
    "signature": "public void addHeader(String name, Object value)",
    "source_code": "\tpublic void addHeader(String name, Object value) {\n\t\tif (HttpHeaders.CONTENT_TYPE.equalsIgnoreCase(name) &&\n\t\t\t\t!this.headers.containsKey(HttpHeaders.CONTENT_TYPE)) {\n\t\t\tsetContentType(value.toString());\n\t\t}\n\t\telse if (HttpHeaders.ACCEPT_LANGUAGE.equalsIgnoreCase(name) &&\n\t\t\t\t!this.headers.containsKey(HttpHeaders.ACCEPT_LANGUAGE)) {\n\t\t\ttry {\n\t\t\t\tHttpHeaders headers = new HttpHeaders();\n\t\t\t\theaders.add(HttpHeaders.ACCEPT_LANGUAGE, value.toString());\n\t\t\t\tList<Locale> locales = headers.getAcceptLanguageAsLocales();\n\t\t\t\tthis.locales.clear();\n\t\t\t\tthis.locales.addAll(locales);\n\t\t\t\tif (this.locales.isEmpty()) {\n\t\t\t\t\tthis.locales.add(Locale.ENGLISH);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t// Invalid Accept-Language format -> just store plain header\n\t\t\t}\n\t\t\tdoAddHeaderValue(name, value, true);\n\t\t}\n\t\telse {\n\t\t\tdoAddHeaderValue(name, value, false);\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#addIntHeader(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 655
    },
    "return": "void",
    "signature": "public void addIntHeader(String name, int value)",
    "source_code": "\tpublic void addIntHeader(String name, int value) {\n\t\taddHeaderValue(name, value);\n\t}"
  },
  "org.springframework.mock.web.<unknown>#addParameter(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a single value for the specified HTTP parameter.\n\t * <p>If there are already one or more values registered for the given\n\t * parameter name, the given value will be added to the end of the list.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "void",
    "signature": "public void addParameter(String name, @Nullable String value)",
    "source_code": "\tpublic void addParameter(String name, @Nullable String value) {\n\t\taddParameter(name, new String[] {value});\n\t}"
  },
  "org.springframework.mock.web.<unknown>#addParameter(name,values)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an array of values for the specified HTTP parameter.\n\t * <p>If there are already one or more values registered for the given\n\t * parameter name, the given values will be added to the end of the list.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 577
    },
    "return": "void",
    "signature": "public void addParameter(String name, String... values)",
    "source_code": "\tpublic void addParameter(String name, String... values) {\n\t\tAssert.notNull(name, \"Parameter name must not be null\");\n\t\tString[] oldArr = this.parameters.get(name);\n\t\tif (oldArr != null) {\n\t\t\tString[] newArr = new String[oldArr.length + values.length];\n\t\t\tSystem.arraycopy(oldArr, 0, newArr, 0, oldArr.length);\n\t\t\tSystem.arraycopy(values, 0, newArr, oldArr.length, values.length);\n\t\t\tthis.parameters.put(name, newArr);\n\t\t}\n\t\telse {\n\t\t\tthis.parameters.put(name, values);\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#addParameters(Map<String,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add all provided parameters <strong>without</strong> replacing any\n\t * existing values. To replace existing values, use\n\t * {@link #setParameters(java.util.Map)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 596
    },
    "return": "void",
    "signature": "public void addParameters(Map<String, ?> params)",
    "source_code": "\tpublic void addParameters(Map<String, ?> params) {\n\t\tAssert.notNull(params, \"Parameter map must not be null\");\n\t\tparams.forEach((key, value) -> {\n\t\t\tif (value instanceof String str) {\n\t\t\t\taddParameter(key, str);\n\t\t\t}\n\t\t\telse if (value instanceof String[] strings) {\n\t\t\t\taddParameter(key, strings);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Parameter map value must be single value \" +\n\t\t\t\t\t\t\" or array of type [\" + String.class.getName() + \"]\");\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.mock.web.<unknown>#forward(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "void",
    "signature": "public void forward(ServletRequest request, ServletResponse response)",
    "source_code": "\tpublic void forward(ServletRequest request, ServletResponse response) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tAssert.notNull(response, \"Response must not be null\");\n\t\tAssert.state(!response.isCommitted(), \"Cannot perform forward - response is already committed\");\n\t\tgetMockHttpServletResponse(response).setForwardedUrl(this.resource);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"MockRequestDispatcher: forwarding to [\" + this.resource + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#getAttribute(name,scope)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "Object",
    "signature": "public Object getAttribute(String name, int scope)",
    "source_code": "\tpublic Object getAttribute(String name, int scope) {\n\t\tAssert.notNull(name, \"Attribute name must not be null\");\n\t\treturn switch (scope) {\n\t\t\tcase PAGE_SCOPE -> getAttribute(name);\n\t\t\tcase REQUEST_SCOPE -> this.request.getAttribute(name);\n\t\t\tcase SESSION_SCOPE -> {\n\t\t\t\tHttpSession session = this.request.getSession(false);\n\t\t\t\tyield (session != null ? session.getAttribute(name) : null);\n\t\t\t}\n\t\t\tcase APPLICATION_SCOPE -> this.servletContext.getAttribute(name);\n\t\t\tdefault -> throw new IllegalArgumentException(\"Invalid scope: \" + scope);\n\t\t};\n\t}"
  },
  "org.springframework.mock.web.<unknown>#include(path,flush)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "flush"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "void",
    "signature": "public void include(String path, boolean flush)",
    "source_code": "\tpublic void include(String path, boolean flush) throws ServletException, IOException {\n\t\tthis.request.getRequestDispatcher(path).include(this.request, this.response);\n\t\tif (flush) {\n\t\t\tthis.response.flushBuffer();\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#include(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "public void include(ServletRequest request, ServletResponse response)",
    "source_code": "\tpublic void include(ServletRequest request, ServletResponse response) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tAssert.notNull(response, \"Response must not be null\");\n\t\tgetMockHttpServletResponse(response).addIncludedUrl(this.resource);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"MockRequestDispatcher: including [\" + this.resource + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#initialize(servlet,request,response,errorPageURL,needsSession,bufferSize,autoFlush)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servlet",
      "request",
      "response",
      "errorPageURL",
      "needsSession",
      "bufferSize",
      "autoFlush"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void initialize(Servlet servlet, ServletRequest request, ServletResponse response,\n\t\t\tString errorPageURL, boolean needsSession, int bufferSize, boolean autoFlush)",
    "source_code": "\tpublic void initialize(\n\t\t\tServlet servlet, ServletRequest request, ServletResponse response,\n\t\t\tString errorPageURL, boolean needsSession, int bufferSize, boolean autoFlush) {\n\n\t\tthrow new UnsupportedOperationException(\"Use appropriate constructor\");\n\t}"
  },
  "org.springframework.mock.web.<unknown>#login(username,password)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 1387
    },
    "return": "void",
    "signature": "public void login(String username, String password)",
    "source_code": "\tpublic void login(String username, String password) throws ServletException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.mock.web.<unknown>#removeAttribute(name,scope)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "void",
    "signature": "public void removeAttribute(String name, int scope)",
    "source_code": "\tpublic void removeAttribute(String name, int scope) {\n\t\tAssert.notNull(name, \"Attribute name must not be null\");\n\t\tswitch (scope) {\n\t\t\tcase PAGE_SCOPE -> this.attributes.remove(name);\n\t\t\tcase REQUEST_SCOPE -> this.request.removeAttribute(name);\n\t\t\tcase SESSION_SCOPE -> this.request.getSession().removeAttribute(name);\n\t\t\tcase APPLICATION_SCOPE -> this.servletContext.removeAttribute(name);\n\t\t\tdefault -> throw new IllegalArgumentException(\"Invalid scope: \" + scope);\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#sendError(status,errorMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status",
      "errorMessage"
    ],
    "position": {
      "column": 1,
      "line": 577
    },
    "return": "void",
    "signature": "public void sendError(int status, String errorMessage)",
    "source_code": "\tpublic void sendError(int status, String errorMessage) throws IOException {\n\t\tAssert.state(!isCommitted(), \"Cannot set error status - response is already committed\");\n\t\tthis.status = status;\n\t\tthis.errorMessage = errorMessage;\n\t\tsetCommitted(true);\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setAttribute(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void setAttribute(String name, @Nullable Object value)",
    "source_code": "\tpublic void setAttribute(String name, @Nullable Object value) {\n\t\tassertIsValid();\n\t\tAssert.notNull(name, \"Attribute name must not be null\");\n\t\tif (value != null) {\n\t\t\tObject oldValue = this.attributes.put(name, value);\n\t\t\tif (value != oldValue) {\n\t\t\t\tif (oldValue instanceof HttpSessionBindingListener listener) {\n\t\t\t\t\tlistener.valueUnbound(new HttpSessionBindingEvent(this, name, oldValue));\n\t\t\t\t}\n\t\t\t\tif (value instanceof HttpSessionBindingListener listener) {\n\t\t\t\t\tlistener.valueBound(new HttpSessionBindingEvent(this, name, value));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tremoveAttribute(name);\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setAttribute(name,value,scope)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "public void setAttribute(String name, @Nullable Object value, int scope)",
    "source_code": "\tpublic void setAttribute(String name, @Nullable Object value, int scope) {\n\t\tAssert.notNull(name, \"Attribute name must not be null\");\n\t\tswitch (scope) {\n\t\t\tcase PAGE_SCOPE -> setAttribute(name, value);\n\t\t\tcase REQUEST_SCOPE -> this.request.setAttribute(name, value);\n\t\t\tcase SESSION_SCOPE -> this.request.getSession().setAttribute(name, value);\n\t\t\tcase APPLICATION_SCOPE -> this.servletContext.setAttribute(name, value);\n\t\t\tdefault -> throw new IllegalArgumentException(\"Invalid scope: \" + scope);\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setDateHeader(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 606
    },
    "return": "void",
    "signature": "public void setDateHeader(String name, long value)",
    "source_code": "\tpublic void setDateHeader(String name, long value) {\n\t\tsetHeaderValue(name, formatDate(value));\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setHeader(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 640
    },
    "return": "void",
    "signature": "public void setHeader(String name, @Nullable String value)",
    "source_code": "\tpublic void setHeader(String name, @Nullable String value) {\n\t\tsetHeaderValue(name, value);\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setIntHeader(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 650
    },
    "return": "void",
    "signature": "public void setIntHeader(String name, int value)",
    "source_code": "\tpublic void setIntHeader(String name, int value) {\n\t\tsetHeaderValue(name, value);\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setParameter(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a single value for the specified HTTP parameter.\n\t * <p>If there are already one or more values registered for the given\n\t * parameter name, they will be replaced.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 528
    },
    "return": "void",
    "signature": "public void setParameter(String name, String value)",
    "source_code": "\tpublic void setParameter(String name, String value) {\n\t\tsetParameter(name, new String[] {value});\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setParameter(name,values)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set an array of values for the specified HTTP parameter.\n\t * <p>If there are already one or more values registered for the given\n\t * parameter name, they will be replaced.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 537
    },
    "return": "void",
    "signature": "public void setParameter(String name, String... values)",
    "source_code": "\tpublic void setParameter(String name, String... values) {\n\t\tAssert.notNull(name, \"Parameter name must not be null\");\n\t\tthis.parameters.put(name, values);\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setParameters(Map<String,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set all provided parameters <strong>replacing</strong> any existing\n\t * values for the provided parameter names. To add without replacing\n\t * existing values, use {@link #addParameters(java.util.Map)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 547
    },
    "return": "void",
    "signature": "public void setParameters(Map<String, ?> params)",
    "source_code": "\tpublic void setParameters(Map<String, ?> params) {\n\t\tAssert.notNull(params, \"Parameter map must not be null\");\n\t\tparams.forEach((key, value) -> {\n\t\t\tif (value instanceof String str) {\n\t\t\t\tsetParameter(key, str);\n\t\t\t}\n\t\t\telse if (value instanceof String[] strings) {\n\t\t\t\tsetParameter(key, strings);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Parameter map value must be single value \" + \" or array of type [\" + String.class.getName() + \"]\");\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.mock.web.<unknown>#startAsync(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 922
    },
    "return": "AsyncContext",
    "signature": "public AsyncContext startAsync(ServletRequest request, @Nullable ServletResponse response)",
    "source_code": "\tpublic AsyncContext startAsync(ServletRequest request, @Nullable ServletResponse response) {\n\t\tAssert.state(this.asyncSupported, \"Async not supported\");\n\t\tthis.asyncStarted = true;\n\t\tthis.asyncContext = new MockAsyncContext(request, response);\n\t\treturn this.asyncContext;\n\t}"
  },
  "org.springframework.mock.web.<unknown>#write(buf,off,len)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "buf",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 835
    },
    "return": "void",
    "signature": "public void write(char[] buf, int off, int len)",
    "source_code": "\t\tpublic void write(char[] buf, int off, int len) {\n\t\t\tsuper.write(buf, off, len);\n\t\t\tsuper.flush();\n\t\t\tsetCommittedIfBufferSizeExceeded();\n\t\t}"
  },
  "org.springframework.mock.web.<unknown>#write(s,off,len)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "s",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 842
    },
    "return": "void",
    "signature": "public void write(String s, int off, int len)",
    "source_code": "\t\tpublic void write(String s, int off, int len) {\n\t\t\tsuper.write(s, off, len);\n\t\t\tsuper.flush();\n\t\t\tsetCommittedIfBufferSizeExceeded();\n\t\t}"
  },
  "org.springframework.mock.web.<unknown>#write(value,offset,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "void",
    "signature": "public void write(char[] value, int offset, int length)",
    "source_code": "\tpublic void write(char[] value, int offset, int length) throws IOException {\n\t\tgetTargetWriter().write(value, offset, length);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#doBegin(transaction,definition)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 460
    },
    "return": "void",
    "signature": "protected void doBegin(Object transaction, TransactionDefinition definition)",
    "source_code": "\tprotected void doBegin(Object transaction, TransactionDefinition definition) {\n\t\tHibernateTransactionObject txObject = (HibernateTransactionObject) transaction;\n\n\t\tif (txObject.hasConnectionHolder() && !txObject.getConnectionHolder().isSynchronizedWithTransaction()) {\n\t\t\tthrow new IllegalTransactionStateException(\n\t\t\t\t\t\"Pre-bound JDBC Connection found! HibernateTransactionManager does not support \" +\n\t\t\t\t\t\"running within DataSourceTransactionManager if told to manage the DataSource itself. \" +\n\t\t\t\t\t\"It is recommended to use a single HibernateTransactionManager for all transactions \" +\n\t\t\t\t\t\"on a single DataSource, no matter whether Hibernate or JDBC access.\");\n\t\t}\n\n\t\tSessionImplementor session = null;\n\n\t\ttry {\n\t\t\tif (!txObject.hasSessionHolder() || txObject.getSessionHolder().isSynchronizedWithTransaction()) {\n\t\t\t\tInterceptor entityInterceptor = getEntityInterceptor();\n\t\t\t\tSession newSession = (entityInterceptor != null ?\n\t\t\t\t\t\tobtainSessionFactory().withOptions().interceptor(entityInterceptor).openSession() :\n\t\t\t\t\t\tobtainSessionFactory().openSession());\n\t\t\t\tif (this.sessionInitializer != null) {\n\t\t\t\t\tthis.sessionInitializer.accept(newSession);\n\t\t\t\t}\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Opened new Session [\" + newSession + \"] for Hibernate transaction\");\n\t\t\t\t}\n\t\t\t\ttxObject.setSession(newSession);\n\t\t\t}\n\n\t\t\tsession = txObject.getSessionHolder().getSession().unwrap(SessionImplementor.class);\n\n\t\t\tboolean holdabilityNeeded = this.allowResultAccessAfterCompletion && !txObject.isNewSession();\n\t\t\tboolean isolationLevelNeeded = (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT);\n\t\t\tif (holdabilityNeeded || isolationLevelNeeded || definition.isReadOnly()) {\n\t\t\t\tif (this.prepareConnection && ConnectionReleaseMode.ON_CLOSE.equals(\n\t\t\t\t\t\tsession.getJdbcCoordinator().getLogicalConnection().getConnectionHandlingMode().getReleaseMode())) {\n\t\t\t\t\t// We're allowed to change the transaction settings of the JDBC Connection.\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Preparing JDBC Connection of Hibernate Session [\" + session + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tConnection con = session.getJdbcCoordinator().getLogicalConnection().getPhysicalConnection();\n\t\t\t\t\tInteger previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);\n\t\t\t\t\ttxObject.setPreviousIsolationLevel(previousIsolationLevel);\n\t\t\t\t\ttxObject.setReadOnly(definition.isReadOnly());\n\t\t\t\t\tif (this.allowResultAccessAfterCompletion && !txObject.isNewSession()) {\n\t\t\t\t\t\tint currentHoldability = con.getHoldability();\n\t\t\t\t\t\tif (currentHoldability != ResultSet.HOLD_CURSORS_OVER_COMMIT) {\n\t\t\t\t\t\t\ttxObject.setPreviousHoldability(currentHoldability);\n\t\t\t\t\t\t\tcon.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttxObject.connectionPrepared();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Not allowed to change the transaction settings of the JDBC Connection.\n\t\t\t\t\tif (isolationLevelNeeded) {\n\t\t\t\t\t\t// We should set a specific isolation level but are not allowed to...\n\t\t\t\t\t\tthrow new InvalidIsolationLevelException(\n\t\t\t\t\t\t\t\t\"HibernateTransactionManager is not allowed to support custom isolation levels: \" +\n\t\t\t\t\t\t\t\t\"make sure that its 'prepareConnection' flag is on (the default) and that the \" +\n\t\t\t\t\t\t\t\t\"Hibernate connection release mode is set to ON_CLOSE.\");\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Not preparing JDBC Connection of Hibernate Session [\" + session + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (definition.isReadOnly() && txObject.isNewSession()) {\n\t\t\t\t// Just set to MANUAL in case of a new Session for this transaction.\n\t\t\t\tsession.setHibernateFlushMode(FlushMode.MANUAL);\n\t\t\t\t// As of 5.1, we're also setting Hibernate's read-only entity mode by default.\n\t\t\t\tsession.setDefaultReadOnly(true);\n\t\t\t}\n\n\t\t\tif (!definition.isReadOnly() && !txObject.isNewSession()) {\n\t\t\t\t// We need AUTO or COMMIT for a non-read-only transaction.\n\t\t\t\tFlushMode flushMode = session.getHibernateFlushMode();\n\t\t\t\tif (FlushMode.MANUAL.equals(flushMode)) {\n\t\t\t\t\tsession.setHibernateFlushMode(FlushMode.AUTO);\n\t\t\t\t\ttxObject.getSessionHolder().setPreviousFlushMode(flushMode);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTransaction hibTx;\n\n\t\t\t// Register transaction timeout.\n\t\t\tint timeout = determineTimeout(definition);\n\t\t\tif (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\t\t// Use Hibernate's own transaction timeout mechanism on Hibernate 3.1+\n\t\t\t\t// Applies to all statements, also to inserts, updates and deletes!\n\t\t\t\thibTx = session.getTransaction();\n\t\t\t\thibTx.setTimeout(timeout);\n\t\t\t\thibTx.begin();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Open a plain Hibernate transaction without specified timeout.\n\t\t\t\thibTx = session.beginTransaction();\n\t\t\t}\n\n\t\t\t// Add the Hibernate transaction to the session holder.\n\t\t\ttxObject.getSessionHolder().setTransaction(hibTx);\n\n\t\t\t// Register the Hibernate Session's JDBC Connection for the DataSource, if set.\n\t\t\tif (getDataSource() != null) {\n\t\t\t\tfinal SessionImplementor sessionToUse = session;\n\t\t\t\tConnectionHolder conHolder = new ConnectionHolder(\n\t\t\t\t\t\t() -> sessionToUse.getJdbcCoordinator().getLogicalConnection().getPhysicalConnection());\n\t\t\t\tif (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\t\t\tconHolder.setTimeoutInSeconds(timeout);\n\t\t\t\t}\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Exposing Hibernate transaction as JDBC [\" + conHolder.getConnectionHandle() + \"]\");\n\t\t\t\t}\n\t\t\t\tTransactionSynchronizationManager.bindResource(getDataSource(), conHolder);\n\t\t\t\ttxObject.setConnectionHolder(conHolder);\n\t\t\t}\n\n\t\t\t// Bind the session holder to the thread.\n\t\t\tif (txObject.isNewSessionHolder()) {\n\t\t\t\tTransactionSynchronizationManager.bindResource(obtainSessionFactory(), txObject.getSessionHolder());\n\t\t\t}\n\t\t\ttxObject.getSessionHolder().setSynchronizedWithTransaction(true);\n\t\t}\n\n\t\tcatch (Throwable ex) {\n\t\t\tif (txObject.isNewSession()) {\n\t\t\t\ttry {\n\t\t\t\t\tif (session != null && session.getTransaction().getStatus() == TransactionStatus.ACTIVE) {\n\t\t\t\t\t\tsession.getTransaction().rollback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\tlogger.debug(\"Could not rollback Session after failed transaction begin\", ex);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tSessionFactoryUtils.closeSession(session);\n\t\t\t\t\ttxObject.setSessionHolder(null);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new CannotCreateTransactionException(\"Could not open Hibernate Session for transaction\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#doResume(transaction,suspendedResources)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 618
    },
    "return": "void",
    "signature": "protected void doResume(@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected void doResume(@Nullable Object transaction, Object suspendedResources) {\n\t\tSessionFactory sessionFactory = obtainSessionFactory();\n\n\t\tSuspendedResourcesHolder resourcesHolder = (SuspendedResourcesHolder) suspendedResources;\n\t\tif (TransactionSynchronizationManager.hasResource(sessionFactory)) {\n\t\t\t// From non-transactional code running in active transaction synchronization\n\t\t\t// -> can be safely removed, will be closed on transaction completion.\n\t\t\tTransactionSynchronizationManager.unbindResource(sessionFactory);\n\t\t}\n\t\tTransactionSynchronizationManager.bindResource(sessionFactory, resourcesHolder.getSessionHolder());\n\t\tif (getDataSource() != null && resourcesHolder.getConnectionHolder() != null) {\n\t\t\tTransactionSynchronizationManager.bindResource(getDataSource(), resourcesHolder.getConnectionHolder());\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#applyTransactionTimeout(query,emf)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the current transaction timeout, if any, to the given JPA Query object.\n\t * <p>This method sets the JPA query hint \"jakarta.persistence.query.timeout\" accordingly.\n\t * @param query the JPA Query object\n\t * @param emf the JPA EntityManagerFactory that the Query was created for\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "query",
      "emf"
    ],
    "position": {
      "column": 1,
      "line": 338
    },
    "return": "void",
    "signature": "public void applyTransactionTimeout(Query query, EntityManagerFactory emf)",
    "source_code": "\tpublic static void applyTransactionTimeout(Query query, EntityManagerFactory emf) {\n\t\tEntityManagerHolder emHolder = (EntityManagerHolder) TransactionSynchronizationManager.getResource(emf);\n\t\tif (emHolder != null && emHolder.hasTimeout()) {\n\t\t\tint timeoutValue = (int) emHolder.getTimeToLiveInMillis();\n\t\t\ttry {\n\t\t\t\tquery.setHint(\"jakarta.persistence.query.timeout\", timeoutValue);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t// oh well, at least we tried...\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#cleanupResource(resourceHolder,resourceKey,committed)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourceHolder",
      "resourceKey",
      "committed"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "void",
    "signature": "protected void cleanupResource(EntityManagerHolder resourceHolder, EntityManagerFactory resourceKey, boolean committed)",
    "source_code": "\t\tprotected void cleanupResource(\n\t\t\t\tEntityManagerHolder resourceHolder, EntityManagerFactory resourceKey, boolean committed) {\n\n\t\t\tif (!committed) {\n\t\t\t\t// Clear all pending inserts/updates/deletes in the EntityManager.\n\t\t\t\t// Necessary for pre-bound EntityManagers, to avoid inconsistent state.\n\t\t\t\tresourceHolder.getEntityManager().clear();\n\t\t\t}\n\t\t\tcleanupTransaction(this.transactionData, resourceKey);\n\t\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createApplicationManagedEntityManager(rawEntityManager,emfInfo)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create an application-managed extended EntityManager proxy.\n\t * @param rawEntityManager the raw EntityManager to decorate\n\t * @param emfInfo the EntityManagerFactoryInfo to obtain the JpaDialect\n\t * and PersistenceUnitInfo from\n\t * @return an application-managed EntityManager that can join transactions\n\t * but does not participate in them automatically\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rawEntityManager",
      "emfInfo"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "EntityManager",
    "signature": "public EntityManager createApplicationManagedEntityManager(EntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo)",
    "source_code": "\tpublic static EntityManager createApplicationManagedEntityManager(\n\t\t\tEntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo) {\n\n\t\treturn createProxy(rawEntityManager, emfInfo, false, false);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createApplicationManagedEntityManager(rawEntityManager,emfInfo,synchronizedWithTransaction)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create an application-managed extended EntityManager proxy.\n\t * @param rawEntityManager the raw EntityManager to decorate\n\t * @param emfInfo the EntityManagerFactoryInfo to obtain the JpaDialect\n\t * and PersistenceUnitInfo from\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @return an application-managed EntityManager that can join transactions\n\t * but does not participate in them automatically\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rawEntityManager",
      "emfInfo",
      "synchronizedWithTransaction"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "EntityManager",
    "signature": "public EntityManager createApplicationManagedEntityManager(EntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo, boolean synchronizedWithTransaction)",
    "source_code": "\tpublic static EntityManager createApplicationManagedEntityManager(\n\t\t\tEntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo, boolean synchronizedWithTransaction) {\n\n\t\treturn createProxy(rawEntityManager, emfInfo, false, synchronizedWithTransaction);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createContainerManagedEntityManager(emf,Map<?,properties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a container-managed extended EntityManager proxy.\n\t * @param emf the EntityManagerFactory to create the EntityManager with.\n\t * If this implements the EntityManagerFactoryInfo interface, the corresponding\n\t * JpaDialect and PersistenceUnitInfo will be detected accordingly.\n\t * @param properties the properties to be passed into the {@code createEntityManager}\n\t * call (may be {@code null})\n\t * @return a container-managed EntityManager that will automatically participate\n\t * in any managed transaction\n\t * @see jakarta.persistence.EntityManagerFactory#createEntityManager(java.util.Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "EntityManager",
    "signature": "public EntityManager createContainerManagedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties)",
    "source_code": "\tpublic static EntityManager createContainerManagedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties) {\n\t\treturn createContainerManagedEntityManager(emf, properties, true);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createContainerManagedEntityManager(emf,Map<?,properties,synchronizedWithTransaction)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a container-managed extended EntityManager proxy.\n\t * @param emf the EntityManagerFactory to create the EntityManager with.\n\t * If this implements the EntityManagerFactoryInfo interface, the corresponding\n\t * JpaDialect and PersistenceUnitInfo will be detected accordingly.\n\t * @param properties the properties to be passed into the {@code createEntityManager}\n\t * call (may be {@code null})\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @return a container-managed EntityManager that expects container-driven lifecycle\n\t * management but may opt out of automatic transaction synchronization\n\t * @since 4.0\n\t * @see jakarta.persistence.EntityManagerFactory#createEntityManager(java.util.Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties",
      "synchronizedWithTransaction"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "EntityManager",
    "signature": "public EntityManager createContainerManagedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction)",
    "source_code": "\tpublic static EntityManager createContainerManagedEntityManager(\n\t\t\tEntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction) {\n\n\t\tAssert.notNull(emf, \"EntityManagerFactory must not be null\");\n\t\tif (emf instanceof EntityManagerFactoryInfo emfInfo) {\n\t\t\tEntityManager rawEntityManager = emfInfo.createNativeEntityManager(properties);\n\t\t\treturn createProxy(rawEntityManager, emfInfo, true, synchronizedWithTransaction);\n\t\t}\n\t\telse {\n\t\t\tEntityManager rawEntityManager = (!CollectionUtils.isEmpty(properties) ?\n\t\t\t\t\temf.createEntityManager(properties) : emf.createEntityManager());\n\t\t\treturn createProxy(rawEntityManager, null, null, null, null, true, synchronizedWithTransaction);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createContainerManagedEntityManager(rawEntityManager,emfInfo)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a container-managed extended EntityManager proxy.\n\t * @param rawEntityManager the raw EntityManager to decorate\n\t * @param emfInfo the EntityManagerFactoryInfo to obtain the JpaDialect\n\t * and PersistenceUnitInfo from\n\t * @return a container-managed EntityManager that will automatically participate\n\t * in any managed transaction\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rawEntityManager",
      "emfInfo"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "EntityManager",
    "signature": "public EntityManager createContainerManagedEntityManager(EntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo)",
    "source_code": "\tpublic static EntityManager createContainerManagedEntityManager(\n\t\t\tEntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo) {\n\n\t\treturn createProxy(rawEntityManager, emfInfo, true, true);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createNativeEntityManager(Map<?,properties)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 581
    },
    "return": "EntityManager",
    "signature": "public EntityManager createNativeEntityManager(@Nullable Map<?, ?> properties)",
    "source_code": "\tpublic EntityManager createNativeEntityManager(@Nullable Map<?, ?> properties) {\n\t\tEntityManager rawEntityManager = (!CollectionUtils.isEmpty(properties) ?\n\t\t\t\tgetNativeEntityManagerFactory().createEntityManager(properties) :\n\t\t\t\tgetNativeEntityManagerFactory().createEntityManager());\n\t\tpostProcessEntityManager(rawEntityManager);\n\t\treturn rawEntityManager;\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createSharedEntityManager(emf,Map<?,properties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a transactional EntityManager proxy for the given EntityManagerFactory.\n\t * @param emf the EntityManagerFactory to delegate to.\n\t * @param properties the properties to be passed into the\n\t * {@code createEntityManager} call (may be {@code null})\n\t * @return a shareable transaction EntityManager proxy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "EntityManager",
    "signature": "public EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties)",
    "source_code": "\tpublic static EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties) {\n\t\treturn createSharedEntityManager(emf, properties, true);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createSharedEntityManager(emf,Map<?,properties,entityManagerInterfaces)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a transactional EntityManager proxy for the given EntityManagerFactory.\n\t * @param emf the EntityManagerFactory to obtain EntityManagers from as needed\n\t * @param properties the properties to be passed into the\n\t * {@code createEntityManager} call (may be {@code null})\n\t * @param entityManagerInterfaces the interfaces to be implemented by the\n\t * EntityManager. Allows the addition or specification of proprietary interfaces.\n\t * @return a shareable transactional EntityManager proxy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties",
      "entityManagerInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "EntityManager",
    "signature": "public EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties, Class<?>... entityManagerInterfaces)",
    "source_code": "\tpublic static EntityManager createSharedEntityManager(\n\t\t\tEntityManagerFactory emf, @Nullable Map<?, ?> properties, Class<?>... entityManagerInterfaces) {\n\n\t\treturn createSharedEntityManager(emf, properties, true, entityManagerInterfaces);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createSharedEntityManager(emf,Map<?,properties,synchronizedWithTransaction)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a transactional EntityManager proxy for the given EntityManagerFactory.\n\t * @param emf the EntityManagerFactory to delegate to.\n\t * @param properties the properties to be passed into the\n\t * {@code createEntityManager} call (may be {@code null})\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @return a shareable transaction EntityManager proxy\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties",
      "synchronizedWithTransaction"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "EntityManager",
    "signature": "public EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction)",
    "source_code": "\tpublic static EntityManager createSharedEntityManager(\n\t\t\tEntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction) {\n\n\t\tClass<?> emIfc = (emf instanceof EntityManagerFactoryInfo ?\n\t\t\t\t((EntityManagerFactoryInfo) emf).getEntityManagerInterface() : EntityManager.class);\n\t\treturn createSharedEntityManager(emf, properties, synchronizedWithTransaction,\n\t\t\t\t(emIfc == null ? NO_ENTITY_MANAGER_INTERFACES : new Class<?>[] {emIfc}));\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createSharedEntityManager(emf,Map<?,properties,synchronizedWithTransaction,entityManagerInterfaces)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a transactional EntityManager proxy for the given EntityManagerFactory.\n\t * @param emf the EntityManagerFactory to obtain EntityManagers from as needed\n\t * @param properties the properties to be passed into the\n\t * {@code createEntityManager} call (may be {@code null})\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @param entityManagerInterfaces the interfaces to be implemented by the\n\t * EntityManager. Allows the addition or specification of proprietary interfaces.\n\t * @return a shareable transactional EntityManager proxy\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties",
      "synchronizedWithTransaction",
      "entityManagerInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "EntityManager",
    "signature": "public EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties,\n\t\t\tboolean synchronizedWithTransaction, Class<?>... entityManagerInterfaces)",
    "source_code": "\tpublic static EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties,\n\t\t\tboolean synchronizedWithTransaction, Class<?>... entityManagerInterfaces) {\n\n\t\tClassLoader cl = null;\n\t\tif (emf instanceof EntityManagerFactoryInfo) {\n\t\t\tcl = ((EntityManagerFactoryInfo) emf).getBeanClassLoader();\n\t\t}\n\t\tClass<?>[] ifcs = new Class<?>[entityManagerInterfaces.length + 1];\n\t\tSystem.arraycopy(entityManagerInterfaces, 0, ifcs, 0, entityManagerInterfaces.length);\n\t\tifcs[entityManagerInterfaces.length] = EntityManagerProxy.class;\n\t\treturn (EntityManager) Proxy.newProxyInstance(\n\t\t\t\t(cl != null ? cl : SharedEntityManagerCreator.class.getClassLoader()),\n\t\t\t\tifcs, new SharedEntityManagerInvocationHandler(emf, properties, synchronizedWithTransaction));\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#doBegin(transaction,definition)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 395
    },
    "return": "void",
    "signature": "protected void doBegin(Object transaction, TransactionDefinition definition)",
    "source_code": "\tprotected void doBegin(Object transaction, TransactionDefinition definition) {\n\t\tJpaTransactionObject txObject = (JpaTransactionObject) transaction;\n\n\t\tif (txObject.hasConnectionHolder() && !txObject.getConnectionHolder().isSynchronizedWithTransaction()) {\n\t\t\tthrow new IllegalTransactionStateException(\n\t\t\t\t\t\"Pre-bound JDBC Connection found! JpaTransactionManager does not support \" +\n\t\t\t\t\t\"running within DataSourceTransactionManager if told to manage the DataSource itself. \" +\n\t\t\t\t\t\"It is recommended to use a single JpaTransactionManager for all transactions \" +\n\t\t\t\t\t\"on a single DataSource, no matter whether JPA or JDBC access.\");\n\t\t}\n\n\t\ttry {\n\t\t\tif (!txObject.hasEntityManagerHolder() ||\n\t\t\t\t\ttxObject.getEntityManagerHolder().isSynchronizedWithTransaction()) {\n\t\t\t\tEntityManager newEm = createEntityManagerForTransaction();\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Opened new EntityManager [\" + newEm + \"] for JPA transaction\");\n\t\t\t\t}\n\t\t\t\ttxObject.setEntityManagerHolder(new EntityManagerHolder(newEm), true);\n\t\t\t}\n\n\t\t\tEntityManager em = txObject.getEntityManagerHolder().getEntityManager();\n\n\t\t\t// Delegate to JpaDialect for actual transaction begin.\n\t\t\tint timeoutToUse = determineTimeout(definition);\n\t\t\tObject transactionData = getJpaDialect().beginTransaction(em,\n\t\t\t\t\tnew JpaTransactionDefinition(definition, timeoutToUse, txObject.isNewEntityManagerHolder()));\n\t\t\ttxObject.setTransactionData(transactionData);\n\t\t\ttxObject.setReadOnly(definition.isReadOnly());\n\n\t\t\t// Register transaction timeout.\n\t\t\tif (timeoutToUse != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\t\ttxObject.getEntityManagerHolder().setTimeoutInSeconds(timeoutToUse);\n\t\t\t}\n\n\t\t\t// Register the JPA EntityManager's JDBC Connection for the DataSource, if set.\n\t\t\tif (getDataSource() != null) {\n\t\t\t\tConnectionHandle conHandle = getJpaDialect().getJdbcConnection(em, definition.isReadOnly());\n\t\t\t\tif (conHandle != null) {\n\t\t\t\t\tConnectionHolder conHolder = new ConnectionHolder(conHandle);\n\t\t\t\t\tif (timeoutToUse != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\t\t\t\tconHolder.setTimeoutInSeconds(timeoutToUse);\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Exposing JPA transaction as JDBC [\" + conHandle + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tTransactionSynchronizationManager.bindResource(getDataSource(), conHolder);\n\t\t\t\t\ttxObject.setConnectionHolder(conHolder);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Not exposing JPA transaction [\" + em + \"] as JDBC transaction because \" +\n\t\t\t\t\t\t\t\t\"JpaDialect [\" + getJpaDialect() + \"] does not support JDBC Connection retrieval\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Bind the entity manager holder to the thread.\n\t\t\tif (txObject.isNewEntityManagerHolder()) {\n\t\t\t\tTransactionSynchronizationManager.bindResource(\n\t\t\t\t\t\tobtainEntityManagerFactory(), txObject.getEntityManagerHolder());\n\t\t\t}\n\t\t\ttxObject.getEntityManagerHolder().setSynchronizedWithTransaction(true);\n\t\t}\n\n\t\tcatch (TransactionException ex) {\n\t\t\tcloseEntityManagerAfterFailedBegin(txObject);\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tcloseEntityManagerAfterFailedBegin(txObject);\n\t\t\tthrow new CannotCreateTransactionException(\"Could not open JPA EntityManager for transaction\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#doGetTransactionalEntityManager(emf,Map<?,properties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JPA EntityManager from the given factory. Is aware of a corresponding\n\t * EntityManager bound to the current thread, e.g. when using JpaTransactionManager.\n\t * <p>Same as {@code getEntityManager}, but throwing the original PersistenceException.\n\t * @param emf the EntityManagerFactory to create the EntityManager with\n\t * @param properties the properties to be passed into the {@code createEntityManager}\n\t * call (may be {@code null})\n\t * @return the EntityManager, or {@code null} if none found\n\t * @throws jakarta.persistence.PersistenceException if the EntityManager couldn't be created\n\t * @see #getTransactionalEntityManager(jakarta.persistence.EntityManagerFactory)\n\t * @see JpaTransactionManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "EntityManager",
    "signature": "public EntityManager doGetTransactionalEntityManager(EntityManagerFactory emf, Map<?, ?> properties)",
    "source_code": "\tpublic static EntityManager doGetTransactionalEntityManager(EntityManagerFactory emf, Map<?, ?> properties)\n\t\t\tthrows PersistenceException {\n\n\t\treturn doGetTransactionalEntityManager(emf, properties, true);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#doGetTransactionalEntityManager(emf,Map<?,properties,synchronizedWithTransaction)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JPA EntityManager from the given factory. Is aware of a corresponding\n\t * EntityManager bound to the current thread, e.g. when using JpaTransactionManager.\n\t * <p>Same as {@code getEntityManager}, but throwing the original PersistenceException.\n\t * @param emf the EntityManagerFactory to create the EntityManager with\n\t * @param properties the properties to be passed into the {@code createEntityManager}\n\t * call (may be {@code null})\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @return the EntityManager, or {@code null} if none found\n\t * @throws jakarta.persistence.PersistenceException if the EntityManager couldn't be created\n\t * @see #getTransactionalEntityManager(jakarta.persistence.EntityManagerFactory)\n\t * @see JpaTransactionManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties",
      "synchronizedWithTransaction"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "EntityManager",
    "signature": "public EntityManager doGetTransactionalEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction)",
    "source_code": "\tpublic static EntityManager doGetTransactionalEntityManager(\n\t\t\tEntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction)\n\t\t\tthrows PersistenceException {\n\n\t\tAssert.notNull(emf, \"No EntityManagerFactory specified\");\n\n\t\tEntityManagerHolder emHolder =\n\t\t\t\t(EntityManagerHolder) TransactionSynchronizationManager.getResource(emf);\n\t\tif (emHolder != null) {\n\t\t\tif (synchronizedWithTransaction) {\n\t\t\t\tif (!emHolder.isSynchronizedWithTransaction()) {\n\t\t\t\t\tif (TransactionSynchronizationManager.isActualTransactionActive()) {\n\t\t\t\t\t\t// Try to explicitly synchronize the EntityManager itself\n\t\t\t\t\t\t// with an ongoing JTA transaction, if any.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\temHolder.getEntityManager().joinTransaction();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (TransactionRequiredException ex) {\n\t\t\t\t\t\t\tlogger.debug(\"Could not join transaction because none was actually active\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\t\t\t\tObject transactionData = prepareTransaction(emHolder.getEntityManager(), emf);\n\t\t\t\t\t\tTransactionSynchronizationManager.registerSynchronization(\n\t\t\t\t\t\t\t\tnew TransactionalEntityManagerSynchronization(emHolder, emf, transactionData, false));\n\t\t\t\t\t\temHolder.setSynchronizedWithTransaction(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Use holder's reference count to track synchronizedWithTransaction access.\n\t\t\t\t// isOpen() check used below to find out about it.\n\t\t\t\temHolder.requested();\n\t\t\t\treturn emHolder.getEntityManager();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// unsynchronized EntityManager demanded\n\t\t\t\tif (emHolder.isTransactionActive() && !emHolder.isOpen()) {\n\t\t\t\t\tif (!TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t// EntityManagerHolder with an active transaction coming from JpaTransactionManager,\n\t\t\t\t\t// with no synchronized EntityManager having been requested by application code before.\n\t\t\t\t\t// Unbind in order to register a new unsynchronized EntityManager instead.\n\t\t\t\t\tTransactionSynchronizationManager.unbindResource(emf);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Either a previously bound unsynchronized EntityManager, or the application\n\t\t\t\t\t// has requested a synchronized EntityManager before and therefore upgraded\n\t\t\t\t\t// this transaction's EntityManager to synchronized before.\n\t\t\t\t\treturn emHolder.getEntityManager();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\t// Indicate that we can't obtain a transactional EntityManager.\n\t\t\treturn null;\n\t\t}\n\n\t\t// Create a new EntityManager for use within the current transaction.\n\t\tlogger.debug(\"Opening JPA EntityManager\");\n\t\tEntityManager em = null;\n\t\tif (!synchronizedWithTransaction) {\n\t\t\ttry {\n\t\t\t\tem = emf.createEntityManager(SynchronizationType.UNSYNCHRONIZED, properties);\n\t\t\t}\n\t\t\tcatch (AbstractMethodError err) {\n\t\t\t\t// JPA 2.1 API available but method not actually implemented in persistence provider:\n\t\t\t\t// falling back to regular createEntityManager method.\n\t\t\t}\n\t\t}\n\t\tif (em == null) {\n\t\t\tem = (!CollectionUtils.isEmpty(properties) ? emf.createEntityManager(properties) : emf.createEntityManager());\n\t\t}\n\n\t\ttry {\n\t\t\t// Use same EntityManager for further JPA operations within the transaction.\n\t\t\t// Thread-bound object will get removed by synchronization at transaction completion.\n\t\t\temHolder = new EntityManagerHolder(em);\n\t\t\tif (synchronizedWithTransaction) {\n\t\t\t\tObject transactionData = prepareTransaction(em, emf);\n\t\t\t\tTransactionSynchronizationManager.registerSynchronization(\n\t\t\t\t\t\tnew TransactionalEntityManagerSynchronization(emHolder, emf, transactionData, true));\n\t\t\t\temHolder.setSynchronizedWithTransaction(true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Unsynchronized - just scope it for the transaction, as demanded by the JPA 2.1 spec...\n\t\t\t\tTransactionSynchronizationManager.registerSynchronization(\n\t\t\t\t\t\tnew TransactionScopedEntityManagerSynchronization(emHolder, emf));\n\t\t\t}\n\t\t\tTransactionSynchronizationManager.bindResource(emf, emHolder);\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\t// Unexpected exception from external delegation call -> close EntityManager and rethrow.\n\t\t\tcloseEntityManager(em);\n\t\t\tthrow ex;\n\t\t}\n\n\t\treturn em;\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#doResume(transaction,suspendedResources)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "void",
    "signature": "protected void doResume(@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected void doResume(@Nullable Object transaction, Object suspendedResources) {\n\t\tSuspendedResourcesHolder resourcesHolder = (SuspendedResourcesHolder) suspendedResources;\n\t\tTransactionSynchronizationManager.bindResource(\n\t\t\t\tobtainEntityManagerFactory(), resourcesHolder.getEntityManagerHolder());\n\t\tif (getDataSource() != null && resourcesHolder.getConnectionHolder() != null) {\n\t\t\tTransactionSynchronizationManager.bindResource(getDataSource(), resourcesHolder.getConnectionHolder());\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#findEntityManagerFactory(beanFactory,unitName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find an EntityManagerFactory with the given name in the given\n\t * Spring application context (represented as ListableBeanFactory).\n\t * <p>The specified unit name will be matched against the configured\n\t * persistence unit, provided that a discovered EntityManagerFactory\n\t * implements the {@link EntityManagerFactoryInfo} interface. If not,\n\t * the persistence unit name will be matched against the Spring bean name,\n\t * assuming that the EntityManagerFactory bean names follow that convention.\n\t * <p>If no unit name has been given, this method will search for a default\n\t * EntityManagerFactory through {@link ListableBeanFactory#getBean(Class)}.\n\t * @param beanFactory the ListableBeanFactory to search\n\t * @param unitName the name of the persistence unit (may be {@code null} or empty,\n\t * in which case a single bean of type EntityManagerFactory will be searched for)\n\t * @return the EntityManagerFactory\n\t * @throws NoSuchBeanDefinitionException if there is no such EntityManagerFactory in the context\n\t * @see EntityManagerFactoryInfo#getPersistenceUnitName()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "unitName"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "EntityManagerFactory",
    "signature": "public EntityManagerFactory findEntityManagerFactory(ListableBeanFactory beanFactory, @Nullable String unitName)",
    "source_code": "\tpublic static EntityManagerFactory findEntityManagerFactory(\n\t\t\tListableBeanFactory beanFactory, @Nullable String unitName) throws NoSuchBeanDefinitionException {\n\n\t\tAssert.notNull(beanFactory, \"ListableBeanFactory must not be null\");\n\t\tif (StringUtils.hasLength(unitName)) {\n\t\t\t// See whether we can find an EntityManagerFactory with matching persistence unit name.\n\t\t\tString[] candidateNames =\n\t\t\t\t\tBeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, EntityManagerFactory.class);\n\t\t\tfor (String candidateName : candidateNames) {\n\t\t\t\tEntityManagerFactory emf = (EntityManagerFactory) beanFactory.getBean(candidateName);\n\t\t\t\tif (emf instanceof EntityManagerFactoryInfo &&\n\t\t\t\t\t\tunitName.equals(((EntityManagerFactoryInfo) emf).getPersistenceUnitName())) {\n\t\t\t\t\treturn emf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// No matching persistence unit found - simply take the EntityManagerFactory\n\t\t\t// with the persistence unit name as bean name (by convention).\n\t\t\treturn beanFactory.getBean(unitName, EntityManagerFactory.class);\n\t\t}\n\t\telse {\n\t\t\t// Find unique EntityManagerFactory bean in the context, falling back to parent contexts.\n\t\t\treturn beanFactory.getBean(EntityManagerFactory.class);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#getTransactionalEntityManager(emf,Map<?,properties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JPA EntityManager from the given factory. Is aware of a corresponding\n\t * EntityManager bound to the current thread, e.g. when using JpaTransactionManager.\n\t * <p>Note: Will return {@code null} if no thread-bound EntityManager found!\n\t * @param emf the EntityManagerFactory to create the EntityManager with\n\t * @param properties the properties to be passed into the {@code createEntityManager}\n\t * call (may be {@code null})\n\t * @return the EntityManager, or {@code null} if none found\n\t * @throws DataAccessResourceFailureException if the EntityManager couldn't be obtained\n\t * @see JpaTransactionManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "EntityManager",
    "signature": "public EntityManager getTransactionalEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties)",
    "source_code": "\tpublic static EntityManager getTransactionalEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties)\n\t\t\tthrows DataAccessResourceFailureException {\n\t\ttry {\n\t\t\treturn doGetTransactionalEntityManager(emf, properties, true);\n\t\t}\n\t\tcatch (PersistenceException ex) {\n\t\t\tthrow new DataAccessResourceFailureException(\"Could not obtain JPA EntityManager\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 368
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on Query interface coming in...\n\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of EntityManager proxy.\n\t\t\t\t\treturn hashCode();\n\t\t\t\tcase \"unwrap\":\n\t\t\t\t\t// Handle JPA 2.0 unwrap method - could be a proxy match.\n\t\t\t\t\tClass<?> targetClass = (Class<?>) args[0];\n\t\t\t\t\tif (targetClass == null) {\n\t\t\t\t\t\treturn this.target;\n\t\t\t\t\t}\n\t\t\t\t\telse if (targetClass.isInstance(proxy)) {\n\t\t\t\t\t\treturn proxy;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"getOutputParameterValue\":\n\t\t\t\t\tif (this.entityManager == null) {\n\t\t\t\t\t\tObject key = args[0];\n\t\t\t\t\t\tif (this.outputParameters == null || !this.outputParameters.containsKey(key)) {\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"OUT/INOUT parameter not available: \" + key);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tObject value = this.outputParameters.get(key);\n\t\t\t\t\t\tif (value instanceof IllegalArgumentException) {\n\t\t\t\t\t\t\tthrow (IllegalArgumentException) value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Invoke method on actual Query object.\n\t\t\ttry {\n\t\t\t\tObject retVal = method.invoke(this.target, args);\n\t\t\t\tif (method.getName().equals(\"registerStoredProcedureParameter\") && args.length == 3 &&\n\t\t\t\t\t\t(args[2] == ParameterMode.OUT || args[2] == ParameterMode.INOUT)) {\n\t\t\t\t\tif (this.outputParameters == null) {\n\t\t\t\t\t\tthis.outputParameters = new LinkedHashMap<>();\n\t\t\t\t\t}\n\t\t\t\t\tthis.outputParameters.put(args[0], null);\n\t\t\t\t}\n\t\t\t\treturn (retVal == this.target ? proxy : retVal);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (queryTerminatingMethods.contains(method.getName())) {\n\t\t\t\t\t// Actual execution of the query: close the EntityManager right\n\t\t\t\t\t// afterwards, since that was the only reason we kept it open.\n\t\t\t\t\tif (this.outputParameters != null && this.target instanceof StoredProcedureQuery storedProc) {\n\t\t\t\t\t\tfor (Map.Entry<Object, Object> entry : this.outputParameters.entrySet()) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tObject key = entry.getKey();\n\t\t\t\t\t\t\t\tif (key instanceof Integer) {\n\t\t\t\t\t\t\t\t\tentry.setValue(storedProc.getOutputParameterValue((Integer) key));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tentry.setValue(storedProc.getOutputParameterValue(key.toString()));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t\t\t\tentry.setValue(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tEntityManagerFactoryUtils.closeEntityManager(this.entityManager);\n\t\t\t\t\tthis.entityManager = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.orm.jpa.<unknown>#releaseResource(resourceHolder,resourceKey)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourceHolder",
      "resourceKey"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "void",
    "signature": "protected void releaseResource(EntityManagerHolder resourceHolder, EntityManagerFactory resourceKey)",
    "source_code": "\t\tprotected void releaseResource(EntityManagerHolder resourceHolder, EntityManagerFactory resourceKey) {\n\t\t\tcloseEntityManager(resourceHolder.getEntityManager());\n\t\t}"
  },
  "org.springframework.orm.jpa.<unknown>#setEntityManagerHolder(entityManagerHolder,newEntityManagerHolder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityManagerHolder",
      "newEntityManagerHolder"
    ],
    "position": {
      "column": 1,
      "line": 671
    },
    "return": "void",
    "signature": "public void setEntityManagerHolder(@Nullable EntityManagerHolder entityManagerHolder, boolean newEntityManagerHolder)",
    "source_code": "\t\tpublic void setEntityManagerHolder(\n\t\t\t\t@Nullable EntityManagerHolder entityManagerHolder, boolean newEntityManagerHolder) {\n\n\t\t\tthis.entityManagerHolder = entityManagerHolder;\n\t\t\tthis.newEntityManagerHolder = newEntityManagerHolder;\n\t\t}"
  },
  "org.springframework.orm.jpa.<unknown>#setJpaPropertyMap(Map<String,jpaProperties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify JPA properties as a Map, to be passed into\n\t * {@code Persistence.createEntityManagerFactory} (if any).\n\t * <p>Can be populated with a \"map\" or \"props\" element in XML bean definitions.\n\t * @see jakarta.persistence.Persistence#createEntityManagerFactory(String, Map)\n\t * @see jakarta.persistence.spi.PersistenceProvider#createContainerEntityManagerFactory(PersistenceUnitInfo, Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "jpaProperties"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "void",
    "signature": "public void setJpaPropertyMap(@Nullable Map<String, ?> jpaProperties)",
    "source_code": "\tpublic void setJpaPropertyMap(@Nullable Map<String, ?> jpaProperties) {\n\t\tif (jpaProperties != null) {\n\t\t\tthis.jpaPropertyMap.putAll(jpaProperties);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#applyTo(generationContext,beanRegistrationCode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode"
    ],
    "position": {
      "column": 1,
      "line": 780
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode)",
    "source_code": "\t\tpublic void applyTo(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode) {\n\t\t\tGeneratedClass generatedClass = generationContext.getGeneratedClasses()\n\t\t\t\t\t.addForFeatureComponent(\"PersistenceInjection\", this.target, type -> {\n\t\t\t\t\t\ttype.addJavadoc(\"Persistence injection for {@link $T}.\", this.target);\n\t\t\t\t\t\ttype.addModifiers(javax.lang.model.element.Modifier.PUBLIC);\n\t\t\t\t\t});\n\t\t\tGeneratedMethod generatedMethod = generatedClass.getMethods().add(\"apply\", method -> {\n\t\t\t\tmethod.addJavadoc(\"Apply the persistence injection.\");\n\t\t\t\tmethod.addModifiers(javax.lang.model.element.Modifier.PUBLIC,\n\t\t\t\t\t\tjavax.lang.model.element.Modifier.STATIC);\n\t\t\t\tmethod.addParameter(RegisteredBean.class, REGISTERED_BEAN_PARAMETER);\n\t\t\t\tmethod.addParameter(this.target, INSTANCE_PARAMETER);\n\t\t\t\tmethod.returns(this.target);\n\t\t\t\tmethod.addCode(generateMethodCode(generationContext.getRuntimeHints(), generatedClass));\n\t\t\t});\n\t\t\tbeanRegistrationCode.addInstancePostProcessor(generatedMethod.toMethodReference());\n\t\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#findEntityManagerFactory(unitName,requestingBeanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find an EntityManagerFactory with the given name in the current Spring\n\t * application context, falling back to a single default EntityManagerFactory\n\t * (if any) in case of no unit name specified.\n\t * @param unitName the name of the persistence unit (may be {@code null} or empty)\n\t * @param requestingBeanName the name of the requesting bean\n\t * @return the EntityManagerFactory\n\t * @throws NoSuchBeanDefinitionException if there is no such EntityManagerFactory in the context\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "unitName",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "EntityManagerFactory",
    "signature": "protected EntityManagerFactory findEntityManagerFactory(@Nullable String unitName, @Nullable String requestingBeanName)",
    "source_code": "\tprotected EntityManagerFactory findEntityManagerFactory(@Nullable String unitName, @Nullable String requestingBeanName)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tString unitNameForLookup = (unitName != null ? unitName : \"\");\n\t\tif (unitNameForLookup.isEmpty()) {\n\t\t\tunitNameForLookup = this.defaultPersistenceUnitName;\n\t\t}\n\t\tif (!unitNameForLookup.isEmpty()) {\n\t\t\treturn findNamedEntityManagerFactory(unitNameForLookup, requestingBeanName);\n\t\t}\n\t\telse {\n\t\t\treturn findDefaultEntityManagerFactory(requestingBeanName);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#findNamedEntityManagerFactory(unitName,requestingBeanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find an EntityManagerFactory with the given name in the current\n\t * Spring application context.\n\t * @param unitName the name of the persistence unit (never empty)\n\t * @param requestingBeanName the name of the requesting bean\n\t * @return the EntityManagerFactory\n\t * @throws NoSuchBeanDefinitionException if there is no such EntityManagerFactory in the context\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "unitName",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 567
    },
    "return": "EntityManagerFactory",
    "signature": "protected EntityManagerFactory findNamedEntityManagerFactory(String unitName, @Nullable String requestingBeanName)",
    "source_code": "\tprotected EntityManagerFactory findNamedEntityManagerFactory(String unitName, @Nullable String requestingBeanName)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tAssert.state(this.beanFactory != null, \"ListableBeanFactory required for EntityManagerFactory bean lookup\");\n\n\t\tEntityManagerFactory emf = EntityManagerFactoryUtils.findEntityManagerFactory(this.beanFactory, unitName);\n\t\tif (requestingBeanName != null && this.beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tcbf.registerDependentBean(unitName, requestingBeanName);\n\t\t}\n\t\treturn emf;\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#getPersistenceContext(unitName,extended)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a specified persistence context for the given unit name, as defined\n\t * through the \"persistenceContexts\" (or \"extendedPersistenceContexts\") map.\n\t * @param unitName the name of the persistence unit\n\t * @param extended whether to obtain an extended persistence context\n\t * @return the corresponding EntityManager, or {@code null} if none found\n\t * @see #setPersistenceContexts\n\t * @see #setExtendedPersistenceContexts\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "unitName",
      "extended"
    ],
    "position": {
      "column": 1,
      "line": 512
    },
    "return": "EntityManager",
    "signature": "protected EntityManager getPersistenceContext(@Nullable String unitName, boolean extended)",
    "source_code": "\tprotected EntityManager getPersistenceContext(@Nullable String unitName, boolean extended) {\n\t\tMap<String, String> contexts = (extended ? this.extendedPersistenceContexts : this.persistenceContexts);\n\t\tif (contexts != null) {\n\t\t\tString unitNameForLookup = (unitName != null ? unitName : \"\");\n\t\t\tif (unitNameForLookup.isEmpty()) {\n\t\t\t\tunitNameForLookup = this.defaultPersistenceUnitName;\n\t\t\t}\n\t\t\tString jndiName = contexts.get(unitNameForLookup);\n\t\t\tif (jndiName == null && unitNameForLookup.isEmpty() && contexts.size() == 1) {\n\t\t\t\tjndiName = contexts.values().iterator().next();\n\t\t\t}\n\t\t\tif (jndiName != null) {\n\t\t\t\ttry {\n\t\t\t\t\treturn lookup(jndiName, EntityManager.class);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new IllegalStateException(\"Could not obtain EntityManager [\" + jndiName + \"] from JNDI\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#getResourceToInject(target,requestingBeanName)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Resolve the object against the application context.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "Object",
    "signature": "protected Object getResourceToInject(Object target, @Nullable String requestingBeanName)",
    "source_code": "\t\tprotected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {\n\t\t\t// Resolves to EntityManagerFactory or EntityManager.\n\t\t\tif (this.type != null) {\n\t\t\t\treturn (this.type == PersistenceContextType.EXTENDED ?\n\t\t\t\t\t\tresolveExtendedEntityManager(target, requestingBeanName) :\n\t\t\t\t\t\tresolveEntityManager(requestingBeanName));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// OK, so we need an EntityManagerFactory...\n\t\t\t\treturn resolveEntityManagerFactory(requestingBeanName);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#lookup(jndiName,requiredType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jndiName",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 623
    },
    "return": "T",
    "signature": "public T lookup(String jndiName, Class<T> requiredType)",
    "source_code": "\t\tpublic <T> T lookup(String jndiName, Class<T> requiredType) throws Exception {\n\t\t\tJndiLocatorDelegate locator = new JndiLocatorDelegate();\n\t\t\tif (jndiEnvironment instanceof JndiTemplate jndiTemplate) {\n\t\t\t\tlocator.setJndiTemplate(jndiTemplate);\n\t\t\t}\n\t\t\telse if (jndiEnvironment instanceof Properties properties) {\n\t\t\t\tlocator.setJndiEnvironment(properties);\n\t\t\t}\n\t\t\telse if (jndiEnvironment != null) {\n\t\t\t\tthrow new IllegalStateException(\"Illegal 'jndiEnvironment' type: \" + jndiEnvironment.getClass());\n\t\t\t}\n\t\t\tlocator.setResourceRef(resourceRef);\n\t\t\treturn locator.lookup(jndiName, requiredType);\n\t\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#postProcessBeforeDestruction(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 392
    },
    "return": "void",
    "signature": "public void postProcessBeforeDestruction(Object bean, String beanName)",
    "source_code": "\tpublic void postProcessBeforeDestruction(Object bean, String beanName) {\n\t\tEntityManager emToClose = this.extendedEntityManagersToClose.remove(bean);\n\t\tEntityManagerFactoryUtils.closeEntityManager(emToClose);\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 351
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t\tfindInjectionMetadata(beanDefinition, beanType, beanName);\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#postProcessProperties(pvs,bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 380
    },
    "return": "PropertyValues",
    "signature": "public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)",
    "source_code": "\tpublic PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n\t\tInjectionMetadata metadata = findPersistenceMetadata(beanName, bean.getClass(), pvs);\n\t\ttry {\n\t\t\tmetadata.inject(bean, beanName, pvs);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"Injection of persistence dependencies failed\", ex);\n\t\t}\n\t\treturn pvs;\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#setExtendedPersistenceContexts(Map<String,extendedPersistenceContexts)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the <i>extended</i> persistence contexts for EntityManager lookups,\n\t * as a Map from persistence unit name to persistence context JNDI name\n\t * (which needs to resolve to an EntityManager instance).\n\t * <p>JNDI names specified here should refer to {@code persistence-context-ref}\n\t * entries in the Jakarta EE deployment descriptors, matching the target persistence unit\n\t * and being set up with persistence context type {@code Extended}.\n\t * <p>In case of no unit name specified in the annotation, the specified value\n\t * for the {@link #setDefaultPersistenceUnitName default persistence unit}\n\t * will be taken (by default, the value mapped to the empty String),\n\t * or simply the single persistence unit if there is only one.\n\t * <p>This is mainly intended for use in a Jakarta EE environment, with all\n\t * lookup driven by the standard JPA annotations, and all EntityManager\n\t * references obtained from JNDI. No separate EntityManagerFactory bean\n\t * definitions are necessary in such a scenario, and all EntityManager\n\t * handling is done by the Jakarta EE server itself.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "extendedPersistenceContexts"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "void",
    "signature": "public void setExtendedPersistenceContexts(Map<String, String> extendedPersistenceContexts)",
    "source_code": "\tpublic void setExtendedPersistenceContexts(Map<String, String> extendedPersistenceContexts) {\n\t\tthis.extendedPersistenceContexts = extendedPersistenceContexts;\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#setPersistenceContexts(Map<String,persistenceContexts)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the <i>transactional</i> persistence contexts for EntityManager lookups,\n\t * as a Map from persistence unit name to persistence context JNDI name\n\t * (which needs to resolve to an EntityManager instance).\n\t * <p>JNDI names specified here should refer to {@code persistence-context-ref}\n\t * entries in the Jakarta EE deployment descriptors, matching the target persistence unit\n\t * and being set up with persistence context type {@code Transaction}.\n\t * <p>In case of no unit name specified in the annotation, the specified value\n\t * for the {@link #setDefaultPersistenceUnitName default persistence unit}\n\t * will be taken (by default, the value mapped to the empty String),\n\t * or simply the single persistence unit if there is only one.\n\t * <p>This is mainly intended for use in a Jakarta EE environment, with all\n\t * lookup driven by the standard JPA annotations, and all EntityManager\n\t * references obtained from JNDI. No separate EntityManagerFactory bean\n\t * definitions are necessary in such a scenario, and all EntityManager\n\t * handling is done by the Jakarta EE server itself.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "persistenceContexts"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "void",
    "signature": "public void setPersistenceContexts(Map<String, String> persistenceContexts)",
    "source_code": "\tpublic void setPersistenceContexts(Map<String, String> persistenceContexts) {\n\t\tthis.persistenceContexts = persistenceContexts;\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#setPersistenceUnits(Map<String,persistenceUnits)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the persistence units for EntityManagerFactory lookups,\n\t * as a Map from persistence unit name to persistence unit JNDI name\n\t * (which needs to resolve to an EntityManagerFactory instance).\n\t * <p>JNDI names specified here should refer to {@code persistence-unit-ref}\n\t * entries in the Jakarta EE deployment descriptor, matching the target persistence unit.\n\t * <p>In case of no unit name specified in the annotation, the specified value\n\t * for the {@link #setDefaultPersistenceUnitName default persistence unit}\n\t * will be taken (by default, the value mapped to the empty String),\n\t * or simply the single persistence unit if there is only one.\n\t * <p>This is mainly intended for use in a Jakarta EE environment, with all lookup\n\t * driven by the standard JPA annotations, and all EntityManagerFactory\n\t * references obtained from JNDI. No separate EntityManagerFactory bean\n\t * definitions are necessary in such a scenario.\n\t * <p>If no corresponding \"persistenceContexts\"/\"extendedPersistenceContexts\"\n\t * are specified, {@code @PersistenceContext} will be resolved to\n\t * EntityManagers built on top of the EntityManagerFactory defined here.\n\t * Note that those will be Spring-managed EntityManagers, which implement\n\t * transaction synchronization based on Spring's facilities.\n\t * If you prefer the Jakarta EE server's own EntityManager handling,\n\t * specify corresponding \"persistenceContexts\"/\"extendedPersistenceContexts\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "persistenceUnits"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "public void setPersistenceUnits(Map<String, String> persistenceUnits)",
    "source_code": "\tpublic void setPersistenceUnits(Map<String, String> persistenceUnits) {\n\t\tthis.persistenceUnits = persistenceUnits;\n\t}"
  },
  "org.springframework.orm.jpa.vendor.<unknown>#beginTransaction(entityManager,definition)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityManager",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "Object",
    "signature": "public Object beginTransaction(EntityManager entityManager, TransactionDefinition definition)",
    "source_code": "\tpublic Object beginTransaction(EntityManager entityManager, TransactionDefinition definition)\n\t\t\tthrows PersistenceException, SQLException, TransactionException {\n\n\t\tSessionImplementor session = getSession(entityManager);\n\n\t\tif (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\tsession.getTransaction().setTimeout(definition.getTimeout());\n\t\t}\n\n\t\tboolean isolationLevelNeeded = (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT);\n\t\tInteger previousIsolationLevel = null;\n\t\tConnection preparedCon = null;\n\n\t\tif (isolationLevelNeeded || definition.isReadOnly()) {\n\t\t\tif (this.prepareConnection && ConnectionReleaseMode.ON_CLOSE.equals(\n\t\t\t\t\tsession.getJdbcCoordinator().getLogicalConnection().getConnectionHandlingMode().getReleaseMode())) {\n\t\t\t\tpreparedCon = session.getJdbcCoordinator().getLogicalConnection().getPhysicalConnection();\n\t\t\t\tpreviousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(preparedCon, definition);\n\t\t\t}\n\t\t\telse if (isolationLevelNeeded) {\n\t\t\t\tthrow new InvalidIsolationLevelException(\n\t\t\t\t\t\t\"HibernateJpaDialect is not allowed to support custom isolation levels: \" +\n\t\t\t\t\t\t\"make sure that its 'prepareConnection' flag is on (the default) and that the \" +\n\t\t\t\t\t\t\"Hibernate connection release mode is set to ON_CLOSE.\");\n\t\t\t}\n\t\t}\n\n\t\t// Standard JPA transaction begin call for full JPA context setup...\n\t\tentityManager.getTransaction().begin();\n\n\t\t// Adapt flush mode and store previous isolation level, if any.\n\t\tFlushMode previousFlushMode = prepareFlushMode(session, definition.isReadOnly());\n\t\tif (definition instanceof ResourceTransactionDefinition &&\n\t\t\t\t((ResourceTransactionDefinition) definition).isLocalResource()) {\n\t\t\t// As of 5.1, we explicitly optimize for a transaction-local EntityManager,\n\t\t\t// aligned with native HibernateTransactionManager behavior.\n\t\t\tpreviousFlushMode = null;\n\t\t\tif (definition.isReadOnly()) {\n\t\t\t\tsession.setDefaultReadOnly(true);\n\t\t\t}\n\t\t}\n\t\treturn new SessionTransactionData(\n\t\t\t\tsession, previousFlushMode, (preparedCon != null), previousIsolationLevel, definition.isReadOnly());\n\t}"
  },
  "org.springframework.orm.jpa.vendor.<unknown>#getJdbcConnection(entityManager,readOnly)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityManager",
      "readOnly"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "ConnectionHandle",
    "signature": "public ConnectionHandle getJdbcConnection(EntityManager entityManager, boolean readOnly)",
    "source_code": "\tpublic ConnectionHandle getJdbcConnection(EntityManager entityManager, boolean readOnly)\n\t\t\tthrows PersistenceException, SQLException {\n\n\t\tSessionImplementor session = getSession(entityManager);\n\t\treturn new HibernateConnectionHandle(session);\n\t}"
  },
  "org.springframework.orm.jpa.vendor.<unknown>#prepareFlushMode(session,readOnly)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "readOnly"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "FlushMode",
    "signature": "protected FlushMode prepareFlushMode(Session session, boolean readOnly)",
    "source_code": "\tprotected FlushMode prepareFlushMode(Session session, boolean readOnly) throws PersistenceException {\n\t\tFlushMode flushMode = session.getHibernateFlushMode();\n\t\tif (readOnly) {\n\t\t\t// We should suppress flushing for a read-only transaction.\n\t\t\tif (!flushMode.equals(FlushMode.MANUAL)) {\n\t\t\t\tsession.setHibernateFlushMode(FlushMode.MANUAL);\n\t\t\t\treturn flushMode;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// We need AUTO or COMMIT for a non-read-only transaction.\n\t\t\tif (flushMode.lessThan(FlushMode.COMMIT)) {\n\t\t\t\tsession.setHibernateFlushMode(FlushMode.AUTO);\n\t\t\t\treturn flushMode;\n\t\t\t}\n\t\t}\n\t\t// No FlushMode change needed...\n\t\treturn null;\n\t}"
  },
  "org.springframework.orm.jpa.vendor.<unknown>#prepareTransaction(entityManager,readOnly,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityManager",
      "readOnly",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "Object",
    "signature": "public Object prepareTransaction(EntityManager entityManager, boolean readOnly, @Nullable String name)",
    "source_code": "\tpublic Object prepareTransaction(EntityManager entityManager, boolean readOnly, @Nullable String name)\n\t\t\tthrows PersistenceException {\n\n\t\tSessionImplementor session = getSession(entityManager);\n\t\tFlushMode previousFlushMode = prepareFlushMode(session, readOnly);\n\t\treturn new SessionTransactionData(session, previousFlushMode, false, null, readOnly);\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#addMtomAttachment(data,offset,length,mimeType,elementNamespace,elementLocalName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "data",
      "offset",
      "length",
      "mimeType",
      "elementNamespace",
      "elementLocalName"
    ],
    "position": {
      "column": 1,
      "line": 972
    },
    "return": "String",
    "signature": "public String addMtomAttachment(byte[] data, int offset, int length, String mimeType,\n\t\t\t\tString elementNamespace, String elementLocalName)",
    "source_code": "\t\tpublic String addMtomAttachment(byte[] data, int offset, int length, String mimeType,\n\t\t\t\tString elementNamespace, String elementLocalName) {\n\t\t\tByteArrayDataSource dataSource = new ByteArrayDataSource(mimeType, data, offset, length);\n\t\t\treturn addMtomAttachment(new DataHandler(dataSource), elementNamespace, elementLocalName);\n\t\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#addMtomAttachment(dataHandler,elementNamespace,elementLocalName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataHandler",
      "elementNamespace",
      "elementLocalName"
    ],
    "position": {
      "column": 1,
      "line": 979
    },
    "return": "String",
    "signature": "public String addMtomAttachment(DataHandler dataHandler, String elementNamespace, String elementLocalName)",
    "source_code": "\t\tpublic String addMtomAttachment(DataHandler dataHandler, String elementNamespace, String elementLocalName) {\n\t\t\tString host = getHost(elementNamespace, dataHandler);\n\t\t\tString contentId = UUID.randomUUID() + \"@\" + host;\n\t\t\tthis.mimeContainer.addAttachment(\"<\" + contentId + \">\", dataHandler);\n\t\t\tcontentId = URLEncoder.encode(contentId, StandardCharsets.UTF_8);\n\t\t\treturn CID + contentId;\n\t\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#marshal(graph,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 697
    },
    "return": "void",
    "signature": "public void marshal(Object graph, Result result)",
    "source_code": "\tpublic void marshal(Object graph, Result result) throws XmlMappingException {\n\t\tmarshal(graph, result, null);\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#marshal(graph,result,mimeContainer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "result",
      "mimeContainer"
    ],
    "position": {
      "column": 1,
      "line": 702
    },
    "return": "void",
    "signature": "public void marshal(Object graph, Result result, @Nullable MimeContainer mimeContainer)",
    "source_code": "\tpublic void marshal(Object graph, Result result, @Nullable MimeContainer mimeContainer) throws XmlMappingException {\n\t\ttry {\n\t\t\tMarshaller marshaller = createMarshaller();\n\t\t\tif (this.mtomEnabled && mimeContainer != null) {\n\t\t\t\tmarshaller.setAttachmentMarshaller(new Jaxb2AttachmentMarshaller(mimeContainer));\n\t\t\t}\n\t\t\tif (StaxUtils.isStaxResult(result)) {\n\t\t\t\tmarshalStaxResult(marshaller, graph, result);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmarshaller.marshal(graph, result);\n\t\t\t}\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow convertJaxbException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#setAdapters(XmlAdapter<?,adapters)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the {@code XmlAdapter}s to be registered with the JAXB {@code Marshaller}\n\t * and {@code Unmarshaller}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "XmlAdapter<?",
      "adapters"
    ],
    "position": {
      "column": 1,
      "line": 329
    },
    "return": "void",
    "signature": "public void setAdapters(XmlAdapter<?, ?>... adapters)",
    "source_code": "\tpublic void setAdapters(XmlAdapter<?, ?>... adapters) {\n\t\tthis.adapters = adapters;\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#setJaxbContextProperties(Map<String,jaxbContextProperties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@code JAXBContext} properties. These implementation-specific\n\t * properties will be set on the underlying {@code JAXBContext}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "jaxbContextProperties"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "void",
    "signature": "public void setJaxbContextProperties(Map<String, ?> jaxbContextProperties)",
    "source_code": "\tpublic void setJaxbContextProperties(Map<String, ?> jaxbContextProperties) {\n\t\tthis.jaxbContextProperties = jaxbContextProperties;\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#setMarshallerProperties(Map<String,properties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JAXB {@code Marshaller} properties.\n\t * <p>These properties will be set on the underlying JAXB {@code Marshaller},\n\t * and allow for features such as indentation.\n\t * @param properties the properties\n\t * @see jakarta.xml.bind.Marshaller#setProperty(String, Object)\n\t * @see jakarta.xml.bind.Marshaller#JAXB_ENCODING\n\t * @see jakarta.xml.bind.Marshaller#JAXB_FORMATTED_OUTPUT\n\t * @see jakarta.xml.bind.Marshaller#JAXB_NO_NAMESPACE_SCHEMA_LOCATION\n\t * @see jakarta.xml.bind.Marshaller#JAXB_SCHEMA_LOCATION\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "void",
    "signature": "public void setMarshallerProperties(Map<String, ?> properties)",
    "source_code": "\tpublic void setMarshallerProperties(Map<String, ?> properties) {\n\t\tthis.marshallerProperties = properties;\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#setUnmarshallerProperties(Map<String,properties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JAXB {@code Unmarshaller} properties.\n\t * <p>These properties will be set on the underlying JAXB {@code Unmarshaller}.\n\t * @param properties the properties\n\t * @see jakarta.xml.bind.Unmarshaller#setProperty(String, Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "void",
    "signature": "public void setUnmarshallerProperties(Map<String, ?> properties)",
    "source_code": "\tpublic void setUnmarshallerProperties(Map<String, ?> properties) {\n\t\tthis.unmarshallerProperties = properties;\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#unmarshal(source,mimeContainer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "mimeContainer"
    ],
    "position": {
      "column": 1,
      "line": 795
    },
    "return": "Object",
    "signature": "public Object unmarshal(Source source, @Nullable MimeContainer mimeContainer)",
    "source_code": "\tpublic Object unmarshal(Source source, @Nullable MimeContainer mimeContainer) throws XmlMappingException {\n\t\tsource = processSource(source);\n\n\t\ttry {\n\t\t\tUnmarshaller unmarshaller = createUnmarshaller();\n\t\t\tif (this.mtomEnabled && mimeContainer != null) {\n\t\t\t\tunmarshaller.setAttachmentUnmarshaller(new Jaxb2AttachmentUnmarshaller(mimeContainer));\n\t\t\t}\n\t\t\tif (StaxUtils.isStaxSource(source)) {\n\t\t\t\treturn unmarshalStaxSource(unmarshaller, source);\n\t\t\t}\n\t\t\telse if (this.mappedClass != null) {\n\t\t\t\treturn unmarshaller.unmarshal(source, this.mappedClass).getValue();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn unmarshaller.unmarshal(source);\n\t\t\t}\n\t\t}\n\t\tcatch (NullPointerException ex) {\n\t\t\tif (!isSupportDtd()) {\n\t\t\t\tthrow new UnmarshallingFailureException(\"NPE while unmarshalling: \" +\n\t\t\t\t\t\t\"This can happen due to the presence of DTD declarations which are disabled.\", ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow convertJaxbException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#unmarshalStaxSource(jaxbUnmarshaller,staxSource)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jaxbUnmarshaller",
      "staxSource"
    ],
    "position": {
      "column": 1,
      "line": 843
    },
    "return": "Object",
    "signature": "protected Object unmarshalStaxSource(Unmarshaller jaxbUnmarshaller, Source staxSource)",
    "source_code": "\tprotected Object unmarshalStaxSource(Unmarshaller jaxbUnmarshaller, Source staxSource) throws JAXBException {\n\t\tXMLStreamReader streamReader = StaxUtils.getXMLStreamReader(staxSource);\n\t\tif (streamReader != null) {\n\t\t\treturn (this.mappedClass != null ?\n\t\t\t\t\tjaxbUnmarshaller.unmarshal(streamReader, this.mappedClass).getValue() :\n\t\t\t\t\tjaxbUnmarshaller.unmarshal(streamReader));\n\t\t}\n\t\telse {\n\t\t\tXMLEventReader eventReader = StaxUtils.getXMLEventReader(staxSource);\n\t\t\tif (eventReader != null) {\n\t\t\t\treturn (this.mappedClass != null ?\n\t\t\t\t\t\tjaxbUnmarshaller.unmarshal(eventReader, this.mappedClass).getValue() :\n\t\t\t\t\t\tjaxbUnmarshaller.unmarshal(eventReader));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"StaxSource contains neither XMLStreamReader nor XMLEventReader\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#convertXStreamException(ex,marshalling)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given XStream exception to an appropriate exception from the\n\t * {@code org.springframework.oxm} hierarchy.\n\t * <p>A boolean flag is used to indicate whether this exception occurs during marshalling or\n\t * unmarshalling, since XStream itself does not make this distinction in its exception hierarchy.\n\t * @param ex the XStream exception that occurred\n\t * @param marshalling indicates whether the exception occurs during marshalling ({@code true}),\n\t * or unmarshalling ({@code false})\n\t * @return the corresponding {@code XmlMappingException}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "marshalling"
    ],
    "position": {
      "column": 1,
      "line": 876
    },
    "return": "XmlMappingException",
    "signature": "protected XmlMappingException convertXStreamException(Exception ex, boolean marshalling)",
    "source_code": "\tprotected XmlMappingException convertXStreamException(Exception ex, boolean marshalling) {\n\t\tif (ex instanceof StreamException || ex instanceof CannotResolveClassException ||\n\t\t\t\tex instanceof ForbiddenClassException || ex instanceof ConversionException) {\n\t\t\tif (marshalling) {\n\t\t\t\treturn new MarshallingFailureException(\"XStream marshalling exception\",  ex);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new UnmarshallingFailureException(\"XStream unmarshalling exception\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// fallback\n\t\t\treturn new UncategorizedMappingException(\"Unknown XStream exception\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalDomNode(graph,node)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "node"
    ],
    "position": {
      "column": 1,
      "line": 674
    },
    "return": "void",
    "signature": "protected void marshalDomNode(Object graph, Node node)",
    "source_code": "\tprotected void marshalDomNode(Object graph, Node node) throws XmlMappingException {\n\t\tHierarchicalStreamWriter streamWriter;\n\t\tif (node instanceof Document document) {\n\t\t\tstreamWriter = new DomWriter(document, this.nameCoder);\n\t\t}\n\t\telse if (node instanceof Element element) {\n\t\t\tstreamWriter = new DomWriter(element, node.getOwnerDocument(), this.nameCoder);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"DOMResult contains neither Document nor Element\");\n\t\t}\n\t\tdoMarshal(graph, streamWriter, null);\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalOutputStream(graph,outputStream)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "outputStream"
    ],
    "position": {
      "column": 1,
      "line": 722
    },
    "return": "void",
    "signature": "public void marshalOutputStream(Object graph, OutputStream outputStream)",
    "source_code": "\tpublic void marshalOutputStream(Object graph, OutputStream outputStream) throws XmlMappingException, IOException {\n\t\tmarshalOutputStream(graph, outputStream, null);\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalOutputStream(graph,outputStream,dataHolder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "outputStream",
      "dataHolder"
    ],
    "position": {
      "column": 1,
      "line": 726
    },
    "return": "void",
    "signature": "public void marshalOutputStream(Object graph, OutputStream outputStream, @Nullable DataHolder dataHolder)",
    "source_code": "\tpublic void marshalOutputStream(Object graph, OutputStream outputStream, @Nullable DataHolder dataHolder)\n\t\t\tthrows XmlMappingException, IOException {\n\n\t\tif (this.streamDriver != null) {\n\t\t\tdoMarshal(graph, this.streamDriver.createWriter(outputStream), dataHolder);\n\t\t}\n\t\telse {\n\t\t\tmarshalWriter(graph, new OutputStreamWriter(outputStream, this.encoding), dataHolder);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalSaxHandlers(graph,contentHandler,lexicalHandler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "contentHandler",
      "lexicalHandler"
    ],
    "position": {
      "column": 1,
      "line": 713
    },
    "return": "void",
    "signature": "protected void marshalSaxHandlers(Object graph, ContentHandler contentHandler, @Nullable LexicalHandler lexicalHandler)",
    "source_code": "\tprotected void marshalSaxHandlers(Object graph, ContentHandler contentHandler, @Nullable LexicalHandler lexicalHandler)\n\t\t\tthrows XmlMappingException {\n\n\t\tSaxWriter saxWriter = new SaxWriter(this.nameCoder);\n\t\tsaxWriter.setContentHandler(contentHandler);\n\t\tdoMarshal(graph, saxWriter, null);\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalWriter(graph,writer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "writer"
    ],
    "position": {
      "column": 1,
      "line": 738
    },
    "return": "void",
    "signature": "public void marshalWriter(Object graph, Writer writer)",
    "source_code": "\tpublic void marshalWriter(Object graph, Writer writer) throws XmlMappingException, IOException {\n\t\tmarshalWriter(graph, writer, null);\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalWriter(graph,writer,dataHolder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "writer",
      "dataHolder"
    ],
    "position": {
      "column": 1,
      "line": 742
    },
    "return": "void",
    "signature": "public void marshalWriter(Object graph, Writer writer, @Nullable DataHolder dataHolder)",
    "source_code": "\tpublic void marshalWriter(Object graph, Writer writer, @Nullable DataHolder dataHolder)\n\t\t\tthrows XmlMappingException, IOException {\n\n\t\tif (this.streamDriver != null) {\n\t\t\tdoMarshal(graph, this.streamDriver.createWriter(writer), dataHolder);\n\t\t}\n\t\telse {\n\t\t\tdoMarshal(graph, new CompactWriter(writer), dataHolder);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalXmlEventWriter(graph,eventWriter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "eventWriter"
    ],
    "position": {
      "column": 1,
      "line": 689
    },
    "return": "void",
    "signature": "protected void marshalXmlEventWriter(Object graph, XMLEventWriter eventWriter)",
    "source_code": "\tprotected void marshalXmlEventWriter(Object graph, XMLEventWriter eventWriter) throws XmlMappingException {\n\t\tContentHandler contentHandler = StaxUtils.createContentHandler(eventWriter);\n\t\tLexicalHandler lexicalHandler = (contentHandler instanceof LexicalHandler handler ? handler : null);\n\t\tmarshalSaxHandlers(graph, contentHandler, lexicalHandler);\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalXmlStreamWriter(graph,streamWriter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "streamWriter"
    ],
    "position": {
      "column": 1,
      "line": 696
    },
    "return": "void",
    "signature": "protected void marshalXmlStreamWriter(Object graph, XMLStreamWriter streamWriter)",
    "source_code": "\tprotected void marshalXmlStreamWriter(Object graph, XMLStreamWriter streamWriter) throws XmlMappingException {\n\t\ttry {\n\t\t\tStaxWriter writer;\n\t\t\tif (this.streamDriver instanceof StaxDriver staxDriver) {\n\t\t\t\twriter = staxDriver.createStaxWriter(streamWriter);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twriter = new StaxWriter(new QNameMap(), streamWriter, this.nameCoder);\n\t\t\t}\n\t\t\tdoMarshal(graph, writer, null);\n\t\t}\n\t\tcatch (XMLStreamException ex) {\n\t\t\tthrow convertXStreamException(ex, true);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setAliases(Map<String,aliases)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the alias/type map, consisting of string aliases mapped to classes.\n\t * <p>Keys are aliases; values are either {@code Class} instances, or String class names.\n\t * @see XStream#alias(String, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "aliases"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "void",
    "signature": "public void setAliases(Map<String, ?> aliases)",
    "source_code": "\tpublic void setAliases(Map<String, ?> aliases) {\n\t\tthis.aliases = aliases;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setAliasesByType(Map<String,aliasesByType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the <em>aliases by type</em> map, consisting of string aliases mapped to classes.\n\t * <p>Any class that is assignable to this type will be aliased to the same name.\n\t * Keys are aliases; values are either {@code Class} instances, or String class names.\n\t * @see XStream#aliasType(String, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "aliasesByType"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "void",
    "signature": "public void setAliasesByType(Map<String, ?> aliasesByType)",
    "source_code": "\tpublic void setAliasesByType(Map<String, ?> aliasesByType) {\n\t\tthis.aliasesByType = aliasesByType;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setFieldAliases(Map<String,fieldAliases)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the field alias/type map, consisting of field names.\n\t * @see XStream#aliasField(String, Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "fieldAliases"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "void",
    "signature": "public void setFieldAliases(Map<String, String> fieldAliases)",
    "source_code": "\tpublic void setFieldAliases(Map<String, String> fieldAliases) {\n\t\tthis.fieldAliases = fieldAliases;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setImplicitCollections(Map<Class<?>,implicitCollections)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify implicit collection fields, as a Map consisting of {@code Class} instances\n\t * mapped to comma separated collection field names.\n\t * @see XStream#addImplicitCollection(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "implicitCollections"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "void",
    "signature": "public void setImplicitCollections(Map<Class<?>, String> implicitCollections)",
    "source_code": "\tpublic void setImplicitCollections(Map<Class<?>, String> implicitCollections) {\n\t\tthis.implicitCollections = implicitCollections;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setOmittedFields(Map<Class<?>,omittedFields)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify omitted fields, as a Map consisting of {@code Class} instances\n\t * mapped to comma separated field names.\n\t * @see XStream#omitField(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "omittedFields"
    ],
    "position": {
      "column": 1,
      "line": 374
    },
    "return": "void",
    "signature": "public void setOmittedFields(Map<Class<?>, String> omittedFields)",
    "source_code": "\tpublic void setOmittedFields(Map<Class<?>, String> omittedFields) {\n\t\tthis.omittedFields = omittedFields;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setUseAttributeFor(Map<?,useAttributeFor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the types to use XML attributes for. The given map can contain\n\t * either {@code <String, Class>} pairs, in which case\n\t * {@link XStream#useAttributeFor(String, Class)} is called.\n\t * Alternatively, the map can contain {@code <Class, String>}\n\t * or {@code <Class, List<String>>} pairs, which results\n\t * in {@link XStream#useAttributeFor(Class, String)} calls.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "useAttributeFor"
    ],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "void",
    "signature": "public void setUseAttributeFor(Map<?, ?> useAttributeFor)",
    "source_code": "\tpublic void setUseAttributeFor(Map<?, ?> useAttributeFor) {\n\t\tthis.useAttributeFor = useAttributeFor;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#unmarshalInputStream(inputStream,dataHolder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "dataHolder"
    ],
    "position": {
      "column": 1,
      "line": 834
    },
    "return": "Object",
    "signature": "public Object unmarshalInputStream(InputStream inputStream, @Nullable DataHolder dataHolder)",
    "source_code": "\tpublic Object unmarshalInputStream(InputStream inputStream, @Nullable DataHolder dataHolder) throws XmlMappingException, IOException {\n\t\tif (this.streamDriver != null) {\n\t\t\treturn doUnmarshal(this.streamDriver.createReader(inputStream), dataHolder);\n\t\t}\n\t\telse {\n\t\t\treturn unmarshalReader(new InputStreamReader(inputStream, this.encoding), dataHolder);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#unmarshalReader(reader,dataHolder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reader",
      "dataHolder"
    ],
    "position": {
      "column": 1,
      "line": 848
    },
    "return": "Object",
    "signature": "public Object unmarshalReader(Reader reader, @Nullable DataHolder dataHolder)",
    "source_code": "\tpublic Object unmarshalReader(Reader reader, @Nullable DataHolder dataHolder) throws XmlMappingException, IOException {\n\t\treturn doUnmarshal(getDefaultDriver().createReader(reader), dataHolder);\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#unmarshalSaxReader(xmlReader,inputSource)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "xmlReader",
      "inputSource"
    ],
    "position": {
      "column": 1,
      "line": 822
    },
    "return": "Object",
    "signature": "protected Object unmarshalSaxReader(XMLReader xmlReader, InputSource inputSource)",
    "source_code": "\tprotected Object unmarshalSaxReader(XMLReader xmlReader, InputSource inputSource)\n\t\t\tthrows XmlMappingException, IOException {\n\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"XStreamMarshaller does not support unmarshalling using SAX XMLReaders\");\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doBegin(synchronizationManager,transaction,definition)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "synchronizationManager",
      "transaction",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doBegin(TransactionSynchronizationManager synchronizationManager, Object transaction,\n\t\t\tTransactionDefinition definition)",
    "source_code": "\tprotected Mono<Void> doBegin(TransactionSynchronizationManager synchronizationManager, Object transaction,\n\t\t\tTransactionDefinition definition) throws TransactionException {\n\n\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) transaction;\n\n\t\treturn Mono.defer(() -> {\n\t\t\tMono<Connection> connectionMono;\n\n\t\t\tif (!txObject.hasConnectionHolder() || txObject.getConnectionHolder().isSynchronizedWithTransaction()) {\n\t\t\t\tMono<Connection> newCon = Mono.from(obtainConnectionFactory().create());\n\t\t\t\tconnectionMono = newCon.doOnNext(connection -> {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Acquired Connection [\" + connection + \"] for R2DBC transaction\");\n\t\t\t\t\t}\n\t\t\t\t\ttxObject.setConnectionHolder(new ConnectionHolder(connection), true);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttxObject.getConnectionHolder().setSynchronizedWithTransaction(true);\n\t\t\t\tconnectionMono = Mono.just(txObject.getConnectionHolder().getConnection());\n\t\t\t}\n\n\t\t\treturn connectionMono.flatMap(con -> switchAutoCommitIfNecessary(con, transaction)\n\t\t\t\t\t.then(Mono.from(doBegin(definition, con)))\n\t\t\t\t\t.then(prepareTransactionalConnection(con, definition))\n\t\t\t\t\t.doOnSuccess(v -> {\n\t\t\t\t\t\ttxObject.getConnectionHolder().setTransactionActive(true);\n\t\t\t\t\t\tDuration timeout = determineTimeout(definition);\n\t\t\t\t\t\tif (!timeout.isNegative() && !timeout.isZero()) {\n\t\t\t\t\t\t\ttxObject.getConnectionHolder().setTimeoutInMillis(timeout.toMillis());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Bind the connection holder to the thread.\n\t\t\t\t\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\t\t\t\t\tsynchronizationManager.bindResource(obtainConnectionFactory(), txObject.getConnectionHolder());\n\t\t\t\t\t\t}\n\t\t\t\t\t}).thenReturn(con).onErrorResume(e -> {\n\t\t\t\t\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\t\t\t\t\treturn ConnectionFactoryUtils.releaseConnection(con, obtainConnectionFactory())\n\t\t\t\t\t\t\t\t\t.doOnTerminate(() -> txObject.setConnectionHolder(null, false))\n\t\t\t\t\t\t\t\t\t.then(Mono.error(e));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn Mono.error(e);\n\t\t\t\t\t})).onErrorResume(e -> {\n\t\t\t\t\t\tCannotCreateTransactionException ex = new CannotCreateTransactionException(\n\t\t\t\t\t\t\t\t\"Could not open R2DBC Connection for transaction\", e);\n\t\t\t\t\t\treturn Mono.error(ex);\n\t\t\t\t\t});\n\t\t}).then();\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doCleanupAfterCompletion(synchronizationManager,transaction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "synchronizationManager",
      "transaction"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doCleanupAfterCompletion(TransactionSynchronizationManager synchronizationManager,\n\t\t\tObject transaction)",
    "source_code": "\tprotected Mono<Void> doCleanupAfterCompletion(TransactionSynchronizationManager synchronizationManager,\n\t\t\tObject transaction) {\n\n\t\treturn Mono.defer(() -> {\n\t\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) transaction;\n\n\t\t\t// Remove the connection holder from the context, if exposed.\n\t\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\t\tsynchronizationManager.unbindResource(obtainConnectionFactory());\n\t\t\t}\n\n\t\t\t// Reset connection.\n\t\t\tConnection con = txObject.getConnectionHolder().getConnection();\n\n\t\t\tMono<Void> afterCleanup = Mono.empty();\n\n\t\t\tif (txObject.isMustRestoreAutoCommit()) {\n\t\t\t\tMono<Void> restoreAutoCommitStep = safeCleanupStep(\n\t\t\t\t\t\t\"doCleanupAfterCompletion when restoring autocommit\", Mono.from(con.setAutoCommit(true)));\n\t\t\t\tafterCleanup = afterCleanup.then(restoreAutoCommitStep);\n\t\t\t}\n\n\t\t\tMono<Void> releaseConnectionStep = Mono.defer(() -> {\n\t\t\t\ttry {\n\t\t\t\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Releasing R2DBC Connection [\" + con + \"] after transaction\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn safeCleanupStep(\"doCleanupAfterCompletion when releasing R2DBC Connection\",\n\t\t\t\t\t\t\t\tConnectionFactoryUtils.releaseConnection(con, obtainConnectionFactory()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\ttxObject.getConnectionHolder().clear();\n\t\t\t\t}\n\t\t\t\treturn Mono.empty();\n\t\t\t});\n\t\t\treturn afterCleanup.then(releaseConnectionStep);\n\t\t});\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doCommit(TransactionSynchronizationManager,status)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "TransactionSynchronizationManager",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doCommit(TransactionSynchronizationManager TransactionSynchronizationManager,\n\t\t\tGenericReactiveTransaction status)",
    "source_code": "\tprotected Mono<Void> doCommit(TransactionSynchronizationManager TransactionSynchronizationManager,\n\t\t\tGenericReactiveTransaction status) throws TransactionException {\n\n\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) status.getTransaction();\n\t\tConnection connection = txObject.getConnectionHolder().getConnection();\n\t\tif (status.isDebug()) {\n\t\t\tlogger.debug(\"Committing R2DBC transaction on Connection [\" + connection + \"]\");\n\t\t}\n\t\treturn Mono.from(connection.commitTransaction())\n\t\t\t\t.onErrorMap(R2dbcException.class, ex -> translateException(\"R2DBC commit\", ex));\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doResume(synchronizationManager,transaction,suspendedResources)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "synchronizationManager",
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doResume(TransactionSynchronizationManager synchronizationManager,\n\t\t\t@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected Mono<Void> doResume(TransactionSynchronizationManager synchronizationManager,\n\t\t\t@Nullable Object transaction, Object suspendedResources) throws TransactionException {\n\n\t\treturn Mono.defer(() -> {\n\t\t\tsynchronizationManager.bindResource(obtainConnectionFactory(), suspendedResources);\n\t\t\treturn Mono.empty();\n\t\t});\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doRollback(TransactionSynchronizationManager,status)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "TransactionSynchronizationManager",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doRollback(TransactionSynchronizationManager TransactionSynchronizationManager,\n\t\t\tGenericReactiveTransaction status)",
    "source_code": "\tprotected Mono<Void> doRollback(TransactionSynchronizationManager TransactionSynchronizationManager,\n\t\t\tGenericReactiveTransaction status) throws TransactionException {\n\n\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) status.getTransaction();\n\t\tConnection connection = txObject.getConnectionHolder().getConnection();\n\t\tif (status.isDebug()) {\n\t\t\tlogger.debug(\"Rolling back R2DBC transaction on Connection [\" + connection + \"]\");\n\t\t}\n\t\treturn Mono.from(connection.rollbackTransaction())\n\t\t\t\t.onErrorMap(R2dbcException.class, ex -> translateException(\"R2DBC rollback\", ex));\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doSetRollbackOnly(synchronizationManager,status)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "synchronizationManager",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 329
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doSetRollbackOnly(TransactionSynchronizationManager synchronizationManager,\n\t\t\tGenericReactiveTransaction status)",
    "source_code": "\tprotected Mono<Void> doSetRollbackOnly(TransactionSynchronizationManager synchronizationManager,\n\t\t\tGenericReactiveTransaction status) throws TransactionException {\n\n\t\treturn Mono.fromRunnable(() -> {\n\t\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) status.getTransaction();\n\t\t\tif (status.isDebug()) {\n\t\t\t\tlogger.debug(\"Setting R2DBC transaction [\" + txObject.getConnectionHolder().getConnection() +\n\t\t\t\t\t\t\"] rollback-only\");\n\t\t\t}\n\t\t\ttxObject.setRollbackOnly();\n\t\t});\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doSuspend(synchronizationManager,transaction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "synchronizationManager",
      "transaction"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "Mono<Object>",
    "signature": "protected Mono<Object> doSuspend(TransactionSynchronizationManager synchronizationManager, Object transaction)",
    "source_code": "\tprotected Mono<Object> doSuspend(TransactionSynchronizationManager synchronizationManager, Object transaction)\n\t\t\tthrows TransactionException {\n\n\t\treturn Mono.defer(() -> {\n\t\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) transaction;\n\t\t\ttxObject.setConnectionHolder(null);\n\t\t\treturn Mono.justOrEmpty(synchronizationManager.unbindResource(obtainConnectionFactory()));\n\t\t});\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#prepareTransactionalConnection(con,definition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the transactional {@link Connection} right after transaction begin.\n\t * <p>The default implementation executes a \"SET TRANSACTION READ ONLY\" statement if the\n\t * {@link #setEnforceReadOnly \"enforceReadOnly\"} flag is set to {@code true} and the\n\t * transaction definition indicates a read-only transaction.\n\t * <p>The \"SET TRANSACTION READ ONLY\" is understood by Oracle, MySQL and Postgres\n\t * and may work with other databases as well. If you'd like to adapt this treatment,\n\t * override this method accordingly.\n\t * @param con the transactional R2DBC Connection\n\t * @param definition the current transaction definition\n\t * @since 5.3.22\n\t * @see #setEnforceReadOnly\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 426
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> prepareTransactionalConnection(Connection con, TransactionDefinition definition)",
    "source_code": "\tprotected Mono<Void> prepareTransactionalConnection(Connection con, TransactionDefinition definition) {\n\t\tMono<Void> prepare = Mono.empty();\n\t\tif (isEnforceReadOnly() && definition.isReadOnly()) {\n\t\t\tprepare = Mono.from(con.createStatement(\"SET TRANSACTION READ ONLY\").execute())\n\t\t\t\t\t.flatMapMany(Result::getRowsUpdated)\n\t\t\t\t\t.then();\n\t\t}\n\t\treturn prepare;\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#translateException(task,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Translate the given R2DBC commit/rollback exception to a common Spring exception to propagate\n\t * from the {@link #commit}/{@link #rollback} call.\n\t * @param task the task description (commit or rollback).\n\t * @param ex the SQLException thrown from commit/rollback.\n\t * @return the translated exception to emit\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 463
    },
    "return": "RuntimeException",
    "signature": "protected RuntimeException translateException(String task, R2dbcException ex)",
    "source_code": "\tprotected RuntimeException translateException(String task, R2dbcException ex) {\n\t\treturn ConnectionFactoryUtils.convertR2dbcException(task, null, ex);\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bind(identifier,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "identifier",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 550
    },
    "return": "void",
    "signature": "public void bind(String identifier, Object value)",
    "source_code": "\t\tpublic void bind(String identifier, Object value) {\n\t\t\tthis.statement.bind(identifier, value);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bind(index,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 555
    },
    "return": "void",
    "signature": "public void bind(int index, Object value)",
    "source_code": "\t\tpublic void bind(int index, Object value) {\n\t\t\tthis.statement.bind(index, value);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bind(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "DefaultGenericExecuteSpec",
    "signature": "public DefaultGenericExecuteSpec bind(String name, Object value)",
    "source_code": "\t\tpublic DefaultGenericExecuteSpec bind(String name, Object value) {\n\t\t\tassertNotPreparedOperation();\n\n\t\t\tAssert.hasText(name, \"Parameter name must not be null or empty\");\n\t\t\tAssert.notNull(value, () -> String.format(\n\t\t\t\t\t\"Value for parameter %s must not be null. Use bindNull(\u2026) instead.\", name));\n\n\t\t\tMap<String, Parameter> byName = new LinkedHashMap<>(this.byName);\n\t\t\tif (value instanceof Parameter p) {\n\t\t\t\tbyName.put(name, p);\n\t\t\t}\n\t\t\telse if (value instanceof org.springframework.r2dbc.core.Parameter p) {\n\t\t\t\tbyName.put(name, p.hasValue() ? Parameters.in(p.getValue()) : Parameters.in(p.getType()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbyName.put(name, Parameters.in(value));\n\t\t\t}\n\n\t\t\treturn new DefaultGenericExecuteSpec(this.byIndex, byName, this.sqlSupplier, this.filterFunction);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bind(target,identifier,parameter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "identifier",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 517
    },
    "return": "void",
    "signature": "public void bind(BindTarget target, String identifier, Parameter parameter)",
    "source_code": "\t\tpublic void bind(BindTarget target, String identifier, Parameter parameter) {\n\t\t\tList<BindMarker> bindMarkers = getBindMarkers(identifier);\n\t\t\tif (bindMarkers == null) {\n\t\t\t\ttarget.bind(identifier, parameter);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (parameter.getValue() instanceof Collection) {\n\t\t\t\tCollection<Object> collection = (Collection<Object>) parameter.getValue();\n\t\t\t\tIterator<Object> iterator = collection.iterator();\n\t\t\t\tIterator<BindMarker> markers = bindMarkers.iterator();\n\t\t\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tObject valueToBind = iterator.next();\n\t\t\t\t\tif (valueToBind instanceof Object[] objects) {\n\t\t\t\t\t\tfor (Object object : objects) {\n\t\t\t\t\t\t\tbind(target, markers, object);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbind(target, markers, valueToBind);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (BindMarker bindMarker : bindMarkers) {\n\t\t\t\t\tbindMarker.bind(target, parameter);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindNull(identifier,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "identifier",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 560
    },
    "return": "void",
    "signature": "public void bindNull(String identifier, Class<?> type)",
    "source_code": "\t\tpublic void bindNull(String identifier, Class<?> type) {\n\t\t\tthis.statement.bindNull(identifier, type);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindNull(index,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 565
    },
    "return": "void",
    "signature": "public void bindNull(int index, Class<?> type)",
    "source_code": "\t\tpublic void bindNull(int index, Class<?> type) {\n\t\t\tthis.statement.bindNull(index, type);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindNull(name,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "DefaultGenericExecuteSpec",
    "signature": "public DefaultGenericExecuteSpec bindNull(String name, Class<?> type)",
    "source_code": "\t\tpublic DefaultGenericExecuteSpec bindNull(String name, Class<?> type) {\n\t\t\tassertNotPreparedOperation();\n\t\t\tAssert.hasText(name, \"Parameter name must not be null or empty\");\n\n\t\t\tMap<String, Parameter> byName = new LinkedHashMap<>(this.byName);\n\t\t\tbyName.put(name, Parameters.in(type));\n\n\t\t\treturn new DefaultGenericExecuteSpec(this.byIndex, byName, this.sqlSupplier, this.filterFunction);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindNull(target,identifier,parameter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "identifier",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 553
    },
    "return": "void",
    "signature": "public void bindNull(BindTarget target, String identifier, Parameter parameter)",
    "source_code": "\t\tpublic void bindNull(BindTarget target, String identifier, Parameter parameter) {\n\t\t\tList<BindMarker> bindMarkers = getBindMarkers(identifier);\n\t\t\tif (bindMarkers == null) {\n\t\t\t\ttarget.bind(identifier, parameter);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (BindMarker bindMarker : bindMarkers) {\n\t\t\t\tbindMarker.bind(target, parameter);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#flatMap(Function<Result,mappingFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Result",
      "mappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "Flux<R>",
    "signature": "public Flux<R> flatMap(Function<Result, Publisher<R>> mappingFunction)",
    "source_code": "\t\tpublic <R> Flux<R> flatMap(Function<Result, Publisher<R>> mappingFunction) {\n\t\t\tAssert.notNull(mappingFunction, \"Mapping function must not be null\");\n\t\t\treturn flatMap(this.sqlSupplier, mappingFunction);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#fromOrEmpty(value,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link Parameter} from {@code value} and {@code type}.\n\t * @param value the parameter value (can be {@code null})\n\t * @param type the parameter type\n\t * @return the {@link Parameter} value for {@code value}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "Parameter",
    "signature": "public Parameter fromOrEmpty(@Nullable Object value, Class<?> type)",
    "source_code": "\tpublic static Parameter fromOrEmpty(@Nullable Object value, Class<?> type) {\n\t\treturn (value == null ? empty(type) : new Parameter(value, ClassUtils.getUserClass(value)));\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#inConnection(Function<Connection,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Connection",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> inConnection(Function<Connection, Mono<T>> action)",
    "source_code": "\tpublic <T> Mono<T> inConnection(Function<Connection, Mono<T>> action) throws DataAccessException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\tMono<ConnectionCloseHolder> connectionMono = getConnection().map(\n\t\t\t\tconnection -> new ConnectionCloseHolder(connection, this::closeConnection));\n\n\t\treturn Mono.usingWhen(connectionMono, connectionCloseHolder -> {\n\t\t\t// Create close-suppressing Connection proxy\n\t\t\tConnection connectionToUse = createConnectionProxy(connectionCloseHolder.connection);\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn action.apply(connectionToUse);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (R2dbcException ex) {\n\t\t\t\t\t\tString sql = getSql(action);\n\t\t\t\t\t\treturn Mono.error(ConnectionFactoryUtils.convertR2dbcException(\"doInConnection\", sql, ex));\n\t\t\t\t\t}\n\t\t\t\t}, ConnectionCloseHolder::close, (it, err) -> it.close(),\n\t\t\t\tConnectionCloseHolder::close)\n\t\t\t\t.onErrorMap(R2dbcException.class,\n\t\t\t\t\t\tex -> ConnectionFactoryUtils.convertR2dbcException(\"execute\", getSql(action), ex));\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#inConnectionMany(Function<Connection,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Connection",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> inConnectionMany(Function<Connection, Flux<T>> action)",
    "source_code": "\tpublic <T> Flux<T> inConnectionMany(Function<Connection, Flux<T>> action) throws DataAccessException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\tMono<ConnectionCloseHolder> connectionMono = getConnection().map(\n\t\t\t\tconnection -> new ConnectionCloseHolder(connection, this::closeConnection));\n\n\t\treturn Flux.usingWhen(connectionMono, connectionCloseHolder -> {\n\t\t\t// Create close-suppressing Connection proxy, also preparing returned Statements.\n\t\t\tConnection connectionToUse = createConnectionProxy(connectionCloseHolder.connection);\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn action.apply(connectionToUse);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (R2dbcException ex) {\n\t\t\t\t\t\tString sql = getSql(action);\n\t\t\t\t\t\treturn Flux.error(ConnectionFactoryUtils.convertR2dbcException(\"doInConnectionMany\", sql, ex));\n\t\t\t\t\t}\n\t\t\t\t}, ConnectionCloseHolder::close, (it, err) -> it.close(),\n\t\t\t\tConnectionCloseHolder::close)\n\t\t\t\t.onErrorMap(R2dbcException.class,\n\t\t\t\t\t\tex -> ConnectionFactoryUtils.convertR2dbcException(\"executeMany\", getSql(action), ex));\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 487
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\treturn proxy == args[0];\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of PersistenceManager proxy.\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\tcase \"unwrap\":\n\t\t\t\t\treturn this.target;\n\t\t\t\tcase \"close\":\n\t\t\t\t\t// Handle close method: suppress, not valid.\n\t\t\t\t\treturn Mono.error(\n\t\t\t\t\t\t\tnew UnsupportedOperationException(\"Close is not supported!\"));\n\t\t\t}\n\n\t\t\t// Invoke method on target Connection.\n\t\t\ttry {\n\t\t\t\treturn method.invoke(this.target, args);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#map(BiFunction<Row,RowMetadata,mappingFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiFunction<Row",
      "RowMetadata",
      "mappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "FetchSpec<R>",
    "signature": "public FetchSpec<R> map(BiFunction<Row, RowMetadata, R> mappingFunction)",
    "source_code": "\t\tpublic <R> FetchSpec<R> map(BiFunction<Row, RowMetadata, R> mappingFunction) {\n\t\t\tAssert.notNull(mappingFunction, \"Mapping function must not be null\");\n\t\t\treturn execute(this.sqlSupplier, result -> result.map(mappingFunction));\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#map(Readable,mappingFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Readable",
      "mappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "FetchSpec<R>",
    "signature": "public FetchSpec<R> map(Function<? super Readable, R> mappingFunction)",
    "source_code": "\t\tpublic <R> FetchSpec<R> map(Function<? super Readable, R> mappingFunction) {\n\t\t\tAssert.notNull(mappingFunction, \"Mapping function must not be null\");\n\t\t\treturn execute(this.sqlSupplier, result -> result.map(mappingFunction));\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#substituteNamedParameters(parsedSql,bindMarkersFactory,paramSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the SQL statement and locate any placeholders or named parameters. Named\n\t * parameters are substituted for a R2DBC placeholder, and any select list is expanded\n\t * to the required number of placeholders. Select lists may contain an array of objects,\n\t * and in that case the placeholders will be grouped and enclosed with parentheses.\n\t * This allows for the use of \"expression lists\" in the SQL statement like:\n\t * {@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}\n\t * <p>The parameter values passed in are used to determine the number of placeholders to\n\t * be used for a select list. Select lists should be limited to 100 or fewer elements.\n\t * A larger number of elements is not guaranteed to be supported by the database and\n\t * is strictly vendor-dependent.\n\t * @param parsedSql the parsed representation of the SQL statement\n\t * @param bindMarkersFactory the bind marker factory.\n\t * @param paramSource the source for named parameters\n\t * @return the expanded query that accepts bind parameters and allows for execution\n\t * without further translation\n\t * @see #parseSqlStatement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parsedSql",
      "bindMarkersFactory",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "PreparedOperation<String>",
    "signature": "public PreparedOperation<String> substituteNamedParameters(ParsedSql parsedSql,\n\t\t\tBindMarkersFactory bindMarkersFactory, BindParameterSource paramSource)",
    "source_code": "\tpublic static PreparedOperation<String> substituteNamedParameters(ParsedSql parsedSql,\n\t\t\tBindMarkersFactory bindMarkersFactory, BindParameterSource paramSource) {\n\n\t\tNamedParameters markerHolder = new NamedParameters(bindMarkersFactory);\n\t\tString originalSql = parsedSql.getOriginalSql();\n\t\tList<String> paramNames = parsedSql.getParameterNames();\n\t\tif (paramNames.isEmpty()) {\n\t\t\treturn new ExpandedQuery(originalSql, markerHolder, paramSource);\n\t\t}\n\n\t\tStringBuilder actualSql = new StringBuilder(originalSql.length());\n\t\tint lastIndex = 0;\n\t\tfor (int i = 0; i < paramNames.size(); i++) {\n\t\t\tString paramName = paramNames.get(i);\n\t\t\tint[] indexes = parsedSql.getParameterIndexes(i);\n\t\t\tint startIndex = indexes[0];\n\t\t\tint endIndex = indexes[1];\n\t\t\tactualSql.append(originalSql, lastIndex, startIndex);\n\t\t\tNamedParameters.NamedParameter marker = markerHolder.getOrCreate(paramName);\n\t\t\tif (paramSource.hasValue(paramName)) {\n\t\t\t\tParameter parameter = paramSource.getValue(paramName);\n\t\t\t\tif (parameter.getValue() instanceof Collection<?> c) {\n\t\t\t\t\tIterator<?> entryIter = c.iterator();\n\t\t\t\t\tint k = 0;\n\t\t\t\t\tint counter = 0;\n\t\t\t\t\twhile (entryIter.hasNext()) {\n\t\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\t\tactualSql.append(\", \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tObject entryItem = entryIter.next();\n\t\t\t\t\t\tif (entryItem instanceof Object[] expressionList) {\n\t\t\t\t\t\t\tactualSql.append('(');\n\t\t\t\t\t\t\tfor (int m = 0; m < expressionList.length; m++) {\n\t\t\t\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\t\t\t\tactualSql.append(\", \");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tactualSql.append(marker.getPlaceholder(counter));\n\t\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tactualSql.append(')');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tactualSql.append(marker.getPlaceholder(counter));\n\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tactualSql.append(marker.getPlaceholder());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tactualSql.append(marker.getPlaceholder());\n\t\t\t}\n\t\t\tlastIndex = endIndex;\n\t\t}\n\t\tactualSql.append(originalSql, lastIndex, originalSql.length());\n\n\t\treturn new ExpandedQuery(actualSql.toString(), markerHolder, paramSource);\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#substituteNamedParameters(sql,bindMarkersFactory,paramSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the SQL statement and locate any placeholders or named parameters.\n\t * Named parameters are substituted for a native placeholder and any\n\t * select list is expanded to the required number of placeholders.\n\t * @param sql the SQL statement\n\t * @param bindMarkersFactory the bind marker factory\n\t * @param paramSource the source for named parameters\n\t * @return the expanded query that accepts bind parameters and allows for execution\n\t * without further translation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "bindMarkersFactory",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "PreparedOperation<String>",
    "signature": "public PreparedOperation<String> substituteNamedParameters(String sql,\n\t\t\tBindMarkersFactory bindMarkersFactory, BindParameterSource paramSource)",
    "source_code": "\tpublic static PreparedOperation<String> substituteNamedParameters(String sql,\n\t\t\tBindMarkersFactory bindMarkersFactory, BindParameterSource paramSource) {\n\n\t\tParsedSql parsedSql = parseSqlStatement(sql);\n\t\treturn substituteNamedParameters(parsedSql, bindMarkersFactory, paramSource);\n\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#createExecutor(poolSize,threadFactory,rejectedExecutionHandler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link ScheduledExecutorService} instance.\n\t * <p>The default implementation creates a {@link ScheduledThreadPoolExecutor}.\n\t * Can be overridden in subclasses to provide custom {@link ScheduledExecutorService} instances.\n\t * @param poolSize the specified pool size\n\t * @param threadFactory the ThreadFactory to use\n\t * @param rejectedExecutionHandler the RejectedExecutionHandler to use\n\t * @return a new ScheduledExecutorService instance\n\t * @see #afterPropertiesSet()\n\t * @see java.util.concurrent.ScheduledThreadPoolExecutor\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "poolSize",
      "threadFactory",
      "rejectedExecutionHandler"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "ScheduledExecutorService",
    "signature": "protected ScheduledExecutorService createExecutor(int poolSize, ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler)",
    "source_code": "\tprotected ScheduledExecutorService createExecutor(\n\t\t\tint poolSize, ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler) {\n\n\t\treturn new ScheduledThreadPoolExecutor(poolSize, threadFactory, rejectedExecutionHandler);\n\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#execute(task,startTimeout)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "startTimeout"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "void",
    "signature": "public void execute(Runnable task, long startTimeout)",
    "source_code": "\tpublic void execute(Runnable task, long startTimeout) {\n\t\texecute(task);\n\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#initializeExecutor(threadFactory,rejectedExecutionHandler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "threadFactory",
      "rejectedExecutionHandler"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "ExecutorService",
    "signature": "protected ExecutorService initializeExecutor(ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler)",
    "source_code": "\tprotected ExecutorService initializeExecutor(\n\t\t\tThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler) {\n\n\t\tthis.scheduledExecutor = createExecutor(this.poolSize, threadFactory, rejectedExecutionHandler);\n\n\t\tif (this.scheduledExecutor instanceof ScheduledThreadPoolExecutor scheduledPoolExecutor) {\n\t\t\tif (this.removeOnCancelPolicy) {\n\t\t\t\tscheduledPoolExecutor.setRemoveOnCancelPolicy(true);\n\t\t\t}\n\t\t\tif (this.continueExistingPeriodicTasksAfterShutdownPolicy) {\n\t\t\t\tscheduledPoolExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(true);\n\t\t\t}\n\t\t\tif (!this.executeExistingDelayedTasksAfterShutdownPolicy) {\n\t\t\t\tscheduledPoolExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n\t\t\t}\n\t\t}\n\n\t\treturn this.scheduledExecutor;\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#addCronTask(task,expression)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a {@link Runnable} task to be triggered per the given cron {@code expression}.\n\t * <p>As of Spring Framework 5.2, this method will not register the task if the\n\t * {@code expression} is equal to {@link #CRON_DISABLED}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "expression"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "void",
    "signature": "public void addCronTask(Runnable task, String expression)",
    "source_code": "\tpublic void addCronTask(Runnable task, String expression) {\n\t\tif (!CRON_DISABLED.equals(expression)) {\n\t\t\taddCronTask(new CronTask(task, expression));\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#addFixedDelayTask(task,delay)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a Runnable task to be triggered with the given fixed delay.\n\t * @since 6.0\n\t * @see TaskScheduler#scheduleWithFixedDelay(Runnable, Duration)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "delay"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "void",
    "signature": "public void addFixedDelayTask(Runnable task, Duration delay)",
    "source_code": "\tpublic void addFixedDelayTask(Runnable task, Duration delay) {\n\t\taddFixedDelayTask(new IntervalTask(task, delay));\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#addFixedRateTask(task,interval)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a {@code Runnable} task to be triggered at the given fixed-rate interval.\n\t * @since 6.0\n\t * @see TaskScheduler#scheduleAtFixedRate(Runnable, Duration)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "interval"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "void",
    "signature": "public void addFixedRateTask(Runnable task, Duration interval)",
    "source_code": "\tpublic void addFixedRateTask(Runnable task, Duration interval) {\n\t\taddFixedRateTask(new IntervalTask(task, interval));\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#addTriggerTask(task,trigger)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a Runnable task to be triggered per the given {@link Trigger}.\n\t * @see TaskScheduler#scheduleAtFixedRate(Runnable, Duration)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "trigger"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "void",
    "signature": "public void addTriggerTask(Runnable task, Trigger trigger)",
    "source_code": "\tpublic void addTriggerTask(Runnable task, Trigger trigger) {\n\t\taddTriggerTask(new TriggerTask(task, trigger));\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#setCronTasks(Map<Runnable,cronTasks)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify triggered tasks as a Map of Runnables (the tasks) and cron expressions.\n\t * @see CronTrigger\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Runnable",
      "cronTasks"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "public void setCronTasks(Map<Runnable, String> cronTasks)",
    "source_code": "\tpublic void setCronTasks(Map<Runnable, String> cronTasks) {\n\t\tthis.cronTasks = new ArrayList<>();\n\t\tcronTasks.forEach(this::addCronTask);\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#setFixedDelayTasks(Map<Runnable,fixedDelayTasks)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify triggered tasks as a Map of Runnables (the tasks) and fixed-delay values.\n\t * @see TaskScheduler#scheduleWithFixedDelay(Runnable, Duration)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Runnable",
      "fixedDelayTasks"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "void",
    "signature": "public void setFixedDelayTasks(Map<Runnable, Long> fixedDelayTasks)",
    "source_code": "\tpublic void setFixedDelayTasks(Map<Runnable, Long> fixedDelayTasks) {\n\t\tthis.fixedDelayTasks = new ArrayList<>();\n\t\tfixedDelayTasks.forEach((task, delay) -> addFixedDelayTask(task, Duration.ofMillis(delay)));\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#setFixedRateTasks(Map<Runnable,fixedRateTasks)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify triggered tasks as a Map of Runnables (the tasks) and fixed-rate values.\n\t * @see TaskScheduler#scheduleAtFixedRate(Runnable, Duration)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Runnable",
      "fixedRateTasks"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "void",
    "signature": "public void setFixedRateTasks(Map<Runnable, Long> fixedRateTasks)",
    "source_code": "\tpublic void setFixedRateTasks(Map<Runnable, Long> fixedRateTasks) {\n\t\tthis.fixedRateTasks = new ArrayList<>();\n\t\tfixedRateTasks.forEach((task, interval) -> addFixedRateTask(task, Duration.ofMillis(interval)));\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#setTriggerTasks(Map<Runnable,triggerTasks)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify triggered tasks as a Map of Runnables (the tasks) and Trigger objects\n\t * (typically custom implementations of the {@link Trigger} interface).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Runnable",
      "triggerTasks"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void setTriggerTasks(Map<Runnable, Trigger> triggerTasks)",
    "source_code": "\tpublic void setTriggerTasks(Map<Runnable, Trigger> triggerTasks) {\n\t\tthis.triggerTasks = new ArrayList<>();\n\t\ttriggerTasks.forEach((task, trigger) -> addTriggerTask(new TriggerTask(task, trigger)));\n\t}"
  },
  "org.springframework.scheduling.quartz.<unknown>#createScheduler(schedulerFactory,schedulerName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the Scheduler instance for the given factory and scheduler name.\n\t * Called by {@link #afterPropertiesSet}.\n\t * <p>The default implementation invokes SchedulerFactory's {@code getScheduler}\n\t * method. Can be overridden for custom Scheduler creation.\n\t * @param schedulerFactory the factory to create the Scheduler with\n\t * @param schedulerName the name of the scheduler to create\n\t * @return the Scheduler instance\n\t * @throws SchedulerException if thrown by Quartz methods\n\t * @see #afterPropertiesSet\n\t * @see org.quartz.SchedulerFactory#getScheduler\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "schedulerFactory",
      "schedulerName"
    ],
    "position": {
      "column": 1,
      "line": 664
    },
    "return": "Scheduler",
    "signature": "protected Scheduler createScheduler(SchedulerFactory schedulerFactory, @Nullable String schedulerName)",
    "source_code": "\tprotected Scheduler createScheduler(SchedulerFactory schedulerFactory, @Nullable String schedulerName)\n\t\t\tthrows SchedulerException {\n\n\t\t// Override thread context ClassLoader to work around naive Quartz ClassLoadHelper loading.\n\t\tThread currentThread = Thread.currentThread();\n\t\tClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\n\t\tboolean overrideClassLoader = (this.resourceLoader != null &&\n\t\t\t\tthis.resourceLoader.getClassLoader() != threadContextClassLoader);\n\t\tif (overrideClassLoader) {\n\t\t\tcurrentThread.setContextClassLoader(this.resourceLoader.getClassLoader());\n\t\t}\n\t\ttry {\n\t\t\tSchedulerRepository repository = SchedulerRepository.getInstance();\n\t\t\tsynchronized (repository) {\n\t\t\t\tScheduler existingScheduler = (schedulerName != null ? repository.lookup(schedulerName) : null);\n\t\t\t\tScheduler newScheduler = schedulerFactory.getScheduler();\n\t\t\t\tif (newScheduler == existingScheduler) {\n\t\t\t\t\tthrow new IllegalStateException(\"Active Scheduler of name '\" + schedulerName + \"' already registered \" +\n\t\t\t\t\t\t\t\"in Quartz SchedulerRepository. Cannot create a new Spring-managed Scheduler of the same name!\");\n\t\t\t\t}\n\t\t\t\tif (!this.exposeSchedulerInRepository) {\n\t\t\t\t\t// Need to remove it in this case, since Quartz shares the Scheduler instance by default!\n\t\t\t\t\tSchedulerRepository.getInstance().remove(newScheduler.getSchedulerName());\n\t\t\t\t}\n\t\t\t\treturn newScheduler;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (overrideClassLoader) {\n\t\t\t\t// Reset original thread context ClassLoader.\n\t\t\t\tcurrentThread.setContextClassLoader(threadContextClassLoader);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.quartz.<unknown>#setSchedulerContextAsMap(Map<String,schedulerContextAsMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register objects in the Scheduler context via a given Map.\n\t * These objects will be available to any Job that runs in this Scheduler.\n\t * <p>Note: When using persistent Jobs whose JobDetail will be kept in the\n\t * database, do not put Spring-managed beans or an ApplicationContext\n\t * reference into the JobDataMap but rather into the SchedulerContext.\n\t * @param schedulerContextAsMap a Map with String keys and any objects as\n\t * values (for example Spring-managed beans)\n\t * @see JobDetailFactoryBean#setJobDataAsMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "schedulerContextAsMap"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "void",
    "signature": "public void setSchedulerContextAsMap(Map<String, ?> schedulerContextAsMap)",
    "source_code": "\tpublic void setSchedulerContextAsMap(Map<String, ?> schedulerContextAsMap) {\n\t\tthis.schedulerContextMap = schedulerContextAsMap;\n\t}"
  },
  "org.springframework.scheduling.quartz.<unknown>#startScheduler(scheduler,startupDelay)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Start the Quartz Scheduler, respecting the \"startupDelay\" setting.\n\t * @param scheduler the Scheduler to start\n\t * @param startupDelay the number of seconds to wait before starting\n\t * the Scheduler asynchronously\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "scheduler",
      "startupDelay"
    ],
    "position": {
      "column": 1,
      "line": 727
    },
    "return": "void",
    "signature": "protected void startScheduler(final Scheduler scheduler, final int startupDelay)",
    "source_code": "\tprotected void startScheduler(final Scheduler scheduler, final int startupDelay) throws SchedulerException {\n\t\tif (startupDelay <= 0) {\n\t\t\tlogger.info(\"Starting Quartz Scheduler now\");\n\t\t\tscheduler.start();\n\t\t}\n\t\telse {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"Will start Quartz Scheduler [\" + scheduler.getSchedulerName() +\n\t\t\t\t\t\t\"] in \" + startupDelay + \" seconds\");\n\t\t\t}\n\t\t\t// Not using the Quartz startDelayed method since we explicitly want a daemon\n\t\t\t// thread here, not keeping the JVM alive in case of all other threads ending.\n\t\t\tThread schedulerThread = new Thread() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tTimeUnit.SECONDS.sleep(startupDelay);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InterruptedException ex) {\n\t\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t\t\t// simply proceed\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\tlogger.info(\"Starting Quartz Scheduler now, after delay of \" + startupDelay + \" seconds\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tscheduler.start();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SchedulerException ex) {\n\t\t\t\t\t\tthrow new SchedulingException(\"Could not start Quartz Scheduler after delay\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tschedulerThread.setName(\"Quartz Scheduler [\" + scheduler.getSchedulerName() + \"]\");\n\t\t\tschedulerThread.setDaemon(true);\n\t\t\tschedulerThread.start();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.support.<unknown>#compose(fields,type,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Composes the given fields into a {@link CronField}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fields",
      "type",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "CronField",
    "signature": "public CronField compose(CronField[] fields, Type type, String value)",
    "source_code": "\tpublic static CronField compose(CronField[] fields, Type type, String value) {\n\t\tAssert.notEmpty(fields, \"Fields must not be empty\");\n\t\tAssert.hasLength(value, \"Value must not be empty\");\n\n\t\tif (fields.length == 1) {\n\t\t\treturn fields[0];\n\t\t}\n\t\telse {\n\t\t\treturn new CompositeCronField(type, fields, value);\n\t\t}\n\t}"
  },
  "org.springframework.scripting.bsh.<unknown>#createBshObject(scriptSource,scriptInterfaces)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new BeanShell-scripted object from the given script source,\n\t * using the default ClassLoader.\n\t * <p>The script may either be a simple script that needs a corresponding proxy\n\t * generated (implementing the specified interfaces), or declare a full class\n\t * or return an actual instance of the scripted object (in which case the\n\t * specified interfaces, if any, need to be implemented by that class/instance).\n\t * @param scriptSource the script source text\n\t * @param scriptInterfaces the interfaces that the scripted Java object is\n\t * supposed to implement (may be {@code null} or empty if the script itself\n\t * declares a full class or returns an actual instance of the scripted object)\n\t * @return the scripted Java object\n\t * @throws EvalError in case of BeanShell parsing failure\n\t * @see #createBshObject(String, Class[], ClassLoader)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource",
      "scriptInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "Object",
    "signature": "public Object createBshObject(String scriptSource, @Nullable Class<?>... scriptInterfaces)",
    "source_code": "\tpublic static Object createBshObject(String scriptSource, @Nullable Class<?>... scriptInterfaces) throws EvalError {\n\t\treturn createBshObject(scriptSource, scriptInterfaces, ClassUtils.getDefaultClassLoader());\n\t}"
  },
  "org.springframework.scripting.bsh.<unknown>#createBshObject(scriptSource,scriptInterfaces,classLoader)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new BeanShell-scripted object from the given script source.\n\t * <p>The script may either be a simple script that needs a corresponding proxy\n\t * generated (implementing the specified interfaces), or declare a full class\n\t * or return an actual instance of the scripted object (in which case the\n\t * specified interfaces, if any, need to be implemented by that class/instance).\n\t * @param scriptSource the script source text\n\t * @param scriptInterfaces the interfaces that the scripted Java object is\n\t * supposed to implement (may be {@code null} or empty if the script itself\n\t * declares a full class or returns an actual instance of the scripted object)\n\t * @param classLoader the ClassLoader to use for evaluating the script\n\t * @return the scripted Java object\n\t * @throws EvalError in case of BeanShell parsing failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource",
      "scriptInterfaces",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "Object",
    "signature": "public Object createBshObject(String scriptSource, @Nullable Class<?>[] scriptInterfaces, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static Object createBshObject(String scriptSource, @Nullable Class<?>[] scriptInterfaces, @Nullable ClassLoader classLoader)\n\t\t\tthrows EvalError {\n\n\t\tObject result = evaluateBshScript(scriptSource, scriptInterfaces, classLoader);\n\t\tif (result instanceof Class<?> clazz) {\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(clazz).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalStateException(\"Could not instantiate script class: \" + clazz.getName(), ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn result;\n\t\t}\n\t}"
  },
  "org.springframework.scripting.bsh.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tif (ReflectionUtils.isEqualsMethod(method)) {\n\t\t\t\treturn (isProxyForSameBshObject(args[0]));\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isHashCodeMethod(method)) {\n\t\t\t\treturn this.xt.hashCode();\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isToStringMethod(method)) {\n\t\t\t\treturn \"BeanShell object [\" + this.xt + \"]\";\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tObject result = this.xt.invokeMethod(method.getName(), args);\n\t\t\t\tif (result == Primitive.NULL || result == Primitive.VOID) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (result instanceof Primitive) {\n\t\t\t\t\treturn ((Primitive) result).getValue();\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcatch (EvalError ex) {\n\t\t\t\tthrow new BshExecutionException(ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.scripting.support.<unknown>#adaptToInterfaces(script,scriptSource,actualInterfaces)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "script",
      "scriptSource",
      "actualInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "Object",
    "signature": "protected Object adaptToInterfaces(@Nullable Object script, ScriptSource scriptSource, Class<?>... actualInterfaces)",
    "source_code": "\tprotected Object adaptToInterfaces(\n\t\t\t@Nullable Object script, ScriptSource scriptSource, Class<?>... actualInterfaces) {\n\n\t\tClass<?> adaptedIfc;\n\t\tif (actualInterfaces.length == 1) {\n\t\t\tadaptedIfc = actualInterfaces[0];\n\t\t}\n\t\telse {\n\t\t\tadaptedIfc = ClassUtils.createCompositeInterface(actualInterfaces, this.beanClassLoader);\n\t\t}\n\n\t\tif (adaptedIfc != null) {\n\t\t\tScriptEngine scriptEngine = this.scriptEngine;\n\t\t\tif (!(scriptEngine instanceof Invocable invocable)) {\n\t\t\t\tthrow new ScriptCompilationException(scriptSource,\n\t\t\t\t\t\t\"ScriptEngine must implement Invocable in order to adapt it to an interface: \" + scriptEngine);\n\t\t\t}\n\t\t\tif (script != null) {\n\t\t\t\tscript = invocable.getInterface(script, adaptedIfc);\n\t\t\t}\n\t\t\tif (script == null) {\n\t\t\t\tscript = invocable.getInterface(adaptedIfc);\n\t\t\t\tif (script == null) {\n\t\t\t\t\tthrow new ScriptCompilationException(scriptSource,\n\t\t\t\t\t\t\t\"Could not adapt script to interface [\" + adaptedIfc.getName() + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn script;\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#getScriptedObject(scriptSource,actualInterfaces)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Load and parse the script via JSR-223's ScriptEngine.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource",
      "actualInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "Object",
    "signature": "public Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)",
    "source_code": "\tpublic Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)\n\t\t\tthrows IOException, ScriptCompilationException {\n\n\t\tObject script = evaluateScript(scriptSource);\n\n\t\tif (!ObjectUtils.isEmpty(actualInterfaces)) {\n\t\t\tboolean adaptationRequired = false;\n\t\t\tfor (Class<?> requestedIfc : actualInterfaces) {\n\t\t\t\tif (script instanceof Class ? !requestedIfc.isAssignableFrom((Class<?>) script) :\n\t\t\t\t\t\t!requestedIfc.isInstance(script)) {\n\t\t\t\t\tadaptationRequired = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (adaptationRequired) {\n\t\t\t\tscript = adaptToInterfaces(script, scriptSource, actualInterfaces);\n\t\t\t}\n\t\t}\n\n\t\tif (script instanceof Class<?> scriptClass) {\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(scriptClass).newInstance();\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\t\"No default constructor on script class: \" + scriptClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (InstantiationException ex) {\n\t\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\tscriptSource, \"Unable to instantiate script class: \" + scriptClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\tscriptSource, \"Could not access script constructor: \" + scriptClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\t\"Failed to invoke script constructor: \" + scriptClass.getName(), ex.getTargetException());\n\t\t\t}\n\t\t}\n\n\t\treturn script;\n\t}"
  },
  "org.springframework.test.context.<unknown>#afterTestExecution(testInstance,testMethod,exception)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for post-processing a test <em>immediately after</em> execution of\n\t * the {@linkplain java.lang.reflect.Method test method} in the supplied\n\t * {@linkplain TestContext test context} &mdash; for example, for timing\n\t * or logging purposes.\n\t * <p>This method <strong>must</strong> be called before framework-specific\n\t * <em>after</em> lifecycle callbacks &mdash; for example, methods annotated\n\t * with JUnit Jupiter's {@link org.junit.jupiter.api.AfterEach @AfterEach}.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance}, {@code testMethod}, and {@code exception}.\n\t * <p>Each registered {@link TestExecutionListener} will be given a chance\n\t * to perform its post-processing. If a listener throws an exception, the\n\t * remaining registered listeners will still be called. After all listeners\n\t * have executed, the first caught exception will be rethrown with any\n\t * subsequent exceptions {@linkplain Throwable#addSuppressed suppressed} in\n\t * the first exception.\n\t * <p>Note that registered listeners will be executed in the opposite\n\t * order in which they were registered.\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which has just been executed on the\n\t * test instance\n\t * @param exception the exception that was thrown during execution of the\n\t * test method or by a TestExecutionListener, or {@code null} if none\n\t * was thrown\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @since 5.0\n\t * @see #beforeTestMethod\n\t * @see #afterTestMethod\n\t * @see #beforeTestExecution\n\t * @see #getTestExecutionListeners()\n\t * @see Throwable#addSuppressed(Throwable)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 367
    },
    "return": "void",
    "signature": "public void afterTestExecution(Object testInstance, Method testMethod, @Nullable Throwable exception)",
    "source_code": "\tpublic void afterTestExecution(Object testInstance, Method testMethod, @Nullable Throwable exception)\n\t\t\tthrows Exception {\n\n\t\tString callbackName = \"afterTestExecution\";\n\t\tprepareForAfterCallback(callbackName, testInstance, testMethod, exception);\n\t\tThrowable afterTestExecutionException = null;\n\n\t\t// Traverse the TestExecutionListeners in reverse order to ensure proper\n\t\t// \"wrapper\"-style execution of listeners.\n\t\tfor (TestExecutionListener testExecutionListener : getReversedTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.afterTestExecution(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t\tif (afterTestExecutionException == null) {\n\t\t\t\t\tafterTestExecutionException = ex;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tafterTestExecutionException.addSuppressed(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (afterTestExecutionException != null) {\n\t\t\tReflectionUtils.rethrowException(afterTestExecutionException);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.<unknown>#afterTestMethod(testInstance,testMethod,exception)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for post-processing a test <em>after</em> execution of <em>after</em>\n\t * lifecycle callbacks of the underlying test framework &mdash; for example,\n\t * tearing down test fixtures, ending a transaction, etc.\n\t * <p>This method <strong>must</strong> be called immediately after\n\t * framework-specific <em>after</em> lifecycle callbacks &mdash; for example, methods\n\t * annotated with JUnit Jupiter's {@link org.junit.jupiter.api.AfterEach @AfterEach}.\n\t * For historical reasons, this method is named {@code afterTestMethod}. Since\n\t * the introduction of {@link #afterTestExecution}, a more suitable name for\n\t * this method might be something like {@code afterTestTearDown} or\n\t * {@code afterEach}; however, it is unfortunately impossible to rename\n\t * this method due to backward compatibility concerns.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance}, {@code testMethod}, and {@code exception}.\n\t * <p>Each registered {@link TestExecutionListener} will be given a chance\n\t * to perform its post-processing. If a listener throws an exception, the\n\t * remaining registered listeners will still be called. After all listeners\n\t * have executed, the first caught exception will be rethrown with any\n\t * subsequent exceptions {@linkplain Throwable#addSuppressed suppressed} in\n\t * the first exception.\n\t * <p>Note that registered listeners will be executed in the opposite\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which has just been executed on the\n\t * test instance\n\t * @param exception the exception that was thrown during execution of the test\n\t * method or by a TestExecutionListener, or {@code null} if none was thrown\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @see #beforeTestMethod\n\t * @see #beforeTestExecution\n\t * @see #afterTestExecution\n\t * @see #getTestExecutionListeners()\n\t * @see Throwable#addSuppressed(Throwable)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "void",
    "signature": "public void afterTestMethod(Object testInstance, Method testMethod, @Nullable Throwable exception)",
    "source_code": "\tpublic void afterTestMethod(Object testInstance, Method testMethod, @Nullable Throwable exception)\n\t\t\tthrows Exception {\n\n\t\tString callbackName = \"afterTestMethod\";\n\t\tprepareForAfterCallback(callbackName, testInstance, testMethod, exception);\n\t\tThrowable afterTestMethodException = null;\n\n\t\t// Traverse the TestExecutionListeners in reverse order to ensure proper\n\t\t// \"wrapper\"-style execution of listeners.\n\t\tfor (TestExecutionListener testExecutionListener : getReversedTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.afterTestMethod(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t\tif (afterTestMethodException == null) {\n\t\t\t\t\tafterTestMethodException = ex;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tafterTestMethodException.addSuppressed(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (afterTestMethodException != null) {\n\t\t\tReflectionUtils.rethrowException(afterTestMethodException);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.<unknown>#beforeTestExecution(testInstance,testMethod)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for pre-processing a test <em>immediately before</em> execution of\n\t * the {@linkplain java.lang.reflect.Method test method} in the supplied\n\t * {@linkplain TestContext test context} &mdash; for example, for timing\n\t * or logging purposes.\n\t * <p>This method <strong>must</strong> be called after framework-specific\n\t * <em>before</em> lifecycle callbacks &mdash; for example, methods annotated\n\t * with JUnit Jupiter's {@link org.junit.jupiter.api.BeforeEach @BeforeEach}.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance} and {@code testMethod}.\n\t * <p>An attempt will be made to give each registered\n\t * {@link TestExecutionListener} a chance to perform its pre-processing.\n\t * If a listener throws an exception, however, the remaining registered\n\t * listeners will <strong>not</strong> be called.\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which is about to be executed on the\n\t * test instance\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @since 5.0\n\t * @see #beforeTestMethod\n\t * @see #afterTestMethod\n\t * @see #beforeTestExecution\n\t * @see #afterTestExecution\n\t * @see #getTestExecutionListeners()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "void",
    "signature": "public void beforeTestExecution(Object testInstance, Method testMethod)",
    "source_code": "\tpublic void beforeTestExecution(Object testInstance, Method testMethod) throws Exception {\n\t\tString callbackName = \"beforeTestExecution\";\n\t\tprepareForBeforeCallback(callbackName, testInstance, testMethod);\n\n\t\tfor (TestExecutionListener testExecutionListener : getTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.beforeTestExecution(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\thandleBeforeException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.context.<unknown>#beforeTestMethod(testInstance,testMethod)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for pre-processing a test <em>before</em> execution of <em>before</em>\n\t * lifecycle callbacks of the underlying test framework &mdash; for example,\n\t * setting up test fixtures, starting a transaction, etc.\n\t * <p>This method <strong>must</strong> be called immediately prior to\n\t * framework-specific <em>before</em> lifecycle callbacks &mdash; for example, methods\n\t * annotated with JUnit Jupiter's {@link org.junit.jupiter.api.BeforeEach @BeforeEach}.\n\t * For historical reasons, this method is named {@code beforeTestMethod}. Since\n\t * the introduction of {@link #beforeTestExecution}, a more suitable name for\n\t * this method might be something like {@code beforeTestSetUp} or\n\t * {@code beforeEach}; however, it is unfortunately impossible to rename\n\t * this method due to backward compatibility concerns.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance} and {@code testMethod}.\n\t * <p>An attempt will be made to give each registered\n\t * {@link TestExecutionListener} a chance to perform its pre-processing.\n\t * If a listener throws an exception, however, the remaining registered\n\t * listeners will <strong>not</strong> be called.\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which is about to be executed on the\n\t * test instance\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @see #afterTestMethod\n\t * @see #beforeTestExecution\n\t * @see #afterTestExecution\n\t * @see #getTestExecutionListeners()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "void",
    "signature": "public void beforeTestMethod(Object testInstance, Method testMethod)",
    "source_code": "\tpublic void beforeTestMethod(Object testInstance, Method testMethod) throws Exception {\n\t\tString callbackName = \"beforeTestMethod\";\n\t\tprepareForBeforeCallback(callbackName, testInstance, testMethod);\n\n\t\tfor (TestExecutionListener testExecutionListener : getTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.beforeTestMethod(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\thandleBeforeException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.<unknown>#closeContext(mergedContextConfiguration,hierarchyMode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedContextConfiguration",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void closeContext(MergedContextConfiguration mergedContextConfiguration, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tpublic void closeContext(MergedContextConfiguration mergedContextConfiguration, @Nullable HierarchyMode hierarchyMode) {\n\t\tsynchronized (this.contextCache) {\n\t\t\tthis.contextCache.remove(replaceIfNecessary(mergedContextConfiguration), hierarchyMode);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.<unknown>#put(key,context)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void put(MergedContextConfiguration key, ApplicationContext context)",
    "source_code": "\tpublic void put(MergedContextConfiguration key, ApplicationContext context) {\n\t\tAssert.notNull(key, \"Key must not be null\");\n\t\tAssert.notNull(context, \"ApplicationContext must not be null\");\n\n\t\tthis.contextMap.put(key, context);\n\t\tMergedContextConfiguration child = key;\n\t\tMergedContextConfiguration parent = child.getParent();\n\t\twhile (parent != null) {\n\t\t\tSet<MergedContextConfiguration> list = this.hierarchyMap.computeIfAbsent(parent, k -> new HashSet<>());\n\t\t\tlist.add(child);\n\t\t\tchild = parent;\n\t\t\tparent = child.getParent();\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.<unknown>#remove(key,hierarchyMode)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "public void remove(MergedContextConfiguration key, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tpublic void remove(MergedContextConfiguration key, @Nullable HierarchyMode hierarchyMode) {\n\t\tAssert.notNull(key, \"Key must not be null\");\n\n\t\t// startKey is the level at which to begin clearing the cache,\n\t\t// depending on the configured hierarchy mode.s\n\t\tMergedContextConfiguration startKey = key;\n\t\tif (hierarchyMode == HierarchyMode.EXHAUSTIVE) {\n\t\t\tMergedContextConfiguration parent = startKey.getParent();\n\t\t\twhile (parent != null) {\n\t\t\t\tstartKey = parent;\n\t\t\t\tparent = startKey.getParent();\n\t\t\t}\n\t\t}\n\n\t\tList<MergedContextConfiguration> removedContexts = new ArrayList<>();\n\t\tremove(removedContexts, startKey);\n\n\t\t// Remove all remaining references to any removed contexts from the\n\t\t// hierarchy map.\n\t\tfor (MergedContextConfiguration currentKey : removedContexts) {\n\t\t\tfor (Set<MergedContextConfiguration> children : this.hierarchyMap.values()) {\n\t\t\t\tchildren.remove(currentKey);\n\t\t\t}\n\t\t}\n\n\t\t// Remove empty entries from the hierarchy map.\n\t\tfor (Map.Entry<MergedContextConfiguration, Set<MergedContextConfiguration>> entry : this.hierarchyMap.entrySet()) {\n\t\t\tif (entry.getValue().isEmpty()) {\n\t\t\t\tthis.hierarchyMap.remove(entry.getKey());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.<unknown>#removeEldestEntry(Map.Entry<MergedContextConfiguration,eldest)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map.Entry<MergedContextConfiguration",
      "eldest"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "boolean",
    "signature": "protected boolean removeEldestEntry(Map.Entry<MergedContextConfiguration, ApplicationContext> eldest)",
    "source_code": "\t\tprotected boolean removeEldestEntry(Map.Entry<MergedContextConfiguration, ApplicationContext> eldest) {\n\t\t\tif (this.size() > DefaultContextCache.this.getMaxSize()) {\n\t\t\t\t// Do NOT delete \"DefaultContextCache.this.\"; otherwise, we accidentally\n\t\t\t\t// invoke java.util.Map.remove(Object, Object).\n\t\t\t\tDefaultContextCache.this.remove(eldest.getKey(), HierarchyMode.CURRENT_LEVEL);\n\t\t\t}\n\n\t\t\t// Return false since we invoke a custom eviction algorithm.\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.test.context.junit.jupiter.<unknown>#evaluateAnnotation(annotationType,Function<A,expressionExtractor,Function<A,reasonExtractor,Function<A,loadContextExtractor,enabledOnTrue,context)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Evaluate the expression configured via the supplied annotation type on\n\t * the {@link AnnotatedElement} for the supplied {@link ExtensionContext}.\n\t * @param annotationType the type of annotation to process\n\t * @param expressionExtractor a function that extracts the expression from\n\t * the annotation\n\t * @param reasonExtractor a function that extracts the reason from the\n\t * annotation\n\t * @param loadContextExtractor a function that extracts the {@code loadContext}\n\t * flag from the annotation\n\t * @param enabledOnTrue indicates whether the returned {@code ConditionEvaluationResult}\n\t * should be {@link ConditionEvaluationResult#enabled enabled} if the expression\n\t * evaluates to {@code true}\n\t * @param context the {@code ExtensionContext}\n\t * @return {@link ConditionEvaluationResult#enabled enabled} if the container\n\t * or test should be enabled; otherwise {@link ConditionEvaluationResult#disabled disabled}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "annotationType",
      "Function<A",
      "expressionExtractor",
      "Function<A",
      "reasonExtractor",
      "Function<A",
      "loadContextExtractor",
      "enabledOnTrue",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "ConditionEvaluationResult",
    "signature": "protected ConditionEvaluationResult evaluateAnnotation(Class<A> annotationType,\n\t\t\tFunction<A, String> expressionExtractor, Function<A, String> reasonExtractor,\n\t\t\tFunction<A, Boolean> loadContextExtractor, boolean enabledOnTrue, ExtensionContext context)",
    "source_code": "\tprotected <A extends Annotation> ConditionEvaluationResult evaluateAnnotation(Class<A> annotationType,\n\t\t\tFunction<A, String> expressionExtractor, Function<A, String> reasonExtractor,\n\t\t\tFunction<A, Boolean> loadContextExtractor, boolean enabledOnTrue, ExtensionContext context) {\n\n\t\tAssert.state(context.getElement().isPresent(), \"No AnnotatedElement\");\n\t\tAnnotatedElement element = context.getElement().get();\n\t\tOptional<A> annotation = findMergedAnnotation(element, annotationType);\n\n\t\tif (annotation.isEmpty()) {\n\t\t\tString reason = String.format(\"%s is enabled since @%s is not present\", element,\n\t\t\t\t\tannotationType.getSimpleName());\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(reason);\n\t\t\t}\n\t\t\treturn ConditionEvaluationResult.enabled(reason);\n\t\t}\n\n\t\tString expression = annotation.map(expressionExtractor).map(String::trim).filter(StringUtils::hasLength)\n\t\t\t\t.orElseThrow(() -> new IllegalStateException(String.format(\n\t\t\t\t\t\t\"The expression in @%s on [%s] must not be blank\", annotationType.getSimpleName(), element)));\n\n\t\tboolean loadContext = loadContextExtractor.apply(annotation.get());\n\t\tboolean evaluatedToTrue = evaluateExpression(expression, loadContext, annotationType, context);\n\t\tConditionEvaluationResult result;\n\n\t\tif (evaluatedToTrue) {\n\t\t\tString adjective = (enabledOnTrue ? \"enabled\" : \"disabled\");\n\t\t\tString reason = annotation.map(reasonExtractor).filter(StringUtils::hasText).orElseGet(\n\t\t\t\t\t() -> String.format(\"%s is %s because @%s(\\\"%s\\\") evaluated to true\", element, adjective,\n\t\t\t\t\t\tannotationType.getSimpleName(), expression));\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(reason);\n\t\t\t}\n\t\t\tresult = (enabledOnTrue ? ConditionEvaluationResult.enabled(reason)\n\t\t\t\t\t: ConditionEvaluationResult.disabled(reason));\n\t\t}\n\t\telse {\n\t\t\tString adjective = (enabledOnTrue ? \"disabled\" : \"enabled\");\n\t\t\tString reason = String.format(\"%s is %s because @%s(\\\"%s\\\") did not evaluate to true\",\n\t\t\t\t\telement, adjective, annotationType.getSimpleName(), expression);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(reason);\n\t\t\t}\n\t\t\tresult = (enabledOnTrue ? ConditionEvaluationResult.disabled(reason) :\n\t\t\t\t\tConditionEvaluationResult.enabled(reason));\n\t\t}\n\n\t\t// If we eagerly loaded the ApplicationContext to evaluate SpEL expressions\n\t\t// and the test class ends up being disabled, we have to check if the\n\t\t// user asked for the ApplicationContext to be closed via @DirtiesContext,\n\t\t// since the DirtiesContextTestExecutionListener will never be invoked for\n\t\t// a disabled test class.\n\t\t// See https://github.com/spring-projects/spring-framework/issues/26694\n\t\tif (loadContext && result.isDisabled() && element instanceof Class<?> testClass) {\n\t\t\tDirtiesContext dirtiesContext = TestContextAnnotationUtils.findMergedAnnotation(testClass, DirtiesContext.class);\n\t\t\tif (dirtiesContext != null) {\n\t\t\t\tHierarchyMode hierarchyMode = dirtiesContext.hierarchyMode();\n\t\t\t\tSpringExtension.getTestContextManager(context).getTestContext().markApplicationContextDirty(hierarchyMode);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#beforeOrAfterTestClass(testContext,requiredClassMode)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform the actual work for {@link #beforeTestClass} and {@link #afterTestClass}\n\t * by dirtying the context if appropriate (i.e., according to the required mode).\n\t * @param testContext the test context whose application context should\n\t * potentially be marked as dirty; never {@code null}\n\t * @param requiredClassMode the class mode required for a context to\n\t * be marked dirty in the current phase; never {@code null}\n\t * @throws Exception allows any exception to propagate\n\t * @since 4.2\n\t * @see #dirtyContext\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "testContext",
      "requiredClassMode"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "protected void beforeOrAfterTestClass(TestContext testContext, ClassMode requiredClassMode)",
    "source_code": "\tprotected void beforeOrAfterTestClass(TestContext testContext, ClassMode requiredClassMode) throws Exception {\n\t\tAssert.notNull(testContext, \"TestContext must not be null\");\n\t\tAssert.notNull(requiredClassMode, \"requiredClassMode must not be null\");\n\n\t\tClass<?> testClass = testContext.getTestClass();\n\t\tAssert.notNull(testClass, \"The test class of the supplied TestContext must not be null\");\n\n\t\tDirtiesContext dirtiesContext = TestContextAnnotationUtils.findMergedAnnotation(testClass, DirtiesContext.class);\n\t\tboolean classAnnotated = (dirtiesContext != null);\n\t\tClassMode classMode = (classAnnotated ? dirtiesContext.classMode() : null);\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"%s test class: context %s, class annotated with @DirtiesContext [%s] with mode [%s]\"\n\t\t\t\t\t.formatted(getPhase(requiredClassMode), testContext, classAnnotated, classMode));\n\t\t}\n\t\telse if (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"%s test class: class [%s], class annotated with @DirtiesContext [%s] with mode [%s]\"\n\t\t\t\t\t.formatted(getPhase(requiredClassMode), testClass.getSimpleName(), classAnnotated, classMode));\n\t\t}\n\n\t\tif (classMode == requiredClassMode) {\n\t\t\tdirtyContext(testContext, dirtiesContext.hierarchyMode());\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#beforeOrAfterTestMethod(testContext,requiredMethodMode,requiredClassMode)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform the actual work for {@link #beforeTestMethod} and {@link #afterTestMethod}\n\t * by dirtying the context if appropriate (i.e., according to the required modes).\n\t * @param testContext the test context whose application context should\n\t * potentially be marked as dirty; never {@code null}\n\t * @param requiredMethodMode the method mode required for a context to\n\t * be marked dirty in the current phase; never {@code null}\n\t * @param requiredClassMode the class mode required for a context to\n\t * be marked dirty in the current phase; never {@code null}\n\t * @throws Exception allows any exception to propagate\n\t * @since 4.2\n\t * @see #dirtyContext\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "testContext",
      "requiredMethodMode",
      "requiredClassMode"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "protected void beforeOrAfterTestMethod(TestContext testContext, MethodMode requiredMethodMode,\n\t\t\tClassMode requiredClassMode)",
    "source_code": "\tprotected void beforeOrAfterTestMethod(TestContext testContext, MethodMode requiredMethodMode,\n\t\t\tClassMode requiredClassMode) throws Exception {\n\n\t\tAssert.notNull(testContext, \"TestContext must not be null\");\n\t\tAssert.notNull(requiredMethodMode, \"requiredMethodMode must not be null\");\n\t\tAssert.notNull(requiredClassMode, \"requiredClassMode must not be null\");\n\n\t\tClass<?> testClass = testContext.getTestClass();\n\t\tMethod testMethod = testContext.getTestMethod();\n\t\tAssert.notNull(testClass, \"The test class of the supplied TestContext must not be null\");\n\t\tAssert.notNull(testMethod, \"The test method of the supplied TestContext must not be null\");\n\n\t\tDirtiesContext methodAnn = AnnotatedElementUtils.findMergedAnnotation(testMethod, DirtiesContext.class);\n\t\tDirtiesContext classAnn = TestContextAnnotationUtils.findMergedAnnotation(testClass, DirtiesContext.class);\n\t\tboolean methodAnnotated = (methodAnn != null);\n\t\tboolean classAnnotated = (classAnn != null);\n\t\tMethodMode methodMode = (methodAnnotated ? methodAnn.methodMode() : null);\n\t\tClassMode classMode = (classAnnotated ? classAnn.classMode() : null);\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"\"\"\n\t\t\t\t\t%s test method: context %s, class annotated with @DirtiesContext [%s] \\\n\t\t\t\t\twith mode [%s], method annotated with @DirtiesContext [%s] with mode [%s]\"\"\"\n\t\t\t\t\t\t.formatted(getPhase(requiredMethodMode), testContext, classAnnotated, classMode,\n\t\t\t\t\t\t\tmethodAnnotated, methodMode));\n\t\t}\n\t\telse if (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"\"\"\n\t\t\t\t\t%s test method: class [%s], method [%s], class annotated with @DirtiesContext [%s] \\\n\t\t\t\t\twith mode [%s], method annotated with @DirtiesContext [%s] with mode [%s]\"\"\"\n\t\t\t\t\t\t.formatted(getPhase(requiredMethodMode), testClass.getSimpleName(),\n\t\t\t\t\t\t\ttestMethod.getName(), classAnnotated, classMode, methodAnnotated, methodMode));\n\t\t}\n\n\t\tif ((methodMode == requiredMethodMode) || (classMode == requiredClassMode)) {\n\t\t\tHierarchyMode hierarchyMode = (methodAnnotated ? methodAnn.hierarchyMode() : classAnn.hierarchyMode());\n\t\t\tdirtyContext(testContext, hierarchyMode);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#computeAttribute(name,Function<String,computeFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "Function<String",
      "computeFunction"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "T",
    "signature": "public T computeAttribute(String name, Function<String, T> computeFunction)",
    "source_code": "\tpublic <T> T computeAttribute(String name, Function<String, T> computeFunction) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tAssert.notNull(computeFunction, \"Compute function must not be null\");\n\t\tObject value = this.attributes.computeIfAbsent(name, computeFunction);\n\t\tAssert.state(value != null,\n\t\t\t\t() -> \"Compute function must not return null for attribute named '%s'\".formatted(name));\n\t\treturn (T) value;\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#dirtyContext(testContext,hierarchyMode)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Mark the {@linkplain ApplicationContext application context} of the supplied\n\t * {@linkplain TestContext test context} as\n\t * {@linkplain TestContext#markApplicationContextDirty(DirtiesContext.HierarchyMode) dirty}\n\t * and set {@link DependencyInjectionTestExecutionListener#REINJECT_DEPENDENCIES_ATTRIBUTE\n\t * REINJECT_DEPENDENCIES_ATTRIBUTE} in the test context to {@code true}.\n\t * @param testContext the test context whose application context should\n\t * be marked as dirty\n\t * @param hierarchyMode the context cache clearing mode to be applied if the\n\t * context is part of a hierarchy; may be {@code null}\n\t * @since 3.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "testContext",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "protected void dirtyContext(TestContext testContext, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tprotected void dirtyContext(TestContext testContext, @Nullable HierarchyMode hierarchyMode) {\n\t\ttestContext.markApplicationContextDirty(hierarchyMode);\n\t\ttestContext.setAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE, Boolean.TRUE);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#isAutowirableConstructor(constructor,testClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied constructor for the given test class is\n\t * autowirable.\n\t * <p>This method delegates to {@link #isAutowirableConstructor(Constructor, Class, PropertyProvider)}\n\t * will a value of {@code null} for the fallback {@link PropertyProvider}.\n\t * @param constructor a constructor for the test class\n\t * @param testClass the test class\n\t * @return {@code true} if the constructor is autowirable\n\t * @see #isAutowirableConstructor(Constructor, Class, PropertyProvider)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constructor",
      "testClass"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "boolean",
    "signature": "public boolean isAutowirableConstructor(Constructor<?> constructor, Class<?> testClass)",
    "source_code": "\tpublic static boolean isAutowirableConstructor(Constructor<?> constructor, Class<?> testClass) {\n\t\treturn isAutowirableConstructor(constructor, testClass, null);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#isAutowirableConstructor(constructor,testClass,fallbackPropertyProvider)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied constructor for the given test class is\n\t * autowirable.\n\t *\n\t * <p>A constructor is considered to be autowirable if one of the following\n\t * conditions is {@code true}.\n\t *\n\t * <ol>\n\t * <li>The constructor is annotated with {@link Autowired @Autowired}.</li>\n\t * <li>{@link TestConstructor @TestConstructor} is <em>present</em> or\n\t * <em>meta-present</em> on the test class with\n\t * {@link TestConstructor#autowireMode() autowireMode} set to\n\t * {@link AutowireMode#ALL ALL}.</li>\n\t * <li>The default <em>test constructor autowire mode</em> has been set to\n\t * {@code ALL} in {@link SpringProperties} or in the supplied fallback\n\t * {@link PropertyProvider} (see\n\t * {@link TestConstructor#TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME}).</li>\n\t * </ol>\n\t * @param constructor a constructor for the test class\n\t * @param testClass the test class\n\t * @param fallbackPropertyProvider fallback property provider used to look up\n\t * the value for the default <em>test constructor autowire mode</em> if no\n\t * such value is found in {@link SpringProperties}\n\t * @return {@code true} if the constructor is autowirable\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constructor",
      "testClass",
      "fallbackPropertyProvider"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "boolean",
    "signature": "public boolean isAutowirableConstructor(Constructor<?> constructor, Class<?> testClass,\n\t\t\t@Nullable PropertyProvider fallbackPropertyProvider)",
    "source_code": "\tpublic static boolean isAutowirableConstructor(Constructor<?> constructor, Class<?> testClass,\n\t\t\t@Nullable PropertyProvider fallbackPropertyProvider) {\n\n\t\t// Is the constructor annotated with @Autowired?\n\t\tif (AnnotatedElementUtils.hasAnnotation(constructor, Autowired.class)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tAutowireMode autowireMode = null;\n\n\t\t// Is the test class annotated with @TestConstructor?\n\t\tTestConstructor testConstructor = TestContextAnnotationUtils.findMergedAnnotation(testClass, TestConstructor.class);\n\t\tif (testConstructor != null) {\n\t\t\tautowireMode = testConstructor.autowireMode();\n\t\t}\n\t\telse {\n\t\t\t// Custom global default from SpringProperties?\n\t\t\tString value = SpringProperties.getProperty(TestConstructor.TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME);\n\t\t\tautowireMode = AutowireMode.from(value);\n\n\t\t\t// Use fallback provider?\n\t\t\tif (autowireMode == null && fallbackPropertyProvider != null) {\n\t\t\t\tvalue = fallbackPropertyProvider.get(TestConstructor.TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME);\n\t\t\t\tautowireMode = AutowireMode.from(value);\n\t\t\t}\n\t\t}\n\n\t\treturn (autowireMode == AutowireMode.ALL);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#isAutowirableConstructor(executable,testClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied executable for the given test class is an\n\t * autowirable constructor.\n\t * <p>This method delegates to {@link #isAutowirableConstructor(Executable, Class, PropertyProvider)}\n\t * will a value of {@code null} for the fallback {@link PropertyProvider}.\n\t * @param executable an executable for the test class\n\t * @param testClass the test class\n\t * @return {@code true} if the executable is an autowirable constructor\n\t * @see #isAutowirableConstructor(Executable, Class, PropertyProvider)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executable",
      "testClass"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "boolean",
    "signature": "public boolean isAutowirableConstructor(Executable executable, Class<?> testClass)",
    "source_code": "\tpublic static boolean isAutowirableConstructor(Executable executable, Class<?> testClass) {\n\t\treturn isAutowirableConstructor(executable, testClass, null);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#isAutowirableConstructor(executable,testClass,fallbackPropertyProvider)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied executable for the given test class is an\n\t * autowirable constructor.\n\t * <p>This method delegates to {@link #isAutowirableConstructor(Constructor, Class, PropertyProvider)}\n\t * if the supplied executable is a constructor and otherwise returns {@code false}.\n\t * @param executable an executable for the test class\n\t * @param testClass the test class\n\t * @param fallbackPropertyProvider fallback property provider used to look up\n\t * the value for {@link TestConstructor#TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME}\n\t * if no such value is found in {@link SpringProperties}\n\t * @return {@code true} if the executable is an autowirable constructor\n\t * @since 5.3\n\t * @see #isAutowirableConstructor(Constructor, Class, PropertyProvider)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executable",
      "testClass",
      "fallbackPropertyProvider"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "boolean",
    "signature": "public boolean isAutowirableConstructor(Executable executable, Class<?> testClass,\n\t\t\t@Nullable PropertyProvider fallbackPropertyProvider)",
    "source_code": "\tpublic static boolean isAutowirableConstructor(Executable executable, Class<?> testClass,\n\t\t\t@Nullable PropertyProvider fallbackPropertyProvider) {\n\n\t\treturn (executable instanceof Constructor<?> constructor &&\n\t\t\t\tisAutowirableConstructor(constructor, testClass, fallbackPropertyProvider));\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#loadBeanDefinitions(context,mergedConfig)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register classes in the supplied {@link GenericApplicationContext context}\n\t * from the classes in the supplied {@link MergedContextConfiguration}.\n\t * <p>Each class must represent a <em>component class</em>. An\n\t * {@link AnnotatedBeanDefinitionReader} is used to register the appropriate\n\t * bean definitions.\n\t * <p>Note that this method does not call {@link #createBeanDefinitionReader}\n\t * since {@code AnnotatedBeanDefinitionReader} is not an instance of\n\t * {@link BeanDefinitionReader}.\n\t * @param context the context in which the component classes should be registered\n\t * @param mergedConfig the merged configuration from which the classes should be retrieved\n\t * @see AbstractGenericContextLoader#loadBeanDefinitions\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context",
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "protected void loadBeanDefinitions(GenericApplicationContext context, MergedContextConfiguration mergedConfig)",
    "source_code": "\tprotected void loadBeanDefinitions(GenericApplicationContext context, MergedContextConfiguration mergedConfig) {\n\t\tClass<?>[] componentClasses = mergedConfig.getClasses();\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Registering component classes: \" + classNames(componentClasses));\n\t\t}\n\t\tnew AnnotatedBeanDefinitionReader(context).register(componentClasses);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#loadContextForAotRuntime(mergedConfig,initializer)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to an appropriate candidate {@code SmartContextLoader} to load\n\t * an {@link ApplicationContext} for AOT run-time execution.\n\t * <p>Delegation is based on explicit knowledge of the implementations of the\n\t * default loaders. See {@link #loadContext(MergedContextConfiguration)} for\n\t * details.\n\t * @param mergedConfig the merged context configuration to use to load the application context\n\t * @param initializer the {@code ApplicationContextInitializer} that should\n\t * be applied to the context in order to recreate bean definitions\n\t * @return a new application context\n\t * @throws IllegalStateException if neither candidate loader is capable of loading an\n\t * {@code ApplicationContext} from the supplied merged context configuration\n\t * @since 6.0\n\t * @see AotContextLoader#loadContextForAotRuntime(MergedContextConfiguration, ApplicationContextInitializer)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig",
      "initializer"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext loadContextForAotRuntime(MergedContextConfiguration mergedConfig,\n\t\t\tApplicationContextInitializer<ConfigurableApplicationContext> initializer)",
    "source_code": "\tpublic final ApplicationContext loadContextForAotRuntime(MergedContextConfiguration mergedConfig,\n\t\t\tApplicationContextInitializer<ConfigurableApplicationContext> initializer) throws Exception {\n\n\t\tAotContextLoader loader = getAotContextLoader(mergedConfig);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Delegating to %s to load context for AOT execution for %s\"\n\t\t\t\t\t.formatted(name(loader), mergedConfig));\n\t\t}\n\t\treturn loader.loadContextForAotRuntime(mergedConfig, initializer);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#modifyLocations(clazz,locations)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@code AnnotationConfigContextLoader} should be used as a\n\t * {@link org.springframework.test.context.SmartContextLoader SmartContextLoader},\n\t * not as a legacy {@link org.springframework.test.context.ContextLoader ContextLoader}.\n\t * Consequently, this method is not supported.\n\t * @throws UnsupportedOperationException in this implementation\n\t * @see AbstractContextLoader#modifyLocations\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "String[]",
    "signature": "protected String[] modifyLocations(Class<?> clazz, String... locations)",
    "source_code": "\tprotected String[] modifyLocations(Class<?> clazz, String... locations) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"AnnotationConfigContextLoader does not support the modifyLocations(Class, String...) method\");\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#resolveContextLoader(testClass,configAttributesList)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the {@link ContextLoader} {@linkplain Class class} to use for the\n\t * supplied list of {@link ContextConfigurationAttributes} and then instantiate\n\t * and return that {@code ContextLoader}.\n\t * <p>If the user has not explicitly declared which loader to use, the value\n\t * returned from {@link #getDefaultContextLoaderClass} will be used as the\n\t * default context loader class. For details on the class resolution process,\n\t * see {@link #resolveExplicitContextLoaderClass} and\n\t * {@link #getDefaultContextLoaderClass}.\n\t * @param testClass the test class for which the {@code ContextLoader} should be\n\t * resolved; must not be {@code null}\n\t * @param configAttributesList the list of configuration attributes to process; must\n\t * not be {@code null}; must be ordered <em>bottom-up</em>\n\t * (i.e., as if we were traversing up the class hierarchy and enclosing class hierarchy)\n\t * @return the resolved {@code ContextLoader} for the supplied {@code testClass}\n\t * (never {@code null})\n\t * @throws IllegalStateException if {@link #getDefaultContextLoaderClass(Class)}\n\t * returns {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "testClass",
      "configAttributesList"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "ContextLoader",
    "signature": "protected ContextLoader resolveContextLoader(Class<?> testClass,\n\t\t\tList<ContextConfigurationAttributes> configAttributesList)",
    "source_code": "\tprotected ContextLoader resolveContextLoader(Class<?> testClass,\n\t\t\tList<ContextConfigurationAttributes> configAttributesList) {\n\n\t\tAssert.notNull(testClass, \"Class must not be null\");\n\t\tAssert.notNull(configAttributesList, \"ContextConfigurationAttributes list must not be null\");\n\n\t\tClass<? extends ContextLoader> contextLoaderClass = resolveExplicitContextLoaderClass(configAttributesList);\n\t\tif (contextLoaderClass == null) {\n\t\t\tcontextLoaderClass = getDefaultContextLoaderClass(testClass);\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(String.format(\"Using ContextLoader class [%s] for test class [%s]\",\n\t\t\t\t\tcontextLoaderClass.getName(), testClass.getName()));\n\t\t}\n\t\treturn BeanUtils.instantiateClass(contextLoaderClass, ContextLoader.class);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#setAttribute(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "void",
    "signature": "public void setAttribute(String name, @Nullable Object value)",
    "source_code": "\tpublic void setAttribute(String name, @Nullable Object value) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tsynchronized (this.attributes) {\n\t\t\tif (value != null) {\n\t\t\t\tthis.attributes.put(name, value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.attributes.remove(name);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#updateState(testInstance,testMethod,testException)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod",
      "testException"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "void",
    "signature": "public void updateState(@Nullable Object testInstance, @Nullable Method testMethod, @Nullable Throwable testException)",
    "source_code": "\tpublic void updateState(@Nullable Object testInstance, @Nullable Method testMethod, @Nullable Throwable testException) {\n\t\tthis.testInstance = testInstance;\n\t\tthis.testMethod = testMethod;\n\t\tthis.testException = testException;\n\t}"
  },
  "org.springframework.test.context.transaction.<unknown>#createDelegatingTransactionAttribute(testContext,targetAttribute)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a delegating {@link TransactionAttribute} for the supplied target\n\t * {@link TransactionAttribute} and {@link TestContext}, using the names of\n\t * the test class and test method to build the name of the transaction.\n\t * @param testContext the {@code TestContext} upon which to base the name\n\t * @param targetAttribute the {@code TransactionAttribute} to delegate to\n\t * @return the delegating {@code TransactionAttribute}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext",
      "targetAttribute"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "TransactionAttribute",
    "signature": "public TransactionAttribute createDelegatingTransactionAttribute(TestContext testContext, TransactionAttribute targetAttribute)",
    "source_code": "\tpublic static TransactionAttribute createDelegatingTransactionAttribute(\n\t\t\tTestContext testContext, TransactionAttribute targetAttribute) {\n\n\t\tAssert.notNull(testContext, \"TestContext must not be null\");\n\t\tAssert.notNull(targetAttribute, \"Target TransactionAttribute must not be null\");\n\t\treturn new TestContextTransactionAttribute(targetAttribute, testContext);\n\t}"
  },
  "org.springframework.test.context.transaction.<unknown>#retrieveDataSource(testContext,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the {@link DataSource} to use for the supplied {@linkplain TestContext\n\t * test context}.\n\t * <p>The following algorithm is used to retrieve the {@code DataSource} from\n\t * the {@link org.springframework.context.ApplicationContext ApplicationContext}\n\t * of the supplied test context:\n\t * <ol>\n\t * <li>Look up the {@code DataSource} by type and name, if the supplied\n\t * {@code name} is non-empty, throwing a {@link BeansException} if the named\n\t * {@code DataSource} does not exist.\n\t * <li>Attempt to look up the single {@code DataSource} by type.\n\t * <li>Attempt to look up the <em>primary</em> {@code DataSource} by type.\n\t * <li>Attempt to look up the {@code DataSource} by type and the\n\t * {@linkplain #DEFAULT_DATA_SOURCE_NAME default data source name}.\n\t * </ol>\n\t * @param testContext the test context for which the {@code DataSource}\n\t * should be retrieved; never {@code null}\n\t * @param name the name of the {@code DataSource} to retrieve\n\t * (may be {@code null} or <em>empty</em>)\n\t * @return the {@code DataSource} to use, or {@code null} if not found\n\t * @throws BeansException if an error occurs while retrieving an explicitly\n\t * named {@code DataSource}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "DataSource",
    "signature": "public DataSource retrieveDataSource(TestContext testContext, @Nullable String name)",
    "source_code": "\tpublic static DataSource retrieveDataSource(TestContext testContext, @Nullable String name) {\n\t\tAssert.notNull(testContext, \"TestContext must not be null\");\n\t\tBeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory();\n\n\t\ttry {\n\t\t\t// Look up by type and explicit name\n\t\t\tif (StringUtils.hasText(name)) {\n\t\t\t\treturn bf.getBean(name, DataSource.class);\n\t\t\t}\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tlogger.error(String.format(\"Failed to retrieve DataSource named '%s' for test context %s\",\n\t\t\t\t\tname, testContext), ex);\n\t\t\tthrow ex;\n\t\t}\n\n\t\ttry {\n\t\t\tif (bf instanceof ListableBeanFactory lbf) {\n\t\t\t\t// Look up single bean by type\n\t\t\t\tMap<String, DataSource> dataSources =\n\t\t\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(lbf, DataSource.class);\n\t\t\t\tif (dataSources.size() == 1) {\n\t\t\t\t\treturn dataSources.values().iterator().next();\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\t// look up single bean by type, with support for 'primary' beans\n\t\t\t\t\treturn bf.getBean(DataSource.class);\n\t\t\t\t}\n\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\tlogBeansException(testContext, ex, PlatformTransactionManager.class);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// look up by type and default name\n\t\t\treturn bf.getBean(DEFAULT_DATA_SOURCE_NAME, DataSource.class);\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tlogBeansException(testContext, ex, DataSource.class);\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.test.context.transaction.<unknown>#retrieveTransactionManager(testContext,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the {@linkplain PlatformTransactionManager transaction manager}\n\t * to use for the supplied {@linkplain TestContext test context}.\n\t * <p>The following algorithm is used to retrieve the transaction manager\n\t * from the {@link org.springframework.context.ApplicationContext ApplicationContext}\n\t * of the supplied test context:\n\t * <ol>\n\t * <li>Look up the transaction manager by type and explicit name, if the supplied\n\t * {@code name} is non-empty, throwing a {@link BeansException} if the named\n\t * transaction manager does not exist.\n\t * <li>Attempt to look up the transaction manager via a\n\t * {@link TransactionManagementConfigurer}, if present.\n\t * <li>Attempt to look up the single transaction manager by type.\n\t * <li>Attempt to look up the <em>primary</em> transaction manager by type.\n\t * <li>Attempt to look up the transaction manager by type and the\n\t * {@linkplain #DEFAULT_TRANSACTION_MANAGER_NAME default transaction manager\n\t * name}.\n\t * </ol>\n\t * @param testContext the test context for which the transaction manager\n\t * should be retrieved; never {@code null}\n\t * @param name the name of the transaction manager to retrieve\n\t * (may be {@code null} or <em>empty</em>)\n\t * @return the transaction manager to use, or {@code null} if not found\n\t * @throws BeansException if an error occurs while retrieving an explicitly\n\t * named transaction manager\n\t * @throws IllegalStateException if more than one TransactionManagementConfigurer\n\t * exists in the ApplicationContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "PlatformTransactionManager",
    "signature": "public PlatformTransactionManager retrieveTransactionManager(TestContext testContext, @Nullable String name)",
    "source_code": "\tpublic static PlatformTransactionManager retrieveTransactionManager(TestContext testContext, @Nullable String name) {\n\t\tAssert.notNull(testContext, \"TestContext must not be null\");\n\t\tBeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory();\n\n\t\ttry {\n\t\t\t// Look up by type and explicit name\n\t\t\tif (StringUtils.hasText(name)) {\n\t\t\t\treturn bf.getBean(name, PlatformTransactionManager.class);\n\t\t\t}\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tlogger.error(String.format(\"Failed to retrieve transaction manager named '%s' for test context %s\",\n\t\t\t\t\tname, testContext), ex);\n\t\t\tthrow ex;\n\t\t}\n\n\t\ttry {\n\t\t\tif (bf instanceof ListableBeanFactory lbf) {\n\t\t\t\t// Look up single TransactionManagementConfigurer\n\t\t\t\tMap<String, TransactionManagementConfigurer> configurers =\n\t\t\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(lbf, TransactionManagementConfigurer.class);\n\t\t\t\tAssert.state(configurers.size() <= 1,\n\t\t\t\t\t\t\"Only one TransactionManagementConfigurer may exist in the ApplicationContext\");\n\t\t\t\tif (configurers.size() == 1) {\n\t\t\t\t\tTransactionManager tm = configurers.values().iterator().next().annotationDrivenTransactionManager();\n\t\t\t\t\tAssert.state(tm instanceof PlatformTransactionManager, () ->\n\t\t\t\t\t\t\"Transaction manager specified via TransactionManagementConfigurer \" +\n\t\t\t\t\t\t\"is not a PlatformTransactionManager: \" + tm);\n\t\t\t\t\treturn (PlatformTransactionManager) tm;\n\t\t\t\t}\n\n\t\t\t\t// Look up single bean by type\n\t\t\t\tMap<String, PlatformTransactionManager> txMgrs =\n\t\t\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(lbf, PlatformTransactionManager.class);\n\t\t\t\tif (txMgrs.size() == 1) {\n\t\t\t\t\treturn txMgrs.values().iterator().next();\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\t// Look up single bean by type, with support for 'primary' beans\n\t\t\t\t\treturn bf.getBean(PlatformTransactionManager.class);\n\t\t\t\t}\n\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\tlogBeansException(testContext, ex, PlatformTransactionManager.class);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// look up by type and default name\n\t\t\treturn bf.getBean(DEFAULT_TRANSACTION_MANAGER_NAME, PlatformTransactionManager.class);\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tlogBeansException(testContext, ex, PlatformTransactionManager.class);\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.test.context.util.<unknown>#convertToClasspathResourcePaths(clazz,paths)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the supplied paths to classpath resource paths.\n\t * <p>Delegates to {@link #convertToClasspathResourcePaths(Class, boolean, String...)}\n\t * with {@code false} supplied for the {@code preservePlaceholders} flag.\n\t * @param clazz the class with which the paths are associated\n\t * @param paths the paths to be converted\n\t * @return a new array of converted resource paths\n\t * @see #convertToResources\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "paths"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "String[]",
    "signature": "public String[] convertToClasspathResourcePaths(Class<?> clazz, String... paths)",
    "source_code": "\tpublic static String[] convertToClasspathResourcePaths(Class<?> clazz, String... paths) {\n\t\treturn convertToClasspathResourcePaths(clazz, false, paths);\n\t}"
  },
  "org.springframework.test.context.util.<unknown>#convertToClasspathResourcePaths(clazz,preservePlaceholders,paths)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the supplied paths to classpath resource paths.\n\t *\n\t * <p>For each of the supplied paths:\n\t * <ul>\n\t * <li>A plain path &mdash; for example, {@code \"context.xml\"} &mdash; will\n\t * be treated as a classpath resource that is relative to the package in\n\t * which the specified class is defined. Such a path will be prepended with\n\t * the {@code classpath:} prefix and the path to the package for the class.\n\t * <li>A path starting with a slash will be treated as an absolute path\n\t * within the classpath, for example: {@code \"/org/example/schema.sql\"}.\n\t * Such a path will be prepended with the {@code classpath:} prefix.\n\t * <li>A path which is already prefixed with a URL protocol (e.g.,\n\t * {@code classpath:}, {@code file:}, {@code http:}, etc.) will not have its\n\t * protocol modified.\n\t * </ul>\n\t * <p>Each path will then be {@linkplain StringUtils#cleanPath cleaned},\n\t * unless the {@code preservePlaceholders} flag is {@code true} and the path\n\t * contains one or more placeholders in the form <code>${placeholder.name}</code>.\n\t * @param clazz the class with which the paths are associated\n\t * @param preservePlaceholders {@code true} if placeholders should be preserved\n\t * @param paths the paths to be converted\n\t * @return a new array of converted resource paths\n\t * @since 5.2\n\t * @see #convertToResources\n\t * @see ResourceUtils#CLASSPATH_URL_PREFIX\n\t * @see ResourceUtils#FILE_URL_PREFIX\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "preservePlaceholders",
      "paths"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "String[]",
    "signature": "public String[] convertToClasspathResourcePaths(Class<?> clazz, boolean preservePlaceholders, String... paths)",
    "source_code": "\tpublic static String[] convertToClasspathResourcePaths(Class<?> clazz, boolean preservePlaceholders, String... paths) {\n\t\tString[] convertedPaths = new String[paths.length];\n\t\tfor (int i = 0; i < paths.length; i++) {\n\t\t\tString path = paths[i];\n\n\t\t\t// Absolute path\n\t\t\tif (path.startsWith(SLASH)) {\n\t\t\t\tconvertedPaths[i] = ResourceUtils.CLASSPATH_URL_PREFIX + path;\n\t\t\t}\n\t\t\t// Relative path\n\t\t\telse if (!ResourcePatternUtils.isUrl(path)) {\n\t\t\t\tconvertedPaths[i] = ResourceUtils.CLASSPATH_URL_PREFIX + SLASH +\n\t\t\t\t\t\tClassUtils.classPackageAsResourcePath(clazz) + SLASH + path;\n\t\t\t}\n\t\t\t// URL\n\t\t\telse {\n\t\t\t\tconvertedPaths[i] = path;\n\t\t\t}\n\n\t\t\tif (!(preservePlaceholders && PLACEHOLDER_PATTERN.matcher(convertedPaths[i]).matches())) {\n\t\t\t\tconvertedPaths[i] = StringUtils.cleanPath(convertedPaths[i]);\n\t\t\t}\n\t\t}\n\t\treturn convertedPaths;\n\t}"
  },
  "org.springframework.test.context.util.<unknown>#convertToResourceList(resourceLoader,paths)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the supplied paths to a list of {@link Resource} handles using\n\t * the given {@link ResourceLoader}.\n\t * @param resourceLoader the {@code ResourceLoader} to use to convert the paths\n\t * @param paths the paths to be converted\n\t * @return a new, mutable list of resources\n\t * @since 4.2\n\t * @see #convertToResources(ResourceLoader, String...)\n\t * @see #convertToClasspathResourcePaths\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLoader",
      "paths"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "List<Resource>",
    "signature": "public List<Resource> convertToResourceList(ResourceLoader resourceLoader, String... paths)",
    "source_code": "\tpublic static List<Resource> convertToResourceList(ResourceLoader resourceLoader, String... paths) {\n\t\treturn stream(resourceLoader, paths).collect(Collectors.toCollection(ArrayList::new));\n\t}"
  },
  "org.springframework.test.context.util.<unknown>#convertToResources(resourceLoader,paths)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the supplied paths to an array of {@link Resource} handles using\n\t * the given {@link ResourceLoader}.\n\t * @param resourceLoader the {@code ResourceLoader} to use to convert the paths\n\t * @param paths the paths to be converted\n\t * @return a new array of resources\n\t * @see #convertToResourceList(ResourceLoader, String...)\n\t * @see #convertToClasspathResourcePaths\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLoader",
      "paths"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "Resource[]",
    "signature": "public Resource[] convertToResources(ResourceLoader resourceLoader, String... paths)",
    "source_code": "\tpublic static Resource[] convertToResources(ResourceLoader resourceLoader, String... paths) {\n\t\treturn stream(resourceLoader, paths).toArray(Resource[]::new);\n\t}"
  },
  "org.springframework.test.context.util.<unknown>#handleFailure(factoryType,factoryImplementationName,failure)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "factoryImplementationName",
      "failure"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "return": "void",
    "signature": "public void handleFailure(Class<?> factoryType, String factoryImplementationName, Throwable failure)",
    "source_code": "\tpublic void handleFailure(Class<?> factoryType, String factoryImplementationName, Throwable failure) {\n\t\tThrowable ex = (failure instanceof InvocationTargetException ite ? ite.getTargetException() : failure);\n\t\tif (ex instanceof ClassNotFoundException || ex instanceof NoClassDefFoundError) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"\"\"\n\t\t\t\t\t\tSkipping candidate %1$s [%2$s] due to a missing dependency. \\\n\t\t\t\t\t\tSpecify custom %1$s classes or make the default %1$s classes \\\n\t\t\t\t\t\tand their required dependencies available. Offending class: [%3$s]\"\"\"\n\t\t\t\t\t\t\t.formatted(factoryType.getSimpleName(), factoryImplementationName, ex.getMessage()));\n\t\t\t}\n\t\t}\n\t\telse if (ex instanceof LinkageError) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"\"\"\n\t\t\t\t\t\tCould not load %1$s [%2$s]. Specify custom %1$s classes or make the default %1$s classes \\\n\t\t\t\t\t\tavailable.\"\"\".formatted(factoryType.getSimpleName(), factoryImplementationName), ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (ex instanceof RuntimeException runtimeException) {\n\t\t\t\tthrow runtimeException;\n\t\t\t}\n\t\t\tif (ex instanceof Error error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\"Failed to load %s [%s]\".formatted(factoryType.getSimpleName(), factoryImplementationName), ex);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.web.<unknown>#configureWebResources(context,webMergedConfig)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configures web resources for the supplied web application context (WAC).\n\t * <h4>Implementation Details</h4>\n\t * <p>If the supplied WAC has no parent or its parent is not a WAC, the\n\t * supplied WAC will be configured as the Root WAC (see \"<em>Root WAC\n\t * Configuration</em>\" below).\n\t * <p>Otherwise the context hierarchy of the supplied WAC will be traversed\n\t * to find the top-most WAC (i.e., the root); and the {@link ServletContext}\n\t * of the Root WAC will be set as the {@code ServletContext} for the supplied\n\t * WAC.\n\t * <h4>Root WAC Configuration</h4>\n\t * <ul>\n\t * <li>The resource base path is retrieved from the supplied\n\t * {@code WebMergedContextConfiguration}.</li>\n\t * <li>A {@link ResourceLoader} is instantiated for the {@link MockServletContext}:\n\t * if the resource base path is prefixed with \"{@code classpath:}\", a\n\t * {@link DefaultResourceLoader} will be used; otherwise, a\n\t * {@link FileSystemResourceLoader} will be used.</li>\n\t * <li>A {@code MockServletContext} will be created using the resource base\n\t * path and resource loader.</li>\n\t * <li>The supplied {@link GenericWebApplicationContext} is then stored in\n\t * the {@code MockServletContext} under the\n\t * {@link WebApplicationContext#ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE} key.</li>\n\t * <li>Finally, the {@code MockServletContext} is set in the\n\t * {@code WebApplicationContext}.</li>\n\t * </ul>\n\t * @param context the web application context for which to configure the web resources\n\t * @param webMergedConfig the merged context configuration to use to load the web application context\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context",
      "webMergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "void",
    "signature": "protected void configureWebResources(GenericWebApplicationContext context,\n\t\t\tWebMergedContextConfiguration webMergedConfig)",
    "source_code": "\tprotected void configureWebResources(GenericWebApplicationContext context,\n\t\t\tWebMergedContextConfiguration webMergedConfig) {\n\n\t\tApplicationContext parent = context.getParent();\n\n\t\t// If the WebApplicationContext has no parent or the parent is not a WebApplicationContext,\n\t\t// set the current context as the root WebApplicationContext:\n\t\tif (!(parent instanceof WebApplicationContext)) {\n\t\t\tString resourceBasePath = webMergedConfig.getResourceBasePath();\n\t\t\tResourceLoader resourceLoader = (resourceBasePath.startsWith(ResourceLoader.CLASSPATH_URL_PREFIX) ?\n\t\t\t\t\tnew DefaultResourceLoader() : new FileSystemResourceLoader());\n\t\t\tServletContext servletContext = new MockServletContext(resourceBasePath, resourceLoader);\n\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, context);\n\t\t\tcontext.setServletContext(servletContext);\n\t\t}\n\t\telse {\n\t\t\tServletContext servletContext = null;\n\t\t\t// Find the root WebApplicationContext\n\t\t\twhile (parent != null) {\n\t\t\t\tif (parent instanceof WebApplicationContext parentWac &&\n\t\t\t\t\t\t!(parent.getParent() instanceof WebApplicationContext)) {\n\t\t\t\t\tservletContext = parentWac.getServletContext();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tparent = parent.getParent();\n\t\t\t}\n\t\t\tAssert.state(servletContext != null, \"Failed to find root WebApplicationContext in the context hierarchy\");\n\t\t\tcontext.setServletContext(servletContext);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.web.<unknown>#customizeBeanFactory(beanFactory,webMergedConfig)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the internal bean factory of the {@code WebApplicationContext}\n\t * created by this context loader.\n\t * <p>The default implementation is empty but can be overridden in subclasses\n\t * to customize {@code DefaultListableBeanFactory}'s standard settings.\n\t * @param beanFactory the bean factory created by this context loader\n\t * @param webMergedConfig the merged context configuration to use to load the\n\t * web application context\n\t * @see #loadContext(MergedContextConfiguration)\n\t * @see DefaultListableBeanFactory#setAllowBeanDefinitionOverriding\n\t * @see DefaultListableBeanFactory#setAllowEagerClassLoading\n\t * @see DefaultListableBeanFactory#setAllowCircularReferences\n\t * @see DefaultListableBeanFactory#setAllowRawInjectionDespiteWrapping\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactory",
      "webMergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 342
    },
    "return": "void",
    "signature": "protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory, WebMergedContextConfiguration webMergedConfig)",
    "source_code": "\tprotected void customizeBeanFactory(\n\t\t\tDefaultListableBeanFactory beanFactory, WebMergedContextConfiguration webMergedConfig) {\n\t}"
  },
  "org.springframework.test.context.web.<unknown>#customizeContext(context,webMergedConfig)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the {@link GenericWebApplicationContext} created by this context\n\t * loader <i>after</i> bean definitions have been loaded into the context but\n\t * <i>before</i> the context is refreshed.\n\t * <p>The default implementation simply delegates to\n\t * {@link AbstractContextLoader#customizeContext(ConfigurableApplicationContext, MergedContextConfiguration)}.\n\t * @param context the newly created web application context\n\t * @param webMergedConfig the merged context configuration to use to load the\n\t * web application context\n\t * @see #loadContext(MergedContextConfiguration)\n\t * @see #customizeContext(ConfigurableApplicationContext, MergedContextConfiguration)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context",
      "webMergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 370
    },
    "return": "void",
    "signature": "protected void customizeContext(GenericWebApplicationContext context, WebMergedContextConfiguration webMergedConfig)",
    "source_code": "\tprotected void customizeContext(\n\t\t\tGenericWebApplicationContext context, WebMergedContextConfiguration webMergedConfig) {\n\n\t\tsuper.customizeContext(context, webMergedConfig);\n\t}"
  },
  "org.springframework.test.context.web.<unknown>#loadBeanDefinitions(context,webMergedConfig)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register classes in the supplied {@linkplain GenericWebApplicationContext context}\n\t * from the classes in the supplied {@link WebMergedContextConfiguration}.\n\t * <p>Each class must represent an <em>annotated class</em>. An\n\t * {@link AnnotatedBeanDefinitionReader} is used to register the appropriate\n\t * bean definitions.\n\t * @param context the context in which the annotated classes should be registered\n\t * @param webMergedConfig the merged configuration from which the classes should be retrieved\n\t * @see AbstractGenericWebContextLoader#loadBeanDefinitions\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context",
      "webMergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "protected void loadBeanDefinitions(GenericWebApplicationContext context, WebMergedContextConfiguration webMergedConfig)",
    "source_code": "\tprotected void loadBeanDefinitions(\n\t\t\tGenericWebApplicationContext context, WebMergedContextConfiguration webMergedConfig) {\n\n\t\tClass<?>[] annotatedClasses = webMergedConfig.getClasses();\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Registering annotated classes: \" + Arrays.toString(annotatedClasses));\n\t\t}\n\t\tnew AnnotatedBeanDefinitionReader(context).register(annotatedClasses);\n\t}"
  },
  "org.springframework.test.context.web.<unknown>#loadContextForAotRuntime(mergedConfig,initializer)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Load a {@link GenericWebApplicationContext} for AOT run-time execution based on\n\t * the supplied {@link MergedContextConfiguration} and\n\t * {@link ApplicationContextInitializer}.\n\t * @param mergedConfig the merged context configuration to use to load the\n\t * application context\n\t * @param initializer the {@code ApplicationContextInitializer} that should\n\t * be applied to the context in order to recreate bean definitions\n\t * @return a new web application context\n\t * @throws Exception if context loading failed\n\t * @since 6.0\n\t * @see AotContextLoader#loadContextForAotRuntime(MergedContextConfiguration, ApplicationContextInitializer)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig",
      "initializer"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "GenericWebApplicationContext",
    "signature": "public GenericWebApplicationContext loadContextForAotRuntime(MergedContextConfiguration mergedConfig,\n\t\t\tApplicationContextInitializer<ConfigurableApplicationContext> initializer)",
    "source_code": "\tpublic final GenericWebApplicationContext loadContextForAotRuntime(MergedContextConfiguration mergedConfig,\n\t\t\tApplicationContextInitializer<ConfigurableApplicationContext> initializer) throws Exception {\n\n\t\tAssert.notNull(mergedConfig, \"MergedContextConfiguration must not be null\");\n\t\tAssert.notNull(initializer, \"ApplicationContextInitializer must not be null\");\n\t\tif (!(mergedConfig instanceof WebMergedContextConfiguration webMergedConfig)) {\n\t\t\tthrow new IllegalArgumentException(\"\"\"\n\t\t\t\t\tCannot load WebApplicationContext from non-web merged context configuration %s. \\\n\t\t\t\t\tConsider annotating your test class with @WebAppConfiguration.\"\"\"\n\t\t\t\t\t\t.formatted(mergedConfig));\n\t\t}\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Loading WebApplicationContext for AOT runtime for \" + mergedConfig);\n\t\t}\n\t\telse if (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Loading WebApplicationContext for AOT runtime for test class \" +\n\t\t\t\t\tmergedConfig.getTestClass().getName());\n\t\t}\n\n\t\tvalidateMergedContextConfiguration(webMergedConfig);\n\n\t\tGenericWebApplicationContext context = createContext();\n\t\ttry {\n\t\t\tconfigureWebResources(context, webMergedConfig);\n\t\t\tprepareContext(context, webMergedConfig);\n\t\t\tinitializer.initialize(context);\n\t\t\tcustomizeContext(context, webMergedConfig);\n\t\t\tcontext.refresh();\n\t\t\treturn context;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new ContextLoadException(context, ex);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.web.<unknown>#modifyLocations(clazz,locations)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@code AnnotationConfigWebContextLoader} should be used as a\n\t * {@link org.springframework.test.context.SmartContextLoader SmartContextLoader},\n\t * not as a legacy {@link org.springframework.test.context.ContextLoader ContextLoader}.\n\t * Consequently, this method is not supported.\n\t * @throws UnsupportedOperationException in this implementation\n\t * @see org.springframework.test.context.support.AbstractContextLoader#modifyLocations\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "String[]",
    "signature": "protected String[] modifyLocations(Class<?> clazz, String... locations)",
    "source_code": "\tprotected String[] modifyLocations(Class<?> clazz, String... locations) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"AnnotationConfigWebContextLoader does not support the modifyLocations(Class, String...) method\");\n\t}"
  },
  "org.springframework.test.context.web.socket.<unknown>#customizeContext(context,mergedConfig)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "return": "void",
    "signature": "public void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig)",
    "source_code": "\tpublic void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig) {\n\t\tif (context instanceof WebApplicationContext wac) {\n\t\t\tServletContext sc = wac.getServletContext();\n\t\t\tif (sc != null) {\n\t\t\t\tsc.setAttribute(\"jakarta.websocket.server.ServerContainer\", new MockServerContainer());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertValue(content,expectedValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Evaluate the JSON path expression against the supplied {@code content}\n\t * and assert that the result is equal to the expected value.\n\t * @param content the JSON content\n\t * @param expectedValue the expected value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "expectedValue"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void assertValue(String content, @Nullable Object expectedValue)",
    "source_code": "\tpublic void assertValue(String content, @Nullable Object expectedValue) {\n\t\tObject actualValue = evaluateJsonPath(content);\n\t\tif ((actualValue instanceof List<?> actualValueList) && !(expectedValue instanceof List)) {\n\t\t\tif (actualValueList.isEmpty()) {\n\t\t\t\tAssertionErrors.fail(\"No matching value at JSON path \\\"\" + this.expression + \"\\\"\");\n\t\t\t}\n\t\t\tif (actualValueList.size() != 1) {\n\t\t\t\tAssertionErrors.fail(\"Got a list of values \" + actualValue +\n\t\t\t\t\t\t\" instead of the expected single value \" + expectedValue);\n\t\t\t}\n\t\t\tactualValue = actualValueList.get(0);\n\t\t}\n\t\telse if (actualValue != null && expectedValue != null &&\n\t\t\t\t!actualValue.getClass().equals(expectedValue.getClass())) {\n\t\t\ttry {\n\t\t\t\tactualValue = evaluateJsonPath(content, expectedValue.getClass());\n\t\t\t}\n\t\t\tcatch (AssertionError error) {\n\t\t\t\tString message = String.format(\n\t\t\t\t\t\"At JSON path \\\"%s\\\", value <%s> of type <%s> cannot be converted to type <%s>\",\n\t\t\t\t\tthis.expression, actualValue, ClassUtils.getDescriptiveType(actualValue),\n\t\t\t\t\tClassUtils.getDescriptiveType(expectedValue));\n\t\t\t\tthrow new AssertionError(message, error.getCause());\n\t\t\t}\n\t\t}\n\t\tAssertionErrors.assertEquals(\"JSON path \\\"\" + this.expression + \"\\\"\", expectedValue, actualValue);\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertValue(content,matcher)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Evaluate the JSON path expression against the supplied {@code content}\n\t * and assert the resulting value with the given {@code Matcher}.\n\t * @param content the JSON content\n\t * @param matcher the matcher with which to assert the result\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "public void assertValue(String content, Matcher<? super T> matcher)",
    "source_code": "\tpublic <T> void assertValue(String content, Matcher<? super T> matcher) {\n\t\tT value = (T) evaluateJsonPath(content);\n\t\tMatcherAssert.assertThat(\"JSON path \\\"\" + this.expression + \"\\\"\", value, matcher);\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertValue(content,matcher,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * An overloaded variant of {@link #assertValue(String, Matcher)} that also\n\t * accepts a target type for the resulting value. This can be useful for\n\t * matching numbers reliably for example coercing an integer into a double.\n\t * @param content the JSON content\n\t * @param matcher the matcher with which to assert the result\n\t * @param targetType the expected type of the resulting value\n\t * @since 4.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "matcher",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void assertValue(String content, Matcher<? super T> matcher, Class<T> targetType)",
    "source_code": "\tpublic <T> void assertValue(String content, Matcher<? super T> matcher, Class<T> targetType) {\n\t\tT value = (T) evaluateJsonPath(content, targetType);\n\t\tMatcherAssert.assertThat(\"JSON path \\\"\" + this.expression + \"\\\"\", value, matcher);\n\t}"
  },
  "org.springframework.test.util.<unknown>#evaluateJsonPath(content,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #evaluateJsonPath(String)} with a target type.\n\t * <p>This can be useful for matching numbers reliably for example coercing an\n\t * integer into a double.\n\t * @param content the content to evaluate against\n\t * @return the result of the evaluation\n\t * @throws AssertionError if the evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "Object",
    "signature": "public Object evaluateJsonPath(String content, Class<?> targetType)",
    "source_code": "\tpublic Object evaluateJsonPath(String content, Class<?> targetType) {\n\t\ttry {\n\t\t\treturn JsonPath.parse(content).read(this.expression, targetType);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tString message = \"No value at JSON path \\\"\" + this.expression + \"\\\"\";\n\t\t\tthrow new AssertionError(message, ex);\n\t\t}\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#formData(MultiValueMap<String,expected)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the body as form data and compare to the given {@code MultiValueMap}.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "expected"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher formData(MultiValueMap<String, String> expected)",
    "source_code": "\tpublic RequestMatcher formData(MultiValueMap<String, String> expected) {\n\t\treturn formData(expected, true);\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#formDataContains(Map<String,expected)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #formData(MultiValueMap)} that matches the given subset\n\t * of expected form parameters.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "expected"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher formDataContains(Map<String, String> expected)",
    "source_code": "\tpublic RequestMatcher formDataContains(Map<String, String> expected) {\n\t\tMultiValueMap<String, String> multiValueMap = new LinkedMultiValueMap<>(expected.size());\n\t\texpected.forEach(multiValueMap::add);\n\t\treturn formData(multiValueMap, false);\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#json(expectedJsonContent,strict)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the request body and the given string as JSON and assert the two\n\t * are \"similar\" - i.e. they contain the same attribute-value pairs\n\t * regardless of formatting.\n\t * <p>Can compare in two modes, depending on {@code strict} parameter value:\n\t * <ul>\n\t * <li>{@code true}: strict checking. Not extensible, and strict array ordering.</li>\n\t * <li>{@code false}: lenient checking. Extensible, and non-strict array ordering.</li>\n\t * </ul>\n\t * <p>Use of this matcher requires the <a\n\t * href=\"https://jsonassert.skyscreamer.org/\">JSONassert</a> library.\n\t * @param expectedJsonContent the expected JSON content\n\t * @param strict enables strict checking\n\t * @since 5.0.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedJsonContent",
      "strict"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher json(String expectedJsonContent, boolean strict)",
    "source_code": "\tpublic RequestMatcher json(String expectedJsonContent, boolean strict) {\n\t\treturn request -> {\n\t\t\ttry {\n\t\t\t\tMockClientHttpRequest mockRequest = (MockClientHttpRequest) request;\n\t\t\t\tthis.jsonHelper.assertJsonEqual(expectedJsonContent, mockRequest.getBodyAsString(), strict);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new AssertionError(\"Failed to parse expected or actual JSON request content\", ex);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#multipartData(MultiValueMap<String,expectedMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the body as multipart data and assert it contains exactly the\n\t * values from the given {@code MultiValueMap}. Values may be of type:\n\t * <ul>\n\t * <li>{@code String} - form field\n\t * <li>{@link Resource} - content from a file\n\t * <li>{@code byte[]} - other raw content\n\t * </ul>\n\t * <p><strong>Note:</strong> This method uses the Apache Commons FileUpload\n\t * library to parse the multipart data and it must be on the test classpath.\n\t * @param expectedMap the expected multipart values\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "expectedMap"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap)",
    "source_code": "\tpublic RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap) {\n\t\treturn multipartData(expectedMap, true);\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#multipartDataContains(Map<String,expectedMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #multipartData(MultiValueMap)} that does the same but\n\t * only for a subset of the actual values.\n\t * @param expectedMap the expected multipart values\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "expectedMap"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher multipartDataContains(Map<String, ?> expectedMap)",
    "source_code": "\tpublic RequestMatcher multipartDataContains(Map<String, ?> expectedMap) {\n\t\tMultiValueMap<String, Object> map = new LinkedMultiValueMap<>(expectedMap.size());\n\t\texpectedMap.forEach(map::add);\n\t\treturn multipartData(map, false);\n\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#connect(method,uri,ClientHttpRequest,requestCallback)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uri",
      "ClientHttpRequest",
      "requestCallback"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "Mono<ClientHttpResponse>",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n\n\t\tAtomicReference<WiretapClientHttpRequest> requestRef = new AtomicReference<>();\n\n\t\treturn this.delegate\n\t\t\t\t.connect(method, uri, request -> {\n\t\t\t\t\tWiretapClientHttpRequest wrapped = new WiretapClientHttpRequest(request);\n\t\t\t\t\trequestRef.set(wrapped);\n\t\t\t\t\treturn requestCallback.apply(wrapped);\n\t\t\t\t})\n\t\t\t\t.map(response ->  {\n\t\t\t\t\tWiretapClientHttpRequest wrappedRequest = requestRef.get();\n\t\t\t\t\tString header = WebTestClient.WEBTESTCLIENT_REQUEST_ID;\n\t\t\t\t\tString requestId = wrappedRequest.getHeaders().getFirst(header);\n\t\t\t\t\tAssert.state(requestId != null, () -> \"No \\\"\" + header + \"\\\" header\");\n\t\t\t\t\tWiretapClientHttpResponse wrappedResponse = new WiretapClientHttpResponse(response);\n\t\t\t\t\tthis.exchanges.put(requestId, new ClientExchangeInfo(wrappedRequest, wrappedResponse));\n\t\t\t\t\treturn wrappedResponse;\n\t\t\t\t});\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#postProcess(r,result,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "r",
      "result",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void postProcess(NativeWebRequest r, DeferredResult<T> result, Object value)",
    "source_code": "\t\t\t\t\tpublic <T> void postProcess(NativeWebRequest r, DeferredResult<T> result, Object value) {\n\t\t\t\t\t\tgetMvcResult(request).setAsyncResult(value);\n\t\t\t\t\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#postProcess(r,task,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "r",
      "task",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "void",
    "signature": "public void postProcess(NativeWebRequest r, Callable<T> task, Object value)",
    "source_code": "\t\t\t\t\tpublic <T> void postProcess(NativeWebRequest r, Callable<T> task, Object value) {\n\t\t\t\t\t\t// We got the result, must also wait for the dispatch\n\t\t\t\t\t\tgetMvcResult(request).setAsyncResult(value);\n\t\t\t\t\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#processHandlerException(request,response,handler,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,\n\t\t\t@Nullable Object handler, Exception ex)",
    "source_code": "\tprotected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,\n\t\t\t@Nullable Object handler, Exception ex) throws Exception {\n\n\t\tModelAndView mav = super.processHandlerException(request, response, handler, ex);\n\n\t\t// We got this far, exception was processed..\n\t\tDefaultMvcResult mvcResult = getMvcResult(request);\n\t\tmvcResult.setResolvedException(ex);\n\t\tmvcResult.setModelAndView(mav);\n\n\t\treturn mav;\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#render(mv,request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception {\n\n\t\tDefaultMvcResult mvcResult = getMvcResult(request);\n\t\tmvcResult.setModelAndView(mv);\n\t\tsuper.render(mv, request, response);\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#service(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "protected void service(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void service(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tregisterAsyncResultInterceptors(request);\n\n\t\tsuper.service(request, response);\n\n\t\tif (request.getAsyncContext() != null) {\n\t\t\tMockAsyncContext asyncContext;\n\t\t\tif (request.getAsyncContext() instanceof MockAsyncContext mockAsyncContext) {\n\t\t\t\tasyncContext = mockAsyncContext;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMockHttpServletRequest mockRequest = WebUtils.getNativeRequest(request, MockHttpServletRequest.class);\n\t\t\t\tAssert.notNull(mockRequest, \"Expected MockHttpServletRequest\");\n\t\t\t\tasyncContext = (MockAsyncContext) mockRequest.getAsyncContext();\n\t\t\t\tString requestClassName = request.getClass().getName();\n\t\t\t\tAssert.notNull(asyncContext, () ->\n\t\t\t\t\t\t\"Outer request wrapper \" + requestClassName + \" has an AsyncContext,\" +\n\t\t\t\t\t\t\t\t\"but it is not a MockAsyncContext, while the nested \" +\n\t\t\t\t\t\t\t\tmockRequest.getClass().getName() + \" does not have an AsyncContext at all.\");\n\t\t\t}\n\n\t\t\tCountDownLatch dispatchLatch = new CountDownLatch(1);\n\t\t\tasyncContext.addDispatchHandler(dispatchLatch::countDown);\n\t\t\tgetMvcResult(request).setAsyncDispatchLatch(dispatchLatch);\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#connect(method,uri,ClientHttpRequest,requestCallback)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uri",
      "ClientHttpRequest",
      "requestCallback"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "Mono<ClientHttpResponse>",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri, Function<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect(\n\t\t\tHttpMethod method, URI uri, Function<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n\n\t\tRequestBuilder requestBuilder = adaptRequest(method, uri, requestCallback);\n\t\ttry {\n\t\t\tMvcResult mvcResult = this.mockMvc.perform(requestBuilder).andReturn();\n\t\t\tif (mvcResult.getRequest().isAsyncStarted()) {\n\t\t\t\tmvcResult.getAsyncResult();\n\t\t\t\tmvcResult = this.mockMvc.perform(asyncDispatch(mvcResult)).andReturn();\n\t\t\t}\n\t\t\treturn Mono.just(adaptResponse(mvcResult));\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#file(name,content)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a new {@link MockMultipartFile} with the given content.\n\t * @param name the name of the file\n\t * @param content the content of the file\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "content"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "MockMultipartHttpServletRequestBuilder",
    "signature": "public MockMultipartHttpServletRequestBuilder file(String name, byte[] content)",
    "source_code": "\tpublic MockMultipartHttpServletRequestBuilder file(String name, byte[] content) {\n\t\tthis.files.add(new MockMultipartFile(name, content));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#flashAttr(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set an \"input\" flash attribute.\n\t * @param name the flash attribute name\n\t * @param value the flash attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 492
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder flashAttr(String name, Object value)",
    "source_code": "\tpublic MockHttpServletRequestBuilder flashAttr(String name, Object value) {\n\t\taddToMap(this.flashAttributes, name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#flashAttrs(Map<String,flashAttributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set flash attributes.\n\t * @param flashAttributes the flash attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "flashAttributes"
    ],
    "position": {
      "column": 1,
      "line": 501
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder flashAttrs(Map<String, Object> flashAttributes)",
    "source_code": "\tpublic MockHttpServletRequestBuilder flashAttrs(Map<String, Object> flashAttributes) {\n\t\tAssert.notEmpty(flashAttributes, \"'flashAttributes' must not be empty\");\n\t\tflashAttributes.forEach(this::flashAttr);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#header(name,values)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a header to the request. Values are always added.\n\t * @param name the header name\n\t * @param values one or more header values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder header(String name, Object... values)",
    "source_code": "\tpublic MockHttpServletRequestBuilder header(String name, Object... values) {\n\t\taddToMultiValueMap(this.headers, name, values);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#param(name,values)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a request parameter to {@link MockHttpServletRequest#getParameterMap()}.\n\t * <p>In the Servlet API, a request parameter may be parsed from the query\n\t * string and/or from the body of an {@code application/x-www-form-urlencoded}\n\t * request. This method simply adds to the request parameter map. You may\n\t * also use add Servlet request parameters by specifying the query or form\n\t * data through one of the following:\n\t * <ul>\n\t * <li>Supply a URL with a query to {@link MockMvcRequestBuilders}.\n\t * <li>Add query params via {@link #queryParam} or {@link #queryParams}.\n\t * <li>Provide {@link #content} with {@link #contentType}\n\t * {@code application/x-www-form-urlencoded}.\n\t * </ul>\n\t * @param name the parameter name\n\t * @param values one or more values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder param(String name, String... values)",
    "source_code": "\tpublic MockHttpServletRequestBuilder param(String name, String... values) {\n\t\taddToMultiValueMap(this.parameters, name, values);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#params(MultiValueMap<String,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #param(String, String...)} with a {@link MultiValueMap}.\n\t * @param params the parameters to add\n\t * @since 4.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder params(MultiValueMap<String, String> params)",
    "source_code": "\tpublic MockHttpServletRequestBuilder params(MultiValueMap<String, String> params) {\n\t\tparams.forEach((name, values) -> {\n\t\t\tfor (String value : values) {\n\t\t\t\tthis.parameters.add(name, value);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#queryParam(name,values)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Append to the query string and also add to the\n\t * {@link #param(String, String...) request parameters} map. The parameter\n\t * name and value are encoded when they are added to the query string.\n\t * @param name the parameter name\n\t * @param values one or more values\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 403
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder queryParam(String name, String... values)",
    "source_code": "\tpublic MockHttpServletRequestBuilder queryParam(String name, String... values) {\n\t\tparam(name, values);\n\t\tthis.queryParams.addAll(name, Arrays.asList(values));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#queryParams(MultiValueMap<String,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Append to the query string and also add to the\n\t * {@link #params(MultiValueMap) request parameters} map. The parameter\n\t * name and value are encoded when they are added to the query string.\n\t * @param params the parameters to add\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 416
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder queryParams(MultiValueMap<String, String> params)",
    "source_code": "\tpublic MockHttpServletRequestBuilder queryParams(MultiValueMap<String, String> params) {\n\t\tparams(params);\n\t\tthis.queryParams.addAll(params);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#requestAttr(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a request attribute.\n\t * @param name the attribute name\n\t * @param value the attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 462
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder requestAttr(String name, Object value)",
    "source_code": "\tpublic MockHttpServletRequestBuilder requestAttr(String name, Object value) {\n\t\taddToMap(this.requestAttributes, name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#sessionAttr(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a session attribute.\n\t * @param name the session attribute name\n\t * @param value the session attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 472
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder sessionAttr(String name, Object value)",
    "source_code": "\tpublic MockHttpServletRequestBuilder sessionAttr(String name, Object value) {\n\t\taddToMap(this.sessionAttributes, name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#sessionAttrs(Map<String,sessionAttributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set session attributes.\n\t * @param sessionAttributes the session attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "sessionAttributes"
    ],
    "position": {
      "column": 1,
      "line": 481
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder sessionAttrs(Map<String, Object> sessionAttributes)",
    "source_code": "\tpublic MockHttpServletRequestBuilder sessionAttrs(Map<String, Object> sessionAttributes) {\n\t\tAssert.notEmpty(sessionAttributes, \"'sessionAttributes' must not be empty\");\n\t\tsessionAttributes.forEach(this::sessionAttr);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#attribute(name,matcher)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a model attribute value with the given Hamcrest {@link Matcher}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attribute(String name, Matcher<? super T> matcher)",
    "source_code": "\tpublic <T> ResultMatcher attribute(String name, Matcher<? super T> matcher) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tassertThat(\"Model attribute '\" + name + \"'\", (T) mav.getModel().get(name), matcher);\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#attribute(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a model attribute value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attribute(String name, @Nullable Object value)",
    "source_code": "\tpublic ResultMatcher attribute(String name, @Nullable Object value) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tassertEquals(\"Model attribute '\" + name + \"'\", value, mav.getModel().get(name));\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#attributeErrorCount(name,expectedCount)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the given model attribute(s) have errors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "expectedCount"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attributeErrorCount(String name, int expectedCount)",
    "source_code": "\tpublic ResultMatcher attributeErrorCount(String name, int expectedCount) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tErrors errors = getBindingResult(mav, name);\n\t\t\tassertEquals(\"Binding/validation error count for attribute '\" + name + \"',\",\n\t\t\t\t\texpectedCount, errors.getErrorCount());\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#attributeHasFieldErrorCode(name,fieldName,error)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a field error code for a model attribute using exact String match.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "fieldName",
      "error"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attributeHasFieldErrorCode(String name, String fieldName, String error)",
    "source_code": "\tpublic ResultMatcher attributeHasFieldErrorCode(String name, String fieldName, String error) {\n\t\treturn mvcResult -> {\n\t\t\tModelAndView mav = getModelAndView(mvcResult);\n\t\t\tBindingResult result = getBindingResult(mav, name);\n\t\t\tassertTrue(\"No errors for attribute '\" + name + \"'\", result.hasErrors());\n\t\t\tFieldError fieldError = result.getFieldError(fieldName);\n\t\t\tassertNotNull(\"No errors for field '\" + fieldName + \"' of attribute '\" + name + \"'\", fieldError);\n\t\t\tString code = fieldError.getCode();\n\t\t\tassertEquals(\"Field error code\", error, code);\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#attributeHasFieldErrorCode(name,fieldName,matcher)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a field error code for a model attribute using a {@link org.hamcrest.Matcher}.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "fieldName",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attributeHasFieldErrorCode(String name, String fieldName,\n\t\t\tMatcher<? super String> matcher)",
    "source_code": "\tpublic ResultMatcher attributeHasFieldErrorCode(String name, String fieldName,\n\t\t\tMatcher<? super String> matcher) {\n\n\t\treturn mvcResult -> {\n\t\t\tModelAndView mav = getModelAndView(mvcResult);\n\t\t\tBindingResult result = getBindingResult(mav, name);\n\t\t\tassertTrue(\"No errors for attribute '\" + name + \"'\", result.hasErrors());\n\t\t\tFieldError fieldError = result.getFieldError(fieldName);\n\t\t\tassertNotNull(\"No errors for field '\" + fieldName + \"' of attribute '\" + name + \"'\", fieldError);\n\t\t\tString code = fieldError.getCode();\n\t\t\tassertThat(\"Field name '\" + fieldName + \"' of attribute '\" + name + \"'\", code, matcher);\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#attributeHasFieldErrors(name,fieldNames)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the given model attribute field(s) have errors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "fieldNames"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attributeHasFieldErrors(String name, String... fieldNames)",
    "source_code": "\tpublic ResultMatcher attributeHasFieldErrors(String name, String... fieldNames) {\n\t\treturn mvcResult -> {\n\t\t\tModelAndView mav = getModelAndView(mvcResult);\n\t\t\tBindingResult result = getBindingResult(mav, name);\n\t\t\tassertTrue(\"No errors for attribute '\" + name + \"'\", result.hasErrors());\n\t\t\tfor (String fieldName : fieldNames) {\n\t\t\t\tboolean hasFieldErrors = result.hasFieldErrors(fieldName);\n\t\t\t\tassertTrue(\"No errors for field '\" + fieldName + \"' of attribute '\" + name + \"'\", hasFieldErrors);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#printHandler(handler,interceptors)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Print the handler.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "void",
    "signature": "protected void printHandler(@Nullable Object handler, @Nullable HandlerInterceptor[] interceptors)",
    "source_code": "\tprotected void printHandler(@Nullable Object handler, @Nullable HandlerInterceptor[] interceptors)\n\t\t\tthrows Exception {\n\n\t\tif (handler == null) {\n\t\t\tthis.printer.printValue(\"Type\", null);\n\t\t}\n\t\telse {\n\t\t\tif (handler instanceof HandlerMethod handlerMethod) {\n\t\t\t\tthis.printer.printValue(\"Type\", handlerMethod.getBeanType().getName());\n\t\t\t\tthis.printer.printValue(\"Method\", handlerMethod);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.printer.printValue(\"Type\", handler.getClass().getName());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#addBean(name,bean)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "void",
    "signature": "public void addBean(String name, Object bean)",
    "source_code": "\tpublic void addBean(String name, Object bean) {\n\t\tthis.beanFactory.addBean(name, bean);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#addFilter(filter,urlPatterns)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filter",
      "urlPatterns"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "T",
    "signature": "public T addFilter(Filter filter, String... urlPatterns)",
    "source_code": "\tpublic final <T extends B> T addFilter(Filter filter, String... urlPatterns) {\n\t\tAssert.notNull(filter, \"filter cannot be null\");\n\t\tAssert.notNull(urlPatterns, \"urlPatterns cannot be null\");\n\t\tif (urlPatterns.length > 0) {\n\t\t\tfilter = new PatternMappingFilterProxy(filter, urlPatterns);\n\t\t}\n\t\tthis.filters.add(filter);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#addMappedInterceptors(pathPatterns,interceptors)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add interceptors mapped to a set of path patterns.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathPatterns",
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "StandaloneMockMvcBuilder",
    "signature": "public StandaloneMockMvcBuilder addMappedInterceptors(@Nullable String[] pathPatterns, HandlerInterceptor... interceptors)",
    "source_code": "\tpublic StandaloneMockMvcBuilder addMappedInterceptors(\n\t\t\t@Nullable String[] pathPatterns, HandlerInterceptor... interceptors) {\n\n\t\tfor (HandlerInterceptor interceptor : interceptors) {\n\t\t\tthis.mappedInterceptors.add(new MappedInterceptor(pathPatterns, null, interceptor));\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#addPlaceholderValue(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * In a standalone setup there is no support for placeholder values embedded in\n\t * request mappings. This method allows manually provided placeholder values so they\n\t * can be resolved. Alternatively consider creating a test that initializes a\n\t * {@link WebApplicationContext}.\n\t * @since 4.2.8\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 371
    },
    "return": "StandaloneMockMvcBuilder",
    "signature": "public StandaloneMockMvcBuilder addPlaceholderValue(String name, String value)",
    "source_code": "\tpublic StandaloneMockMvcBuilder addPlaceholderValue(String name, String value) {\n\t\tthis.placeholderValues.put(name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#applyBeanPostProcessorsAfterInitialization(existingBean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 480
    },
    "return": "Object",
    "signature": "public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)",
    "source_code": "\t\tpublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) {\n\t\t\treturn existingBean;\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#applyBeanPostProcessorsBeforeInitialization(existingBean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 475
    },
    "return": "Object",
    "signature": "public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)",
    "source_code": "\t\tpublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) {\n\t\t\treturn existingBean;\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#applyBeanPropertyValues(existingBean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "void",
    "signature": "public void applyBeanPropertyValues(Object existingBean, String beanName)",
    "source_code": "\t\tpublic void applyBeanPropertyValues(Object existingBean, String beanName) throws BeansException {\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#autowire(beanClass,autowireMode,dependencyCheck)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "Object",
    "signature": "public Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck)",
    "source_code": "\t\tpublic Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck) {\n\t\t\treturn BeanUtils.instantiateClass(beanClass);\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#autowireBeanProperties(existingBean,autowireMode,dependencyCheck)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 439
    },
    "return": "void",
    "signature": "public void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)",
    "source_code": "\t\tpublic void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck) {\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#configureBean(existingBean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "Object",
    "signature": "public Object configureBean(Object existingBean, String beanName)",
    "source_code": "\t\tpublic Object configureBean(Object existingBean, String beanName) {\n\t\t\treturn existingBean;\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#createBean(beanClass,autowireMode,dependencyCheck)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 425
    },
    "return": "Object",
    "signature": "public Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck)",
    "source_code": "\t\tpublic Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck) {\n\t\t\treturn BeanUtils.instantiateClass(beanClass);\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#findAllAnnotationsOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "Set<A>",
    "signature": "public Set<A> findAllAnnotationsOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> Set<A> findAllAnnotationsOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\treturn this.beanFactory.findAllAnnotationsOnBean(beanName, annotationType, allowFactoryBeanInit);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#findAnnotationOnBean(beanName,annotationType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)\n\t\t\tthrows NoSuchBeanDefinitionException{\n\n\t\treturn this.beanFactory.findAnnotationOnBean(beanName, annotationType);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#findAnnotationOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\treturn this.beanFactory.findAnnotationOnBean(beanName, annotationType, allowFactoryBeanInit);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBean(name,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "Object",
    "signature": "public Object getBean(String name, Object... args)",
    "source_code": "\tpublic Object getBean(String name, Object... args) throws BeansException {\n\t\treturn this.beanFactory.getBean(name, args);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBean(name,requiredType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "T",
    "signature": "public T getBean(String name, Class<T> requiredType)",
    "source_code": "\tpublic <T> T getBean(String name, Class<T> requiredType) throws BeansException {\n\t\treturn this.beanFactory.getBean(name, requiredType);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBean(requiredType,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "T",
    "signature": "public T getBean(Class<T> requiredType, Object... args)",
    "source_code": "\tpublic <T> T getBean(Class<T> requiredType, Object... args) throws BeansException {\n\t\treturn this.beanFactory.getBean(requiredType, args);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeanNamesForType(type,includeNonSingletons,allowEagerInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "String[]",
    "signature": "public String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {\n\t\treturn this.beanFactory.getBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeanProvider(requiredType,allowEagerInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "ObjectProvider<T>",
    "signature": "public ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit)",
    "source_code": "\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit) {\n\t\treturn this.beanFactory.getBeanProvider(requiredType, allowEagerInit);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeansOfType(type,includeNonSingletons,allowEagerInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "T>",
    "signature": "public T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic <T> Map<String, T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException {\n\n\t\treturn this.beanFactory.getBeansOfType(type, includeNonSingletons, allowEagerInit);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getHandlerMapping(mvcConversionService,mvcResourceUrlProvider)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mvcConversionService",
      "mvcResourceUrlProvider"
    ],
    "position": {
      "column": 1,
      "line": 474
    },
    "return": "RequestMappingHandlerMapping",
    "signature": "public RequestMappingHandlerMapping getHandlerMapping(FormattingConversionService mvcConversionService,\n\t\t\t\tResourceUrlProvider mvcResourceUrlProvider)",
    "source_code": "\t\tpublic RequestMappingHandlerMapping getHandlerMapping(\n\t\t\t\tFormattingConversionService mvcConversionService,\n\t\t\t\tResourceUrlProvider mvcResourceUrlProvider) {\n\n\t\t\tRequestMappingHandlerMapping handlerMapping = handlerMappingFactory.get();\n\t\t\thandlerMapping.setEmbeddedValueResolver(new StaticStringValueResolver(placeholderValues));\n\t\t\tif (patternParser == null && preferPathMatcher) {\n\t\t\t\thandlerMapping.setPatternParser(null);\n\t\t\t\thandlerMapping.setUseSuffixPatternMatch(useSuffixPatternMatch);\n\t\t\t\tif (removeSemicolonContent != null) {\n\t\t\t\t\tUrlPathHelper pathHelper = new UrlPathHelper();\n\t\t\t\t\tpathHelper.setRemoveSemicolonContent(removeSemicolonContent);\n\t\t\t\t\thandlerMapping.setUrlPathHelper(pathHelper);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (patternParser != null) {\n\t\t\t\thandlerMapping.setPatternParser(patternParser);\n\t\t\t}\n\t\t\thandlerMapping.setUseTrailingSlashMatch(useTrailingSlashPatternMatch);\n\t\t\thandlerMapping.setOrder(0);\n\t\t\thandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));\n\t\t\treturn handlerMapping;\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getMessage(code,args,defaultMessage,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale) {\n\t\treturn this.messageSource.getMessage(code, args, defaultMessage, locale);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getMessage(code,args,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, Locale locale) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(code, args, locale);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getMessage(resolvable,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(resolvable, locale);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#initializeBean(existingBean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "Object",
    "signature": "public Object initializeBean(Object existingBean, String beanName)",
    "source_code": "\t\tpublic Object initializeBean(Object existingBean, String beanName) throws BeansException {\n\t\t\tif (existingBean instanceof ApplicationContextAware applicationContextAware) {\n\t\t\t\tapplicationContextAware.setApplicationContext(StubWebApplicationContext.this);\n\t\t\t}\n\t\t\treturn existingBean;\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#isTypeMatch(name,typeToMatch)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "typeToMatch"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "boolean",
    "signature": "public boolean isTypeMatch(String name, Class<?> typeToMatch)",
    "source_code": "\tpublic boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException {\n\t\treturn this.beanFactory.isTypeMatch(name, typeToMatch);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#resolveBeanByName(name,descriptor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 453
    },
    "return": "Object",
    "signature": "public Object resolveBeanByName(String name, DependencyDescriptor descriptor)",
    "source_code": "\t\tpublic Object resolveBeanByName(String name, DependencyDescriptor descriptor) throws BeansException {\n\t\t\tthrow new UnsupportedOperationException(\"Dependency resolution not supported\");\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#resolveDependency(descriptor,requestingBeanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "Object",
    "signature": "public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName)",
    "source_code": "\t\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName) {\n\t\t\tthrow new UnsupportedOperationException(\"Dependency resolution not supported\");\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#resolveDependency(descriptor,requestingBeanName,autowiredBeanNames,typeConverter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "requestingBeanName",
      "autowiredBeanNames",
      "typeConverter"
    ],
    "position": {
      "column": 1,
      "line": 465
    },
    "return": "Object",
    "signature": "public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,\n\t\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter)",
    "source_code": "\t\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,\n\t\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {\n\t\t\tthrow new UnsupportedOperationException(\"Dependency resolution not supported\");\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#resolveViewName(viewName,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 613
    },
    "return": "View",
    "signature": "public View resolveViewName(String viewName, Locale locale)",
    "source_code": "\t\tpublic View resolveViewName(String viewName, Locale locale) {\n\t\t\treturn this.view;\n\t\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#addTransactionalMethod(clazz,mappedName,attr)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute for a transactional method.\n\t * Method names can end or start with \"*\" for matching multiple methods.\n\t * @param clazz target interface or class\n\t * @param mappedName mapped method name\n\t * @param attr attribute associated with the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mappedName",
      "attr"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "void",
    "signature": "public void addTransactionalMethod(Class<?> clazz, String mappedName, TransactionAttribute attr)",
    "source_code": "\tpublic void addTransactionalMethod(Class<?> clazz, String mappedName, TransactionAttribute attr) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(mappedName, \"Mapped name must not be null\");\n\t\tString name = clazz.getName() + '.'  + mappedName;\n\n\t\tMethod[] methods = clazz.getDeclaredMethods();\n\t\tList<Method> matchingMethods = new ArrayList<>();\n\t\tfor (Method method : methods) {\n\t\t\tif (isMatch(method.getName(), mappedName)) {\n\t\t\t\tmatchingMethods.add(method);\n\t\t\t}\n\t\t}\n\t\tif (matchingMethods.isEmpty()) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Could not find method '\" + mappedName + \"' on class [\" + clazz.getName() + \"]\");\n\t\t}\n\n\t\t// Register all matching methods\n\t\tfor (Method method : matchingMethods) {\n\t\t\tString regMethodName = this.methodNameMap.get(method);\n\t\t\tif (regMethodName == null || (!regMethodName.equals(name) && regMethodName.length() <= name.length())) {\n\t\t\t\t// No already registered method name, or more specific\n\t\t\t\t// method name specification now -> (re-)register method.\n\t\t\t\tif (logger.isDebugEnabled() && regMethodName != null) {\n\t\t\t\t\tlogger.debug(\"Replacing attribute for transactional method [\" + method + \"]: current name '\" +\n\t\t\t\t\t\t\tname + \"' is more specific than '\" + regMethodName + \"'\");\n\t\t\t\t}\n\t\t\t\tthis.methodNameMap.put(method, name);\n\t\t\t\taddTransactionalMethod(method, attr);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Keeping attribute for transactional method [\" + method + \"]: current name '\" +\n\t\t\t\t\t\t\tname + \"' is not more specific than '\" + regMethodName + \"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#addTransactionalMethod(method,attr)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute for a transactional method.\n\t * @param method the method\n\t * @param attr attribute associated with the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "attr"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "void",
    "signature": "public void addTransactionalMethod(Method method, TransactionAttribute attr)",
    "source_code": "\tpublic void addTransactionalMethod(Method method, TransactionAttribute attr) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tAssert.notNull(attr, \"TransactionAttribute must not be null\");\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Adding transactional method [\" + method + \"] with attribute [\" + attr + \"]\");\n\t\t}\n\t\tif (this.embeddedValueResolver != null && attr instanceof DefaultTransactionAttribute dta) {\n\t\t\tdta.resolveAttributeStrings(this.embeddedValueResolver);\n\t\t}\n\t\tthis.transactionAttributeMap.put(method, attr);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#addTransactionalMethod(methodName,attr)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute for a transactional method.\n\t * <p>Method names can be exact matches, or of the pattern \"xxx*\",\n\t * \"*xxx\", or \"*xxx*\" for matching multiple methods.\n\t * @param methodName the name of the method\n\t * @param attr attribute associated with the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodName",
      "attr"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void addTransactionalMethod(String methodName, TransactionAttribute attr)",
    "source_code": "\tpublic void addTransactionalMethod(String methodName, TransactionAttribute attr) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Adding transactional method [\" + methodName + \"] with attribute [\" + attr + \"]\");\n\t\t}\n\t\tif (this.embeddedValueResolver != null && attr instanceof DefaultTransactionAttribute dta) {\n\t\t\tdta.resolveAttributeStrings(this.embeddedValueResolver);\n\t\t}\n\t\tthis.nameMap.put(methodName, attr);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#addTransactionalMethod(name,attr)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute for a transactional method.\n\t * <p>Method names can end or start with \"*\" for matching multiple methods.\n\t * @param name class and method name, separated by a dot\n\t * @param attr attribute associated with the method\n\t * @throws IllegalArgumentException in case of an invalid name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "attr"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "public void addTransactionalMethod(String name, TransactionAttribute attr)",
    "source_code": "\tpublic void addTransactionalMethod(String name, TransactionAttribute attr) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tint lastDotIndex = name.lastIndexOf('.');\n\t\tif (lastDotIndex == -1) {\n\t\t\tthrow new IllegalArgumentException(\"'\" + name + \"' is not a valid method name: format is FQN.methodName\");\n\t\t}\n\t\tString className = name.substring(0, lastDotIndex);\n\t\tString methodName = name.substring(lastDotIndex + 1);\n\t\tClass<?> clazz = ClassUtils.resolveClassName(className, this.beanClassLoader);\n\t\taddTransactionalMethod(clazz, methodName, attr);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#computeTransactionAttribute(method,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Same signature as {@link #getTransactionAttribute}, but doesn't cache the result.\n\t * {@link #getTransactionAttribute} is effectively a caching decorator for this method.\n\t * <p>As of 4.1.8, this method can be overridden.\n\t * @since 4.1.8\n\t * @see #getTransactionAttribute\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "TransactionAttribute",
    "signature": "protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tprotected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class<?> targetClass) {\n\t\t// Don't allow non-public methods, as configured.\n\t\tif (allowPublicMethodsOnly() && !Modifier.isPublic(method.getModifiers())) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// The method may be on an interface, but we need attributes from the target class.\n\t\t// If the target class is null, the method will be unchanged.\n\t\tMethod specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);\n\n\t\t// First try is the method in the target class.\n\t\tTransactionAttribute txAttr = findTransactionAttribute(specificMethod);\n\t\tif (txAttr != null) {\n\t\t\treturn txAttr;\n\t\t}\n\n\t\t// Second try is the transaction attribute on the target class.\n\t\ttxAttr = findTransactionAttribute(specificMethod.getDeclaringClass());\n\t\tif (txAttr != null && ClassUtils.isUserLevelMethod(method)) {\n\t\t\treturn txAttr;\n\t\t}\n\n\t\tif (specificMethod != method) {\n\t\t\t// Fallback is to look at the original method.\n\t\t\ttxAttr = findTransactionAttribute(method);\n\t\t\tif (txAttr != null) {\n\t\t\t\treturn txAttr;\n\t\t\t}\n\t\t\t// Last fallback is the class of the original method.\n\t\t\ttxAttr = findTransactionAttribute(method.getDeclaringClass());\n\t\t\tif (txAttr != null && ClassUtils.isUserLevelMethod(method)) {\n\t\t\t\treturn txAttr;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#getCacheKey(method,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine a cache key for the given method and target class.\n\t * <p>Must not produce same key for overloaded methods.\n\t * Must produce same key for different instances of the same method.\n\t * @param method the method (never {@code null})\n\t * @param targetClass the target class (may be {@code null})\n\t * @return the cache key (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "Object",
    "signature": "protected Object getCacheKey(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tprotected Object getCacheKey(Method method, @Nullable Class<?> targetClass) {\n\t\treturn new MethodClassKey(method, targetClass);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#getTransactionAttribute(method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "TransactionAttribute",
    "signature": "public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic TransactionAttribute getTransactionAttribute(Method method, @Nullable Class<?> targetClass) {\n\t\treturn (ClassUtils.isUserLevelMethod(method) ? this.transactionAttribute : null);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#initMethodMap(Map<String,methodMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the specified {@link #setMethodMap(java.util.Map) \"methodMap\"}, if any.\n\t * @param methodMap a Map from method names to {@code TransactionAttribute} instances\n\t * @see #setMethodMap\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "methodMap"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "protected void initMethodMap(@Nullable Map<String, TransactionAttribute> methodMap)",
    "source_code": "\tprotected void initMethodMap(@Nullable Map<String, TransactionAttribute> methodMap) {\n\t\tif (methodMap != null) {\n\t\t\tmethodMap.forEach(this::addTransactionalMethod);\n\t\t}\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#isMatch(methodName,mappedName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return if the given method name matches the mapped name.\n\t * <p>The default implementation checks for \"xxx*\", \"*xxx\" and \"*xxx*\"\n\t * matches, as well as direct equality.\n\t * @param methodName the method name of the class\n\t * @param mappedName the name in the descriptor\n\t * @return if the names match\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "mappedName"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "boolean",
    "signature": "protected boolean isMatch(String methodName, String mappedName)",
    "source_code": "\tprotected boolean isMatch(String methodName, String mappedName) {\n\t\treturn PatternMatchUtils.simpleMatch(mappedName, methodName);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#matches(method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\tTransactionAttributeSource tas = getTransactionAttributeSource();\n\t\treturn (tas == null || tas.getTransactionAttribute(method, targetClass) != null);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#setMethodMap(Map<String,methodMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a name/attribute map, consisting of \"FQCN.method\" method names\n\t * (e.g. \"com.mycompany.mycode.MyClass.myMethod\") and\n\t * {@link TransactionAttribute} instances (or Strings to be converted\n\t * to {@code TransactionAttribute} instances).\n\t * <p>Intended for configuration via setter injection, typically within\n\t * a Spring bean factory. Relies on {@link #afterPropertiesSet()}\n\t * being called afterwards.\n\t * @param methodMap said {@link Map} from method name to attribute value\n\t * @see TransactionAttribute\n\t * @see TransactionAttributeEditor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "methodMap"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void setMethodMap(Map<String, TransactionAttribute> methodMap)",
    "source_code": "\tpublic void setMethodMap(Map<String, TransactionAttribute> methodMap) {\n\t\tthis.methodMap = methodMap;\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#setNameMap(Map<String,nameMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a name/attribute map, consisting of method names\n\t * (e.g. \"myMethod\") and {@link TransactionAttribute} instances.\n\t * @see #setProperties\n\t * @see TransactionAttribute\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "nameMap"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void setNameMap(Map<String, TransactionAttribute> nameMap)",
    "source_code": "\tpublic void setNameMap(Map<String, TransactionAttribute> nameMap) {\n\t\tnameMap.forEach(this::addTransactionalMethod);\n\t}"
  },
  "org.springframework.ui.freemarker.<unknown>#setFreemarkerVariables(Map<String,variables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Map that contains well-known FreeMarker objects which will be passed\n\t * to FreeMarker's {@code Configuration.setAllSharedVariables()} method.\n\t * @see freemarker.template.Configuration#setAllSharedVariables\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "variables"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void setFreemarkerVariables(Map<String, Object> variables)",
    "source_code": "\tpublic void setFreemarkerVariables(Map<String, Object> variables) {\n\t\tthis.freemarkerVariables = variables;\n\t}"
  },
  "org.springframework.util.<unknown>#accessibleConstructor(clazz,parameterTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain an accessible constructor for the given class and parameters.\n\t * @param clazz the clazz to check\n\t * @param parameterTypes the parameter types of the desired constructor\n\t * @return the constructor reference\n\t * @throws NoSuchMethodException if no such constructor exists\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "Constructor<T>",
    "signature": "public Constructor<T> accessibleConstructor(Class<T> clazz, Class<?>... parameterTypes)",
    "source_code": "\tpublic static <T> Constructor<T> accessibleConstructor(Class<T> clazz, Class<?>... parameterTypes)\n\t\t\tthrows NoSuchMethodException {\n\n\t\tConstructor<T> ctor = clazz.getDeclaredConstructor(parameterTypes);\n\t\tmakeAccessible(ctor);\n\t\treturn ctor;\n\t}"
  },
  "org.springframework.util.<unknown>#add(Entry<K,kListEntry)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "kListEntry"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "boolean",
    "signature": "public boolean add(Entry<K, List<V>> kListEntry)",
    "source_code": "\t\tpublic boolean add(Entry<K, List<V>> kListEntry) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.util.<unknown>#add(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "void",
    "signature": "public void add(K key, @Nullable V value)",
    "source_code": "\tpublic void add(K key, @Nullable V value) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#addAll(Entry<K,c)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "c"
    ],
    "position": {
      "column": 1,
      "line": 399
    },
    "return": "boolean",
    "signature": "public boolean addAll(Collection<? extends Entry<K, List<V>>> c)",
    "source_code": "\t\tpublic boolean addAll(Collection<? extends Entry<K, List<V>>> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.util.<unknown>#addAll(MultiValueMap<K,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<K",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<K, V> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<K, V> values) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#addAll(key,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "public void addAll(K key, List<? extends V> values)",
    "source_code": "\tpublic void addAll(K key, List<? extends V> values) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#addIfAbsent(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void addIfAbsent(K key, @Nullable V value)",
    "source_code": "\tpublic void addIfAbsent(K key, @Nullable V value) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#addObjectToArray(array,obj)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Append the given object to the given array, returning a new array\n\t * consisting of the input array contents plus the given object.\n\t * @param array the array to append to (can be {@code null})\n\t * @param obj the object to append\n\t * @return the new array (of the same component type; never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "A[]",
    "signature": "public A[] addObjectToArray(@Nullable A[] array, @Nullable O obj)",
    "source_code": "\tpublic static <A, O extends A> A[] addObjectToArray(@Nullable A[] array, @Nullable O obj) {\n\t\treturn addObjectToArray(array, obj, (array != null ? array.length : 0));\n\t}"
  },
  "org.springframework.util.<unknown>#addObjectToArray(array,obj,position)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given object to the given array at the specified position, returning\n\t * a new array consisting of the input array contents plus the given object.\n\t * @param array the array to add to (can be {@code null})\n\t * @param obj the object to append\n\t * @param position the position at which to add the object\n\t * @return the new array (of the same component type; never {@code null})\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "obj",
      "position"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "A[]",
    "signature": "public A[] addObjectToArray(@Nullable A[] array, @Nullable O obj, int position)",
    "source_code": "\tpublic static <A, O extends A> A[] addObjectToArray(@Nullable A[] array, @Nullable O obj, int position) {\n\t\tClass<?> componentType = Object.class;\n\t\tif (array != null) {\n\t\t\tcomponentType = array.getClass().getComponentType();\n\t\t}\n\t\telse if (obj != null) {\n\t\t\tcomponentType = obj.getClass();\n\t\t}\n\t\tint newArrayLength = (array != null ? array.length + 1 : 1);\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tA[] newArray = (A[]) Array.newInstance(componentType, newArrayLength);\n\t\tif (array != null) {\n\t\t\tSystem.arraycopy(array, 0, newArray, 0, position);\n\t\t\tSystem.arraycopy(array, position, newArray, position + 1, array.length - position);\n\t\t}\n\t\tnewArray[position] = obj;\n\t\treturn newArray;\n\t}"
  },
  "org.springframework.util.<unknown>#appendMd5DigestAsHex(bytes,builder)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Append a hexadecimal string representation of the MD5 digest of the given\n\t * bytes to the given {@link StringBuilder}.\n\t * @param bytes the bytes to calculate the digest over\n\t * @param builder the string builder to append the digest to\n\t * @return the given string builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bytes",
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "StringBuilder",
    "signature": "public StringBuilder appendMd5DigestAsHex(byte[] bytes, StringBuilder builder)",
    "source_code": "\tpublic static StringBuilder appendMd5DigestAsHex(byte[] bytes, StringBuilder builder) {\n\t\treturn appendDigestAsHex(MD5_ALGORITHM_NAME, bytes, builder);\n\t}"
  },
  "org.springframework.util.<unknown>#appendMd5DigestAsHex(inputStream,builder)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Append a hexadecimal string representation of the MD5 digest of the given\n\t * inputStream to the given {@link StringBuilder}.\n\t * <p>This method does <strong>not</strong> close the input stream.\n\t * @param inputStream the inputStream to calculate the digest over\n\t * @param builder the string builder to append the digest to\n\t * @return the given string builder\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "StringBuilder",
    "signature": "public StringBuilder appendMd5DigestAsHex(InputStream inputStream, StringBuilder builder)",
    "source_code": "\tpublic static StringBuilder appendMd5DigestAsHex(InputStream inputStream, StringBuilder builder) throws IOException {\n\t\treturn appendDigestAsHex(MD5_ALGORITHM_NAME, inputStream, builder);\n\t}"
  },
  "org.springframework.util.<unknown>#calculateShift(minimumValue,maximumValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Calculate a shift value that can be used to create a power-of-two value between\n\t * the specified maximum and minimum values.\n\t * @param minimumValue the minimum value\n\t * @param maximumValue the maximum value\n\t * @return the calculated shift (use {@code 1 << shift} to obtain a value)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "minimumValue",
      "maximumValue"
    ],
    "position": {
      "column": 1,
      "line": 433
    },
    "return": "int",
    "signature": "protected int calculateShift(int minimumValue, int maximumValue)",
    "source_code": "\tprotected static int calculateShift(int minimumValue, int maximumValue) {\n\t\tint shift = 0;\n\t\tint value = 1;\n\t\twhile (value < minimumValue && value < maximumValue) {\n\t\t\tvalue <<= 1;\n\t\t\tshift++;\n\t\t}\n\t\treturn shift;\n\t}"
  },
  "org.springframework.util.<unknown>#checkParameters(parameter,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "void",
    "signature": "protected void checkParameters(String parameter, String value)",
    "source_code": "\tprotected void checkParameters(String parameter, String value) {\n\t\tAssert.hasLength(parameter, \"'parameter' must not be empty\");\n\t\tAssert.hasLength(value, \"'value' must not be empty\");\n\t\tcheckToken(parameter);\n\t\tif (PARAM_CHARSET.equals(parameter)) {\n\t\t\tif (this.resolvedCharset == null) {\n\t\t\t\tthis.resolvedCharset = Charset.forName(unquote(value));\n\t\t\t}\n\t\t}\n\t\telse if (!isQuotedString(value)) {\n\t\t\tcheckToken(value);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#compare(mimeType1,mimeType2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mimeType1",
      "mimeType2"
    ],
    "position": {
      "column": 1,
      "line": 715
    },
    "return": "int",
    "signature": "public int compare(T mimeType1, T mimeType2)",
    "source_code": "\t\tpublic int compare(T mimeType1, T mimeType2) {\n\t\t\tif (mimeType1.isWildcardType() && !mimeType2.isWildcardType()) {  // */* < audio/*\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if (mimeType2.isWildcardType() && !mimeType1.isWildcardType()) {  // audio/* > */*\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (!mimeType1.getType().equals(mimeType2.getType())) {  // audio/basic == text/html\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {  // mediaType1.getType().equals(mediaType2.getType())\n\t\t\t\tif (mimeType1.isWildcardSubtype() && !mimeType2.isWildcardSubtype()) {  // audio/* < audio/basic\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if (mimeType2.isWildcardSubtype() && !mimeType1.isWildcardSubtype()) {  // audio/basic > audio/*\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse if (!mimeType1.getSubtype().equals(mimeType2.getSubtype())) {  // audio/basic == audio/wave\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse {  // mediaType2.getSubtype().equals(mediaType2.getSubtype())\n\t\t\t\t\treturn compareParameters(mimeType1, mimeType2);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.util.<unknown>#compareParameters(mimeType1,mimeType2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mimeType1",
      "mimeType2"
    ],
    "position": {
      "column": 1,
      "line": 741
    },
    "return": "int",
    "signature": "protected int compareParameters(T mimeType1, T mimeType2)",
    "source_code": "\t\tprotected int compareParameters(T mimeType1, T mimeType2) {\n\t\t\tint paramsSize1 = mimeType1.getParameters().size();\n\t\t\tint paramsSize2 = mimeType2.getParameters().size();\n\t\t\treturn Integer.compare(paramsSize2, paramsSize1);  // audio/basic;level=1 < audio/basic\n\t\t}"
  },
  "org.springframework.util.<unknown>#compute(key,K,List<V>,remappingFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "K",
      "List<V>",
      "remappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "List<V>",
    "signature": "public List<V> compute(K key,\n\t\t\tBiFunction<? super K, ? super List<V>, ? extends List<V>> remappingFunction)",
    "source_code": "\tpublic List<V> compute(K key,\n\t\t\tBiFunction<? super K, ? super List<V>, ? extends List<V>> remappingFunction) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#computeIfAbsent(key,K,mappingFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "K",
      "mappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "List<V>",
    "signature": "public List<V> computeIfAbsent(K key, Function<? super K, ? extends List<V>> mappingFunction)",
    "source_code": "\tpublic List<V> computeIfAbsent(K key, Function<? super K, ? extends List<V>> mappingFunction) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#computeIfAbsent(key,String,mappingFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "String",
      "mappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "V",
    "signature": "public V computeIfAbsent(String key, Function<? super String, ? extends V> mappingFunction)",
    "source_code": "\tpublic V computeIfAbsent(String key, Function<? super String, ? extends V> mappingFunction) {\n\t\tString oldKey = this.caseInsensitiveKeys.putIfAbsent(convertKey(key), key);\n\t\tif (oldKey != null) {\n\t\t\tV oldKeyValue = this.targetMap.get(oldKey);\n\t\t\tif (oldKeyValue != null) {\n\t\t\t\treturn oldKeyValue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey = oldKey;\n\t\t\t}\n\t\t}\n\t\treturn this.targetMap.computeIfAbsent(key, mappingFunction);\n\t}"
  },
  "org.springframework.util.<unknown>#computeIfPresent(key,K,List<V>,remappingFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "K",
      "List<V>",
      "remappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "List<V>",
    "signature": "public List<V> computeIfPresent(K key,\n\t\t\tBiFunction<? super K, ? super List<V>, ? extends List<V>> remappingFunction)",
    "source_code": "\tpublic List<V> computeIfPresent(K key,\n\t\t\tBiFunction<? super K, ? super List<V>, ? extends List<V>> remappingFunction) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#containsConstant(enumValues,constant)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given array of enum constants contains a constant with the given name,\n\t * ignoring case when determining a match.\n\t * @param enumValues the enum values to check, typically obtained via {@code MyEnum.values()}\n\t * @param constant the constant name to find (must not be null or empty string)\n\t * @return whether the constant has been found in the given array\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enumValues",
      "constant"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "boolean",
    "signature": "public boolean containsConstant(Enum<?>[] enumValues, String constant)",
    "source_code": "\tpublic static boolean containsConstant(Enum<?>[] enumValues, String constant) {\n\t\treturn containsConstant(enumValues, constant, false);\n\t}"
  },
  "org.springframework.util.<unknown>#containsConstant(enumValues,constant,caseSensitive)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given array of enum constants contains a constant with the given name.\n\t * @param enumValues the enum values to check, typically obtained via {@code MyEnum.values()}\n\t * @param constant the constant name to find (must not be null or empty string)\n\t * @param caseSensitive whether case is significant in determining a match\n\t * @return whether the constant has been found in the given array\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enumValues",
      "constant",
      "caseSensitive"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "boolean",
    "signature": "public boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive)",
    "source_code": "\tpublic static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive) {\n\t\tfor (Enum<?> candidate : enumValues) {\n\t\t\tif (caseSensitive ? candidate.toString().equals(constant) :\n\t\t\t\t\tcandidate.toString().equalsIgnoreCase(constant)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#containsElement(array,element)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given array contains the given element.\n\t * @param array the array to check (may be {@code null},\n\t * in which case the return value will always be {@code false})\n\t * @param element the element to check for\n\t * @return whether the element has been found in the given array\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "boolean",
    "signature": "public boolean containsElement(@Nullable Object[] array, Object element)",
    "source_code": "\tpublic static boolean containsElement(@Nullable Object[] array, Object element) {\n\t\tif (array == null) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (Object arrayEle : array) {\n\t\t\tif (nullSafeEquals(arrayEle, element)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#convertNumberToTargetClass(number,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given number into an instance of the given target class.\n\t * @param number the number to convert\n\t * @param targetClass the target class to convert to\n\t * @return the converted number\n\t * @throws IllegalArgumentException if the target class is not supported\n\t * (i.e. not a standard Number subclass as included in the JDK)\n\t * @see java.lang.Byte\n\t * @see java.lang.Short\n\t * @see java.lang.Integer\n\t * @see java.lang.Long\n\t * @see java.math.BigInteger\n\t * @see java.lang.Float\n\t * @see java.lang.Double\n\t * @see java.math.BigDecimal\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "number",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "T",
    "signature": "public T convertNumberToTargetClass(Number number, Class<T> targetClass)",
    "source_code": "\tpublic static <T extends Number> T convertNumberToTargetClass(Number number, Class<T> targetClass)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tAssert.notNull(number, \"Number must not be null\");\n\t\tAssert.notNull(targetClass, \"Target class must not be null\");\n\n\t\tif (targetClass.isInstance(number)) {\n\t\t\treturn (T) number;\n\t\t}\n\t\telse if (Byte.class == targetClass) {\n\t\t\tlong value = checkedLongValue(number, targetClass);\n\t\t\tif (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {\n\t\t\t\traiseOverflowException(number, targetClass);\n\t\t\t}\n\t\t\treturn (T) Byte.valueOf(number.byteValue());\n\t\t}\n\t\telse if (Short.class == targetClass) {\n\t\t\tlong value = checkedLongValue(number, targetClass);\n\t\t\tif (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {\n\t\t\t\traiseOverflowException(number, targetClass);\n\t\t\t}\n\t\t\treturn (T) Short.valueOf(number.shortValue());\n\t\t}\n\t\telse if (Integer.class == targetClass) {\n\t\t\tlong value = checkedLongValue(number, targetClass);\n\t\t\tif (value < Integer.MIN_VALUE || value > Integer.MAX_VALUE) {\n\t\t\t\traiseOverflowException(number, targetClass);\n\t\t\t}\n\t\t\treturn (T) Integer.valueOf(number.intValue());\n\t\t}\n\t\telse if (Long.class == targetClass) {\n\t\t\tlong value = checkedLongValue(number, targetClass);\n\t\t\treturn (T) Long.valueOf(value);\n\t\t}\n\t\telse if (BigInteger.class == targetClass) {\n\t\t\tif (number instanceof BigDecimal bigDecimal) {\n\t\t\t\t// do not lose precision - use BigDecimal's own conversion\n\t\t\t\treturn (T) bigDecimal.toBigInteger();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// original value is not a Big* number - use standard long conversion\n\t\t\t\treturn (T) BigInteger.valueOf(number.longValue());\n\t\t\t}\n\t\t}\n\t\telse if (Float.class == targetClass) {\n\t\t\treturn (T) Float.valueOf(number.floatValue());\n\t\t}\n\t\telse if (Double.class == targetClass) {\n\t\t\treturn (T) Double.valueOf(number.doubleValue());\n\t\t}\n\t\telse if (BigDecimal.class == targetClass) {\n\t\t\t// always use BigDecimal(String) here to avoid unpredictability of BigDecimal(double)\n\t\t\t// (see BigDecimal javadoc for details)\n\t\t\treturn (T) new BigDecimal(number.toString());\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Could not convert number [\" + number + \"] of type [\" +\n\t\t\t\t\tnumber.getClass().getName() + \"] to unsupported target class [\" + targetClass.getName() + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#copy(in,out)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the contents of the given String to the given Writer.\n\t * Closes the writer when done.\n\t * @param in the String to copy from\n\t * @param out the Writer to copy to\n\t * @throws IOException in case of I/O errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "in",
      "out"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "void",
    "signature": "public void copy(String in, Writer out)",
    "source_code": "\tpublic static void copy(String in, Writer out) throws IOException {\n\t\tAssert.notNull(in, \"No input String specified\");\n\t\tAssert.notNull(out, \"No Writer specified\");\n\n\t\ttry {\n\t\t\tout.write(in);\n\t\t}\n\t\tfinally {\n\t\t\tclose(out);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#createReference(Entry<K,entry,hash,Reference<K,next)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Factory method used to create a new {@link Reference}.\n\t\t * @param entry the entry contained in the reference\n\t\t * @param hash the hash\n\t\t * @param next the next reference in the chain, or {@code null} if none\n\t\t * @return a new {@link Reference}\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "entry",
      "hash",
      "Reference<K",
      "next"
    ],
    "position": {
      "column": 1,
      "line": 995
    },
    "return": "V>",
    "signature": "public V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next)",
    "source_code": "\t\tpublic Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {\n\t\t\tif (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {\n\t\t\t\treturn new WeakEntryReference<>(entry, hash, next, this.queue);\n\t\t\t}\n\t\t\treturn new SoftEntryReference<>(entry, hash, next, this.queue);\n\t\t}"
  },
  "org.springframework.util.<unknown>#declaresException(method,exceptionType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given method explicitly declares the given\n\t * exception or one of its superclasses, which means that an exception\n\t * of that type can be propagated as-is within a reflective invocation.\n\t * @param method the declaring method\n\t * @param exceptionType the exception to throw\n\t * @return {@code true} if the exception can be thrown as-is;\n\t * {@code false} if it needs to be wrapped\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "exceptionType"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "boolean",
    "signature": "public boolean declaresException(Method method, Class<?> exceptionType)",
    "source_code": "\tpublic static boolean declaresException(Method method, Class<?> exceptionType) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tClass<?>[] declaredExceptions = method.getExceptionTypes();\n\t\tfor (Class<?> declaredException : declaredExceptions) {\n\t\t\tif (declaredException.isAssignableFrom(exceptionType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#doTask(hash,key,task)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Apply an update operation to this segment.\n\t\t * The segment will be locked during the update.\n\t\t * @param hash the hash of the key\n\t\t * @param key the key\n\t\t * @param task the update operation\n\t\t * @return the result of the operation\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hash",
      "key",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 516
    },
    "return": "T",
    "signature": "public T doTask(final int hash, @Nullable final Object key, final Task<T> task)",
    "source_code": "\t\tpublic <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task) {\n\t\t\tboolean resize = task.hasOption(TaskOption.RESIZE);\n\t\t\tif (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {\n\t\t\t\trestructureIfNecessary(resize);\n\t\t\t}\n\t\t\tif (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count.get() == 0) {\n\t\t\t\treturn task.execute(null, null, null);\n\t\t\t}\n\t\t\tlock();\n\t\t\ttry {\n\t\t\t\tfinal int index = getIndex(hash, this.references);\n\t\t\t\tfinal Reference<K, V> head = this.references[index];\n\t\t\t\tReference<K, V> ref = findInChain(head, key, hash);\n\t\t\t\tEntry<K, V> entry = (ref != null ? ref.get() : null);\n\t\t\t\tEntries<V> entries = value -> {\n\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\tEntry<K, V> newEntry = new Entry<>((K) key, value);\n\t\t\t\t\tReference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head);\n\t\t\t\t\tSegment.this.references[index] = newReference;\n\t\t\t\t\tSegment.this.count.incrementAndGet();\n\t\t\t\t};\n\t\t\t\treturn task.execute(ref, entry, entries);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tunlock();\n\t\t\t\tif (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {\n\t\t\t\t\trestructureIfNecessary(resize);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.util.<unknown>#doWithFields(clazz,fc)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given callback on all fields in the target class, going up the\n\t * class hierarchy to get all declared fields.\n\t * @param clazz the target class to analyze\n\t * @param fc the callback to invoke for each field\n\t * @throws IllegalStateException if introspection fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "fc"
    ],
    "position": {
      "column": 1,
      "line": 689
    },
    "return": "void",
    "signature": "public void doWithFields(Class<?> clazz, FieldCallback fc)",
    "source_code": "\tpublic static void doWithFields(Class<?> clazz, FieldCallback fc) {\n\t\tdoWithFields(clazz, fc, null);\n\t}"
  },
  "org.springframework.util.<unknown>#doWithFields(clazz,fc,ff)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given callback on all fields in the target class, going up the\n\t * class hierarchy to get all declared fields.\n\t * @param clazz the target class to analyze\n\t * @param fc the callback to invoke for each field\n\t * @param ff the filter that determines the fields to apply the callback to\n\t * @throws IllegalStateException if introspection fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "fc",
      "ff"
    ],
    "position": {
      "column": 1,
      "line": 701
    },
    "return": "void",
    "signature": "public void doWithFields(Class<?> clazz, FieldCallback fc, @Nullable FieldFilter ff)",
    "source_code": "\tpublic static void doWithFields(Class<?> clazz, FieldCallback fc, @Nullable FieldFilter ff) {\n\t\t// Keep backing up the inheritance hierarchy.\n\t\tClass<?> targetClass = clazz;\n\t\tdo {\n\t\t\tField[] fields = getDeclaredFields(targetClass);\n\t\t\tfor (Field field : fields) {\n\t\t\t\tif (ff != null && !ff.matches(field)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tfc.doWith(field);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\t\tthrow new IllegalStateException(\"Not allowed to access field '\" + field.getName() + \"': \" + ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttargetClass = targetClass.getSuperclass();\n\t\t}\n\t\twhile (targetClass != null && targetClass != Object.class);\n\t}"
  },
  "org.springframework.util.<unknown>#doWithLocalFields(clazz,fc)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given callback on all locally declared fields in the given class.\n\t * @param clazz the target class to analyze\n\t * @param fc the callback to invoke for each field\n\t * @throws IllegalStateException if introspection fails\n\t * @since 4.2\n\t * @see #doWithFields\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "fc"
    ],
    "position": {
      "column": 1,
      "line": 671
    },
    "return": "void",
    "signature": "public void doWithLocalFields(Class<?> clazz, FieldCallback fc)",
    "source_code": "\tpublic static void doWithLocalFields(Class<?> clazz, FieldCallback fc) {\n\t\tfor (Field field : getDeclaredFields(clazz)) {\n\t\t\ttry {\n\t\t\t\tfc.doWith(field);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Not allowed to access field '\" + field.getName() + \"': \" + ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#doWithLocalMethods(clazz,mc)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform the given callback operation on all matching methods of the given\n\t * class, as locally declared or equivalent thereof (such as default methods\n\t * on Java 8 based interfaces that the given class implements).\n\t * @param clazz the class to introspect\n\t * @param mc the callback to invoke for each method\n\t * @throws IllegalStateException if introspection fails\n\t * @since 4.2\n\t * @see #doWithMethods\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mc"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "void",
    "signature": "public void doWithLocalMethods(Class<?> clazz, MethodCallback mc)",
    "source_code": "\tpublic static void doWithLocalMethods(Class<?> clazz, MethodCallback mc) {\n\t\tMethod[] methods = getDeclaredMethods(clazz, false);\n\t\tfor (Method method : methods) {\n\t\t\ttry {\n\t\t\t\tmc.doWith(method);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Not allowed to access method '\" + method.getName() + \"': \" + ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#doWithMethods(clazz,mc)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform the given callback operation on all matching methods of the given\n\t * class and superclasses.\n\t * <p>The same named method occurring on subclass and superclass will appear\n\t * twice, unless excluded by a {@link MethodFilter}.\n\t * @param clazz the class to introspect\n\t * @param mc the callback to invoke for each method\n\t * @throws IllegalStateException if introspection fails\n\t * @see #doWithMethods(Class, MethodCallback, MethodFilter)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mc"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "void",
    "signature": "public void doWithMethods(Class<?> clazz, MethodCallback mc)",
    "source_code": "\tpublic static void doWithMethods(Class<?> clazz, MethodCallback mc) {\n\t\tdoWithMethods(clazz, mc, null);\n\t}"
  },
  "org.springframework.util.<unknown>#doWithMethods(clazz,mc,mf)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform the given callback operation on all matching methods of the given\n\t * class and superclasses (or given interface and super-interfaces).\n\t * <p>The same named method occurring on subclass and superclass will appear\n\t * twice, unless excluded by the specified {@link MethodFilter}.\n\t * @param clazz the class to introspect\n\t * @param mc the callback to invoke for each method\n\t * @param mf the filter that determines the methods to apply the callback to\n\t * @throws IllegalStateException if introspection fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mc",
      "mf"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "void",
    "signature": "public void doWithMethods(Class<?> clazz, MethodCallback mc, @Nullable MethodFilter mf)",
    "source_code": "\tpublic static void doWithMethods(Class<?> clazz, MethodCallback mc, @Nullable MethodFilter mf) {\n\t\tif (mf == USER_DECLARED_METHODS && clazz == Object.class) {\n\t\t\t// nothing to introspect\n\t\t\treturn;\n\t\t}\n\t\tMethod[] methods = getDeclaredMethods(clazz, false);\n\t\tfor (Method method : methods) {\n\t\t\tif (mf != null && !mf.matches(method)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tmc.doWith(method);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Not allowed to access method '\" + method.getName() + \"': \" + ex);\n\t\t\t}\n\t\t}\n\t\t// Keep backing up the inheritance hierarchy.\n\t\tif (clazz.getSuperclass() != null && (mf != USER_DECLARED_METHODS || clazz.getSuperclass() != Object.class)) {\n\t\t\tdoWithMethods(clazz.getSuperclass(), mc, mf);\n\t\t}\n\t\telse if (clazz.isInterface()) {\n\t\t\tfor (Class<?> superIfc : clazz.getInterfaces()) {\n\t\t\t\tdoWithMethods(superIfc, mc, mf);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#execute(Reference<K,ref,Entry<K,entry)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Convenience method that can be used for tasks that do not need access to {@link Entries}.\n\t\t * @param ref the found reference (or {@code null})\n\t\t * @param entry the found entry (or {@code null})\n\t\t * @return the result of the task\n\t\t * @see #execute(Reference, Entry, Entries)\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Reference<K",
      "ref",
      "Entry<K",
      "entry"
    ],
    "position": {
      "column": 1,
      "line": 815
    },
    "return": "T",
    "signature": "protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry)",
    "source_code": "\t\tprotected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.util.<unknown>#execute(Reference<K,ref,Entry<K,entry,entries)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Execute the task.\n\t\t * @param ref the found reference (or {@code null})\n\t\t * @param entry the found entry (or {@code null})\n\t\t * @param entries access to the underlying entries\n\t\t * @return the result of the task\n\t\t * @see #execute(Reference, Entry)\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Reference<K",
      "ref",
      "Entry<K",
      "entry",
      "entries"
    ],
    "position": {
      "column": 1,
      "line": 803
    },
    "return": "T",
    "signature": "protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries<V> entries)",
    "source_code": "\t\tprotected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries<V> entries) {\n\t\t\treturn execute(ref, entry);\n\t\t}"
  },
  "org.springframework.util.<unknown>#findField(clazz,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to find a {@link Field field} on the supplied {@link Class} with the\n\t * supplied {@code name}. Searches all superclasses up to {@link Object}.\n\t * @param clazz the class to introspect\n\t * @param name the name of the field\n\t * @return the corresponding Field object, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 589
    },
    "return": "Field",
    "signature": "public Field findField(Class<?> clazz, String name)",
    "source_code": "\tpublic static Field findField(Class<?> clazz, String name) {\n\t\treturn findField(clazz, name, null);\n\t}"
  },
  "org.springframework.util.<unknown>#findField(clazz,name,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to find a {@link Field field} on the supplied {@link Class} with the\n\t * supplied {@code name} and/or {@link Class type}. Searches all superclasses\n\t * up to {@link Object}.\n\t * @param clazz the class to introspect\n\t * @param name the name of the field (may be {@code null} if type is specified)\n\t * @param type the type of the field (may be {@code null} if name is specified)\n\t * @return the corresponding Field object, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "name",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 603
    },
    "return": "Field",
    "signature": "public Field findField(Class<?> clazz, @Nullable String name, @Nullable Class<?> type)",
    "source_code": "\tpublic static Field findField(Class<?> clazz, @Nullable String name, @Nullable Class<?> type) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.isTrue(name != null || type != null, \"Either name or type of the field must be specified\");\n\t\tClass<?> searchType = clazz;\n\t\twhile (Object.class != searchType && searchType != null) {\n\t\t\tField[] fields = getDeclaredFields(searchType);\n\t\t\tfor (Field field : fields) {\n\t\t\t\tif ((name == null || name.equals(field.getName())) &&\n\t\t\t\t\t\t(type == null || type.equals(field.getType()))) {\n\t\t\t\t\treturn field;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsearchType = searchType.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.util.<unknown>#findMethod(clazz,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to find a {@link Method} on the supplied class with the supplied name\n\t * and no parameters. Searches all superclasses up to {@code Object}.\n\t * <p>Returns {@code null} if no {@link Method} can be found.\n\t * @param clazz the class to introspect\n\t * @param name the name of the method\n\t * @return the Method object, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "Method",
    "signature": "public Method findMethod(Class<?> clazz, String name)",
    "source_code": "\tpublic static Method findMethod(Class<?> clazz, String name) {\n\t\treturn findMethod(clazz, name, EMPTY_CLASS_ARRAY);\n\t}"
  },
  "org.springframework.util.<unknown>#findMethod(clazz,name,paramTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to find a {@link Method} on the supplied class with the supplied name\n\t * and parameter types. Searches all superclasses up to {@code Object}.\n\t * <p>Returns {@code null} if no {@link Method} can be found.\n\t * @param clazz the class to introspect\n\t * @param name the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * (may be {@code null} to indicate any signature)\n\t * @return the Method object, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "name",
      "paramTypes"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "Method",
    "signature": "public Method findMethod(Class<?> clazz, String name, @Nullable Class<?>... paramTypes)",
    "source_code": "\tpublic static Method findMethod(Class<?> clazz, String name, @Nullable Class<?>... paramTypes) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(name, \"Method name must not be null\");\n\t\tClass<?> searchType = clazz;\n\t\twhile (searchType != null) {\n\t\t\tMethod[] methods = (searchType.isInterface() ? searchType.getMethods() :\n\t\t\t\t\tgetDeclaredMethods(searchType, false));\n\t\t\tfor (Method method : methods) {\n\t\t\t\tif (name.equals(method.getName()) && (paramTypes == null || hasSameParams(method, paramTypes))) {\n\t\t\t\t\treturn method;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsearchType = searchType.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.util.<unknown>#forEach(Entry<K,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "void",
    "signature": "public void forEach(Consumer<? super Entry<K, List<V>>> action)",
    "source_code": "\t\tpublic void forEach(Consumer<? super Entry<K, List<V>>> action) {\n\t\t\tthis.delegate.forEach(e -> action.accept(new UnmodifiableEntry<>(e)));\n\t\t}"
  },
  "org.springframework.util.<unknown>#forEach(Entry<String,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<String",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 481
    },
    "return": "void",
    "signature": "public void forEach(Consumer<? super Entry<String, V>> action)",
    "source_code": "\t\tpublic void forEach(Consumer<? super Entry<String, V>> action) {\n\t\t\tthis.delegate.forEach(action);\n\t\t}"
  },
  "org.springframework.util.<unknown>#forEach(K,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "K",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void forEach(BiConsumer<? super K, ? super List<V>> action)",
    "source_code": "\tpublic void forEach(BiConsumer<? super K, ? super List<V>> action) {\n\t\tthis.delegate.forEach((k, vs) -> action.accept(k, Collections.unmodifiableList(vs)));\n\t}"
  },
  "org.springframework.util.<unknown>#forEachRemaining(Entry<K,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "void",
    "signature": "public void forEachRemaining(Consumer<? super Entry<K, List<V>>> action)",
    "source_code": "\t\t\tpublic void forEachRemaining(Consumer<? super Entry<K, List<V>>> action) {\n\t\t\t\tthis.delegate.forEachRemaining(entry -> action.accept(new UnmodifiableEntry<>(entry)));\n\t\t\t}"
  },
  "org.springframework.util.<unknown>#getField(field,target)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the field represented by the supplied {@link Field field object} on the\n\t * specified {@link Object target object}. In accordance with {@link Field#get(Object)}\n\t * semantics, the returned value is automatically wrapped if the underlying field\n\t * has a primitive type.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException(Exception)}.\n\t * @param field the field to get\n\t * @param target the target object from which to get the field\n\t * (or {@code null} for a static field)\n\t * @return the field's current value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "target"
    ],
    "position": {
      "column": 1,
      "line": 653
    },
    "return": "Object",
    "signature": "public Object getField(Field field, @Nullable Object target)",
    "source_code": "\tpublic static Object getField(Field field, @Nullable Object target) {\n\t\ttry {\n\t\t\treturn field.get(target);\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\thandleReflectionException(ex);\n\t\t}\n\t\tthrow new IllegalStateException(\"Should never get here\");\n\t}"
  },
  "org.springframework.util.<unknown>#getOrDefault(key,defaultValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "defaultValue"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "V",
    "signature": "public V getOrDefault(@Nullable Object key, @Nullable V defaultValue)",
    "source_code": "\tpublic V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {\n\t\tReference<K, V> ref = getReference(key, Restructure.WHEN_NECESSARY);\n\t\tEntry<K, V> entry = (ref != null ? ref.get() : null);\n\t\treturn (entry != null ? entry.getValue() : defaultValue);\n\t}"
  },
  "org.springframework.util.<unknown>#getReference(key,hash,restructure)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "hash",
      "restructure"
    ],
    "position": {
      "column": 1,
      "line": 493
    },
    "return": "V>",
    "signature": "public V> getReference(@Nullable Object key, int hash, Restructure restructure)",
    "source_code": "\t\tpublic Reference<K, V> getReference(@Nullable Object key, int hash, Restructure restructure) {\n\t\t\tif (restructure == Restructure.WHEN_NECESSARY) {\n\t\t\t\trestructureIfNecessary(false);\n\t\t\t}\n\t\t\tif (this.count.get() == 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Use a local copy to protect against other threads writing\n\t\t\tReference<K, V>[] references = this.references;\n\t\t\tint index = getIndex(hash, references);\n\t\t\tReference<K, V> head = references[index];\n\t\t\treturn findInChain(head, key, hash);\n\t\t}"
  },
  "org.springframework.util.<unknown>#getReference(key,restructure)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link Reference} to the {@link Entry} for the specified {@code key},\n\t * or {@code null} if not found.\n\t * @param key the key (can be {@code null})\n\t * @param restructure types of restructure allowed during this call\n\t * @return the reference, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key",
      "restructure"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "V>",
    "signature": "protected V> getReference(@Nullable Object key, Restructure restructure)",
    "source_code": "\tprotected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {\n\t\tint hash = getHash(key);\n\t\treturn getSegmentForHash(hash).getReference(key, hash, restructure);\n\t}"
  },
  "org.springframework.util.<unknown>#getUniqueDeclaredMethods(leafClass,mf)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the unique set of declared methods on the leaf class and all superclasses.\n\t * Leaf class methods are included first and while traversing the superclass hierarchy\n\t * any methods found with signatures matching a method already included are filtered out.\n\t * @param leafClass the class to introspect\n\t * @param mf the filter that determines the methods to take into account\n\t * @throws IllegalStateException if introspection fails\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "leafClass",
      "mf"
    ],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "Method[]",
    "signature": "public Method[] getUniqueDeclaredMethods(Class<?> leafClass, @Nullable MethodFilter mf)",
    "source_code": "\tpublic static Method[] getUniqueDeclaredMethods(Class<?> leafClass, @Nullable MethodFilter mf) {\n\t\tfinal List<Method> methods = new ArrayList<>(20);\n\t\tdoWithMethods(leafClass, method -> {\n\t\t\tboolean knownSignature = false;\n\t\t\tMethod methodBeingOverriddenWithCovariantReturnType = null;\n\t\t\tfor (Method existingMethod : methods) {\n\t\t\t\tif (method.getName().equals(existingMethod.getName()) &&\n\t\t\t\t\t\tmethod.getParameterCount() == existingMethod.getParameterCount() &&\n\t\t\t\t\t\tArrays.equals(method.getParameterTypes(), existingMethod.getParameterTypes())) {\n\t\t\t\t\t// Is this a covariant return type situation?\n\t\t\t\t\tif (existingMethod.getReturnType() != method.getReturnType() &&\n\t\t\t\t\t\t\texistingMethod.getReturnType().isAssignableFrom(method.getReturnType())) {\n\t\t\t\t\t\tmethodBeingOverriddenWithCovariantReturnType = existingMethod;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tknownSignature = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (methodBeingOverriddenWithCovariantReturnType != null) {\n\t\t\t\tmethods.remove(methodBeingOverriddenWithCovariantReturnType);\n\t\t\t}\n\t\t\tif (!knownSignature && !isCglibRenamedMethod(method)) {\n\t\t\t\tmethods.add(method);\n\t\t\t}\n\t\t}, mf);\n\t\treturn methods.toArray(EMPTY_METHOD_ARRAY);\n\t}"
  },
  "org.springframework.util.<unknown>#invokeMethod(method,target)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified {@link Method} against the supplied target object with no arguments.\n\t * The target object can be {@code null} when invoking a static {@link Method}.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException}.\n\t * @param method the method to invoke\n\t * @param target the target object to invoke the method on\n\t * @return the invocation result, if any\n\t * @see #invokeMethod(java.lang.reflect.Method, Object, Object[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "target"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "Object",
    "signature": "public Object invokeMethod(Method method, @Nullable Object target)",
    "source_code": "\tpublic static Object invokeMethod(Method method, @Nullable Object target) {\n\t\treturn invokeMethod(method, target, EMPTY_OBJECT_ARRAY);\n\t}"
  },
  "org.springframework.util.<unknown>#invokeMethod(method,target,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified {@link Method} against the supplied target object with the\n\t * supplied arguments. The target object can be {@code null} when invoking a\n\t * static {@link Method}.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException}.\n\t * @param method the method to invoke\n\t * @param target the target object to invoke the method on\n\t * @param args the invocation arguments (may be {@code null})\n\t * @return the invocation result, if any\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "target",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "Object",
    "signature": "public Object invokeMethod(Method method, @Nullable Object target, @Nullable Object... args)",
    "source_code": "\tpublic static Object invokeMethod(Method method, @Nullable Object target, @Nullable Object... args) {\n\t\ttry {\n\t\t\treturn method.invoke(target, args);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\thandleReflectionException(ex);\n\t\t}\n\t\tthrow new IllegalStateException(\"Should never get here\");\n\t}"
  },
  "org.springframework.util.<unknown>#isAssignable(lhsType,rhsType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check if the right-hand side type may be assigned to the left-hand side\n\t * type following the Java generics rules.\n\t * @param lhsType the target type\n\t * @param rhsType the value type that should be assigned to the target type\n\t * @return true if rhs is assignable to lhs\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lhsType",
      "rhsType"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "boolean",
    "signature": "public boolean isAssignable(Type lhsType, Type rhsType)",
    "source_code": "\tpublic static boolean isAssignable(Type lhsType, Type rhsType) {\n\t\tAssert.notNull(lhsType, \"Left-hand side type must not be null\");\n\t\tAssert.notNull(rhsType, \"Right-hand side type must not be null\");\n\n\t\t// all types are assignable to themselves and to class Object\n\t\tif (lhsType.equals(rhsType) || Object.class == lhsType) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (lhsType instanceof Class<?> lhsClass) {\n\t\t\t// just comparing two classes\n\t\t\tif (rhsType instanceof Class<?> rhsClass) {\n\t\t\t\treturn ClassUtils.isAssignable(lhsClass, rhsClass);\n\t\t\t}\n\n\t\t\tif (rhsType instanceof ParameterizedType rhsParameterizedType) {\n\t\t\t\tType rhsRaw = rhsParameterizedType.getRawType();\n\n\t\t\t\t// a parameterized type is always assignable to its raw class type\n\t\t\t\tif (rhsRaw instanceof Class<?> rhRawClass) {\n\t\t\t\t\treturn ClassUtils.isAssignable(lhsClass, rhRawClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (lhsClass.isArray() && rhsType instanceof GenericArrayType rhsGenericArrayType) {\n\t\t\t\tType rhsComponent = rhsGenericArrayType.getGenericComponentType();\n\n\t\t\t\treturn isAssignable(lhsClass.getComponentType(), rhsComponent);\n\t\t\t}\n\t\t}\n\n\t\t// parameterized types are only assignable to other parameterized types and class types\n\t\tif (lhsType instanceof ParameterizedType lhsParameterizedType) {\n\t\t\tif (rhsType instanceof Class<?> rhsClass) {\n\t\t\t\tType lhsRaw = lhsParameterizedType.getRawType();\n\n\t\t\t\tif (lhsRaw instanceof Class<?> lhsClass) {\n\t\t\t\t\treturn ClassUtils.isAssignable(lhsClass, rhsClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (rhsType instanceof ParameterizedType rhsParameterizedType) {\n\t\t\t\treturn isAssignable(lhsParameterizedType, rhsParameterizedType);\n\t\t\t}\n\t\t}\n\n\t\tif (lhsType instanceof GenericArrayType lhsGenericArrayType) {\n\t\t\tType lhsComponent = lhsGenericArrayType.getGenericComponentType();\n\n\t\t\tif (rhsType instanceof Class<?> rhsClass && rhsClass.isArray()) {\n\t\t\t\treturn isAssignable(lhsComponent, rhsClass.getComponentType());\n\t\t\t}\n\t\t\telse if (rhsType instanceof GenericArrayType rhsGenericArrayType) {\n\t\t\t\tType rhsComponent = rhsGenericArrayType.getGenericComponentType();\n\n\t\t\t\treturn isAssignable(lhsComponent, rhsComponent);\n\t\t\t}\n\t\t}\n\n\t\tif (lhsType instanceof WildcardType lhsWildcardType) {\n\t\t\treturn isAssignable(lhsWildcardType, rhsType);\n\t\t}\n\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#isAssignableBound(lhsType,rhsType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lhsType",
      "rhsType"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "boolean",
    "signature": "public boolean isAssignableBound(@Nullable Type lhsType, @Nullable Type rhsType)",
    "source_code": "\tpublic static boolean isAssignableBound(@Nullable Type lhsType, @Nullable Type rhsType) {\n\t\tif (rhsType == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (lhsType == null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn isAssignable(lhsType, rhsType);\n\t}"
  },
  "org.springframework.util.<unknown>#isCompatibleWithThrowsClause(ex,declaredExceptions)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given exception is compatible with the specified\n\t * exception types, as declared in a throws clause.\n\t * @param ex the exception to check\n\t * @param declaredExceptions the exception types declared in the throws clause\n\t * @return whether the given exception is compatible\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex",
      "declaredExceptions"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "boolean",
    "signature": "public boolean isCompatibleWithThrowsClause(Throwable ex, @Nullable Class<?>... declaredExceptions)",
    "source_code": "\tpublic static boolean isCompatibleWithThrowsClause(Throwable ex, @Nullable Class<?>... declaredExceptions) {\n\t\tif (!isCheckedException(ex)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (declaredExceptions != null) {\n\t\t\tfor (Class<?> declaredException : declaredExceptions) {\n\t\t\t\tif (declaredException.isInstance(ex)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#merge(key,value,List<V>,List<V>,remappingFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value",
      "List<V>",
      "List<V>",
      "remappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "List<V>",
    "signature": "public List<V> merge(K key, List<V> value,\n\t\t\tBiFunction<? super List<V>, ? super List<V>, ? extends List<V>> remappingFunction)",
    "source_code": "\tpublic List<V> merge(K key, List<V> value,\n\t\t\tBiFunction<? super List<V>, ? super List<V>, ? extends List<V>> remappingFunction) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#nullSafeEquals(o1,o2)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the given objects are equal, returning {@code true} if\n\t * both are {@code null} or {@code false} if only one is {@code null}.\n\t * <p>Compares arrays with {@code Arrays.equals}, performing an equality\n\t * check based on the array elements rather than the array reference.\n\t * @param o1 first Object to compare\n\t * @param o2 second Object to compare\n\t * @return whether the given objects are equal\n\t * @see Object#equals(Object)\n\t * @see java.util.Arrays#equals\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o1",
      "o2"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "boolean",
    "signature": "public boolean nullSafeEquals(@Nullable Object o1, @Nullable Object o2)",
    "source_code": "\tpublic static boolean nullSafeEquals(@Nullable Object o1, @Nullable Object o2) {\n\t\tif (o1 == o2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (o1 == null || o2 == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (o1.equals(o2)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (o1.getClass().isArray() && o2.getClass().isArray()) {\n\t\t\treturn arrayEquals(o1, o2);\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#parseNumber(text,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given {@code text} into a {@link Number} instance of the given\n\t * target class, using the corresponding {@code decode} / {@code valueOf} method.\n\t * <p>Trims all whitespace (leading, trailing, and in between characters) from\n\t * the input {@code String} before attempting to parse the number.\n\t * <p>Supports numbers in hex format (with leading \"0x\", \"0X\", or \"#\") as well.\n\t * @param text the text to convert\n\t * @param targetClass the target class to parse into\n\t * @return the parsed number\n\t * @throws IllegalArgumentException if the target class is not supported\n\t * (i.e. not a standard Number subclass as included in the JDK)\n\t * @see Byte#decode\n\t * @see Short#decode\n\t * @see Integer#decode\n\t * @see Long#decode\n\t * @see #decodeBigInteger(String)\n\t * @see Float#valueOf\n\t * @see Double#valueOf\n\t * @see java.math.BigDecimal#BigDecimal(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "T",
    "signature": "public T parseNumber(String text, Class<T> targetClass)",
    "source_code": "\tpublic static <T extends Number> T parseNumber(String text, Class<T> targetClass) {\n\t\tAssert.notNull(text, \"Text must not be null\");\n\t\tAssert.notNull(targetClass, \"Target class must not be null\");\n\t\tString trimmed = StringUtils.trimAllWhitespace(text);\n\n\t\tif (Byte.class == targetClass) {\n\t\t\treturn (T) (isHexNumber(trimmed) ? Byte.decode(trimmed) : Byte.valueOf(trimmed));\n\t\t}\n\t\telse if (Short.class == targetClass) {\n\t\t\treturn (T) (isHexNumber(trimmed) ? Short.decode(trimmed) : Short.valueOf(trimmed));\n\t\t}\n\t\telse if (Integer.class == targetClass) {\n\t\t\treturn (T) (isHexNumber(trimmed) ? Integer.decode(trimmed) : Integer.valueOf(trimmed));\n\t\t}\n\t\telse if (Long.class == targetClass) {\n\t\t\treturn (T) (isHexNumber(trimmed) ? Long.decode(trimmed) : Long.valueOf(trimmed));\n\t\t}\n\t\telse if (BigInteger.class == targetClass) {\n\t\t\treturn (T) (isHexNumber(trimmed) ? decodeBigInteger(trimmed) : new BigInteger(trimmed));\n\t\t}\n\t\telse if (Float.class == targetClass) {\n\t\t\treturn (T) Float.valueOf(trimmed);\n\t\t}\n\t\telse if (Double.class == targetClass) {\n\t\t\treturn (T) Double.valueOf(trimmed);\n\t\t}\n\t\telse if (BigDecimal.class == targetClass || Number.class == targetClass) {\n\t\t\treturn (T) new BigDecimal(trimmed);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Cannot convert String [\" + text + \"] to target class [\" + targetClass.getName() + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#parseNumber(text,targetClass,numberFormat)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given {@code text} into a {@link Number} instance of the\n\t * given target class, using the supplied {@link NumberFormat}.\n\t * <p>Trims the input {@code String} before attempting to parse the number.\n\t * @param text the text to convert\n\t * @param targetClass the target class to parse into\n\t * @param numberFormat the {@code NumberFormat} to use for parsing (if\n\t * {@code null}, this method falls back to {@link #parseNumber(String, Class)})\n\t * @return the parsed number\n\t * @throws IllegalArgumentException if the target class is not supported\n\t * (i.e. not a standard Number subclass as included in the JDK)\n\t * @see java.text.NumberFormat#parse\n\t * @see #convertNumberToTargetClass\n\t * @see #parseNumber(String, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "targetClass",
      "numberFormat"
    ],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "T",
    "signature": "public T parseNumber(String text, Class<T> targetClass, @Nullable NumberFormat numberFormat)",
    "source_code": "\tpublic static <T extends Number> T parseNumber(\n\t\t\tString text, Class<T> targetClass, @Nullable NumberFormat numberFormat) {\n\n\t\tif (numberFormat != null) {\n\t\t\tAssert.notNull(text, \"Text must not be null\");\n\t\t\tAssert.notNull(targetClass, \"Target class must not be null\");\n\t\t\tDecimalFormat decimalFormat = null;\n\t\t\tboolean resetBigDecimal = false;\n\t\t\tif (numberFormat instanceof DecimalFormat) {\n\t\t\t\tdecimalFormat = (DecimalFormat) numberFormat;\n\t\t\t\tif (BigDecimal.class == targetClass && !decimalFormat.isParseBigDecimal()) {\n\t\t\t\t\tdecimalFormat.setParseBigDecimal(true);\n\t\t\t\t\tresetBigDecimal = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tNumber number = numberFormat.parse(StringUtils.trimAllWhitespace(text));\n\t\t\t\treturn convertNumberToTargetClass(number, targetClass);\n\t\t\t}\n\t\t\tcatch (ParseException ex) {\n\t\t\t\tthrow new IllegalArgumentException(\"Could not parse number: \" + ex.getMessage());\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (resetBigDecimal) {\n\t\t\t\t\tdecimalFormat.setParseBigDecimal(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn parseNumber(text, targetClass);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "V",
    "signature": "public V put(@Nullable K key, @Nullable V value)",
    "source_code": "\tpublic V put(@Nullable K key, @Nullable V value) {\n\t\treturn put(key, value, true);\n\t}"
  },
  "org.springframework.util.<unknown>#putAll(K,m)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "K",
      "m"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends K, ? extends List<V>> m)",
    "source_code": "\tpublic void putAll(Map<? extends K, ? extends List<V>> m) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#putAll(String,map)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends V> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends V> map) {\n\t\tif (map.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.util.<unknown>#putIfAbsent(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "V",
    "signature": "public V putIfAbsent(@Nullable K key, @Nullable V value)",
    "source_code": "\tpublic V putIfAbsent(@Nullable K key, @Nullable V value) {\n\t\treturn put(key, value, false);\n\t}"
  },
  "org.springframework.util.<unknown>#remove(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "boolean",
    "signature": "public boolean remove(@Nullable Object key, final @Nullable Object value)",
    "source_code": "\tpublic boolean remove(@Nullable Object key, final @Nullable Object value) {\n\t\tBoolean result = doTask(key, new Task<Boolean>(TaskOption.RESTRUCTURE_AFTER, TaskOption.SKIP_IF_EMPTY) {\n\t\t\t@Override\n\t\t\tprotected Boolean execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\n\t\t\t\tif (entry != null && ObjectUtils.nullSafeEquals(entry.getValue(), value)) {\n\t\t\t\t\tif (ref != null) {\n\t\t\t\t\t\tref.release();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\treturn (Boolean.TRUE.equals(result));\n\t}"
  },
  "org.springframework.util.<unknown>#removeEldestEntry(Map.Entry<String,eldest)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether this map should remove the given eldest entry.\n\t * @param eldest the candidate entry\n\t * @return {@code true} for removing it, {@code false} for keeping it\n\t * @see LinkedHashMap#removeEldestEntry\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map.Entry<String",
      "eldest"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "boolean",
    "signature": "protected boolean removeEldestEntry(Map.Entry<String, V> eldest)",
    "source_code": "\tprotected boolean removeEldestEntry(Map.Entry<String, V> eldest) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#removeIf(Entry<K,filter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "filter"
    ],
    "position": {
      "column": 1,
      "line": 394
    },
    "return": "boolean",
    "signature": "public boolean removeIf(Predicate<? super Entry<K, List<V>>> filter)",
    "source_code": "\t\tpublic boolean removeIf(Predicate<? super Entry<K, List<V>>> filter) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.util.<unknown>#replace(key,oldValue,newValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "oldValue",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "boolean",
    "signature": "public boolean replace(@Nullable K key, final @Nullable V oldValue, final @Nullable V newValue)",
    "source_code": "\tpublic boolean replace(@Nullable K key, final @Nullable V oldValue, final @Nullable V newValue) {\n\t\tBoolean result = doTask(key, new Task<Boolean>(TaskOption.RESTRUCTURE_BEFORE, TaskOption.SKIP_IF_EMPTY) {\n\t\t\t@Override\n\t\t\tprotected Boolean execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\n\t\t\t\tif (entry != null && ObjectUtils.nullSafeEquals(entry.getValue(), oldValue)) {\n\t\t\t\t\tentry.setValue(newValue);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\treturn (Boolean.TRUE.equals(result));\n\t}"
  },
  "org.springframework.util.<unknown>#replace(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "V",
    "signature": "public V replace(@Nullable K key, final @Nullable V value)",
    "source_code": "\tpublic V replace(@Nullable K key, final @Nullable V value) {\n\t\treturn doTask(key, new Task<V>(TaskOption.RESTRUCTURE_BEFORE, TaskOption.SKIP_IF_EMPTY) {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tprotected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\n\t\t\t\tif (entry != null) {\n\t\t\t\t\tV oldValue = entry.getValue();\n\t\t\t\t\tentry.setValue(value);\n\t\t\t\t\treturn oldValue;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.util.<unknown>#replaceAll(K,List<V>,function)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "K",
      "List<V>",
      "function"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "void",
    "signature": "public void replaceAll(BiFunction<? super K, ? super List<V>, ? extends List<V>> function)",
    "source_code": "\tpublic void replaceAll(BiFunction<? super K, ? super List<V>, ? extends List<V>> function) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#set(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void set(K key, @Nullable V value)",
    "source_code": "\tpublic void set(K key, @Nullable V value) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#setAll(Map<K,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<K",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "void",
    "signature": "public void setAll(Map<K, V> values)",
    "source_code": "\tpublic void setAll(Map<K, V> values) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#setField(field,target,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the field represented by the supplied {@linkplain Field field object} on\n\t * the specified {@linkplain Object target object} to the specified {@code value}.\n\t * <p>In accordance with {@link Field#set(Object, Object)} semantics, the new value\n\t * is automatically unwrapped if the underlying field has a primitive type.\n\t * <p>This method does not support setting {@code static final} fields.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException(Exception)}.\n\t * @param field the field to set\n\t * @param target the target object on which to set the field\n\t * (or {@code null} for a static field)\n\t * @param value the value to set (may be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "target",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "void",
    "signature": "public void setField(Field field, @Nullable Object target, @Nullable Object value)",
    "source_code": "\tpublic static void setField(Field field, @Nullable Object target, @Nullable Object value) {\n\t\ttry {\n\t\t\tfield.set(target, value);\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\thandleReflectionException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#setNext(Node<K,next)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Node<K",
      "next"
    ],
    "position": {
      "column": 1,
      "line": 510
    },
    "return": "void",
    "signature": "public void setNext(@Nullable Node<K, V> next)",
    "source_code": "\t\tpublic void setNext(@Nullable Node<K, V> next) {\n\t\t\tthis.next = next;\n\t\t}"
  },
  "org.springframework.util.<unknown>#setPrevious(Node<K,prev)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Node<K",
      "prev"
    ],
    "position": {
      "column": 1,
      "line": 501
    },
    "return": "void",
    "signature": "public void setPrevious(@Nullable Node<K, V> prev)",
    "source_code": "\t\tpublic void setPrevious(@Nullable Node<K, V> prev) {\n\t\t\tthis.prev = prev;\n\t\t}"
  },
  "org.springframework.util.<unknown>#shallowCopyFieldState(src,dest)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Given the source object and the destination, which must be the same class\n\t * or a subclass, copy all fields, including inherited fields. Designed to\n\t * work on objects with public no-arg constructors.\n\t * @throws IllegalStateException if introspection fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "src",
      "dest"
    ],
    "position": {
      "column": 1,
      "line": 752
    },
    "return": "void",
    "signature": "public void shallowCopyFieldState(final Object src, final Object dest)",
    "source_code": "\tpublic static void shallowCopyFieldState(final Object src, final Object dest) {\n\t\tAssert.notNull(src, \"Source for field copy cannot be null\");\n\t\tAssert.notNull(dest, \"Destination for field copy cannot be null\");\n\t\tif (!src.getClass().isAssignableFrom(dest.getClass())) {\n\t\t\tthrow new IllegalArgumentException(\"Destination class [\" + dest.getClass().getName() +\n\t\t\t\t\t\"] must be same or subclass as source class [\" + src.getClass().getName() + \"]\");\n\t\t}\n\t\tdoWithFields(src.getClass(), field -> {\n\t\t\tmakeAccessible(field);\n\t\t\tObject srcValue = field.get(src);\n\t\t\tfield.set(dest, srcValue);\n\t\t}, COPYABLE_FIELDS);\n\t}"
  },
  "org.springframework.util.<unknown>#tryAdvance(Entry<K,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 431
    },
    "return": "boolean",
    "signature": "public boolean tryAdvance(Consumer<? super Entry<K, List<V>>> action)",
    "source_code": "\t\t\tpublic boolean tryAdvance(Consumer<? super Entry<K, List<V>>> action) {\n\t\t\t\treturn this.delegate.tryAdvance(entry -> action.accept(new UnmodifiableEntry<>(entry)));\n\t\t\t}"
  },
  "org.springframework.util.comparator.<unknown>#compare(o1,o2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o1",
      "o2"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "int",
    "signature": "public int compare(@Nullable T o1, @Nullable T o2)",
    "source_code": "\tpublic int compare(@Nullable T o1, @Nullable T o2) {\n\t\tif (o1 == o2) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (o1 == null) {\n\t\t\treturn (this.nullsLow ? -1 : 1);\n\t\t}\n\t\tif (o2 == null) {\n\t\t\treturn (this.nullsLow ? 1 : -1);\n\t\t}\n\t\treturn this.nonNullComparator.compare(o1, o2);\n\t}"
  },
  "org.springframework.util.concurrent.<unknown>#get(timeout,unit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "T",
    "signature": "public T get(long timeout, TimeUnit unit)",
    "source_code": "\tpublic T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n\t\treturn adaptInternal(this.adaptee.get(timeout, unit));\n\t}"
  },
  "org.springframework.util.xml.<unknown>#characters(ch,start,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ch",
      "start",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "void",
    "signature": "public void characters(char[] ch, int start, int length)",
    "source_code": "\tpublic void characters(char[] ch, int start, int length) {\n\t\tString data = new String(ch, start, length);\n\t\tNode parent = getParent();\n\t\tNode lastChild = parent.getLastChild();\n\t\tif (lastChild != null && lastChild.getNodeType() == Node.TEXT_NODE) {\n\t\t\t((Text) lastChild).appendData(data);\n\t\t}\n\t\telse {\n\t\t\tText text = this.document.createTextNode(data);\n\t\t\tparent.appendChild(text);\n\t\t}\n\t}"
  },
  "org.springframework.util.xml.<unknown>#createEventStreamWriter(eventWriter,eventFactory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link XMLStreamWriter} that writes to a {@link XMLEventWriter}.\n\t * @return a stream writer that writes to an event writer\n\t * @since 3.0.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "eventWriter",
      "eventFactory"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "XMLStreamWriter",
    "signature": "public XMLStreamWriter createEventStreamWriter(XMLEventWriter eventWriter, XMLEventFactory eventFactory)",
    "source_code": "\tpublic static XMLStreamWriter createEventStreamWriter(XMLEventWriter eventWriter, XMLEventFactory eventFactory) {\n\t\treturn new XMLEventStreamWriter(eventWriter, eventFactory);\n\t}"
  },
  "org.springframework.util.xml.<unknown>#endElement(uri,localName,qName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri",
      "localName",
      "qName"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "void",
    "signature": "public void endElement(String uri, String localName, String qName)",
    "source_code": "\tpublic void endElement(String uri, String localName, String qName) {\n\t\tthis.elements.remove(this.elements.size() - 1);\n\t}"
  },
  "org.springframework.util.xml.<unknown>#getChildElementByTagName(ele,childEleName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Utility method that returns the first child element identified by its name.\n\t * @param ele the DOM element to analyze\n\t * @param childEleName the child element name to look for\n\t * @return the {@code org.w3c.dom.Element} instance, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "childEleName"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "Element",
    "signature": "public Element getChildElementByTagName(Element ele, String childEleName)",
    "source_code": "\tpublic static Element getChildElementByTagName(Element ele, String childEleName) {\n\t\tAssert.notNull(ele, \"Element must not be null\");\n\t\tAssert.notNull(childEleName, \"Element name must not be null\");\n\t\tNodeList nl = ele.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (node instanceof Element element && nodeNameMatch(node, childEleName)) {\n\t\t\t\treturn element;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.util.xml.<unknown>#getChildElementValueByTagName(ele,childEleName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Utility method that returns the first child element value identified by its name.\n\t * @param ele the DOM element to analyze\n\t * @param childEleName the child element name to look for\n\t * @return the extracted text value, or {@code null} if no child element found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "childEleName"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "String",
    "signature": "public String getChildElementValueByTagName(Element ele, String childEleName)",
    "source_code": "\tpublic static String getChildElementValueByTagName(Element ele, String childEleName) {\n\t\tElement child = getChildElementByTagName(ele, childEleName);\n\t\treturn (child != null ? getTextValue(child) : null);\n\t}"
  },
  "org.springframework.util.xml.<unknown>#getChildElementsByTagName(ele,childEleName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieves all child elements of the given DOM element that match the given element name.\n\t * Only look at the direct child level of the given element; do not go into further depth\n\t * (in contrast to the DOM API's {@code getElementsByTagName} method).\n\t * @param ele the DOM element to analyze\n\t * @param childEleName the child element name to look for\n\t * @return a List of child {@code org.w3c.dom.Element} instances\n\t * @see org.w3c.dom.Element\n\t * @see org.w3c.dom.Element#getElementsByTagName\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "childEleName"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "List<Element>",
    "signature": "public List<Element> getChildElementsByTagName(Element ele, String childEleName)",
    "source_code": "\tpublic static List<Element> getChildElementsByTagName(Element ele, String childEleName) {\n\t\treturn getChildElementsByTagName(ele, new String[] {childEleName});\n\t}"
  },
  "org.springframework.util.xml.<unknown>#getChildElementsByTagName(ele,childEleNames)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieves all child elements of the given DOM element that match any of the given element names.\n\t * Only looks at the direct child level of the given element; do not go into further depth\n\t * (in contrast to the DOM API's {@code getElementsByTagName} method).\n\t * @param ele the DOM element to analyze\n\t * @param childEleNames the child element names to look for\n\t * @return a List of child {@code org.w3c.dom.Element} instances\n\t * @see org.w3c.dom.Element\n\t * @see org.w3c.dom.Element#getElementsByTagName\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "childEleNames"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "List<Element>",
    "signature": "public List<Element> getChildElementsByTagName(Element ele, String... childEleNames)",
    "source_code": "\tpublic static List<Element> getChildElementsByTagName(Element ele, String... childEleNames) {\n\t\tAssert.notNull(ele, \"Element must not be null\");\n\t\tAssert.notNull(childEleNames, \"Element names collection must not be null\");\n\t\tList<String> childEleNameList = Arrays.asList(childEleNames);\n\t\tNodeList nl = ele.getChildNodes();\n\t\tList<Element> childEles = new ArrayList<>();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (node instanceof Element element && nodeNameMatch(node, childEleNameList)) {\n\t\t\t\tchildEles.add(element);\n\t\t\t}\n\t\t}\n\t\treturn childEles;\n\t}"
  },
  "org.springframework.util.xml.<unknown>#ignorableWhitespace(ch,start,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ch",
      "start",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "void",
    "signature": "public void ignorableWhitespace(char[] ch, int start, int length)",
    "source_code": "\tpublic void ignorableWhitespace(char[] ch, int start, int length) {\n\t}"
  },
  "org.springframework.util.xml.<unknown>#nodeNameEquals(node,desiredName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Namespace-aware equals comparison. Returns {@code true} if either\n\t * {@link Node#getLocalName} or {@link Node#getNodeName} equals\n\t * {@code desiredName}, otherwise returns {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "node",
      "desiredName"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "boolean",
    "signature": "public boolean nodeNameEquals(Node node, String desiredName)",
    "source_code": "\tpublic static boolean nodeNameEquals(Node node, String desiredName) {\n\t\tAssert.notNull(node, \"Node must not be null\");\n\t\tAssert.notNull(desiredName, \"Desired name must not be null\");\n\t\treturn nodeNameMatch(node, desiredName);\n\t}"
  },
  "org.springframework.util.xml.<unknown>#processingInstruction(target,data)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "data"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void processingInstruction(String target, String data)",
    "source_code": "\tpublic void processingInstruction(String target, String data) {\n\t\tNode parent = getParent();\n\t\tProcessingInstruction pi = this.document.createProcessingInstruction(target, data);\n\t\tparent.appendChild(pi);\n\t}"
  },
  "org.springframework.util.xml.<unknown>#setFeature(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void setFeature(String name, boolean value)",
    "source_code": "\tpublic void setFeature(String name, boolean value) throws SAXNotRecognizedException, SAXNotSupportedException {\n\t\tif (NAMESPACES_FEATURE_NAME.equals(name)) {\n\t\t\tthis.namespacesFeature = value;\n\t\t}\n\t\telse if (NAMESPACE_PREFIXES_FEATURE_NAME.equals(name)) {\n\t\t\tthis.namespacePrefixesFeature = value;\n\t\t}\n\t\telse {\n\t\t\tsuper.setFeature(name, value);\n\t\t}\n\t}"
  },
  "org.springframework.util.xml.<unknown>#startElement(uri,localName,qName,attributes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri",
      "localName",
      "qName",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void startElement(String uri, String localName, String qName, Attributes attributes)",
    "source_code": "\tpublic void startElement(String uri, String localName, String qName, Attributes attributes) {\n\t\tNode parent = getParent();\n\t\tElement element = this.document.createElementNS(uri, qName);\n\t\tfor (int i = 0; i < attributes.getLength(); i++) {\n\t\t\tString attrUri = attributes.getURI(i);\n\t\t\tString attrQname = attributes.getQName(i);\n\t\t\tString value = attributes.getValue(i);\n\t\t\tif (!attrQname.startsWith(\"xmlns\")) {\n\t\t\t\telement.setAttributeNS(attrUri, attrQname, value);\n\t\t\t}\n\t\t}\n\t\telement = (Element) parent.appendChild(element);\n\t\tthis.elements.add(element);\n\t}"
  },
  "org.springframework.util.xml.<unknown>#startPrefixMapping(prefix,namespace)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Start the prefix mapping for the given prefix.\n\t * @see org.xml.sax.ContentHandler#startPrefixMapping(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "prefix",
      "namespace"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "protected void startPrefixMapping(@Nullable String prefix, String namespace)",
    "source_code": "\tprotected void startPrefixMapping(@Nullable String prefix, String namespace) throws SAXException {\n\t\tif (getContentHandler() != null && StringUtils.hasLength(namespace)) {\n\t\t\tif (prefix == null) {\n\t\t\t\tprefix = \"\";\n\t\t\t}\n\t\t\tif (!namespace.equals(this.namespaces.get(prefix))) {\n\t\t\t\tgetContentHandler().startPrefixMapping(prefix, namespace);\n\t\t\t\tthis.namespaces.put(prefix, namespace);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.xml.<unknown>#startPrefixMapping(prefix,uri)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "prefix",
      "uri"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void startPrefixMapping(String prefix, String uri)",
    "source_code": "\tpublic void startPrefixMapping(String prefix, String uri) {\n\t}"
  },
  "org.springframework.validation.<unknown>#addCustomFormatter(formatter,fieldTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a custom formatter, applying it to the specified field types only, if any,\n\t * or otherwise to all fields matching the {@link Formatter}-declared type.\n\t * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.\n\t * @param formatter the formatter to add (does not need to generically declare a\n\t * field type if field types are explicitly specified as parameters)\n\t * @param fieldTypes the field types to apply the formatter to, or none if to be\n\t * derived from the given {@link Formatter} implementation class\n\t * @since 4.2\n\t * @see #registerCustomEditor(Class, PropertyEditor)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "formatter",
      "fieldTypes"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "void",
    "signature": "public void addCustomFormatter(Formatter<?> formatter, Class<?>... fieldTypes)",
    "source_code": "\tpublic void addCustomFormatter(Formatter<?> formatter, Class<?>... fieldTypes) {\n\t\tFormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);\n\t\tif (ObjectUtils.isEmpty(fieldTypes)) {\n\t\t\tgetPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter);\n\t\t}\n\t\telse {\n\t\t\tfor (Class<?> fieldType : fieldTypes) {\n\t\t\t\tgetPropertyEditorRegistry().registerCustomEditor(fieldType, adapter);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.<unknown>#addCustomFormatter(formatter,fields)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a custom formatter for the field type specified in {@link Formatter} class,\n\t * applying it to the specified fields only, if any, or otherwise to all fields.\n\t * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.\n\t * @param formatter the formatter to add, generically declared for a specific type\n\t * @param fields the fields to apply the formatter to, or none if to be applied to all\n\t * @since 4.2\n\t * @see #registerCustomEditor(Class, String, PropertyEditor)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "formatter",
      "fields"
    ],
    "position": {
      "column": 1,
      "line": 666
    },
    "return": "void",
    "signature": "public void addCustomFormatter(Formatter<?> formatter, String... fields)",
    "source_code": "\tpublic void addCustomFormatter(Formatter<?> formatter, String... fields) {\n\t\tFormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);\n\t\tClass<?> fieldType = adapter.getFieldType();\n\t\tif (ObjectUtils.isEmpty(fields)) {\n\t\t\tgetPropertyEditorRegistry().registerCustomEditor(fieldType, adapter);\n\t\t}\n\t\telse {\n\t\t\tfor (String field : fields) {\n\t\t\t\tgetPropertyEditorRegistry().registerCustomEditor(fieldType, field, adapter);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.<unknown>#convertIfNecessary(value,requiredType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 720
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType) throws TypeMismatchException {\n\t\treturn getTypeConverter().convertIfNecessary(value, requiredType);\n\t}"
  },
  "org.springframework.validation.<unknown>#convertIfNecessary(value,requiredType,field)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 734
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field)\n\t\t\tthrows TypeMismatchException {\n\n\t\treturn getTypeConverter().convertIfNecessary(value, requiredType, field);\n\t}"
  },
  "org.springframework.validation.<unknown>#convertIfNecessary(value,requiredType,methodParam)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "methodParam"
    ],
    "position": {
      "column": 1,
      "line": 726
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable MethodParameter methodParam)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable MethodParameter methodParam) throws TypeMismatchException {\n\n\t\treturn getTypeConverter().convertIfNecessary(value, requiredType, methodParam);\n\t}"
  },
  "org.springframework.validation.<unknown>#convertIfNecessary(value,requiredType,typeDescriptor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "typeDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 742
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable TypeDescriptor typeDescriptor)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable TypeDescriptor typeDescriptor) throws TypeMismatchException {\n\n\t\treturn getTypeConverter().convertIfNecessary(value, requiredType, typeDescriptor);\n\t}"
  },
  "org.springframework.validation.<unknown>#findCustomEditor(requiredType,propertyPath)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "propertyPath"
    ],
    "position": {
      "column": 1,
      "line": 714
    },
    "return": "PropertyEditor",
    "signature": "public PropertyEditor findCustomEditor(@Nullable Class<?> requiredType, @Nullable String propertyPath)",
    "source_code": "\tpublic PropertyEditor findCustomEditor(@Nullable Class<?> requiredType, @Nullable String propertyPath) {\n\t\treturn getPropertyEditorRegistry().findCustomEditor(requiredType, propertyPath);\n\t}"
  },
  "org.springframework.validation.<unknown>#findEditor(field,valueType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation delegates to the\n\t * {@link #getPropertyEditorRegistry() PropertyEditorRegistry}'s\n\t * editor lookup facility, if available.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "valueType"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "PropertyEditor",
    "signature": "public PropertyEditor findEditor(@Nullable String field, @Nullable Class<?> valueType)",
    "source_code": "\tpublic PropertyEditor findEditor(@Nullable String field, @Nullable Class<?> valueType) {\n\t\tPropertyEditorRegistry editorRegistry = getPropertyEditorRegistry();\n\t\tif (editorRegistry != null) {\n\t\t\tClass<?> valueTypeToUse = valueType;\n\t\t\tif (valueTypeToUse == null) {\n\t\t\t\tvalueTypeToUse = getFieldType(field);\n\t\t\t}\n\t\t\treturn editorRegistry.findCustomEditor(valueTypeToUse, fixedField(field));\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.validation.<unknown>#formatFieldValue(field,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Format the given value for the specified field.\n\t * <p>The default implementation simply returns the field value as-is.\n\t * @param field the field to check\n\t * @param value the value of the field (either a rejected value\n\t * other than from a binding error, or an actual field value)\n\t * @return the formatted value\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "field",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "Object",
    "signature": "protected Object formatFieldValue(String field, @Nullable Object value)",
    "source_code": "\tprotected Object formatFieldValue(String field, @Nullable Object value) {\n\t\treturn value;\n\t}"
  },
  "org.springframework.validation.<unknown>#recordFieldValue(field,type,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "type",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "void",
    "signature": "public void recordFieldValue(String field, Class<?> type, @Nullable Object value)",
    "source_code": "\tpublic void recordFieldValue(String field, Class<?> type, @Nullable Object value) {\n\t\tthis.fieldTypes.put(field, type);\n\t\tthis.fieldValues.put(field, value);\n\t}"
  },
  "org.springframework.validation.<unknown>#registerCustomEditor(requiredType,field,propertyEditor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "field",
      "propertyEditor"
    ],
    "position": {
      "column": 1,
      "line": 708
    },
    "return": "void",
    "signature": "public void registerCustomEditor(@Nullable Class<?> requiredType, @Nullable String field, PropertyEditor propertyEditor)",
    "source_code": "\tpublic void registerCustomEditor(@Nullable Class<?> requiredType, @Nullable String field, PropertyEditor propertyEditor) {\n\t\tgetPropertyEditorRegistry().registerCustomEditor(requiredType, field, propertyEditor);\n\t}"
  },
  "org.springframework.validation.<unknown>#registerCustomEditor(requiredType,propertyEditor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "propertyEditor"
    ],
    "position": {
      "column": 1,
      "line": 703
    },
    "return": "void",
    "signature": "public void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor)",
    "source_code": "\tpublic void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor) {\n\t\tgetPropertyEditorRegistry().registerCustomEditor(requiredType, propertyEditor);\n\t}"
  },
  "org.springframework.validation.<unknown>#reject(errorCode,errorArgs,defaultMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\t\taddError(new ObjectError(getObjectName(), resolveMessageCodes(errorCode), errorArgs, defaultMessage));\n\t}"
  },
  "org.springframework.validation.<unknown>#rejectValue(field,errorCode,errorArgs,defaultMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode, @Nullable Object[] errorArgs,\n\t\t\t@Nullable String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode, @Nullable Object[] errorArgs,\n\t\t\t@Nullable String defaultMessage) {\n\n\t\tif (!StringUtils.hasLength(getNestedPath()) && !StringUtils.hasLength(field)) {\n\t\t\t// We're at the top of the nested object hierarchy,\n\t\t\t// so the present level is not a field but rather the top object.\n\t\t\t// The best we can do is register a global error here...\n\t\t\treject(errorCode, errorArgs, defaultMessage);\n\t\t\treturn;\n\t\t}\n\n\t\tString fixedField = fixedField(field);\n\t\tObject newVal = getActualFieldValue(fixedField);\n\t\tFieldError fe = new FieldError(getObjectName(), fixedField, newVal, false,\n\t\t\t\tresolveMessageCodes(errorCode, field), errorArgs, defaultMessage);\n\t\taddError(fe);\n\t}"
  },
  "org.springframework.validation.<unknown>#resolveMessageCodes(errorCode,field)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "String[]",
    "signature": "public String[] resolveMessageCodes(String errorCode, @Nullable String field)",
    "source_code": "\tpublic String[] resolveMessageCodes(String errorCode, @Nullable String field) {\n\t\treturn getMessageCodesResolver().resolveMessageCodes(\n\t\t\t\terrorCode, getObjectName(), fixedField(field), getFieldType(field));\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#getArgumentsForConstraint(objectName,field,descriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return FieldError arguments for a validation error on the given field.\n\t * Invoked for each violated constraint.\n\t * <p>The default implementation returns a first argument indicating the field name\n\t * (see {@link #getResolvableField}). Afterwards, it adds all actual constraint\n\t * annotation attributes (i.e. excluding \"message\", \"groups\" and \"payload\") in\n\t * alphabetical order of their attribute names.\n\t * <p>Can be overridden to e.g. add further attributes from the constraint descriptor.\n\t * @param objectName the name of the target object\n\t * @param field the field that caused the binding error\n\t * @param descriptor the JSR-303 constraint descriptor\n\t * @return the Object array that represents the FieldError arguments\n\t * @see org.springframework.validation.FieldError#getArguments\n\t * @see org.springframework.context.support.DefaultMessageSourceResolvable\n\t * @see org.springframework.validation.DefaultBindingErrorProcessor#getArgumentsForBindError\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "objectName",
      "field",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "Object[]",
    "signature": "protected Object[] getArgumentsForConstraint(String objectName, String field, ConstraintDescriptor<?> descriptor)",
    "source_code": "\tprotected Object[] getArgumentsForConstraint(String objectName, String field, ConstraintDescriptor<?> descriptor) {\n\t\tList<Object> arguments = new ArrayList<>();\n\t\targuments.add(getResolvableField(objectName, field));\n\t\t// Using a TreeMap for alphabetical ordering of attribute names\n\t\tMap<String, Object> attributesToExpose = new TreeMap<>();\n\t\tdescriptor.getAttributes().forEach((attributeName, attributeValue) -> {\n\t\t\tif (!internalAnnotationAttributes.contains(attributeName)) {\n\t\t\t\tif (attributeValue instanceof String str) {\n\t\t\t\t\tattributeValue = new ResolvableAttribute(str);\n\t\t\t\t}\n\t\t\t\tattributesToExpose.put(attributeName, attributeValue);\n\t\t\t}\n\t\t});\n\t\targuments.addAll(attributesToExpose.values());\n\t\treturn arguments.toArray();\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#getRejectedValue(field,violation,bindingResult)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extract the rejected value behind the given constraint violation,\n\t * for exposure through the Spring errors representation.\n\t * @param field the field that caused the binding error\n\t * @param violation the corresponding JSR-303 ConstraintViolation\n\t * @param bindingResult a Spring BindingResult for the backing object\n\t * which contains the current field's value\n\t * @return the invalid value to expose as part of the field error\n\t * @since 4.2\n\t * @see jakarta.validation.ConstraintViolation#getInvalidValue()\n\t * @see org.springframework.validation.FieldError#getRejectedValue()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "field",
      "violation",
      "bindingResult"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "Object",
    "signature": "protected Object getRejectedValue(String field, ConstraintViolation<Object> violation, BindingResult bindingResult)",
    "source_code": "\tprotected Object getRejectedValue(String field, ConstraintViolation<Object> violation, BindingResult bindingResult) {\n\t\tObject invalidValue = violation.getInvalidValue();\n\t\tif (!field.isEmpty() && !field.contains(\"[]\") &&\n\t\t\t\t(invalidValue == violation.getLeafBean() || field.contains(\"[\") || field.contains(\".\"))) {\n\t\t\t// Possibly a bean constraint with property path: retrieve the actual property value.\n\t\t\t// However, explicitly avoid this for \"address[]\" style paths that we can't handle.\n\t\t\tinvalidValue = bindingResult.getRawFieldValue(field);\n\t\t}\n\t\treturn invalidValue;\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#getResolvableField(objectName,field)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Build a resolvable wrapper for the specified field, allowing to resolve the field's\n\t * name in a {@code MessageSource}.\n\t * <p>The default implementation returns a first argument indicating the field:\n\t * of type {@code DefaultMessageSourceResolvable}, with \"objectName.field\" and \"field\"\n\t * as codes, and with the plain field name as default message.\n\t * @param objectName the name of the target object\n\t * @param field the field that caused the binding error\n\t * @return a corresponding {@code MessageSourceResolvable} for the specified field\n\t * @since 4.3\n\t * @see #getArgumentsForConstraint\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "objectName",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "MessageSourceResolvable",
    "signature": "protected MessageSourceResolvable getResolvableField(String objectName, String field)",
    "source_code": "\tprotected MessageSourceResolvable getResolvableField(String objectName, String field) {\n\t\tString[] codes = new String[] {objectName + Errors.NESTED_PATH_SEPARATOR + field, field};\n\t\treturn new DefaultMessageSourceResolvable(codes, field);\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#processConstraintViolations(violations,errors)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given JSR-303 ConstraintViolations, adding corresponding errors to\n\t * the provided Spring {@link Errors} object.\n\t * @param violations the JSR-303 ConstraintViolation results\n\t * @param errors the Spring errors object to register to\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "violations",
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "protected void processConstraintViolations(Set<ConstraintViolation<Object>> violations, Errors errors)",
    "source_code": "\tprotected void processConstraintViolations(Set<ConstraintViolation<Object>> violations, Errors errors) {\n\t\tfor (ConstraintViolation<Object> violation : violations) {\n\t\t\tString field = determineField(violation);\n\t\t\tFieldError fieldError = errors.getFieldError(field);\n\t\t\tif (fieldError == null || !fieldError.isBindingFailure()) {\n\t\t\t\ttry {\n\t\t\t\t\tConstraintDescriptor<?> cd = violation.getConstraintDescriptor();\n\t\t\t\t\tString errorCode = determineErrorCode(cd);\n\t\t\t\t\tObject[] errorArgs = getArgumentsForConstraint(errors.getObjectName(), field, cd);\n\t\t\t\t\tif (errors instanceof BindingResult bindingResult) {\n\t\t\t\t\t\t// Can do custom FieldError registration with invalid value from ConstraintViolation,\n\t\t\t\t\t\t// as necessary for Hibernate Validator compatibility (non-indexed set path in field)\n\t\t\t\t\t\tString nestedField = bindingResult.getNestedPath() + field;\n\t\t\t\t\t\tif (nestedField.isEmpty()) {\n\t\t\t\t\t\t\tString[] errorCodes = bindingResult.resolveMessageCodes(errorCode);\n\t\t\t\t\t\t\tObjectError error = new ViolationObjectError(\n\t\t\t\t\t\t\t\t\terrors.getObjectName(), errorCodes, errorArgs, violation, this);\n\t\t\t\t\t\t\tbindingResult.addError(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tObject rejectedValue = getRejectedValue(field, violation, bindingResult);\n\t\t\t\t\t\t\tString[] errorCodes = bindingResult.resolveMessageCodes(errorCode, field);\n\t\t\t\t\t\t\tFieldError error = new ViolationFieldError(errors.getObjectName(), nestedField,\n\t\t\t\t\t\t\t\t\trejectedValue, errorCodes, errorArgs, violation, this);\n\t\t\t\t\t\t\tbindingResult.addError(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Got no BindingResult - can only do standard rejectValue call\n\t\t\t\t\t\t// with automatic extraction of the current field value\n\t\t\t\t\t\terrors.rejectValue(field, errorCode, errorArgs, violation.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\t\tthrow new IllegalStateException(\"JSR-303 validated property '\" + field +\n\t\t\t\t\t\t\t\"' does not have a corresponding accessor for Spring data binding - \" +\n\t\t\t\t\t\t\t\"check your DataBinder's configuration (bean property versus direct field access)\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validate(object,groups)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 350
    },
    "return": "Set<ConstraintViolation<T>>",
    "signature": "public Set<ConstraintViolation<T>> validate(T object, Class<?>... groups)",
    "source_code": "\tpublic <T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groups) {\n\t\tAssert.state(this.targetValidator != null, \"No target Validator set\");\n\t\treturn this.targetValidator.validate(object, groups);\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validate(target,errors)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void validate(Object target, Errors errors)",
    "source_code": "\tpublic void validate(Object target, Errors errors) {\n\t\tif (this.targetValidator != null) {\n\t\t\tprocessConstraintViolations(this.targetValidator.validate(target), errors);\n\t\t}\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validate(target,errors,validationHints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "errors",
      "validationHints"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void validate(Object target, Errors errors, Object... validationHints)",
    "source_code": "\tpublic void validate(Object target, Errors errors, Object... validationHints) {\n\t\tif (this.targetValidator != null) {\n\t\t\tprocessConstraintViolations(\n\t\t\t\t\tthis.targetValidator.validate(target, asValidationGroups(validationHints)), errors);\n\t\t}\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validateProperty(object,propertyName,groups)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "propertyName",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "Set<ConstraintViolation<T>>",
    "signature": "public Set<ConstraintViolation<T>> validateProperty(T object, String propertyName, Class<?>... groups)",
    "source_code": "\tpublic <T> Set<ConstraintViolation<T>> validateProperty(T object, String propertyName, Class<?>... groups) {\n\t\tAssert.state(this.targetValidator != null, \"No target Validator set\");\n\t\treturn this.targetValidator.validateProperty(object, propertyName, groups);\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validateValue(beanType,propertyName,value,groups)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanType",
      "propertyName",
      "value",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "Set<ConstraintViolation<T>>",
    "signature": "public Set<ConstraintViolation<T>> validateValue(Class<T> beanType, String propertyName, Object value, Class<?>... groups)",
    "source_code": "\tpublic <T> Set<ConstraintViolation<T>> validateValue(\n\t\t\tClass<T> beanType, String propertyName, Object value, Class<?>... groups) {\n\n\t\tAssert.state(this.targetValidator != null, \"No target Validator set\");\n\t\treturn this.targetValidator.validateValue(beanType, propertyName, value, groups);\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validateValue(targetType,fieldName,value,errors,validationHints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetType",
      "fieldName",
      "value",
      "errors",
      "validationHints"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "void",
    "signature": "public void validateValue(Class<?> targetType, String fieldName, @Nullable Object value, Errors errors, Object... validationHints)",
    "source_code": "\tpublic void validateValue(\n\t\t\tClass<?> targetType, String fieldName, @Nullable Object value, Errors errors, Object... validationHints) {\n\n\t\tif (this.targetValidator != null) {\n\t\t\tprocessConstraintViolations(this.targetValidator.validateValue(\n\t\t\t\t\t(Class) targetType, fieldName, value, asValidationGroups(validationHints)), errors);\n\t\t}\n\t}"
  },
  "org.springframework.validation.support.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "Object",
    "signature": "public Object put(String key, @Nullable Object value)",
    "source_code": "\tpublic Object put(String key, @Nullable Object value) {\n\t\tremoveBindingResultIfNecessary(key, value);\n\t\treturn super.put(key, value);\n\t}"
  },
  "org.springframework.validation.support.<unknown>#putAll(String,map)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ?> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ?> map) {\n\t\tmap.forEach(this::removeBindingResultIfNecessary);\n\t\tsuper.putAll(map);\n\t}"
  },
  "org.springframework.web.bind.<unknown>#errorsToStringList(errors,source,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #errorsToStringList(List)} that uses a\n\t * {@link MessageSource} to resolve the message code of the error, or fall\n\t * back on the error's default message.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "source",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "List<String>",
    "signature": "public List<String> errorsToStringList(List<? extends ObjectError> errors, @Nullable MessageSource source, Locale locale)",
    "source_code": "\tpublic static List<String> errorsToStringList(\n\t\t\tList<? extends ObjectError> errors, @Nullable MessageSource source, Locale locale) {\n\n\t\treturn (source != null ?\n\t\t\t\terrorsToStringList(errors, error -> source.getMessage(error, locale)) :\n\t\t\t\terrorsToStringList(errors));\n\t}"
  },
  "org.springframework.web.bind.<unknown>#getDetailMessageArguments(messageSource,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "Object[]",
    "signature": "public Object[] getDetailMessageArguments(MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic Object[] getDetailMessageArguments(MessageSource messageSource, Locale locale) {\n\t\treturn new Object[] {\n\t\t\t\terrorsToStringList(getGlobalErrors(), messageSource, locale),\n\t\t\t\terrorsToStringList(getFieldErrors(), messageSource, locale)\n\t\t};\n\t}"
  },
  "org.springframework.web.bind.<unknown>#reject(errorCode,defaultMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "void",
    "signature": "public void reject(String errorCode, String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, String defaultMessage) {\n\t\tthis.source.reject(errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.web.bind.<unknown>#reject(errorCode,errorArgs,defaultMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\t\tthis.source.reject(errorCode, errorArgs, defaultMessage);\n\t}"
  },
  "org.springframework.web.bind.<unknown>#rejectValue(field,errorCode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode) {\n\t\tthis.source.rejectValue(field, errorCode);\n\t}"
  },
  "org.springframework.web.bind.<unknown>#rejectValue(field,errorCode,defaultMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode, String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode, String defaultMessage) {\n\t\tthis.source.rejectValue(field, errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.web.bind.<unknown>#rejectValue(field,errorCode,errorArgs,defaultMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode, @Nullable Object[] errorArgs,\n\t\t\t@Nullable String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode, @Nullable Object[] errorArgs,\n\t\t\t@Nullable String defaultMessage) {\n\n\t\tthis.source.rejectValue(field, errorCode, errorArgs, defaultMessage);\n\t}"
  },
  "org.springframework.web.bind.<unknown>#resolveErrorMessages(messageSource,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve global and field errors to messages with the given\n\t * {@link MessageSource} and {@link Locale}.\n\t * @return a Map with errors as key and resolved messages as value\n\t * @since 6.0.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "String>",
    "signature": "public String> resolveErrorMessages(MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic Map<ObjectError, String> resolveErrorMessages(MessageSource messageSource, Locale locale) {\n\t\tMap<ObjectError, String> map = new LinkedHashMap<>();\n\t\taddMessages(map, getGlobalErrors(), messageSource, locale);\n\t\taddMessages(map, getFieldErrors(), messageSource, locale);\n\t\treturn map;\n\t}"
  },
  "org.springframework.web.bind.annotation.<unknown>#registerMethodHints(hints,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "protected void registerMethodHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerMethodHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tfor (Parameter parameter : method.getParameters()) {\n\t\t\tregisterParameterTypeHints(hints, MethodParameter.forParameter(parameter));\n\t\t}\n\t\tregisterReturnTypeHints(hints, MethodParameter.forExecutable(method, -1));\n\t}"
  },
  "org.springframework.web.bind.annotation.<unknown>#registerParameterTypeHints(hints,methodParameter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "methodParameter"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "void",
    "signature": "protected void registerParameterTypeHints(ReflectionHints hints, MethodParameter methodParameter)",
    "source_code": "\tprotected void registerParameterTypeHints(ReflectionHints hints, MethodParameter methodParameter) {\n\t\tif (methodParameter.hasParameterAnnotation(RequestBody.class) ||\n\t\t\t\tmethodParameter.hasParameterAnnotation(ModelAttribute.class) ||\n\t\t\t\tmethodParameter.hasParameterAnnotation(RequestPart.class)) {\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, methodParameter.getGenericParameterType());\n\t\t}\n\t\telse if (HttpEntity.class.isAssignableFrom(methodParameter.getParameterType())) {\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, getHttpEntityType(methodParameter));\n\t\t}\n\t}"
  },
  "org.springframework.web.bind.annotation.<unknown>#registerReflectionHints(hints,element)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "void",
    "signature": "public void registerReflectionHints(ReflectionHints hints, AnnotatedElement element)",
    "source_code": "\tpublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tif (element instanceof Class<?> type) {\n\t\t\tregisterTypeHints(hints, type);\n\t\t}\n\t\telse if (element instanceof Method method) {\n\t\t\tregisterMethodHints(hints, method);\n\t\t}\n\t}"
  },
  "org.springframework.web.bind.annotation.<unknown>#registerReturnTypeHints(hints,returnTypeParameter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "returnTypeParameter"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "protected void registerReturnTypeHints(ReflectionHints hints, MethodParameter returnTypeParameter)",
    "source_code": "\tprotected void registerReturnTypeHints(ReflectionHints hints, MethodParameter returnTypeParameter) {\n\t\tif (AnnotatedElementUtils.hasAnnotation(returnTypeParameter.getContainingClass(), ResponseBody.class) ||\n\t\t\t\treturnTypeParameter.hasMethodAnnotation(ResponseBody.class)) {\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, returnTypeParameter.getGenericParameterType());\n\t\t}\n\t\telse if (HttpEntity.class.isAssignableFrom(returnTypeParameter.getParameterType())) {\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, getHttpEntityType(returnTypeParameter));\n\t\t}\n\t}"
  },
  "org.springframework.web.bind.annotation.<unknown>#registerTypeHints(hints,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "void",
    "signature": "protected void registerTypeHints(ReflectionHints hints, Class<?> type)",
    "source_code": "\tprotected void registerTypeHints(ReflectionHints hints, Class<?> type) {\n\t\thints.registerType(type);\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#addBindValue(Map<String,params,key,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "params",
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "protected void addBindValue(Map<String, Object> params, String key, List<?> values)",
    "source_code": "\tprotected static void addBindValue(Map<String, Object> params, String key, List<?> values) {\n\t\tif (!CollectionUtils.isEmpty(values)) {\n\t\t\tvalues = values.stream()\n\t\t\t\t\t.map(value -> value instanceof FormFieldPart formFieldPart ? formFieldPart.value() : value)\n\t\t\t\t\t.toList();\n\t\t\tparams.put(key, values.size() == 1 ? values.get(0) : values);\n\t\t}\n\t}"
  },
  "org.springframework.web.client.<unknown>#create(message,statusCode,statusText,headers,body,charset)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #create(HttpStatusCode, String, HttpHeaders, byte[], Charset)}\n\t * with an optional prepared message.\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "statusCode",
      "statusText",
      "headers",
      "body",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "HttpClientErrorException",
    "signature": "public HttpClientErrorException create(@Nullable String message, HttpStatusCode statusCode,\n\t\t\tString statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset)",
    "source_code": "\tpublic static HttpClientErrorException create(@Nullable String message, HttpStatusCode statusCode,\n\t\t\tString statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset) {\n\n\t\tif (statusCode instanceof HttpStatus status) {\n\t\t\treturn switch (status) {\n\t\t\t\tcase BAD_REQUEST -> message != null ?\n\t\t\t\t\t\tnew BadRequest(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew BadRequest(statusText, headers, body, charset);\n\t\t\t\tcase UNAUTHORIZED -> message != null ?\n\t\t\t\t\t\tnew Unauthorized(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew Unauthorized(statusText, headers, body, charset);\n\t\t\t\tcase FORBIDDEN -> message != null ?\n\t\t\t\t\t\tnew Forbidden(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew Forbidden(statusText, headers, body, charset);\n\t\t\t\tcase NOT_FOUND -> message != null ?\n\t\t\t\t\t\tnew NotFound(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew NotFound(statusText, headers, body, charset);\n\t\t\t\tcase METHOD_NOT_ALLOWED -> message != null ?\n\t\t\t\t\t\tnew MethodNotAllowed(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew MethodNotAllowed(statusText, headers, body, charset);\n\t\t\t\tcase NOT_ACCEPTABLE -> message != null ?\n\t\t\t\t\t\tnew NotAcceptable(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew NotAcceptable(statusText, headers, body, charset);\n\t\t\t\tcase CONFLICT -> message != null ?\n\t\t\t\t\t\tnew Conflict(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew Conflict(statusText, headers, body, charset);\n\t\t\t\tcase GONE -> message != null ?\n\t\t\t\t\t\tnew Gone(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew Gone(statusText, headers, body, charset);\n\t\t\t\tcase UNSUPPORTED_MEDIA_TYPE -> message != null ?\n\t\t\t\t\t\tnew UnsupportedMediaType(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew UnsupportedMediaType(statusText, headers, body, charset);\n\t\t\t\tcase TOO_MANY_REQUESTS -> message != null ?\n\t\t\t\t\t\tnew TooManyRequests(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew TooManyRequests(statusText, headers, body, charset);\n\t\t\t\tcase UNPROCESSABLE_ENTITY -> message != null ?\n\t\t\t\t\t\tnew UnprocessableEntity(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew UnprocessableEntity(statusText, headers, body, charset);\n\t\t\t\tdefault -> message != null ?\n\t\t\t\t\t\tnew HttpClientErrorException(message, statusCode, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew HttpClientErrorException(statusCode, statusText, headers, body, charset);\n\t\t\t};\n\t\t}\n\t\tif (message != null) {\n\t\t\treturn new HttpClientErrorException(message, statusCode, statusText, headers, body, charset);\n\t\t}\n\t\telse {\n\t\t\treturn new HttpClientErrorException(statusCode, statusText, headers, body, charset);\n\t\t}\n\t}"
  },
  "org.springframework.web.client.<unknown>#create(statusCode,statusText,headers,body,charset)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@code HttpClientErrorException} or an HTTP status specific subclass.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCode",
      "statusText",
      "headers",
      "body",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "HttpClientErrorException",
    "signature": "public HttpClientErrorException create(HttpStatusCode statusCode, String statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset)",
    "source_code": "\tpublic static HttpClientErrorException create(\n\t\t\tHttpStatusCode statusCode, String statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset) {\n\n\t\treturn create(null, statusCode, statusText, headers, body, charset);\n\t}"
  },
  "org.springframework.web.client.<unknown>#delete(url,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 603
    },
    "return": "void",
    "signature": "public void delete(String url, Map<String, ?> uriVariables)",
    "source_code": "\tpublic void delete(String url, Map<String, ?> uriVariables) throws RestClientException {\n\t\texecute(url, HttpMethod.DELETE, null, null, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#delete(url,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 598
    },
    "return": "void",
    "signature": "public void delete(String url, Object... uriVariables)",
    "source_code": "\tpublic void delete(String url, Object... uriVariables) throws RestClientException {\n\t\texecute(url, HttpMethod.DELETE, null, null, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#doExecute(url,method,requestCallback,responseExtractor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the given method on the provided URI.\n\t * <p>The {@link ClientHttpRequest} is processed using the {@link RequestCallback};\n\t * the response with the {@link ResponseExtractor}.\n\t * @param url the fully-expanded URL to connect to\n\t * @param method the HTTP method to execute (GET, POST, etc.)\n\t * @param requestCallback object that prepares the request (can be {@code null})\n\t * @param responseExtractor object that extracts the return value from the response (can be {@code null})\n\t * @return an arbitrary object, as returned by the {@link ResponseExtractor}\n\t * @deprecated in favor of {@link #doExecute(URI, String, HttpMethod, RequestCallback, ResponseExtractor)}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "url",
      "method",
      "requestCallback",
      "responseExtractor"
    ],
    "position": {
      "column": 1,
      "line": 820
    },
    "return": "T",
    "signature": "protected T doExecute(URI url, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor)",
    "source_code": "\tprotected <T> T doExecute(URI url, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor) throws RestClientException {\n\n\t\treturn doExecute(url, null, method, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#doExecute(url,uriTemplate,method,requestCallback,responseExtractor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the given method on the provided URI.\n\t * <p>The {@link ClientHttpRequest} is processed using the {@link RequestCallback};\n\t * the response with the {@link ResponseExtractor}.\n\t * @param url the fully-expanded URL to connect to\n\t * @param uriTemplate the URI template that was used for creating the expanded URL\n\t * @param method the HTTP method to execute (GET, POST, etc.)\n\t * @param requestCallback object that prepares the request (can be {@code null})\n\t * @param responseExtractor object that extracts the return value from the response (can be {@code null})\n\t * @return an arbitrary object, as returned by the {@link ResponseExtractor}\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "url",
      "uriTemplate",
      "method",
      "requestCallback",
      "responseExtractor"
    ],
    "position": {
      "column": 1,
      "line": 840
    },
    "return": "T",
    "signature": "protected T doExecute(URI url, @Nullable String uriTemplate, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor)",
    "source_code": "\tprotected <T> T doExecute(URI url, @Nullable String uriTemplate, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor) throws RestClientException {\n\n\t\tAssert.notNull(url, \"url is required\");\n\t\tAssert.notNull(method, \"HttpMethod is required\");\n\t\tClientHttpRequest request;\n\t\ttry {\n\t\t\trequest = createRequest(url, method);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tResourceAccessException exception = createResourceAccessException(url, method, ex);\n\t\t\tthrow exception;\n\t\t}\n\t\tClientRequestObservationContext observationContext = new ClientRequestObservationContext(request);\n\t\tobservationContext.setUriTemplate(uriTemplate);\n\t\tObservation observation = ClientHttpObservationDocumentation.HTTP_CLIENT_EXCHANGES.observation(this.observationConvention,\n\t\t\t\tDEFAULT_OBSERVATION_CONVENTION, () -> observationContext, this.observationRegistry).start();\n\t\tClientHttpResponse response = null;\n\t\ttry {\n\t\t\tif (requestCallback != null) {\n\t\t\t\trequestCallback.doWithRequest(request);\n\t\t\t}\n\t\t\tresponse = request.execute();\n\t\t\tobservationContext.setResponse(response);\n\t\t\thandleResponse(url, method, response);\n\t\t\treturn (responseExtractor != null ? responseExtractor.extractData(response) : null);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tResourceAccessException exception = createResourceAccessException(url, method, ex);\n\t\t\tobservation.error(exception);\n\t\t\tthrow exception;\n\t\t}\n\t\tcatch (RestClientException exc) {\n\t\t\tobservation.error(exc);\n\t\t\tthrow exc;\n\t\t}\n\t\tfinally {\n\t\t\tif (response != null) {\n\t\t\t\tresponse.close();\n\t\t\t}\n\t\t\tobservation.stop();\n\t\t}\n\t}"
  },
  "org.springframework.web.client.<unknown>#exchange(entity,responseType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 708
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> exchange(RequestEntity<?> entity, ParameterizedTypeReference<T> responseType)",
    "source_code": "\tpublic <T> ResponseEntity<T> exchange(RequestEntity<?> entity, ParameterizedTypeReference<T> responseType)\n\t\t\tthrows RestClientException {\n\n\t\tType type = responseType.getType();\n\t\tRequestCallback requestCallback = httpEntityCallback(entity, type);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(type);\n\t\treturn nonNull(doExecute(resolveUrl(entity), resolveUriTemplate(entity), entity.getMethod(), requestCallback, responseExtractor));\n\t}"
  },
  "org.springframework.web.client.<unknown>#exchange(url,method,requestEntity,responseType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "method",
      "requestEntity",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 689
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> exchange(URI url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType)",
    "source_code": "\tpublic <T> ResponseEntity<T> exchange(URI url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType) throws RestClientException {\n\n\t\tType type = responseType.getType();\n\t\tRequestCallback requestCallback = httpEntityCallback(requestEntity, type);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(type);\n\t\treturn nonNull(execute(url, method, requestCallback, responseExtractor));\n\t}"
  },
  "org.springframework.web.client.<unknown>#exchange(url,method,requestEntity,responseType,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "method",
      "requestEntity",
      "responseType",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 679
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType, Map<String, ?> uriVariables)",
    "source_code": "\tpublic <T> ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType, Map<String, ?> uriVariables) throws RestClientException {\n\n\t\tType type = responseType.getType();\n\t\tRequestCallback requestCallback = httpEntityCallback(requestEntity, type);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(type);\n\t\treturn nonNull(execute(url, method, requestCallback, responseExtractor, uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#exchange(url,method,requestEntity,responseType,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "method",
      "requestEntity",
      "responseType",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 669
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType, Object... uriVariables)",
    "source_code": "\tpublic <T> ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType, Object... uriVariables) throws RestClientException {\n\n\t\tType type = responseType.getType();\n\t\tRequestCallback requestCallback = httpEntityCallback(requestEntity, type);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(type);\n\t\treturn nonNull(execute(url, method, requestCallback, responseExtractor, uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#execute(uriTemplate,method,requestCallback,responseExtractor,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>To provide a {@code RequestCallback} or {@code ResponseExtractor} only,\n\t * but not both, consider using:\n\t * <ul>\n\t * <li>{@link #acceptHeaderRequestCallback(Class)}\n\t * <li>{@link #httpEntityCallback(Object)}\n\t * <li>{@link #httpEntityCallback(Object, Type)}\n\t * <li>{@link #responseEntityExtractor(Type)}\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "method",
      "requestCallback",
      "responseExtractor",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 780
    },
    "return": "T",
    "signature": "public T execute(String uriTemplate, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor, Map<String, ?> uriVariables)",
    "source_code": "\tpublic <T> T execute(String uriTemplate, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor, Map<String, ?> uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tURI url = getUriTemplateHandler().expand(uriTemplate, uriVariables);\n\t\treturn doExecute(url, uriTemplate, method, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#execute(uriTemplate,method,requestCallback,responseExtractor,uriVariables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>To provide a {@code RequestCallback} or {@code ResponseExtractor} only,\n\t * but not both, consider using:\n\t * <ul>\n\t * <li>{@link #acceptHeaderRequestCallback(Class)}\n\t * <li>{@link #httpEntityCallback(Object)}\n\t * <li>{@link #httpEntityCallback(Object, Type)}\n\t * <li>{@link #responseEntityExtractor(Type)}\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "method",
      "requestCallback",
      "responseExtractor",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 760
    },
    "return": "T",
    "signature": "public T execute(String uriTemplate, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor, Object... uriVariables)",
    "source_code": "\tpublic <T> T execute(String uriTemplate, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor, Object... uriVariables) throws RestClientException {\n\n\t\tURI url = getUriTemplateHandler().expand(uriTemplate, uriVariables);\n\t\treturn doExecute(url, uriTemplate, method, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#execute(url,method,requestCallback,responseExtractor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>To provide a {@code RequestCallback} or {@code ResponseExtractor} only,\n\t * but not both, consider using:\n\t * <ul>\n\t * <li>{@link #acceptHeaderRequestCallback(Class)}\n\t * <li>{@link #httpEntityCallback(Object)}\n\t * <li>{@link #httpEntityCallback(Object, Type)}\n\t * <li>{@link #responseEntityExtractor(Type)}\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "method",
      "requestCallback",
      "responseExtractor"
    ],
    "position": {
      "column": 1,
      "line": 801
    },
    "return": "T",
    "signature": "public T execute(URI url, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor)",
    "source_code": "\tpublic <T> T execute(URI url, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor) throws RestClientException {\n\n\t\treturn doExecute(url, null, method, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#getForEntity(url,responseType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 418
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> getForEntity(URI url, Class<T> responseType)",
    "source_code": "\tpublic <T> ResponseEntity<T> getForEntity(URI url, Class<T> responseType) throws RestClientException {\n\t\tRequestCallback requestCallback = acceptHeaderRequestCallback(responseType);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType);\n\t\treturn nonNull(execute(url, HttpMethod.GET, requestCallback, responseExtractor));\n\t}"
  },
  "org.springframework.web.client.<unknown>#getForEntity(url,responseType,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "responseType",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> getForEntity(String url, Class<T> responseType, Map<String, ?> uriVariables)",
    "source_code": "\tpublic <T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Map<String, ?> uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = acceptHeaderRequestCallback(responseType);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType);\n\t\treturn nonNull(execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#getForEntity(url,responseType,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "responseType",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 400
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> getForEntity(String url, Class<T> responseType, Object... uriVariables)",
    "source_code": "\tpublic <T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Object... uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = acceptHeaderRequestCallback(responseType);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType);\n\t\treturn nonNull(execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#getForObject(url,responseType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 392
    },
    "return": "T",
    "signature": "public T getForObject(URI url, Class<T> responseType)",
    "source_code": "\tpublic <T> T getForObject(URI url, Class<T> responseType) throws RestClientException {\n\t\tRequestCallback requestCallback = acceptHeaderRequestCallback(responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.GET, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#getForObject(url,responseType,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "responseType",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 383
    },
    "return": "T",
    "signature": "public T getForObject(String url, Class<T> responseType, Map<String, ?> uriVariables)",
    "source_code": "\tpublic <T> T getForObject(String url, Class<T> responseType, Map<String, ?> uriVariables) throws RestClientException {\n\t\tRequestCallback requestCallback = acceptHeaderRequestCallback(responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#getForObject(url,responseType,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "responseType",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 374
    },
    "return": "T",
    "signature": "public T getForObject(String url, Class<T> responseType, Object... uriVariables)",
    "source_code": "\tpublic <T> T getForObject(String url, Class<T> responseType, Object... uriVariables) throws RestClientException {\n\t\tRequestCallback requestCallback = acceptHeaderRequestCallback(responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#handleResponse(url,method,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the given response, performing appropriate logging and\n\t * invoking the {@link ResponseErrorHandler} if necessary.\n\t * <p>Can be overridden in subclasses.\n\t * @param url the fully-expanded URL to connect to\n\t * @param method the HTTP method to execute (GET, POST, etc.)\n\t * @param response the resulting {@link ClientHttpResponse}\n\t * @throws IOException if propagated from {@link ResponseErrorHandler}\n\t * @since 4.1.6\n\t * @see #setErrorHandler\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "url",
      "method",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 902
    },
    "return": "void",
    "signature": "protected void handleResponse(URI url, HttpMethod method, ClientHttpResponse response)",
    "source_code": "\tprotected void handleResponse(URI url, HttpMethod method, ClientHttpResponse response) throws IOException {\n\t\tResponseErrorHandler errorHandler = getErrorHandler();\n\t\tboolean hasError = errorHandler.hasError(response);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\ttry {\n\t\t\t\tHttpStatusCode statusCode = response.getStatusCode();\n\t\t\t\tlogger.debug(\"Response \" + statusCode);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tlogger.debug(\"Failed to obtain response status code\", ex);\n\t\t\t}\n\t\t}\n\t\tif (hasError) {\n\t\t\terrorHandler.handleError(url, method, response);\n\t\t}\n\t}"
  },
  "org.springframework.web.client.<unknown>#headForHeaders(url,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 433
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders headForHeaders(String url, Map<String, ?> uriVariables)",
    "source_code": "\tpublic HttpHeaders headForHeaders(String url, Map<String, ?> uriVariables) throws RestClientException {\n\t\treturn nonNull(execute(url, HttpMethod.HEAD, null, headersExtractor(), uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#headForHeaders(url,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 428
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders headForHeaders(String url, Object... uriVariables)",
    "source_code": "\tpublic HttpHeaders headForHeaders(String url, Object... uriVariables) throws RestClientException {\n\t\treturn nonNull(execute(url, HttpMethod.HEAD, null, headersExtractor(), uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#httpEntityCallback(requestBody,responseType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestCallback} implementation that:\n\t * <ol>\n\t * <li>Sets the request {@code Accept} header based on the given response\n\t * type, cross-checked against the configured message converters.\n\t * <li>Writes the given object to the request stream.\n\t * </ol>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestBody",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 944
    },
    "return": "RequestCallback",
    "signature": "public RequestCallback httpEntityCallback(@Nullable Object requestBody, Type responseType)",
    "source_code": "\tpublic <T> RequestCallback httpEntityCallback(@Nullable Object requestBody, Type responseType) {\n\t\treturn new HttpEntityRequestCallback(requestBody, responseType);\n\t}"
  },
  "org.springframework.web.client.<unknown>#optionsForAllow(url,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 623
    },
    "return": "Set<HttpMethod>",
    "signature": "public Set<HttpMethod> optionsForAllow(String url, Map<String, ?> uriVariables)",
    "source_code": "\tpublic Set<HttpMethod> optionsForAllow(String url, Map<String, ?> uriVariables) throws RestClientException {\n\t\tResponseExtractor<HttpHeaders> headersExtractor = headersExtractor();\n\t\tHttpHeaders headers = execute(url, HttpMethod.OPTIONS, null, headersExtractor, uriVariables);\n\t\treturn (headers != null ? headers.getAllow() : Collections.emptySet());\n\t}"
  },
  "org.springframework.web.client.<unknown>#optionsForAllow(url,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 616
    },
    "return": "Set<HttpMethod>",
    "signature": "public Set<HttpMethod> optionsForAllow(String url, Object... uriVariables)",
    "source_code": "\tpublic Set<HttpMethod> optionsForAllow(String url, Object... uriVariables) throws RestClientException {\n\t\tResponseExtractor<HttpHeaders> headersExtractor = headersExtractor();\n\t\tHttpHeaders headers = execute(url, HttpMethod.OPTIONS, null, headersExtractor, uriVariables);\n\t\treturn (headers != null ? headers.getAllow() : Collections.emptySet());\n\t}"
  },
  "org.springframework.web.client.<unknown>#patchForObject(url,request,responseType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 585
    },
    "return": "T",
    "signature": "public T patchForObject(URI url, @Nullable Object request, Class<T> responseType)",
    "source_code": "\tpublic <T> T patchForObject(URI url, @Nullable Object request, Class<T> responseType)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters());\n\t\treturn execute(url, HttpMethod.PATCH, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#patchForObject(url,request,responseType,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 574
    },
    "return": "T",
    "signature": "public T patchForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tMap<String, ?> uriVariables)",
    "source_code": "\tpublic <T> T patchForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tMap<String, ?> uriVariables) throws RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.PATCH, requestCallback, responseExtractor, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#patchForObject(url,request,responseType,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "T",
    "signature": "public T patchForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tObject... uriVariables)",
    "source_code": "\tpublic <T> T patchForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tObject... uriVariables) throws RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.PATCH, requestCallback, responseExtractor, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForEntity(url,request,responseType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 525
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> postForEntity(URI url, @Nullable Object request, Class<T> responseType)",
    "source_code": "\tpublic <T> ResponseEntity<T> postForEntity(URI url, @Nullable Object request, Class<T> responseType)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType);\n\t\treturn nonNull(execute(url, HttpMethod.POST, requestCallback, responseExtractor));\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForEntity(url,request,responseType,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 516
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> postForEntity(String url, @Nullable Object request,\n\t\t\tClass<T> responseType, Map<String, ?> uriVariables)",
    "source_code": "\tpublic <T> ResponseEntity<T> postForEntity(String url, @Nullable Object request,\n\t\t\tClass<T> responseType, Map<String, ?> uriVariables) throws RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType);\n\t\treturn nonNull(execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForEntity(url,request,responseType,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 507
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> postForEntity(String url, @Nullable Object request,\n\t\t\tClass<T> responseType, Object... uriVariables)",
    "source_code": "\tpublic <T> ResponseEntity<T> postForEntity(String url, @Nullable Object request,\n\t\t\tClass<T> responseType, Object... uriVariables) throws RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType);\n\t\treturn nonNull(execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForLocation(url,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 467
    },
    "return": "URI",
    "signature": "public URI postForLocation(URI url, @Nullable Object request)",
    "source_code": "\tpublic URI postForLocation(URI url, @Nullable Object request) throws RestClientException {\n\t\tRequestCallback requestCallback = httpEntityCallback(request);\n\t\tHttpHeaders headers = execute(url, HttpMethod.POST, requestCallback, headersExtractor());\n\t\treturn (headers != null ? headers.getLocation() : null);\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForLocation(url,request,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 457
    },
    "return": "URI",
    "signature": "public URI postForLocation(String url, @Nullable Object request, Map<String, ?> uriVariables)",
    "source_code": "\tpublic URI postForLocation(String url, @Nullable Object request, Map<String, ?> uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request);\n\t\tHttpHeaders headers = execute(url, HttpMethod.POST, requestCallback, headersExtractor(), uriVariables);\n\t\treturn (headers != null ? headers.getLocation() : null);\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForLocation(url,request,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 447
    },
    "return": "URI",
    "signature": "public URI postForLocation(String url, @Nullable Object request, Object... uriVariables)",
    "source_code": "\tpublic URI postForLocation(String url, @Nullable Object request, Object... uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request);\n\t\tHttpHeaders headers = execute(url, HttpMethod.POST, requestCallback, headersExtractor(), uriVariables);\n\t\treturn (headers != null ? headers.getLocation() : null);\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForObject(url,request,responseType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 497
    },
    "return": "T",
    "signature": "public T postForObject(URI url, @Nullable Object request, Class<T> responseType)",
    "source_code": "\tpublic <T> T postForObject(URI url, @Nullable Object request, Class<T> responseType)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters());\n\t\treturn execute(url, HttpMethod.POST, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForObject(url,request,responseType,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "T",
    "signature": "public T postForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tMap<String, ?> uriVariables)",
    "source_code": "\tpublic <T> T postForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tMap<String, ?> uriVariables) throws RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForObject(url,request,responseType,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 475
    },
    "return": "T",
    "signature": "public T postForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tObject... uriVariables)",
    "source_code": "\tpublic <T> T postForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tObject... uriVariables) throws RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#put(url,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 553
    },
    "return": "void",
    "signature": "public void put(URI url, @Nullable Object request)",
    "source_code": "\tpublic void put(URI url, @Nullable Object request) throws RestClientException {\n\t\tRequestCallback requestCallback = httpEntityCallback(request);\n\t\texecute(url, HttpMethod.PUT, requestCallback, null);\n\t}"
  },
  "org.springframework.web.client.<unknown>#put(url,request,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 545
    },
    "return": "void",
    "signature": "public void put(String url, @Nullable Object request, Map<String, ?> uriVariables)",
    "source_code": "\tpublic void put(String url, @Nullable Object request, Map<String, ?> uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request);\n\t\texecute(url, HttpMethod.PUT, requestCallback, null, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#put(url,request,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 537
    },
    "return": "void",
    "signature": "public void put(String url, @Nullable Object request, Object... uriVariables)",
    "source_code": "\tpublic void put(String url, @Nullable Object request, Object... uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request);\n\t\texecute(url, HttpMethod.PUT, requestCallback, null, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#setDefaultUriVariables(Map<String,uriVars)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure default URI variable values. This is a shortcut for:\n\t * <pre class=\"code\">\n\t * DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory();\n\t * handler.setDefaultUriVariables(...);\n\t *\n\t * RestTemplate restTemplate = new RestTemplate();\n\t * restTemplate.setUriTemplateHandler(handler);\n\t * </pre>\n\t * @param uriVars the default URI variable values\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVars"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "void",
    "signature": "public void setDefaultUriVariables(Map<String, ?> uriVars)",
    "source_code": "\tpublic void setDefaultUriVariables(Map<String, ?> uriVars) {\n\t\tif (this.uriTemplateHandler instanceof DefaultUriBuilderFactory factory) {\n\t\t\tfactory.setDefaultUriVariables(uriVars);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"This property is not supported with the configured UriTemplateHandler.\");\n\t\t}\n\t}"
  },
  "org.springframework.web.context.<unknown>#configureAndRefreshWebApplicationContext(wac,sc)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "wac",
      "sc"
    ],
    "position": {
      "column": 1,
      "line": 364
    },
    "return": "void",
    "signature": "protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc)",
    "source_code": "\tprotected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) {\n\t\tif (ObjectUtils.identityToString(wac).equals(wac.getId())) {\n\t\t\t// The application context id is still set to its original default value\n\t\t\t// -> assign a more useful id based on available information\n\t\t\tString idParam = sc.getInitParameter(CONTEXT_ID_PARAM);\n\t\t\tif (idParam != null) {\n\t\t\t\twac.setId(idParam);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Generate default id...\n\t\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +\n\t\t\t\t\t\tObjectUtils.getDisplayString(sc.getContextPath()));\n\t\t\t}\n\t\t}\n\n\t\twac.setServletContext(sc);\n\t\tString configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);\n\t\tif (configLocationParam != null) {\n\t\t\twac.setConfigLocation(configLocationParam);\n\t\t}\n\n\t\t// The wac environment's #initPropertySources will be called in any case when the context\n\t\t// is refreshed; do it eagerly here to ensure servlet property sources are in place for\n\t\t// use in any post-processing or initialization that occurs below prior to #refresh\n\t\tConfigurableEnvironment env = wac.getEnvironment();\n\t\tif (env instanceof ConfigurableWebEnvironment cwe) {\n\t\t\tcwe.initPropertySources(sc, null);\n\t\t}\n\n\t\tcustomizeContext(sc, wac);\n\t\twac.refresh();\n\t}"
  },
  "org.springframework.web.context.<unknown>#customizeContext(sc,wac)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the {@link ConfigurableWebApplicationContext} created by this\n\t * ContextLoader after config locations have been supplied to the context\n\t * but before the context is <em>refreshed</em>.\n\t * <p>The default implementation {@linkplain #determineContextInitializerClasses(ServletContext)\n\t * determines} what (if any) context initializer classes have been specified through\n\t * {@linkplain #CONTEXT_INITIALIZER_CLASSES_PARAM context init parameters} and\n\t * {@linkplain ApplicationContextInitializer#initialize invokes each} with the\n\t * given web application context.\n\t * <p>Any {@code ApplicationContextInitializers} implementing\n\t * {@link org.springframework.core.Ordered Ordered} or marked with @{@link\n\t * org.springframework.core.annotation.Order Order} will be sorted appropriately.\n\t * @param sc the current servlet context\n\t * @param wac the newly created application context\n\t * @see #CONTEXT_INITIALIZER_CLASSES_PARAM\n\t * @see ApplicationContextInitializer#initialize(ConfigurableApplicationContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sc",
      "wac"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "void",
    "signature": "protected void customizeContext(ServletContext sc, ConfigurableWebApplicationContext wac)",
    "source_code": "\tprotected void customizeContext(ServletContext sc, ConfigurableWebApplicationContext wac) {\n\t\tList<Class<ApplicationContextInitializer<ConfigurableApplicationContext>>> initializerClasses =\n\t\t\t\tdetermineContextInitializerClasses(sc);\n\n\t\tfor (Class<ApplicationContextInitializer<ConfigurableApplicationContext>> initializerClass : initializerClasses) {\n\t\t\tClass<?> initializerContextClass =\n\t\t\t\t\tGenericTypeResolver.resolveTypeArgument(initializerClass, ApplicationContextInitializer.class);\n\t\t\tif (initializerContextClass != null && !initializerContextClass.isInstance(wac)) {\n\t\t\t\tthrow new ApplicationContextException(String.format(\n\t\t\t\t\t\t\"Could not apply context initializer [%s] since its generic parameter [%s] \" +\n\t\t\t\t\t\t\"is not assignable from the type of application context used by this \" +\n\t\t\t\t\t\t\"context loader: [%s]\", initializerClass.getName(), initializerContextClass.getName(),\n\t\t\t\t\t\twac.getClass().getName()));\n\t\t\t}\n\t\t\tthis.contextInitializers.add(BeanUtils.instantiateClass(initializerClass));\n\t\t}\n\n\t\tAnnotationAwareOrderComparator.sort(this.contextInitializers);\n\t\tfor (ApplicationContextInitializer<ConfigurableApplicationContext> initializer : this.contextInitializers) {\n\t\t\tinitializer.initialize(wac);\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#doFindPathMatchingFileResources(rootDirResource,subPattern)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Overridden version which checks for ServletContextResource\n\t * and uses {@code ServletContext.getResourcePaths} to find\n\t * matching resources below the web application root directory.\n\t * In case of other resources, delegates to the superclass version.\n\t * @see #doRetrieveMatchingServletContextResources\n\t * @see ServletContextResource\n\t * @see jakarta.servlet.ServletContext#getResourcePaths\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rootDirResource",
      "subPattern"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "Set<Resource>",
    "signature": "protected Set<Resource> doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)",
    "source_code": "\tprotected Set<Resource> doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)\n\t\t\tthrows IOException {\n\n\t\tif (rootDirResource instanceof ServletContextResource scResource) {\n\t\t\tServletContext sc = scResource.getServletContext();\n\t\t\tString fullPattern = scResource.getPath() + subPattern;\n\t\t\tSet<Resource> result = new LinkedHashSet<>(8);\n\t\t\tdoRetrieveMatchingServletContextResources(sc, fullPattern, scResource.getPath(), result);\n\t\t\treturn result;\n\t\t}\n\t\telse {\n\t\t\treturn super.doFindPathMatchingFileResources(rootDirResource, subPattern);\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#doRetrieveMatchingServletContextResources(servletContext,fullPattern,dir,result)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Recursively retrieve ServletContextResources that match the given pattern,\n\t * adding them to the given result set.\n\t * @param servletContext the ServletContext to work on\n\t * @param fullPattern the pattern to match against,\n\t * with prepended root directory path\n\t * @param dir the current directory\n\t * @param result the Set of matching Resources to add to\n\t * @throws IOException if directory contents could not be retrieved\n\t * @see ServletContextResource\n\t * @see jakarta.servlet.ServletContext#getResourcePaths\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "servletContext",
      "fullPattern",
      "dir",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "protected void doRetrieveMatchingServletContextResources(ServletContext servletContext, String fullPattern, String dir, Set<Resource> result)",
    "source_code": "\tprotected void doRetrieveMatchingServletContextResources(\n\t\t\tServletContext servletContext, String fullPattern, String dir, Set<Resource> result)\n\t\t\tthrows IOException {\n\n\t\tSet<String> candidates = servletContext.getResourcePaths(dir);\n\t\tif (candidates != null) {\n\t\t\tboolean dirDepthNotFixed = fullPattern.contains(\"**\");\n\t\t\tint jarFileSep = fullPattern.indexOf(ResourceUtils.JAR_URL_SEPARATOR);\n\t\t\tString jarFilePath = null;\n\t\t\tString pathInJarFile = null;\n\t\t\tif (jarFileSep > 0 && jarFileSep + ResourceUtils.JAR_URL_SEPARATOR.length() < fullPattern.length()) {\n\t\t\t\tjarFilePath = fullPattern.substring(0, jarFileSep);\n\t\t\t\tpathInJarFile = fullPattern.substring(jarFileSep + ResourceUtils.JAR_URL_SEPARATOR.length());\n\t\t\t}\n\t\t\tfor (String currPath : candidates) {\n\t\t\t\tif (!currPath.startsWith(dir)) {\n\t\t\t\t\t// Returned resource path does not start with relative directory:\n\t\t\t\t\t// assuming absolute path returned -> strip absolute path.\n\t\t\t\t\tint dirIndex = currPath.indexOf(dir);\n\t\t\t\t\tif (dirIndex != -1) {\n\t\t\t\t\t\tcurrPath = currPath.substring(dirIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currPath.endsWith(\"/\") && (dirDepthNotFixed || StringUtils.countOccurrencesOf(currPath, \"/\") <=\n\t\t\t\t\t\tStringUtils.countOccurrencesOf(fullPattern, \"/\"))) {\n\t\t\t\t\t// Search subdirectories recursively: ServletContext.getResourcePaths\n\t\t\t\t\t// only returns entries for one directory level.\n\t\t\t\t\tdoRetrieveMatchingServletContextResources(servletContext, fullPattern, currPath, result);\n\t\t\t\t}\n\t\t\t\tif (jarFilePath != null && getPathMatcher().match(jarFilePath, currPath)) {\n\t\t\t\t\t// Base pattern matches a jar file - search for matching entries within.\n\t\t\t\t\tString absoluteJarPath = servletContext.getRealPath(currPath);\n\t\t\t\t\tif (absoluteJarPath != null) {\n\t\t\t\t\t\tdoRetrieveMatchingJarEntries(absoluteJarPath, pathInJarFile, result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (getPathMatcher().match(fullPattern, currPath)) {\n\t\t\t\t\tresult.add(new ServletContextResource(servletContext, currPath));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#getWebApplicationContext(sc,attrName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a custom {@code WebApplicationContext} for this web app.\n\t * @param sc the ServletContext to find the web application context for\n\t * @param attrName the name of the ServletContext attribute to look for\n\t * @return the desired WebApplicationContext for this web app, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sc",
      "attrName"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "WebApplicationContext",
    "signature": "public WebApplicationContext getWebApplicationContext(ServletContext sc, String attrName)",
    "source_code": "\tpublic static WebApplicationContext getWebApplicationContext(ServletContext sc, String attrName) {\n\t\tAssert.notNull(sc, \"ServletContext must not be null\");\n\t\tObject attr = sc.getAttribute(attrName);\n\t\tif (attr == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (attr instanceof RuntimeException runtimeException) {\n\t\t\tthrow runtimeException;\n\t\t}\n\t\tif (attr instanceof Error error) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (attr instanceof Exception exception) {\n\t\t\tthrow new IllegalStateException(exception);\n\t\t}\n\t\tif (!(attr instanceof WebApplicationContext wac)) {\n\t\t\tthrow new IllegalStateException(\"Context attribute is not of type WebApplicationContext: \" + attr);\n\t\t}\n\t\treturn wac;\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#initServletPropertySources(propertySources,servletContext)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient variant of {@link #initServletPropertySources(MutablePropertySources,\n\t * ServletContext, ServletConfig)} that always provides {@code null} for the\n\t * {@link ServletConfig} parameter.\n\t * @see #initServletPropertySources(MutablePropertySources, ServletContext, ServletConfig)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertySources",
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "public void initServletPropertySources(MutablePropertySources propertySources, ServletContext servletContext)",
    "source_code": "\tpublic static void initServletPropertySources(MutablePropertySources propertySources, ServletContext servletContext) {\n\t\tinitServletPropertySources(propertySources, servletContext, null);\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#initServletPropertySources(sources,servletContext,servletConfig)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Replace {@code Servlet}-based {@link StubPropertySource stub property sources} with\n\t * actual instances populated with the given {@code servletContext} and\n\t * {@code servletConfig} objects.\n\t * <p>This method is idempotent with respect to the fact it may be called any number\n\t * of times but will perform replacement of stub property sources with their\n\t * corresponding actual property sources once and only once.\n\t * @param sources the {@link MutablePropertySources} to initialize (must not\n\t * be {@code null})\n\t * @param servletContext the current {@link ServletContext} (ignored if {@code null}\n\t * or if the {@link StandardServletEnvironment#SERVLET_CONTEXT_PROPERTY_SOURCE_NAME\n\t * servlet context property source} has already been initialized)\n\t * @param servletConfig the current {@link ServletConfig} (ignored if {@code null}\n\t * or if the {@link StandardServletEnvironment#SERVLET_CONFIG_PROPERTY_SOURCE_NAME\n\t * servlet config property source} has already been initialized)\n\t * @see org.springframework.core.env.PropertySource.StubPropertySource\n\t * @see org.springframework.core.env.ConfigurableEnvironment#getPropertySources()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sources",
      "servletContext",
      "servletConfig"
    ],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "void",
    "signature": "public void initServletPropertySources(MutablePropertySources sources,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig)",
    "source_code": "\tpublic static void initServletPropertySources(MutablePropertySources sources,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig) {\n\n\t\tAssert.notNull(sources, \"'propertySources' must not be null\");\n\t\tString name = StandardServletEnvironment.SERVLET_CONTEXT_PROPERTY_SOURCE_NAME;\n\t\tif (servletContext != null && sources.get(name) instanceof StubPropertySource) {\n\t\t\tsources.replace(name, new ServletContextPropertySource(name, servletContext));\n\t\t}\n\t\tname = StandardServletEnvironment.SERVLET_CONFIG_PROPERTY_SOURCE_NAME;\n\t\tif (servletConfig != null && sources.get(name) instanceof StubPropertySource) {\n\t\t\tsources.replace(name, new ServletConfigPropertySource(name, servletConfig));\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (getServletContext() != null && bean instanceof ServletContextAware servletContextAware) {\n\t\t\tservletContextAware.setServletContext(getServletContext());\n\t\t}\n\t\tif (getServletConfig() != null && bean instanceof ServletConfigAware servletConfigAware) {\n\t\t\tservletConfigAware.setServletConfig(getServletConfig());\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#registerEnvironmentBeans(bf,sc)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register web-specific environment beans (\"contextParameters\", \"contextAttributes\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param bf the BeanFactory to configure\n\t * @param sc the ServletContext that we're running within\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bf",
      "sc"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "public void registerEnvironmentBeans(ConfigurableListableBeanFactory bf, @Nullable ServletContext sc)",
    "source_code": "\tpublic static void registerEnvironmentBeans(ConfigurableListableBeanFactory bf, @Nullable ServletContext sc) {\n\t\tregisterEnvironmentBeans(bf, sc, null);\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#registerEnvironmentBeans(bf,servletContext,servletConfig)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register web-specific environment beans (\"contextParameters\", \"contextAttributes\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param bf the BeanFactory to configure\n\t * @param servletContext the ServletContext that we're running within\n\t * @param servletConfig the ServletConfig\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bf",
      "servletContext",
      "servletConfig"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void registerEnvironmentBeans(ConfigurableListableBeanFactory bf,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig)",
    "source_code": "\tpublic static void registerEnvironmentBeans(ConfigurableListableBeanFactory bf,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig) {\n\n\t\tif (servletContext != null && !bf.containsBean(WebApplicationContext.SERVLET_CONTEXT_BEAN_NAME)) {\n\t\t\tbf.registerSingleton(WebApplicationContext.SERVLET_CONTEXT_BEAN_NAME, servletContext);\n\t\t}\n\n\t\tif (servletConfig != null && !bf.containsBean(ConfigurableWebApplicationContext.SERVLET_CONFIG_BEAN_NAME)) {\n\t\t\tbf.registerSingleton(ConfigurableWebApplicationContext.SERVLET_CONFIG_BEAN_NAME, servletConfig);\n\t\t}\n\n\t\tif (!bf.containsBean(WebApplicationContext.CONTEXT_PARAMETERS_BEAN_NAME)) {\n\t\t\tMap<String, String> parameterMap = new HashMap<>();\n\t\t\tif (servletContext != null) {\n\t\t\t\tEnumeration<?> paramNameEnum = servletContext.getInitParameterNames();\n\t\t\t\twhile (paramNameEnum.hasMoreElements()) {\n\t\t\t\t\tString paramName = (String) paramNameEnum.nextElement();\n\t\t\t\t\tparameterMap.put(paramName, servletContext.getInitParameter(paramName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (servletConfig != null) {\n\t\t\t\tEnumeration<?> paramNameEnum = servletConfig.getInitParameterNames();\n\t\t\t\twhile (paramNameEnum.hasMoreElements()) {\n\t\t\t\t\tString paramName = (String) paramNameEnum.nextElement();\n\t\t\t\t\tparameterMap.put(paramName, servletConfig.getInitParameter(paramName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbf.registerSingleton(WebApplicationContext.CONTEXT_PARAMETERS_BEAN_NAME,\n\t\t\t\t\tCollections.unmodifiableMap(parameterMap));\n\t\t}\n\n\t\tif (!bf.containsBean(WebApplicationContext.CONTEXT_ATTRIBUTES_BEAN_NAME)) {\n\t\t\tMap<String, Object> attributeMap = new HashMap<>();\n\t\t\tif (servletContext != null) {\n\t\t\t\tEnumeration<?> attrNameEnum = servletContext.getAttributeNames();\n\t\t\t\twhile (attrNameEnum.hasMoreElements()) {\n\t\t\t\t\tString attrName = (String) attrNameEnum.nextElement();\n\t\t\t\t\tattributeMap.put(attrName, servletContext.getAttribute(attrName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbf.registerSingleton(WebApplicationContext.CONTEXT_ATTRIBUTES_BEAN_NAME,\n\t\t\t\t\tCollections.unmodifiableMap(attributeMap));\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#registerWebApplicationScopes(beanFactory,sc)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register web-specific scopes (\"request\", \"session\", \"globalSession\", \"application\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param beanFactory the BeanFactory to configure\n\t * @param sc the ServletContext that we're running within\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "sc"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void registerWebApplicationScopes(ConfigurableListableBeanFactory beanFactory,\n\t\t\t@Nullable ServletContext sc)",
    "source_code": "\tpublic static void registerWebApplicationScopes(ConfigurableListableBeanFactory beanFactory,\n\t\t\t@Nullable ServletContext sc) {\n\n\t\tbeanFactory.registerScope(WebApplicationContext.SCOPE_REQUEST, new RequestScope());\n\t\tbeanFactory.registerScope(WebApplicationContext.SCOPE_SESSION, new SessionScope());\n\t\tif (sc != null) {\n\t\t\tServletContextScope appScope = new ServletContextScope(sc);\n\t\t\tbeanFactory.registerScope(WebApplicationContext.SCOPE_APPLICATION, appScope);\n\t\t\t// Register as ServletContext attribute, for ContextCleanupListener to detect it.\n\t\t\tsc.setAttribute(ServletContextScope.class.getName(), appScope);\n\t\t}\n\n\t\tbeanFactory.registerResolvableDependency(ServletRequest.class, new RequestObjectFactory());\n\t\tbeanFactory.registerResolvableDependency(ServletResponse.class, new ResponseObjectFactory());\n\t\tbeanFactory.registerResolvableDependency(HttpSession.class, new SessionObjectFactory());\n\t\tbeanFactory.registerResolvableDependency(WebRequest.class, new WebRequestObjectFactory());\n\t\tif (jsfPresent) {\n\t\t\tFacesDependencyRegistrar.registerFacesDependencies(beanFactory);\n\t\t}\n\t}"
  },
  "org.springframework.web.filter.<unknown>#doFilter(request,response,filterChain)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "void",
    "signature": "public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)",
    "source_code": "\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\t// Lazily initialize the delegate if necessary.\n\t\tFilter delegateToUse = this.delegate;\n\t\tif (delegateToUse == null) {\n\t\t\tsynchronized (this.delegateMonitor) {\n\t\t\t\tdelegateToUse = this.delegate;\n\t\t\t\tif (delegateToUse == null) {\n\t\t\t\t\tWebApplicationContext wac = findWebApplicationContext();\n\t\t\t\t\tif (wac == null) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"No WebApplicationContext found: \" +\n\t\t\t\t\t\t\t\t\"no ContextLoaderListener or DispatcherServlet registered?\");\n\t\t\t\t\t}\n\t\t\t\t\tdelegateToUse = initDelegate(wac);\n\t\t\t\t}\n\t\t\t\tthis.delegate = delegateToUse;\n\t\t\t}\n\t\t}\n\n\t\t// Let the delegate perform the actual doFilter operation.\n\t\tinvokeDelegate(delegateToUse, request, response, filterChain);\n\t}"
  },
  "org.springframework.web.filter.<unknown>#doFilterInternal(request,response,filterChain)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Same contract as for {@code doFilter}, but guaranteed to be\n\t * just invoked once per request within a single request thread.\n\t * See {@link #shouldNotFilterAsyncDispatch()} for details.\n\t * <p>Provides HttpServletRequest and HttpServletResponse arguments instead of the\n\t * default ServletRequest and ServletResponse ones.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "void",
    "signature": "protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)",
    "source_code": "\tprotected abstract void doFilterInternal(\n\t\t\tHttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException;\n\n\t/**\n\t * Typically an ERROR dispatch happens after the REQUEST dispatch completes,\n\t * and the filter chain starts anew. On some servers however the ERROR\n\t * dispatch may be nested within the REQUEST dispatch, e.g. as a result of\n\t * calling {@code sendError} on the response. In that case we are still in"
  },
  "org.springframework.web.filter.<unknown>#doFilterNestedErrorDispatch(request,response,filterChain)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Typically an ERROR dispatch happens after the REQUEST dispatch completes,\n\t * and the filter chain starts anew. On some servers however the ERROR\n\t * dispatch may be nested within the REQUEST dispatch, e.g. as a result of\n\t * calling {@code sendError} on the response. In that case we are still in\n\t * the filter chain, on the same thread, but the request and response have\n\t * been switched to the original, unwrapped ones.\n\t * <p>Sub-classes may use this method to filter such nested ERROR dispatches\n\t * and re-apply wrapping on the request or response. {@code ThreadLocal}\n\t * context, if any, should still be active as we are still nested within\n\t * the filter chain.\n\t * @since 5.1.9\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "void",
    "signature": "protected void doFilterNestedErrorDispatch(HttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)",
    "source_code": "\tprotected void doFilterNestedErrorDispatch(HttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain) throws ServletException, IOException {\n\n\t\tfilterChain.doFilter(request, response);\n\t}"
  },
  "org.springframework.web.filter.<unknown>#invokeDelegate(delegate,request,response,filterChain)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually invoke the delegate Filter with the given request and response.\n\t * @param delegate the delegate Filter\n\t * @param request the current HTTP request\n\t * @param response the current HTTP response\n\t * @param filterChain the current FilterChain\n\t * @throws ServletException if thrown by the Filter\n\t * @throws IOException if thrown by the Filter\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "delegate",
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "void",
    "signature": "protected void invokeDelegate(Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)",
    "source_code": "\tprotected void invokeDelegate(\n\t\t\tFilter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tdelegate.doFilter(request, response, filterChain);\n\t}"
  },
  "org.springframework.web.jsf.<unknown>#callNextHandlerInChain(facesContext,fromAction,outcome,originalNavigationHandler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Method to be called by subclasses when intending to delegate to the next\n\t * handler in the NavigationHandler chain. Will always call the most\n\t * appropriate next handler, either the decorated NavigationHandler passed\n\t * in as constructor argument or the original NavigationHandler as passed\n\t * into this method - according to the position of this instance in the chain.\n\t * <p>Will call the decorated NavigationHandler specified as constructor\n\t * argument, if any. In case of a DecoratingNavigationHandler as target, the\n\t * original NavigationHandler as passed into this method will be passed on to\n\t * the next element in the chain: This ensures propagation of the original\n\t * handler that the last element in the handler chain might delegate back to.\n\t * In case of a standard NavigationHandler as target, the original handler\n\t * will simply not get passed on; no delegating back to the original is\n\t * possible further down the chain in that scenario.\n\t * <p>If no decorated NavigationHandler specified as constructor argument,\n\t * this instance is the last element in the chain. Hence, this method will\n\t * call the original NavigationHandler as passed into this method. If no\n\t * original NavigationHandler has been passed in (for example if this\n\t * instance is the last element in a chain with standard NavigationHandlers\n\t * as earlier elements), this method corresponds to a no-op.\n\t * @param facesContext the current JSF context\n\t * @param fromAction the action binding expression that was evaluated to retrieve the\n\t * specified outcome, or {@code null} if the outcome was acquired by some other means\n\t * @param outcome the logical outcome returned by a previous invoked application action\n\t * (which may be {@code null})\n\t * @param originalNavigationHandler the original NavigationHandler,\n\t * or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "facesContext",
      "fromAction",
      "outcome",
      "originalNavigationHandler"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "protected void callNextHandlerInChain(FacesContext facesContext, @Nullable String fromAction,\n\t\t\t@Nullable String outcome, @Nullable NavigationHandler originalNavigationHandler)",
    "source_code": "\tprotected final void callNextHandlerInChain(FacesContext facesContext, @Nullable String fromAction,\n\t\t\t@Nullable String outcome, @Nullable NavigationHandler originalNavigationHandler) {\n\n\t\tNavigationHandler decoratedNavigationHandler = getDecoratedNavigationHandler();\n\n\t\tif (decoratedNavigationHandler instanceof DecoratingNavigationHandler decHandler) {\n\t\t\t// DecoratingNavigationHandler specified through constructor argument:\n\t\t\t// Call it with original NavigationHandler passed in.\n\t\t\tdecHandler.handleNavigation(facesContext, fromAction, outcome, originalNavigationHandler);\n\t\t}\n\t\telse if (decoratedNavigationHandler != null) {\n\t\t\t// Standard NavigationHandler specified through constructor argument:\n\t\t\t// Call it through standard API, without original NavigationHandler passed in.\n\t\t\t// The called handler will not be able to redirect to the original handler.\n\t\t\tdecoratedNavigationHandler.handleNavigation(facesContext, fromAction, outcome);\n\t\t}\n\t\telse if (originalNavigationHandler != null) {\n\t\t\t// No NavigationHandler specified through constructor argument:\n\t\t\t// Call original handler, marking the end of this chain.\n\t\t\toriginalNavigationHandler.handleNavigation(facesContext, fromAction, outcome);\n\t\t}\n\t}"
  },
  "org.springframework.web.jsf.<unknown>#handleNavigation(facesContext,fromAction,outcome)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the navigation request implied by the specified parameters,\n\t * through delegating to the target bean in the Spring application context.\n\t * <p>The target bean needs to extend the JSF NavigationHandler class.\n\t * If it extends Spring's DecoratingNavigationHandler, the overloaded\n\t * {@code handleNavigation} method with the original NavigationHandler\n\t * as argument will be used. Else, the standard {@code handleNavigation}\n\t * method will be called.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "facesContext",
      "fromAction",
      "outcome"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void handleNavigation(FacesContext facesContext, String fromAction, String outcome)",
    "source_code": "\tpublic void handleNavigation(FacesContext facesContext, String fromAction, String outcome) {\n\t\tNavigationHandler handler = getDelegate(facesContext);\n\t\tif (handler instanceof DecoratingNavigationHandler decoratingNavigationHandler) {\n\t\t\tdecoratingNavigationHandler.handleNavigation(\n\t\t\t\t\tfacesContext, fromAction, outcome, this.originalNavigationHandler);\n\t\t}\n\t\telse {\n\t\t\thandler.handleNavigation(facesContext, fromAction, outcome);\n\t\t}\n\t}"
  },
  "org.springframework.web.jsf.<unknown>#handleNavigation(facesContext,fromAction,outcome,originalNavigationHandler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Special {@code handleNavigation} variant with explicit NavigationHandler\n\t * argument. Either called directly, by code with an explicit original handler,\n\t * or called from the standard {@code handleNavigation} method, as\n\t * plain JSF-defined NavigationHandler.\n\t * <p>Implementations should invoke {@code callNextHandlerInChain} to\n\t * delegate to the next handler in the chain. This will always call the most\n\t * appropriate next handler (see {@code callNextHandlerInChain} javadoc).\n\t * Alternatively, the decorated NavigationHandler or the passed-in original\n\t * NavigationHandler can also be called directly; however, this is not as\n\t * flexible in terms of reacting to potential positions in the chain.\n\t * @param facesContext the current JSF context\n\t * @param fromAction the action binding expression that was evaluated to retrieve the\n\t * specified outcome, or {@code null} if the outcome was acquired by some other means\n\t * @param outcome the logical outcome returned by a previous invoked application action\n\t * (which may be {@code null})\n\t * @param originalNavigationHandler the original NavigationHandler,\n\t * or {@code null} if none\n\t * @see #callNextHandlerInChain\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "facesContext",
      "fromAction",
      "outcome",
      "originalNavigationHandler"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "void",
    "signature": "public void handleNavigation(FacesContext facesContext, @Nullable String fromAction,\n\t\t\t@Nullable String outcome, @Nullable NavigationHandler originalNavigationHandler)",
    "source_code": "\tpublic abstract void handleNavigation(FacesContext facesContext, @Nullable String fromAction,\n\t\t\t@Nullable String outcome, @Nullable NavigationHandler originalNavigationHandler);\n\n\n\t/**\n\t * Method to be called by subclasses when intending to delegate to the next\n\t * handler in the NavigationHandler chain. Will always call the most\n\t * appropriate next handler, either the decorated NavigationHandler passed\n\t * in as constructor argument or the original NavigationHandler as passed\n\t * into this method - according to the position of this instance in the chain.\n\t * <p>Will call the decorated NavigationHandler specified as constructor\n\t * argument, if any. In case of a DecoratingNavigationHandler as target, the\n\t * original NavigationHandler as passed into this method will be passed on to\n\t * the next element in the chain: This ensures propagation of the original\n\t * handler that the last element in the handler chain might delegate back to.\n\t * In case of a standard NavigationHandler as target, the original handler\n\t * will simply not get passed on; no delegating back to the original is\n\t * possible further down the chain in that scenario.\n\t * <p>If no decorated NavigationHandler specified as constructor argument,\n\t * this instance is the last element in the chain. Hence, this method will\n\t * call the original NavigationHandler as passed into this method. If no\n\t * original NavigationHandler has been passed in (for example if this\n\t * instance is the last element in a chain with standard NavigationHandlers\n\t * as earlier elements), this method corresponds to a no-op.\n\t * @param facesContext the current JSF context\n\t * @param fromAction the action binding expression that was evaluated to retrieve the\n\t * specified outcome, or {@code null} if the outcome was acquired by some other means"
  },
  "org.springframework.web.jsf.el.<unknown>#getFeatureDescriptors(elContext,base)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elContext",
      "base"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "Iterator<FeatureDescriptor>",
    "signature": "public Iterator<FeatureDescriptor> getFeatureDescriptors(ELContext elContext, Object base)",
    "source_code": "\tpublic Iterator<FeatureDescriptor> getFeatureDescriptors(ELContext elContext, Object base) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.jsf.el.<unknown>#getValue(elContext,base,property)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elContext",
      "base",
      "property"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "Object",
    "signature": "public Object getValue(ELContext elContext, @Nullable Object base, Object property)",
    "source_code": "\tpublic Object getValue(ELContext elContext, @Nullable Object base, Object property) throws ELException {\n\t\tif (base != null) {\n\t\t\tif (base instanceof WebApplicationContext wac) {\n\t\t\t\tString beanName = property.toString();\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Attempting to resolve property '\" + beanName + \"' in root WebApplicationContext\");\n\t\t\t\t}\n\t\t\t\tif (wac.containsBean(beanName)) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Successfully resolved property '\" + beanName + \"' in root WebApplicationContext\");\n\t\t\t\t\t}\n\t\t\t\t\telContext.setPropertyResolved(true);\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn wac.getBean(beanName);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\t\tthrow new ELException(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Mimic standard JSF/JSP behavior when base is a Map by returning null.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (WEB_APPLICATION_CONTEXT_VARIABLE_NAME.equals(property)) {\n\t\t\t\telContext.setPropertyResolved(true);\n\t\t\t\treturn getWebApplicationContext(elContext);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.jsf.el.<unknown>#isReadOnly(elContext,base,property)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elContext",
      "base",
      "property"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "boolean",
    "signature": "public boolean isReadOnly(ELContext elContext, Object base, Object property)",
    "source_code": "\tpublic boolean isReadOnly(ELContext elContext, Object base, Object property) throws ELException {\n\t\tif (base instanceof WebApplicationContext) {\n\t\t\telContext.setPropertyResolved(true);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.jsf.el.<unknown>#setValue(elContext,base,property,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elContext",
      "base",
      "property",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "void",
    "signature": "public void setValue(ELContext elContext, Object base, Object property, Object value)",
    "source_code": "\tpublic void setValue(ELContext elContext, Object base, Object property, Object value) throws ELException {\n\t}"
  },
  "org.springframework.web.method.<unknown>#assertTargetBean(method,targetBean,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the target bean class is an instance of the class where the given\n\t * method is declared. In some cases the actual controller instance at request-\n\t * processing time may be a JDK dynamic proxy (lazy initialization, prototype\n\t * beans, and others). {@code @Controller}'s that require proxying should prefer\n\t * class-based proxy mechanisms.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetBean",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 473
    },
    "return": "void",
    "signature": "protected void assertTargetBean(Method method, Object targetBean, Object[] args)",
    "source_code": "\tprotected void assertTargetBean(Method method, Object targetBean, Object[] args) {\n\t\tClass<?> methodDeclaringClass = method.getDeclaringClass();\n\t\tClass<?> targetBeanClass = targetBean.getClass();\n\t\tif (!methodDeclaringClass.isAssignableFrom(targetBeanClass)) {\n\t\t\tString text = \"The mapped handler method class '\" + methodDeclaringClass.getName() +\n\t\t\t\t\t\"' is not an instance of the actual controller bean class '\" +\n\t\t\t\t\ttargetBeanClass.getName() + \"'. If the controller requires proxying \" +\n\t\t\t\t\t\"(e.g. due to @Transactional), please use class-based proxying.\";\n\t\t\tthrow new IllegalStateException(formatInvokeError(text, args));\n\t\t}\n\t}"
  },
  "org.springframework.web.method.<unknown>#findProvidedArgument(parameter,providedArgs)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 450
    },
    "return": "Object",
    "signature": "protected Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs)",
    "source_code": "\tprotected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\n\t\tif (!ObjectUtils.isEmpty(providedArgs)) {\n\t\t\tfor (Object providedArg : providedArgs) {\n\t\t\t\tif (parameter.getParameterType().isInstance(providedArg)) {\n\t\t\t\t\treturn providedArg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.method.<unknown>#formatArgumentError(param,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "param",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 461
    },
    "return": "String",
    "signature": "protected String formatArgumentError(MethodParameter param, String message)",
    "source_code": "\tprotected static String formatArgumentError(MethodParameter param, String message) {\n\t\treturn \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" +\n\t\t\t\tparam.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\n\t}"
  },
  "org.springframework.web.method.<unknown>#formatInvokeError(text,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "text",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 485
    },
    "return": "String",
    "signature": "protected String formatInvokeError(String text, Object[] args)",
    "source_code": "\tprotected String formatInvokeError(String text, Object[] args) {\n\t\tString formattedArgs = IntStream.range(0, args.length)\n\t\t\t\t.mapToObj(i -> (args[i] != null ?\n\t\t\t\t\t\t\"[\" + i + \"] [type=\" + args[i].getClass().getName() + \"] [value=\" + args[i] + \"]\" :\n\t\t\t\t\t\t\"[\" + i + \"] [null]\"))\n\t\t\t\t.collect(Collectors.joining(\",\\n\", \" \", \" \"));\n\t\treturn text + \"\\n\" +\n\t\t\t\t\"Controller [\" + getBeanType().getName() + \"]\\n\" +\n\t\t\t\t\"Method [\" + getBridgedMethod().toGenericString() + \"] \" +\n\t\t\t\t\"with argument values:\\n\" + formattedArgs;\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#bindRequestParameters(binder,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param request the current request\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "void",
    "signature": "protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request)",
    "source_code": "\tprotected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {\n\t\t((WebRequestDataBinder) binder).bind(request);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#constructAttribute(ctor,attributeName,parameter,binderFactory,webRequest)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Construct a new attribute instance with the given constructor.\n\t * <p>Called from\n\t * {@link #createAttribute(String, MethodParameter, WebDataBinderFactory, NativeWebRequest)}\n\t * after constructor resolution.\n\t * @param ctor the constructor to use\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ctor",
      "attributeName",
      "parameter",
      "binderFactory",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "Object",
    "signature": "protected Object constructAttribute(Constructor<?> ctor, String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest)",
    "source_code": "\tprotected Object constructAttribute(Constructor<?> ctor, String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (ctor.getParameterCount() == 0) {\n\t\t\t// A single default constructor -> clearly a standard JavaBeans arrangement.\n\t\t\treturn BeanUtils.instantiateClass(ctor);\n\t\t}\n\n\t\t// A single data class constructor -> resolve constructor arguments from request parameters.\n\t\tString[] paramNames = BeanUtils.getParameterNames(ctor);\n\t\tClass<?>[] paramTypes = ctor.getParameterTypes();\n\t\tObject[] args = new Object[paramTypes.length];\n\t\tWebDataBinder binder = binderFactory.createBinder(webRequest, null, attributeName);\n\t\tString fieldDefaultPrefix = binder.getFieldDefaultPrefix();\n\t\tString fieldMarkerPrefix = binder.getFieldMarkerPrefix();\n\t\tboolean bindingFailure = false;\n\t\tSet<String> failedParams = new HashSet<>(4);\n\n\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\tString paramName = paramNames[i];\n\t\t\tClass<?> paramType = paramTypes[i];\n\t\t\tObject value = webRequest.getParameterValues(paramName);\n\n\t\t\t// Since WebRequest#getParameter exposes a single-value parameter as an array\n\t\t\t// with a single element, we unwrap the single value in such cases, analogous\n\t\t\t// to WebExchangeDataBinder.addBindValue(Map<String, Object>, String, List<?>).\n\t\t\tif (ObjectUtils.isArray(value) && Array.getLength(value) == 1) {\n\t\t\t\tvalue = Array.get(value, 0);\n\t\t\t}\n\n\t\t\tif (value == null) {\n\t\t\t\tif (fieldDefaultPrefix != null) {\n\t\t\t\t\tvalue = webRequest.getParameter(fieldDefaultPrefix + paramName);\n\t\t\t\t}\n\t\t\t\tif (value == null) {\n\t\t\t\t\tif (fieldMarkerPrefix != null && webRequest.getParameter(fieldMarkerPrefix + paramName) != null) {\n\t\t\t\t\t\tvalue = binder.getEmptyValue(paramType);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = resolveConstructorArgument(paramName, paramType, webRequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tMethodParameter methodParam = new FieldAwareConstructorParameter(ctor, i, paramName);\n\t\t\t\tif (value == null && methodParam.isOptional()) {\n\t\t\t\t\targs[i] = (methodParam.getParameterType() == Optional.class ? Optional.empty() : null);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\targs[i] = binder.convertIfNecessary(value, paramType, methodParam);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tex.initPropertyName(paramName);\n\t\t\t\targs[i] = null;\n\t\t\t\tfailedParams.add(paramName);\n\t\t\t\tbinder.getBindingResult().recordFieldValue(paramName, paramType, value);\n\t\t\t\tbinder.getBindingErrorProcessor().processPropertyAccessException(ex, binder.getBindingResult());\n\t\t\t\tbindingFailure = true;\n\t\t\t}\n\t\t}\n\n\t\tif (bindingFailure) {\n\t\t\tBindingResult result = binder.getBindingResult();\n\t\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\t\tString paramName = paramNames[i];\n\t\t\t\tif (!failedParams.contains(paramName)) {\n\t\t\t\t\tObject value = args[i];\n\t\t\t\t\tresult.recordFieldValue(paramName, paramTypes[i], value);\n\t\t\t\t\tvalidateValueIfApplicable(binder, parameter, ctor.getDeclaringClass(), paramName, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!parameter.isOptional()) {\n\t\t\t\ttry {\n\t\t\t\t\tObject target = BeanUtils.instantiateClass(ctor, args);\n\t\t\t\t\tthrow new MethodArgumentNotValidException(parameter, result) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Object getTarget() {\n\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcatch (BeanInstantiationException ex) {\n\t\t\t\t\t// swallow and proceed without target instance\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new MethodArgumentNotValidException(parameter, result);\n\t\t}\n\n\t\ttry {\n\t\t\treturn BeanUtils.instantiateClass(ctor, args);\n\t\t}\n\t\tcatch (BeanInstantiationException ex) {\n\t\t\tThrowable cause = ex.getCause();\n\t\t\tif (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) && cause instanceof NullPointerException) {\n\t\t\t\tBindingResult result = binder.getBindingResult();\n\t\t\t\tObjectError error = new ObjectError(ctor.getName(), cause.getMessage());\n\t\t\t\tresult.addError(error);\n\t\t\t\tthrow new MethodArgumentNotValidException(ctor, result);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#contributeMethodArgument(parameter,value,builder,Map<String,uriVariables,conversionService)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "value",
      "builder",
      "Map<String",
      "uriVariables",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "void",
    "signature": "public void contributeMethodArgument(MethodParameter parameter, @Nullable Object value,\n\t\t\tUriComponentsBuilder builder, Map<String, Object> uriVariables, ConversionService conversionService)",
    "source_code": "\tpublic void contributeMethodArgument(MethodParameter parameter, @Nullable Object value,\n\t\t\tUriComponentsBuilder builder, Map<String, Object> uriVariables, ConversionService conversionService) {\n\n\t\tClass<?> paramType = parameter.getNestedParameterType();\n\t\tif (Map.class.isAssignableFrom(paramType) || MultipartFile.class == paramType || Part.class == paramType) {\n\t\t\treturn;\n\t\t}\n\n\t\tRequestParam requestParam = parameter.getParameterAnnotation(RequestParam.class);\n\t\tString name = (requestParam != null && StringUtils.hasLength(requestParam.name()) ?\n\t\t\t\trequestParam.name() : parameter.getParameterName());\n\t\tAssert.state(name != null, \"Unresolvable parameter name\");\n\n\t\tparameter = parameter.nestedIfOptional();\n\t\tif (value instanceof Optional<?> optional) {\n\t\t\tvalue = optional.orElse(null);\n\t\t}\n\n\t\tif (value == null) {\n\t\t\tif (requestParam != null &&\n\t\t\t\t\t(!requestParam.required() || !requestParam.defaultValue().equals(ValueConstants.DEFAULT_NONE))) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbuilder.queryParam(name);\n\t\t}\n\t\telse if (value instanceof Collection<?> elements) {\n\t\t\tfor (Object element : elements) {\n\t\t\t\telement = formatUriValue(conversionService, TypeDescriptor.nested(parameter, 1), element);\n\t\t\t\tbuilder.queryParam(name, element);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbuilder.queryParam(name, formatUriValue(conversionService, new TypeDescriptor(parameter), value));\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#createAttribute(attributeName,parameter,binderFactory,webRequest)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to create the model attribute if not found in the model,\n\t * with subsequent parameter binding through bean properties (unless suppressed).\n\t * <p>The default implementation typically uses the unique public no-arg constructor\n\t * if available but also handles a \"primary constructor\" approach for data classes:\n\t * It understands the JavaBeans {@code ConstructorProperties} annotation as well as\n\t * runtime-retained parameter names in the bytecode, associating request parameters\n\t * with constructor arguments by name. If no such constructor is found, the default\n\t * constructor will be used (even if not public), assuming subsequent bean property\n\t * bindings through setter methods.\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param parameter the method parameter declaration\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @see #constructAttribute(Constructor, String, MethodParameter, WebDataBinderFactory, NativeWebRequest)\n\t * @see BeanUtils#findPrimaryConstructor(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "attributeName",
      "parameter",
      "binderFactory",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "Object",
    "signature": "protected Object createAttribute(String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest)",
    "source_code": "\tprotected Object createAttribute(String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest) throws Exception {\n\n\t\tMethodParameter nestedParameter = parameter.nestedIfOptional();\n\t\tClass<?> clazz = nestedParameter.getNestedParameterType();\n\n\t\tConstructor<?> ctor = BeanUtils.getResolvableConstructor(clazz);\n\t\tObject attribute = constructAttribute(ctor, attributeName, parameter, binderFactory, webRequest);\n\t\tif (parameter != nestedParameter) {\n\t\t\tattribute = Optional.of(attribute);\n\t\t}\n\t\treturn attribute;\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#formatUriValue(cs,sourceType,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cs",
      "sourceType",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "String",
    "signature": "protected String formatUriValue(@Nullable ConversionService cs, @Nullable TypeDescriptor sourceType, @Nullable Object value)",
    "source_code": "\tprotected String formatUriValue(\n\t\t\t@Nullable ConversionService cs, @Nullable TypeDescriptor sourceType, @Nullable Object value) {\n\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\telse if (value instanceof String string) {\n\t\t\treturn string;\n\t\t}\n\t\telse if (cs != null) {\n\t\t\treturn (String) cs.convert(value, sourceType, STRING_TYPE_DESCRIPTOR);\n\t\t}\n\t\telse {\n\t\t\treturn value.toString();\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#handleMissingValue(name,parameter,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "void",
    "signature": "protected void handleMissingValue(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected void handleMissingValue(String name, MethodParameter parameter, NativeWebRequest request)\n\t\t\tthrows Exception {\n\n\t\thandleMissingValueInternal(name, parameter, request, false);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#handleMissingValueAfterConversion(name,parameter,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "void",
    "signature": "protected void handleMissingValueAfterConversion(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected void handleMissingValueAfterConversion(\n\t\t\tString name, MethodParameter parameter, NativeWebRequest request) throws Exception {\n\n\t\thandleMissingValueInternal(name, parameter, request, true);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#handleMissingValueInternal(name,parameter,request,missingAfterConversion)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request",
      "missingAfterConversion"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "protected void handleMissingValueInternal(String name, MethodParameter parameter, NativeWebRequest request, boolean missingAfterConversion)",
    "source_code": "\tprotected void handleMissingValueInternal(\n\t\t\tString name, MethodParameter parameter, NativeWebRequest request, boolean missingAfterConversion)\n\t\t\tthrows Exception {\n\n\t\tHttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);\n\t\tif (MultipartResolutionDelegate.isMultipartArgument(parameter)) {\n\t\t\tif (servletRequest == null || !MultipartResolutionDelegate.isMultipartRequest(servletRequest)) {\n\t\t\t\tthrow new MultipartException(\"Current request is not a multipart request\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new MissingServletRequestPartException(name);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new MissingServletRequestParameterException(name,\n\t\t\t\t\tparameter.getNestedParameterType().getSimpleName(), missingAfterConversion);\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add non-null return values to the {@link ModelAndViewContainer}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 480
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (returnValue != null) {\n\t\t\tString name = ModelFactory.getNameForReturnValue(returnValue, returnType);\n\t\t\tmavContainer.addAttribute(name, returnValue);\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#isBindExceptionRequired(binder,parameter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * <p>The default implementation delegates to {@link #isBindExceptionRequired(MethodParameter)}.\n\t * @param binder the data binder used to perform data binding\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @see #isBindExceptionRequired(MethodParameter)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 448
    },
    "return": "boolean",
    "signature": "protected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter) {\n\t\treturn isBindExceptionRequired(parameter);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#resolveArgument(parameter,mavContainer,webRequest,binderFactory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the argument from the model or if not found instantiate it with\n\t * its default if it is available. The model attribute is then populated\n\t * with request values via data binding and optionally validated\n\t * if {@code @java.validation.Valid} is present on the argument.\n\t * @throws BindException if data binding and validation result in an error\n\t * and the next method parameter is not of type {@link Errors}\n\t * @throws Exception if WebDataBinder initialization fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "mavContainer",
      "webRequest",
      "binderFactory"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "Object",
    "signature": "public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)",
    "source_code": "\tpublic final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n\t\tAssert.state(mavContainer != null, \"ModelAttributeMethodProcessor requires ModelAndViewContainer\");\n\t\tAssert.state(binderFactory != null, \"ModelAttributeMethodProcessor requires WebDataBinderFactory\");\n\n\t\tString name = ModelFactory.getNameForParameter(parameter);\n\t\tModelAttribute ann = parameter.getParameterAnnotation(ModelAttribute.class);\n\t\tif (ann != null) {\n\t\t\tmavContainer.setBinding(name, ann.binding());\n\t\t}\n\n\t\tObject attribute = null;\n\t\tBindingResult bindingResult = null;\n\n\t\tif (mavContainer.containsAttribute(name)) {\n\t\t\tattribute = mavContainer.getModel().get(name);\n\t\t}\n\t\telse {\n\t\t\t// Create attribute instance\n\t\t\ttry {\n\t\t\t\tattribute = createAttribute(name, parameter, binderFactory, webRequest);\n\t\t\t}\n\t\t\tcatch (MethodArgumentNotValidException ex) {\n\t\t\t\tif (isBindExceptionRequired(parameter)) {\n\t\t\t\t\t// No BindingResult parameter -> fail with BindException\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\t// Otherwise, expose null/empty value and associated BindingResult\n\t\t\t\tif (parameter.getParameterType() == Optional.class) {\n\t\t\t\t\tattribute = Optional.empty();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tattribute = ex.getTarget();\n\t\t\t\t}\n\t\t\t\tbindingResult = ex.getBindingResult();\n\t\t\t}\n\t\t}\n\n\t\tif (bindingResult == null) {\n\t\t\t// Bean property binding and validation;\n\t\t\t// skipped in case of binding failure on construction.\n\t\t\tWebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);\n\t\t\tif (binder.getTarget() != null) {\n\t\t\t\tif (!mavContainer.isBindingDisabled(name)) {\n\t\t\t\t\tbindRequestParameters(binder, webRequest);\n\t\t\t\t}\n\t\t\t\tvalidateIfApplicable(binder, parameter);\n\t\t\t\tif (binder.getBindingResult().hasErrors() && isBindExceptionRequired(binder, parameter)) {\n\t\t\t\t\tthrow new BindException(binder.getBindingResult());\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Value type adaptation, also covering java.util.Optional\n\t\t\tif (!parameter.getParameterType().isInstance(attribute)) {\n\t\t\t\tattribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);\n\t\t\t}\n\t\t\tbindingResult = binder.getBindingResult();\n\t\t}\n\n\t\t// Add resolved attribute and BindingResult at the end of the model\n\t\tMap<String, Object> bindingResultModel = bindingResult.getModel();\n\t\tmavContainer.removeAttributes(bindingResultModel);\n\t\tmavContainer.addAllAttributes(bindingResultModel);\n\n\t\treturn attribute;\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#resolveConstructorArgument(paramName,paramType,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "paramType",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 361
    },
    "return": "Object",
    "signature": "public Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)",
    "source_code": "\tpublic Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)\n\t\t\tthrows Exception {\n\n\t\tMultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class);\n\t\tif (multipartRequest != null) {\n\t\t\tList<MultipartFile> files = multipartRequest.getFiles(paramName);\n\t\t\tif (!files.isEmpty()) {\n\t\t\t\treturn (files.size() == 1 ? files.get(0) : files);\n\t\t\t}\n\t\t}\n\t\telse if (StringUtils.startsWithIgnoreCase(\n\t\t\t\trequest.getHeader(HttpHeaders.CONTENT_TYPE), MediaType.MULTIPART_FORM_DATA_VALUE)) {\n\t\t\tHttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);\n\t\t\tif (servletRequest != null && HttpMethod.POST.matches(servletRequest.getMethod())) {\n\t\t\t\tList<Part> parts = StandardServletPartUtils.getParts(servletRequest, paramName);\n\t\t\t\tif (!parts.isEmpty()) {\n\t\t\t\t\treturn (parts.size() == 1 ? parts.get(0) : parts);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#resolveName(name,parameter,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "Object",
    "signature": "protected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception {\n\t\tHttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);\n\n\t\tif (servletRequest != null) {\n\t\t\tObject mpArg = MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest);\n\t\t\tif (mpArg != MultipartResolutionDelegate.UNRESOLVABLE) {\n\t\t\t\treturn mpArg;\n\t\t\t}\n\t\t}\n\n\t\tObject arg = null;\n\t\tMultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class);\n\t\tif (multipartRequest != null) {\n\t\t\tList<MultipartFile> files = multipartRequest.getFiles(name);\n\t\t\tif (!files.isEmpty()) {\n\t\t\t\targ = (files.size() == 1 ? files.get(0) : files);\n\t\t\t}\n\t\t}\n\t\tif (arg == null) {\n\t\t\tString[] paramValues = request.getParameterValues(name);\n\t\t\tif (paramValues != null) {\n\t\t\t\targ = (paramValues.length == 1 ? paramValues[0] : paramValues);\n\t\t\t}\n\t\t}\n\t\treturn arg;\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#validateIfApplicable(binder,parameter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the model attribute if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @see WebDataBinder#validate(Object...)\n\t * @see SmartValidator#validate(Object, Errors, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 394
    },
    "return": "void",
    "signature": "protected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tbinder.validate(validationHints);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#validateValueIfApplicable(binder,parameter,targetType,fieldName,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the specified candidate value if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @param targetType the target type\n\t * @param fieldName the name of the field\n\t * @param value the candidate value\n\t * @since 5.1\n\t * @see #validateIfApplicable(WebDataBinder, MethodParameter)\n\t * @see SmartValidator#validateValue(Class, String, Object, Errors, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter",
      "targetType",
      "fieldName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 418
    },
    "return": "void",
    "signature": "protected void validateValueIfApplicable(WebDataBinder binder, MethodParameter parameter,\n\t\t\tClass<?> targetType, String fieldName, @Nullable Object value)",
    "source_code": "\tprotected void validateValueIfApplicable(WebDataBinder binder, MethodParameter parameter,\n\t\t\tClass<?> targetType, String fieldName, @Nullable Object value) {\n\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tfor (Validator validator : binder.getValidators()) {\n\t\t\t\t\tif (validator instanceof SmartValidator smartValidator) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsmartValidator.validateValue(targetType, fieldName, value,\n\t\t\t\t\t\t\t\t\tbinder.getBindingResult(), validationHints);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t\t\t// No corresponding field on the target class...\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#addAllAttributes(Map<String,attributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all attributes to the underlying model.\n\t * A shortcut for {@code getModel().addAllAttributes(Map)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer addAllAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ModelAndViewContainer addAllAttributes(@Nullable Map<String, ?> attributes) {\n\t\tgetModel().addAllAttributes(attributes);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#addAttribute(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the supplied attribute to the underlying model.\n\t * A shortcut for {@code getModel().addAttribute(String, Object)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer addAttribute(String name, @Nullable Object value)",
    "source_code": "\tpublic ModelAndViewContainer addAttribute(String name, @Nullable Object value) {\n\t\tgetModel().addAttribute(name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#contributeMethodArgument(parameter,value,builder,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * An overloaded method that uses the ConversionService created at construction.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "value",
      "builder",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "void",
    "signature": "public void contributeMethodArgument(MethodParameter parameter, Object value, UriComponentsBuilder builder,\n\t\t\tMap<String, Object> uriVariables)",
    "source_code": "\tpublic void contributeMethodArgument(MethodParameter parameter, Object value, UriComponentsBuilder builder,\n\t\t\tMap<String, Object> uriVariables) {\n\n\t\tcontributeMethodArgument(parameter, value, builder, uriVariables, this.conversionService);\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#contributeMethodArgument(parameter,value,builder,Map<String,uriVariables,conversionService)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "value",
      "builder",
      "Map<String",
      "uriVariables",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "public void contributeMethodArgument(MethodParameter parameter, Object value,\n\t\t\tUriComponentsBuilder builder, Map<String, Object> uriVariables, ConversionService conversionService)",
    "source_code": "\tpublic void contributeMethodArgument(MethodParameter parameter, Object value,\n\t\t\tUriComponentsBuilder builder, Map<String, Object> uriVariables, ConversionService conversionService) {\n\n\t\tfor (Object contributor : this.contributors) {\n\t\t\tif (contributor instanceof UriComponentsContributor ucc) {\n\t\t\t\tif (ucc.supportsParameter(parameter)) {\n\t\t\t\t\tucc.contributeMethodArgument(parameter, value, builder, uriVariables, conversionService);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (contributor instanceof HandlerMethodArgumentResolver resolver) {\n\t\t\t\tif (resolver.supportsParameter(parameter)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#getMethodArgumentValues(request,mavContainer,providedArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the method argument values for the current request, checking the provided\n\t * argument values and falling back to the configured argument resolvers.\n\t * <p>The resulting array will be passed into {@link #doInvoke}.\n\t * @since 5.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "mavContainer",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "Object[]",
    "signature": "protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs)",
    "source_code": "\tprotected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs) throws Exception {\n\n\t\tMethodParameter[] parameters = getMethodParameters();\n\t\tif (ObjectUtils.isEmpty(parameters)) {\n\t\t\treturn EMPTY_ARGS;\n\t\t}\n\n\t\tObject[] args = new Object[parameters.length];\n\t\tfor (int i = 0; i < parameters.length; i++) {\n\t\t\tMethodParameter parameter = parameters[i];\n\t\t\tparameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n\t\t\targs[i] = findProvidedArgument(parameter, providedArgs);\n\t\t\tif (args[i] != null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!this.resolvers.supportsParameter(parameter)) {\n\t\t\t\tthrow new IllegalStateException(formatArgumentError(parameter, \"No suitable resolver\"));\n\t\t\t}\n\t\t\ttry {\n\t\t\t\targs[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\t// Leave stack trace for later, exception may actually be resolved and handled...\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tString exMsg = ex.getMessage();\n\t\t\t\t\tif (exMsg != null && !exMsg.contains(parameter.getExecutable().toGenericString())) {\n\t\t\t\t\t\tlogger.debug(formatArgumentError(parameter, exMsg));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t\treturn args;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Iterate over registered {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers} and invoke the one that supports it.\n\t * @throws IllegalStateException if no suitable {@link HandlerMethodReturnValueHandler} is found.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tHandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);\n\t\tif (handler == null) {\n\t\t\tthrow new IllegalArgumentException(\"Unknown return value type: \" + returnType.getParameterType().getName());\n\t\t}\n\t\thandler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#invokeForRequest(request,mavContainer,providedArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method after resolving its argument values in the context of the given request.\n\t * <p>Argument values are commonly resolved through\n\t * {@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers}.\n\t * The {@code providedArgs} parameter however may supply argument values to be used directly,\n\t * i.e. without argument resolution. Examples of provided argument values include a\n\t * {@link WebDataBinder}, a {@link SessionStatus}, or a thrown exception instance.\n\t * Provided argument values are checked before argument resolvers.\n\t * <p>Delegates to {@link #getMethodArgumentValues} and calls {@link #doInvoke} with the\n\t * resolved arguments.\n\t * @param request the current request\n\t * @param mavContainer the ModelAndViewContainer for this request\n\t * @param providedArgs \"given\" arguments matched by type, not resolved\n\t * @return the raw value returned by the invoked method\n\t * @throws Exception raised if no suitable argument resolver can be found,\n\t * or if the method raised an exception\n\t * @see #getMethodArgumentValues\n\t * @see #doInvoke\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "mavContainer",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "Object",
    "signature": "public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs)",
    "source_code": "\tpublic Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs) throws Exception {\n\n\t\tObject[] args = getMethodArgumentValues(request, mavContainer, providedArgs);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Arguments: \" + Arrays.toString(args));\n\t\t}\n\t\treturn doInvoke(args);\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#mergeAttributes(Map<String,attributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy attributes in the supplied {@code Map} with existing objects of\n\t * the same name taking precedence (i.e. not getting replaced).\n\t * A shortcut for {@code getModel().mergeAttributes(Map<String, ?>)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer mergeAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ModelAndViewContainer mergeAttributes(@Nullable Map<String, ?> attributes) {\n\t\tgetModel().mergeAttributes(attributes);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#removeAttributes(Map<String,attributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Remove the given attributes from the model.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer removeAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ModelAndViewContainer removeAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tfor (String key : attributes.keySet()) {\n\t\t\t\tgetModel().remove(key);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#setBinding(attributeName,enabled)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register whether data binding should occur for a corresponding model attribute,\n\t * corresponding to an {@code @ModelAttribute(binding=true/false)} declaration.\n\t * <p>Note: While this flag will be taken into account by {@link #isBindingDisabled},\n\t * a hard {@link #setBindingDisabled} declaration will always override it.\n\t * @param attributeName the name of the attribute\n\t * @since 4.3.13\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "enabled"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "void",
    "signature": "public void setBinding(String attributeName, boolean enabled)",
    "source_code": "\tpublic void setBinding(String attributeName, boolean enabled) {\n\t\tif (!enabled) {\n\t\t\tthis.noBinding.add(attributeName);\n\t\t}\n\t\telse {\n\t\t\tthis.noBinding.remove(attributeName);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromFormData(MultiValueMap<String,formData)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link FormInserter} to write the given {@code MultiValueMap}\n\t * as URL-encoded form data. The returned inserter allows for additional\n\t * entries to be added via {@link FormInserter#with(String, Object)}.\n\t * <p>Note that you can also use the {@code bodyValue(Object)} method in the\n\t * request builders of both the {@code WebClient} and {@code WebTestClient}.\n\t * In that case the setting of the request content type is also not required,\n\t * just be sure the map contains String values only or otherwise it would be\n\t * interpreted as a multipart request.\n\t * @param formData the form data to write to the output message\n\t * @return the inserter that allows adding more form data\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "formData"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "FormInserter<String>",
    "signature": "public FormInserter<String> fromFormData(MultiValueMap<String, String> formData)",
    "source_code": "\tpublic static FormInserter<String> fromFormData(MultiValueMap<String, String> formData) {\n\t\treturn new DefaultFormInserter().with(formData);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromFormData(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link FormInserter} to write the given key-value pair as\n\t * URL-encoded form data. The returned inserter allows for additional\n\t * entries to be added via {@link FormInserter#with(String, Object)}.\n\t * @param name the key to add to the form\n\t * @param value the value to add to the form\n\t * @return the inserter that allows adding more form data\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "FormInserter<String>",
    "signature": "public FormInserter<String> fromFormData(String name, String value)",
    "source_code": "\tpublic static FormInserter<String> fromFormData(String name, String value) {\n\t\tAssert.notNull(name, \"'name' must not be null\");\n\t\tAssert.notNull(value, \"'value' must not be null\");\n\t\treturn new DefaultFormInserter().with(name, value);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromMultipartAsyncData(name,publisher,elementClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link MultipartInserter} to write the given asynchronous parts,\n\t * as multipart data.\n\t * <p>Note that you can also build the multipart data externally with\n\t * {@link MultipartBodyBuilder}, and pass the resulting map directly to the\n\t * {@code bodyValue(Object)} shortcut method in {@code WebClient}.\n\t * @param name the part name\n\t * @param publisher the publisher that forms the part value\n\t * @param elementClass the class contained in the {@code publisher}\n\t * @return the inserter that allows adding more parts\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter fromMultipartAsyncData(String name, P publisher, Class<T> elementClass)",
    "source_code": "\tpublic static <T, P extends Publisher<T>> MultipartInserter fromMultipartAsyncData(\n\t\t\tString name, P publisher, Class<T> elementClass) {\n\n\t\treturn new DefaultMultipartInserter().withPublisher(name, publisher, elementClass);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromMultipartAsyncData(name,publisher,typeReference)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #fromMultipartAsyncData(String, Publisher, Class)} that\n\t * accepts a {@link ParameterizedTypeReference} for the element type, which\n\t * allows specifying generic type information.\n\t * <p>Note that you can also build the multipart data externally with\n\t * {@link MultipartBodyBuilder}, and pass the resulting map directly to the\n\t * {@code bodyValue(Object)} shortcut method in {@code WebClient}.\n\t * @param name the part name\n\t * @param publisher the publisher that forms the part value\n\t * @param typeReference the type contained in the {@code publisher}\n\t * @return the inserter that allows adding more parts\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "typeReference"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter fromMultipartAsyncData(String name, P publisher, ParameterizedTypeReference<T> typeReference)",
    "source_code": "\tpublic static <T, P extends Publisher<T>> MultipartInserter fromMultipartAsyncData(\n\t\t\tString name, P publisher, ParameterizedTypeReference<T> typeReference) {\n\n\t\treturn new DefaultMultipartInserter().withPublisher(name, publisher, typeReference);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromMultipartData(MultiValueMap<String,multipartData)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link MultipartInserter} to write the given\n\t * {@code MultiValueMap} as multipart data. Values in the map can be an\n\t * Object or an {@link HttpEntity}.\n\t * <p>Note that you can also build the multipart data externally with\n\t * {@link MultipartBodyBuilder}, and pass the resulting map directly to the\n\t * {@code bodyValue(Object)} shortcut method in {@code WebClient}.\n\t * @param multipartData the form data to write to the output message\n\t * @return the inserter that allows adding more parts\n\t * @see MultipartBodyBuilder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "multipartData"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter fromMultipartData(MultiValueMap<String, ?> multipartData)",
    "source_code": "\tpublic static MultipartInserter fromMultipartData(MultiValueMap<String, ?> multipartData) {\n\t\tAssert.notNull(multipartData, \"'multipartData' must not be null\");\n\t\treturn new DefaultMultipartInserter().withInternal(multipartData);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromMultipartData(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link MultipartInserter} to write the given parts,\n\t * as multipart data. Values in the map can be an Object or an\n\t * {@link HttpEntity}.\n\t * <p>Note that you can also build the multipart data externally with\n\t * {@link MultipartBodyBuilder}, and pass the resulting map directly to the\n\t * {@code bodyValue(Object)} shortcut method in {@code WebClient}.\n\t * @param name the part name\n\t * @param value the part value, an Object or {@code HttpEntity}\n\t * @return the inserter that allows adding more parts\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter fromMultipartData(String name, Object value)",
    "source_code": "\tpublic static MultipartInserter fromMultipartData(String name, Object value) {\n\t\tAssert.notNull(name, \"'name' must not be null\");\n\t\tAssert.notNull(value, \"'value' must not be null\");\n\t\treturn new DefaultMultipartInserter().with(name, value);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromProducer(producer,elementClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given producer of value(s) which must be a {@link Publisher}\n\t * or another producer adaptable to a {@code Publisher} via\n\t * {@link ReactiveAdapterRegistry}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param <T> the type of the body\n\t * @param producer the source of body value(s).\n\t * @param elementClass the class of values to be produced\n\t * @return the inserter to write a producer\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromProducer(T producer, Class<?> elementClass)",
    "source_code": "\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromProducer(T producer, Class<?> elementClass) {\n\t\tAssert.notNull(producer, \"'producer' must not be null\");\n\t\tAssert.notNull(elementClass, \"'elementClass' must not be null\");\n\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(producer.getClass());\n\t\tAssert.notNull(adapter, \"'producer' type is unknown to ReactiveAdapterRegistry\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, producer, ResolvableType.forClass(elementClass), adapter);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromProducer(producer,elementTypeRef)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given producer of value(s) which must be a {@link Publisher}\n\t * or another producer adaptable to a {@code Publisher} via\n\t * {@link ReactiveAdapterRegistry}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param <T> the type of the body\n\t * @param producer the source of body value(s).\n\t * @param elementTypeRef the type of values to be produced\n\t * @return the inserter to write a producer\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromProducer(T producer, ParameterizedTypeReference<?> elementTypeRef)",
    "source_code": "\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromProducer(\n\t\t\tT producer, ParameterizedTypeReference<?> elementTypeRef) {\n\n\t\tAssert.notNull(producer, \"'producer' must not be null\");\n\t\tAssert.notNull(elementTypeRef, \"'elementTypeRef' must not be null\");\n\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(producer.getClass());\n\t\tAssert.notNull(adapter, \"'producer' type is unknown to ReactiveAdapterRegistry\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, producer, ResolvableType.forType(elementTypeRef), adapter);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromPublisher(publisher,elementClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given {@link Publisher}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param publisher the publisher to write with\n\t * @param elementClass the class of elements in the publisher\n\t * @param <T> the type of the elements contained in the publisher\n\t * @param <P> the {@code Publisher} type\n\t * @return the inserter to write a {@code Publisher}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromPublisher(P publisher, Class<T> elementClass)",
    "source_code": "\tpublic static <T, P extends Publisher<T>> BodyInserter<P, ReactiveHttpOutputMessage> fromPublisher(\n\t\t\tP publisher, Class<T> elementClass) {\n\n\t\tAssert.notNull(publisher, \"'publisher' must not be null\");\n\t\tAssert.notNull(elementClass, \"'elementClass' must not be null\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, publisher, ResolvableType.forClass(elementClass), null);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromPublisher(publisher,elementTypeRef)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given {@link Publisher}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param publisher the publisher to write with\n\t * @param elementTypeRef the type of elements contained in the publisher\n\t * @param <T> the type of the elements contained in the publisher\n\t * @param <P> the {@code Publisher} type\n\t * @return the inserter to write a {@code Publisher}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "elementTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromPublisher(P publisher, ParameterizedTypeReference<T> elementTypeRef)",
    "source_code": "\tpublic static <T, P extends Publisher<T>> BodyInserter<P, ReactiveHttpOutputMessage> fromPublisher(\n\t\t\tP publisher, ParameterizedTypeReference<T> elementTypeRef) {\n\n\t\tAssert.notNull(publisher, \"'publisher' must not be null\");\n\t\tAssert.notNull(elementTypeRef, \"'elementTypeRef' must not be null\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, publisher, ResolvableType.forType(elementTypeRef.getType()), null);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#insert(outputMessage,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputMessage",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 550
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> insert(ClientHttpRequest outputMessage, Context context)",
    "source_code": "\t\tpublic Mono<Void> insert(ClientHttpRequest outputMessage, Context context) {\n\t\t\tHttpMessageWriter<MultiValueMap<String, HttpEntity<?>>> messageWriter =\n\t\t\t\t\tfindWriter(context, MULTIPART_DATA_TYPE, MediaType.MULTIPART_FORM_DATA);\n\t\t\tMultiValueMap<String, HttpEntity<?>> body = this.builder.build();\n\t\t\treturn messageWriter.write(Mono.just(body), MULTIPART_DATA_TYPE,\n\t\t\t\t\tMediaType.MULTIPART_FORM_DATA, outputMessage, context.hints());\n\t\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#with(MultiValueMap<String,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 519
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter with(MultiValueMap<String, Object> values)",
    "source_code": "\t\tpublic MultipartInserter with(MultiValueMap<String, Object> values) {\n\t\t\treturn withInternal(values);\n\t\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#with(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 513
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter with(String key, Object value)",
    "source_code": "\t\tpublic MultipartInserter with(String key, Object value) {\n\t\t\tthis.builder.part(key, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#withPublisher(name,publisher,elementClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter withPublisher(String name, P publisher, Class<T> elementClass)",
    "source_code": "\t\tpublic <T, P extends Publisher<T>> MultipartInserter withPublisher(\n\t\t\t\tString name, P publisher, Class<T> elementClass) {\n\n\t\t\tthis.builder.asyncPart(name, publisher, elementClass);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#withPublisher(name,publisher,typeReference)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "typeReference"
    ],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter withPublisher(String name, P publisher, ParameterizedTypeReference<T> typeReference)",
    "source_code": "\t\tpublic <T, P extends Publisher<T>> MultipartInserter withPublisher(\n\t\t\t\tString name, P publisher, ParameterizedTypeReference<T> typeReference) {\n\n\t\t\tthis.builder.asyncPart(name, publisher, typeReference);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#basicAuthentication(username,password)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a filter that applies HTTP Basic Authentication to the request\n\t * headers via {@link HttpHeaders#setBasicAuth(String)} and\n\t * {@link HttpHeaders#encodeBasicAuth(String, String, Charset)}.\n\t * @param username the username\n\t * @param password the password\n\t * @return the filter to add authentication headers with\n\t * @see HttpHeaders#encodeBasicAuth(String, String, Charset)\n\t * @see HttpHeaders#setBasicAuth(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "ExchangeFilterFunction",
    "signature": "public ExchangeFilterFunction basicAuthentication(String username, String password)",
    "source_code": "\tpublic static ExchangeFilterFunction basicAuthentication(String username, String password) {\n\t\tString encodedCredentials = HttpHeaders.encodeBasicAuth(username, password, null);\n\t\treturn (request, next) ->\n\t\t\t\tnext.exchange(ClientRequest.from(request)\n\t\t\t\t\t\t.headers(headers -> headers.setBasicAuth(encodedCredentials))\n\t\t\t\t\t\t.build());\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#basicAuthenticationCredentials(username,password)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return a {@literal Consumer} that stores the given username and password\n\t\t * as a request attribute of type {@code Credentials} that is in turn\n\t\t * used by {@link ExchangeFilterFunctions#basicAuthentication()}.\n\t\t * @param username the username\n\t\t * @param password the password\n\t\t * @return a consumer that can be passed into\n\t\t * {@linkplain ClientRequest.Builder#attributes(java.util.function.Consumer)}\n\t\t * @see ClientRequest.Builder#attributes(java.util.function.Consumer)\n\t\t * @see #BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "Object>>",
    "signature": "public Object>> basicAuthenticationCredentials(String username, String password)",
    "source_code": "\t\tpublic static Consumer<Map<String, Object>> basicAuthenticationCredentials(String username, String password) {\n\t\t\tCredentials credentials = new Credentials(username, password);\n\t\t\treturn (map -> map.put(BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE, credentials));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#body(BodyExtractor<T,extractor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BodyExtractor<T",
      "extractor"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "T",
    "signature": "public T body(BodyExtractor<T, ? super ClientHttpResponse> extractor)",
    "source_code": "\tpublic <T> T body(BodyExtractor<T, ? super ClientHttpResponse> extractor) {\n\t\tT result = extractor.extract(this.response, this.bodyExtractorContext);\n\t\tString description = \"Body from \" + this.requestDescription + \" [DefaultClientResponse]\";\n\t\tif (result instanceof Mono<?> mono) {\n\t\t\treturn (T) mono.checkpoint(description);\n\t\t}\n\t\telse if (result instanceof Flux<?> flux) {\n\t\t\treturn (T) flux.checkpoint(description);\n\t\t}\n\t\telse {\n\t\t\treturn result;\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#cookie(name,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "DefaultClientResponseBuilder",
    "signature": "public DefaultClientResponseBuilder cookie(String name, String... values)",
    "source_code": "\tpublic DefaultClientResponseBuilder cookie(String name, String... values) {\n\t\tfor (String value : values) {\n\t\t\tgetCookies().add(name, ResponseCookie.from(name, value).build());\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#create(statusCode,statusText,headers,body,charset)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@code WebClientResponseException} or an HTTP status specific subclass.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCode",
      "statusText",
      "headers",
      "body",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "WebClientResponseException",
    "signature": "public WebClientResponseException create(int statusCode, String statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset)",
    "source_code": "\tpublic static WebClientResponseException create(\n\t\t\tint statusCode, String statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset) {\n\n\t\treturn create(statusCode, statusText, headers, body, charset, null);\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#create(statusCode,statusText,headers,body,charset,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@code WebClientResponseException} or an HTTP status specific subclass.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCode",
      "statusText",
      "headers",
      "body",
      "charset",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "WebClientResponseException",
    "signature": "public WebClientResponseException create(HttpStatusCode statusCode, String statusText, HttpHeaders headers,\n\t\t\tbyte[] body, @Nullable Charset charset, @Nullable HttpRequest request)",
    "source_code": "\tpublic static WebClientResponseException create(\n\t\t\tHttpStatusCode statusCode, String statusText, HttpHeaders headers,\n\t\t\tbyte[] body, @Nullable Charset charset, @Nullable HttpRequest request) {\n\n\t\tif (statusCode instanceof HttpStatus httpStatus) {\n\t\t\tswitch (httpStatus) {\n\t\t\t\tcase BAD_REQUEST:\n\t\t\t\t\treturn new WebClientResponseException.BadRequest(statusText, headers, body, charset, request);\n\t\t\t\tcase UNAUTHORIZED:\n\t\t\t\t\treturn new WebClientResponseException.Unauthorized(statusText, headers, body, charset, request);\n\t\t\t\tcase FORBIDDEN:\n\t\t\t\t\treturn new WebClientResponseException.Forbidden(statusText, headers, body, charset, request);\n\t\t\t\tcase NOT_FOUND:\n\t\t\t\t\treturn new WebClientResponseException.NotFound(statusText, headers, body, charset, request);\n\t\t\t\tcase METHOD_NOT_ALLOWED:\n\t\t\t\t\treturn new WebClientResponseException.MethodNotAllowed(statusText, headers, body, charset, request);\n\t\t\t\tcase NOT_ACCEPTABLE:\n\t\t\t\t\treturn new WebClientResponseException.NotAcceptable(statusText, headers, body, charset, request);\n\t\t\t\tcase CONFLICT:\n\t\t\t\t\treturn new WebClientResponseException.Conflict(statusText, headers, body, charset, request);\n\t\t\t\tcase GONE:\n\t\t\t\t\treturn new WebClientResponseException.Gone(statusText, headers, body, charset, request);\n\t\t\t\tcase UNSUPPORTED_MEDIA_TYPE:\n\t\t\t\t\treturn new WebClientResponseException.UnsupportedMediaType(statusText, headers, body, charset, request);\n\t\t\t\tcase TOO_MANY_REQUESTS:\n\t\t\t\t\treturn new WebClientResponseException.TooManyRequests(statusText, headers, body, charset, request);\n\t\t\t\tcase UNPROCESSABLE_ENTITY:\n\t\t\t\t\treturn new WebClientResponseException.UnprocessableEntity(statusText, headers, body, charset, request);\n\t\t\t\tcase INTERNAL_SERVER_ERROR:\n\t\t\t\t\treturn new WebClientResponseException.InternalServerError(statusText, headers, body, charset, request);\n\t\t\t\tcase NOT_IMPLEMENTED:\n\t\t\t\t\treturn new WebClientResponseException.NotImplemented(statusText, headers, body, charset, request);\n\t\t\t\tcase BAD_GATEWAY:\n\t\t\t\t\treturn new WebClientResponseException.BadGateway(statusText, headers, body, charset, request);\n\t\t\t\tcase SERVICE_UNAVAILABLE:\n\t\t\t\t\treturn new WebClientResponseException.ServiceUnavailable(statusText, headers, body, charset, request);\n\t\t\t\tcase GATEWAY_TIMEOUT:\n\t\t\t\t\treturn new WebClientResponseException.GatewayTimeout(statusText, headers, body, charset, request);\n\t\t\t}\n\t\t}\n\t\treturn new WebClientResponseException(statusCode, statusText, headers, body, charset, request);\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#setBodyDecodeFunction(Function<ResolvableType,decoderFunction)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a function to find a decoder the given target type.\n\t * For use with {@link #getResponseBodyAs(Class)}.\n\t * @param decoderFunction the function to find a decoder with\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ResolvableType",
      "decoderFunction"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "public void setBodyDecodeFunction(Function<ResolvableType, ?> decoderFunction)",
    "source_code": "\tpublic void setBodyDecodeFunction(Function<ResolvableType, ?> decoderFunction) {\n\t\tthis.bodyDecodeFunction = decoderFunction;\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#statusError(statusPredicate,Function<ClientResponse,exceptionFunction)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a filter that generates an error signal when the given\n\t * {@link HttpStatusCode} predicate matches.\n\t * @param statusPredicate the predicate to check the HTTP status with\n\t * @param exceptionFunction the function to create the exception\n\t * @return the filter to generate an error signal\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusPredicate",
      "Function<ClientResponse",
      "exceptionFunction"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "ExchangeFilterFunction",
    "signature": "public ExchangeFilterFunction statusError(Predicate<HttpStatusCode> statusPredicate,\n\t\t\tFunction<ClientResponse, ? extends Throwable> exceptionFunction)",
    "source_code": "\tpublic static ExchangeFilterFunction statusError(Predicate<HttpStatusCode> statusPredicate,\n\t\t\tFunction<ClientResponse, ? extends Throwable> exceptionFunction) {\n\n\t\tAssert.notNull(statusPredicate, \"Predicate must not be null\");\n\t\tAssert.notNull(exceptionFunction, \"Function must not be null\");\n\n\t\treturn ExchangeFilterFunction.ofResponseProcessor(\n\t\t\t\tresponse -> (statusPredicate.test(response.statusCode()) ?\n\t\t\t\t\t\tMono.error(exceptionFunction.apply(response)) : Mono.just(response)));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#attributes(Map<String,attributes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void attributes(Map<String, Object> attributes)",
    "source_code": "\tpublic void attributes(Map<String, Object> attributes) {\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(BodyExtractor<T,extractor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BodyExtractor<T",
      "extractor"
    ],
    "position": {
      "column": 1,
      "line": 1018
    },
    "return": "T",
    "signature": "public T body(BodyExtractor<T, ? super ServerHttpRequest> extractor)",
    "source_code": "\t\tpublic <T> T body(BodyExtractor<T, ? super ServerHttpRequest> extractor) {\n\t\t\treturn this.request.body(extractor);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(BodyExtractor<T,extractor,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BodyExtractor<T",
      "extractor",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 1023
    },
    "return": "T",
    "signature": "public T body(BodyExtractor<T, ? super ServerHttpRequest> extractor, Map<String, Object> hints)",
    "source_code": "\t\tpublic <T> T body(BodyExtractor<T, ? super ServerHttpRequest> extractor, Map<String, Object> hints) {\n\t\t\treturn this.request.body(extractor, hints);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(BodyInserter<?,inserter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BodyInserter<?",
      "inserter"
    ],
    "position": {
      "column": 1,
      "line": 253
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> body(BodyInserter<?, ? super ServerHttpResponse> inserter)",
    "source_code": "\tpublic Mono<ServerResponse> body(BodyInserter<?, ? super ServerHttpResponse> inserter) {\n\t\treturn Mono.just(new BodyInserterResponse<>(\n\t\t\t\tthis.statusCode, this.headers, this.cookies, inserter, this.hints));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(producer,elementClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> body(Object producer, Class<?> elementClass)",
    "source_code": "\tpublic Mono<ServerResponse> body(Object producer, Class<?> elementClass) {\n\t\treturn initBuilder(producer, BodyInserters.fromProducer(producer, elementClass));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(producer,elementTypeRef)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> body(Object producer, ParameterizedTypeReference<?> elementTypeRef)",
    "source_code": "\tpublic Mono<ServerResponse> body(Object producer, ParameterizedTypeReference<?> elementTypeRef) {\n\t\treturn initBuilder(producer, BodyInserters.fromProducer(producer, elementTypeRef));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(publisher,elementClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> body(P publisher, Class<T> elementClass)",
    "source_code": "\tpublic <T, P extends Publisher<T>> Mono<ServerResponse> body(P publisher, Class<T> elementClass) {\n\t\treturn initBuilder(publisher, BodyInserters.fromPublisher(publisher, elementClass));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(publisher,typeRef)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "typeRef"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> body(P publisher, ParameterizedTypeReference<T> typeRef)",
    "source_code": "\tpublic <T, P extends Publisher<T>> Mono<ServerResponse> body(P publisher, ParameterizedTypeReference<T> typeRef) {\n\t\treturn initBuilder(publisher, BodyInserters.fromPublisher(publisher, typeRef));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#build(BiFunction<ServerWebExchange,ServerResponse.Context,writeFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiFunction<ServerWebExchange",
      "ServerResponse.Context",
      "writeFunction"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> build(BiFunction<ServerWebExchange, ServerResponse.Context, Mono<Void>> writeFunction)",
    "source_code": "\tpublic Mono<ServerResponse> build(\n\t\t\tBiFunction<ServerWebExchange, ServerResponse.Context, Mono<Void>> writeFunction) {\n\n\t\treturn Mono.just(new WriterFunctionResponse(\n\t\t\t\tthis.statusCode, this.headers, this.cookies, writeFunction));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#queryParam(name,predicate)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that tests the request's query parameter of the given name\n\t * against the given predicate.\n\t * @param name the name of the query parameter to test against\n\t * @param predicate the predicate to test against the query parameter value\n\t * @return a predicate that matches the given predicate against the query parameter of the given name\n\t * @see ServerRequest#queryParam(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "predicate"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate queryParam(String name, Predicate<String> predicate)",
    "source_code": "\tpublic static RequestPredicate queryParam(String name, Predicate<String> predicate) {\n\t\treturn new QueryParamPredicate(name, predicate);\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#queryParam(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's query parameter of the given name\n\t * has the given value.\n\t * @param name the name of the query parameter to test against\n\t * @param value the value of the query parameter to test against\n\t * @return a predicate that matches if the query parameter has the given value\n\t * @since 5.0.7\n\t * @see ServerRequest#queryParam(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate queryParam(String name, String value)",
    "source_code": "\tpublic static RequestPredicate queryParam(String name, String value) {\n\t\treturn new QueryParamPredicate(name, value);\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#render(name,Map<String,model)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "Map<String",
      "model"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> render(String name, Map<String, ?> model)",
    "source_code": "\tpublic Mono<ServerResponse> render(String name, Map<String, ?> model) {\n\t\treturn new DefaultRenderingResponseBuilder(name)\n\t\t\t\t.status(this.statusCode)\n\t\t\t\t.headers(this.headers)\n\t\t\t\t.cookies(cookies -> cookies.addAll(this.cookies))\n\t\t\t\t.modelAttributes(model)\n\t\t\t\t.build()\n\t\t\t\t.map(Function.identity());\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#render(name,modelAttributes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "modelAttributes"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> render(String name, Object... modelAttributes)",
    "source_code": "\tpublic Mono<ServerResponse> render(String name, Object... modelAttributes) {\n\t\treturn new DefaultRenderingResponseBuilder(name)\n\t\t\t\t.status(this.statusCode)\n\t\t\t\t.headers(this.headers)\n\t\t\t\t.cookies(cookies -> cookies.addAll(this.cookies))\n\t\t\t\t.modelAttributes(modelAttributes)\n\t\t\t\t.build()\n\t\t\t\t.map(Function.identity());\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#resources(Function<ServerRequest,lookupFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ServerRequest",
      "lookupFunction"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "void",
    "signature": "public void resources(Function<ServerRequest, Mono<Resource>> lookupFunction)",
    "source_code": "\tpublic void resources(Function<ServerRequest, Mono<Resource>> lookupFunction) {\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#route(predicate,handlerFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "handlerFunction"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "void",
    "signature": "public void route(RequestPredicate predicate, HandlerFunction<?> handlerFunction)",
    "source_code": "\tpublic void route(RequestPredicate predicate, HandlerFunction<?> handlerFunction) {\n\t\tchangeParser(predicate);\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#writeTo(exchange,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> writeTo(ServerWebExchange exchange, Context context)",
    "source_code": "\t\tpublic final Mono<Void> writeTo(ServerWebExchange exchange, Context context) {\n\t\t\twriteStatusAndHeaders(exchange.getResponse());\n\t\t\tInstant lastModified = Instant.ofEpochMilli(headers().getLastModified());\n\t\t\tHttpMethod httpMethod = exchange.getRequest().getMethod();\n\t\t\tif (SAFE_METHODS.contains(httpMethod) && exchange.checkNotModified(headers().getETag(), lastModified)) {\n\t\t\t\treturn exchange.getResponse().setComplete();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn writeToInternal(exchange, context);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#writeToInternal(exchange,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exchange",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> writeToInternal(ServerWebExchange exchange, Context context)",
    "source_code": "\t\tprotected Mono<Void> writeToInternal(ServerWebExchange exchange, Context context) {\n\t\t\tMediaType contentType = exchange.getResponse().getHeaders().getContentType();\n\t\t\tLocale locale = LocaleContextHolder.getLocale(exchange.getLocaleContext());\n\t\t\tStream<ViewResolver> viewResolverStream = context.viewResolvers().stream();\n\n\t\t\treturn Flux.fromStream(viewResolverStream)\n\t\t\t\t\t.concatMap(viewResolver -> viewResolver.resolveViewName(name(), locale))\n\t\t\t\t\t.next()\n\t\t\t\t\t.switchIfEmpty(Mono.error(() ->\n\t\t\t\t\t\t\tnew IllegalArgumentException(\"Could not resolve view with name '\" + name() + \"'\")))\n\t\t\t\t\t.flatMap(view -> {\n\t\t\t\t\t\tsetStatus(view);\n\t\t\t\t\t\tList<MediaType> mediaTypes = view.getSupportedMediaTypes();\n\t\t\t\t\t\treturn view.render(model(),\n\t\t\t\t\t\t\t\tcontentType == null && !mediaTypes.isEmpty() ? mediaTypes.get(0) : contentType,\n\t\t\t\t\t\t\t\texchange);\n\t\t\t\t\t});\n\t\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#getCorsConfiguration(handler,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the CORS configuration for the given handler.\n\t * @param handler the handler to check (never {@code null})\n\t * @param exchange the current exchange\n\t * @return the CORS configuration for the handler, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration getCorsConfiguration(Object handler, ServerWebExchange exchange)",
    "source_code": "\tprotected CorsConfiguration getCorsConfiguration(Object handler, ServerWebExchange exchange) {\n\t\tif (handler instanceof CorsConfigurationSource ccs) {\n\t\t\treturn ccs.getCorsConfiguration(exchange);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#lookupHandler(lookupPath,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look up a handler instance for the given URL lookup path.\n\t * <p>Supports direct matches, e.g. a registered \"/test\" matches \"/test\",\n\t * and various path pattern matches, e.g. a registered \"/t*\" matches\n\t * both \"/test\" and \"/team\". For details, see the PathPattern class.\n\t * @param lookupPath the URL the handler is mapped to\n\t * @param exchange the current exchange\n\t * @return the associated handler instance, or {@code null} if not found\n\t * @see org.springframework.web.util.pattern.PathPattern\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "lookupPath",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "Object",
    "signature": "protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange)",
    "source_code": "\tprotected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange) throws Exception {\n\t\tList<PathPattern> matches = null;\n\t\tfor (PathPattern pattern : this.handlerMap.keySet()) {\n\t\t\tif (pattern.matches(lookupPath)) {\n\t\t\t\tmatches = (matches != null ? matches : new ArrayList<>());\n\t\t\t\tmatches.add(pattern);\n\t\t\t}\n\t\t}\n\t\tif (matches == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (matches.size() > 1) {\n\t\t\tmatches.sort(PathPattern.SPECIFICITY_COMPARATOR);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.debug(exchange.getLogPrefix() + \"Matching patterns \" + matches);\n\t\t\t}\n\t\t}\n\n\t\tPathPattern pattern = matches.get(0);\n\t\tPathContainer pathWithinMapping = pattern.extractPathWithinPattern(lookupPath);\n\t\tPathPattern.PathMatchInfo matchInfo = pattern.matchAndExtract(lookupPath);\n\t\tAssert.notNull(matchInfo, \"Expected a match\");\n\n\t\tObject handler = this.handlerMap.get(pattern);\n\n\t\t// Bean name or resolved handler?\n\t\tif (handler instanceof String handlerName) {\n\t\t\thandler = obtainApplicationContext().getBean(handlerName);\n\t\t}\n\n\t\tif (this.handlerPredicate != null && !this.handlerPredicate.test(handler, exchange)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvalidateHandler(handler, exchange);\n\n\t\texchange.getAttributes().put(BEST_MATCHING_HANDLER_ATTRIBUTE, handler);\n\t\texchange.getAttributes().put(BEST_MATCHING_PATTERN_ATTRIBUTE, pattern);\n\t\tServerHttpObservationFilter.findObservationContext(exchange)\n\t\t\t\t.ifPresent(context -> context.setPathPattern(pattern.toString()));\n\t\texchange.getAttributes().put(PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, pathWithinMapping);\n\t\texchange.getAttributes().put(URI_TEMPLATE_VARIABLES_ATTRIBUTE, matchInfo.getUriVariables());\n\n\t\treturn handler;\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#registerHandler(urlPath,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified handler for the given URL path.\n\t * @param urlPath the URL the bean should be mapped to\n\t * @param handler the handler instance or handler bean name String\n\t * (a bean name will automatically be resolved into the corresponding handler bean)\n\t * @throws BeansException if the handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "urlPath",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "protected void registerHandler(String urlPath, Object handler)",
    "source_code": "\tprotected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {\n\t\tAssert.notNull(urlPath, \"URL path must not be null\");\n\t\tAssert.notNull(handler, \"Handler object must not be null\");\n\t\tObject resolvedHandler = handler;\n\n\t\t// Parse path pattern\n\t\turlPath = prependLeadingSlash(urlPath);\n\t\tPathPattern pattern = getPathPatternParser().parse(urlPath);\n\t\tif (this.handlerMap.containsKey(pattern)) {\n\t\t\tObject existingHandler = this.handlerMap.get(pattern);\n\t\t\tif (existingHandler != null && existingHandler != resolvedHandler) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Cannot map \" + getHandlerDescription(handler) + \" to [\" + urlPath + \"]: \" +\n\t\t\t\t\t\t\"there is already \" + getHandlerDescription(existingHandler) + \" mapped.\");\n\t\t\t}\n\t\t}\n\n\t\t// Eagerly resolve handler if referencing singleton via name.\n\t\tif (!this.lazyInitHandlers && handler instanceof String handlerName) {\n\t\t\tif (obtainApplicationContext().isSingleton(handlerName)) {\n\t\t\t\tresolvedHandler = obtainApplicationContext().getBean(handlerName);\n\t\t\t}\n\t\t}\n\n\t\t// Register resolved handler\n\t\tthis.handlerMap.put(pattern, resolvedHandler);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Mapped [\" + urlPath + \"] onto \" + getHandlerDescription(handler));\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#registerHandler(urlPaths,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified handler for the given URL paths.\n\t * @param urlPaths the URLs that the bean should be mapped to\n\t * @param beanName the name of the handler bean\n\t * @throws BeansException if the handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "urlPaths",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "void",
    "signature": "protected void registerHandler(String[] urlPaths, String beanName)",
    "source_code": "\tprotected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {\n\t\tAssert.notNull(urlPaths, \"URL path array must not be null\");\n\t\tfor (String urlPath : urlPaths) {\n\t\t\tregisterHandler(urlPath, beanName);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#registerHandlers(Map<String,urlMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register all handlers specified in the URL map for the corresponding paths.\n\t * @param urlMap a Map with URL paths as keys and handler beans or bean names as values\n\t * @throws BeansException if a handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "urlMap"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "protected void registerHandlers(Map<String, Object> urlMap)",
    "source_code": "\tprotected void registerHandlers(Map<String, Object> urlMap) throws BeansException {\n\t\tif (urlMap.isEmpty()) {\n\t\t\tlogger.trace(\"No patterns in \" + formatMappingName());\n\t\t}\n\t\telse {\n\t\t\tfor (Map.Entry<String, Object> entry : urlMap.entrySet()) {\n\t\t\t\tString url = entry.getKey();\n\t\t\t\tObject handler = entry.getValue();\n\t\t\t\t// Prepend with slash if not already present.\n\t\t\t\tif (!url.startsWith(\"/\")) {\n\t\t\t\t\turl = \"/\" + url;\n\t\t\t\t}\n\t\t\t\t// Remove whitespace from handler bean name.\n\t\t\t\tif (handler instanceof String handlerName) {\n\t\t\t\t\thandler = handlerName.trim();\n\t\t\t\t}\n\t\t\t\tregisterHandler(url, handler);\n\t\t\t}\n\t\t\tlogMappings();\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#setCorsConfigurations(Map<String,corsConfigurations)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the \"global\" CORS configurations based on URL patterns. By default, the\n\t * first matching URL pattern is combined with handler-level CORS configuration if any.\n\t * @see #setCorsConfigurationSource(CorsConfigurationSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "corsConfigurations"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void setCorsConfigurations(Map<String, CorsConfiguration> corsConfigurations)",
    "source_code": "\tpublic void setCorsConfigurations(Map<String, CorsConfiguration> corsConfigurations) {\n\t\tAssert.notNull(corsConfigurations, \"corsConfigurations must not be null\");\n\t\tif (!corsConfigurations.isEmpty()) {\n\t\t\tUrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(this.patternParser);\n\t\t\tsource.setCorsConfigurations(corsConfigurations);\n\t\t\tthis.corsConfigurationSource = source;\n\t\t}\n\t\telse {\n\t\t\tthis.corsConfigurationSource = null;\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#setHandlerPredicate(BiPredicate<Object,handlerPredicate)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a predicate for extended matching of the handler that was\n\t * matched by URL path. This allows for further narrowing of the mapping by\n\t * checking additional properties of the request. If the predicate returns\n\t * \"false\", it result in a no-match, which allows another\n\t * {@link org.springframework.web.reactive.HandlerMapping} to match or\n\t * result in a 404 (NOT_FOUND) response.\n\t * @param handlerPredicate a bi-predicate to match the candidate handler\n\t * against the current exchange.\n\t * @since 5.3.5\n\t * @see org.springframework.web.reactive.socket.server.support.WebSocketUpgradeHandlerPredicate\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiPredicate<Object",
      "handlerPredicate"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "void",
    "signature": "public void setHandlerPredicate(BiPredicate<Object, ServerWebExchange> handlerPredicate)",
    "source_code": "\tpublic void setHandlerPredicate(BiPredicate<Object, ServerWebExchange> handlerPredicate) {\n\t\tthis.handlerPredicate = (this.handlerPredicate != null ?\n\t\t\t\tthis.handlerPredicate.and(handlerPredicate) : handlerPredicate);\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#setUrlMap(Map<String,urlMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Map with URL paths as keys and handler beans (or handler bean names)\n\t * as values. Convenient for population with bean references.\n\t * <p>Supports direct URL matches and Ant-style pattern matches. For syntax details,\n\t * see the {@link org.springframework.web.util.pattern.PathPattern} javadoc.\n\t * @param urlMap map with URLs as keys and beans as values\n\t * @see #setMappings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "urlMap"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void setUrlMap(Map<String, ?> urlMap)",
    "source_code": "\tpublic void setUrlMap(Map<String, ?> urlMap) {\n\t\tthis.urlMap.putAll(urlMap);\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#validateHandler(handler,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the given handler against the current request.\n\t * <p>The default implementation is empty. Can be overridden in subclasses,\n\t * for example to enforce specific preconditions expressed in URL mappings.\n\t * @param handler the handler object to validate\n\t * @param exchange current exchange\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "protected void validateHandler(Object handler, ServerWebExchange exchange)",
    "source_code": "\tprotected void validateHandler(Object handler, ServerWebExchange exchange) {\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#addFixedVersionStrategy(version,pathPatterns)": {
    "deprecated": false,
    "doc": "\t * will also configure automatically a {@code \"/v1.0.0/js/**\"} with {@code \"v1.0.0\"} the\n\t * {@code version} String given as an argument.\n\t * @param version a version string\n\t * @param pathPatterns one or more resource URL path patterns,\n\t * relative to the pattern configured with the resource handler\n\t * @return the current instance for chained method invocation\n\t * @see FixedVersionStrategy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "version",
      "pathPatterns"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "VersionResourceResolver",
    "signature": "public VersionResourceResolver addFixedVersionStrategy(String version, String... pathPatterns)",
    "source_code": "\tpublic VersionResourceResolver addFixedVersionStrategy(String version, String... pathPatterns) {\n\t\tList<String> patternsList = Arrays.asList(pathPatterns);\n\t\tList<String> prefixedPatterns = new ArrayList<>(pathPatterns.length);\n\t\tString versionPrefix = \"/\" + version;\n\t\tfor (String pattern : patternsList) {\n\t\t\tprefixedPatterns.add(pattern);\n\t\t\tif (!pattern.startsWith(versionPrefix) && !patternsList.contains(versionPrefix + pattern)) {\n\t\t\t\tprefixedPatterns.add(versionPrefix + pattern);\n\t\t\t}\n\t\t}\n\t\treturn addVersionStrategy(new FixedVersionStrategy(version), StringUtils.toStringArray(prefixedPatterns));\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#addVersionStrategy(strategy,pathPatterns)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a custom VersionStrategy to apply to resource URLs that match the\n\t * given path patterns.\n\t * @param strategy the custom strategy\n\t * @param pathPatterns one or more resource URL path patterns,\n\t * relative to the pattern configured with the resource handler\n\t * @return the current instance for chained method invocation\n\t * @see VersionStrategy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "strategy",
      "pathPatterns"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "VersionResourceResolver",
    "signature": "public VersionResourceResolver addVersionStrategy(VersionStrategy strategy, String... pathPatterns)",
    "source_code": "\tpublic VersionResourceResolver addVersionStrategy(VersionStrategy strategy, String... pathPatterns) {\n\t\tfor (String pattern : pathPatterns) {\n\t\t\tgetStrategyMap().put(pattern, strategy);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#checkResource(resource,location)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform additional checks on a resolved resource beyond checking whether the\n\t * resource exists and is readable. The default implementation also verifies\n\t * the resource is either under the location relative to which it was found or\n\t * is under one of the {@link #setAllowedLocations allowed locations}.\n\t * @param resource the resource to check\n\t * @param location the location relative to which the resource was found\n\t * @return \"true\" if resource is in a valid location, \"false\" otherwise.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resource",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "boolean",
    "signature": "protected boolean checkResource(Resource resource, Resource location)",
    "source_code": "\tprotected boolean checkResource(Resource resource, Resource location) throws IOException {\n\t\tif (isResourceUnderLocation(resource, location)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (getAllowedLocations() != null) {\n\t\t\tfor (Resource current : getAllowedLocations()) {\n\t\t\t\tif (isResourceUnderLocation(resource, current)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#extractLink(index,endChar,content,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "index",
      "endChar",
      "content",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "int",
    "signature": "protected int extractLink(int index, char endChar, String content, Set<ContentChunkInfo> result)",
    "source_code": "\t\tprotected int extractLink(int index, char endChar, String content, Set<ContentChunkInfo> result) {\n\t\t\tint start = index + 1;\n\t\t\tint end = content.indexOf(endChar, start);\n\t\t\tresult.add(new ContentChunkInfo(start, end, true));\n\t\t\treturn end + 1;\n\t\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#extractUnquotedLink(position,content,linksToAdd)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Invoked after a keyword match, after whitespace has been removed, and when\n\t\t * the next char is neither a single nor double quote.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "position",
      "content",
      "linksToAdd"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "int",
    "signature": "protected int extractUnquotedLink(int position, String content,\n\t\t\t\tSet<ContentChunkInfo> linksToAdd)",
    "source_code": "\t\tprotected abstract int extractUnquotedLink(int position, String content,\n\t\t\t\tSet<ContentChunkInfo> linksToAdd);\n\n\t}\n\n\n\tprivate static class ImportLinkParser extends AbstractLinkParser {"
  },
  "org.springframework.web.reactive.resource.<unknown>#extractUnquotedLink(position,content,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "position",
      "content",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "int",
    "signature": "protected int extractUnquotedLink(int position, String content, Set<ContentChunkInfo> result)",
    "source_code": "\t\tprotected int extractUnquotedLink(int position, String content, Set<ContentChunkInfo> result) {\n\t\t\t// A url() function without unquoted\n\t\t\treturn extractLink(position - 1, ')', content, result);\n\t\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#getForUriString(uriString,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the public resource URL for the given URI string.\n\t * <p>The URI string is expected to be a path and if it contains a query or\n\t * fragment those will be preserved in the resulting public resource URL.\n\t * @param uriString the URI string to transform\n\t * @param exchange the current exchange\n\t * @return the resolved public resource URL path, or empty if unresolved\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriString",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "Mono<String>",
    "signature": "public Mono<String> getForUriString(String uriString, ServerWebExchange exchange)",
    "source_code": "\tpublic final Mono<String> getForUriString(String uriString, ServerWebExchange exchange) {\n\t\tServerHttpRequest request = exchange.getRequest();\n\t\tint queryIndex = getQueryIndex(uriString);\n\t\tString lookupPath = uriString.substring(0, queryIndex);\n\t\tString query = uriString.substring(queryIndex);\n\t\tPathContainer parsedLookupPath = PathContainer.parsePath(lookupPath);\n\n\t\treturn resolveResourceUrl(exchange, parsedLookupPath).map(resolvedPath ->\n\t\t\t\trequest.getPath().contextPath().value() + resolvedPath + query);\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#getResource(resourcePath,location)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find the resource under the given location.\n\t * <p>The default implementation checks if there is a readable\n\t * {@code Resource} for the given path relative to the location.\n\t * @param resourcePath the path to the resource\n\t * @param location the location to check\n\t * @return the resource, or empty {@link Mono} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourcePath",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Mono<Resource>",
    "signature": "protected Mono<Resource> getResource(String resourcePath, Resource location)",
    "source_code": "\tprotected Mono<Resource> getResource(String resourcePath, Resource location) {\n\t\ttry {\n\t\t\tif (!(location instanceof UrlResource)) {\n\t\t\t\tresourcePath = UriUtils.decode(resourcePath, StandardCharsets.UTF_8);\n\t\t\t}\n\t\t\tResource resource = location.createRelative(resourcePath);\n\t\t\tif (resource.isReadable()) {\n\t\t\t\tif (checkResource(resource, location)) {\n\t\t\t\t\treturn Mono.just(resource);\n\t\t\t\t}\n\t\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\t\tResource[] allowed = getAllowedLocations();\n\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\t\"Resource path \\\"\" + resourcePath + \"\\\" was successfully resolved \" +\n\t\t\t\t\t\t\t\t\t\"but resource \\\"\" + resource.getURL() + \"\\\" is neither under the \" +\n\t\t\t\t\t\t\t\t\t\"current location \\\"\" + location.getURL() + \"\\\" nor under any of the \" +\n\t\t\t\t\t\t\t\t\t\"allowed locations \" + (allowed != null ? Arrays.asList(allowed) : \"[]\"), -1, true));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tString error = \"Skip location [\" + location + \"] due to error\";\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(error, ex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.debug(error + \": \" + ex.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#parse(content,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "void",
    "signature": "public void parse(String content, SortedSet<ContentChunkInfo> result)",
    "source_code": "\t\tpublic void parse(String content, SortedSet<ContentChunkInfo> result) {\n\t\t\tint position = 0;\n\t\t\twhile (true) {\n\t\t\t\tposition = content.indexOf(getKeyword(), position);\n\t\t\t\tif (position == -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tposition += getKeyword().length();\n\t\t\t\twhile (Character.isWhitespace(content.charAt(position))) {\n\t\t\t\t\tposition++;\n\t\t\t\t}\n\t\t\t\tif (content.charAt(position) == '\\'') {\n\t\t\t\t\tposition = extractLink(position, '\\'', content, result);\n\t\t\t\t}\n\t\t\t\telse if (content.charAt(position) == '\"') {\n\t\t\t\t\tposition = extractLink(position, '\"', content, result);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tposition = extractUnquotedLink(position, content, result);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#registerExtension(coding,extension)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Java config friendly alternative to {@link #setExtensions(Map)}.\n\t * @param coding the content coding\n\t * @param extension the associated file extension\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "coding",
      "extension"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "void",
    "signature": "public void registerExtension(String coding, String extension)",
    "source_code": "\tpublic void registerExtension(String coding, String extension) {\n\t\tthis.extensions.put(coding, (extension.startsWith(\".\") ? extension : \".\" + extension));\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#registerHandlers(Map<String,handlerMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Manually configure resource handler mappings.\n\t * <p><strong>Note:</strong> by default resource mappings are auto-detected\n\t * from the Spring {@code ApplicationContext}. If this property is used,\n\t * auto-detection is turned off.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "handlerMap"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void registerHandlers(Map<String, ResourceWebHandler> handlerMap)",
    "source_code": "\tpublic void registerHandlers(Map<String, ResourceWebHandler> handlerMap) {\n\t\tthis.handlerMap.clear();\n\t\thandlerMap.forEach((rawPattern, resourceWebHandler) -> {\n\t\t\trawPattern = prependLeadingSlash(rawPattern);\n\t\t\tPathPattern pattern = PathPatternParser.defaultInstance.parse(rawPattern);\n\t\t\tthis.handlerMap.put(pattern, resourceWebHandler);\n\t\t});\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#resolveResourceInternal(exchange,requestPath,locations,chain)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exchange",
      "requestPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "Mono<Resource>",
    "signature": "protected Mono<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,\n\t\t\tString requestPath, List<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected Mono<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,\n\t\t\tString requestPath, List<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\treturn getResource(requestPath, locations);\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#resolveUrlPathInternal(path,locations,chain)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "path",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "Mono<String>",
    "signature": "protected Mono<String> resolveUrlPathInternal(String path, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain)",
    "source_code": "\tprotected Mono<String> resolveUrlPathInternal(String path, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain) {\n\n\t\tif (StringUtils.hasText(path)) {\n\t\t\treturn getResource(path, locations).map(resource -> path);\n\t\t}\n\t\telse {\n\t\t\treturn Mono.empty();\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#resolveUrlPathInternal(resourceUrlPath,locations,chain)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourceUrlPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "Mono<String>",
    "signature": "protected Mono<String> resolveUrlPathInternal(String resourceUrlPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected Mono<String> resolveUrlPathInternal(String resourceUrlPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\treturn chain.resolveUrlPath(resourceUrlPath, locations)\n\t\t\t\t.flatMap(baseUrl -> {\n\t\t\t\t\tif (StringUtils.hasText(baseUrl)) {\n\t\t\t\t\t\tVersionStrategy strategy = getStrategyForPath(resourceUrlPath);\n\t\t\t\t\t\tif (strategy == null) {\n\t\t\t\t\t\t\treturn Mono.just(baseUrl);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn chain.resolveResource(null, baseUrl, locations)\n\t\t\t\t\t\t\t\t.flatMap(resource -> strategy.getResourceVersion(resource)\n\t\t\t\t\t\t\t\t\t\t.map(version -> strategy.addVersion(baseUrl, version)));\n\t\t\t\t\t}\n\t\t\t\t\treturn Mono.empty();\n\t\t\t\t});\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#setExtensions(Map<String,extensions)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure mappings from content codings to file extensions. A dot \".\"\n\t * will be prepended in front of the extension value if not present.\n\t * <p>By default this is configured with {@literal [\"br\" -> \".br\"]} and\n\t * {@literal [\"gzip\" -> \".gz\"]}.\n\t * @param extensions the extensions to use.\n\t * @see #registerExtension(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "extensions"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void setExtensions(Map<String, String> extensions)",
    "source_code": "\tpublic void setExtensions(Map<String, String> extensions) {\n\t\textensions.forEach(this::registerExtension);\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#setHeaders(exchange,resource,mediaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set headers on the response. Called for both GET and HEAD requests.\n\t * @param exchange current exchange\n\t * @param resource the identified resource (never {@code null})\n\t * @param mediaType the resource's media type (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exchange",
      "resource",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 634
    },
    "return": "void",
    "signature": "protected void setHeaders(ServerWebExchange exchange, Resource resource, @Nullable MediaType mediaType)",
    "source_code": "\tprotected void setHeaders(ServerWebExchange exchange, Resource resource, @Nullable MediaType mediaType)\n\t\t\tthrows IOException {\n\n\t\tHttpHeaders headers = exchange.getResponse().getHeaders();\n\n\t\tlong length = resource.contentLength();\n\t\theaders.setContentLength(length);\n\n\t\tif (mediaType != null) {\n\t\t\theaders.setContentType(mediaType);\n\t\t}\n\n\t\tif (resource instanceof HttpResource httpResource) {\n\t\t\texchange.getResponse().getHeaders().putAll(httpResource.getResponseHeaders());\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#setMediaTypes(Map<String,mediaTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add mappings between file extensions extracted from the filename of static\n\t * {@link Resource}s and the media types to use for the response.\n\t * <p>Use of this method is typically not necessary since mappings can be\n\t * also determined via {@link MediaTypeFactory#getMediaType(Resource)}.\n\t * @param mediaTypes media type mappings\n\t * @since 5.3.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "mediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "void",
    "signature": "public void setMediaTypes(Map<String, MediaType> mediaTypes)",
    "source_code": "\tpublic void setMediaTypes(Map<String, MediaType> mediaTypes) {\n\t\tif (this.mediaTypes == null) {\n\t\t\tthis.mediaTypes = new HashMap<>(mediaTypes.size());\n\t\t}\n\t\tmediaTypes.forEach((ext, type) ->\n\t\t\t\tthis.mediaTypes.put(ext.toLowerCase(Locale.ENGLISH), type));\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#setStrategyMap(Map<String,map)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Map with URL paths as keys and {@code VersionStrategy} as values.\n\t * <p>Supports direct URL matches and Ant-style pattern matches. For syntax\n\t * details, see the {@link AntPathMatcher} javadoc.\n\t * @param map a map with URLs as keys and version strategies as values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "public void setStrategyMap(Map<String, VersionStrategy> map)",
    "source_code": "\tpublic void setStrategyMap(Map<String, VersionStrategy> map) {\n\t\tthis.versionStrategyMap.clear();\n\t\tthis.versionStrategyMap.putAll(map);\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#transform(exchange,inputResource,transformerChain)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "inputResource",
      "transformerChain"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "Mono<Resource>",
    "signature": "public Mono<Resource> transform(ServerWebExchange exchange, Resource inputResource,\n\t\t\tResourceTransformerChain transformerChain)",
    "source_code": "\tpublic Mono<Resource> transform(ServerWebExchange exchange, Resource inputResource,\n\t\t\tResourceTransformerChain transformerChain) {\n\n\t\treturn transformerChain.transform(exchange, inputResource)\n\t\t\t\t.flatMap(outputResource -> {\n\t\t\t\t\tString filename = outputResource.getFilename();\n\t\t\t\t\tif (!\"css\".equals(StringUtils.getFilenameExtension(filename)) ||\n\t\t\t\t\t\t\tinputResource instanceof EncodedResourceResolver.EncodedResource) {\n\t\t\t\t\t\treturn Mono.just(outputResource);\n\t\t\t\t\t}\n\n\t\t\t\t\tDataBufferFactory bufferFactory = exchange.getResponse().bufferFactory();\n\t\t\t\t\tFlux<DataBuffer> flux = DataBufferUtils\n\t\t\t\t\t\t\t.read(outputResource, bufferFactory, StreamUtils.BUFFER_SIZE);\n\t\t\t\t\treturn DataBufferUtils.join(flux)\n\t\t\t\t\t\t\t.flatMap(dataBuffer -> {\n\t\t\t\t\t\t\t\tString cssContent = dataBuffer.toString(DEFAULT_CHARSET);\n\t\t\t\t\t\t\t\tDataBufferUtils.release(dataBuffer);\n\t\t\t\t\t\t\t\treturn transformContent(cssContent, outputResource, transformerChain, exchange);\n\t\t\t\t\t\t\t});\n\t\t\t\t});\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#compare(match1,match2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "match1",
      "match2"
    ],
    "position": {
      "column": 1,
      "line": 662
    },
    "return": "int",
    "signature": "public int compare(Match match1, Match match2)",
    "source_code": "\t\tpublic int compare(Match match1, Match match2) {\n\t\t\treturn this.comparator.compare(match1.mapping, match2.mapping);\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#compareTo(other,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Compares \"this\" info (i.e. the current instance) with another info in the context of a request.\n\t * <p>Note: It is assumed both instances have been obtained via\n\t * {@link #getMatchingCondition(ServerWebExchange)} to ensure they have conditions with\n\t * content relevant to current request.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "int",
    "signature": "public int compareTo(RequestMappingInfo other, ServerWebExchange exchange)",
    "source_code": "\tpublic int compareTo(RequestMappingInfo other, ServerWebExchange exchange) {\n\t\tint result = this.patternsCondition.compareTo(other.getPatternsCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.paramsCondition.compareTo(other.getParamsCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.headersCondition.compareTo(other.getHeadersCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.consumesCondition.compareTo(other.getConsumesCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.producesCondition.compareTo(other.getProducesCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.methodsCondition.compareTo(other.getMethodsCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.customConditionHolder.compareTo(other.customConditionHolder, exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\treturn 0;\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#createHandlerMethod(handler,method)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the HandlerMethod instance.\n\t * @param handler either a bean name or an actual handler instance\n\t * @param method the target method\n\t * @return the created HandlerMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod createHandlerMethod(Object handler, Method method)",
    "source_code": "\tprotected HandlerMethod createHandlerMethod(Object handler, Method method) {\n\t\tif (handler instanceof String beanName) {\n\t\t\treturn new HandlerMethod(beanName,\n\t\t\t\t\tobtainApplicationContext().getAutowireCapableBeanFactory(),\n\t\t\t\t\tobtainApplicationContext(),\n\t\t\t\t\tmethod);\n\t\t}\n\t\treturn new HandlerMethod(handler, method);\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#getCorsConfiguration(handler,exchange)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 403
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration getCorsConfiguration(Object handler, ServerWebExchange exchange)",
    "source_code": "\tprotected CorsConfiguration getCorsConfiguration(Object handler, ServerWebExchange exchange) {\n\t\tCorsConfiguration corsConfig = super.getCorsConfiguration(handler, exchange);\n\t\tif (handler instanceof HandlerMethod handlerMethod) {\n\t\t\tif (handlerMethod.equals(PREFLIGHT_AMBIGUOUS_MATCH)) {\n\t\t\t\treturn ALLOW_CORS_CONFIG;\n\t\t\t}\n\t\t\tCorsConfiguration methodConfig = this.mappingRegistry.getCorsConfiguration(handlerMethod);\n\t\t\tcorsConfig = (corsConfig != null ? corsConfig.combine(methodConfig) : methodConfig);\n\t\t}\n\t\treturn corsConfig;\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#getMappingForMethod(method,handlerType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Provide the mapping for a handler method. A method for which no\n\t * mapping can be provided is not a handler method.\n\t * @param method the method to provide a mapping for\n\t * @param handlerType the handler type, possibly a subtype of the method's\n\t * declaring class\n\t * @return the mapping, or {@code null} if the method is not mapped\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 434
    },
    "return": "T",
    "signature": "protected T getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected abstract T getMappingForMethod(Method method, Class<?> handlerType);"
  },
  "org.springframework.web.reactive.result.method.<unknown>#getMatchingMapping(mapping,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check if a mapping matches the current request and return a (potentially\n\t * new) mapping with conditions relevant to the current request.\n\t * @param mapping the mapping to get a match for\n\t * @param exchange the current exchange\n\t * @return the match, or {@code null} if the mapping doesn't match\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 452
    },
    "return": "T",
    "signature": "protected T getMatchingMapping(T mapping, ServerWebExchange exchange)",
    "source_code": "\tprotected abstract T getMatchingMapping(T mapping, ServerWebExchange exchange);"
  },
  "org.springframework.web.reactive.result.method.<unknown>#handleMatch(mapping,handlerMethod,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a matching mapping is found.\n\t * @param mapping the matching mapping\n\t * @param handlerMethod the matching method\n\t * @param exchange the current exchange\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "handlerMethod",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "void",
    "signature": "protected void handleMatch(T mapping, HandlerMethod handlerMethod, ServerWebExchange exchange)",
    "source_code": "\tprotected void handleMatch(T mapping, HandlerMethod handlerMethod, ServerWebExchange exchange) {\n\t\tString lookupPath = exchange.getRequest().getPath().pathWithinApplication().value();\n\t\texchange.getAttributes().put(PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, lookupPath);\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#handleNoMatch(mappings,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when no matching mapping is not found.\n\t * @param mappings all registered mappings\n\t * @param exchange the current exchange\n\t * @return an alternative HandlerMethod or {@code null}\n\t * @throws Exception provides details that can be translated into an error status code\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mappings",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 392
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod handleNoMatch(Set<T> mappings, ServerWebExchange exchange)",
    "source_code": "\tprotected HandlerMethod handleNoMatch(Set<T> mappings, ServerWebExchange exchange) throws Exception {\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#handlerMethodsInitialized(Map<T,handlerMethods)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked after all handler methods have been detected.\n\t * @param handlerMethods a read-only map with handler methods and mappings.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<T",
      "handlerMethods"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "void",
    "signature": "protected void handlerMethodsInitialized(Map<T, HandlerMethod> handlerMethods)",
    "source_code": "\tprotected void handlerMethodsInitialized(Map<T, HandlerMethod> handlerMethods) {\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#initCorsConfiguration(handler,method,mapping)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extract and return the CORS configuration for the mapping.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration initCorsConfiguration(Object handler, Method method, T mapping)",
    "source_code": "\tprotected CorsConfiguration initCorsConfiguration(Object handler, Method method, T mapping) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#invoke(exchange,bindingContext,providedArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method for the given exchange.\n\t * @param exchange the current exchange\n\t * @param bindingContext the binding context to use\n\t * @param providedArgs optional list of argument values to match by type\n\t * @return a Mono with a {@link HandlerResult}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "bindingContext",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "Mono<HandlerResult>",
    "signature": "public Mono<HandlerResult> invoke(ServerWebExchange exchange, BindingContext bindingContext, Object... providedArgs)",
    "source_code": "\tpublic Mono<HandlerResult> invoke(\n\t\t\tServerWebExchange exchange, BindingContext bindingContext, Object... providedArgs) {\n\n\t\treturn getMethodArgumentValues(exchange, bindingContext, providedArgs).flatMap(args -> {\n\t\t\tObject value;\n\t\t\tMethod method = getBridgedMethod();\n\t\t\tboolean isSuspendingFunction = KotlinDetector.isSuspendingFunction(method);\n\t\t\ttry {\n\t\t\t\tif (isSuspendingFunction) {\n\t\t\t\t\tvalue = CoroutinesUtils.invokeSuspendingFunction(method, getBean(), args);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvalue = method.invoke(getBean(), args);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tassertTargetBean(getBridgedMethod(), getBean(), args);\n\t\t\t\tString text = (ex.getMessage() != null ? ex.getMessage() : \"Illegal argument\");\n\t\t\t\treturn Mono.error(new IllegalStateException(formatInvokeError(text, args), ex));\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\treturn Mono.error(ex.getTargetException());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// Unlikely to ever get here, but it must be handled...\n\t\t\t\treturn Mono.error(new IllegalStateException(formatInvokeError(\"Invocation failure\", args), ex));\n\t\t\t}\n\n\t\t\tHttpStatusCode status = getResponseStatus();\n\t\t\tif (status != null) {\n\t\t\t\texchange.getResponse().setStatusCode(status);\n\t\t\t}\n\n\t\t\tMethodParameter returnType = getReturnType();\n\t\t\tif (isResponseHandled(args, exchange)) {\n\t\t\t\tClass<?> parameterType = returnType.getParameterType();\n\t\t\t\tReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(parameterType);\n\t\t\t\tboolean asyncVoid = isAsyncVoidReturnType(returnType, adapter);\n\t\t\t\tif (value == null || asyncVoid) {\n\t\t\t\t\treturn (asyncVoid ? Mono.from(adapter.toPublisher(value)) : Mono.empty());\n\t\t\t\t}\n\t\t\t\tif (isSuspendingFunction && parameterType == void.class) {\n\t\t\t\t\treturn (Mono<HandlerResult>) value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tHandlerResult result = new HandlerResult(this, value, returnType, bindingContext);\n\t\t\treturn Mono.just(result);\n\t\t});\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#register(mapping,handler,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 521
    },
    "return": "void",
    "signature": "public void register(T mapping, Object handler, Method method)",
    "source_code": "\t\tpublic void register(T mapping, Object handler, Method method) {\n\t\t\tthis.readWriteLock.writeLock().lock();\n\t\t\ttry {\n\t\t\t\tHandlerMethod handlerMethod = createHandlerMethod(handler, method);\n\t\t\t\tvalidateMethodMapping(handlerMethod, mapping);\n\n\t\t\t\tSet<String> directPaths = AbstractHandlerMethodMapping.this.getDirectPaths(mapping);\n\t\t\t\tfor (String path : directPaths) {\n\t\t\t\t\tthis.pathLookup.add(path, mapping);\n\t\t\t\t}\n\n\t\t\t\tCorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);\n\t\t\t\tif (corsConfig != null) {\n\t\t\t\t\tcorsConfig.validateAllowCredentials();\n\t\t\t\t\tthis.corsLookup.put(handlerMethod, corsConfig);\n\t\t\t\t}\n\n\t\t\t\tthis.registry.put(mapping,\n\t\t\t\t\t\tnew MappingRegistration<>(mapping, handlerMethod, directPaths, corsConfig != null));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.readWriteLock.writeLock().unlock();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#registerHandlerMethod(handler,method,mapping)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a handler method and its unique mapping. Invoked at startup for\n\t * each detected handler method.\n\t * @param handler the bean name of the handler or the handler instance\n\t * @param method the method to register\n\t * @param mapping the mapping conditions associated with the handler method\n\t * @throws IllegalStateException if another method was already registered\n\t * under the same mapping\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "void",
    "signature": "protected void registerHandlerMethod(Object handler, Method method, T mapping)",
    "source_code": "\tprotected void registerHandlerMethod(Object handler, Method method, T mapping) {\n\t\tthis.mappingRegistry.register(mapping, handler, method);\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#registerMapping(mapping,handler,method)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given mapping.\n\t * <p>This method may be invoked at runtime after initialization has completed.\n\t * @param mapping the mapping for the handler method\n\t * @param handler the handler\n\t * @param method the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void registerMapping(T mapping, Object handler, Method method)",
    "source_code": "\tpublic void registerMapping(T mapping, Object handler, Method method) {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Register \\\"\" + mapping + \"\\\" to \" + method.toGenericString());\n\t\t}\n\t\tthis.mappingRegistry.register(mapping, handler, method);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#bindRequestParameters(binder,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param exchange the current request\n\t * @since 5.2.6\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> bindRequestParameters(WebExchangeDataBinder binder, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<Void> bindRequestParameters(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.bind(exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#createProblemDetail(ex,status,defaultDetail,detailMessageCode,detailMessageArguments,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method to create a {@link ProblemDetail} for any exception\n\t * that doesn't implement {@link ErrorResponse}, also performing a\n\t * {@link MessageSource} lookup for the \"detail\" field.\n\t * @param ex the exception being handled\n\t * @param status the status to associate with the exception\n\t * @param defaultDetail default value for the \"detail\" field\n\t * @param detailMessageCode the code to use to look up the \"detail\" field\n\t * through a {@code MessageSource}, falling back on\n\t * {@link ErrorResponse#getDefaultDetailMessageCode(Class, String)}\n\t * @param detailMessageArguments the arguments to go with the detailMessageCode\n\t * @return the created {@code ProblemDetail} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "status",
      "defaultDetail",
      "detailMessageCode",
      "detailMessageArguments",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "ProblemDetail",
    "signature": "protected ProblemDetail createProblemDetail(Exception ex, HttpStatusCode status, String defaultDetail, @Nullable String detailMessageCode,\n\t\t\t@Nullable Object[] detailMessageArguments, ServerWebExchange exchange)",
    "source_code": "\tprotected ProblemDetail createProblemDetail(\n\t\t\tException ex, HttpStatusCode status, String defaultDetail, @Nullable String detailMessageCode,\n\t\t\t@Nullable Object[] detailMessageArguments, ServerWebExchange exchange) {\n\n\t\tErrorResponse.Builder builder = ErrorResponse.builder(ex, status, defaultDetail);\n\t\tif (detailMessageCode != null) {\n\t\t\tbuilder.detailMessageCode(detailMessageCode);\n\t\t}\n\t\tif (detailMessageArguments != null) {\n\t\t\tbuilder.detailMessageArguments(detailMessageArguments);\n\t\t}\n\t\treturn builder.build().updateAndGetBody(this.messageSource, getLocale(exchange));\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#createRequestMappingInfo(requestMapping,customCondition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RequestMappingInfo} from the supplied\n\t * {@link RequestMapping @RequestMapping} annotation, which is either\n\t * a directly declared annotation, a meta-annotation, or the synthesized\n\t * result of merging annotation attributes within an annotation hierarchy.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "requestMapping",
      "customCondition"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo createRequestMappingInfo(RequestMapping requestMapping, @Nullable RequestCondition<?> customCondition)",
    "source_code": "\tprotected RequestMappingInfo createRequestMappingInfo(\n\t\t\tRequestMapping requestMapping, @Nullable RequestCondition<?> customCondition) {\n\n\t\tRequestMappingInfo.Builder builder = RequestMappingInfo\n\t\t\t\t.paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))\n\t\t\t\t.methods(requestMapping.method())\n\t\t\t\t.params(requestMapping.params())\n\t\t\t\t.headers(requestMapping.headers())\n\t\t\t\t.consumes(requestMapping.consumes())\n\t\t\t\t.produces(requestMapping.produces())\n\t\t\t\t.mappingName(requestMapping.name());\n\t\tif (customCondition != null) {\n\t\t\tbuilder.customCondition(customCondition);\n\t\t}\n\t\treturn builder.options(this.config).build();\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#createResponseEntity(body,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the {@link ResponseEntity} to use from the given body, headers,\n\t * and statusCode. Subclasses can override this method to inspect and possibly\n\t * modify the body, headers, or statusCode, e.g. to re-create an instance of\n\t * {@link ProblemDetail} as an extension of {@link ProblemDetail}.\n\t * @param body the body to use for the response\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the created {@code ResponseEntity}\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "body",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> createResponseEntity(@Nullable Object body, @Nullable HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> createResponseEntity(\n\t\t\t@Nullable Object body, @Nullable HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn Mono.just(new ResponseEntity<>(body, headers, status));\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#getMappingForMethod(method,handlerType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Uses method and type-level @{@link RequestMapping} annotations to create\n\t * the RequestMappingInfo.\n\t * @return the created RequestMappingInfo, or {@code null} if the method\n\t * does not have a {@code @RequestMapping} annotation.\n\t * @see #getCustomMethodCondition(Method)\n\t * @see #getCustomTypeCondition(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n\t\tRequestMappingInfo info = createRequestMappingInfo(method);\n\t\tif (info != null) {\n\t\t\tRequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);\n\t\t\tif (typeInfo != null) {\n\t\t\t\tinfo = typeInfo.combine(info);\n\t\t\t}\n\t\t\tfor (Map.Entry<String, Predicate<Class<?>>> entry : this.pathPrefixes.entrySet()) {\n\t\t\t\tif (entry.getValue().test(handlerType)) {\n\t\t\t\t\tString prefix = entry.getKey();\n\t\t\t\t\tif (this.embeddedValueResolver != null) {\n\t\t\t\t\t\tprefix = this.embeddedValueResolver.resolveStringValue(prefix);\n\t\t\t\t\t}\n\t\t\t\t\tinfo = RequestMappingInfo.paths(prefix).options(this.config).build().combine(info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn info;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#getValuesToBind(binder,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Protected method to obtain the values for data binding. By default this\n\t * method delegates to {@link WebExchangeDataBinder#getValuesToBind}.\n\t * @param binder the data binder in use\n\t * @param exchange the current exchange\n\t * @return a map of bind values\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "binder",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "Object>>",
    "signature": "public Object>> getValuesToBind(WebExchangeDataBinder binder, ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Map<String, Object>> getValuesToBind(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.getValuesToBind(exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handle(exchange,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "Mono<HandlerResult>",
    "signature": "public Mono<HandlerResult> handle(ServerWebExchange exchange, Object handler)",
    "source_code": "\tpublic Mono<HandlerResult> handle(ServerWebExchange exchange, Object handler) {\n\t\tHandlerMethod handlerMethod = (HandlerMethod) handler;\n\t\tAssert.state(this.methodResolver != null && this.modelInitializer != null, \"Not initialized\");\n\n\t\tInitBinderBindingContext bindingContext = new InitBinderBindingContext(\n\t\t\t\tgetWebBindingInitializer(), this.methodResolver.getInitBinderMethods(handlerMethod));\n\n\t\tInvocableHandlerMethod invocableMethod = this.methodResolver.getRequestMappingMethod(handlerMethod);\n\n\t\tDispatchExceptionHandler exceptionHandler =\n\t\t\t\t(exchange2, ex) -> handleException(exchange, ex, handlerMethod, bindingContext);\n\n\t\treturn this.modelInitializer\n\t\t\t\t.initModel(handlerMethod, bindingContext, exchange)\n\t\t\t\t.then(Mono.defer(() -> invocableMethod.invoke(exchange, bindingContext)))\n\t\t\t\t.doOnNext(result -> result.setExceptionHandler(exceptionHandler))\n\t\t\t\t.doOnNext(result -> bindingContext.saveModel())\n\t\t\t\t.onErrorResume(ex -> exceptionHandler.handleError(exchange, ex));\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleError(exchange,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "Mono<HandlerResult>",
    "signature": "public Mono<HandlerResult> handleError(ServerWebExchange exchange, Throwable ex)",
    "source_code": "\tpublic Mono<HandlerResult> handleError(ServerWebExchange exchange, Throwable ex) {\n\t\treturn handleException(exchange, ex, null, null);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleErrorResponseException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of any {@link ErrorResponseException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleErrorResponseException(ErrorResponseException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleErrorResponseException(\n\t\t\tErrorResponseException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleException(ex,exchange)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "public Mono<ResponseEntity<Object>> handleException(Exception ex, ServerWebExchange exchange)",
    "source_code": "\tpublic final Mono<ResponseEntity<Object>> handleException(Exception ex, ServerWebExchange exchange) {\n\t\tif (ex instanceof MethodNotAllowedException theEx) {\n\t\t\treturn handleMethodNotAllowedException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse if (ex instanceof NotAcceptableStatusException theEx) {\n\t\t\treturn handleNotAcceptableStatusException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse if (ex instanceof UnsupportedMediaTypeStatusException theEx) {\n\t\t\treturn handleUnsupportedMediaTypeStatusException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse if (ex instanceof MissingRequestValueException theEx) {\n\t\t\treturn handleMissingRequestValueException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse if (ex instanceof UnsatisfiedRequestParameterException theEx) {\n\t\t\treturn handleUnsatisfiedRequestParameterException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse if (ex instanceof WebExchangeBindException theEx) {\n\t\t\treturn handleWebExchangeBindException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse if (ex instanceof ServerWebInputException theEx) {\n\t\t\treturn handleServerWebInputException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse if (ex instanceof ServerErrorException theEx) {\n\t\t\treturn handleServerErrorException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse if (ex instanceof ResponseStatusException theEx) {\n\t\t\treturn handleResponseStatusException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse if (ex instanceof ErrorResponseException theEx) {\n\t\t\treturn handleErrorResponseException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Unexpected exception type: \" + ex.getClass().getName());\n\t\t\t}\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleExceptionInternal(ex,body,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Internal handler method that all others in this class delegate to, for\n\t * common handling, and for the creation of a {@link ResponseEntity}.\n\t * <p>The default implementation does the following:\n\t * <ul>\n\t * <li>return {@code null} if response is already committed\n\t * <li>set the {@code \"jakarta.servlet.error.exception\"} request attribute\n\t * if the response status is 500 (INTERNAL_SERVER_ERROR).\n\t * <li>extract the {@link ErrorResponse#getBody() body} from\n\t * {@link ErrorResponse} exceptions, if the {@code body} is {@code null}.\n\t * </ul>\n\t * @param ex the exception to handle\n\t * @param body the body to use for the response\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "body",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleExceptionInternal(Exception ex, @Nullable Object body, @Nullable HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleExceptionInternal(\n\t\t\tException ex, @Nullable Object body, @Nullable HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\tif (exchange.getResponse().isCommitted()) {\n\t\t\treturn Mono.error(ex);\n\t\t}\n\n\t\tif (body == null && ex instanceof ErrorResponse errorResponse) {\n\t\t\tbody = errorResponse.updateAndGetBody(this.messageSource, getLocale(exchange));\n\t\t}\n\n\t\treturn createResponseEntity(body, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleMethodNotAllowedException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MethodNotAllowedException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleMethodNotAllowedException(MethodNotAllowedException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleMethodNotAllowedException(\n\t\t\tMethodNotAllowedException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleMissingRequestValueException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MissingRequestValueException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleMissingRequestValueException(MissingRequestValueException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleMissingRequestValueException(\n\t\t\tMissingRequestValueException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleNotAcceptableStatusException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link NotAcceptableStatusException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleNotAcceptableStatusException(NotAcceptableStatusException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleNotAcceptableStatusException(\n\t\t\tNotAcceptableStatusException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleResponseStatusException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of any {@link ResponseStatusException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleResponseStatusException(ResponseStatusException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleResponseStatusException(\n\t\t\tResponseStatusException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleResult(exchange,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result)",
    "source_code": "\tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n\t\tObject body = result.getReturnValue();\n\t\tMethodParameter bodyTypeParameter = result.getReturnTypeSource();\n\t\tif (body instanceof ProblemDetail detail) {\n\t\t\texchange.getResponse().setStatusCode(HttpStatusCode.valueOf(detail.getStatus()));\n\t\t\tif (detail.getInstance() == null) {\n\t\t\t\tURI path = URI.create(exchange.getRequest().getPath().value());\n\t\t\t\tdetail.setInstance(path);\n\t\t\t}\n\t\t}\n\t\treturn writeBody(body, bodyTypeParameter, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleServerErrorException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link ServerErrorException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleServerErrorException(ServerErrorException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleServerErrorException(\n\t\t\tServerErrorException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleServerWebInputException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link ServerWebInputException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleServerWebInputException(ServerWebInputException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleServerWebInputException(\n\t\t\tServerWebInputException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleUnsatisfiedRequestParameterException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link UnsatisfiedRequestParameterException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleUnsatisfiedRequestParameterException(UnsatisfiedRequestParameterException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleUnsatisfiedRequestParameterException(\n\t\t\tUnsatisfiedRequestParameterException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleUnsupportedMediaTypeStatusException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link UnsupportedMediaTypeStatusException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleUnsupportedMediaTypeStatusException(UnsupportedMediaTypeStatusException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleUnsupportedMediaTypeStatusException(\n\t\t\tUnsupportedMediaTypeStatusException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleWebExchangeBindException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link WebExchangeBindException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleWebExchangeBindException(WebExchangeBindException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleWebExchangeBindException(\n\t\t\tWebExchangeBindException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#initCorsConfiguration(handler,method,mappingInfo)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mappingInfo"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mappingInfo)",
    "source_code": "\tprotected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mappingInfo) {\n\t\tHandlerMethod handlerMethod = createHandlerMethod(handler, method);\n\t\tClass<?> beanType = handlerMethod.getBeanType();\n\t\tCrossOrigin typeAnnotation = AnnotatedElementUtils.findMergedAnnotation(beanType, CrossOrigin.class);\n\t\tCrossOrigin methodAnnotation = AnnotatedElementUtils.findMergedAnnotation(method, CrossOrigin.class);\n\n\t\tif (typeAnnotation == null && methodAnnotation == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tCorsConfiguration config = new CorsConfiguration();\n\t\tupdateCorsConfig(config, typeAnnotation);\n\t\tupdateCorsConfig(config, methodAnnotation);\n\n\t\tif (CollectionUtils.isEmpty(config.getAllowedMethods())) {\n\t\t\tfor (RequestMethod allowedMethod : mappingInfo.getMethodsCondition().getMethods()) {\n\t\t\t\tconfig.addAllowedMethod(allowedMethod.name());\n\t\t\t}\n\t\t}\n\t\treturn config.applyPermitDefaultValues();\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#registerHandlerMethod(handler,method,mapping)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "void",
    "signature": "protected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping)",
    "source_code": "\tprotected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping) {\n\t\tsuper.registerHandlerMethod(handler, method, mapping);\n\t\tupdateConsumesCondition(mapping, method);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#registerMapping(mapping,handler,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "void",
    "signature": "public void registerMapping(RequestMappingInfo mapping, Object handler, Method method)",
    "source_code": "\tpublic void registerMapping(RequestMappingInfo mapping, Object handler, Method method) {\n\t\tsuper.registerMapping(mapping, handler, method);\n\t\tupdateConsumesCondition(mapping, method);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#resolveArgument(parameter,context,exchange)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "context",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "Mono<Object>",
    "signature": "public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext context, ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Object> resolveArgument(\n\t\t\tMethodParameter parameter, BindingContext context, ServerWebExchange exchange) {\n\n\t\tResolvableType type = ResolvableType.forMethodParameter(parameter);\n\t\tClass<?> resolvedType = type.resolve();\n\t\tReactiveAdapter adapter = (resolvedType != null ? getAdapterRegistry().getAdapter(resolvedType) : null);\n\t\tResolvableType valueType = (adapter != null ? type.getGeneric() : type);\n\n\t\tAssert.state(adapter == null || !adapter.isMultiValue(),\n\t\t\t\t() -> getClass().getSimpleName() + \" does not support multi-value reactive type wrapper: \" +\n\t\t\t\t\t\tparameter.getGenericParameterType());\n\n\t\tString name = ModelInitializer.getNameForParameter(parameter);\n\t\tMono<?> valueMono = prepareAttributeMono(name, valueType, context, exchange);\n\n\t\t// unsafe(): we're intercepting, already serialized Publisher signals\n\t\tSinks.One<BindingResult> bindingResultSink = Sinks.unsafe().one();\n\n\t\tMap<String, Object> model = context.getModel().asMap();\n\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, bindingResultSink.asMono());\n\n\t\treturn valueMono.flatMap(value -> {\n\t\t\tWebExchangeDataBinder binder = context.createDataBinder(exchange, value, name);\n\t\t\treturn (bindingDisabled(parameter) ? Mono.empty() : bindRequestParameters(binder, exchange))\n\t\t\t\t\t.doOnError(bindingResultSink::tryEmitError)\n\t\t\t\t\t.doOnSuccess(aVoid -> {\n\t\t\t\t\t\tvalidateIfApplicable(binder, parameter, exchange);\n\t\t\t\t\t\tBindingResult bindingResult = binder.getBindingResult();\n\t\t\t\t\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, bindingResult);\n\t\t\t\t\t\tmodel.put(name, value);\n\t\t\t\t\t\t// Ignore result: serialized and buffered (should never fail)\n\t\t\t\t\t\tbindingResultSink.tryEmitValue(bindingResult);\n\t\t\t\t\t})\n\t\t\t\t\t.then(Mono.fromCallable(() -> {\n\t\t\t\t\t\tBindingResult errors = binder.getBindingResult();\n\t\t\t\t\t\tif (adapter != null) {\n\t\t\t\t\t\t\treturn adapter.fromPublisher(errors.hasErrors() ?\n\t\t\t\t\t\t\t\t\tMono.error(new WebExchangeBindException(parameter, errors)) : valueMono);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (errors.hasErrors() && !hasErrorsArgument(parameter)) {\n\t\t\t\t\t\t\t\tthrow new WebExchangeBindException(parameter, errors);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t});\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#resolveArgumentValue(methodParameter,context,exchange)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodParameter",
      "context",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "Object",
    "signature": "public Object resolveArgumentValue(MethodParameter methodParameter, BindingContext context, ServerWebExchange exchange)",
    "source_code": "\tpublic Object resolveArgumentValue(\n\t\t\tMethodParameter methodParameter, BindingContext context, ServerWebExchange exchange) {\n\n\t\tClass<?> paramType = methodParameter.getParameterType();\n\t\tif (ServerWebExchange.class.isAssignableFrom(paramType)) {\n\t\t\treturn exchange;\n\t\t}\n\t\telse if (ServerHttpRequest.class.isAssignableFrom(paramType)) {\n\t\t\treturn exchange.getRequest();\n\t\t}\n\t\telse if (ServerHttpResponse.class.isAssignableFrom(paramType)) {\n\t\t\treturn exchange.getResponse();\n\t\t}\n\t\telse if (HttpMethod.class == paramType) {\n\t\t\treturn exchange.getRequest().getMethod();\n\t\t}\n\t\telse if (Locale.class == paramType) {\n\t\t\treturn exchange.getLocaleContext().getLocale();\n\t\t}\n\t\telse if (TimeZone.class == paramType) {\n\t\t\tLocaleContext localeContext = exchange.getLocaleContext();\n\t\t\tTimeZone timeZone = getTimeZone(localeContext);\n\t\t\treturn (timeZone != null ? timeZone : TimeZone.getDefault());\n\t\t}\n\t\telse if (ZoneId.class == paramType) {\n\t\t\tLocaleContext localeContext = exchange.getLocaleContext();\n\t\t\tTimeZone timeZone = getTimeZone(localeContext);\n\t\t\treturn (timeZone != null ? timeZone.toZoneId() : ZoneId.systemDefault());\n\t\t}\n\t\telse if (UriBuilder.class == paramType || UriComponentsBuilder.class == paramType) {\n\t\t\tURI uri = exchange.getRequest().getURI();\n\t\t\tString contextPath = exchange.getRequest().getPath().contextPath().value();\n\t\t\treturn UriComponentsBuilder.fromUri(uri).replacePath(contextPath).replaceQuery(null);\n\t\t}\n\t\telse {\n\t\t\t// should never happen...\n\t\t\tthrow new IllegalArgumentException(\"Unknown parameter type: \" +\n\t\t\t\t\tparamType + \" in method: \" + methodParameter.getMethod());\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#setPathPrefixes(Map<String,prefixes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure path prefixes to apply to controller methods.\n\t * <p>Prefixes are used to enrich the mappings of every {@code @RequestMapping}\n\t * method whose controller type is matched by a corresponding\n\t * {@code Predicate} in the map. The prefix for the first matching predicate\n\t * is used, assuming the input map has predictable order.\n\t * <p>Consider using {@link org.springframework.web.method.HandlerTypePredicate\n\t * HandlerTypePredicate} to group controllers.\n\t * @param prefixes a map with path prefixes as key\n\t * @since 5.1\n\t * @see org.springframework.web.method.HandlerTypePredicate\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "prefixes"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void setPathPrefixes(Map<String, Predicate<Class<?>>> prefixes)",
    "source_code": "\tpublic void setPathPrefixes(Map<String, Predicate<Class<?>>> prefixes) {\n\t\tthis.pathPrefixes.clear();\n\t\tprefixes.entrySet().stream()\n\t\t\t\t.filter(entry -> StringUtils.hasText(entry.getKey()))\n\t\t\t\t.forEach(entry -> this.pathPrefixes.put(entry.getKey(), entry.getValue()));\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#applyLifecycleMethods(viewName,view)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the containing {@link ApplicationContext}'s lifecycle methods\n\t * to the given {@link View} instance, if such a context is available.\n\t * @param viewName the name of the view\n\t * @param view the freshly created View instance, pre-configured with\n\t * {@link AbstractUrlBasedView}'s properties\n\t * @return the {@link View} instance to use (either the original one\n\t * or a decorated variant)\n\t * @see #getApplicationContext()\n\t * @see ApplicationContext#getAutowireCapableBeanFactory()\n\t * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#initializeBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "view"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "View",
    "signature": "protected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view)",
    "source_code": "\tprotected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view) {\n\t\tApplicationContext context = getApplicationContext();\n\t\tif (context != null) {\n\t\t\tObject initialized = context.getAutowireCapableBeanFactory().initializeBean(view, viewName);\n\t\t\tif (initialized instanceof View initializedView) {\n\t\t\t\treturn initializedView;\n\t\t\t}\n\t\t}\n\t\treturn view;\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#canHandle(viewName,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Indicates whether this {@link ViewResolver} can handle the supplied\n\t * view name. If not, an empty result is returned. The default implementation\n\t * checks against the configured {@link #setViewNames view names}.\n\t * @param viewName the name of the view to retrieve\n\t * @param locale the Locale to retrieve the view for\n\t * @return whether this resolver applies to the specified view\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "boolean",
    "signature": "protected boolean canHandle(String viewName, Locale locale)",
    "source_code": "\tprotected boolean canHandle(String viewName, Locale locale) {\n\t\tString[] viewNames = getViewNames();\n\t\treturn (viewNames == null || PatternMatchUtils.simpleMatch(viewNames, viewName));\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#changeLocale(locale,timeZone)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Change the current locale to the specified locale and time zone context.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locale",
      "timeZone"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void changeLocale(Locale locale, TimeZone timeZone)",
    "source_code": "\tpublic void changeLocale(Locale locale, TimeZone timeZone) {\n\t\tthis.locale = locale;\n\t\tthis.timeZone = timeZone;\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getBindStatus(path,htmlEscape)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a BindStatus for the given bind object, using the\n\t * \"defaultHtmlEscape\" setting.\n\t * @param path the bean and property path for which values and errors will\n\t * be resolved (e.g. \"person.age\")\n\t * @param htmlEscape create a BindStatus with automatic HTML escaping?\n\t * @return the new BindStatus instance\n\t * @throws IllegalStateException if no corresponding Errors object found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 440
    },
    "return": "BindStatus",
    "signature": "public BindStatus getBindStatus(String path, boolean htmlEscape)",
    "source_code": "\tpublic BindStatus getBindStatus(String path, boolean htmlEscape) throws IllegalStateException {\n\t\treturn new BindStatus(this, path, htmlEscape);\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getContextUrl(relativeUrl,Map<String,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a context-aware URl for the given relative URL with placeholders --\n\t * named keys with braces {@code {}}. For example, send in a relative URL\n\t * {@code foo/{bar}?spam={spam}} and a parameter map {@code {bar=baz,spam=nuts}}\n\t * and the result will be {@code [contextpath]/foo/baz?spam=nuts}.\n\t * @param relativeUrl the relative URL part\n\t * @param params a map of parameters to insert as placeholders in the url\n\t * @return a URL that points back to the current web application with an\n\t * absolute path also URL-encoded accordingly\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativeUrl",
      "Map<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "String",
    "signature": "public String getContextUrl(String relativeUrl, Map<String, ?> params)",
    "source_code": "\tpublic String getContextUrl(String relativeUrl, Map<String, ?> params) {\n\t\tString url = StringUtils.applyRelativePath(getContextPath() + \"/\", relativeUrl);\n\t\turl = UriComponentsBuilder.fromUriString(url).buildAndExpand(params).encode().toUri().toASCIIString();\n\t\treturn getExchange().transformUrl(url);\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getErrors(name,htmlEscape)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the Errors instance for the given bind object.\n\t * @param name the name of the bind object\n\t * @param htmlEscape create an Errors instance with automatic HTML escaping?\n\t * @return the Errors instance, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "Errors",
    "signature": "public Errors getErrors(String name, boolean htmlEscape)",
    "source_code": "\tpublic Errors getErrors(String name, boolean htmlEscape) {\n\t\tif (this.errorsMap == null) {\n\t\t\tthis.errorsMap = new HashMap<>();\n\t\t}\n\n\t\tErrors errors = this.errorsMap.get(name);\n\t\tif (errors == null) {\n\t\t\terrors = getModelObject(BindingResult.MODEL_KEY_PREFIX + name);\n\t\t\tif (errors == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (errors instanceof BindException bindException) {\n\t\t\terrors = bindException.getBindingResult();\n\t\t}\n\n\t\tif (htmlEscape && !(errors instanceof EscapedErrors)) {\n\t\t\terrors = new EscapedErrors(errors);\n\t\t}\n\t\telse if (!htmlEscape && errors instanceof EscapedErrors escapedErrors) {\n\t\t\terrors = escapedErrors.getSource();\n\t\t}\n\n\t\tthis.errorsMap.put(name, errors);\n\t\treturn errors;\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(code,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable List<?> args)",
    "source_code": "\tpublic String getMessage(String code, @Nullable List<?> args) throws NoSuchMessageException {\n\t\treturn getMessage(code, (args != null ? args.toArray() : null), isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(code,args,defaultMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable List<?> args, String defaultMessage)",
    "source_code": "\tpublic String getMessage(String code, @Nullable List<?> args, String defaultMessage) {\n\t\treturn getMessage(code, (args != null ? args.toArray() : null), defaultMessage, isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(code,args,defaultMessage,htmlEscape)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, String defaultMessage, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, String defaultMessage, boolean htmlEscape) {\n\t\tString msg = this.messageSource.getMessage(code, args, defaultMessage, this.locale);\n\t\tif (msg == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(code,args,htmlEscape)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, boolean htmlEscape) throws NoSuchMessageException {\n\t\tString msg = this.messageSource.getMessage(code, args, this.locale);\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(code,defaultMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "String",
    "signature": "public String getMessage(String code, String defaultMessage)",
    "source_code": "\tpublic String getMessage(String code, String defaultMessage) {\n\t\treturn getMessage(code, null, defaultMessage, isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(resolvable,htmlEscape)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given MessageSourceResolvable (e.g. an ObjectError instance).\n\t * @param resolvable the MessageSourceResolvable\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable, boolean htmlEscape) throws NoSuchMessageException {\n\t\tString msg = this.messageSource.getMessage(resolvable, this.locale);\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#handleResult(exchange,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result)",
    "source_code": "\tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n\t\tMono<Object> valueMono;\n\t\tResolvableType valueType;\n\t\tReactiveAdapter adapter = getAdapter(result);\n\n\t\tif (adapter != null) {\n\t\t\tif (adapter.isMultiValue()) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Multi-value reactive types not supported in view resolution: \" + result.getReturnType());\n\t\t\t}\n\n\t\t\tvalueMono = (result.getReturnValue() != null ?\n\t\t\t\t\tMono.from(adapter.toPublisher(result.getReturnValue())) : Mono.empty());\n\n\t\t\tvalueType = (adapter.isNoValue() ? ResolvableType.forClass(Void.class) :\n\t\t\t\t\tresult.getReturnType().getGeneric());\n\t\t}\n\t\telse {\n\t\t\tvalueMono = Mono.justOrEmpty(result.getReturnValue());\n\t\t\tvalueType = result.getReturnType();\n\t\t}\n\n\t\treturn valueMono\n\t\t\t\t.switchIfEmpty(exchange.isNotModified() ? Mono.empty() : NO_VALUE_MONO)\n\t\t\t\t.flatMap(returnValue -> {\n\n\t\t\t\t\tMono<List<View>> viewsMono;\n\t\t\t\t\tModel model = result.getModel();\n\t\t\t\t\tMethodParameter parameter = result.getReturnTypeSource();\n\t\t\t\t\tLocale locale = LocaleContextHolder.getLocale(exchange.getLocaleContext());\n\n\t\t\t\t\tClass<?> clazz = valueType.toClass();\n\t\t\t\t\tif (clazz == Object.class) {\n\t\t\t\t\t\tclazz = returnValue.getClass();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (returnValue == NO_VALUE || clazz == void.class || clazz == Void.class) {\n\t\t\t\t\t\tviewsMono = resolveViews(getDefaultViewName(exchange), locale);\n\t\t\t\t\t}\n\t\t\t\t\telse if (CharSequence.class.isAssignableFrom(clazz) && !hasModelAnnotation(parameter)) {\n\t\t\t\t\t\tviewsMono = resolveViews(returnValue.toString(), locale);\n\t\t\t\t\t}\n\t\t\t\t\telse if (Rendering.class.isAssignableFrom(clazz)) {\n\t\t\t\t\t\tRendering render = (Rendering) returnValue;\n\t\t\t\t\t\tHttpStatusCode status = render.status();\n\t\t\t\t\t\tif (status != null) {\n\t\t\t\t\t\t\texchange.getResponse().setStatusCode(status);\n\t\t\t\t\t\t}\n\t\t\t\t\t\texchange.getResponse().getHeaders().putAll(render.headers());\n\t\t\t\t\t\tmodel.addAllAttributes(render.modelAttributes());\n\t\t\t\t\t\tObject view = render.view();\n\t\t\t\t\t\tif (view == null) {\n\t\t\t\t\t\t\tview = getDefaultViewName(exchange);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tviewsMono = (view instanceof String viewName ? resolveViews(viewName, locale) :\n\t\t\t\t\t\t\t\tMono.just(Collections.singletonList((View) view)));\n\t\t\t\t\t}\n\t\t\t\t\telse if (Model.class.isAssignableFrom(clazz)) {\n\t\t\t\t\t\tmodel.addAllAttributes(((Model) returnValue).asMap());\n\t\t\t\t\t\tviewsMono = resolveViews(getDefaultViewName(exchange), locale);\n\t\t\t\t\t}\n\t\t\t\t\telse if (Map.class.isAssignableFrom(clazz) && !hasModelAnnotation(parameter)) {\n\t\t\t\t\t\tmodel.addAllAttributes((Map<String, ?>) returnValue);\n\t\t\t\t\t\tviewsMono = resolveViews(getDefaultViewName(exchange), locale);\n\t\t\t\t\t}\n\t\t\t\t\telse if (View.class.isAssignableFrom(clazz)) {\n\t\t\t\t\t\tviewsMono = Mono.just(Collections.singletonList((View) returnValue));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tString name = getNameForReturnValue(parameter);\n\t\t\t\t\t\tmodel.addAttribute(name, returnValue);\n\t\t\t\t\t\tviewsMono = resolveViews(getDefaultViewName(exchange), locale);\n\t\t\t\t\t}\n\t\t\t\t\tBindingContext bindingContext = result.getBindingContext();\n\t\t\t\t\tupdateBindingResult(bindingContext, exchange);\n\t\t\t\t\treturn viewsMono.flatMap(views -> render(views, model.asMap(), bindingContext, exchange));\n\t\t\t\t});\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#resolveViewName(viewName,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "Mono<View>",
    "signature": "public Mono<View> resolveViewName(String viewName, Locale locale)",
    "source_code": "\tpublic Mono<View> resolveViewName(String viewName, Locale locale) {\n\t\tif (!canHandle(viewName, locale)) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tAbstractUrlBasedView urlBasedView;\n\t\tif (viewName.startsWith(REDIRECT_URL_PREFIX)) {\n\t\t\tString redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length());\n\t\t\turlBasedView = this.redirectViewProvider.apply(redirectUrl);\n\t\t}\n\t\telse {\n\t\t\turlBasedView = createView(viewName);\n\t\t}\n\n\t\tView view = applyLifecycleMethods(viewName, urlBasedView);\n\t\ttry {\n\t\t\treturn (urlBasedView.checkResourceExists(locale) ? Mono.just(view) : Mono.empty());\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#setRedirectViewProvider(Function<String,redirectViewProvider)": {
    "deprecated": false,
    "doc": "\t/**\n\t * URL based {@link RedirectView} provider which can be used to provide, for example,\n\t * redirect views with a custom default status code.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<String",
      "redirectViewProvider"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "public void setRedirectViewProvider(Function<String, RedirectView> redirectViewProvider)",
    "source_code": "\tpublic void setRedirectViewProvider(Function<String, RedirectView> redirectViewProvider) {\n\t\tthis.redirectViewProvider = redirectViewProvider;\n\t}"
  },
  "org.springframework.web.reactive.socket.<unknown>#create(code,reason)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a constant for the given code, or create a new instance if the\n\t * code does not match or there is a reason.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "reason"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "CloseStatus",
    "signature": "public CloseStatus create(int code, @Nullable String reason)",
    "source_code": "\tpublic static CloseStatus create(int code, @Nullable String reason) {\n\t\tif (!StringUtils.hasText(reason)) {\n\t\t\treturn switch (code) {\n\t\t\t\tcase 1000 -> NORMAL;\n\t\t\t\tcase 1001 -> GOING_AWAY;\n\t\t\t\tcase 1002 -> PROTOCOL_ERROR;\n\t\t\t\tcase 1003 -> NOT_ACCEPTABLE;\n\t\t\t\tcase 1005 -> NO_STATUS_CODE;\n\t\t\t\tcase 1006 -> NO_CLOSE_FRAME;\n\t\t\t\tcase 1007 -> BAD_DATA;\n\t\t\t\tcase 1008 -> POLICY_VIOLATION;\n\t\t\t\tcase 1009 -> TOO_BIG_TO_PROCESS;\n\t\t\t\tcase 1010 -> REQUIRED_EXTENSION;\n\t\t\t\tcase 1011 -> SERVER_ERROR;\n\t\t\t\tcase 1012 -> SERVICE_RESTARTED;\n\t\t\t\tcase 1013 -> SERVICE_OVERLOAD;\n\t\t\t\tdefault -> new CloseStatus(code, reason);\n\t\t\t};\n\t\t}\n\t\treturn new CloseStatus(code, reason);\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#complete(channel,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channel",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void complete(WebSocketChannel channel, Void context)",
    "source_code": "\t\tpublic void complete(WebSocketChannel channel, Void context) {\n\t\t\tDataBufferUtils.release(this.payload);\n\t\t\tgetSendProcessor().setReadyToSend(true);\n\t\t\tgetSendProcessor().onWritePossible();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#onClose(session,reason)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "reason"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void onClose(Session session, CloseReason reason)",
    "source_code": "\tpublic void onClose(Session session, CloseReason reason) {\n\t\tif (this.delegateSession != null) {\n\t\t\tint code = reason.getCloseCode().getCode();\n\t\t\tthis.delegateSession.handleClose(CloseStatus.create(code, reason.getReasonPhrase()));\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#onError(channel,context,throwable)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channel",
      "context",
      "throwable"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void onError(WebSocketChannel channel, Void context, Throwable throwable)",
    "source_code": "\t\tpublic void onError(WebSocketChannel channel, Void context, Throwable throwable) {\n\t\t\tDataBufferUtils.release(this.payload);\n\t\t\tgetSendProcessor().cancel();\n\t\t\tgetSendProcessor().onError(throwable);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#onError(session,exception)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void onError(Session session, Throwable exception)",
    "source_code": "\tpublic void onError(Session session, Throwable exception) {\n\t\tif (this.delegateSession != null) {\n\t\t\tthis.delegateSession.handleError(exception);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#onOpen(session,config)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "config"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "void",
    "signature": "public void onOpen(Session session, EndpointConfig config)",
    "source_code": "\tpublic void onOpen(Session session, EndpointConfig config) {\n\t\tthis.delegateSession = this.sessionFactory.apply(session);\n\t\tAssert.state(this.delegateSession != null, \"No delegate session\");\n\n\t\tsession.addMessageHandler(String.class, message -> {\n\t\t\tWebSocketMessage webSocketMessage = toMessage(message);\n\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t});\n\t\tsession.addMessageHandler(ByteBuffer.class, message -> {\n\t\t\tWebSocketMessage webSocketMessage = toMessage(message);\n\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t});\n\t\tsession.addMessageHandler(PongMessage.class, message -> {\n\t\t\tWebSocketMessage webSocketMessage = toMessage(message);\n\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t});\n\n\t\tthis.delegateHandler.handle(this.delegateSession)\n\t\t\t\t.checkpoint(session.getRequestURI() + \" [StandardWebSocketHandlerAdapter]\")\n\t\t\t\t.subscribe(this.delegateSession);\n\t}"
  },
  "org.springframework.web.reactive.socket.server.support.<unknown>#handleRequest(exchange,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> handleRequest(ServerWebExchange exchange, WebSocketHandler handler)",
    "source_code": "\tpublic Mono<Void> handleRequest(ServerWebExchange exchange, WebSocketHandler handler) {\n\t\tServerHttpRequest request = exchange.getRequest();\n\t\tHttpMethod method = request.getMethod();\n\t\tHttpHeaders headers = request.getHeaders();\n\n\t\tif (HttpMethod.GET != method) {\n\t\t\treturn Mono.error(new MethodNotAllowedException(\n\t\t\t\t\trequest.getMethod(), Collections.singleton(HttpMethod.GET)));\n\t\t}\n\n\t\tif (!\"WebSocket\".equalsIgnoreCase(headers.getUpgrade())) {\n\t\t\treturn handleBadRequest(exchange, \"Invalid 'Upgrade' header: \" + headers);\n\t\t}\n\n\t\tList<String> connectionValue = headers.getConnection();\n\t\tif (!connectionValue.contains(\"Upgrade\") && !connectionValue.contains(\"upgrade\")) {\n\t\t\treturn handleBadRequest(exchange, \"Invalid 'Connection' header: \" + headers);\n\t\t}\n\n\t\tString key = headers.getFirst(SEC_WEBSOCKET_KEY);\n\t\tif (key == null) {\n\t\t\treturn handleBadRequest(exchange, \"Missing \\\"Sec-WebSocket-Key\\\" header\");\n\t\t}\n\n\t\tString protocol = selectProtocol(headers, handler);\n\n\t\treturn initAttributes(exchange).flatMap(attributes ->\n\t\t\t\tthis.upgradeStrategy.upgrade(exchange, handler, protocol,\n\t\t\t\t\t\t() -> createHandshakeInfo(exchange, request, protocol, attributes))\n\t\t);\n\t}"
  },
  "org.springframework.web.server.adapter.<unknown>#httpHandlerDecorator(Function<HttpHandler,handlerDecorator)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link Function} to decorate the {@link HttpHandler} returned\n\t * by this builder which effectively wraps the entire\n\t * {@link WebExceptionHandler} - {@link WebFilter} - {@link WebHandler}\n\t * processing chain. This provides access to the request and response before\n\t * the entire chain and likewise the ability to observe the result of\n\t * the entire chain.\n\t * @param handlerDecorator the decorator to apply\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<HttpHandler",
      "handlerDecorator"
    ],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder httpHandlerDecorator(Function<HttpHandler, HttpHandler> handlerDecorator)",
    "source_code": "\tpublic WebHttpHandlerBuilder httpHandlerDecorator(Function<HttpHandler, HttpHandler> handlerDecorator) {\n\t\tthis.httpHandlerDecorator = (this.httpHandlerDecorator != null ?\n\t\t\t\thandlerDecorator.andThen(this.httpHandlerDecorator) : handlerDecorator);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.<unknown>#registerCloseListener(servletContext,applicationContext)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a {@link ServletContextListener} that closes the given\n\t * application context when the servlet context is destroyed.\n\t * @param servletContext the servlet context to listen to\n\t * @param applicationContext the application context that is to be\n\t * closed when {@code servletContext} is destroyed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "servletContext",
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "protected void registerCloseListener(ServletContext servletContext, ApplicationContext applicationContext)",
    "source_code": "\tprotected void registerCloseListener(ServletContext servletContext, ApplicationContext applicationContext) {\n\t\tif (applicationContext instanceof ConfigurableApplicationContext cac) {\n\t\t\tservletContext.addListener(new ServletContextDestroyedListener(cac));\n\t\t}\n\t}"
  },
  "org.springframework.web.server.handler.<unknown>#handle(exchange,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> handle(ServerWebExchange exchange, Throwable ex)",
    "source_code": "\tpublic Mono<Void> handle(ServerWebExchange exchange, Throwable ex) {\n\t\tif (!updateResponse(exchange.getResponse(), ex)) {\n\t\t\treturn Mono.error(ex);\n\t\t}\n\n\t\t// Mirrors AbstractHandlerExceptionResolver in spring-webmvc...\n\t\tString logPrefix = exchange.getLogPrefix();\n\t\tif (this.warnLogger != null && this.warnLogger.isWarnEnabled()) {\n\t\t\tthis.warnLogger.warn(logPrefix + formatError(ex, exchange.getRequest()));\n\t\t}\n\t\telse if (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(logPrefix + formatError(ex, exchange.getRequest()));\n\t\t}\n\n\t\treturn exchange.getResponse().setComplete();\n\t}"
  },
  "org.springframework.web.service.annotation.<unknown>#registerMethodHints(hints,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "void",
    "signature": "protected void registerMethodHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerMethodHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tfor (Parameter parameter : method.getParameters()) {\n\t\t\tregisterParameterTypeHints(hints, MethodParameter.forParameter(parameter));\n\t\t}\n\t\tregisterReturnTypeHints(hints, MethodParameter.forExecutable(method, -1));\n\t}"
  },
  "org.springframework.web.service.annotation.<unknown>#registerParameterTypeHints(hints,methodParameter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "methodParameter"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "protected void registerParameterTypeHints(ReflectionHints hints, MethodParameter methodParameter)",
    "source_code": "\tprotected void registerParameterTypeHints(ReflectionHints hints, MethodParameter methodParameter) {\n\t\tif (methodParameter.hasParameterAnnotation(RequestBody.class)) {\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, methodParameter.getGenericParameterType());\n\t\t}\n\t}"
  },
  "org.springframework.web.service.annotation.<unknown>#registerReflectionHints(hints,element)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "return": "void",
    "signature": "public void registerReflectionHints(ReflectionHints hints, AnnotatedElement element)",
    "source_code": "\tpublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tif (element instanceof Method method) {\n\t\t\tregisterMethodHints(hints, method);\n\t\t}\n\t}"
  },
  "org.springframework.web.service.annotation.<unknown>#registerReturnTypeHints(hints,returnTypeParameter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "returnTypeParameter"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "protected void registerReturnTypeHints(ReflectionHints hints, MethodParameter returnTypeParameter)",
    "source_code": "\tprotected void registerReturnTypeHints(ReflectionHints hints, MethodParameter returnTypeParameter) {\n\t\tif (!void.class.equals(returnTypeParameter.getParameterType())) {\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, returnTypeParameter.getGenericParameterType());\n\t\t}\n\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#addRequestValue(name,value,parameter,requestValues)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given, single request value. This may be called multiples times\n\t * if the request value is multivalued.\n\t * <p>If the resolver was created with a {@link ConversionService}, the value\n\t * will have been converted to a String and may be cast down.\n\t * @param name the request value name\n\t * @param value the value\n\t * @param parameter the method parameter type, nested if Map, List/array, or Optional\n\t * @param requestValues builder to add the request value to\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "value",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "protected void addRequestValue(String name, Object value, MethodParameter parameter, HttpRequestValues.Builder requestValues)",
    "source_code": "\tprotected abstract void addRequestValue(\n\t\t\tString name, Object value, MethodParameter parameter, HttpRequestValues.Builder requestValues);\n\n\n\t/**\n\t * Info about a request value, typically extracted from a method parameter annotation.\n\t */\n\tprotected static class NamedValueInfo {\n\n\t\tprivate final String name;\n\n\t\tprivate final boolean required;\n\n\t\t@Nullable\n\t\tprivate final String defaultValue;\n\n\t\tprivate final String label;\n\n\t\tprivate final boolean multiValued;\n\n\t\t/**\n\t\t * Create an instance.\n\t\t * @param name the name to use, possibly empty if not specified\n\t\t * @param required whether it is marked as required\n\t\t * @param defaultValue fallback value, possibly {@link ValueConstants#DEFAULT_NONE}\n\t\t * @param label how it should appear in error messages, e.g. \"path variable\", \"request header\"\n\t\t */\n\t\tpublic NamedValueInfo(\n\t\t\t\tString name, boolean required, @Nullable String defaultValue, String label, boolean multiValued) {\n\n\t\t\tthis.name = name;\n\t\t\tthis.required = required;\n\t\t\tthis.defaultValue = defaultValue;\n\t\t\tthis.label = label;\n\t\t\tthis.multiValued = multiValued;\n\t\t}\n\n\t\tpublic NamedValueInfo update(String name, boolean required, @Nullable String defaultValue) {\n\t\t\treturn new NamedValueInfo(name, required, defaultValue, this.label, this.multiValued);\n\t\t}\n\n\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#create(client,method,reactiveRegistry,blockTimeout)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method's return type.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "client",
      "method",
      "reactiveRegistry",
      "blockTimeout"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "ResponseFunction",
    "signature": "public ResponseFunction create(HttpClientAdapter client, Method method, ReactiveAdapterRegistry reactiveRegistry,\n\t\t\t\tDuration blockTimeout)",
    "source_code": "\t\tpublic static ResponseFunction create(\n\t\t\t\tHttpClientAdapter client, Method method, ReactiveAdapterRegistry reactiveRegistry,\n\t\t\t\tDuration blockTimeout) {\n\n\t\t\tMethodParameter returnParam = new MethodParameter(method, -1);\n\t\t\tClass<?> returnType = returnParam.getParameterType();\n\t\t\tif (KotlinDetector.isSuspendingFunction(method)) {\n\t\t\t\treturnType = Mono.class;\n\t\t\t}\n\n\t\t\tReactiveAdapter reactiveAdapter = reactiveRegistry.getAdapter(returnType);\n\n\t\t\tMethodParameter actualParam = (reactiveAdapter != null ? returnParam.nested() : returnParam.nestedIfOptional());\n\t\t\tClass<?> actualType = actualParam.getNestedParameterType();\n\n\t\t\tFunction<HttpRequestValues, Publisher<?>> responseFunction;\n\t\t\tif (actualType.equals(void.class) || actualType.equals(Void.class)) {\n\t\t\t\tresponseFunction = client::requestToVoid;\n\t\t\t}\n\t\t\telse if (reactiveAdapter != null && reactiveAdapter.isNoValue()) {\n\t\t\t\tresponseFunction = client::requestToVoid;\n\t\t\t}\n\t\t\telse if (actualType.equals(HttpHeaders.class)) {\n\t\t\t\tresponseFunction = client::requestToHeaders;\n\t\t\t}\n\t\t\telse if (actualType.equals(ResponseEntity.class)) {\n\t\t\t\tMethodParameter bodyParam = actualParam.nested();\n\t\t\t\tClass<?> bodyType = bodyParam.getNestedParameterType();\n\t\t\t\tif (bodyType.equals(Void.class)) {\n\t\t\t\t\tresponseFunction = client::requestToBodilessEntity;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tReactiveAdapter bodyAdapter = reactiveRegistry.getAdapter(bodyType);\n\t\t\t\t\tresponseFunction = initResponseEntityFunction(client, bodyParam, bodyAdapter);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponseFunction = initBodyFunction(client, actualParam, reactiveAdapter);\n\t\t\t}\n\n\t\t\tboolean blockForOptional = returnType.equals(Optional.class);\n\t\t\treturn new ResponseFunction(responseFunction, reactiveAdapter, blockForOptional, blockTimeout);\n\t\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#create(method,containingClass,embeddedValueResolver)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Introspect the method and create the request factory for it.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "containingClass",
      "embeddedValueResolver"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "HttpRequestValuesInitializer",
    "signature": "public HttpRequestValuesInitializer create(Method method, Class<?> containingClass, @Nullable StringValueResolver embeddedValueResolver)",
    "source_code": "\t\tpublic static HttpRequestValuesInitializer create(\n\t\t\t\tMethod method, Class<?> containingClass, @Nullable StringValueResolver embeddedValueResolver) {\n\n\t\t\tHttpExchange annot1 = AnnotatedElementUtils.findMergedAnnotation(containingClass, HttpExchange.class);\n\t\t\tHttpExchange annot2 = AnnotatedElementUtils.findMergedAnnotation(method, HttpExchange.class);\n\n\t\t\tAssert.notNull(annot2, \"Expected HttpRequest annotation\");\n\n\t\t\tHttpMethod httpMethod = initHttpMethod(annot1, annot2);\n\t\t\tString url = initUrl(annot1, annot2, embeddedValueResolver);\n\t\t\tMediaType contentType = initContentType(annot1, annot2);\n\t\t\tList<MediaType> acceptableMediaTypes = initAccept(annot1, annot2);\n\n\t\t\treturn new HttpRequestValuesInitializer(httpMethod, url, contentType, acceptableMediaTypes);\n\t\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#invokeSuspendingFunction(invocation,httpServiceMethod)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invocation",
      "httpServiceMethod"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "Object",
    "signature": "public Object invokeSuspendingFunction(MethodInvocation invocation, HttpServiceMethod httpServiceMethod)",
    "source_code": "\t\tpublic static Object invokeSuspendingFunction(MethodInvocation invocation, HttpServiceMethod httpServiceMethod) {\n\t\t\tObject[] rawArguments = invocation.getArguments();\n\t\t\tObject[] arguments = resolveArguments(rawArguments);\n\t\t\tContinuation<Object> continuation = (Continuation<Object>) rawArguments[rawArguments.length - 1];\n\t\t\tMono<Object> wrapped = (Mono<Object>) httpServiceMethod.invoke(arguments);\n\t\t\treturn MonoKt.awaitSingleOrNull(wrapped, continuation);\n\t\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#resolve(argument,parameter,requestValues)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argument",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "boolean",
    "signature": "public boolean resolve(@Nullable Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues)",
    "source_code": "\tpublic boolean resolve(\n\t\t\t@Nullable Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues) {\n\n\t\tNamedValueInfo info = getNamedValueInfo(parameter);\n\t\tif (info == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (Map.class.isAssignableFrom(parameter.getParameterType())) {\n\t\t\tAssert.isInstanceOf(Map.class, argument);\n\t\t\tparameter = parameter.nested(1);\n\t\t\targument = (argument != null ? argument : Collections.emptyMap());\n\t\t\tfor (Map.Entry<String, ?> entry : ((Map<String, ?>) argument).entrySet()) {\n\t\t\t\taddSingleOrMultipleValues(\n\t\t\t\t\t\tentry.getKey(), entry.getValue(), false, null, info.label, info.multiValued,\n\t\t\t\t\t\tparameter, requestValues);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\taddSingleOrMultipleValues(\n\t\t\t\t\tinfo.name, argument, info.required, info.defaultValue, info.label, info.multiValued,\n\t\t\t\t\tparameter, requestValues);\n\t\t}\n\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#update(name,required,defaultValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "required",
      "defaultValue"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "NamedValueInfo",
    "signature": "public NamedValueInfo update(String name, boolean required, @Nullable String defaultValue)",
    "source_code": "\t\tpublic NamedValueInfo update(String name, boolean required, @Nullable String defaultValue) {\n\t\t\treturn new NamedValueInfo(name, required, defaultValue, this.label, this.multiValued);\n\t\t}"
  },
  "org.springframework.web.servlet.<unknown>#addInterceptor(index,interceptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given interceptor at the specified index of this chain.\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "interceptor"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "void",
    "signature": "public void addInterceptor(int index, HandlerInterceptor interceptor)",
    "source_code": "\tpublic void addInterceptor(int index, HandlerInterceptor interceptor) {\n\t\tthis.interceptorList.add(index, interceptor);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#addTargetRequestParam(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a request parameter identifying the request for this FlashMap.\n\t * @param name the expected parameter name (skipped if empty)\n\t * @param value the expected value (skipped if empty)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "FlashMap",
    "signature": "public FlashMap addTargetRequestParam(String name, String value)",
    "source_code": "\tpublic FlashMap addTargetRequestParam(String name, String value) {\n\t\tif (StringUtils.hasText(name) && StringUtils.hasText(value)) {\n\t\t\tthis.targetRequestParams.add(name, value);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#addTargetRequestParams(MultiValueMap<String,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Provide request parameters identifying the request for this FlashMap.\n\t * @param params a Map with the names and values of expected parameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "FlashMap",
    "signature": "public FlashMap addTargetRequestParams(@Nullable MultiValueMap<String, String> params)",
    "source_code": "\tpublic FlashMap addTargetRequestParams(@Nullable MultiValueMap<String, String> params) {\n\t\tif (params != null) {\n\t\t\tparams.forEach((key, values) -> {\n\t\t\t\tfor (String value : values) {\n\t\t\t\t\taddTargetRequestParam(key, value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#buildRequestAttributes(request,response,previousAttributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Build ServletRequestAttributes for the given request (potentially also\n\t * holding a reference to the response), taking pre-bound attributes\n\t * (and their type) into consideration.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param previousAttributes pre-bound RequestAttributes instance, if any\n\t * @return the ServletRequestAttributes to bind, or {@code null} to preserve\n\t * the previously bound instance (or not binding any, if none bound before)\n\t * @see RequestContextHolder#setRequestAttributes\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "previousAttributes"
    ],
    "position": {
      "column": 1,
      "line": 1056
    },
    "return": "ServletRequestAttributes",
    "signature": "protected ServletRequestAttributes buildRequestAttributes(HttpServletRequest request,\n\t\t\t@Nullable HttpServletResponse response, @Nullable RequestAttributes previousAttributes)",
    "source_code": "\tprotected ServletRequestAttributes buildRequestAttributes(HttpServletRequest request,\n\t\t\t@Nullable HttpServletResponse response, @Nullable RequestAttributes previousAttributes) {\n\n\t\tif (previousAttributes == null || previousAttributes instanceof ServletRequestAttributes) {\n\t\t\treturn new ServletRequestAttributes(request, response);\n\t\t}\n\t\telse {\n\t\t\treturn null;  // preserve the pre-bound RequestAttributes instance\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doDelete(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate DELETE requests to {@link #processRequest}.\n\t * @see #doService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 933
    },
    "return": "void",
    "signature": "protected void doDelete(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected final void doDelete(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tprocessRequest(request, response);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doGet(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate GET requests to processRequest/doService.\n\t * <p>Will also be invoked by HttpServlet's default implementation of {@code doHead},\n\t * with a {@code NoBodyResponse} that just captures the content length.\n\t * @see #doService\n\t * @see #doHead\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 900
    },
    "return": "void",
    "signature": "protected void doGet(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected final void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tprocessRequest(request, response);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doOptions(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate OPTIONS requests to {@link #processRequest}, if desired.\n\t * <p>Applies HttpServlet's standard OPTIONS processing otherwise,\n\t * and also if there is still no 'Allow' header set after dispatching.\n\t * @see #doService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 946
    },
    "return": "void",
    "signature": "protected void doOptions(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void doOptions(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (this.dispatchOptionsRequest || CorsUtils.isPreFlightRequest(request)) {\n\t\t\tprocessRequest(request, response);\n\t\t\tif (response.containsHeader(HttpHeaders.ALLOW)) {\n\t\t\t\t// Proper OPTIONS response coming from a handler - we're done.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Use response wrapper in order to always add PATCH to the allowed methods\n\t\tsuper.doOptions(request, new HttpServletResponseWrapper(response) {\n\t\t\t@Override\n\t\t\tpublic void setHeader(String name, String value) {\n\t\t\t\tif (HttpHeaders.ALLOW.equals(name)) {\n\t\t\t\t\tvalue = (StringUtils.hasLength(value) ? value + \", \" : \"\") + HttpMethod.PATCH.name();\n\t\t\t\t}\n\t\t\t\tsuper.setHeader(name, value);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doPost(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate POST requests to {@link #processRequest}.\n\t * @see #doService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 911
    },
    "return": "void",
    "signature": "protected void doPost(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected final void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tprocessRequest(request, response);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doPut(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate PUT requests to {@link #processRequest}.\n\t * @see #doService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 922
    },
    "return": "void",
    "signature": "protected void doPut(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected final void doPut(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tprocessRequest(request, response);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doService(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses must implement this method to do the work of request handling,\n\t * receiving a centralized callback for GET, POST, PUT and DELETE.\n\t * <p>The contract is essentially the same as that for the commonly overridden\n\t * {@code doGet} or {@code doPost} methods of HttpServlet.\n\t * <p>This class intercepts calls to ensure that exception handling and\n\t * event publication takes place.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @throws Exception in case of any kind of processing failure\n\t * @see jakarta.servlet.http.HttpServlet#doGet\n\t * @see jakarta.servlet.http.HttpServlet#doPost\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 1182
    },
    "return": "void",
    "signature": "protected void doService(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected abstract void doService(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception;\n\n\n\t/**\n\t * ApplicationListener endpoint that receives events from this servlet's WebApplicationContext\n\t * only, delegating to {@code onApplicationEvent} on the FrameworkServlet instance."
  },
  "org.springframework.web.servlet.<unknown>#doTrace(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate TRACE requests to {@link #processRequest}, if desired.\n\t * <p>Applies HttpServlet's standard TRACE processing otherwise.\n\t * @see #doService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 975
    },
    "return": "void",
    "signature": "protected void doTrace(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void doTrace(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (this.dispatchTraceRequest) {\n\t\t\tprocessRequest(request, response);\n\t\t\tif (\"message/http\".equals(response.getContentType())) {\n\t\t\t\t// Proper TRACE response coming from a handler - we're done.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tsuper.doTrace(request, response);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#postProcess(webRequest,task,concurrentResult)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "task",
      "concurrentResult"
    ],
    "position": {
      "column": 1,
      "line": 1215
    },
    "return": "void",
    "signature": "public void postProcess(NativeWebRequest webRequest, Callable<T> task, Object concurrentResult)",
    "source_code": "\t\tpublic <T> void postProcess(NativeWebRequest webRequest, Callable<T> task, Object concurrentResult) {\n\t\t\tHttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);\n\t\t\tif (request != null) {\n\t\t\t\tresetContextHolders(request, null, null);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.<unknown>#preProcess(webRequest,task)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 1206
    },
    "return": "void",
    "signature": "public void preProcess(NativeWebRequest webRequest, Callable<T> task)",
    "source_code": "\t\tpublic <T> void preProcess(NativeWebRequest webRequest, Callable<T> task) {\n\t\t\tHttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);\n\t\t\tif (request != null) {\n\t\t\t\tHttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);\n\t\t\t\tinitContextHolders(request, buildLocaleContext(request),\n\t\t\t\t\t\tbuildRequestAttributes(request, response, null));\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.<unknown>#processRequest(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Process this request, publishing an event regardless of the outcome.\n\t * <p>The actual event handling is performed by the abstract\n\t * {@link #doService} template method.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 993
    },
    "return": "void",
    "signature": "protected void processRequest(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected final void processRequest(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tlong startTime = System.currentTimeMillis();\n\t\tThrowable failureCause = null;\n\n\t\tLocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();\n\t\tLocaleContext localeContext = buildLocaleContext(request);\n\n\t\tRequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();\n\t\tServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);\n\n\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\t\tasyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());\n\n\t\tinitContextHolders(request, localeContext, requestAttributes);\n\n\t\ttry {\n\t\t\tdoService(request, response);\n\t\t}\n\t\tcatch (ServletException | IOException ex) {\n\t\t\tfailureCause = ex;\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tfailureCause = ex;\n\t\t\tthrow new ServletException(\"Request processing failed: \" + ex, ex);\n\t\t}\n\n\t\tfinally {\n\t\t\tresetContextHolders(request, previousLocaleContext, previousAttributes);\n\t\t\tif (requestAttributes != null) {\n\t\t\t\trequestAttributes.requestCompleted();\n\t\t\t}\n\t\t\tlogResult(request, response, failureCause, asyncManager);\n\t\t\tpublishRequestHandledEvent(request, response, startTime, failureCause);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#service(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Override the parent class implementation in order to intercept requests\n\t * using PATCH or non-standard HTTP methods (WebDAV).\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 881
    },
    "return": "void",
    "signature": "protected void service(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void service(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (HTTP_SERVLET_METHODS.contains(request.getMethod())) {\n\t\t\tsuper.service(request, response);\n\t\t}\n\t\telse {\n\t\t\tprocessRequest(request, response);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#setHeader(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 960
    },
    "return": "void",
    "signature": "public void setHeader(String name, String value)",
    "source_code": "\t\t\tpublic void setHeader(String name, String value) {\n\t\t\t\tif (HttpHeaders.ALLOW.equals(name)) {\n\t\t\t\t\tvalue = (StringUtils.hasLength(value) ? value + \", \" : \"\") + HttpMethod.PATCH.name();\n\t\t\t\t}\n\t\t\t\tsuper.setHeader(name, value);\n\t\t\t}"
  },
  "org.springframework.web.servlet.config.<unknown>#parse(element,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "BeanDefinition",
    "signature": "public BeanDefinition parse(Element element, ParserContext context)",
    "source_code": "\tpublic BeanDefinition parse(Element element, ParserContext context) {\n\t\tObject source = context.extractSource(element);\n\t\tXmlReaderContext readerContext = context.getReaderContext();\n\n\t\tCompositeComponentDefinition compDefinition = new CompositeComponentDefinition(element.getTagName(), source);\n\t\tcontext.pushContainingComponent(compDefinition);\n\n\t\tRuntimeBeanReference contentNegotiationManager = getContentNegotiationManager(element, source, context);\n\n\t\tRootBeanDefinition handlerMappingDef = new RootBeanDefinition(RequestMappingHandlerMapping.class);\n\t\thandlerMappingDef.setSource(source);\n\t\thandlerMappingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\thandlerMappingDef.getPropertyValues().add(\"order\", 0);\n\t\thandlerMappingDef.getPropertyValues().add(\"contentNegotiationManager\", contentNegotiationManager);\n\n\t\tif (element.hasAttribute(\"enable-matrix-variables\")) {\n\t\t\tboolean enableMatrixVariables = Boolean.parseBoolean(element.getAttribute(\"enable-matrix-variables\"));\n\t\t\thandlerMappingDef.getPropertyValues().add(\"removeSemicolonContent\", !enableMatrixVariables);\n\t\t}\n\n\t\tconfigurePathMatchingProperties(handlerMappingDef, element, context);\n\t\treaderContext.getRegistry().registerBeanDefinition(HANDLER_MAPPING_BEAN_NAME, handlerMappingDef);\n\n\t\tRuntimeBeanReference corsRef = MvcNamespaceUtils.registerCorsConfigurations(null, context, source);\n\t\thandlerMappingDef.getPropertyValues().add(\"corsConfigurations\", corsRef);\n\n\t\tRuntimeBeanReference conversionService = getConversionService(element, source, context);\n\t\tRuntimeBeanReference validator = getValidator(element, source, context);\n\t\tRuntimeBeanReference messageCodesResolver = getMessageCodesResolver(element);\n\n\t\tRootBeanDefinition bindingDef = new RootBeanDefinition(ConfigurableWebBindingInitializer.class);\n\t\tbindingDef.setSource(source);\n\t\tbindingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tbindingDef.getPropertyValues().add(\"conversionService\", conversionService);\n\t\tbindingDef.getPropertyValues().add(\"validator\", validator);\n\t\tbindingDef.getPropertyValues().add(\"messageCodesResolver\", messageCodesResolver);\n\n\t\tManagedList<?> messageConverters = getMessageConverters(element, source, context);\n\t\tManagedList<?> argumentResolvers = getArgumentResolvers(element, context);\n\t\tManagedList<?> returnValueHandlers = getReturnValueHandlers(element, context);\n\t\tString asyncTimeout = getAsyncTimeout(element);\n\t\tRuntimeBeanReference asyncExecutor = getAsyncExecutor(element);\n\t\tManagedList<?> callableInterceptors = getInterceptors(element, source, context, \"callable-interceptors\");\n\t\tManagedList<?> deferredResultInterceptors = getInterceptors(element, source, context, \"deferred-result-interceptors\");\n\n\t\tRootBeanDefinition handlerAdapterDef = new RootBeanDefinition(RequestMappingHandlerAdapter.class);\n\t\thandlerAdapterDef.setSource(source);\n\t\thandlerAdapterDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\thandlerAdapterDef.getPropertyValues().add(\"contentNegotiationManager\", contentNegotiationManager);\n\t\thandlerAdapterDef.getPropertyValues().add(\"webBindingInitializer\", bindingDef);\n\t\thandlerAdapterDef.getPropertyValues().add(\"messageConverters\", messageConverters);\n\t\taddRequestBodyAdvice(handlerAdapterDef);\n\t\taddResponseBodyAdvice(handlerAdapterDef);\n\n\t\tif (element.hasAttribute(\"ignore-default-model-on-redirect\")) {\n\t\t\tBoolean ignoreDefaultModel = Boolean.valueOf(element.getAttribute(\"ignore-default-model-on-redirect\"));\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"ignoreDefaultModelOnRedirect\", ignoreDefaultModel);\n\t\t}\n\t\tif (argumentResolvers != null) {\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"customArgumentResolvers\", argumentResolvers);\n\t\t}\n\t\tif (returnValueHandlers != null) {\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"customReturnValueHandlers\", returnValueHandlers);\n\t\t}\n\t\tif (asyncTimeout != null) {\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"asyncRequestTimeout\", asyncTimeout);\n\t\t}\n\t\tif (asyncExecutor != null) {\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"taskExecutor\", asyncExecutor);\n\t\t}\n\n\t\thandlerAdapterDef.getPropertyValues().add(\"callableInterceptors\", callableInterceptors);\n\t\thandlerAdapterDef.getPropertyValues().add(\"deferredResultInterceptors\", deferredResultInterceptors);\n\t\treaderContext.getRegistry().registerBeanDefinition(HANDLER_ADAPTER_BEAN_NAME, handlerAdapterDef);\n\n\t\tRootBeanDefinition uriContributorDef =\n\t\t\t\tnew RootBeanDefinition(CompositeUriComponentsContributorFactoryBean.class);\n\t\turiContributorDef.setSource(source);\n\t\turiContributorDef.getPropertyValues().addPropertyValue(\"handlerAdapter\", handlerAdapterDef);\n\t\turiContributorDef.getPropertyValues().addPropertyValue(\"conversionService\", conversionService);\n\t\tString uriContributorName = MvcUriComponentsBuilder.MVC_URI_COMPONENTS_CONTRIBUTOR_BEAN_NAME;\n\t\treaderContext.getRegistry().registerBeanDefinition(uriContributorName, uriContributorDef);\n\n\t\tRootBeanDefinition csInterceptorDef = new RootBeanDefinition(ConversionServiceExposingInterceptor.class);\n\t\tcsInterceptorDef.setSource(source);\n\t\tcsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, conversionService);\n\t\tRootBeanDefinition mappedInterceptorDef = new RootBeanDefinition(MappedInterceptor.class);\n\t\tmappedInterceptorDef.setSource(source);\n\t\tmappedInterceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tmappedInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, (Object) null);\n\t\tmappedInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(1, csInterceptorDef);\n\t\tString mappedInterceptorName = readerContext.registerWithGeneratedName(mappedInterceptorDef);\n\n\t\tRootBeanDefinition methodExceptionResolver = new RootBeanDefinition(ExceptionHandlerExceptionResolver.class);\n\t\tmethodExceptionResolver.setSource(source);\n\t\tmethodExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tmethodExceptionResolver.getPropertyValues().add(\"contentNegotiationManager\", contentNegotiationManager);\n\t\tmethodExceptionResolver.getPropertyValues().add(\"messageConverters\", messageConverters);\n\t\tmethodExceptionResolver.getPropertyValues().add(\"order\", 0);\n\t\taddResponseBodyAdvice(methodExceptionResolver);\n\t\tif (argumentResolvers != null) {\n\t\t\tmethodExceptionResolver.getPropertyValues().add(\"customArgumentResolvers\", argumentResolvers);\n\t\t}\n\t\tif (returnValueHandlers != null) {\n\t\t\tmethodExceptionResolver.getPropertyValues().add(\"customReturnValueHandlers\", returnValueHandlers);\n\t\t}\n\t\tString methodExResolverName = readerContext.registerWithGeneratedName(methodExceptionResolver);\n\n\t\tRootBeanDefinition statusExceptionResolver = new RootBeanDefinition(ResponseStatusExceptionResolver.class);\n\t\tstatusExceptionResolver.setSource(source);\n\t\tstatusExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tstatusExceptionResolver.getPropertyValues().add(\"order\", 1);\n\t\tString statusExResolverName = readerContext.registerWithGeneratedName(statusExceptionResolver);\n\n\t\tRootBeanDefinition defaultExceptionResolver = new RootBeanDefinition(DefaultHandlerExceptionResolver.class);\n\t\tdefaultExceptionResolver.setSource(source);\n\t\tdefaultExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tdefaultExceptionResolver.getPropertyValues().add(\"order\", 2);\n\t\tString defaultExResolverName = readerContext.registerWithGeneratedName(defaultExceptionResolver);\n\n\t\tcontext.registerComponent(new BeanComponentDefinition(handlerMappingDef, HANDLER_MAPPING_BEAN_NAME));\n\t\tcontext.registerComponent(new BeanComponentDefinition(handlerAdapterDef, HANDLER_ADAPTER_BEAN_NAME));\n\t\tcontext.registerComponent(new BeanComponentDefinition(uriContributorDef, uriContributorName));\n\t\tcontext.registerComponent(new BeanComponentDefinition(mappedInterceptorDef, mappedInterceptorName));\n\t\tcontext.registerComponent(new BeanComponentDefinition(methodExceptionResolver, methodExResolverName));\n\t\tcontext.registerComponent(new BeanComponentDefinition(statusExceptionResolver, statusExResolverName));\n\t\tcontext.registerComponent(new BeanComponentDefinition(defaultExceptionResolver, defaultExResolverName));\n\n\t\t// Ensure BeanNameUrlHandlerMapping (SPR-8289) and default HandlerAdapters are not \"turned off\"\n\t\tMvcNamespaceUtils.registerDefaultComponents(context, source);\n\n\t\tcontext.popAndRegisterContainingComponent();\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.config.<unknown>#parse(element,parserContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "BeanDefinition",
    "signature": "public BeanDefinition parse(Element element, ParserContext parserContext)",
    "source_code": "\tpublic BeanDefinition parse(Element element, ParserContext parserContext) {\n\t\tObject source = parserContext.extractSource(element);\n\n\t\t// Register SimpleUrlHandlerMapping for view controllers\n\t\tBeanDefinition hm = registerHandlerMapping(parserContext, source);\n\n\t\t// Ensure BeanNameUrlHandlerMapping (SPR-8289) and default HandlerAdapters are not \"turned off\"\n\t\tMvcNamespaceUtils.registerDefaultComponents(parserContext, source);\n\n\t\t// Create view controller bean definition\n\t\tRootBeanDefinition controller = new RootBeanDefinition(ParameterizableViewController.class);\n\t\tcontroller.setSource(source);\n\n\t\tHttpStatusCode statusCode = null;\n\t\tif (element.hasAttribute(\"status-code\")) {\n\t\t\tint statusValue = Integer.parseInt(element.getAttribute(\"status-code\"));\n\t\t\tstatusCode = HttpStatusCode.valueOf(statusValue);\n\t\t}\n\n\t\tString name = element.getLocalName();\n\t\tswitch (name) {\n\t\t\tcase \"view-controller\" -> {\n\t\t\t\tif (element.hasAttribute(\"view-name\")) {\n\t\t\t\t\tcontroller.getPropertyValues().add(\"viewName\", element.getAttribute(\"view-name\"));\n\t\t\t\t}\n\t\t\t\tif (statusCode != null) {\n\t\t\t\t\tcontroller.getPropertyValues().add(\"statusCode\", statusCode);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase \"redirect-view-controller\" ->\n\t\t\t\tcontroller.getPropertyValues().add(\"view\", getRedirectView(element, statusCode, source));\n\t\t\tcase \"status-controller\" -> {\n\t\t\t\tcontroller.getPropertyValues().add(\"statusCode\", statusCode);\n\t\t\t\tcontroller.getPropertyValues().add(\"statusOnly\", true);\n\t\t\t}\n\t\t\tdefault ->\n\t\t\t\t// Should never happen...\n\t\t\t\tthrow new IllegalStateException(\"Unexpected tag name: \" + name);\n\t\t}\n\n\t\tMap<String, BeanDefinition> urlMap = (Map<String, BeanDefinition>) hm.getPropertyValues().get(\"urlMap\");\n\t\tif (urlMap == null) {\n\t\t\turlMap = new ManagedMap<>();\n\t\t\thm.getPropertyValues().add(\"urlMap\", urlMap);\n\t\t}\n\t\turlMap.put(element.getAttribute(\"path\"), controller);\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#addDateHeader(name,date)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "date"
    ],
    "position": {
      "column": 1,
      "line": 566
    },
    "return": "void",
    "signature": "public void addDateHeader(String name, long date)",
    "source_code": "\t\tpublic void addDateHeader(String name, long date) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#addHeader(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 507
    },
    "return": "void",
    "signature": "public void addHeader(String name, String value)",
    "source_code": "\t\t\tpublic void addHeader(String name, String value) {\n\t\t\t\tif (!HttpHeaders.CONTENT_LENGTH.equals(name)) {\n\t\t\t\t\tsuper.addHeader(name, value);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#addIntHeader(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 500
    },
    "return": "void",
    "signature": "public void addIntHeader(String name, int value)",
    "source_code": "\t\t\tpublic void addIntHeader(String name, int value) {\n\t\t\t\tif (!HttpHeaders.CONTENT_LENGTH.equals(name)) {\n\t\t\t\t\tsuper.addIntHeader(name, value);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#attributes(Map<String,attributes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void attributes(Map<String, Object> attributes)",
    "source_code": "\tpublic void attributes(Map<String, Object> attributes) {\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#checkNotModified(lastModified,etag)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lastModified",
      "etag"
    ],
    "position": {
      "column": 1,
      "line": 1079
    },
    "return": "Optional<ServerResponse>",
    "signature": "public Optional<ServerResponse> checkNotModified(Instant lastModified, String etag)",
    "source_code": "\t\tpublic Optional<ServerResponse> checkNotModified(Instant lastModified, String etag) {\n\t\t\treturn this.request.checkNotModified(lastModified, etag);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#param(name,predicate)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that tests the request's parameter of the given name\n\t * against the given predicate.\n\t * @param name the name of the parameter to test against\n\t * @param predicate the predicate to test against the parameter value\n\t * @return a predicate that matches the given predicate against the parameter of the given name\n\t * @see ServerRequest#param(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "predicate"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate param(String name, Predicate<String> predicate)",
    "source_code": "\tpublic static RequestPredicate param(String name, Predicate<String> predicate) {\n\t\treturn new ParamPredicate(name, predicate);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#param(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's parameter of the given name\n\t * has the given value.\n\t * @param name the name of the parameter to test against\n\t * @param value the value of the parameter to test against\n\t * @return a predicate that matches if the parameter has the given value\n\t * @see ServerRequest#param(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate param(String name, String value)",
    "source_code": "\tpublic static RequestPredicate param(String name, String value) {\n\t\treturn new ParamPredicate(name, value);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 457
    },
    "return": "Object",
    "signature": "public Object put(String key, Object value)",
    "source_code": "\t\tpublic Object put(String key, Object value) {\n\t\t\tObject oldValue = this.servletRequest.getAttribute(key);\n\t\t\tthis.servletRequest.setAttribute(key, value);\n\t\t\treturn oldValue;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#resources(Function<ServerRequest,lookupFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ServerRequest",
      "lookupFunction"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "void",
    "signature": "public void resources(Function<ServerRequest, Optional<Resource>> lookupFunction)",
    "source_code": "\tpublic void resources(Function<ServerRequest, Optional<Resource>> lookupFunction) {\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#route(predicate,handlerFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "handlerFunction"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "void",
    "signature": "public void route(RequestPredicate predicate, HandlerFunction<?> handlerFunction)",
    "source_code": "\tpublic void route(RequestPredicate predicate, HandlerFunction<?> handlerFunction) {\n\t\tchangeParser(predicate);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#sendError(sc,msg)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sc",
      "msg"
    ],
    "position": {
      "column": 1,
      "line": 551
    },
    "return": "void",
    "signature": "public void sendError(int sc, String msg)",
    "source_code": "\t\tpublic void sendError(int sc, String msg) throws IOException {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#setDateHeader(name,date)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "date"
    ],
    "position": {
      "column": 1,
      "line": 491
    },
    "return": "void",
    "signature": "public void setDateHeader(String name, long date)",
    "source_code": "\t\tpublic void setDateHeader(String name, long date) {\n\t\t\tthis.headers.setDate(name, date);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#setHeader(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 496
    },
    "return": "void",
    "signature": "public void setHeader(String name, String value)",
    "source_code": "\t\tpublic void setHeader(String name, String value) {\n\t\t\tthis.headers.set(name, value);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#setIntHeader(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 571
    },
    "return": "void",
    "signature": "public void setIntHeader(String name, int value)",
    "source_code": "\t\tpublic void setIntHeader(String name, int value) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#tryWriteEntityWithMessageConverters(entity,request,response,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "entity",
      "request",
      "response",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "void",
    "signature": "protected void tryWriteEntityWithMessageConverters(Object entity, HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, ServerResponse.Context context)",
    "source_code": "\t\tprotected void tryWriteEntityWithMessageConverters(Object entity, HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, ServerResponse.Context context) throws ServletException, IOException {\n\t\t\ttry {\n\t\t\t\twriteEntityWithMessageConverters(entity, request, response, context);\n\t\t\t}\n\t\t\tcatch (IOException | ServletException ex) {\n\t\t\t\thandleError(ex, request, response, context);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#writeEntityWithMessageConverters(entity,request,response,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "entity",
      "request",
      "response",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "void",
    "signature": "protected void writeEntityWithMessageConverters(Object entity, HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, ServerResponse.Context context)",
    "source_code": "\t\tprotected void writeEntityWithMessageConverters(Object entity, HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, ServerResponse.Context context)\n\t\t\t\tthrows ServletException, IOException {\n\n\t\t\tServletServerHttpResponse serverResponse = new ServletServerHttpResponse(response);\n\t\t\tMediaType contentType = getContentType(response);\n\t\t\tClass<?> entityClass = entity.getClass();\n\t\t\tType entityType = this.entityType;\n\n\t\t\tif (entityClass != InputStreamResource.class && Resource.class.isAssignableFrom(entityClass)) {\n\t\t\t\tserverResponse.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\t\t\t\tString rangeHeader = request.getHeader(HttpHeaders.RANGE);\n\t\t\t\tif (rangeHeader != null) {\n\t\t\t\t\tResource resource = (Resource) entity;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tList<HttpRange> httpRanges = HttpRange.parseRanges(rangeHeader);\n\t\t\t\t\t\tserverResponse.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n\t\t\t\t\t\tentity = HttpRange.toResourceRegions(httpRanges, resource);\n\t\t\t\t\t\tentityClass = entity.getClass();\n\t\t\t\t\t\tentityType = RESOURCE_REGION_LIST_TYPE;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t\tserverResponse.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n\t\t\t\t\t\tserverResponse.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (HttpMessageConverter<?> messageConverter : context.messageConverters()) {\n\t\t\t\tif (messageConverter instanceof GenericHttpMessageConverter genericMessageConverter) {\n\t\t\t\t\tif (genericMessageConverter.canWrite(entityType, entityClass, contentType)) {\n\t\t\t\t\t\tgenericMessageConverter.write(entity, entityType, contentType, serverResponse);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (messageConverter.canWrite(entityClass, contentType)) {\n\t\t\t\t\t((HttpMessageConverter<Object>) messageConverter).write(entity, contentType, serverResponse);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tList<MediaType> producibleMediaTypes = producibleMediaTypes(context.messageConverters(), entityClass);\n\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#writeToInternal(request,response,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView writeToInternal(HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, Context context)",
    "source_code": "\t\tprotected ModelAndView writeToInternal(HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, Context context) {\n\n\t\t\tModelAndView mav = new ModelAndView(this.name, this.statusCode());\n\t\t\tmav.addAllObjects(this.model);\n\t\t\treturn mav;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#writeToInternal(servletRequest,servletResponse,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "servletRequest",
      "servletResponse",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView writeToInternal(HttpServletRequest servletRequest, HttpServletResponse servletResponse,\n\t\t\t\tContext context)",
    "source_code": "\t\tprotected ModelAndView writeToInternal(HttpServletRequest servletRequest, HttpServletResponse servletResponse,\n\t\t\t\tContext context) throws ServletException, IOException {\n\n\t\t\tDeferredResult<?> deferredResult = new DeferredResult<>();\n\t\t\tDefaultAsyncServerResponse.writeAsync(servletRequest, servletResponse, deferredResult);\n\n\t\t\tentity().subscribe(new DeferredResultSubscriber(servletRequest, servletResponse, context, deferredResult));\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#afterCompletion(request,response,handler,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex)",
    "source_code": "\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\n\t\tthis.requestInterceptor.afterCompletion(new DispatcherServletWebRequest(request, response), ex);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#afterConcurrentHandlingStarted(request,response,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object handler) {\n\t\tif (this.requestInterceptor instanceof AsyncWebRequestInterceptor asyncInterceptor) {\n\t\t\tDispatcherServletWebRequest webRequest = new DispatcherServletWebRequest(request, response);\n\t\t\tasyncInterceptor.afterConcurrentHandlingStarted(webRequest);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#buildPathExposingHandler(rawHandler,bestMatchingPattern,pathWithinMapping,Map<String,uriTemplateVariables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Build a handler object for the given raw handler, exposing the actual\n\t * handler, the {@link #PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE}, as well as\n\t * the {@link #URI_TEMPLATE_VARIABLES_ATTRIBUTE} before executing the handler.\n\t * <p>The default implementation builds a {@link HandlerExecutionChain}\n\t * with a special interceptor that exposes the path attribute and URI\n\t * template variables\n\t * @param rawHandler the raw handler to expose\n\t * @param pathWithinMapping the path to expose before executing the handler\n\t * @param uriTemplateVariables the URI template variables, can be {@code null} if no variables found\n\t * @return the final handler object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rawHandler",
      "bestMatchingPattern",
      "pathWithinMapping",
      "Map<String",
      "uriTemplateVariables"
    ],
    "position": {
      "column": 1,
      "line": 338
    },
    "return": "Object",
    "signature": "protected Object buildPathExposingHandler(Object rawHandler, String bestMatchingPattern,\n\t\t\tString pathWithinMapping, @Nullable Map<String, String> uriTemplateVariables)",
    "source_code": "\tprotected Object buildPathExposingHandler(Object rawHandler, String bestMatchingPattern,\n\t\t\tString pathWithinMapping, @Nullable Map<String, String> uriTemplateVariables) {\n\n\t\tHandlerExecutionChain chain = new HandlerExecutionChain(rawHandler);\n\t\tchain.addInterceptor(new PathExposingHandlerInterceptor(bestMatchingPattern, pathWithinMapping));\n\t\tif (!CollectionUtils.isEmpty(uriTemplateVariables)) {\n\t\t\tchain.addInterceptor(new UriTemplateVariablesHandlerInterceptor(uriTemplateVariables));\n\t\t}\n\t\treturn chain;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#compare(match1,match2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "match1",
      "match2"
    ],
    "position": {
      "column": 1,
      "line": 828
    },
    "return": "int",
    "signature": "public int compare(Match match1, Match match2)",
    "source_code": "\t\tpublic int compare(Match match1, Match match2) {\n\t\t\treturn this.comparator.compare(match1.mapping, match2.mapping);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#createHandlerMethod(handler,method)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the HandlerMethod instance.\n\t * @param handler either a bean name or an actual handler instance\n\t * @param method the target method\n\t * @return the created HandlerMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod createHandlerMethod(Object handler, Method method)",
    "source_code": "\tprotected HandlerMethod createHandlerMethod(Object handler, Method method) {\n\t\tif (handler instanceof String beanName) {\n\t\t\treturn new HandlerMethod(beanName,\n\t\t\t\t\tobtainApplicationContext().getAutowireCapableBeanFactory(),\n\t\t\t\t\tobtainApplicationContext(),\n\t\t\t\t\tmethod);\n\t\t}\n\t\treturn new HandlerMethod(handler, method);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#doResolveException(request,response,handler,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)",
    "source_code": "\tprotected final ModelAndView doResolveException(\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {\n\n\t\tHandlerMethod handlerMethod = (handler instanceof HandlerMethod ? (HandlerMethod) handler : null);\n\t\treturn doResolveHandlerMethodException(request, response, handlerMethod, ex);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#doResolveHandlerMethodException(request,response,handlerMethod,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually resolve the given exception that got thrown during on handler execution,\n\t * returning a ModelAndView that represents a specific error page if appropriate.\n\t * <p>May be overridden in subclasses, in order to apply specific exception checks.\n\t * Note that this template method will be invoked <i>after</i> checking whether this\n\t * resolved applies (\"mappedHandlers\" etc), so an implementation may simply proceed\n\t * with its actual exception handling.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handlerMethod the executed handler method, or {@code null} if none chosen at the time\n\t * of the exception (for example, if multipart resolution failed)\n\t * @param ex the exception that got thrown during handler execution\n\t * @return a corresponding ModelAndView to forward to, or {@code null} for default processing\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handlerMethod",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView doResolveHandlerMethodException(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception ex)",
    "source_code": "\tprotected abstract ModelAndView doResolveHandlerMethodException(\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception ex);\n\n}"
  },
  "org.springframework.web.servlet.handler.<unknown>#exposePathWithinMapping(bestMatchingPattern,pathWithinMapping,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Expose the path within the current mapping as request attribute.\n\t * @param pathWithinMapping the path within the current mapping\n\t * @param request the request to expose the path to\n\t * @see #PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bestMatchingPattern",
      "pathWithinMapping",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "void",
    "signature": "protected void exposePathWithinMapping(String bestMatchingPattern, String pathWithinMapping,\n\t\t\tHttpServletRequest request)",
    "source_code": "\tprotected void exposePathWithinMapping(String bestMatchingPattern, String pathWithinMapping,\n\t\t\tHttpServletRequest request) {\n\n\t\trequest.setAttribute(BEST_MATCHING_PATTERN_ATTRIBUTE, bestMatchingPattern);\n\t\tServerHttpObservationFilter.findObservationContext(request)\n\t\t\t\t.ifPresent(context -> context.setPathPattern(bestMatchingPattern));\n\t\trequest.setAttribute(PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, pathWithinMapping);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#exposeUriTemplateVariables(Map<String,uriTemplateVariables,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Expose the URI templates variables as request attribute.\n\t * @param uriTemplateVariables the URI template variables\n\t * @param request the request to expose the path to\n\t * @see #PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "uriTemplateVariables",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 370
    },
    "return": "void",
    "signature": "protected void exposeUriTemplateVariables(Map<String, String> uriTemplateVariables, HttpServletRequest request)",
    "source_code": "\tprotected void exposeUriTemplateVariables(Map<String, String> uriTemplateVariables, HttpServletRequest request) {\n\t\trequest.setAttribute(URI_TEMPLATE_VARIABLES_ATTRIBUTE, uriTemplateVariables);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#getCorsConfiguration(handler,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the CORS configuration for the given handler.\n\t * @param handler the handler to check (never {@code null}).\n\t * @param request the current request.\n\t * @return the CORS configuration for the handler, or {@code null} if none\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 653
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration getCorsConfiguration(Object handler, HttpServletRequest request)",
    "source_code": "\tprotected CorsConfiguration getCorsConfiguration(Object handler, HttpServletRequest request) {\n\t\tObject resolvedHandler = handler;\n\t\tif (handler instanceof HandlerExecutionChain handlerExecutionChain) {\n\t\t\tresolvedHandler = handlerExecutionChain.getHandler();\n\t\t}\n\t\tif (resolvedHandler instanceof CorsConfigurationSource configSource) {\n\t\t\treturn configSource.getCorsConfiguration(request);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#getCorsHandlerExecutionChain(request,chain,config)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Update the HandlerExecutionChain for CORS-related handling.\n\t * <p>For pre-flight requests, the default implementation replaces the selected\n\t * handler with a simple HttpRequestHandler that invokes the configured\n\t * {@link #setCorsProcessor}.\n\t * <p>For actual requests, the default implementation inserts a\n\t * HandlerInterceptor that makes CORS-related checks and adds CORS headers.\n\t * @param request the current request\n\t * @param chain the handler chain\n\t * @param config the applicable CORS configuration (possibly {@code null})\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "chain",
      "config"
    ],
    "position": {
      "column": 1,
      "line": 676
    },
    "return": "HandlerExecutionChain",
    "signature": "protected HandlerExecutionChain getCorsHandlerExecutionChain(HttpServletRequest request,\n\t\t\tHandlerExecutionChain chain, @Nullable CorsConfiguration config)",
    "source_code": "\tprotected HandlerExecutionChain getCorsHandlerExecutionChain(HttpServletRequest request,\n\t\t\tHandlerExecutionChain chain, @Nullable CorsConfiguration config) {\n\n\t\tif (CorsUtils.isPreFlightRequest(request)) {\n\t\t\tHandlerInterceptor[] interceptors = chain.getInterceptors();\n\t\t\treturn new HandlerExecutionChain(new PreFlightHandler(config), interceptors);\n\t\t}\n\t\telse {\n\t\t\tchain.addInterceptor(0, new CorsInterceptor(config));\n\t\t\treturn chain;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#getHandlerExecutionChain(handler,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link HandlerExecutionChain} for the given handler, including\n\t * applicable interceptors.\n\t * <p>The default implementation builds a standard {@link HandlerExecutionChain}\n\t * with the given handler, the common interceptors of the handler mapping, and any\n\t * {@link MappedInterceptor MappedInterceptors} matching to the current request URL. Interceptors\n\t * are added in the order they were registered. Subclasses may override this\n\t * in order to extend/rearrange the list of interceptors.\n\t * <p><b>NOTE:</b> The passed-in handler object may be a raw handler or a\n\t * pre-built {@link HandlerExecutionChain}. This method should handle those\n\t * two cases explicitly, either building a new {@link HandlerExecutionChain}\n\t * or extending the existing chain.\n\t * <p>For simply adding an interceptor in a custom subclass, consider calling\n\t * {@code super.getHandlerExecutionChain(handler, request)} and invoking\n\t * {@link HandlerExecutionChain#addInterceptor} on the returned chain object.\n\t * @param handler the resolved handler instance (never {@code null})\n\t * @param request current HTTP request\n\t * @return the HandlerExecutionChain (never {@code null})\n\t * @see #getAdaptedInterceptors()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 617
    },
    "return": "HandlerExecutionChain",
    "signature": "protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request)",
    "source_code": "\tprotected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {\n\t\tHandlerExecutionChain chain = (handler instanceof HandlerExecutionChain handlerExecutionChain ?\n\t\t\t\thandlerExecutionChain : new HandlerExecutionChain(handler));\n\n\t\tfor (HandlerInterceptor interceptor : this.adaptedInterceptors) {\n\t\t\tif (interceptor instanceof MappedInterceptor mappedInterceptor) {\n\t\t\t\tif (mappedInterceptor.matches(request)) {\n\t\t\t\t\tchain.addInterceptor(mappedInterceptor.getInterceptor());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchain.addInterceptor(interceptor);\n\t\t\t}\n\t\t}\n\t\treturn chain;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#getMappingForMethod(method,handlerType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Provide the mapping for a handler method. A method for which no\n\t * mapping can be provided is not a handler method.\n\t * @param method the method to provide a mapping for\n\t * @param handlerType the handler type, possibly a subtype of the method's\n\t * declaring class\n\t * @return the mapping, or {@code null} if the method is not mapped\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 519
    },
    "return": "T",
    "signature": "protected T getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected abstract T getMappingForMethod(Method method, Class<?> handlerType);"
  },
  "org.springframework.web.servlet.handler.<unknown>#getMatchingMapping(mapping,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check if a mapping matches the current request and return a (potentially\n\t * new) mapping with conditions relevant to the current request.\n\t * @param mapping the mapping to get a match for\n\t * @param request the current HTTP servlet request\n\t * @return the match, or {@code null} if the mapping doesn't match\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 554
    },
    "return": "T",
    "signature": "protected T getMatchingMapping(T mapping, HttpServletRequest request)",
    "source_code": "\tprotected abstract T getMatchingMapping(T mapping, HttpServletRequest request);"
  },
  "org.springframework.web.servlet.handler.<unknown>#handleMatch(mapping,lookupPath,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a matching mapping is found.\n\t * @param mapping the matching mapping\n\t * @param lookupPath mapping lookup path within the current servlet mapping\n\t * @param request the current request\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 460
    },
    "return": "void",
    "signature": "protected void handleMatch(T mapping, String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected void handleMatch(T mapping, String lookupPath, HttpServletRequest request) {\n\t\trequest.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, lookupPath);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#handleNoMatch(mappings,lookupPath,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when no matching mapping is not found.\n\t * @param mappings all registered mappings\n\t * @param lookupPath mapping lookup path within the current servlet mapping\n\t * @param request the current request\n\t * @throws ServletException in case of errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mappings",
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 472
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod handleNoMatch(Set<T> mappings, String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected HandlerMethod handleNoMatch(Set<T> mappings, String lookupPath, HttpServletRequest request)\n\t\t\tthrows Exception {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#handleRequest(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 700
    },
    "return": "void",
    "signature": "public void handleRequest(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\t\tpublic void handleRequest(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\t\tcorsProcessor.processRequest(this.config, request, response);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#handlerMethodsInitialized(Map<T,handlerMethods)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked after all handler methods have been detected.\n\t * @param handlerMethods a read-only map with handler methods and mappings.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<T",
      "handlerMethods"
    ],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "void",
    "signature": "protected void handlerMethodsInitialized(Map<T, HandlerMethod> handlerMethods)",
    "source_code": "\tprotected void handlerMethodsInitialized(Map<T, HandlerMethod> handlerMethods) {\n\t\t// Total includes detected mappings + explicit registrations via registerMapping\n\t\tint total = handlerMethods.size();\n\t\tif ((logger.isTraceEnabled() && total == 0) || (logger.isDebugEnabled() && total > 0) ) {\n\t\t\tlogger.debug(total + \" mappings in \" + formatMappingName());\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#initCorsConfiguration(handler,method,mapping)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extract and return the CORS configuration for the mapping.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration initCorsConfiguration(Object handler, Method method, T mapping)",
    "source_code": "\tprotected CorsConfiguration initCorsConfiguration(Object handler, Method method, T mapping) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#initPatterns(patterns,parser)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "patterns",
      "parser"
    ],
    "position": {
      "column": 1,
      "line": 310
    },
    "return": "PatternAdapter[]",
    "signature": "public PatternAdapter[] initPatterns(@Nullable String[] patterns, @Nullable PathPatternParser parser)",
    "source_code": "\t\tpublic static PatternAdapter[] initPatterns(\n\t\t\t\t@Nullable String[] patterns, @Nullable PathPatternParser parser) {\n\n\t\t\tif (ObjectUtils.isEmpty(patterns)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn Arrays.stream(patterns)\n\t\t\t\t\t.map(pattern -> new PatternAdapter(pattern, parser))\n\t\t\t\t\t.toArray(PatternAdapter[]::new);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#lookupHandler(lookupPath,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look up a handler instance for the given URL path. This method is used\n\t * when String pattern matching with {@code PathMatcher} is in use.\n\t * @param lookupPath the path to match patterns against\n\t * @param request current HTTP request\n\t * @return a matching handler, or {@code null} if not found\n\t * @see #exposePathWithinMapping\n\t * @see AntPathMatcher\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "Object",
    "signature": "protected Object lookupHandler(String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected Object lookupHandler(String lookupPath, HttpServletRequest request) throws Exception {\n\t\tObject handler = getDirectMatch(lookupPath, request);\n\t\tif (handler != null) {\n\t\t\treturn handler;\n\t\t}\n\n\t\t// Pattern match?\n\t\tList<String> matchingPatterns = new ArrayList<>();\n\t\tfor (String registeredPattern : this.handlerMap.keySet()) {\n\t\t\tif (getPathMatcher().match(registeredPattern, lookupPath)) {\n\t\t\t\tmatchingPatterns.add(registeredPattern);\n\t\t\t}\n\t\t\telse if (useTrailingSlashMatch()) {\n\t\t\t\tif (!registeredPattern.endsWith(\"/\") && getPathMatcher().match(registeredPattern + \"/\", lookupPath)) {\n\t\t\t\t\tmatchingPatterns.add(registeredPattern + \"/\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString bestMatch = null;\n\t\tComparator<String> patternComparator = getPathMatcher().getPatternComparator(lookupPath);\n\t\tif (!matchingPatterns.isEmpty()) {\n\t\t\tmatchingPatterns.sort(patternComparator);\n\t\t\tif (logger.isTraceEnabled() && matchingPatterns.size() > 1) {\n\t\t\t\tlogger.trace(\"Matching patterns \" + matchingPatterns);\n\t\t\t}\n\t\t\tbestMatch = matchingPatterns.get(0);\n\t\t}\n\t\tif (bestMatch != null) {\n\t\t\thandler = this.handlerMap.get(bestMatch);\n\t\t\tif (handler == null) {\n\t\t\t\tif (bestMatch.endsWith(\"/\")) {\n\t\t\t\t\thandler = this.handlerMap.get(bestMatch.substring(0, bestMatch.length() - 1));\n\t\t\t\t}\n\t\t\t\tif (handler == null) {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"Could not find handler for best pattern match [\" + bestMatch + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Bean name or resolved handler?\n\t\t\tif (handler instanceof String handlerName) {\n\t\t\t\thandler = obtainApplicationContext().getBean(handlerName);\n\t\t\t}\n\t\t\tvalidateHandler(handler, request);\n\t\t\tString pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestMatch, lookupPath);\n\n\t\t\t// There might be multiple 'best patterns', let's make sure we have the correct URI template variables\n\t\t\t// for all of them\n\t\t\tMap<String, String> uriTemplateVariables = new LinkedHashMap<>();\n\t\t\tfor (String matchingPattern : matchingPatterns) {\n\t\t\t\tif (patternComparator.compare(bestMatch, matchingPattern) == 0) {\n\t\t\t\t\tMap<String, String> vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, lookupPath);\n\t\t\t\t\tMap<String, String> decodedVars = getUrlPathHelper().decodePathVariables(request, vars);\n\t\t\t\t\turiTemplateVariables.putAll(decodedVars);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled() && uriTemplateVariables.size() > 0) {\n\t\t\t\tlogger.trace(\"URI variables \" + uriTemplateVariables);\n\t\t\t}\n\t\t\treturn buildPathExposingHandler(handler, bestMatch, pathWithinMapping, uriTemplateVariables);\n\t\t}\n\n\t\t// No handler found...\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#lookupHandler(path,lookupPath,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look up a handler instance for the given URL path. This method is used\n\t * when parsed {@code PathPattern}s are {@link #usesPathPatterns() enabled}.\n\t * @param path the parsed RequestPath\n\t * @param lookupPath the String lookupPath for checking direct hits\n\t * @param request current HTTP request\n\t * @return a matching handler, or {@code null} if not found\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "path",
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "Object",
    "signature": "protected Object lookupHandler(RequestPath path, String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected Object lookupHandler(\n\t\t\tRequestPath path, String lookupPath, HttpServletRequest request) throws Exception {\n\n\t\tObject handler = getDirectMatch(lookupPath, request);\n\t\tif (handler != null) {\n\t\t\treturn handler;\n\t\t}\n\n\t\t// Pattern match?\n\t\tList<PathPattern> matches = null;\n\t\tfor (PathPattern pattern : this.pathPatternHandlerMap.keySet()) {\n\t\t\tif (pattern.matches(path.pathWithinApplication())) {\n\t\t\t\tmatches = (matches != null ? matches : new ArrayList<>());\n\t\t\t\tmatches.add(pattern);\n\t\t\t}\n\t\t}\n\t\tif (matches == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (matches.size() > 1) {\n\t\t\tmatches.sort(PathPattern.SPECIFICITY_COMPARATOR);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Matching patterns \" + matches);\n\t\t\t}\n\t\t}\n\t\tPathPattern pattern = matches.get(0);\n\t\thandler = this.pathPatternHandlerMap.get(pattern);\n\t\tif (handler instanceof String handlerName) {\n\t\t\thandler = obtainApplicationContext().getBean(handlerName);\n\t\t}\n\t\tvalidateHandler(handler, request);\n\t\tString pathWithinMapping = pattern.extractPathWithinPattern(path.pathWithinApplication()).value();\n\t\tpathWithinMapping = UrlPathHelper.defaultInstance.removeSemicolonContent(pathWithinMapping);\n\t\treturn buildPathExposingHandler(handler, pattern.getPatternString(), pathWithinMapping, null);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#lookupHandlerMethod(lookupPath,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look up the best-matching handler method for the current request.\n\t * If multiple matches are found, the best match is selected.\n\t * @param lookupPath mapping lookup path within the current servlet mapping\n\t * @param request the current request\n\t * @return the best-matching handler method, or {@code null} if no match\n\t * @see #handleMatch(Object, String, HttpServletRequest)\n\t * @see #handleNoMatch(Set, String, HttpServletRequest)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 400
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception {\n\t\tList<Match> matches = new ArrayList<>();\n\t\tList<T> directPathMatches = this.mappingRegistry.getMappingsByDirectPath(lookupPath);\n\t\tif (directPathMatches != null) {\n\t\t\taddMatchingMappings(directPathMatches, matches, request);\n\t\t}\n\t\tif (matches.isEmpty()) {\n\t\t\taddMatchingMappings(this.mappingRegistry.getRegistrations().keySet(), matches, request);\n\t\t}\n\t\tif (!matches.isEmpty()) {\n\t\t\tMatch bestMatch = matches.get(0);\n\t\t\tif (matches.size() > 1) {\n\t\t\t\tComparator<Match> comparator = new MatchComparator(getMappingComparator(request));\n\t\t\t\tmatches.sort(comparator);\n\t\t\t\tbestMatch = matches.get(0);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(matches.size() + \" matching mappings: \" + matches);\n\t\t\t\t}\n\t\t\t\tif (CorsUtils.isPreFlightRequest(request)) {\n\t\t\t\t\tfor (Match match : matches) {\n\t\t\t\t\t\tif (match.hasCorsConfig()) {\n\t\t\t\t\t\t\treturn PREFLIGHT_AMBIGUOUS_MATCH;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMatch secondBestMatch = matches.get(1);\n\t\t\t\t\tif (comparator.compare(bestMatch, secondBestMatch) == 0) {\n\t\t\t\t\t\tMethod m1 = bestMatch.getHandlerMethod().getMethod();\n\t\t\t\t\t\tMethod m2 = secondBestMatch.getHandlerMethod().getMethod();\n\t\t\t\t\t\tString uri = request.getRequestURI();\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\"Ambiguous handler methods mapped for '\" + uri + \"': {\" + m1 + \", \" + m2 + \"}\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trequest.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.getHandlerMethod());\n\t\t\thandleMatch(bestMatch.mapping, lookupPath, request);\n\t\t\treturn bestMatch.getHandlerMethod();\n\t\t}\n\t\telse {\n\t\t\treturn handleNoMatch(this.mappingRegistry.getRegistrations().keySet(), lookupPath, request);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#match(path,isPathContainer,pathMatcher)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "isPathContainer",
      "pathMatcher"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "boolean",
    "signature": "public boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher)",
    "source_code": "\t\tpublic boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher) {\n\t\t\tif (isPathContainer) {\n\t\t\t\tPathContainer pathContainer = (PathContainer) path;\n\t\t\t\tif (this.pathPattern != null) {\n\t\t\t\t\treturn this.pathPattern.matches(pathContainer);\n\t\t\t\t}\n\t\t\t\tString lookupPath = pathContainer.value();\n\t\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);\n\t\t\t}\n\t\t\treturn pathMatcher.match(this.patternString, (String) path);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#match(request,pattern)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "RequestMatchResult",
    "signature": "public RequestMatchResult match(HttpServletRequest request, String pattern)",
    "source_code": "\tpublic RequestMatchResult match(HttpServletRequest request, String pattern) {\n\t\tAssert.state(getPatternParser() == null, \"This HandlerMapping uses PathPatterns.\");\n\t\tString lookupPath = UrlPathHelper.getResolvedLookupPath(request);\n\t\tif (getPathMatcher().match(pattern, lookupPath)) {\n\t\t\treturn new RequestMatchResult(pattern, lookupPath, getPathMatcher());\n\t\t}\n\t\telse if (useTrailingSlashMatch()) {\n\t\t\tif (!pattern.endsWith(\"/\") && getPathMatcher().match(pattern + \"/\", lookupPath)) {\n\t\t\t\treturn new RequestMatchResult(pattern + \"/\", lookupPath, getPathMatcher());\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#matches(lookupPath,pathMatcher)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lookupPath",
      "pathMatcher"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "boolean",
    "signature": "public boolean matches(String lookupPath, PathMatcher pathMatcher)",
    "source_code": "\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#postHandle(request,response,handler,modelAndView)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "modelAndView"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView)",
    "source_code": "\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\n\t\tthis.requestInterceptor.postHandle(new DispatcherServletWebRequest(request, response),\n\t\t\t\t(modelAndView != null && !modelAndView.wasCleared() ? modelAndView.getModelMap() : null));\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#preHandle(request,response,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "boolean",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\tthis.requestInterceptor.preHandle(new DispatcherServletWebRequest(request, response));\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#register(mapping,handler,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 629
    },
    "return": "void",
    "signature": "public void register(T mapping, Object handler, Method method)",
    "source_code": "\t\tpublic void register(T mapping, Object handler, Method method) {\n\t\t\tthis.readWriteLock.writeLock().lock();\n\t\t\ttry {\n\t\t\t\tHandlerMethod handlerMethod = createHandlerMethod(handler, method);\n\t\t\t\tvalidateMethodMapping(handlerMethod, mapping);\n\n\t\t\t\tSet<String> directPaths = AbstractHandlerMethodMapping.this.getDirectPaths(mapping);\n\t\t\t\tfor (String path : directPaths) {\n\t\t\t\t\tthis.pathLookup.add(path, mapping);\n\t\t\t\t}\n\n\t\t\t\tString name = null;\n\t\t\t\tif (getNamingStrategy() != null) {\n\t\t\t\t\tname = getNamingStrategy().getName(handlerMethod, mapping);\n\t\t\t\t\taddMappingName(name, handlerMethod);\n\t\t\t\t}\n\n\t\t\t\tCorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);\n\t\t\t\tif (corsConfig != null) {\n\t\t\t\t\tcorsConfig.validateAllowCredentials();\n\t\t\t\t\tthis.corsLookup.put(handlerMethod, corsConfig);\n\t\t\t\t}\n\n\t\t\t\tthis.registry.put(mapping,\n\t\t\t\t\t\tnew MappingRegistration<>(mapping, handlerMethod, directPaths, name, corsConfig != null));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.readWriteLock.writeLock().unlock();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#registerHandler(urlPath,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified handler for the given URL path.\n\t * @param urlPath the URL the bean should be mapped to\n\t * @param handler the handler instance or handler bean name String\n\t * (a bean name will automatically be resolved into the corresponding handler bean)\n\t * @throws BeansException if the handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "urlPath",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "void",
    "signature": "protected void registerHandler(String urlPath, Object handler)",
    "source_code": "\tprotected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {\n\t\tAssert.notNull(urlPath, \"URL path must not be null\");\n\t\tAssert.notNull(handler, \"Handler object must not be null\");\n\t\tObject resolvedHandler = handler;\n\n\t\t// Eagerly resolve handler if referencing singleton via name.\n\t\tif (!this.lazyInitHandlers && handler instanceof String handlerName) {\n\t\t\tApplicationContext applicationContext = obtainApplicationContext();\n\t\t\tif (applicationContext.isSingleton(handlerName)) {\n\t\t\t\tresolvedHandler = applicationContext.getBean(handlerName);\n\t\t\t}\n\t\t}\n\n\t\tObject mappedHandler = this.handlerMap.get(urlPath);\n\t\tif (mappedHandler != null) {\n\t\t\tif (mappedHandler != resolvedHandler) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Cannot map \" + getHandlerDescription(handler) + \" to URL path [\" + urlPath +\n\t\t\t\t\t\t\"]: There is already \" + getHandlerDescription(mappedHandler) + \" mapped.\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (urlPath.equals(\"/\")) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Root mapping to \" + getHandlerDescription(handler));\n\t\t\t\t}\n\t\t\t\tsetRootHandler(resolvedHandler);\n\t\t\t}\n\t\t\telse if (urlPath.equals(\"/*\")) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Default mapping to \" + getHandlerDescription(handler));\n\t\t\t\t}\n\t\t\t\tsetDefaultHandler(resolvedHandler);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.handlerMap.put(urlPath, resolvedHandler);\n\t\t\t\tif (getPatternParser() != null) {\n\t\t\t\t\tthis.pathPatternHandlerMap.put(getPatternParser().parse(urlPath), resolvedHandler);\n\t\t\t\t}\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Mapped [\" + urlPath + \"] onto \" + getHandlerDescription(handler));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#registerHandler(urlPaths,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified handler for the given URL paths.\n\t * @param urlPaths the URLs that the bean should be mapped to\n\t * @param beanName the name of the handler bean\n\t * @throws BeansException if the handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "urlPaths",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "void",
    "signature": "protected void registerHandler(String[] urlPaths, String beanName)",
    "source_code": "\tprotected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {\n\t\tAssert.notNull(urlPaths, \"URL path array must not be null\");\n\t\tfor (String urlPath : urlPaths) {\n\t\t\tregisterHandler(urlPath, beanName);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#registerHandlerMethod(handler,method,mapping)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a handler method and its unique mapping. Invoked at startup for\n\t * each detected handler method.\n\t * @param handler the bean name of the handler or the handler instance\n\t * @param method the method to register\n\t * @param mapping the mapping conditions associated with the handler method\n\t * @throws IllegalStateException if another method was already registered\n\t * under the same mapping\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "void",
    "signature": "protected void registerHandlerMethod(Object handler, Method method, T mapping)",
    "source_code": "\tprotected void registerHandlerMethod(Object handler, Method method, T mapping) {\n\t\tthis.mappingRegistry.register(mapping, handler, method);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#registerMapping(mapping,handler,method)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given mapping.\n\t * <p>This method may be invoked at runtime after initialization has completed.\n\t * @param mapping the mapping for the handler method\n\t * @param handler the handler\n\t * @param method the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void registerMapping(T mapping, Object handler, Method method)",
    "source_code": "\tpublic void registerMapping(T mapping, Object handler, Method method) {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Register \\\"\" + mapping + \"\\\" to \" + method.toGenericString());\n\t\t}\n\t\tthis.mappingRegistry.register(mapping, handler, method);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#setCorsConfigurations(Map<String,corsConfigurations)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set \"global\" CORS configuration mappings. The first matching URL pattern\n\t * determines the {@code CorsConfiguration} to use which is then further\n\t * {@link CorsConfiguration#combine(CorsConfiguration) combined} with the\n\t * {@code CorsConfiguration} for the selected handler.\n\t * <p>This is mutually exclusive with\n\t * {@link #setCorsConfigurationSource(CorsConfigurationSource)}.\n\t * @since 4.2\n\t * @see #setCorsProcessor(CorsProcessor)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "corsConfigurations"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "void",
    "signature": "public void setCorsConfigurations(Map<String, CorsConfiguration> corsConfigurations)",
    "source_code": "\tpublic void setCorsConfigurations(Map<String, CorsConfiguration> corsConfigurations) {\n\t\tif (CollectionUtils.isEmpty(corsConfigurations)) {\n\t\t\tthis.corsConfigurationSource = null;\n\t\t\treturn;\n\t\t}\n\t\tUrlBasedCorsConfigurationSource source;\n\t\tif (getPatternParser() != null) {\n\t\t\tsource = new UrlBasedCorsConfigurationSource(getPatternParser());\n\t\t\tsource.setCorsConfigurations(corsConfigurations);\n\t\t}\n\t\telse {\n\t\t\tsource = new UrlBasedCorsConfigurationSource();\n\t\t\tsource.setCorsConfigurations(corsConfigurations);\n\t\t\tsource.setPathMatcher(this.pathMatcher);\n\t\t\tsource.setUrlPathHelper(this.urlPathHelper);\n\t\t}\n\t\tsetCorsConfigurationSource(source);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#shouldApplyTo(request,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Checks if the handler is a {@link HandlerMethod} and then delegates to the\n\t * base class implementation of {@code #shouldApplyTo(HttpServletRequest, Object)}\n\t * passing the bean of the {@code HandlerMethod}. Otherwise returns {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "return": "boolean",
    "signature": "protected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler)",
    "source_code": "\tprotected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler) {\n\t\tif (handler == null) {\n\t\t\treturn super.shouldApplyTo(request, null);\n\t\t}\n\t\telse if (handler instanceof HandlerMethod handlerMethod) {\n\t\t\thandler = handlerMethod.getBean();\n\t\t\treturn super.shouldApplyTo(request, handler);\n\t\t}\n\t\telse if (hasGlobalExceptionHandlers() && hasHandlerMappings()) {\n\t\t\treturn super.shouldApplyTo(request, handler);\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#validateHandler(handler,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the given handler against the current request.\n\t * <p>The default implementation is empty. Can be overridden in subclasses,\n\t * for example to enforce specific preconditions expressed in URL mappings.\n\t * @param handler the handler object to validate\n\t * @param request current HTTP request\n\t * @throws Exception if validation failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "void",
    "signature": "protected void validateHandler(Object handler, HttpServletRequest request)",
    "source_code": "\tprotected void validateHandler(Object handler, HttpServletRequest request) throws Exception {\n\t}"
  },
  "org.springframework.web.servlet.i18n.<unknown>#setDefaultLocaleFunction(Function<HttpServletRequest,defaultLocaleFunction)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the function used to determine the default locale for the given request,\n\t * called if no locale cookie has been found.\n\t * <p>The default implementation returns the configured\n\t * {@linkplain #setDefaultLocale(Locale) default locale}, if any, and otherwise\n\t * falls back to the request's {@code Accept-Language} header locale or the\n\t * default locale for the server.\n\t * @param defaultLocaleFunction the function used to determine the default locale\n\t * @since 6.0\n\t * @see #setDefaultLocale\n\t * @see jakarta.servlet.http.HttpServletRequest#getLocale()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<HttpServletRequest",
      "defaultLocaleFunction"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "void",
    "signature": "public void setDefaultLocaleFunction(Function<HttpServletRequest, Locale> defaultLocaleFunction)",
    "source_code": "\tpublic void setDefaultLocaleFunction(Function<HttpServletRequest, Locale> defaultLocaleFunction) {\n\t\tAssert.notNull(defaultLocaleFunction, \"defaultLocaleFunction must not be null\");\n\t\tthis.defaultLocaleFunction = defaultLocaleFunction;\n\t}"
  },
  "org.springframework.web.servlet.i18n.<unknown>#setDefaultTimeZoneFunction(Function<HttpServletRequest,defaultTimeZoneFunction)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the function used to determine the default time zone for the given request,\n\t * called if no locale cookie has been found.\n\t * <p>The default implementation returns the configured default time zone,\n\t * if any, or {@code null} otherwise.\n\t * @param defaultTimeZoneFunction the function used to determine the default time zone\n\t * @since 6.0\n\t * @see #setDefaultTimeZone\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<HttpServletRequest",
      "defaultTimeZoneFunction"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "void",
    "signature": "public void setDefaultTimeZoneFunction(Function<HttpServletRequest, TimeZone> defaultTimeZoneFunction)",
    "source_code": "\tpublic void setDefaultTimeZoneFunction(Function<HttpServletRequest, TimeZone> defaultTimeZoneFunction) {\n\t\tAssert.notNull(defaultTimeZoneFunction, \"defaultTimeZoneFunction must not be null\");\n\t\tthis.defaultTimeZoneFunction = defaultTimeZoneFunction;\n\t}"
  },
  "org.springframework.web.servlet.i18n.<unknown>#setLocaleContext(request,response,localeContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "localeContext"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "void",
    "signature": "public void setLocaleContext(HttpServletRequest request, @Nullable HttpServletResponse response,\n\t\t\t@Nullable LocaleContext localeContext)",
    "source_code": "\tpublic void setLocaleContext(HttpServletRequest request, @Nullable HttpServletResponse response,\n\t\t\t@Nullable LocaleContext localeContext) {\n\n\t\tAssert.notNull(response, \"HttpServletResponse is required for CookieLocaleResolver\");\n\n\t\tLocale locale = null;\n\t\tTimeZone zone = null;\n\t\tif (localeContext != null) {\n\t\t\tlocale = localeContext.getLocale();\n\t\t\tif (localeContext instanceof TimeZoneAwareLocaleContext timeZoneAwareLocaleContext) {\n\t\t\t\tzone = timeZoneAwareLocaleContext.getTimeZone();\n\t\t\t}\n\t\t\tString value = (locale != null ? toLocaleValue(locale) : \"-\") + (zone != null ? '/' + zone.getID() : \"\");\n\t\t\tthis.cookie = this.cookie.mutate().value(value).build();\n\t\t}\n\t\tresponse.addHeader(HttpHeaders.SET_COOKIE, this.cookie.toString());\n\t\trequest.setAttribute(LOCALE_REQUEST_ATTRIBUTE_NAME,\n\t\t\t\t(locale != null ? locale : this.defaultLocaleFunction.apply(request)));\n\t\trequest.setAttribute(TIME_ZONE_REQUEST_ATTRIBUTE_NAME,\n\t\t\t\t(zone != null ? zone : this.defaultTimeZoneFunction.apply(request)));\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#addCacheMapping(cacheControl,paths)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Map specific URL paths to a specific {@link org.springframework.http.CacheControl}.\n\t * <p>Overrides the default cache seconds setting of this interceptor.\n\t * Can specify an empty {@link org.springframework.http.CacheControl} instance\n\t * to exclude a URL path from default caching.\n\t * <p>For pattern syntax see {@link AntPathMatcher} and {@link PathPattern}\n\t * as well as the class-level Javadoc for details for when each is used.\n\t * The syntax is largely the same with {@link PathPattern} more tailored for\n\t * web usage.\n\t * <p><b>NOTE:</b> Path patterns are not supposed to overlap. If a request\n\t * matches several mappings, it is effectively undefined which one will apply\n\t * (due to the lack of key ordering in the underlying {@code java.util.HashMap}).\n\t * @param cacheControl the {@code CacheControl} to use\n\t * @param paths the URL paths that will map to the given {@code CacheControl}\n\t * @since 4.2\n\t * @see #setCacheSeconds\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheControl",
      "paths"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "public void addCacheMapping(CacheControl cacheControl, String... paths)",
    "source_code": "\tpublic void addCacheMapping(CacheControl cacheControl, String... paths) {\n\t\tfor (String path : paths) {\n\t\t\tthis.cacheControlMappings.put(this.patternParser.parse(path), cacheControl);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#afterCompletion(request,response,handler,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation is empty.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "void",
    "signature": "public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex)",
    "source_code": "\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#handleRequestInternal(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a ModelAndView object with the specified view name.\n\t * <p>The content of the {@link RequestContextUtils#getInputFlashMap\n\t * \"input\" FlashMap} is also added to the model.\n\t * @see #getViewName()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception {\n\n\t\tString viewName = getViewName();\n\n\t\tif (getStatusCode() != null) {\n\t\t\tif (getStatusCode().is3xxRedirection()) {\n\t\t\t\trequest.setAttribute(View.RESPONSE_STATUS_ATTRIBUTE, getStatusCode());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponse.setStatus(getStatusCode().value());\n\t\t\t\tif (getStatusCode().equals(HttpStatus.NO_CONTENT) && viewName == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (isStatusOnly()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tModelAndView modelAndView = new ModelAndView();\n\t\tmodelAndView.addAllObjects(RequestContextUtils.getInputFlashMap(request));\n\t\tif (viewName != null) {\n\t\t\tmodelAndView.setViewName(viewName);\n\t\t}\n\t\telse {\n\t\t\tmodelAndView.setView(getView());\n\t\t}\n\t\treturn modelAndView;\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#postHandle(request,response,handler,modelAndView)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation is empty.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "modelAndView"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "void",
    "signature": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView)",
    "source_code": "\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#preHandle(request,response,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "boolean",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows ServletException {\n\n\t\tcheckRequest(request);\n\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\n\t\tif (!ObjectUtils.isEmpty(this.cacheControlMappings)) {\n\t\t\tCacheControl control = (path instanceof PathContainer pathContainer ?\n\t\t\t\t\tlookupCacheControl(pathContainer) : lookupCacheControl((String) path));\n\t\t\tif (control != null) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Applying \" + control);\n\t\t\t\t}\n\t\t\t\tapplyCacheControl(response, control);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (!ObjectUtils.isEmpty(this.cacheMappings)) {\n\t\t\tInteger cacheSeconds = (path instanceof PathContainer pathContainer ?\n\t\t\t\t\tlookupCacheSeconds(pathContainer) : lookupCacheSeconds((String) path));\n\t\t\tif (cacheSeconds != null) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Applying cacheSeconds \" + cacheSeconds);\n\t\t\t\t}\n\t\t\t\tapplyCacheSeconds(response, cacheSeconds);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tprepareResponse(response);\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#compareTo(other,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Compares \"this\" info (i.e. the current instance) with another info in the\n\t * context of a request.\n\t * <p>Note: It is assumed both instances have been obtained via\n\t * {@link #getMatchingCondition(HttpServletRequest)} to ensure they have\n\t * conditions with content relevant to current request.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 427
    },
    "return": "int",
    "signature": "public int compareTo(RequestMappingInfo other, HttpServletRequest request)",
    "source_code": "\tpublic int compareTo(RequestMappingInfo other, HttpServletRequest request) {\n\t\tint result;\n\t\t// Automatic vs explicit HTTP HEAD mapping\n\t\tif (HttpMethod.HEAD.matches(request.getMethod())) {\n\t\t\tresult = this.methodsCondition.compareTo(other.getMethodsCondition(), request);\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\tresult = getActivePatternsCondition().compareTo(other.getActivePatternsCondition(), request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.paramsCondition.compareTo(other.getParamsCondition(), request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.headersCondition.compareTo(other.getHeadersCondition(), request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.consumesCondition.compareTo(other.getConsumesCondition(), request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.producesCondition.compareTo(other.getProducesCondition(), request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\t// Implicit (no method) vs explicit HTTP method mappings\n\t\tresult = this.methodsCondition.compareTo(other.getMethodsCondition(), request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.customConditionHolder.compareTo(other.customConditionHolder, request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\treturn 0;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#afterBodyRead(body,inputMessage,parameter,targetType,converterType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "inputMessage",
      "parameter",
      "targetType",
      "converterType"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "Object",
    "signature": "public Object afterBodyRead(Object body, HttpInputMessage inputMessage, MethodParameter parameter,\n\t\t\tType targetType, Class<? extends HttpMessageConverter<?>> converterType)",
    "source_code": "\tpublic Object afterBodyRead(Object body, HttpInputMessage inputMessage, MethodParameter parameter,\n\t\t\tType targetType, Class<? extends HttpMessageConverter<?>> converterType) {\n\n\t\tfor (RequestBodyAdvice advice : getMatchingAdvice(parameter, RequestBodyAdvice.class)) {\n\t\t\tif (advice.supports(parameter, targetType, converterType)) {\n\t\t\t\tbody = advice.afterBodyRead(body, inputMessage, parameter, targetType, converterType);\n\t\t\t}\n\t\t}\n\t\treturn body;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#beforeBodyRead(request,parameter,targetType,converterType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "parameter",
      "targetType",
      "converterType"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "HttpInputMessage",
    "signature": "public HttpInputMessage beforeBodyRead(HttpInputMessage request, MethodParameter parameter,\n\t\t\tType targetType, Class<? extends HttpMessageConverter<?>> converterType)",
    "source_code": "\tpublic HttpInputMessage beforeBodyRead(HttpInputMessage request, MethodParameter parameter,\n\t\t\tType targetType, Class<? extends HttpMessageConverter<?>> converterType) throws IOException {\n\n\t\tfor (RequestBodyAdvice advice : getMatchingAdvice(parameter, RequestBodyAdvice.class)) {\n\t\t\tif (advice.supports(parameter, targetType, converterType)) {\n\t\t\t\trequest = advice.beforeBodyRead(request, parameter, targetType, converterType);\n\t\t\t}\n\t\t}\n\t\treturn request;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#beforeBodyWrite(body,returnType,contentType,converterType,request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "returnType",
      "contentType",
      "converterType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Object",
    "signature": "public Object beforeBodyWrite(@Nullable Object body, MethodParameter returnType, MediaType contentType,\n\t\t\tClass<? extends HttpMessageConverter<?>> converterType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tpublic Object beforeBodyWrite(@Nullable Object body, MethodParameter returnType, MediaType contentType,\n\t\t\tClass<? extends HttpMessageConverter<?>> converterType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response) {\n\n\t\treturn processBody(body, returnType, contentType, converterType, request, response);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#connect(adapter,returnValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "adapter",
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 460
    },
    "return": "void",
    "signature": "public void connect(ReactiveAdapter adapter, Object returnValue)",
    "source_code": "\t\tpublic void connect(ReactiveAdapter adapter, Object returnValue) {\n\t\t\tPublisher<Object> publisher = adapter.toPublisher(returnValue);\n\t\t\tpublisher.subscribe(this);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#createProblemDetail(ex,status,defaultDetail,detailMessageCode,detailMessageArguments,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method to create a {@link ProblemDetail} for any exception\n\t * that doesn't implement {@link ErrorResponse}, also performing a\n\t * {@link MessageSource} lookup for the \"detail\" field.\n\t * @param ex the exception being handled\n\t * @param status the status to associate with the exception\n\t * @param defaultDetail default value for the \"detail\" field\n\t * @param detailMessageCode the code to use to look up the \"detail\" field\n\t * through a {@code MessageSource}, falling back on\n\t * {@link ErrorResponse#getDefaultDetailMessageCode(Class, String)}\n\t * @param detailMessageArguments the arguments to go with the detailMessageCode\n\t * @param request the current request\n\t * @return the created {@code ProblemDetail} instance\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "status",
      "defaultDetail",
      "detailMessageCode",
      "detailMessageArguments",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 516
    },
    "return": "ProblemDetail",
    "signature": "protected ProblemDetail createProblemDetail(Exception ex, HttpStatusCode status, String defaultDetail, @Nullable String detailMessageCode,\n\t\t\t@Nullable Object[] detailMessageArguments, WebRequest request)",
    "source_code": "\tprotected ProblemDetail createProblemDetail(\n\t\t\tException ex, HttpStatusCode status, String defaultDetail, @Nullable String detailMessageCode,\n\t\t\t@Nullable Object[] detailMessageArguments, WebRequest request) {\n\n\t\tErrorResponse.Builder builder = ErrorResponse.builder(ex, status, defaultDetail);\n\t\tif (detailMessageCode != null) {\n\t\t\tbuilder.detailMessageCode(detailMessageCode);\n\t\t}\n\t\tif (detailMessageArguments != null) {\n\t\t\tbuilder.detailMessageArguments(detailMessageArguments);\n\t\t}\n\t\treturn builder.build().updateAndGetBody(this.messageSource, LocaleContextHolder.getLocale());\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#createRequestMappingInfo(requestMapping,customCondition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RequestMappingInfo} from the supplied\n\t * {@link RequestMapping @RequestMapping} annotation, which is either\n\t * a directly declared annotation, a meta-annotation, or the synthesized\n\t * result of merging annotation attributes within an annotation hierarchy.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "requestMapping",
      "customCondition"
    ],
    "position": {
      "column": 1,
      "line": 383
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo createRequestMappingInfo(RequestMapping requestMapping, @Nullable RequestCondition<?> customCondition)",
    "source_code": "\tprotected RequestMappingInfo createRequestMappingInfo(\n\t\t\tRequestMapping requestMapping, @Nullable RequestCondition<?> customCondition) {\n\n\t\tRequestMappingInfo.Builder builder = RequestMappingInfo\n\t\t\t\t.paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))\n\t\t\t\t.methods(requestMapping.method())\n\t\t\t\t.params(requestMapping.params())\n\t\t\t\t.headers(requestMapping.headers())\n\t\t\t\t.consumes(requestMapping.consumes())\n\t\t\t\t.produces(requestMapping.produces())\n\t\t\t\t.mappingName(requestMapping.name());\n\t\tif (customCondition != null) {\n\t\t\tbuilder.customCondition(customCondition);\n\t\t}\n\t\treturn builder.options(this.config).build();\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#createResponseEntity(body,headers,statusCode,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the {@link ResponseEntity} to use from the given body, headers,\n\t * and statusCode. Subclasses can override this method to inspect and possibly\n\t * modify the body, headers, or statusCode, e.g. to re-create an instance of\n\t * {@link ProblemDetail} as an extension of {@link ProblemDetail}.\n\t * @param body the body to use for the response\n\t * @param headers the headers to use for the response\n\t * @param statusCode the status code to use for the response\n\t * @param request the current request\n\t * @return the {@code ResponseEntity} instance to use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "body",
      "headers",
      "statusCode",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 586
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> createResponseEntity(@Nullable Object body, HttpHeaders headers, HttpStatusCode statusCode, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> createResponseEntity(\n\t\t\t@Nullable Object body, HttpHeaders headers, HttpStatusCode statusCode, WebRequest request) {\n\n\t\treturn new ResponseEntity<>(body, headers, statusCode);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#getLastModifiedInternal(request,handlerMethod)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation always returns -1. An {@code @RequestMapping} method can\n\t * calculate the lastModified value, call {@link WebRequest#checkNotModified(long)},\n\t * and return {@code null} if the result of that call is {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 819
    },
    "return": "long",
    "signature": "protected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod)",
    "source_code": "\tprotected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod) {\n\t\treturn -1;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#getMappingForMethod(method,handlerType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Uses method and type-level @{@link RequestMapping} annotations to create\n\t * the RequestMappingInfo.\n\t * @return the created RequestMappingInfo, or {@code null} if the method\n\t * does not have a {@code @RequestMapping} annotation.\n\t * @see #getCustomMethodCondition(Method)\n\t * @see #getCustomTypeCondition(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n\t\tRequestMappingInfo info = createRequestMappingInfo(method);\n\t\tif (info != null) {\n\t\t\tRequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);\n\t\t\tif (typeInfo != null) {\n\t\t\t\tinfo = typeInfo.combine(info);\n\t\t\t}\n\t\t\tString prefix = getPathPrefix(handlerType);\n\t\t\tif (prefix != null) {\n\t\t\t\tinfo = RequestMappingInfo.paths(prefix).options(this.config).build().combine(info);\n\t\t\t}\n\t\t}\n\t\treturn info;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleAsyncRequestTimeoutException(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link AsyncRequestTimeoutException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 4.2.8\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleAsyncRequestTimeoutException(AsyncRequestTimeoutException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleAsyncRequestTimeoutException(\n\t\t\tAsyncRequestTimeoutException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleBindException(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link BindException}.\n\t * <p>By default this method creates a {@link ProblemDetail} with the status\n\t * and a short detail message, and then delegates to\n\t * {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @deprecated as of 6.0 since {@link org.springframework.web.method.annotation.ModelAttributeMethodProcessor}\n\t * now raises the {@link MethodArgumentNotValidException} subclass instead.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleBindException(BindException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleBindException(\n\t\t\tBindException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\tProblemDetail body = ProblemDetail.forStatusAndDetail(status, \"Failed to bind request\");\n\t\treturn handleExceptionInternal(ex, body, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleConversionNotSupported(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link ConversionNotSupportedException}.\n\t * <p>By default this method creates a {@link ProblemDetail} with the status\n\t * and a short detail message, and also looks up an override for the detail\n\t * via {@link MessageSource}, before delegating to\n\t * {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleConversionNotSupported(ConversionNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleConversionNotSupported(\n\t\t\tConversionNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\tObject[] args = {ex.getPropertyName(), ex.getValue()};\n\t\tString defaultDetail = \"Failed to convert '\" + args[0] + \"' with value: '\" + args[1] + \"'\";\n\t\tProblemDetail body = createProblemDetail(ex, status, defaultDetail, null, args, request);\n\n\t\treturn handleExceptionInternal(ex, body, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleEmptyBody(body,inputMessage,parameter,targetType,converterType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "inputMessage",
      "parameter",
      "targetType",
      "converterType"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "Object",
    "signature": "public Object handleEmptyBody(@Nullable Object body, HttpInputMessage inputMessage, MethodParameter parameter,\n\t\t\tType targetType, Class<? extends HttpMessageConverter<?>> converterType)",
    "source_code": "\tpublic Object handleEmptyBody(@Nullable Object body, HttpInputMessage inputMessage, MethodParameter parameter,\n\t\t\tType targetType, Class<? extends HttpMessageConverter<?>> converterType) {\n\n\t\tfor (RequestBodyAdvice advice : getMatchingAdvice(parameter, RequestBodyAdvice.class)) {\n\t\t\tif (advice.supports(parameter, targetType, converterType)) {\n\t\t\t\tbody = advice.handleEmptyBody(body, inputMessage, parameter, targetType, converterType);\n\t\t\t}\n\t\t}\n\t\treturn body;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleErrorResponseException(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of any {@link ErrorResponseException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleErrorResponseException(ErrorResponseException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleErrorResponseException(\n\t\t\tErrorResponseException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleException(ex,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "ResponseEntity<Object>",
    "signature": "public ResponseEntity<Object> handleException(Exception ex, WebRequest request)",
    "source_code": "\tpublic final ResponseEntity<Object> handleException(Exception ex, WebRequest request) throws Exception {\n\t\tif (ex instanceof HttpRequestMethodNotSupportedException subEx) {\n\t\t\treturn handleHttpRequestMethodNotSupported(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof HttpMediaTypeNotSupportedException subEx) {\n\t\t\treturn handleHttpMediaTypeNotSupported(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof HttpMediaTypeNotAcceptableException subEx) {\n\t\t\treturn handleHttpMediaTypeNotAcceptable(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof MissingPathVariableException subEx) {\n\t\t\treturn handleMissingPathVariable(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof MissingServletRequestParameterException subEx) {\n\t\t\treturn handleMissingServletRequestParameter(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof MissingServletRequestPartException subEx) {\n\t\t\treturn handleMissingServletRequestPart(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof ServletRequestBindingException subEx) {\n\t\t\treturn handleServletRequestBindingException(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof MethodArgumentNotValidException subEx) {\n\t\t\treturn handleMethodArgumentNotValid(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof NoHandlerFoundException subEx) {\n\t\t\treturn handleNoHandlerFoundException(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof AsyncRequestTimeoutException subEx) {\n\t\t\treturn handleAsyncRequestTimeoutException(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof ErrorResponseException subEx) {\n\t\t\treturn handleErrorResponseException(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\n\t\t// Lower level exceptions, and exceptions used symmetrically on client and server\n\n\t\tHttpHeaders headers = new HttpHeaders();\n\t\tif (ex instanceof ConversionNotSupportedException theEx) {\n\t\t\treturn handleConversionNotSupported(theEx, headers, HttpStatus.INTERNAL_SERVER_ERROR, request);\n\t\t}\n\t\telse if (ex instanceof TypeMismatchException theEx) {\n\t\t\treturn handleTypeMismatch(theEx, headers, HttpStatus.BAD_REQUEST, request);\n\t\t}\n\t\telse if (ex instanceof HttpMessageNotReadableException theEx) {\n\t\t\treturn handleHttpMessageNotReadable(theEx, headers, HttpStatus.BAD_REQUEST, request);\n\t\t}\n\t\telse if (ex instanceof HttpMessageNotWritableException theEx) {\n\t\t\treturn handleHttpMessageNotWritable(theEx, headers, HttpStatus.INTERNAL_SERVER_ERROR, request);\n\t\t}\n\t\telse if (ex instanceof BindException theEx) {\n\t\t\treturn handleBindException(theEx, headers, HttpStatus.BAD_REQUEST, request);\n\t\t}\n\t\telse {\n\t\t\t// Unknown exception, typically a wrapper with a common MVC exception as cause\n\t\t\t// (since @ExceptionHandler type declarations also match nested causes):\n\t\t\t// We only deal with top-level MVC exceptions here, so let's rethrow the given\n\t\t\t// exception for further processing through the HandlerExceptionResolver chain.\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleExceptionInternal(ex,body,headers,statusCode,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Internal handler method that all others in this class delegate to, for\n\t * common handling, and for the creation of a {@link ResponseEntity}.\n\t * <p>The default implementation does the following:\n\t * <ul>\n\t * <li>return {@code null} if response is already committed\n\t * <li>set the {@code \"jakarta.servlet.error.exception\"} request attribute\n\t * if the response status is 500 (INTERNAL_SERVER_ERROR).\n\t * <li>extract the {@link ErrorResponse#getBody() body} from\n\t * {@link ErrorResponse} exceptions, if the {@code body} is {@code null}.\n\t * </ul>\n\t * @param ex the exception to handle\n\t * @param body the body to use for the response\n\t * @param headers the headers to use for the response\n\t * @param statusCode the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "body",
      "headers",
      "statusCode",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 550
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleExceptionInternal(Exception ex, @Nullable Object body, HttpHeaders headers, HttpStatusCode statusCode, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleExceptionInternal(\n\t\t\tException ex, @Nullable Object body, HttpHeaders headers, HttpStatusCode statusCode, WebRequest request) {\n\n\t\tif (request instanceof ServletWebRequest servletWebRequest) {\n\t\t\tHttpServletResponse response = servletWebRequest.getResponse();\n\t\t\tif (response != null && response.isCommitted()) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Response already committed. Ignoring: \" + ex);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (statusCode.equals(HttpStatus.INTERNAL_SERVER_ERROR)) {\n\t\t\trequest.setAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE, ex, WebRequest.SCOPE_REQUEST);\n\t\t}\n\n\t\tif (body == null && ex instanceof ErrorResponse errorResponse) {\n\t\t\tbody = errorResponse.updateAndGetBody(this.messageSource, LocaleContextHolder.getLocale());\n\t\t}\n\n\t\treturn createResponseEntity(body, headers, statusCode, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleHttpMediaTypeNotAcceptable(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HttpMediaTypeNotAcceptableException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHttpMediaTypeNotAcceptable(HttpMediaTypeNotAcceptableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHttpMediaTypeNotAcceptable(\n\t\t\tHttpMediaTypeNotAcceptableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleHttpMediaTypeNotSupported(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HttpMediaTypeNotSupportedException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHttpMediaTypeNotSupported(HttpMediaTypeNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHttpMediaTypeNotSupported(\n\t\t\tHttpMediaTypeNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleHttpMessageNotReadable(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HttpMessageNotReadableException}.\n\t * <p>By default this method creates a {@link ProblemDetail} with the status\n\t * and a short detail message, and also looks up an override for the detail\n\t * via {@link MessageSource}, before delegating to\n\t * {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 450
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHttpMessageNotReadable(HttpMessageNotReadableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHttpMessageNotReadable(\n\t\t\tHttpMessageNotReadableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\tProblemDetail body = createProblemDetail(ex, status, \"Failed to read request\", null, null, request);\n\t\treturn handleExceptionInternal(ex, body, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleHttpMessageNotWritable(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HttpMessageNotWritableException}.\n\t * <p>By default this method creates a {@link ProblemDetail} with the status\n\t * and a short detail message, and also looks up an override for the detail\n\t * via {@link MessageSource}, before delegating to\n\t * {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHttpMessageNotWritable(HttpMessageNotWritableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHttpMessageNotWritable(\n\t\t\tHttpMessageNotWritableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\tProblemDetail body = createProblemDetail(ex, status, \"Failed to write request\", null, null, request);\n\t\treturn handleExceptionInternal(ex, body, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleHttpRequestMethodNotSupported(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HttpRequestMethodNotSupportedException}.\n\t * <p>This method logs a warning and delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHttpRequestMethodNotSupported(HttpRequestMethodNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHttpRequestMethodNotSupported(\n\t\t\tHttpRequestMethodNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\tpageNotFoundLogger.warn(ex.getMessage());\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleInternal(request,response,handlerMethod)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 775
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleInternal(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod)",
    "source_code": "\tprotected ModelAndView handleInternal(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\n\t\tModelAndView mav;\n\t\tcheckRequest(request);\n\n\t\t// Execute invokeHandlerMethod in synchronized block if required.\n\t\tif (this.synchronizeOnSession) {\n\t\t\tHttpSession session = request.getSession(false);\n\t\t\tif (session != null) {\n\t\t\t\tObject mutex = WebUtils.getSessionMutex(session);\n\t\t\t\tsynchronized (mutex) {\n\t\t\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// No HttpSession available -> no mutex necessary\n\t\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// No synchronization on session demanded at all...\n\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t\t}\n\n\t\tif (!response.containsHeader(HEADER_CACHE_CONTROL)) {\n\t\t\tif (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {\n\t\t\t\tapplyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprepareResponse(response);\n\t\t\t}\n\t\t}\n\n\t\treturn mav;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMethodArgumentNotValid(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MethodArgumentNotValidException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMethodArgumentNotValid(\n\t\t\tMethodArgumentNotValidException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMissingPathVariable(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MissingPathVariableException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMissingPathVariable(MissingPathVariableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMissingPathVariable(\n\t\t\tMissingPathVariableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMissingServletRequestParameter(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MissingServletRequestParameterException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMissingServletRequestParameter(MissingServletRequestParameterException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMissingServletRequestParameter(\n\t\t\tMissingServletRequestParameterException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMissingServletRequestPart(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MissingServletRequestPartException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMissingServletRequestPart(MissingServletRequestPartException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMissingServletRequestPart(\n\t\t\tMissingServletRequestPartException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleNoHandlerFoundException(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link NoHandlerFoundException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleNoHandlerFoundException(NoHandlerFoundException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleNoHandlerFoundException(\n\t\t\tNoHandlerFoundException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)\n\t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n\n\t\tmavContainer.setRequestHandled(true);\n\t\tServletServerHttpRequest inputMessage = createInputMessage(webRequest);\n\t\tServletServerHttpResponse outputMessage = createOutputMessage(webRequest);\n\n\t\tif (returnValue instanceof ProblemDetail detail) {\n\t\t\toutputMessage.setStatusCode(HttpStatusCode.valueOf(detail.getStatus()));\n\t\t\tif (detail.getInstance() == null) {\n\t\t\t\tURI path = URI.create(inputMessage.getServletRequest().getRequestURI());\n\t\t\t\tdetail.setInstance(path);\n\t\t\t}\n\t\t}\n\n\t\t// Try even with null return value. ResponseBodyAdvice could get involved.\n\t\twriteWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleServletRequestBindingException(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link ServletRequestBindingException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 310
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleServletRequestBindingException(ServletRequestBindingException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleServletRequestBindingException(\n\t\t\tServletRequestBindingException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleTypeMismatch(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link TypeMismatchException}.\n\t * <p>By default this method creates a {@link ProblemDetail} with the status\n\t * and a short detail message, and also looks up an override for the detail\n\t * via {@link MessageSource}, before delegating to\n\t * {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 425
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleTypeMismatch(TypeMismatchException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleTypeMismatch(\n\t\t\tTypeMismatchException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\tObject[] args = {ex.getPropertyName(), ex.getValue()};\n\t\tString defaultDetail = \"Failed to convert '\" + args[0] + \"' with value: '\" + args[1] + \"'\";\n\t\tString messageCode = ErrorResponse.getDefaultDetailMessageCode(TypeMismatchException.class, null);\n\t\tProblemDetail body = createProblemDetail(ex, status, defaultDetail, messageCode, args, request);\n\n\t\treturn handleExceptionInternal(ex, body, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleValue(returnValue,returnType,mav,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given reactive return value and decide whether to adapt it\n\t * to a {@link ResponseBodyEmitter} or a {@link DeferredResult}.\n\t * @return an emitter for streaming, or {@code null} if handled internally\n\t * with a {@link DeferredResult}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mav",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "ResponseBodyEmitter",
    "signature": "public ResponseBodyEmitter handleValue(Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mav, NativeWebRequest request)",
    "source_code": "\tpublic ResponseBodyEmitter handleValue(Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mav, NativeWebRequest request) throws Exception {\n\n\t\tAssert.notNull(returnValue, \"Expected return value\");\n\t\tClass<?> clazz = returnValue.getClass();\n\t\tReactiveAdapter adapter = this.adapterRegistry.getAdapter(clazz);\n\t\tAssert.state(adapter != null, () -> \"Unexpected return value type: \" + clazz);\n\n\t\tif (isContextPropagationPresent) {\n\t\t\treturnValue = ContextSnapshotHelper.writeReactorContext(returnValue);\n\t\t}\n\n\t\tResolvableType elementType = ResolvableType.forMethodParameter(returnType).getGeneric();\n\t\tClass<?> elementClass = elementType.toClass();\n\n\t\tCollection<MediaType> mediaTypes = getMediaTypes(request);\n\t\tOptional<MediaType> mediaType = mediaTypes.stream().filter(MimeType::isConcrete).findFirst();\n\n\t\tif (adapter.isMultiValue()) {\n\t\t\tif (mediaTypes.stream().anyMatch(MediaType.TEXT_EVENT_STREAM::includes) ||\n\t\t\t\t\tServerSentEvent.class.isAssignableFrom(elementClass)) {\n\t\t\t\tlogExecutorWarning(returnType);\n\t\t\t\tSseEmitter emitter = new SseEmitter(STREAMING_TIMEOUT_VALUE);\n\t\t\t\tnew SseEmitterSubscriber(emitter, this.taskExecutor).connect(adapter, returnValue);\n\t\t\t\treturn emitter;\n\t\t\t}\n\t\t\tif (CharSequence.class.isAssignableFrom(elementClass)) {\n\t\t\t\tlogExecutorWarning(returnType);\n\t\t\t\tResponseBodyEmitter emitter = getEmitter(mediaType.orElse(MediaType.TEXT_PLAIN));\n\t\t\t\tnew TextEmitterSubscriber(emitter, this.taskExecutor).connect(adapter, returnValue);\n\t\t\t\treturn emitter;\n\t\t\t}\n\t\t\tfor (MediaType type : mediaTypes) {\n\t\t\t\tfor (MediaType streamingType : JSON_STREAMING_MEDIA_TYPES) {\n\t\t\t\t\tif (streamingType.includes(type)) {\n\t\t\t\t\t\tlogExecutorWarning(returnType);\n\t\t\t\t\t\tResponseBodyEmitter emitter = getEmitter(streamingType);\n\t\t\t\t\t\tnew JsonEmitterSubscriber(emitter, this.taskExecutor).connect(adapter, returnValue);\n\t\t\t\t\t\treturn emitter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Not streaming...\n\t\tDeferredResult<Object> result = new DeferredResult<>();\n\t\tnew DeferredResultSubscriber(result, adapter, elementType).connect(adapter, returnValue);\n\t\tWebAsyncUtils.getAsyncManager(request).startDeferredResultProcessing(result, mav);\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#initCorsConfiguration(handler,method,mappingInfo)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mappingInfo"
    ],
    "position": {
      "column": 1,
      "line": 468
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mappingInfo)",
    "source_code": "\tprotected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mappingInfo) {\n\t\tHandlerMethod handlerMethod = createHandlerMethod(handler, method);\n\t\tClass<?> beanType = handlerMethod.getBeanType();\n\t\tCrossOrigin typeAnnotation = AnnotatedElementUtils.findMergedAnnotation(beanType, CrossOrigin.class);\n\t\tCrossOrigin methodAnnotation = AnnotatedElementUtils.findMergedAnnotation(method, CrossOrigin.class);\n\n\t\tif (typeAnnotation == null && methodAnnotation == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tCorsConfiguration config = new CorsConfiguration();\n\t\tupdateCorsConfig(config, typeAnnotation);\n\t\tupdateCorsConfig(config, methodAnnotation);\n\n\t\tif (CollectionUtils.isEmpty(config.getAllowedMethods())) {\n\t\t\tfor (RequestMethod allowedMethod : mappingInfo.getMethodsCondition().getMethods()) {\n\t\t\t\tconfig.addAllowedMethod(allowedMethod.name());\n\t\t\t}\n\t\t}\n\t\treturn config.applyPermitDefaultValues();\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#invokeHandlerMethod(request,response,handlerMethod)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the {@link RequestMapping} handler method preparing a {@link ModelAndView}\n\t * if view resolution is required.\n\t * @since 4.2\n\t * @see #createInvocableHandlerMethod(HandlerMethod)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 842
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod)",
    "source_code": "\tprotected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\n\t\tServletWebRequest webRequest = new ServletWebRequest(request, response);\n\t\tWebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);\n\t\tModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);\n\n\t\tServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);\n\t\tif (this.argumentResolvers != null) {\n\t\t\tinvocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\n\t\t}\n\t\tif (this.returnValueHandlers != null) {\n\t\t\tinvocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\n\t\t}\n\t\tinvocableMethod.setDataBinderFactory(binderFactory);\n\t\tinvocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);\n\n\t\tModelAndViewContainer mavContainer = new ModelAndViewContainer();\n\t\tmavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));\n\t\tmodelFactory.initModel(webRequest, mavContainer, invocableMethod);\n\t\tmavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);\n\n\t\tAsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);\n\t\tasyncWebRequest.setTimeout(this.asyncRequestTimeout);\n\n\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\t\tasyncManager.setTaskExecutor(this.taskExecutor);\n\t\tasyncManager.setAsyncWebRequest(asyncWebRequest);\n\t\tasyncManager.registerCallableInterceptors(this.callableInterceptors);\n\t\tasyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);\n\n\t\tif (asyncManager.hasConcurrentResult()) {\n\t\t\tObject result = asyncManager.getConcurrentResult();\n\t\t\tmavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];\n\t\t\tasyncManager.clearConcurrentResult();\n\t\t\tLogFormatUtils.traceDebug(logger, traceOn -> {\n\t\t\t\tString formatted = LogFormatUtils.formatValue(result, !traceOn);\n\t\t\t\treturn \"Resume with async result [\" + formatted + \"]\";\n\t\t\t});\n\t\t\tinvocableMethod = invocableMethod.wrapConcurrentResult(result);\n\t\t}\n\n\t\tinvocableMethod.invokeAndHandle(webRequest, mavContainer);\n\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn getModelAndView(mavContainer, modelFactory, webRequest);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#match(request,pattern)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 456
    },
    "return": "RequestMatchResult",
    "signature": "public RequestMatchResult match(HttpServletRequest request, String pattern)",
    "source_code": "\tpublic RequestMatchResult match(HttpServletRequest request, String pattern) {\n\t\tAssert.state(getPatternParser() == null, \"This HandlerMapping uses PathPatterns.\");\n\t\tRequestMappingInfo info = RequestMappingInfo.paths(pattern).options(this.config).build();\n\t\tRequestMappingInfo match = info.getMatchingCondition(request);\n\t\treturn (match != null && match.getPatternsCondition() != null ?\n\t\t\t\tnew RequestMatchResult(\n\t\t\t\t\t\tmatch.getPatternsCondition().getPatterns().iterator().next(),\n\t\t\t\t\t\tUrlPathHelper.getResolvedLookupPath(request),\n\t\t\t\t\t\tgetPathMatcher()) : null);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#readWithMessageConverters(webRequest,parameter,paramType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "webRequest",
      "parameter",
      "paramType"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "Object",
    "signature": "protected Object readWithMessageConverters(NativeWebRequest webRequest, MethodParameter parameter,\n\t\t\tType paramType)",
    "source_code": "\tprotected <T> Object readWithMessageConverters(NativeWebRequest webRequest, MethodParameter parameter,\n\t\t\tType paramType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException {\n\n\t\tHttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);\n\t\tAssert.state(servletRequest != null, \"No HttpServletRequest\");\n\t\tServletServerHttpRequest inputMessage = new ServletServerHttpRequest(servletRequest);\n\n\t\tObject arg = readWithMessageConverters(inputMessage, parameter, paramType);\n\t\tif (arg == null && checkRequired(parameter)) {\n\t\t\tthrow new HttpMessageNotReadableException(\"Required request body is missing: \" +\n\t\t\t\t\tparameter.getExecutable().toGenericString(), inputMessage);\n\t\t}\n\t\treturn arg;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#registerHandlerMethod(handler,method,mapping)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p><strong>Note:</strong> To create the {@link RequestMappingInfo},\n\t * please use {@link #getBuilderConfiguration()} and set the options on\n\t * {@link RequestMappingInfo.Builder#options(RequestMappingInfo.BuilderConfiguration)}\n\t * to match how this {@code HandlerMapping} is configured. This\n\t * is important for example to ensure use of\n\t * {@link org.springframework.web.util.pattern.PathPattern} or\n\t * {@link org.springframework.util.PathMatcher} based matching.\n\t * @param handler the bean name of the handler or the handler instance\n\t * @param method the method to register\n\t * @param mapping the mapping conditions associated with the handler method\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "void",
    "signature": "protected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping)",
    "source_code": "\tprotected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping) {\n\t\tsuper.registerHandlerMethod(handler, method, mapping);\n\t\tupdateConsumesCondition(mapping, method);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#registerMapping(mapping,handler,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 418
    },
    "return": "void",
    "signature": "public void registerMapping(RequestMappingInfo mapping, Object handler, Method method)",
    "source_code": "\tpublic void registerMapping(RequestMappingInfo mapping, Object handler, Method method) {\n\t\tsuper.registerMapping(mapping, handler, method);\n\t\tupdateConsumesCondition(mapping, method);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#resolveArgument(parameter,mavContainer,webRequest,binderFactory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Throws MethodArgumentNotValidException if validation fails.\n\t * @throws HttpMessageNotReadableException if {@link RequestBody#required()}\n\t * is {@code true} and there is no body content or if there is no suitable\n\t * converter to read the content with.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "mavContainer",
      "webRequest",
      "binderFactory"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "Object",
    "signature": "public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)",
    "source_code": "\tpublic Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n\t\tparameter = parameter.nestedIfOptional();\n\t\tObject arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());\n\t\tString name = Conventions.getVariableNameForParameter(parameter);\n\n\t\tif (binderFactory != null) {\n\t\t\tWebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);\n\t\t\tif (arg != null) {\n\t\t\t\tvalidateIfApplicable(binder, parameter);\n\t\t\t\tif (binder.getBindingResult().hasErrors() && isBindExceptionRequired(binder, parameter)) {\n\t\t\t\t\tthrow new MethodArgumentNotValidException(parameter, binder.getBindingResult());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mavContainer != null) {\n\t\t\t\tmavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());\n\t\t\t}\n\t\t}\n\n\t\treturn adaptArgumentIfNecessary(arg, parameter);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#send(data,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "data",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void send(Object data, @Nullable MediaType mediaType)",
    "source_code": "\t\tpublic void send(Object data, @Nullable MediaType mediaType) throws IOException {\n\t\t\tsendInternal(data, mediaType);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#setPathPrefixes(Map<String,prefixes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure path prefixes to apply to controller methods.\n\t * <p>Prefixes are used to enrich the mappings of every {@code @RequestMapping}\n\t * method whose controller type is matched by the corresponding\n\t * {@code Predicate}. The prefix for the first matching predicate is used.\n\t * <p>Consider using {@link org.springframework.web.method.HandlerTypePredicate\n\t * HandlerTypePredicate} to group controllers.\n\t * @param prefixes a map with path prefixes as key\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "prefixes"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "void",
    "signature": "public void setPathPrefixes(Map<String, Predicate<Class<?>>> prefixes)",
    "source_code": "\tpublic void setPathPrefixes(Map<String, Predicate<Class<?>>> prefixes) {\n\t\tthis.pathPrefixes = (!prefixes.isEmpty() ?\n\t\t\t\tCollections.unmodifiableMap(new LinkedHashMap<>(prefixes)) :\n\t\t\t\tCollections.emptyMap());\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#supports(param,type,converterType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "param",
      "type",
      "converterType"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "boolean",
    "signature": "public boolean supports(MethodParameter param, Type type, Class<? extends HttpMessageConverter<?>> converterType)",
    "source_code": "\tpublic boolean supports(MethodParameter param, Type type, Class<? extends HttpMessageConverter<?>> converterType) {\n\t\tthrow new UnsupportedOperationException(\"Not implemented\");\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#supports(returnType,converterType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType",
      "converterType"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "boolean",
    "signature": "public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType)",
    "source_code": "\tpublic boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {\n\t\tthrow new UnsupportedOperationException(\"Not implemented\");\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#addFixedVersionStrategy(version,pathPatterns)": {
    "deprecated": false,
    "doc": "\t * will also configure automatically a {@code \"/v1.0.0/js/**\"} with {@code \"v1.0.0\"} the\n\t * {@code version} String given as an argument.\n\t * @param version a version string\n\t * @param pathPatterns one or more resource URL path patterns,\n\t * relative to the pattern configured with the resource handler\n\t * @return the current instance for chained method invocation\n\t * @see FixedVersionStrategy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "version",
      "pathPatterns"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "VersionResourceResolver",
    "signature": "public VersionResourceResolver addFixedVersionStrategy(String version, String... pathPatterns)",
    "source_code": "\tpublic VersionResourceResolver addFixedVersionStrategy(String version, String... pathPatterns) {\n\t\tList<String> patternsList = Arrays.asList(pathPatterns);\n\t\tList<String> prefixedPatterns = new ArrayList<>(pathPatterns.length);\n\t\tString versionPrefix = \"/\" + version;\n\t\tfor (String pattern : patternsList) {\n\t\t\tprefixedPatterns.add(pattern);\n\t\t\tif (!pattern.startsWith(versionPrefix) && !patternsList.contains(versionPrefix + pattern)) {\n\t\t\t\tprefixedPatterns.add(versionPrefix + pattern);\n\t\t\t}\n\t\t}\n\t\treturn addVersionStrategy(new FixedVersionStrategy(version), StringUtils.toStringArray(prefixedPatterns));\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#addVersionStrategy(strategy,pathPatterns)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a custom VersionStrategy to apply to resource URLs that match the\n\t * given path patterns.\n\t * @param strategy the custom strategy\n\t * @param pathPatterns one or more resource URL path patterns,\n\t * relative to the pattern configured with the resource handler\n\t * @return the current instance for chained method invocation\n\t * @see VersionStrategy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "strategy",
      "pathPatterns"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "VersionResourceResolver",
    "signature": "public VersionResourceResolver addVersionStrategy(VersionStrategy strategy, String... pathPatterns)",
    "source_code": "\tpublic VersionResourceResolver addVersionStrategy(VersionStrategy strategy, String... pathPatterns) {\n\t\tfor (String pattern : pathPatterns) {\n\t\t\tgetStrategyMap().put(pattern, strategy);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#checkResource(resource,location)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform additional checks on a resolved resource beyond checking whether the\n\t * resource exists and is readable. The default implementation also verifies\n\t * the resource is either under the location relative to which it was found or\n\t * is under one of the {@linkplain #setAllowedLocations allowed locations}.\n\t * @param resource the resource to check\n\t * @param location the location relative to which the resource was found\n\t * @return \"true\" if resource is in a valid location, \"false\" otherwise.\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resource",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "boolean",
    "signature": "protected boolean checkResource(Resource resource, Resource location)",
    "source_code": "\tprotected boolean checkResource(Resource resource, Resource location) throws IOException {\n\t\tif (isResourceUnderLocation(resource, location)) {\n\t\t\treturn true;\n\t\t}\n\t\tResource[] allowedLocations = getAllowedLocations();\n\t\tif (allowedLocations != null) {\n\t\t\tfor (Resource current : allowedLocations) {\n\t\t\t\tif (isResourceUnderLocation(resource, current)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#doFilter(request,response,filterChain)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "void",
    "signature": "public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)",
    "source_code": "\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (!(request instanceof HttpServletRequest httpRequest) || !(response instanceof HttpServletResponse httpResponse)) {\n\t\t\tthrow new ServletException(\"ResourceUrlEncodingFilter only supports HTTP requests\");\n\t\t}\n\n\t\tResourceUrlEncodingRequestWrapper wrappedRequest =\n\t\t\t\tnew ResourceUrlEncodingRequestWrapper(httpRequest);\n\t\tResourceUrlEncodingResponseWrapper wrappedResponse =\n\t\t\t\tnew ResourceUrlEncodingResponseWrapper(wrappedRequest, httpResponse);\n\n\t\tfilterChain.doFilter(wrappedRequest, wrappedResponse);\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#extractLink(index,content,linksToAdd)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "index",
      "content",
      "linksToAdd"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "int",
    "signature": "protected int extractLink(int index, String content, SortedSet<ContentChunkInfo> linksToAdd)",
    "source_code": "\t\tprotected int extractLink(int index, String content, SortedSet<ContentChunkInfo> linksToAdd) {\n\t\t\t// A url() function without unquoted\n\t\t\treturn extractLink(index - 1, \")\", content, linksToAdd);\n\t\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#extractLink(index,endKey,content,linksToAdd)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "index",
      "endKey",
      "content",
      "linksToAdd"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "int",
    "signature": "protected int extractLink(int index, String endKey, String content, SortedSet<ContentChunkInfo> linksToAdd)",
    "source_code": "\t\tprotected int extractLink(int index, String endKey, String content, SortedSet<ContentChunkInfo> linksToAdd) {\n\t\t\tint start = index + 1;\n\t\t\tint end = content.indexOf(endKey, start);\n\t\t\tlinksToAdd.add(new ContentChunkInfo(start, end));\n\t\t\treturn end + endKey.length();\n\t\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#getForRequestUrl(request,requestUrl)": {
    "deprecated": false,
    "doc": "\t/**\n\t * A variation on {@link #getForLookupPath(String)} that accepts a full request\n\t * URL path (i.e. including context and servlet path) and returns the full request\n\t * URL path to expose for public use.\n\t * @param request the current request\n\t * @param requestUrl the request URL path to resolve\n\t * @return the resolved public URL path, or {@code null} if unresolved\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "requestUrl"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "String",
    "signature": "public String getForRequestUrl(HttpServletRequest request, String requestUrl)",
    "source_code": "\tpublic final String getForRequestUrl(HttpServletRequest request, String requestUrl) {\n\t\tint prefixIndex = getLookupPathIndex(request);\n\t\tint suffixIndex = getEndPathIndex(requestUrl);\n\t\tif (prefixIndex >= suffixIndex) {\n\t\t\treturn null;\n\t\t}\n\t\tString prefix = requestUrl.substring(0, prefixIndex);\n\t\tString suffix = requestUrl.substring(suffixIndex);\n\t\tString lookupPath = requestUrl.substring(prefixIndex, suffixIndex);\n\t\tString resolvedLookupPath = getForLookupPath(lookupPath);\n\t\treturn (resolvedLookupPath != null ? prefix + resolvedLookupPath + suffix : null);\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#getMediaType(request,resource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the media type for the given request and the resource matched\n\t * to it. This implementation tries to determine the MediaType using one of\n\t * the following lookups based on the resource filename and its path\n\t * extension:\n\t * <ol>\n\t * <li>{@link jakarta.servlet.ServletContext#getMimeType(String)}\n\t * <li>{@link #getMediaTypes()}\n\t * <li>{@link MediaTypeFactory#getMediaType(String)}\n\t * </ol>\n\t * @param request the current request\n\t * @param resource the resource to check\n\t * @return the corresponding media type, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 779
    },
    "return": "MediaType",
    "signature": "protected MediaType getMediaType(HttpServletRequest request, Resource resource)",
    "source_code": "\tprotected MediaType getMediaType(HttpServletRequest request, Resource resource) {\n\t\tMediaType result = null;\n\t\tString mimeType = request.getServletContext().getMimeType(resource.getFilename());\n\t\tif (StringUtils.hasText(mimeType)) {\n\t\t\tresult = MediaType.parseMediaType(mimeType);\n\t\t}\n\t\tif (result == null || MediaType.APPLICATION_OCTET_STREAM.equals(result)) {\n\t\t\tMediaType mediaType = null;\n\t\t\tString filename = resource.getFilename();\n\t\t\tString ext = StringUtils.getFilenameExtension(filename);\n\t\t\tif (ext != null) {\n\t\t\t\tmediaType = this.mediaTypes.get(ext.toLowerCase(Locale.ENGLISH));\n\t\t\t}\n\t\t\tif (mediaType == null) {\n\t\t\t\tList<MediaType> mediaTypes = MediaTypeFactory.getMediaTypes(filename);\n\t\t\t\tif (!CollectionUtils.isEmpty(mediaTypes)) {\n\t\t\t\t\tmediaType = mediaTypes.get(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mediaType != null) {\n\t\t\t\tresult = mediaType;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#getResource(resourcePath,location)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find the resource under the given location.\n\t * <p>The default implementation checks if there is a readable\n\t * {@code Resource} for the given path relative to the location.\n\t * @param resourcePath the path to the resource\n\t * @param location the location to check\n\t * @return the resource, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourcePath",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "Resource",
    "signature": "protected Resource getResource(String resourcePath, Resource location)",
    "source_code": "\tprotected Resource getResource(String resourcePath, Resource location) throws IOException {\n\t\tResource resource = location.createRelative(resourcePath);\n\t\tif (resource.isReadable()) {\n\t\t\tif (checkResource(resource, location)) {\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\tResource[] allowed = getAllowedLocations();\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Resource path \\\"\" + resourcePath + \"\\\" was successfully resolved \" +\n\t\t\t\t\t\t\t\t\"but resource \\\"\" + resource.getURL() + \"\\\" is neither under \" +\n\t\t\t\t\t\t\t\t\"the current location \\\"\" + location.getURL() + \"\\\" nor under any of \" +\n\t\t\t\t\t\t\t\t\"the allowed locations \" + (allowed != null ? Arrays.asList(allowed) : \"[]\"), -1, true));\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#handleRequest(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Processes a resource request.\n\t * <p>Checks for the existence of the requested resource in the configured list of locations.\n\t * If the resource does not exist, a {@code 404} response will be returned to the client.\n\t * If the resource exists, the request will be checked for the presence of the\n\t * {@code Last-Modified} header, and its value will be compared against the last-modified\n\t * timestamp of the given resource, returning a {@code 304} status code if the\n\t * {@code Last-Modified} value  is greater. If the resource is newer than the\n\t * {@code Last-Modified} value, or the header is not present, the content resource\n\t * of the resource will be written to the response with caching headers\n\t * set to expire one year in the future.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 551
    },
    "return": "void",
    "signature": "public void handleRequest(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tpublic void handleRequest(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\t// For very general mappings (e.g. \"/\") we need to check 404 first\n\t\tResource resource = getResource(request);\n\t\tif (resource == null) {\n\t\t\tlogger.debug(\"Resource not found\");\n\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND);\n\t\t\treturn;\n\t\t}\n\n\t\tif (HttpMethod.OPTIONS.matches(request.getMethod())) {\n\t\t\tresponse.setHeader(HttpHeaders.ALLOW, getAllowHeader());\n\t\t\treturn;\n\t\t}\n\n\t\t// Supported methods and required session\n\t\tcheckRequest(request);\n\n\t\t// Header phase\n\t\tif (isUseLastModified() && new ServletWebRequest(request, response).checkNotModified(resource.lastModified())) {\n\t\t\tlogger.trace(\"Resource not modified\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Apply cache settings, if any\n\t\tprepareResponse(response);\n\n\t\t// Check the media type for the resource\n\t\tMediaType mediaType = getMediaType(request, resource);\n\t\tsetHeaders(response, resource, mediaType);\n\n\t\t// Content phase\n\t\tServletServerHttpResponse outputMessage = new ServletServerHttpResponse(response);\n\t\tif (request.getHeader(HttpHeaders.RANGE) == null) {\n\t\t\tAssert.state(this.resourceHttpMessageConverter != null, \"Not initialized\");\n\n\t\t\tif (HttpMethod.HEAD.matches(request.getMethod())) {\n\t\t\t\tthis.resourceHttpMessageConverter.addDefaultHeaders(outputMessage, resource, mediaType);\n\t\t\t\toutputMessage.flush();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.resourceHttpMessageConverter.write(resource, mediaType, outputMessage);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tAssert.state(this.resourceRegionHttpMessageConverter != null, \"Not initialized\");\n\t\t\tServletServerHttpRequest inputMessage = new ServletServerHttpRequest(request);\n\t\t\ttry {\n\t\t\t\tList<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);\n\t\t\t\tthis.resourceRegionHttpMessageConverter.write(\n\t\t\t\t\t\tHttpRange.toResourceRegions(httpRanges, resource), mediaType, outputMessage);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tresponse.setHeader(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#parse(content,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void parse(String content, SortedSet<ContentChunkInfo> result)",
    "source_code": "\t\tpublic void parse(String content, SortedSet<ContentChunkInfo> result) {\n\t\t\tint position = 0;\n\t\t\twhile (true) {\n\t\t\t\tposition = content.indexOf(getKeyword(), position);\n\t\t\t\tif (position == -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tposition += getKeyword().length();\n\t\t\t\twhile (Character.isWhitespace(content.charAt(position))) {\n\t\t\t\t\tposition++;\n\t\t\t\t}\n\t\t\t\tif (content.charAt(position) == '\\'') {\n\t\t\t\t\tposition = extractLink(position, \"'\", content, result);\n\t\t\t\t}\n\t\t\t\telse if (content.charAt(position) == '\"') {\n\t\t\t\t\tposition = extractLink(position, \"\\\"\", content, result);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tposition = extractLink(position, content, result);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#resolveResourceInternal(request,requestPath,locations,chain)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "requestPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "Resource",
    "signature": "protected Resource resolveResourceInternal(@Nullable HttpServletRequest request, String requestPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected Resource resolveResourceInternal(@Nullable HttpServletRequest request, String requestPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\treturn getResource(requestPath, request, locations);\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#resolveUrlPathInternal(resourcePath,locations,chain)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourcePath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "String",
    "signature": "protected String resolveUrlPathInternal(String resourcePath, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain)",
    "source_code": "\tprotected String resolveUrlPathInternal(String resourcePath, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain) {\n\n\t\treturn (StringUtils.hasText(resourcePath) &&\n\t\t\t\tgetResource(resourcePath, null, locations) != null ? resourcePath : null);\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#resolveUrlPathInternal(resourceUrlPath,locations,chain)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourceUrlPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "String",
    "signature": "protected String resolveUrlPathInternal(String resourceUrlPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected String resolveUrlPathInternal(String resourceUrlPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\tString baseUrl = chain.resolveUrlPath(resourceUrlPath, locations);\n\t\tif (StringUtils.hasText(baseUrl)) {\n\t\t\tVersionStrategy versionStrategy = getStrategyForPath(resourceUrlPath);\n\t\t\tif (versionStrategy == null) {\n\t\t\t\treturn baseUrl;\n\t\t\t}\n\t\t\tResource resource = chain.resolveResource(null, baseUrl, locations);\n\t\t\tAssert.state(resource != null, \"Unresolvable resource\");\n\t\t\tString version = versionStrategy.getResourceVersion(resource);\n\t\t\treturn versionStrategy.addVersion(baseUrl, version);\n\t\t}\n\t\treturn baseUrl;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setAttribute(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "void",
    "signature": "public void setAttribute(String name, Object value)",
    "source_code": "\t\tpublic void setAttribute(String name, Object value) {\n\t\t\tsuper.setAttribute(name, value);\n\t\t\tif (ResourceUrlProviderExposingInterceptor.RESOURCE_URL_PROVIDER_ATTR.equals(name)) {\n\t\t\t\tif (value instanceof ResourceUrlProvider) {\n\t\t\t\t\tinitLookupPath((ResourceUrlProvider) value);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setHandlerMap(Map<String,handlerMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Manually configure the resource mappings.\n\t * <p><strong>Note:</strong> by default resource mappings are auto-detected\n\t * from the Spring {@code ApplicationContext}. However if this property is\n\t * used, the auto-detection is turned off.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "handlerMap"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void setHandlerMap(@Nullable Map<String, ResourceHttpRequestHandler> handlerMap)",
    "source_code": "\tpublic void setHandlerMap(@Nullable Map<String, ResourceHttpRequestHandler> handlerMap) {\n\t\tif (handlerMap != null) {\n\t\t\tthis.handlerMap.clear();\n\t\t\tthis.handlerMap.putAll(handlerMap);\n\t\t\tthis.autodetect = false;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setHeaders(response,resource,mediaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set headers on the given servlet response.\n\t * Called for GET requests as well as HEAD requests.\n\t * @param response current servlet response\n\t * @param resource the identified resource (never {@code null})\n\t * @param mediaType the resource's media type (never {@code null})\n\t * @throws IOException in case of errors while setting the headers\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "resource",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 813
    },
    "return": "void",
    "signature": "protected void setHeaders(HttpServletResponse response, Resource resource, @Nullable MediaType mediaType)",
    "source_code": "\tprotected void setHeaders(HttpServletResponse response, Resource resource, @Nullable MediaType mediaType)\n\t\t\tthrows IOException {\n\n\t\tif (mediaType != null) {\n\t\t\tresponse.setContentType(mediaType.toString());\n\t\t}\n\n\t\tif (resource instanceof HttpResource httpResource) {\n\t\t\tHttpHeaders resourceHeaders = httpResource.getResponseHeaders();\n\t\t\tresourceHeaders.forEach((headerName, headerValues) -> {\n\t\t\t\tboolean first = true;\n\t\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\t\tif (first) {\n\t\t\t\t\t\tresponse.setHeader(headerName, headerValue);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresponse.addHeader(headerName, headerValue);\n\t\t\t\t\t}\n\t\t\t\t\tfirst = false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tresponse.setHeader(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setLocationCharsets(Map<Resource,locationCharsets)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure charsets associated with locations. If a static resource is found\n\t * under a {@link org.springframework.core.io.UrlResource URL resource}\n\t * location the charset is used to encode the relative path\n\t * <p><strong>Note:</strong> the charset is used only if the\n\t * {@link #setUrlPathHelper urlPathHelper} property is also configured and\n\t * its {@code urlDecode} property is set to true.\n\t * @since 4.3.13\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Resource",
      "locationCharsets"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void setLocationCharsets(Map<Resource, Charset> locationCharsets)",
    "source_code": "\tpublic void setLocationCharsets(Map<Resource, Charset> locationCharsets) {\n\t\tthis.locationCharsets.clear();\n\t\tthis.locationCharsets.putAll(locationCharsets);\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setMediaTypes(Map<String,mediaTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add mappings between file extensions, extracted from the filename of a\n\t * static {@link Resource}, and corresponding media type to set on the\n\t * response.\n\t * <p>Use of this method is typically not necessary since mappings are\n\t * otherwise determined via\n\t * {@link jakarta.servlet.ServletContext#getMimeType(String)} or via\n\t * {@link MediaTypeFactory#getMediaType(Resource)}.\n\t * @param mediaTypes media type mappings\n\t * @since 5.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "mediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "void",
    "signature": "public void setMediaTypes(Map<String, MediaType> mediaTypes)",
    "source_code": "\tpublic void setMediaTypes(Map<String, MediaType> mediaTypes) {\n\t\tmediaTypes.forEach((ext, mediaType) ->\n\t\t\t\tthis.mediaTypes.put(ext.toLowerCase(Locale.ENGLISH), mediaType));\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setStrategyMap(Map<String,map)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Map with URL paths as keys and {@code VersionStrategy} as values.\n\t * <p>Supports direct URL matches and Ant-style pattern matches. For syntax\n\t * details, see the {@link org.springframework.util.AntPathMatcher} javadoc.\n\t * @param map a map with URLs as keys and version strategies as values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "public void setStrategyMap(Map<String, VersionStrategy> map)",
    "source_code": "\tpublic void setStrategyMap(Map<String, VersionStrategy> map) {\n\t\tthis.versionStrategyMap.clear();\n\t\tthis.versionStrategyMap.putAll(map);\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#transform(request,resource,transformerChain)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "resource",
      "transformerChain"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "Resource",
    "signature": "public Resource transform(HttpServletRequest request, Resource resource, ResourceTransformerChain transformerChain)",
    "source_code": "\tpublic Resource transform(HttpServletRequest request, Resource resource, ResourceTransformerChain transformerChain)\n\t\t\tthrows IOException {\n\n\t\tresource = transformerChain.transform(request, resource);\n\n\t\tString filename = resource.getFilename();\n\t\tif (!\"css\".equals(StringUtils.getFilenameExtension(filename)) ||\n\t\t\t\tresource instanceof EncodedResourceResolver.EncodedResource) {\n\t\t\treturn resource;\n\t\t}\n\n\t\tbyte[] bytes = FileCopyUtils.copyToByteArray(resource.getInputStream());\n\t\tString content = new String(bytes, DEFAULT_CHARSET);\n\n\t\tSortedSet<ContentChunkInfo> links = new TreeSet<>();\n\t\tfor (LinkParser parser : this.linkParsers) {\n\t\t\tparser.parse(content, links);\n\t\t}\n\n\t\tif (links.isEmpty()) {\n\t\t\treturn resource;\n\t\t}\n\n\t\tint index = 0;\n\t\tStringWriter writer = new StringWriter();\n\t\tfor (ContentChunkInfo linkContentChunkInfo : links) {\n\t\t\twriter.write(content.substring(index, linkContentChunkInfo.getStart()));\n\t\t\tString link = content.substring(linkContentChunkInfo.getStart(), linkContentChunkInfo.getEnd());\n\t\t\tString newLink = null;\n\t\t\tif (!hasScheme(link)) {\n\t\t\t\tString absolutePath = toAbsolutePath(link, request);\n\t\t\t\tnewLink = resolveUrlPath(absolutePath, request, resource, transformerChain);\n\t\t\t}\n\t\t\twriter.write(newLink != null ? newLink : link);\n\t\t\tindex = linkContentChunkInfo.getEnd();\n\t\t}\n\t\twriter.write(content.substring(index));\n\n\t\treturn new TransformedResource(resource, writer.toString().getBytes(DEFAULT_CHARSET));\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#findWebApplicationContext(request,servletContext)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look for the WebApplicationContext associated with the DispatcherServlet\n\t * that has initiated request processing, and for the global context if none\n\t * was found associated with the current request. The global context will\n\t * be found via the ServletContext or via ContextLoader's current context.\n\t * <p>NOTE: This variant remains compatible with Servlet 2.5, explicitly\n\t * checking a given ServletContext instead of deriving it from the request.\n\t * @param request current HTTP request\n\t * @param servletContext current servlet context\n\t * @return the request-specific WebApplicationContext, or the global one\n\t * if no request-specific context has been found, or {@code null} if none\n\t * @since 4.2.1\n\t * @see DispatcherServlet#WEB_APPLICATION_CONTEXT_ATTRIBUTE\n\t * @see WebApplicationContextUtils#getWebApplicationContext(ServletContext)\n\t * @see ContextLoader#getCurrentWebApplicationContext()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "WebApplicationContext",
    "signature": "public WebApplicationContext findWebApplicationContext(HttpServletRequest request, @Nullable ServletContext servletContext)",
    "source_code": "\tpublic static WebApplicationContext findWebApplicationContext(\n\t\t\tHttpServletRequest request, @Nullable ServletContext servletContext) {\n\n\t\tWebApplicationContext webApplicationContext = (WebApplicationContext) request.getAttribute(\n\t\t\t\tDispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE);\n\t\tif (webApplicationContext == null) {\n\t\t\tif (servletContext != null) {\n\t\t\t\twebApplicationContext = WebApplicationContextUtils.getWebApplicationContext(servletContext);\n\t\t\t}\n\t\t\tif (webApplicationContext == null) {\n\t\t\t\twebApplicationContext = ContextLoader.getCurrentWebApplicationContext();\n\t\t\t}\n\t\t}\n\t\treturn webApplicationContext;\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#saveOutputFlashMap(location,request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method that retrieves the {@link #getOutputFlashMap \"output\"\n\t * FlashMap}, updates it with the path and query params of the target URL,\n\t * and then saves it using the {@link #getFlashMapManager FlashMapManager}.\n\t * @param location the target URL for the redirect\n\t * @param request the current request\n\t * @param response the current response\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "public void saveOutputFlashMap(String location, HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tpublic static void saveOutputFlashMap(String location, HttpServletRequest request, HttpServletResponse response) {\n\t\tFlashMap flashMap = getOutputFlashMap(request);\n\t\tif (CollectionUtils.isEmpty(flashMap)) {\n\t\t\treturn;\n\t\t}\n\n\t\tUriComponents uriComponents = UriComponentsBuilder.fromUriString(location).build();\n\t\tflashMap.setTargetRequestPath(uriComponents.getPath());\n\t\tflashMap.addTargetRequestParams(uriComponents.getQueryParams());\n\n\t\tFlashMapManager manager = getFlashMapManager(request);\n\t\tAssert.state(manager != null, \"No FlashMapManager. Is this a DispatcherServlet handled request?\");\n\t\tmanager.saveOutputFlashMap(flashMap, request, response);\n\t}"
  },
  "org.springframework.web.servlet.tags.form.<unknown>#isSelected(bindStatus,candidateValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@code true} if the supplied candidate value is equal to the value bound to\n\t * the supplied {@link BindStatus}. Equality in this case differs from standard Java equality and\n\t * is described in more detail <a href=\"#equality-contract\">here</a>.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindStatus",
      "candidateValue"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "boolean",
    "signature": "public boolean isSelected(BindStatus bindStatus, @Nullable Object candidateValue)",
    "source_code": "\tpublic static boolean isSelected(BindStatus bindStatus, @Nullable Object candidateValue) {\n\t\t// Check obvious equality matches with the candidate first,\n\t\t// both with the rendered value and with the original value.\n\t\tObject boundValue = bindStatus.getValue();\n\t\tif (ObjectUtils.nullSafeEquals(boundValue, candidateValue)) {\n\t\t\treturn true;\n\t\t}\n\t\tObject actualValue = bindStatus.getActualValue();\n\t\tif (actualValue != null && actualValue != boundValue &&\n\t\t\t\tObjectUtils.nullSafeEquals(actualValue, candidateValue)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (actualValue != null) {\n\t\t\tboundValue = actualValue;\n\t\t}\n\t\telse if (boundValue == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Non-null value but no obvious equality with the candidate value:\n\t\t// go into more exhaustive comparisons.\n\t\tboolean selected = false;\n\t\tif (candidateValue != null) {\n\t\t\tif (boundValue.getClass().isArray()) {\n\t\t\t\tselected = collectionCompare(CollectionUtils.arrayToList(boundValue), candidateValue, bindStatus);\n\t\t\t}\n\t\t\telse if (boundValue instanceof Collection<?> collection) {\n\t\t\t\tselected = collectionCompare(collection, candidateValue, bindStatus);\n\t\t\t}\n\t\t\telse if (boundValue instanceof Map<?, ?> map) {\n\t\t\t\tselected = mapCompare(map, candidateValue, bindStatus);\n\t\t\t}\n\t\t}\n\t\tif (!selected) {\n\t\t\tselected = exhaustiveCompare(boundValue, candidateValue, bindStatus.getEditor(), null);\n\t\t}\n\t\treturn selected;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#appendCurrentQueryParams(targetUrl,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Append the query string of the current request to the target redirect URL.\n\t * @param targetUrl the StringBuilder to append the properties to\n\t * @param request the current request\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "void",
    "signature": "protected void appendCurrentQueryParams(StringBuilder targetUrl, HttpServletRequest request)",
    "source_code": "\tprotected void appendCurrentQueryParams(StringBuilder targetUrl, HttpServletRequest request) {\n\t\tString query = request.getQueryString();\n\t\tif (StringUtils.hasText(query)) {\n\t\t\t// Extract anchor fragment, if any.\n\t\t\tString fragment = null;\n\t\t\tint anchorIndex = targetUrl.indexOf(\"#\");\n\t\t\tif (anchorIndex > -1) {\n\t\t\t\tfragment = targetUrl.substring(anchorIndex);\n\t\t\t\ttargetUrl.delete(anchorIndex, targetUrl.length());\n\t\t\t}\n\n\t\t\tif (targetUrl.toString().indexOf('?') < 0) {\n\t\t\t\ttargetUrl.append('?').append(query);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttargetUrl.append('&').append(query);\n\t\t\t}\n\t\t\t// Append anchor fragment, if any, to end of URL.\n\t\t\tif (fragment != null) {\n\t\t\t\ttargetUrl.append(fragment);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#appendQueryProperties(targetUrl,Map<String,model,encodingScheme)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Append query properties to the redirect URL.\n\t * Stringifies, URL-encodes and formats model attributes as query properties.\n\t * @param targetUrl the StringBuilder to append the properties to\n\t * @param model a Map that contains model attributes\n\t * @param encodingScheme the encoding scheme to use\n\t * @throws UnsupportedEncodingException if string encoding failed\n\t * @see #queryProperties\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "Map<String",
      "model",
      "encodingScheme"
    ],
    "position": {
      "column": 1,
      "line": 445
    },
    "return": "void",
    "signature": "protected void appendQueryProperties(StringBuilder targetUrl, Map<String, Object> model, String encodingScheme)",
    "source_code": "\tprotected void appendQueryProperties(StringBuilder targetUrl, Map<String, Object> model, String encodingScheme)\n\t\t\tthrows UnsupportedEncodingException {\n\n\t\t// Extract anchor fragment, if any.\n\t\tString fragment = null;\n\t\tint anchorIndex = targetUrl.indexOf(\"#\");\n\t\tif (anchorIndex > -1) {\n\t\t\tfragment = targetUrl.substring(anchorIndex);\n\t\t\ttargetUrl.delete(anchorIndex, targetUrl.length());\n\t\t}\n\n\t\t// If there aren't already some parameters, we need a \"?\".\n\t\tboolean first = (targetUrl.toString().indexOf('?') < 0);\n\t\tfor (Map.Entry<String, Object> entry : queryProperties(model).entrySet()) {\n\t\t\tObject rawValue = entry.getValue();\n\t\t\tCollection<?> values;\n\t\t\tif (rawValue != null && rawValue.getClass().isArray()) {\n\t\t\t\tvalues = CollectionUtils.arrayToList(rawValue);\n\t\t\t}\n\t\t\telse if (rawValue instanceof Collection) {\n\t\t\t\tvalues = ((Collection<?>) rawValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = Collections.singleton(rawValue);\n\t\t\t}\n\t\t\tfor (Object value : values) {\n\t\t\t\tif (first) {\n\t\t\t\t\ttargetUrl.append('?');\n\t\t\t\t\tfirst = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttargetUrl.append('&');\n\t\t\t\t}\n\t\t\t\tString encodedKey = urlEncode(entry.getKey(), encodingScheme);\n\t\t\t\tString encodedValue = (value != null ? urlEncode(value.toString(), encodingScheme) : \"\");\n\t\t\t\ttargetUrl.append(encodedKey).append('=').append(encodedValue);\n\t\t\t}\n\t\t}\n\n\t\t// Append anchor fragment, if any, to end of URL.\n\t\tif (fragment != null) {\n\t\t\ttargetUrl.append(fragment);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#createTargetUrl(Map<String,model,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the target URL by checking if the redirect string is a URI template first,\n\t * expanding it with the given model, and then optionally appending simple type model\n\t * attributes as query String parameters.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "String",
    "signature": "protected String createTargetUrl(Map<String, Object> model, HttpServletRequest request)",
    "source_code": "\tprotected final String createTargetUrl(Map<String, Object> model, HttpServletRequest request)\n\t\t\tthrows UnsupportedEncodingException {\n\n\t\t// Prepare target URL.\n\t\tStringBuilder targetUrl = new StringBuilder();\n\t\tString url = getUrl();\n\t\tAssert.state(url != null, \"'url' not set\");\n\n\t\tif (this.contextRelative && getUrl().startsWith(\"/\")) {\n\t\t\t// Do not apply context path to relative URLs.\n\t\t\ttargetUrl.append(getContextPath(request));\n\t\t}\n\t\ttargetUrl.append(getUrl());\n\n\t\tString enc = this.encodingScheme;\n\t\tif (enc == null) {\n\t\t\tenc = request.getCharacterEncoding();\n\t\t}\n\t\tif (enc == null) {\n\t\t\tenc = WebUtils.DEFAULT_CHARACTER_ENCODING;\n\t\t}\n\n\t\tif (this.expandUriTemplateVariables && StringUtils.hasText(targetUrl)) {\n\t\t\tMap<String, String> variables = getCurrentRequestUriVariables(request);\n\t\t\ttargetUrl = replaceUriTemplateVariables(targetUrl.toString(), model, variables, enc);\n\t\t}\n\t\tif (isPropagateQueryProperties()) {\n\t\t\tappendCurrentQueryParams(targetUrl, request);\n\t\t}\n\t\tif (this.exposeModelAttributes) {\n\t\t\tappendQueryProperties(targetUrl, model, enc);\n\t\t}\n\n\t\treturn targetUrl.toString();\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#getHttp11StatusCode(request,response,targetUrl)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determines the status code to use for HTTP 1.1 compatible requests.\n\t * <p>The default implementation returns the {@link #setStatusCode(HttpStatusCode) statusCode}\n\t * property if set, or the value of the {@link #RESPONSE_STATUS_ATTRIBUTE} attribute.\n\t * If neither are set, it defaults to {@link HttpStatus#SEE_OTHER} (303).\n\t * @param request the request to inspect\n\t * @param response the servlet response\n\t * @param targetUrl the target URL\n\t * @return the response status\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "targetUrl"
    ],
    "position": {
      "column": 1,
      "line": 673
    },
    "return": "HttpStatusCode",
    "signature": "protected HttpStatusCode getHttp11StatusCode(HttpServletRequest request, HttpServletResponse response, String targetUrl)",
    "source_code": "\tprotected HttpStatusCode getHttp11StatusCode(\n\t\t\tHttpServletRequest request, HttpServletResponse response, String targetUrl) {\n\n\t\tif (this.statusCode != null) {\n\t\t\treturn this.statusCode;\n\t\t}\n\t\tHttpStatusCode attributeStatusCode = (HttpStatusCode) request.getAttribute(View.RESPONSE_STATUS_ATTRIBUTE);\n\t\tif (attributeStatusCode != null) {\n\t\t\treturn attributeStatusCode;\n\t\t}\n\t\treturn HttpStatus.SEE_OTHER;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#isEligibleProperty(key,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given model element should be exposed\n\t * as a query property.\n\t * <p>The default implementation considers Strings and primitives\n\t * as eligible, and also arrays and Collections/Iterables with\n\t * corresponding elements. This can be overridden in subclasses.\n\t * @param key the key of the model element\n\t * @param value the value of the model element\n\t * @return whether the element is eligible as query property\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 520
    },
    "return": "boolean",
    "signature": "protected boolean isEligibleProperty(String key, @Nullable Object value)",
    "source_code": "\tprotected boolean isEligibleProperty(String key, @Nullable Object value) {\n\t\tif (value == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (isEligibleValue(value)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (value.getClass().isArray()) {\n\t\t\tint length = Array.getLength(value);\n\t\t\tif (length == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tObject element = Array.get(value, i);\n\t\t\t\tif (!isEligibleValue(element)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (value instanceof Collection<?> coll) {\n\t\t\tif (coll.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (Object element : coll) {\n\t\t\t\tif (!isEligibleValue(element)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#queryProperties(Map<String,model)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine name-value pairs for query strings, which will be stringified,\n\t * URL-encoded and formatted by {@link #appendQueryProperties}.\n\t * <p>This implementation filters the model through checking\n\t * {@link #isEligibleProperty(String, Object)} for each element,\n\t * by default accepting Strings, primitives and primitive wrappers only.\n\t * @param model the original model Map\n\t * @return the filtered Map of eligible query properties\n\t * @see #isEligibleProperty(String, Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model"
    ],
    "position": {
      "column": 1,
      "line": 500
    },
    "return": "Object>",
    "signature": "protected Object> queryProperties(Map<String, Object> model)",
    "source_code": "\tprotected Map<String, Object> queryProperties(Map<String, Object> model) {\n\t\tMap<String, Object> result = new LinkedHashMap<>();\n\t\tmodel.forEach((name, value) -> {\n\t\t\tif (isEligibleProperty(name, value)) {\n\t\t\t\tresult.put(name, value);\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#render(Map<String,model,request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "void",
    "signature": "public void render(@Nullable Map<String, ?> model, HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\t\tpublic void render(@Nullable Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) {\n\t\t\tresponse.setStatus(HttpServletResponse.SC_NOT_ACCEPTABLE);\n\t\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#renderMergedOutputModel(Map<String,model,request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert model to request parameters and redirect to the given URL.\n\t * @see #appendQueryProperties\n\t * @see #sendRedirect\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "void",
    "signature": "protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response)",
    "source_code": "\tprotected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws IOException {\n\n\t\tString targetUrl = createTargetUrl(model, request);\n\t\ttargetUrl = updateTargetUrl(targetUrl, model, request, response);\n\n\t\t// Save flash attributes\n\t\tRequestContextUtils.saveOutputFlashMap(targetUrl, request, response);\n\n\t\t// Redirect\n\t\tsendRedirect(request, response, targetUrl, this.http10Compatible);\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#replaceUriTemplateVariables(targetUrl,Map<String,model,Map<String,currentUriVariables,encodingScheme)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Replace URI template variables in the target URL with encoded model\n\t * attributes or URI variables from the current request. Model attributes\n\t * referenced in the URL are removed from the model.\n\t * @param targetUrl the redirect URL\n\t * @param model a Map that contains model attributes\n\t * @param currentUriVariables current request URI variables to use\n\t * @param encodingScheme the encoding scheme to use\n\t * @throws UnsupportedEncodingException if string encoding failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "Map<String",
      "model",
      "Map<String",
      "currentUriVariables",
      "encodingScheme"
    ],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "StringBuilder",
    "signature": "protected StringBuilder replaceUriTemplateVariables(String targetUrl, Map<String, Object> model, Map<String, String> currentUriVariables, String encodingScheme)",
    "source_code": "\tprotected StringBuilder replaceUriTemplateVariables(\n\t\t\tString targetUrl, Map<String, Object> model, Map<String, String> currentUriVariables, String encodingScheme)\n\t\t\tthrows UnsupportedEncodingException {\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tMatcher matcher = URI_TEMPLATE_VARIABLE_PATTERN.matcher(targetUrl);\n\t\tint endLastMatch = 0;\n\t\twhile (matcher.find()) {\n\t\t\tString name = matcher.group(1);\n\t\t\tObject value = (model.containsKey(name) ? model.remove(name) : currentUriVariables.get(name));\n\t\t\tif (value == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Model has no value for key '\" + name + \"'\");\n\t\t\t}\n\t\t\tresult.append(targetUrl, endLastMatch, matcher.start());\n\t\t\tresult.append(UriUtils.encodePathSegment(value.toString(), encodingScheme));\n\t\t\tendLastMatch = matcher.end();\n\t\t}\n\t\tresult.append(targetUrl.substring(endLastMatch));\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#resolveViewName(viewName,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "View",
    "signature": "public View resolveViewName(String viewName, Locale locale)",
    "source_code": "\tpublic View resolveViewName(String viewName, Locale locale) throws Exception {\n\t\tRequestAttributes attrs = RequestContextHolder.getRequestAttributes();\n\t\tAssert.state(attrs instanceof ServletRequestAttributes, \"No current ServletRequestAttributes\");\n\t\tList<MediaType> requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());\n\t\tif (requestedMediaTypes != null) {\n\t\t\tList<View> candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);\n\t\t\tView bestView = getBestView(candidateViews, requestedMediaTypes, attrs);\n\t\t\tif (bestView != null) {\n\t\t\t\treturn bestView;\n\t\t\t}\n\t\t}\n\n\t\tString mediaTypeInfo = logger.isDebugEnabled() && requestedMediaTypes != null ?\n\t\t\t\t\" given \" + requestedMediaTypes.toString() : \"\";\n\n\t\tif (this.useNotAcceptableStatusCode) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Using 406 NOT_ACCEPTABLE\" + mediaTypeInfo);\n\t\t\t}\n\t\t\treturn NOT_ACCEPTABLE_VIEW;\n\t\t}\n\t\telse {\n\t\t\tlogger.debug(\"View remains unresolved\" + mediaTypeInfo);\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#sendRedirect(request,response,targetUrl,http10Compatible)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Send a redirect back to the HTTP client.\n\t * @param request current HTTP request (allows for reacting to request method)\n\t * @param response current HTTP response (for sending response headers)\n\t * @param targetUrl the target URL to redirect to\n\t * @param http10Compatible whether to stay compatible with HTTP 1.0 clients\n\t * @throws IOException if thrown by response methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "targetUrl",
      "http10Compatible"
    ],
    "position": {
      "column": 1,
      "line": 611
    },
    "return": "void",
    "signature": "protected void sendRedirect(HttpServletRequest request, HttpServletResponse response,\n\t\t\tString targetUrl, boolean http10Compatible)",
    "source_code": "\tprotected void sendRedirect(HttpServletRequest request, HttpServletResponse response,\n\t\t\tString targetUrl, boolean http10Compatible) throws IOException {\n\n\t\tString encodedURL = (isRemoteHost(targetUrl) ? targetUrl : response.encodeRedirectURL(targetUrl));\n\t\tif (http10Compatible) {\n\t\t\tHttpStatusCode attributeStatusCode = (HttpStatusCode) request.getAttribute(View.RESPONSE_STATUS_ATTRIBUTE);\n\t\t\tif (this.statusCode != null) {\n\t\t\t\tresponse.setStatus(this.statusCode.value());\n\t\t\t\tresponse.setHeader(\"Location\", encodedURL);\n\t\t\t}\n\t\t\telse if (attributeStatusCode != null) {\n\t\t\t\tresponse.setStatus(attributeStatusCode.value());\n\t\t\t\tresponse.setHeader(\"Location\", encodedURL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Send status code 302 by default.\n\t\t\t\tresponse.sendRedirect(encodedURL);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tHttpStatusCode statusCode = getHttp11StatusCode(request, response, targetUrl);\n\t\t\tresponse.setStatus(statusCode.value());\n\t\t\tresponse.setHeader(\"Location\", encodedURL);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#updateTargetUrl(targetUrl,Map<String,model,request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find the registered {@link RequestDataValueProcessor}, if any, and allow\n\t * it to update the redirect target URL.\n\t * @param targetUrl the given redirect URL\n\t * @return the updated URL or the same as URL as the one passed in\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 586
    },
    "return": "String",
    "signature": "protected String updateTargetUrl(String targetUrl, Map<String, Object> model,\n\t\t\tHttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected String updateTargetUrl(String targetUrl, Map<String, Object> model,\n\t\t\tHttpServletRequest request, HttpServletResponse response) {\n\n\t\tWebApplicationContext wac = getWebApplicationContext();\n\t\tif (wac == null) {\n\t\t\twac = RequestContextUtils.findWebApplicationContext(request, getServletContext());\n\t\t}\n\n\t\tif (wac != null && wac.containsBean(RequestContextUtils.REQUEST_DATA_VALUE_PROCESSOR_BEAN_NAME)) {\n\t\t\tRequestDataValueProcessor processor = wac.getBean(\n\t\t\t\t\tRequestContextUtils.REQUEST_DATA_VALUE_PROCESSOR_BEAN_NAME, RequestDataValueProcessor.class);\n\t\t\treturn processor.processUrl(request, targetUrl);\n\t\t}\n\n\t\treturn targetUrl;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#urlEncode(input,encodingScheme)": {
    "deprecated": false,
    "doc": "\t/**\n\t * URL-encode the given input String with the given encoding scheme.\n\t * <p>The default implementation uses {@code URLEncoder.encode(input, enc)}.\n\t * @param input the unencoded input String\n\t * @param encodingScheme the encoding scheme\n\t * @return the encoded output String\n\t * @throws UnsupportedEncodingException if thrown by the JDK URLEncoder\n\t * @see java.net.URLEncoder#encode(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "input",
      "encodingScheme"
    ],
    "position": {
      "column": 1,
      "line": 576
    },
    "return": "String",
    "signature": "protected String urlEncode(String input, String encodingScheme)",
    "source_code": "\tprotected String urlEncode(String input, String encodingScheme) throws UnsupportedEncodingException {\n\t\treturn URLEncoder.encode(input, encodingScheme);\n\t}"
  },
  "org.springframework.web.servlet.view.json.<unknown>#filterAndWrapModel(Map<String,model,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Filter and optionally wrap the model in {@link MappingJacksonValue} container.\n\t * @param model the model, as passed on to {@link #renderMergedOutputModel}\n\t * @param request current HTTP request\n\t * @return the wrapped or unwrapped value to be rendered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "Object",
    "signature": "protected Object filterAndWrapModel(Map<String, Object> model, HttpServletRequest request)",
    "source_code": "\tprotected Object filterAndWrapModel(Map<String, Object> model, HttpServletRequest request) {\n\t\tObject value = filterModel(model);\n\t\tClass<?> serializationView = (Class<?>) model.get(JsonView.class.getName());\n\t\tFilterProvider filters = (FilterProvider) model.get(FilterProvider.class.getName());\n\t\tif (serializationView != null || filters != null) {\n\t\t\tMappingJacksonValue container = new MappingJacksonValue(value);\n\t\t\tif (serializationView != null) {\n\t\t\t\tcontainer.setSerializationView(serializationView);\n\t\t\t}\n\t\t\tif (filters != null) {\n\t\t\t\tcontainer.setFilters(filters);\n\t\t\t}\n\t\t\tvalue = container;\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.web.servlet.view.json.<unknown>#filterModel(Map<String,model)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Filter out undesired attributes from the given model.\n\t * The return value can be either another {@link Map} or a single value object.\n\t * @param model the model, as passed on to {@link #renderMergedOutputModel}\n\t * @return the value to be rendered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "Object",
    "signature": "protected Object filterModel(Map<String, Object> model)",
    "source_code": "\tprotected abstract Object filterModel(Map<String, Object> model);"
  },
  "org.springframework.web.servlet.view.json.<unknown>#prepareResponse(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "protected void prepareResponse(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void prepareResponse(HttpServletRequest request, HttpServletResponse response) {\n\t\tsetResponseContentType(request, response);\n\t\tresponse.setCharacterEncoding(this.encoding.getJavaName());\n\t\tif (this.disableCaching) {\n\t\t\tresponse.addHeader(\"Cache-Control\", \"no-store\");\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.json.<unknown>#renderMergedOutputModel(Map<String,model,request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response)",
    "source_code": "\tprotected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws Exception {\n\n\t\tByteArrayOutputStream temporaryStream = null;\n\t\tOutputStream stream;\n\n\t\tif (this.updateContentLength) {\n\t\t\ttemporaryStream = createTemporaryOutputStream();\n\t\t\tstream = temporaryStream;\n\t\t}\n\t\telse {\n\t\t\tstream = response.getOutputStream();\n\t\t}\n\n\t\tObject value = filterAndWrapModel(model, request);\n\t\twriteContent(stream, value);\n\n\t\tif (temporaryStream != null) {\n\t\t\twriteToResponse(response, temporaryStream);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.json.<unknown>#writeContent(stream,object)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write the actual JSON content to the stream.\n\t * @param stream the output stream to use\n\t * @param object the value to be rendered, as returned from {@link #filterModel}\n\t * @throws IOException if writing failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "stream",
      "object"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "void",
    "signature": "protected void writeContent(OutputStream stream, Object object)",
    "source_code": "\tprotected void writeContent(OutputStream stream, Object object) throws IOException {\n\t\ttry (JsonGenerator generator = this.objectMapper.getFactory().createGenerator(stream, this.encoding)) {\n\t\t\twritePrefix(generator, object);\n\n\t\t\tObject value = object;\n\t\t\tClass<?> serializationView = null;\n\t\t\tFilterProvider filters = null;\n\n\t\t\tif (value instanceof MappingJacksonValue container) {\n\t\t\t\tvalue = container.getValue();\n\t\t\t\tserializationView = container.getSerializationView();\n\t\t\t\tfilters = container.getFilters();\n\t\t\t}\n\n\t\t\tObjectWriter objectWriter = (serializationView != null ?\n\t\t\t\t\tthis.objectMapper.writerWithView(serializationView) : this.objectMapper.writer());\n\t\t\tif (filters != null) {\n\t\t\t\tobjectWriter = objectWriter.with(filters);\n\t\t\t}\n\t\t\tobjectWriter.writeValue(generator, value);\n\n\t\t\twriteSuffix(generator, object);\n\t\t\tgenerator.flush();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.json.<unknown>#writePrefix(generator,object)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write a prefix before the main content.\n\t * @param generator the generator to use for writing content.\n\t * @param object the object to write to the output message.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "generator",
      "object"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "void",
    "signature": "protected void writePrefix(JsonGenerator generator, Object object)",
    "source_code": "\tprotected void writePrefix(JsonGenerator generator, Object object) throws IOException {\n\t}"
  },
  "org.springframework.web.servlet.view.json.<unknown>#writeSuffix(generator,object)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write a suffix after the main content.\n\t * @param generator the generator to use for writing content.\n\t * @param object the object to write to the output message.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "generator",
      "object"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "void",
    "signature": "protected void writeSuffix(JsonGenerator generator, Object object)",
    "source_code": "\tprotected void writeSuffix(JsonGenerator generator, Object object) throws IOException {\n\t}"
  },
  "org.springframework.web.servlet.view.script.<unknown>#prepareResponse(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 387
    },
    "return": "void",
    "signature": "protected void prepareResponse(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void prepareResponse(HttpServletRequest request, HttpServletResponse response) {\n\t\tsuper.prepareResponse(request, response);\n\n\t\tsetResponseContentType(request, response);\n\t\tif (this.charset != null) {\n\t\t\tresponse.setCharacterEncoding(this.charset.name());\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.script.<unknown>#renderMergedOutputModel(Map<String,model,request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "void",
    "signature": "protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response)",
    "source_code": "\tprotected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws Exception {\n\n\t\ttry {\n\t\t\tScriptEngine engine = getEngine();\n\t\t\tString url = getUrl();\n\t\t\tAssert.state(url != null, \"'url' not set\");\n\t\t\tString template = getTemplate(url);\n\n\t\t\tFunction<String, String> templateLoader = path -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn getTemplate(path);\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tLocale locale = RequestContextUtils.getLocale(request);\n\t\t\tRenderingContext context = new RenderingContext(obtainApplicationContext(), locale, templateLoader, url);\n\n\t\t\tObject html;\n\t\t\tif (this.renderFunction == null) {\n\t\t\t\tSimpleBindings bindings = new SimpleBindings();\n\t\t\t\tbindings.putAll(model);\n\t\t\t\tmodel.put(\"renderingContext\", context);\n\t\t\t\thtml = engine.eval(template, bindings);\n\t\t\t}\n\t\t\telse if (this.renderObject != null) {\n\t\t\t\tObject thiz = engine.eval(this.renderObject);\n\t\t\t\thtml = ((Invocable) engine).invokeMethod(thiz, this.renderFunction, template, model, context);\n\t\t\t}\n\t\t\telse {\n\t\t\t\thtml = ((Invocable) engine).invokeFunction(this.renderFunction, template, model, context);\n\t\t\t}\n\n\t\t\tresponse.getWriter().write(String.valueOf(html));\n\t\t}\n\t\tcatch (ScriptException ex) {\n\t\t\tthrow new ServletException(\"Failed to render script template\", new StandardScriptEvalException(ex));\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.xslt.<unknown>#configureResponse(Map<String,model,response,transformer)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the supplied {@link HttpServletResponse}.\n\t * <p>The default implementation of this method sets the\n\t * {@link HttpServletResponse#setContentType content type} and\n\t * {@link HttpServletResponse#setCharacterEncoding encoding}\n\t * from the \"media-type\" and \"encoding\" output properties\n\t * specified in the {@link Transformer}.\n\t * @param model merged output Map (never {@code null})\n\t * @param response current HTTP response\n\t * @param transformer the target transformer\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "response",
      "transformer"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "void",
    "signature": "protected void configureResponse(Map<String, Object> model, HttpServletResponse response, Transformer transformer)",
    "source_code": "\tprotected void configureResponse(Map<String, Object> model, HttpServletResponse response, Transformer transformer) {\n\t\tString contentType = getContentType();\n\t\tString mediaType = transformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n\t\tString encoding = transformer.getOutputProperty(OutputKeys.ENCODING);\n\t\tif (StringUtils.hasText(mediaType)) {\n\t\t\tcontentType = mediaType;\n\t\t}\n\t\tif (StringUtils.hasText(encoding)) {\n\t\t\t// Only apply encoding if content type is specified but does not contain charset clause already.\n\t\t\tif (contentType != null && !contentType.toLowerCase().contains(WebUtils.CONTENT_TYPE_CHARSET_PREFIX)) {\n\t\t\t\tcontentType = contentType + WebUtils.CONTENT_TYPE_CHARSET_PREFIX + encoding;\n\t\t\t}\n\t\t}\n\t\tresponse.setContentType(contentType);\n\t}"
  },
  "org.springframework.web.servlet.view.xslt.<unknown>#configureTransformer(Map<String,model,response,transformer)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the supplied {@link Transformer} instance.\n\t * <p>The default implementation copies parameters from the model into the\n\t * Transformer's {@link Transformer#setParameter parameter set}.\n\t * This implementation also copies the {@link #setOutputProperties output properties}\n\t * into the {@link Transformer} {@link Transformer#setOutputProperty output properties}.\n\t * Indentation properties are set as well.\n\t * @param model merged output Map (never {@code null})\n\t * @param response current HTTP response\n\t * @param transformer the target transformer\n\t * @see #copyModelParameters(Map, Transformer)\n\t * @see #copyOutputProperties(Transformer)\n\t * @see #configureIndentation(Transformer)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "response",
      "transformer"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "void",
    "signature": "protected void configureTransformer(Map<String, Object> model, HttpServletResponse response,\n\t\t\tTransformer transformer)",
    "source_code": "\tprotected void configureTransformer(Map<String, Object> model, HttpServletResponse response,\n\t\t\tTransformer transformer) {\n\n\t\tcopyModelParameters(model, transformer);\n\t\tcopyOutputProperties(transformer);\n\t\tconfigureIndentation(transformer);\n\t}"
  },
  "org.springframework.web.servlet.view.xslt.<unknown>#copyModelParameters(Map<String,model,transformer)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all entries from the supplied Map into the\n\t * {@link Transformer#setParameter(String, Object) parameter set}\n\t * of the supplied {@link Transformer}.\n\t * @param model merged output Map (never {@code null})\n\t * @param transformer the target transformer\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "transformer"
    ],
    "position": {
      "column": 1,
      "line": 393
    },
    "return": "void",
    "signature": "protected void copyModelParameters(Map<String, Object> model, Transformer transformer)",
    "source_code": "\tprotected final void copyModelParameters(Map<String, Object> model, Transformer transformer) {\n\t\tmodel.forEach(transformer::setParameter);\n\t}"
  },
  "org.springframework.web.servlet.view.xslt.<unknown>#locateSource(Map<String,model)": {
    "deprecated": false,
    "doc": "\t/**\n\t * <p>Locate the {@link Source} object in the supplied model,\n\t * converting objects as required.\n\t * The default implementation first attempts to look under the configured\n\t * {@link #setSourceKey source key}, if any, before attempting to locate\n\t * an object of {@link #getSourceTypes() supported type}.\n\t * @param model the merged model Map\n\t * @return the XSLT Source object (or {@code null} if none found)\n\t * @throws Exception if an error occurred during locating the source\n\t * @see #setSourceKey\n\t * @see #convertSource\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "Source",
    "signature": "protected Source locateSource(Map<String, Object> model)",
    "source_code": "\tprotected Source locateSource(Map<String, Object> model) throws Exception {\n\t\tif (this.sourceKey != null) {\n\t\t\treturn convertSource(model.get(this.sourceKey));\n\t\t}\n\t\tObject source = CollectionUtils.findValueOfType(model.values(), getSourceTypes());\n\t\treturn (source != null ? convertSource(source) : null);\n\t}"
  },
  "org.springframework.web.servlet.view.xslt.<unknown>#renderMergedOutputModel(Map<String,model,request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "void",
    "signature": "protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void renderMergedOutputModel(\n\t\t\tMap<String, Object> model, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception {\n\n\t\tTemplates templates = this.cachedTemplates;\n\t\tif (templates == null) {\n\t\t\ttemplates = loadTemplates();\n\t\t}\n\n\t\tTransformer transformer = createTransformer(templates);\n\t\tconfigureTransformer(model, response, transformer);\n\t\tconfigureResponse(model, response, transformer);\n\t\tSource source = null;\n\t\ttry {\n\t\t\tsource = locateSource(model);\n\t\t\tif (source == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Unable to locate Source object in model: \" + model);\n\t\t\t}\n\t\t\ttransformer.transform(source, createResult(response));\n\t\t}\n\t\tfinally {\n\t\t\tcloseSourceIfNecessary(source);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.<unknown>#add(headerName,headerValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given, single header value under the given name.\n\t * @param headerName  the header name\n\t * @param headerValue the header value\n\t * @throws UnsupportedOperationException if adding headers is not supported\n\t * @see #put(String, List)\n\t * @see #set(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "void",
    "signature": "public void add(String headerName, @Nullable String headerValue)",
    "source_code": "\tpublic void add(String headerName, @Nullable String headerValue) {\n\t\tthis.headers.add(headerName, headerValue);\n\t}"
  },
  "org.springframework.web.socket.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\treturn this.headers.put(key, value);\n\t}"
  },
  "org.springframework.web.socket.<unknown>#putAll(String,m)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "m"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> m)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> m) {\n\t\tthis.headers.putAll(m);\n\t}"
  },
  "org.springframework.web.socket.<unknown>#set(headerName,headerValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given, single header value under the given name.\n\t * @param headerName  the header name\n\t * @param headerValue the header value\n\t * @throws UnsupportedOperationException if adding headers is not supported\n\t * @see #put(String, List)\n\t * @see #add(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "void",
    "signature": "public void set(String headerName, @Nullable String headerValue)",
    "source_code": "\tpublic void set(String headerName, @Nullable String headerValue) {\n\t\tthis.headers.set(headerName, headerValue);\n\t}"
  },
  "org.springframework.web.socket.<unknown>#setAll(Map<String,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tthis.headers.setAll(values);\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#afterSessionEnded(session,closeStatus,outputChannel)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "closeStatus",
      "outputChannel"
    ],
    "position": {
      "column": 1,
      "line": 640
    },
    "return": "void",
    "signature": "public void afterSessionEnded(WebSocketSession session, CloseStatus closeStatus, MessageChannel outputChannel)",
    "source_code": "\tpublic void afterSessionEnded(WebSocketSession session, CloseStatus closeStatus, MessageChannel outputChannel) {\n\t\tthis.decoders.remove(session.getId());\n\n\t\tMessage<byte[]> message = createDisconnectMessage(session);\n\t\tSimpAttributes simpAttributes = SimpAttributes.fromMessage(message);\n\t\ttry {\n\t\t\tSimpAttributesContextHolder.setAttributes(simpAttributes);\n\t\t\tif (this.eventPublisher != null) {\n\t\t\t\tPrincipal user = getUser(session);\n\t\t\t\tpublishEvent(this.eventPublisher, new SessionDisconnectEvent(this, message, session.getId(), closeStatus, user));\n\t\t\t}\n\t\t\toutputChannel.send(message);\n\t\t}\n\t\tfinally {\n\t\t\tthis.stompAuthentications.remove(session.getId());\n\t\t\tSimpAttributesContextHolder.resetAttributes();\n\t\t\tsimpAttributes.sessionCompleted();\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#afterSessionStarted(session,outputChannel)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "outputChannel"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "void",
    "signature": "public void afterSessionStarted(WebSocketSession session, MessageChannel outputChannel)",
    "source_code": "\tpublic void afterSessionStarted(WebSocketSession session, MessageChannel outputChannel) {\n\t\tif (session.getTextMessageSizeLimit() < MINIMUM_WEBSOCKET_MESSAGE_SIZE) {\n\t\t\tsession.setTextMessageSizeLimit(MINIMUM_WEBSOCKET_MESSAGE_SIZE);\n\t\t}\n\t\tthis.decoders.put(session.getId(), new BufferingStompDecoder(this.stompDecoder, getMessageSizeLimit()));\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#handleMessageFromClient(session,webSocketMessage,outputChannel)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle incoming WebSocket messages from clients.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "webSocketMessage",
      "outputChannel"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "void",
    "signature": "public void handleMessageFromClient(WebSocketSession session,\n\t\t\tWebSocketMessage<?> webSocketMessage, MessageChannel outputChannel)",
    "source_code": "\tpublic void handleMessageFromClient(WebSocketSession session,\n\t\t\tWebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {\n\n\t\tList<Message<byte[]>> messages;\n\t\ttry {\n\t\t\tByteBuffer byteBuffer;\n\t\t\tif (webSocketMessage instanceof TextMessage) {\n\t\t\t\tbyteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes());\n\t\t\t}\n\t\t\telse if (webSocketMessage instanceof BinaryMessage) {\n\t\t\t\tbyteBuffer = ((BinaryMessage) webSocketMessage).getPayload();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tBufferingStompDecoder decoder = this.decoders.get(session.getId());\n\t\t\tif (decoder == null) {\n\t\t\t\tif (!session.isOpen()) {\n\t\t\t\t\tlogger.trace(\"Dropped inbound WebSocket message due to closed session\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthrow new IllegalStateException(\"No decoder for session id '\" + session.getId() + \"'\");\n\t\t\t}\n\n\t\t\tmessages = decoder.decode(byteBuffer);\n\t\t\tif (messages.isEmpty()) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Incomplete STOMP frame content received in session \" +\n\t\t\t\t\t\t\tsession + \", bufferSize=\" + decoder.getBufferSize() +\n\t\t\t\t\t\t\t\", bufferSizeLimit=\" + decoder.getBufferSizeLimit() + \".\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Failed to parse \" + webSocketMessage +\n\t\t\t\t\t\t\" in session \" + session.getId() + \". Sending STOMP ERROR to client.\", ex);\n\t\t\t}\n\t\t\thandleError(session, ex, null);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (Message<byte[]> message : messages) {\n\t\t\tStompHeaderAccessor headerAccessor =\n\t\t\t\t\tMessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);\n\t\t\tAssert.state(headerAccessor != null, \"No StompHeaderAccessor\");\n\n\t\t\tStompCommand command = headerAccessor.getCommand();\n\t\t\tboolean isConnect = StompCommand.CONNECT.equals(command) || StompCommand.STOMP.equals(command);\n\n\t\t\tboolean sent = false;\n\t\t\ttry {\n\n\t\t\t\theaderAccessor.setSessionId(session.getId());\n\t\t\t\theaderAccessor.setSessionAttributes(session.getAttributes());\n\t\t\t\theaderAccessor.setUser(getUser(session));\n\t\t\t\tif (isConnect) {\n\t\t\t\t\theaderAccessor.setUserChangeCallback(user -> {\n\t\t\t\t\t\tif (user != null && user != session.getPrincipal()) {\n\t\t\t\t\t\t\tthis.stompAuthentications.put(session.getId(), user);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\theaderAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat());\n\t\t\t\tif (!detectImmutableMessageInterceptor(outputChannel)) {\n\t\t\t\t\theaderAccessor.setImmutable();\n\t\t\t\t}\n\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"From client: \" + headerAccessor.getShortLogMessage(message.getPayload()));\n\t\t\t\t}\n\n\t\t\t\tif (isConnect) {\n\t\t\t\t\tthis.stats.incrementConnectCount();\n\t\t\t\t}\n\t\t\t\telse if (StompCommand.DISCONNECT.equals(command)) {\n\t\t\t\t\tthis.stats.incrementDisconnectCount();\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tSimpAttributesContextHolder.setAttributesFromMessage(message);\n\t\t\t\t\tsent = outputChannel.send(message);\n\n\t\t\t\t\tif (sent) {\n\t\t\t\t\t\tif (this.eventPublisher != null) {\n\t\t\t\t\t\t\tPrincipal user = getUser(session);\n\t\t\t\t\t\t\tif (isConnect) {\n\t\t\t\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionConnectEvent(this, message, user));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (StompCommand.SUBSCRIBE.equals(command)) {\n\t\t\t\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionSubscribeEvent(this, message, user));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (StompCommand.UNSUBSCRIBE.equals(command)) {\n\t\t\t\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionUnsubscribeEvent(this, message, user));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tSimpAttributesContextHolder.resetAttributes();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Failed to send message to MessageChannel in session \" + session.getId(), ex);\n\t\t\t\t}\n\t\t\t\telse if (logger.isErrorEnabled()) {\n\t\t\t\t\t// Skip unsent CONNECT messages (likely auth issues)\n\t\t\t\t\tif (!isConnect || sent) {\n\t\t\t\t\t\tlogger.error(\"Failed to send message to MessageChannel in session \" + session.getId() +\n\t\t\t\t\t\t\t\t\":\" + ex.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\thandleError(session, ex, message);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#handleMessageToClient(session,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle STOMP messages going back out to WebSocket clients.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "void",
    "signature": "public void handleMessageToClient(WebSocketSession session, Message<?> message)",
    "source_code": "\tpublic void handleMessageToClient(WebSocketSession session, Message<?> message) {\n\t\tif (!(message.getPayload() instanceof byte[] payload)) {\n\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Expected byte[] payload. Ignoring \" + message + \".\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tStompHeaderAccessor accessor = getStompHeaderAccessor(message);\n\t\tStompCommand command = accessor.getCommand();\n\n\t\tif (StompCommand.MESSAGE.equals(command)) {\n\t\t\tif (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"No STOMP \\\"subscription\\\" header in \" + message);\n\t\t\t}\n\t\t\tString origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION);\n\t\t\tif (origDestination != null) {\n\t\t\t\taccessor = toMutableAccessor(accessor, message);\n\t\t\t\taccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION);\n\t\t\t\taccessor.setDestination(origDestination);\n\t\t\t}\n\t\t}\n\t\telse if (StompCommand.CONNECTED.equals(command)) {\n\t\t\tthis.stats.incrementConnectedCount();\n\t\t\taccessor = afterStompSessionConnected(message, accessor, session);\n\t\t\tif (this.eventPublisher != null) {\n\t\t\t\ttry {\n\t\t\t\t\tSimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes());\n\t\t\t\t\tSimpAttributesContextHolder.setAttributes(simpAttributes);\n\t\t\t\t\tPrincipal user = getUser(session);\n\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionConnectedEvent(this, (Message<byte[]>) message, user));\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tSimpAttributesContextHolder.resetAttributes();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {\n\t\t\tMessage<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message);\n\t\t\tif (errorMessage != null) {\n\t\t\t\taccessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class);\n\t\t\t\tAssert.state(accessor != null, \"No StompHeaderAccessor\");\n\t\t\t\tpayload = errorMessage.getPayload();\n\t\t\t}\n\t\t}\n\n\t\tRunnable task = OrderedMessageChannelDecorator.getNextMessageTask(message);\n\t\tif (task != null) {\n\t\t\tAssert.isInstanceOf(ConcurrentWebSocketSessionDecorator.class, session);\n\t\t\t((ConcurrentWebSocketSessionDecorator) session).setMessageCallback(m -> task.run());\n\t\t}\n\n\t\tsendToClient(session, accessor, payload);\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#toMutableAccessor(headerAccessor,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headerAccessor",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 601
    },
    "return": "StompHeaderAccessor",
    "signature": "protected StompHeaderAccessor toMutableAccessor(StompHeaderAccessor headerAccessor, Message<?> message)",
    "source_code": "\tprotected StompHeaderAccessor toMutableAccessor(StompHeaderAccessor headerAccessor, Message<?> message) {\n\t\treturn (headerAccessor.isMutable() ? headerAccessor : StompHeaderAccessor.wrap(message));\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#afterHandshake(request,response,wsHandler,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "wsHandler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "void",
    "signature": "public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, @Nullable Exception ex)",
    "source_code": "\tpublic void afterHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, @Nullable Exception ex) {\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#beforeHandshake(request,response,wsHandler,Map<String,attributes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "wsHandler",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "boolean",
    "signature": "public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, Map<String, Object> attributes)",
    "source_code": "\tpublic boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, Map<String, Object> attributes) throws Exception {\n\n\t\tHttpSession session = getSession(request);\n\t\tif (session != null) {\n\t\t\tif (isCopyHttpSessionId()) {\n\t\t\t\tattributes.put(HTTP_SESSION_ID_ATTR_NAME, session.getId());\n\t\t\t}\n\t\t\tEnumeration<String> names = session.getAttributeNames();\n\t\t\twhile (names.hasMoreElements()) {\n\t\t\t\tString name = names.nextElement();\n\t\t\t\tif (isCopyAllAttributes() || getAttributeNames().contains(name)) {\n\t\t\t\t\tattributes.put(name, session.getAttribute(name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#execute(handler,headers,url)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler",
      "headers",
      "url"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "CompletableFuture<WebSocketSession>",
    "signature": "public CompletableFuture<WebSocketSession> execute(WebSocketHandler handler, @Nullable WebSocketHttpHeaders headers, URI url)",
    "source_code": "\tpublic final CompletableFuture<WebSocketSession> execute(\n\t\t\tWebSocketHandler handler, @Nullable WebSocketHttpHeaders headers, URI url) {\n\n\t\tAssert.notNull(handler, \"WebSocketHandler is required\");\n\t\tAssert.notNull(url, \"URL is required\");\n\n\t\tString scheme = url.getScheme();\n\t\tif (!supportedProtocols.contains(scheme)) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid scheme: '\" + scheme + \"'\");\n\t\t}\n\n\t\tCompletableFuture<WebSocketSession> connectFuture = new CompletableFuture<>();\n\t\ttry {\n\t\t\tSockJsUrlInfo sockJsUrlInfo = new SockJsUrlInfo(url);\n\t\t\tServerInfo serverInfo = getServerInfo(sockJsUrlInfo, getHttpRequestHeaders(headers));\n\t\t\tcreateRequest(sockJsUrlInfo, headers, serverInfo).connect(handler, connectFuture);\n\t\t}\n\t\tcatch (Exception exception) {\n\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Initial SockJS \\\"Info\\\" request to server failed, url=\" + url, exception);\n\t\t\t}\n\t\t\tconnectFuture.completeExceptionally(exception);\n\t\t}\n\t\treturn connectFuture;\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#execute(handler,uriTemplate,uriVars)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler",
      "uriTemplate",
      "uriVars"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "CompletableFuture<WebSocketSession>",
    "signature": "public CompletableFuture<WebSocketSession> execute(WebSocketHandler handler, String uriTemplate, Object... uriVars)",
    "source_code": "\tpublic CompletableFuture<WebSocketSession> execute(\n\t\t\tWebSocketHandler handler, String uriTemplate, Object... uriVars) {\n\n\t\tAssert.notNull(uriTemplate, \"uriTemplate must not be null\");\n\t\tURI uri = UriComponentsBuilder.fromUriString(uriTemplate).buildAndExpand(uriVars).encode().toUri();\n\t\treturn execute(handler, null, uri);\n\t}"
  },
  "org.springframework.web.socket.sockjs.frame.<unknown>#closeFrame(code,reason)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "reason"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "SockJsFrame",
    "signature": "public SockJsFrame closeFrame(int code, @Nullable String reason)",
    "source_code": "\tpublic static SockJsFrame closeFrame(int code, @Nullable String reason) {\n\t\treturn new SockJsFrame(\"c[\" + code + \",\\\"\" + (reason != null ? reason : \"\") + \"\\\"]\");\n\t}"
  },
  "org.springframework.web.socket.sockjs.frame.<unknown>#messageFrame(codec,messages)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codec",
      "messages"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "SockJsFrame",
    "signature": "public SockJsFrame messageFrame(SockJsMessageCodec codec, String... messages)",
    "source_code": "\tpublic static SockJsFrame messageFrame(SockJsMessageCodec codec, String... messages) {\n\t\tString encoded = codec.encode(messages);\n\t\treturn new SockJsFrame(encoded);\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#checkOrigin(request,response,httpMethods)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "httpMethods"
    ],
    "position": {
      "column": 1,
      "line": 523
    },
    "return": "boolean",
    "signature": "protected boolean checkOrigin(ServerHttpRequest request, ServerHttpResponse response, HttpMethod... httpMethods)",
    "source_code": "\tprotected boolean checkOrigin(ServerHttpRequest request, ServerHttpResponse response, HttpMethod... httpMethods)\n\t\t\tthrows IOException {\n\n\t\tif (WebUtils.isSameOrigin(request)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this.corsConfiguration.checkOrigin(request.getHeaders().getOrigin()) == null) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Origin header value '\" + request.getHeaders().getOrigin() + \"' not allowed.\");\n\t\t\t}\n\t\t\tresponse.setStatusCode(HttpStatus.FORBIDDEN);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#handle(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 637
    },
    "return": "void",
    "signature": "public void handle(ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\t\tpublic void handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException {\n\t\t\tif (request.getMethod() != HttpMethod.GET) {\n\t\t\t\tsendMethodNotAllowed(response, HttpMethod.GET);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString content = String.format(IFRAME_CONTENT, getSockJsClientLibraryUrl());\n\t\t\tbyte[] contentBytes = content.getBytes(StandardCharsets.UTF_8);\n\t\t\tStringBuilder builder = new StringBuilder(\"\\\"0\");\n\t\t\tDigestUtils.appendMd5DigestAsHex(contentBytes, builder);\n\t\t\tbuilder.append('\"');\n\t\t\tString etagValue = builder.toString();\n\n\t\t\tList<String> ifNoneMatch = request.getHeaders().getIfNoneMatch();\n\t\t\tif (!CollectionUtils.isEmpty(ifNoneMatch) && ifNoneMatch.get(0).equals(etagValue)) {\n\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_MODIFIED);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresponse.getHeaders().setContentType(new MediaType(\"text\", \"html\", StandardCharsets.UTF_8));\n\t\t\tresponse.getHeaders().setContentLength(contentBytes.length);\n\n\t\t\t// No cache in order to check every time if IFrame are authorized\n\t\t\taddNoCacheHeaders(response);\n\t\t\tresponse.getHeaders().setETag(etagValue);\n\t\t\tresponse.getBody().write(contentBytes);\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#handleRawWebSocketRequest(request,response,webSocketHandler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle request for raw WebSocket communication, i.e. without any SockJS message framing.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "webSocketHandler"
    ],
    "position": {
      "column": 1,
      "line": 569
    },
    "return": "void",
    "signature": "protected void handleRawWebSocketRequest(ServerHttpRequest request,\n\t\t\tServerHttpResponse response, WebSocketHandler webSocketHandler)",
    "source_code": "\tprotected abstract void handleRawWebSocketRequest(ServerHttpRequest request,\n\t\t\tServerHttpResponse response, WebSocketHandler webSocketHandler) throws IOException;\n\n\t/**\n\t * Handle a SockJS session URL (i.e. transport-specific request).\n\t */\n\tprotected abstract void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler webSocketHandler, String sessionId, String transport) throws SockJsException;\n\n\n\tprivate interface SockJsRequestHandler {\n\n\t\tvoid handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#handleRequest(request,response,sockJsPath,wsHandler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This method determines the SockJS path and handles SockJS static URLs.\n\t * Session URLs and raw WebSocket requests are delegated to abstract methods.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "sockJsPath",
      "wsHandler"
    ],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "void",
    "signature": "public void handleRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\t@Nullable String sockJsPath, WebSocketHandler wsHandler)",
    "source_code": "\tpublic final void handleRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\t@Nullable String sockJsPath, WebSocketHandler wsHandler) throws SockJsException {\n\n\t\tif (sockJsPath == null) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Expected SockJS path. Failing request: \" + request.getURI(), -1, true));\n\t\t\t}\n\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\trequest.getHeaders();\n\t\t}\n\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\t// As per SockJS protocol content-type can be ignored (it's always json)\n\t\t}\n\n\t\tString requestInfo = (logger.isDebugEnabled() ? request.getMethod() + \" \" + request.getURI() : null);\n\n\t\ttry {\n\t\t\tif (sockJsPath.isEmpty() || sockJsPath.equals(\"/\")) {\n\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\tlogger.debug(\"Processing transport request: \" + requestInfo);\n\t\t\t\t}\n\t\t\t\tif (\"websocket\".equalsIgnoreCase(request.getHeaders().getUpgrade())) {\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.BAD_REQUEST);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresponse.getHeaders().setContentType(new MediaType(\"text\", \"plain\", StandardCharsets.UTF_8));\n\t\t\t\tresponse.getBody().write(\"Welcome to SockJS!\\n\".getBytes(StandardCharsets.UTF_8));\n\t\t\t}\n\n\t\t\telse if (sockJsPath.equals(\"/info\")) {\n\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\tlogger.debug(\"Processing transport request: \" + requestInfo);\n\t\t\t\t}\n\t\t\t\tthis.infoHandler.handle(request, response);\n\t\t\t}\n\n\t\t\telse if (sockJsPath.matches(\"/iframe[0-9-.a-z_]*.html\")) {\n\t\t\t\tif (!getAllowedOrigins().isEmpty() && !getAllowedOrigins().contains(\"*\") ||\n\t\t\t\t\t\t!getAllowedOriginPatterns().isEmpty()) {\n\t\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\t\tlogger.debug(\"Iframe support is disabled when an origin check is required. \" +\n\t\t\t\t\t\t\t\t\"Ignoring transport request: \" + requestInfo);\n\t\t\t\t\t}\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (getAllowedOrigins().isEmpty()) {\n\t\t\t\t\tresponse.getHeaders().add(XFRAME_OPTIONS_HEADER, \"SAMEORIGIN\");\n\t\t\t\t}\n\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\tlogger.debug(\"Processing transport request: \" + requestInfo);\n\t\t\t\t}\n\t\t\t\tthis.iframeHandler.handle(request, response);\n\t\t\t}\n\n\t\t\telse if (sockJsPath.equals(\"/websocket\")) {\n\t\t\t\tif (isWebSocketEnabled()) {\n\t\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\t\tlogger.debug(\"Processing transport request: \" + requestInfo);\n\t\t\t\t\t}\n\t\t\t\t\thandleRawWebSocketRequest(request, response, wsHandler);\n\t\t\t\t}\n\t\t\t\telse if (requestInfo != null) {\n\t\t\t\t\tlogger.debug(\"WebSocket disabled. Ignoring transport request: \" + requestInfo);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tString[] pathSegments = StringUtils.tokenizeToStringArray(sockJsPath.substring(1), \"/\");\n\t\t\t\tif (pathSegments.length != 3) {\n\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\"Invalid SockJS path '\" + sockJsPath + \"' - \" +\n\t\t\t\t\t\t\t\t\"required to have 3 path segments\", -1, true));\n\t\t\t\t\t}\n\t\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring transport request: \" + requestInfo);\n\t\t\t\t\t}\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tString serverId = pathSegments[0];\n\t\t\t\tString sessionId = pathSegments[1];\n\t\t\t\tString transport = pathSegments[2];\n\n\t\t\t\tif (!isWebSocketEnabled() && transport.equals(\"websocket\")) {\n\t\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\t\tlogger.debug(\"WebSocket disabled. Ignoring transport request: \" + requestInfo);\n\t\t\t\t\t}\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse if (!validateRequest(serverId, sessionId, transport) || !validatePath(request)) {\n\t\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring transport request: \" + requestInfo);\n\t\t\t\t\t}\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\tlogger.debug(\"Processing transport request: \" + requestInfo);\n\t\t\t\t}\n\t\t\t\thandleTransportRequest(request, response, wsHandler, sessionId, transport);\n\t\t\t}\n\t\t\tresponse.close();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new SockJsException(\"Failed to write to the response\", null, ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#handleTransportRequest(request,response,webSocketHandler,sessionId,transport)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle a SockJS session URL (i.e. transport-specific request).\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "webSocketHandler",
      "sessionId",
      "transport"
    ],
    "position": {
      "column": 1,
      "line": 575
    },
    "return": "void",
    "signature": "protected void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler webSocketHandler, String sessionId, String transport)",
    "source_code": "\tprotected abstract void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler webSocketHandler, String sessionId, String transport) throws SockJsException;\n\n\n\tprivate interface SockJsRequestHandler {\n\n\t\tvoid handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#sendMethodNotAllowed(response,httpMethods)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "httpMethods"
    ],
    "position": {
      "column": 1,
      "line": 559
    },
    "return": "void",
    "signature": "protected void sendMethodNotAllowed(ServerHttpResponse response, HttpMethod... httpMethods)",
    "source_code": "\tprotected void sendMethodNotAllowed(ServerHttpResponse response, HttpMethod... httpMethods) {\n\t\tlogger.warn(\"Sending Method Not Allowed (405)\");\n\t\tresponse.setStatusCode(HttpStatus.METHOD_NOT_ALLOWED);\n\t\tresponse.getHeaders().setAllow(new LinkedHashSet<>(Arrays.asList(httpMethods)));\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#validateRequest(serverId,sessionId,transport)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "serverId",
      "sessionId",
      "transport"
    ],
    "position": {
      "column": 1,
      "line": 493
    },
    "return": "boolean",
    "signature": "protected boolean validateRequest(String serverId, String sessionId, String transport)",
    "source_code": "\tprotected boolean validateRequest(String serverId, String sessionId, String transport) {\n\t\tif (!StringUtils.hasText(serverId) || !StringUtils.hasText(sessionId) || !StringUtils.hasText(transport)) {\n\t\t\tlogger.warn(\"No server, session, or transport path segment in SockJS request.\");\n\t\t\treturn false;\n\t\t}\n\n\t\t// Server and session id's must not contain \".\"\n\t\tif (serverId.contains(\".\") || sessionId.contains(\".\")) {\n\t\t\tlogger.warn(\"Either server or session contains a \\\".\\\" which is not allowed by SockJS protocol.\");\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.<unknown>#handleRawWebSocketRequest(request,response,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "void",
    "signature": "protected void handleRawWebSocketRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler handler)",
    "source_code": "\tprotected void handleRawWebSocketRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler handler) throws IOException {\n\n\t\tTransportHandler transportHandler = this.handlers.get(TransportType.WEBSOCKET);\n\t\tif (!(transportHandler instanceof HandshakeHandler)) {\n\t\t\tlogger.error(\"No handler configured for raw WebSocket messages\");\n\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\treturn;\n\t\t}\n\n\t\tHandshakeInterceptorChain chain = new HandshakeInterceptorChain(this.interceptors, handler);\n\t\tHandshakeFailureException failure = null;\n\n\t\ttry {\n\t\t\tMap<String, Object> attributes = new HashMap<>();\n\t\t\tif (!chain.applyBeforeHandshake(request, response, attributes)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t((HandshakeHandler) transportHandler).doHandshake(request, response, handler, attributes);\n\t\t\tchain.applyAfterHandshake(request, response, null);\n\t\t}\n\t\tcatch (HandshakeFailureException ex) {\n\t\t\tfailure = ex;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tfailure = new HandshakeFailureException(\"Uncaught failure for request \" + request.getURI(), ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (failure != null) {\n\t\t\t\tchain.applyAfterHandshake(request, response, failure);\n\t\t\t\tthrow failure;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.<unknown>#handleTransportRequest(request,response,handler,sessionId,transport)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "sessionId",
      "transport"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "void",
    "signature": "protected void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler handler, String sessionId, String transport)",
    "source_code": "\tprotected void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler handler, String sessionId, String transport) throws SockJsException {\n\n\t\tTransportType transportType = TransportType.fromValue(transport);\n\t\tif (transportType == null) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\"Unknown transport type for \" + request.getURI(), -1, true));\n\t\t\t}\n\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\treturn;\n\t\t}\n\n\t\tTransportHandler transportHandler = this.handlers.get(transportType);\n\t\tif (transportHandler == null) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\"No TransportHandler for \" + request.getURI(), -1, true));\n\t\t\t}\n\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\treturn;\n\t\t}\n\n\t\tSockJsException failure = null;\n\t\tHandshakeInterceptorChain chain = new HandshakeInterceptorChain(this.interceptors, handler);\n\n\t\ttry {\n\t\t\tHttpMethod supportedMethod = transportType.getHttpMethod();\n\t\t\tif (supportedMethod != request.getMethod()) {\n\t\t\t\tif (request.getMethod() == HttpMethod.OPTIONS && transportType.supportsCors()) {\n\t\t\t\t\tif (checkOrigin(request, response, HttpMethod.OPTIONS, supportedMethod)) {\n\t\t\t\t\t\tresponse.setStatusCode(HttpStatus.NO_CONTENT);\n\t\t\t\t\t\taddCacheHeaders(response);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (transportType.supportsCors()) {\n\t\t\t\t\tsendMethodNotAllowed(response, supportedMethod, HttpMethod.OPTIONS);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsendMethodNotAllowed(response, supportedMethod);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSockJsSession session = this.sessions.get(sessionId);\n\t\t\tboolean isNewSession = false;\n\t\t\tif (session == null) {\n\t\t\t\tif (transportHandler instanceof SockJsSessionFactory sessionFactory) {\n\t\t\t\t\tMap<String, Object> attributes = new HashMap<>();\n\t\t\t\t\tif (!chain.applyBeforeHandshake(request, response, attributes)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tsession = createSockJsSession(sessionId, sessionFactory, handler, attributes);\n\t\t\t\t\tisNewSession = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Session not found, sessionId=\" + sessionId +\n\t\t\t\t\t\t\t\t\". The session may have been closed \" +\n\t\t\t\t\t\t\t\t\"(e.g. missed heart-beat) while a message was coming in.\");\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPrincipal principal = session.getPrincipal();\n\t\t\t\tif (principal != null && !principal.equals(request.getPrincipal())) {\n\t\t\t\t\tlogger.debug(\"The user for the session does not match the user for the request.\");\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!transportHandler.checkSessionType(session)) {\n\t\t\t\t\tlogger.debug(\"Session type does not match the transport type for the request.\");\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (transportType.sendsNoCacheInstruction()) {\n\t\t\t\taddNoCacheHeaders(response);\n\t\t\t}\n\t\t\tif (transportType.supportsCors() && !checkOrigin(request, response)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttransportHandler.handleRequest(request, response, handler, session);\n\n\t\t\tif (isNewSession && response instanceof ServletServerHttpResponse servletResponse) {\n\t\t\t\tint status = servletResponse.getServletResponse().getStatus();\n\t\t\t\tif (HttpStatusCode.valueOf(status).is4xxClientError()) {\n\t\t\t\t\tthis.sessions.remove(sessionId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchain.applyAfterHandshake(request, response, null);\n\t\t}\n\t\tcatch (SockJsException ex) {\n\t\t\tfailure = ex;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tfailure = new SockJsException(\"Uncaught failure for request \" + request.getURI(), sessionId, ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (failure != null) {\n\t\t\t\tchain.applyAfterHandshake(request, response, failure);\n\t\t\t\tthrow failure;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.<unknown>#validateRequest(serverId,sessionId,transport)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "serverId",
      "sessionId",
      "transport"
    ],
    "position": {
      "column": 1,
      "line": 344
    },
    "return": "boolean",
    "signature": "protected boolean validateRequest(String serverId, String sessionId, String transport)",
    "source_code": "\tprotected boolean validateRequest(String serverId, String sessionId, String transport) {\n\t\tif (!super.validateRequest(serverId, sessionId, transport)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!getAllowedOrigins().isEmpty() && !getAllowedOrigins().contains(\"*\") ||\n\t\t\t\t!getAllowedOriginPatterns().isEmpty()) {\n\t\t\tTransportType transportType = TransportType.fromValue(transport);\n\t\t\tif (transportType == null || !transportType.supportsOrigin()) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Origin check enabled but transport '\" + transport + \"' does not support it.\");\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#createSession(sessionId,handler,Map<String,attributes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "handler",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "StreamingSockJsSession",
    "signature": "public StreamingSockJsSession createSession(String sessionId, WebSocketHandler handler, Map<String, Object> attributes)",
    "source_code": "\tpublic StreamingSockJsSession createSession(\n\t\t\tString sessionId, WebSocketHandler handler, Map<String, Object> attributes) {\n\n\t\treturn new HtmlFileStreamingSockJsSession(sessionId, getServiceConfig(), handler, attributes);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#handleRequestInternal(request,response,sockJsSession)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "sockJsSession"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tAbstractHttpSockJsSession sockJsSession)",
    "source_code": "\tpublic void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tAbstractHttpSockJsSession sockJsSession) throws SockJsException {\n\n\t\tString callback = getCallbackParam(request);\n\t\tif (!StringUtils.hasText(callback)) {\n\t\t\tresponse.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);\n\t\t\ttry {\n\t\t\t\tresponse.getBody().write(\"\\\"callback\\\" parameter required\".getBytes(StandardCharsets.UTF_8));\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tsockJsSession.tryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\t\tthrow new SockJsTransportFailureException(\"Failed to write to response\", sockJsSession.getId(), ex);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tsuper.handleRequestInternal(request, response, sockJsSession);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.<unknown>#tryCloseWithSockJsTransportError(error,closeStatus)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Close due to error arising from SockJS transport handling.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "error",
      "closeStatus"
    ],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "void",
    "signature": "public void tryCloseWithSockJsTransportError(Throwable error, CloseStatus closeStatus)",
    "source_code": "\tpublic void tryCloseWithSockJsTransportError(Throwable error, CloseStatus closeStatus) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Closing due to transport error for \" + this);\n\t\t}\n\t\ttry {\n\t\t\tdelegateError(error);\n\t\t}\n\t\tcatch (Throwable delegateException) {\n\t\t\t// Ignore\n\t\t\tlogger.debug(\"Exception from error handling delegate\", delegateException);\n\t\t}\n\t\ttry {\n\t\t\tclose(closeStatus);\n\t\t}\n\t\tcatch (Throwable closeException) {\n\t\t\tlogger.debug(\"Failure while closing \" + this, closeException);\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#apply(source,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 781
    },
    "return": "String",
    "signature": "public String apply(String source, Type type)",
    "source_code": "\t\tpublic String apply(String source, Type type) {\n\t\t\t// URI variable only?\n\t\t\tif (isUriVariable(source)) {\n\t\t\t\treturn source;\n\t\t\t}\n\t\t\t// Literal template only?\n\t\t\tif (source.indexOf('{') == -1) {\n\t\t\t\treturn encodeUriComponent(source, this.charset, type);\n\t\t\t}\n\t\t\tint level = 0;\n\t\t\tclear(this.currentLiteral);\n\t\t\tclear(this.currentVariable);\n\t\t\tclear(this.output);\n\t\t\tfor (int i = 0; i < source.length(); i++) {\n\t\t\t\tchar c = source.charAt(i);\n\t\t\t\tif (c == ':' && level == 1) {\n\t\t\t\t\tthis.variableWithNameAndRegex = true;\n\t\t\t\t}\n\t\t\t\tif (c == '{') {\n\t\t\t\t\tlevel++;\n\t\t\t\t\tif (level == 1) {\n\t\t\t\t\t\tappend(this.currentLiteral, true, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (c == '}' && level > 0) {\n\t\t\t\t\tlevel--;\n\t\t\t\t\tthis.currentVariable.append('}');\n\t\t\t\t\tif (level == 0) {\n\t\t\t\t\t\tboolean encode = !isUriVariable(this.currentVariable);\n\t\t\t\t\t\tappend(this.currentVariable, encode, type);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!this.variableWithNameAndRegex) {\n\t\t\t\t\t\tappend(this.currentVariable, true, type);\n\t\t\t\t\t\tlevel = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (level > 0) {\n\t\t\t\t\tthis.currentVariable.append(c);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.currentLiteral.append(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (level > 0) {\n\t\t\t\tthis.currentLiteral.append(this.currentVariable);\n\t\t\t}\n\t\t\tappend(this.currentLiteral, true, type);\n\t\t\treturn this.output.toString();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#build(Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 522
    },
    "return": "URI",
    "signature": "public URI build(Map<String, ?> uriVariables)",
    "source_code": "\tpublic URI build(Map<String, ?> uriVariables) {\n\t\treturn buildInternal(EncodingHint.ENCODE_TEMPLATE).expand(uriVariables).toUri();\n\t}"
  },
  "org.springframework.web.util.<unknown>#buildAndExpand(Map<String,uriVariables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@code UriComponents} instance and replaces URI template variables\n\t * with the values from a map. This is a shortcut method which combines\n\t * calls to {@link #build()} and then {@link UriComponents#expand(Map)}.\n\t * @param uriVariables the map of URI variables\n\t * @return the URI components with expanded values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 501
    },
    "return": "UriComponents",
    "signature": "public UriComponents buildAndExpand(Map<String, ?> uriVariables)",
    "source_code": "\tpublic UriComponents buildAndExpand(Map<String, ?> uriVariables) {\n\t\treturn build().expand(uriVariables);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encode(BiFunction<String,Type,encoder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiFunction<String",
      "Type",
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 1048
    },
    "return": "PathComponent",
    "signature": "public PathComponent encode(BiFunction<String, Type, String> encoder)",
    "source_code": "\t\tpublic PathComponent encode(BiFunction<String, Type, String> encoder) {\n\t\t\tList<PathComponent> encodedComponents = new ArrayList<>(this.pathComponents.size());\n\t\t\tfor (PathComponent pathComponent : this.pathComponents) {\n\t\t\t\tencodedComponents.add(pathComponent.encode(encoder));\n\t\t\t}\n\t\t\treturn new PathComponentComposite(encodedComponents);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#expand(uriVariables,encoder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriVariables",
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 1064
    },
    "return": "PathComponent",
    "signature": "public PathComponent expand(UriTemplateVariables uriVariables, @Nullable UnaryOperator<String> encoder)",
    "source_code": "\t\tpublic PathComponent expand(UriTemplateVariables uriVariables, @Nullable UnaryOperator<String> encoder) {\n\t\t\tList<PathComponent> expandedComponents = new ArrayList<>(this.pathComponents.size());\n\t\t\tfor (PathComponent pathComponent : this.pathComponents) {\n\t\t\t\texpandedComponents.add(pathComponent.expand(uriVariables, encoder));\n\t\t\t}\n\t\t\treturn new PathComponentComposite(expandedComponents);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#exposeErrorRequestAttributes(request,ex,servletName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Expose the Servlet spec's error attributes as {@link jakarta.servlet.http.HttpServletRequest}\n\t * attributes under the keys defined in the Servlet 2.3 specification, for error pages that\n\t * are rendered directly rather than through the Servlet container's error page resolution:\n\t * {@code jakarta.servlet.error.status_code},\n\t * {@code jakarta.servlet.error.exception_type},\n\t * {@code jakarta.servlet.error.message},\n\t * {@code jakarta.servlet.error.exception},\n\t * {@code jakarta.servlet.error.request_uri},\n\t * {@code jakarta.servlet.error.servlet_name}.\n\t * <p>Does not override values if already present, to respect attribute values\n\t * that have been exposed explicitly before.\n\t * <p>Exposes status code 200 by default. Set the \"jakarta.servlet.error.status_code\"\n\t * attribute explicitly (before or after) in order to expose a different status code.\n\t * @param request current servlet request\n\t * @param ex the exception encountered\n\t * @param servletName the name of the offending servlet\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "ex",
      "servletName"
    ],
    "position": {
      "column": 1,
      "line": 524
    },
    "return": "void",
    "signature": "public void exposeErrorRequestAttributes(HttpServletRequest request, Throwable ex,\n\t\t\t@Nullable String servletName)",
    "source_code": "\tpublic static void exposeErrorRequestAttributes(HttpServletRequest request, Throwable ex,\n\t\t\t@Nullable String servletName) {\n\n\t\texposeRequestAttributeIfNotPresent(request, ERROR_STATUS_CODE_ATTRIBUTE, HttpServletResponse.SC_OK);\n\t\texposeRequestAttributeIfNotPresent(request, ERROR_EXCEPTION_TYPE_ATTRIBUTE, ex.getClass());\n\t\texposeRequestAttributeIfNotPresent(request, ERROR_MESSAGE_ATTRIBUTE, ex.getMessage());\n\t\texposeRequestAttributeIfNotPresent(request, ERROR_EXCEPTION_ATTRIBUTE, ex);\n\t\texposeRequestAttributeIfNotPresent(request, ERROR_REQUEST_URI_ATTRIBUTE, request.getRequestURI());\n\t\tif (servletName != null) {\n\t\t\texposeRequestAttributeIfNotPresent(request, ERROR_SERVLET_NAME_ATTRIBUTE, servletName);\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#findParameterValue(Map<String,parameters,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a named parameter from the given request parameters.\n\t * <p>This method will try to obtain a parameter value using the\n\t * following algorithm:\n\t * <ol>\n\t * <li>Try to get the parameter value using just the given <i>logical</i> name.\n\t * This handles parameters of the form {@code logicalName = value}. For normal\n\t * parameters, e.g. submitted using a hidden HTML form field, this will return\n\t * the requested value.</li>\n\t * <li>Try to obtain the parameter value from the parameter name, where the\n\t * parameter name in the request is of the form {@code logicalName_value = xyz}\n\t * with \"_\" being the configured delimiter. This deals with parameter values\n\t * submitted using an HTML form submit button.</li>\n\t * <li>If the value obtained in the previous step has a \".x\" or \".y\" suffix,\n\t * remove that. This handles cases where the value was submitted using an\n\t * HTML form image button. In this case the parameter in the request would\n\t * actually be of the form {@code logicalName_value.x = 123}.</li>\n\t * </ol>\n\t * @param parameters the available parameter map\n\t * @param name the <i>logical</i> name of the request parameter\n\t * @return the value of the parameter, or {@code null}\n\t * if the parameter does not exist in given request\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "parameters",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 650
    },
    "return": "String",
    "signature": "public String findParameterValue(Map<String, ?> parameters, String name)",
    "source_code": "\tpublic static String findParameterValue(Map<String, ?> parameters, String name) {\n\t\t// First try to get it as a normal name=value parameter\n\t\tObject value = parameters.get(name);\n\t\tif (value instanceof String[] values) {\n\t\t\treturn (values.length > 0 ? values[0] : null);\n\t\t}\n\t\telse if (value != null) {\n\t\t\treturn value.toString();\n\t\t}\n\t\t// If no value yet, try to get it as a name_value=xyz parameter\n\t\tString prefix = name + \"_\";\n\t\tfor (String paramName : parameters.keySet()) {\n\t\t\tif (paramName.startsWith(prefix)) {\n\t\t\t\t// Support images buttons, which would submit parameters as name_value.x=123\n\t\t\t\tfor (String suffix : SUBMIT_IMAGE_SUFFIXES) {\n\t\t\t\t\tif (paramName.endsWith(suffix)) {\n\t\t\t\t\t\treturn paramName.substring(prefix.length(), paramName.length() - suffix.length());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn paramName.substring(prefix.length());\n\t\t\t}\n\t\t}\n\t\t// We couldn't find the parameter value...\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.util.<unknown>#findParameterValue(request,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a named parameter from the given request parameters.\n\t * <p>See {@link #findParameterValue(java.util.Map, String)}\n\t * for a description of the lookup algorithm.\n\t * @param request current HTTP request\n\t * @param name the <i>logical</i> name of the request parameter\n\t * @return the value of the parameter, or {@code null}\n\t * if the parameter does not exist in given request\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 622
    },
    "return": "String",
    "signature": "public String findParameterValue(ServletRequest request, String name)",
    "source_code": "\tpublic static String findParameterValue(ServletRequest request, String name) {\n\t\treturn findParameterValue(request.getParameterMap(), name);\n\t}"
  },
  "org.springframework.web.util.<unknown>#getCookie(request,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the first cookie with the given name. Note that multiple\n\t * cookies can have the same name but different paths or domains.\n\t * @param request current servlet request\n\t * @param name cookie name\n\t * @return the first cookie with the given name, or {@code null} if none is found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 577
    },
    "return": "Cookie",
    "signature": "public Cookie getCookie(HttpServletRequest request, String name)",
    "source_code": "\tpublic static Cookie getCookie(HttpServletRequest request, String name) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tCookie[] cookies = request.getCookies();\n\t\tif (cookies != null) {\n\t\t\tfor (Cookie cookie : cookies) {\n\t\t\t\tif (name.equals(cookie.getName())) {\n\t\t\t\t\treturn cookie;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.util.<unknown>#getNativeRequest(request,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return an appropriate request object of the specified type, if available,\n\t * unwrapping the given request as far as necessary.\n\t * @param request the servlet request to introspect\n\t * @param requiredType the desired type of request object\n\t * @return the matching request object, or {@code null} if none\n\t * of that type is available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "T",
    "signature": "public T getNativeRequest(ServletRequest request, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic static <T> T getNativeRequest(ServletRequest request, @Nullable Class<T> requiredType) {\n\t\tif (requiredType != null) {\n\t\t\tif (requiredType.isInstance(request)) {\n\t\t\t\treturn (T) request;\n\t\t\t}\n\t\t\telse if (request instanceof ServletRequestWrapper wrapper) {\n\t\t\t\treturn getNativeRequest(wrapper.getRequest(), requiredType);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.util.<unknown>#getNativeResponse(response,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return an appropriate response object of the specified type, if available,\n\t * unwrapping the given response as far as necessary.\n\t * @param response the servlet response to introspect\n\t * @param requiredType the desired type of response object\n\t * @return the matching response object, or {@code null} if none\n\t * of that type is available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "response",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 481
    },
    "return": "T",
    "signature": "public T getNativeResponse(ServletResponse response, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic static <T> T getNativeResponse(ServletResponse response, @Nullable Class<T> requiredType) {\n\t\tif (requiredType != null) {\n\t\t\tif (requiredType.isInstance(response)) {\n\t\t\t\treturn (T) response;\n\t\t\t}\n\t\t\telse if (response instanceof ServletResponseWrapper wrapper) {\n\t\t\t\treturn getNativeResponse(wrapper.getResponse(), requiredType);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.util.<unknown>#getParametersStartingWith(request,prefix)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a map containing all parameters with the given prefix.\n\t * Maps single values to String and multiple values to String array.\n\t * <p>For example, with a prefix of \"spring_\", \"spring_param1\" and\n\t * \"spring_param2\" result in a Map with \"param1\" and \"param2\" as keys.\n\t * @param request the HTTP request in which to look for parameters\n\t * @param prefix the beginning of parameter names\n\t * (if this is null or the empty string, all parameters will match)\n\t * @return map containing request parameters <b>without the prefix</b>,\n\t * containing either a String or a String array as values\n\t * @see jakarta.servlet.ServletRequest#getParameterNames\n\t * @see jakarta.servlet.ServletRequest#getParameterValues\n\t * @see jakarta.servlet.ServletRequest#getParameterMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "Object>",
    "signature": "public Object> getParametersStartingWith(ServletRequest request, @Nullable String prefix)",
    "source_code": "\tpublic static Map<String, Object> getParametersStartingWith(ServletRequest request, @Nullable String prefix) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tEnumeration<String> paramNames = request.getParameterNames();\n\t\tMap<String, Object> params = new TreeMap<>();\n\t\tif (prefix == null) {\n\t\t\tprefix = \"\";\n\t\t}\n\t\twhile (paramNames != null && paramNames.hasMoreElements()) {\n\t\t\tString paramName = paramNames.nextElement();\n\t\t\tif (prefix.isEmpty() || paramName.startsWith(prefix)) {\n\t\t\t\tString unprefixed = paramName.substring(prefix.length());\n\t\t\t\tString[] values = request.getParameterValues(paramName);\n\t\t\t\tif (values == null || values.length == 0) {\n\t\t\t\t\t// Do nothing, no values found at all.\n\t\t\t\t}\n\t\t\t\telse if (values.length > 1) {\n\t\t\t\t\tparams.put(unprefixed, values);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparams.put(unprefixed, values[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn params;\n\t}"
  },
  "org.springframework.web.util.<unknown>#getRealPath(servletContext,path)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return the real path of the given path within the web application,\n\t * as provided by the servlet container.\n\t * <p>Prepends a slash if the path does not already start with a slash,\n\t * and throws a FileNotFoundException if the path cannot be resolved to\n\t * a resource (in contrast to ServletContext's {@code getRealPath},\n\t * which returns null).\n\t * @param servletContext the servlet context of the web application\n\t * @param path the path within the web application\n\t * @return the corresponding real path\n\t * @throws FileNotFoundException if the path cannot be resolved to a resource\n\t * @see jakarta.servlet.ServletContext#getRealPath\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext",
      "path"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "String",
    "signature": "public String getRealPath(ServletContext servletContext, String path)",
    "source_code": "\tpublic static String getRealPath(ServletContext servletContext, String path) throws FileNotFoundException {\n\t\tAssert.notNull(servletContext, \"ServletContext must not be null\");\n\t\t// Interpret location as relative to the web application root directory.\n\t\tif (!path.startsWith(\"/\")) {\n\t\t\tpath = \"/\" + path;\n\t\t}\n\t\tString realPath = servletContext.getRealPath(path);\n\t\tif (realPath == null) {\n\t\t\tthrow new FileNotFoundException(\n\t\t\t\t\t\"ServletContext resource [\" + path + \"] cannot be resolved to absolute file path - \" +\n\t\t\t\t\t\"web application archive not expanded?\");\n\t\t}\n\t\treturn realPath;\n\t}"
  },
  "org.springframework.web.util.<unknown>#getRequiredSessionAttribute(request,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check the given request for a session attribute of the given name.\n\t * Throws an exception if there is no session or if the session has no such\n\t * attribute. Does not create a new session if none has existed before!\n\t * @param request current HTTP request\n\t * @param name the name of the session attribute\n\t * @return the value of the session attribute, or {@code null} if not found\n\t * @throws IllegalStateException if the session attribute could not be found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "Object",
    "signature": "public Object getRequiredSessionAttribute(HttpServletRequest request, String name)",
    "source_code": "\tpublic static Object getRequiredSessionAttribute(HttpServletRequest request, String name)\n\t\t\tthrows IllegalStateException {\n\n\t\tObject attr = getSessionAttribute(request, name);\n\t\tif (attr == null) {\n\t\t\tthrow new IllegalStateException(\"No session attribute '\" + name + \"' found\");\n\t\t}\n\t\treturn attr;\n\t}"
  },
  "org.springframework.web.util.<unknown>#getSessionAttribute(request,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check the given request for a session attribute of the given name.\n\t * Returns null if there is no session or if the session has no such attribute.\n\t * Does not create a new session if none has existed before!\n\t * @param request current HTTP request\n\t * @param name the name of the session attribute\n\t * @return the value of the session attribute, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 373
    },
    "return": "Object",
    "signature": "public Object getSessionAttribute(HttpServletRequest request, String name)",
    "source_code": "\tpublic static Object getSessionAttribute(HttpServletRequest request, String name) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tHttpSession session = request.getSession(false);\n\t\treturn (session != null ? session.getAttribute(name) : null);\n\t}"
  },
  "org.springframework.web.util.<unknown>#hasSubmitParameter(request,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check if a specific input type=\"submit\" parameter was sent in the request,\n\t * either via a button (directly with name) or via an image (name + \".x\" or\n\t * name + \".y\").\n\t * @param request current HTTP request\n\t * @param name the name of the parameter\n\t * @return if the parameter was sent\n\t * @see #SUBMIT_IMAGE_SUFFIXES\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 599
    },
    "return": "boolean",
    "signature": "public boolean hasSubmitParameter(ServletRequest request, String name)",
    "source_code": "\tpublic static boolean hasSubmitParameter(ServletRequest request, String name) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tif (request.getParameter(name) != null) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (String suffix : SUBMIT_IMAGE_SUFFIXES) {\n\t\t\tif (request.getParameter(name + suffix) != null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.util.<unknown>#isValidOrigin(request,allowedOrigins)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check the given request origin against a list of allowed origins.\n\t * A list containing \"*\" means that all origins are allowed.\n\t * An empty list means only same origin is allowed.\n\t *\n\t * <p><strong>Note:</strong> as of 5.1 this method ignores\n\t * {@code \"Forwarded\"} and {@code \"X-Forwarded-*\"} headers that specify the\n\t * client-originated address. Consider using the {@code ForwardedHeaderFilter}\n\t * to extract and use, or to discard such headers.\n\t * @return {@code true} if the request origin is valid, {@code false} otherwise\n\t * @since 4.1.5\n\t * @see <a href=\"https://tools.ietf.org/html/rfc6454\">RFC 6454: The Web Origin Concept</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "allowedOrigins"
    ],
    "position": {
      "column": 1,
      "line": 764
    },
    "return": "boolean",
    "signature": "public boolean isValidOrigin(HttpRequest request, Collection<String> allowedOrigins)",
    "source_code": "\tpublic static boolean isValidOrigin(HttpRequest request, Collection<String> allowedOrigins) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tAssert.notNull(allowedOrigins, \"Allowed origins must not be null\");\n\n\t\tString origin = request.getHeaders().getOrigin();\n\t\tif (origin == null || allowedOrigins.contains(\"*\")) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (CollectionUtils.isEmpty(allowedOrigins)) {\n\t\t\treturn isSameOrigin(request);\n\t\t}\n\t\telse {\n\t\t\treturn allowedOrigins.contains(origin);\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#parseForwardedFor(request,remoteAddress)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the first \"Forwarded: for=...\" or \"X-Forwarded-For\" header value to\n\t * an {@code InetSocketAddress} representing the address of the client.\n\t * @param request a request with headers that may contain forwarded headers\n\t * @param remoteAddress the current remoteAddress\n\t * @return an {@code InetSocketAddress} with the extracted host and port, or\n\t * {@code null} if the headers are not present.\n\t * @since 5.3\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7239#section-5.2\">RFC 7239, Section 5.2</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "remoteAddress"
    ],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress parseForwardedFor(HttpRequest request, @Nullable InetSocketAddress remoteAddress)",
    "source_code": "\tpublic static InetSocketAddress parseForwardedFor(\n\t\t\tHttpRequest request, @Nullable InetSocketAddress remoteAddress) {\n\n\t\tint port = (remoteAddress != null ?\n\t\t\t\tremoteAddress.getPort() : \"https\".equals(request.getURI().getScheme()) ? 443 : 80);\n\n\t\tString forwardedHeader = request.getHeaders().getFirst(\"Forwarded\");\n\t\tif (StringUtils.hasText(forwardedHeader)) {\n\t\t\tString forwardedToUse = StringUtils.tokenizeToStringArray(forwardedHeader, \",\")[0];\n\t\t\tMatcher matcher = FORWARDED_FOR_PATTERN.matcher(forwardedToUse);\n\t\t\tif (matcher.find()) {\n\t\t\t\tString value = matcher.group(1).trim();\n\t\t\t\tString host = value;\n\t\t\t\tint portSeparatorIdx = value.lastIndexOf(':');\n\t\t\t\tint squareBracketIdx = value.lastIndexOf(']');\n\t\t\t\tif (portSeparatorIdx > squareBracketIdx) {\n\t\t\t\t\tif (squareBracketIdx == -1 && value.indexOf(':') != portSeparatorIdx) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid IPv4 address: \" + value);\n\t\t\t\t\t}\n\t\t\t\t\thost = value.substring(0, portSeparatorIdx);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tport = Integer.parseInt(value, portSeparatorIdx + 1, value.length(), 10);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NumberFormatException ex) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\t\"Failed to parse a port from \\\"forwarded\\\"-type header value: \" + value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn InetSocketAddress.createUnresolved(host, port);\n\t\t\t}\n\t\t}\n\n\t\tString forHeader = request.getHeaders().getFirst(\"X-Forwarded-For\");\n\t\tif (StringUtils.hasText(forHeader)) {\n\t\t\tString host = StringUtils.tokenizeToStringArray(forHeader, \",\")[0];\n\t\t\treturn InetSocketAddress.createUnresolved(host, port);\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.util.<unknown>#queryParam(name,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 737
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder queryParam(String name, @Nullable Collection<?> values)",
    "source_code": "\tpublic UriComponentsBuilder queryParam(String name, @Nullable Collection<?> values) {\n\t\treturn queryParam(name, (CollectionUtils.isEmpty(values) ? EMPTY_VALUES : values.toArray()));\n\t}"
  },
  "org.springframework.web.util.<unknown>#queryParamIfPresent(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 742
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder queryParamIfPresent(String name, Optional<?> value)",
    "source_code": "\tpublic UriComponentsBuilder queryParamIfPresent(String name, Optional<?> value) {\n\t\tvalue.ifPresent(v -> {\n\t\t\tif (v instanceof Collection<?> values) {\n\t\t\t\tqueryParam(name, values);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tqueryParam(name, v);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.<unknown>#queryParams(MultiValueMap<String,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 759
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder queryParams(@Nullable MultiValueMap<String, String> params)",
    "source_code": "\tpublic UriComponentsBuilder queryParams(@Nullable MultiValueMap<String, String> params) {\n\t\tif (params != null) {\n\t\t\tthis.queryParams.addAll(params);\n\t\t\tresetSchemeSpecificPart();\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.<unknown>#replaceQueryParam(name,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 779
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder replaceQueryParam(String name, @Nullable Collection<?> values)",
    "source_code": "\tpublic UriComponentsBuilder replaceQueryParam(String name, @Nullable Collection<?> values) {\n\t\treturn replaceQueryParam(name, (CollectionUtils.isEmpty(values) ? EMPTY_VALUES : values.toArray()));\n\t}"
  },
  "org.springframework.web.util.<unknown>#replaceQueryParams(MultiValueMap<String,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 788
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder replaceQueryParams(@Nullable MultiValueMap<String, String> params)",
    "source_code": "\tpublic UriComponentsBuilder replaceQueryParams(@Nullable MultiValueMap<String, String> params) {\n\t\tthis.queryParams.clear();\n\t\tif (params != null) {\n\t\t\tthis.queryParams.putAll(params);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.<unknown>#setParsedRequestPath(requestPath,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the cached, parsed {@code RequestPath} to the given value.\n\t * @param requestPath the value to set to, or if {@code null} the cache\n\t * value is cleared.\n\t * @param request the current request\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void setParsedRequestPath(@Nullable RequestPath requestPath, ServletRequest request)",
    "source_code": "\tpublic static void setParsedRequestPath(@Nullable RequestPath requestPath, ServletRequest request) {\n\t\tif (requestPath != null) {\n\t\t\trequest.setAttribute(PATH_ATTRIBUTE, requestPath);\n\t\t}\n\t\telse {\n\t\t\trequest.removeAttribute(PATH_ATTRIBUTE);\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#setSessionAttribute(request,name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the session attribute with the given name to the given value.\n\t * Removes the session attribute if value is null, if a session existed at all.\n\t * Does not create a new session if not necessary!\n\t * @param request current HTTP request\n\t * @param name the name of the session attribute\n\t * @param value the value of the session attribute\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 406
    },
    "return": "void",
    "signature": "public void setSessionAttribute(HttpServletRequest request, String name, @Nullable Object value)",
    "source_code": "\tpublic static void setSessionAttribute(HttpServletRequest request, String name, @Nullable Object value) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tif (value != null) {\n\t\t\trequest.getSession().setAttribute(name, value);\n\t\t}\n\t\telse {\n\t\t\tHttpSession session = request.getSession(false);\n\t\t\tif (session != null) {\n\t\t\t\tsession.removeAttribute(name);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#uriVariables(Map<String,uriVariables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure URI variables to be expanded at build time.\n\t * <p>The provided variables may be a subset of all required ones. At build\n\t * time, the available ones are expanded, while unresolved URI placeholders\n\t * are left in place and can still be expanded later.\n\t * <p>In contrast to {@link UriComponents#expand(Map)} or\n\t * {@link #buildAndExpand(Map)}, this method is useful when you need to\n\t * supply URI variables without building the {@link UriComponents} instance\n\t * just yet, or perhaps pre-expand some shared default values such as host\n\t * and port.\n\t * @param uriVariables the URI variables to use\n\t * @return this UriComponentsBuilder\n\t * @since 5.0.8\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 822
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder uriVariables(Map<String, Object> uriVariables)",
    "source_code": "\tpublic UriComponentsBuilder uriVariables(Map<String, Object> uriVariables) {\n\t\tthis.uriVariables.putAll(uriVariables);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.pattern.<unknown>#matches(pathIndex,matchingContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathIndex",
      "matchingContext"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "boolean",
    "signature": "public boolean matches(int pathIndex, MatchingContext matchingContext)",
    "source_code": "\tpublic boolean matches(int pathIndex, MatchingContext matchingContext) {\n\t\t// No need to handle 'match start' checking as this captures everything\n\t\t// anyway and cannot be followed by anything else\n\t\t// assert next == null\n\n\t\t// If there is more data, it must start with the separator\n\t\tif (pathIndex < matchingContext.pathLength && !matchingContext.isSeparator(pathIndex)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (matchingContext.determineRemainingPath) {\n\t\t\tmatchingContext.remainingPathIndex = matchingContext.pathLength;\n\t\t}\n\t\tif (matchingContext.extractingVariables) {\n\t\t\t// Collect the parameters from all the remaining segments\n\t\t\tMultiValueMap<String,String> parametersCollector = null;\n\t\t\tfor (int i = pathIndex; i < matchingContext.pathLength; i++) {\n\t\t\t\tElement element = matchingContext.pathElements.get(i);\n\t\t\t\tif (element instanceof PathSegment pathSegment) {\n\t\t\t\t\tMultiValueMap<String, String> parameters = pathSegment.parameters();\n\t\t\t\t\tif (!parameters.isEmpty()) {\n\t\t\t\t\t\tif (parametersCollector == null) {\n\t\t\t\t\t\t\tparametersCollector = new LinkedMultiValueMap<>();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparametersCollector.addAll(parameters);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmatchingContext.set(this.variableName, pathToString(pathIndex, matchingContext.pathElements),\n\t\t\t\t\tparametersCollector == null?NO_PARAMETERS:parametersCollector);\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.util.pattern.<unknown>#set(key,value,MultiValueMap<String,parameters)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value",
      "MultiValueMap<String",
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "void",
    "signature": "public void set(String key, String value, MultiValueMap<String,String> parameters)",
    "source_code": "\t\tpublic void set(String key, String value, MultiValueMap<String,String> parameters) {\n\t\t\tif (this.extractedUriVariables == null) {\n\t\t\t\tthis.extractedUriVariables = new HashMap<>();\n\t\t\t}\n\t\t\tthis.extractedUriVariables.put(key, value);\n\n\t\t\tif (!parameters.isEmpty()) {\n\t\t\t\tif (this.extractedMatrixVariables == null) {\n\t\t\t\t\tthis.extractedMatrixVariables = new HashMap<>();\n\t\t\t\t}\n\t\t\t\tthis.extractedMatrixVariables.put(key, CollectionUtils.unmodifiableMultiValueMap(parameters));\n\t\t\t}\n\t\t}"
  }
}