{
  "org.apache.commons.logging.<unknown>#createLocationAwareLog(name)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "Log",
    "signature": "public Log createLocationAwareLog(String name)",
    "source_code": "\t\tpublic static Log createLocationAwareLog(String name) {\n\t\t\tLogger logger = LoggerFactory.getLogger(name);\n\t\t\treturn (logger instanceof LocationAwareLogger locationAwareLogger ?\n\t\t\t\t\tnew Slf4jLocationAwareLog(locationAwareLogger) : new Slf4jLog<>(logger));\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#createLog(name)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "Log",
    "signature": "public Log createLog(String name)",
    "source_code": "\t\tpublic static Log createLog(String name) {\n\t\t\treturn new JavaUtilLog(name);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#debug(message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 581
    },
    "return": "void",
    "signature": "public void debug(Object message)",
    "source_code": "\t\tpublic void debug(Object message) {\n\t\t\tlog(java.util.logging.Level.FINE, message, null);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#debug(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 586
    },
    "return": "void",
    "signature": "public void debug(Object message, Throwable exception)",
    "source_code": "\t\tpublic void debug(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINE, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#error(message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 551
    },
    "return": "void",
    "signature": "public void error(Object message)",
    "source_code": "\t\tpublic void error(Object message) {\n\t\t\tlog(java.util.logging.Level.SEVERE, message, null);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#error(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 556
    },
    "return": "void",
    "signature": "public void error(Object message, Throwable exception)",
    "source_code": "\t\tpublic void error(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.SEVERE, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#fatal(message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 541
    },
    "return": "void",
    "signature": "public void fatal(Object message)",
    "source_code": "\t\tpublic void fatal(Object message) {\n\t\t\terror(message);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#fatal(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 546
    },
    "return": "void",
    "signature": "public void fatal(Object message, Throwable exception)",
    "source_code": "\t\tpublic void fatal(Object message, Throwable exception) {\n\t\t\terror(message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#getSourceClassName()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 635
    },
    "return": "String",
    "signature": "public String getSourceClassName()",
    "source_code": "\t\tpublic String getSourceClassName() {\n\t\t\tif (!this.resolved) {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t\treturn super.getSourceClassName();\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#getSourceMethodName()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 649
    },
    "return": "String",
    "signature": "public String getSourceMethodName()",
    "source_code": "\t\tpublic String getSourceMethodName() {\n\t\t\tif (!this.resolved) {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t\treturn super.getSourceMethodName();\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#info(message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 571
    },
    "return": "void",
    "signature": "public void info(Object message)",
    "source_code": "\t\tpublic void info(Object message) {\n\t\t\tlog(java.util.logging.Level.INFO, message, null);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#info(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 576
    },
    "return": "void",
    "signature": "public void info(Object message, Throwable exception)",
    "source_code": "\t\tpublic void info(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.INFO, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#isDebugEnabled()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 531
    },
    "return": "boolean",
    "signature": "public boolean isDebugEnabled()",
    "source_code": "\t\tpublic boolean isDebugEnabled() {\n\t\t\treturn this.logger.isLoggable(java.util.logging.Level.FINE);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#isErrorEnabled()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 516
    },
    "return": "boolean",
    "signature": "public boolean isErrorEnabled()",
    "source_code": "\t\tpublic boolean isErrorEnabled() {\n\t\t\treturn this.logger.isLoggable(java.util.logging.Level.SEVERE);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#isFatalEnabled()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 511
    },
    "return": "boolean",
    "signature": "public boolean isFatalEnabled()",
    "source_code": "\t\tpublic boolean isFatalEnabled() {\n\t\t\treturn isErrorEnabled();\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#isInfoEnabled()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 526
    },
    "return": "boolean",
    "signature": "public boolean isInfoEnabled()",
    "source_code": "\t\tpublic boolean isInfoEnabled() {\n\t\t\treturn this.logger.isLoggable(java.util.logging.Level.INFO);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#isTraceEnabled()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 536
    },
    "return": "boolean",
    "signature": "public boolean isTraceEnabled()",
    "source_code": "\t\tpublic boolean isTraceEnabled() {\n\t\t\treturn this.logger.isLoggable(java.util.logging.Level.FINEST);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#isWarnEnabled()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 521
    },
    "return": "boolean",
    "signature": "public boolean isWarnEnabled()",
    "source_code": "\t\tpublic boolean isWarnEnabled() {\n\t\t\treturn this.logger.isLoggable(java.util.logging.Level.WARNING);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#readResolve()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 617
    },
    "return": "Object",
    "signature": "protected Object readResolve()",
    "source_code": "\t\tprotected Object readResolve() {\n\t\t\treturn new JavaUtilLog(this.name);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#setSourceClassName(sourceClassName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceClassName"
    ],
    "position": {
      "column": 1,
      "line": 643
    },
    "return": "void",
    "signature": "public void setSourceClassName(String sourceClassName)",
    "source_code": "\t\tpublic void setSourceClassName(String sourceClassName) {\n\t\t\tsuper.setSourceClassName(sourceClassName);\n\t\t\tthis.resolved = true;\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#setSourceMethodName(sourceMethodName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceMethodName"
    ],
    "position": {
      "column": 1,
      "line": 657
    },
    "return": "void",
    "signature": "public void setSourceMethodName(String sourceMethodName)",
    "source_code": "\t\tpublic void setSourceMethodName(String sourceMethodName) {\n\t\t\tsuper.setSourceMethodName(sourceMethodName);\n\t\t\tthis.resolved = true;\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#trace(message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 591
    },
    "return": "void",
    "signature": "public void trace(Object message)",
    "source_code": "\t\tpublic void trace(Object message) {\n\t\t\tlog(java.util.logging.Level.FINEST, message, null);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#trace(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 596
    },
    "return": "void",
    "signature": "public void trace(Object message, Throwable exception)",
    "source_code": "\t\tpublic void trace(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINEST, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#warn(message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 561
    },
    "return": "void",
    "signature": "public void warn(Object message)",
    "source_code": "\t\tpublic void warn(Object message) {\n\t\t\tlog(java.util.logging.Level.WARNING, message, null);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#warn(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 566
    },
    "return": "void",
    "signature": "public void warn(Object message, Throwable exception)",
    "source_code": "\t\tpublic void warn(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.WARNING, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#writeReplace()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 682
    },
    "return": "Object",
    "signature": "protected Object writeReplace()",
    "source_code": "\t\tprotected Object writeReplace() {\n\t\t\tLogRecord serialized = new LogRecord(getLevel(), getMessage());\n\t\t\tserialized.setLoggerName(getLoggerName());\n\t\t\tserialized.setResourceBundle(getResourceBundle());\n\t\t\tserialized.setResourceBundleName(getResourceBundleName());\n\t\t\tserialized.setSourceClassName(getSourceClassName());\n\t\t\tserialized.setSourceMethodName(getSourceMethodName());\n\t\t\tserialized.setSequenceNumber(getSequenceNumber());\n\t\t\tserialized.setParameters(getParameters());\n\t\t\tserialized.setLongThreadID(getLongThreadID());\n\t\t\tserialized.setInstant(getInstant());\n\t\t\tserialized.setThrown(getThrown());\n\t\t\treturn serialized;\n\t\t}"
  },
  "org.apache.commons.logging.logger": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "signature": "protected T logger",
    "source_code": "\t\tprotected final transient T logger;",
    "type": "T"
  },
  "org.apache.commons.logging.name": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "signature": "protected String name",
    "source_code": "\t\tprotected final String name;",
    "type": "String"
  },
  "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer#getParameterNames(ctor)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * An advice method can never be a constructor in Spring.\n\t * @return {@code null}\n\t * @throws UnsupportedOperationException if\n\t * {@link #setRaiseExceptions(boolean) raiseExceptions} has been set to {@code true}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ctor"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "String[]",
    "signature": "public String[] getParameterNames(Constructor<?> ctor)",
    "source_code": "\tpublic String[] getParameterNames(Constructor<?> ctor) {\n\t\tif (this.raiseExceptions) {\n\t\t\tthrow new UnsupportedOperationException(\"An advice method can never be a constructor\");\n\t\t}\n\t\telse {\n\t\t\t// we return null rather than throw an exception so that we behave well\n\t\t\t// in a chain-of-responsibility.\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer#getParameterNames(method)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Deduce the parameter names for an advice method.\n\t * <p>See the {@link AspectJAdviceParameterNameDiscoverer class-level javadoc}\n\t * for this class for details on the algorithm used.\n\t * @param method the target {@link Method}\n\t * @return the parameter names\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "String[]",
    "signature": "public String[] getParameterNames(Method method)",
    "source_code": "\tpublic String[] getParameterNames(Method method) {\n\t\tthis.argumentTypes = method.getParameterTypes();\n\t\tthis.numberOfRemainingUnboundArguments = this.argumentTypes.length;\n\t\tthis.parameterNameBindings = new String[this.numberOfRemainingUnboundArguments];\n\n\t\tint minimumNumberUnboundArgs = 0;\n\t\tif (this.returningName != null) {\n\t\t\tminimumNumberUnboundArgs++;\n\t\t}\n\t\tif (this.throwingName != null) {\n\t\t\tminimumNumberUnboundArgs++;\n\t\t}\n\t\tif (this.numberOfRemainingUnboundArguments < minimumNumberUnboundArgs) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Not enough arguments in method to satisfy binding of returning and throwing variables\");\n\t\t}\n\n\t\ttry {\n\t\t\tint algorithmicStep = STEP_JOIN_POINT_BINDING;\n\t\t\twhile ((this.numberOfRemainingUnboundArguments > 0) && algorithmicStep < STEP_FINISHED) {\n\t\t\t\tswitch (algorithmicStep++) {\n\t\t\t\t\tcase STEP_JOIN_POINT_BINDING -> {\n\t\t\t\t\t\tif (!maybeBindThisJoinPoint()) {\n\t\t\t\t\t\t\tmaybeBindThisJoinPointStaticPart();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcase STEP_THROWING_BINDING -> maybeBindThrowingVariable();\n\t\t\t\t\tcase STEP_ANNOTATION_BINDING -> maybeBindAnnotationsFromPointcutExpression();\n\t\t\t\t\tcase STEP_RETURNING_BINDING -> maybeBindReturningVariable();\n\t\t\t\t\tcase STEP_PRIMITIVE_ARGS_BINDING -> maybeBindPrimitiveArgsFromPointcutExpression();\n\t\t\t\t\tcase STEP_THIS_TARGET_ARGS_BINDING -> maybeBindThisOrTargetOrArgsFromPointcutExpression();\n\t\t\t\t\tcase STEP_REFERENCE_PCUT_BINDING -> maybeBindReferencePointcutParameter();\n\t\t\t\t\tdefault -> throw new IllegalStateException(\"Unknown algorithmic step: \" + (algorithmicStep - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (AmbiguousBindingException | IllegalArgumentException ex) {\n\t\t\tif (this.raiseExceptions) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (this.numberOfRemainingUnboundArguments == 0) {\n\t\t\treturn this.parameterNameBindings;\n\t\t}\n\t\telse {\n\t\t\tif (this.raiseExceptions) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to bind all argument names: \" +\n\t\t\t\t\t\tthis.numberOfRemainingUnboundArguments + \" argument(s) could not be bound\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// convention for failing is to return null, allowing participation in a chain of responsibility\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An implementation of the AspectJ {@link ProceedingJoinPoint} interface\n * wrapping an AOP Alliance {@link org.aopalliance.intercept.MethodInvocation}.\n *\n * <p><b>Note</b>: The {@code getThis()} method returns the current Spring AOP proxy.\n * The {@code getTarget()} method returns the current Spring AOP target (which may be\n * {@code null} if there is no target instance) as a plain POJO without any advice.\n * <b>If you want to call the object and have the advice take effect, use {@code getThis()}.</b>\n * A common example is casting the object to an introduced interface in the implementation of\n * an introduction. There is no such distinction between target and proxy in AspectJ itself.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Adrian Colyer\n * @author Ramnivas Laddad\n * @since 2.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public class MethodInvocationProceedingJoinPoint",
    "source_code": "public class MethodInvocationProceedingJoinPoint implements ProceedingJoinPoint, JoinPoint.StaticPart {\n\n\tprivate static final ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();\n\n\tprivate final ProxyMethodInvocation methodInvocation;\n\n\tprivate @Nullable Object @Nullable [] args;\n\n\t/** Lazily initialized signature object. */\n\tprivate @Nullable Signature signature;\n\n\t/** Lazily initialized source location object. */\n\tprivate @Nullable SourceLocation sourceLocation;\n\n\n\t/**\n\t * Create a new MethodInvocationProceedingJoinPoint, wrapping the given\n\t * Spring ProxyMethodInvocation object.\n\t * @param methodInvocation the Spring ProxyMethodInvocation object\n\t */\n\tpublic MethodInvocationProceedingJoinPoint(ProxyMethodInvocation methodInvocation) {\n\t\tAssert.notNull(methodInvocation, \"MethodInvocation must not be null\");\n\t\tthis.methodInvocation = methodInvocation;\n\t}\n\n\n\t@Override\n\tpublic void set$AroundClosure(AroundClosure aroundClosure) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic @Nullable Object proceed() throws Throwable {\n\t\treturn this.methodInvocation.invocableClone().proceed();\n\t}\n\n\t@Override\n\tpublic @Nullable Object proceed(Object[] arguments) throws Throwable {\n\t\tAssert.notNull(arguments, \"Argument array passed to proceed cannot be null\");\n\t\tif (arguments.length != this.methodInvocation.getArguments().length) {\n\t\t\tthrow new IllegalArgumentException(\"Expecting \" +\n\t\t\t\t\tthis.methodInvocation.getArguments().length + \" arguments to proceed, \" +\n\t\t\t\t\t\"but was passed \" + arguments.length + \" arguments\");\n\t\t}\n\t\tthis.methodInvocation.setArguments(arguments);\n\t\treturn this.methodInvocation.invocableClone(arguments).proceed();\n\t}\n\n\t/**\n\t * Returns the Spring AOP proxy. Cannot be {@code null}.\n\t */\n\t@Override\n\tpublic Object getThis() {\n\t\treturn this.methodInvocation.getProxy();\n\t}\n\n\t/**\n\t * Returns the Spring AOP target. May be {@code null} if there is no target.\n\t */\n\t@Override\n\tpublic @Nullable Object getTarget() {\n\t\treturn this.methodInvocation.getThis();\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"NullAway\") // Overridden method does not define nullness\n\tpublic @Nullable Object[] getArgs() {\n\t\tif (this.args == null) {\n\t\t\tthis.args = this.methodInvocation.getArguments().clone();\n\t\t}\n\t\treturn this.args;\n\t}\n\n\t@Override\n\tpublic Signature getSignature() {\n\t\tif (this.signature == null) {\n\t\t\tthis.signature = new MethodSignatureImpl();\n\t\t}\n\t\treturn this.signature;\n\t}\n\n\t@Override\n\tpublic SourceLocation getSourceLocation() {\n\t\tif (this.sourceLocation == null) {\n\t\t\tthis.sourceLocation = new SourceLocationImpl();\n\t\t}\n\t\treturn this.sourceLocation;\n\t}\n\n\t@Override\n\tpublic String getKind() {\n\t\treturn ProceedingJoinPoint.METHOD_EXECUTION;\n\t}\n\n\t@Override\n\tpublic int getId() {\n\t\t// TODO: It's just an adapter but returning 0 might still have side effects...\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic JoinPoint.StaticPart getStaticPart() {\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic String toShortString() {\n\t\treturn \"execution(\" + getSignature().toShortString() + \")\";\n\t}\n\n\t@Override\n\tpublic String toLongString() {\n\t\treturn \"execution(\" + getSignature().toLongString() + \")\";\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"execution(\" + getSignature().toString() + \")\";\n\t}\n\n\n\t/**\n\t * Lazily initialized MethodSignature.\n\t */\n\tprivate class MethodSignatureImpl implements MethodSignature {\n\n\t\tprivate volatile @Nullable String @Nullable [] parameterNames;\n\n\t\t@Override\n\t\tpublic String getName() {\n\t\t\treturn methodInvocation.getMethod().getName();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getModifiers() {\n\t\t\treturn methodInvocation.getMethod().getModifiers();\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getDeclaringType() {\n\t\t\treturn methodInvocation.getMethod().getDeclaringClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic String getDeclaringTypeName() {\n\t\t\treturn methodInvocation.getMethod().getDeclaringClass().getName();\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getReturnType() {\n\t\t\treturn methodInvocation.getMethod().getReturnType();\n\t\t}\n\n\t\t@Override\n\t\tpublic Method getMethod() {\n\t\t\treturn methodInvocation.getMethod();\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?>[] getParameterTypes() {\n\t\t\treturn methodInvocation.getMethod().getParameterTypes();\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings(\"NullAway\") // Overridden method does not define nullness\n\t\tpublic @Nullable String @Nullable [] getParameterNames() {\n\t\t\t@Nullable String[] parameterNames = this.parameterNames;\n\t\t\tif (parameterNames == null) {\n\t\t\t\tparameterNames = parameterNameDiscoverer.getParameterNames(getMethod());\n\t\t\t\tthis.parameterNames = parameterNames;\n\t\t\t}\n\t\t\treturn parameterNames;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?>[] getExceptionTypes() {\n\t\t\treturn methodInvocation.getMethod().getExceptionTypes();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toShortString() {\n\t\t\treturn toString(false, false, false, false);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toLongString() {\n\t\t\treturn toString(true, true, true, true);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn toString(false, true, false, true);\n\t\t}\n\n\t\tprivate String toString(boolean includeModifier, boolean includeReturnTypeAndArgs,\n\t\t\t\tboolean useLongReturnAndArgumentTypeName, boolean useLongTypeName) {\n\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (includeModifier) {\n\t\t\t\tsb.append(Modifier.toString(getModifiers()));\n\t\t\t\tsb.append(' ');\n\t\t\t}\n\t\t\tif (includeReturnTypeAndArgs) {\n\t\t\t\tappendType(sb, getReturnType(), useLongReturnAndArgumentTypeName);\n\t\t\t\tsb.append(' ');\n\t\t\t}\n\t\t\tappendType(sb, getDeclaringType(), useLongTypeName);\n\t\t\tsb.append('.');\n\t\t\tsb.append(getMethod().getName());\n\t\t\tsb.append('(');\n\t\t\tClass<?>[] parametersTypes = getParameterTypes();\n\t\t\tappendTypes(sb, parametersTypes, includeReturnTypeAndArgs, useLongReturnAndArgumentTypeName);\n\t\t\tsb.append(')');\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tprivate void appendTypes(StringBuilder sb, Class<?>[] types, boolean includeArgs,\n\t\t\t\tboolean useLongReturnAndArgumentTypeName) {\n\n\t\t\tif (includeArgs) {\n\t\t\t\tfor (int size = types.length, i = 0; i < size; i++) {\n\t\t\t\t\tappendType(sb, types[i], useLongReturnAndArgumentTypeName);\n\t\t\t\t\tif (i < size - 1) {\n\t\t\t\t\t\tsb.append(',');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (types.length != 0) {\n\t\t\t\t\tsb.append(\"..\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void appendType(StringBuilder sb, Class<?> type, boolean useLongTypeName) {\n\t\t\tif (type.isArray()) {\n\t\t\t\tappendType(sb, type.componentType(), useLongTypeName);\n\t\t\t\tsb.append(\"[]\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(useLongTypeName ? type.getName() : type.getSimpleName());\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Lazily initialized SourceLocation.\n\t */\n\tprivate class SourceLocationImpl implements SourceLocation {\n\n\t\t@Override\n\t\tpublic Class<?> getWithinType() {\n\t\t\tif (methodInvocation.getThis() == null) {\n\t\t\t\tthrow new UnsupportedOperationException(\"No source location joinpoint available: target is null\");\n\t\t\t}\n\t\t\treturn methodInvocation.getThis().getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic String getFileName() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getLine() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic int getColumn() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint#getArgs()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "Object[]",
    "signature": "public Object[] getArgs()",
    "source_code": "\tpublic @Nullable Object[] getArgs() {\n\t\tif (this.args == null) {\n\t\t\tthis.args = this.methodInvocation.getArguments().clone();\n\t\t}\n\t\treturn this.args;\n\t}"
  },
  "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint#getColumn()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "int",
    "signature": "public int getColumn()",
    "source_code": "\t\tpublic int getColumn() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint#getDeclaringTypeName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "String",
    "signature": "public String getDeclaringTypeName()",
    "source_code": "\t\tpublic String getDeclaringTypeName() {\n\t\t\treturn methodInvocation.getMethod().getDeclaringClass().getName();\n\t\t}"
  },
  "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint#getFileName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "String",
    "signature": "public String getFileName()",
    "source_code": "\t\tpublic String getFileName() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint#getId()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "int",
    "signature": "public int getId()",
    "source_code": "\tpublic int getId() {\n\t\t// TODO: It's just an adapter but returning 0 might still have side effects...\n\t\treturn 0;\n\t}"
  },
  "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint#getKind()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "String",
    "signature": "public String getKind()",
    "source_code": "\tpublic String getKind() {\n\t\treturn ProceedingJoinPoint.METHOD_EXECUTION;\n\t}"
  },
  "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint#getLine()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "int",
    "signature": "public int getLine()",
    "source_code": "\t\tpublic int getLine() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint#getMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "Method",
    "signature": "public Method getMethod()",
    "source_code": "\t\tpublic Method getMethod() {\n\t\t\treturn methodInvocation.getMethod();\n\t\t}"
  },
  "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint#getModifiers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "int",
    "signature": "public int getModifiers()",
    "source_code": "\t\tpublic int getModifiers() {\n\t\t\treturn methodInvocation.getMethod().getModifiers();\n\t\t}"
  },
  "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "\t\tpublic String getName() {\n\t\t\treturn methodInvocation.getMethod().getName();\n\t\t}"
  },
  "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint#getSignature()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "Signature",
    "signature": "public Signature getSignature()",
    "source_code": "\tpublic Signature getSignature() {\n\t\tif (this.signature == null) {\n\t\t\tthis.signature = new MethodSignatureImpl();\n\t\t}\n\t\treturn this.signature;\n\t}"
  },
  "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint#getSourceLocation()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "SourceLocation",
    "signature": "public SourceLocation getSourceLocation()",
    "source_code": "\tpublic SourceLocation getSourceLocation() {\n\t\tif (this.sourceLocation == null) {\n\t\t\tthis.sourceLocation = new SourceLocationImpl();\n\t\t}\n\t\treturn this.sourceLocation;\n\t}"
  },
  "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint#getTarget()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the Spring AOP target. May be {@code null} if there is no target.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Object",
    "signature": "public Object getTarget()",
    "source_code": "\tpublic @Nullable Object getTarget() {\n\t\treturn this.methodInvocation.getThis();\n\t}"
  },
  "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint#getThis()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the Spring AOP proxy. Cannot be {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "Object",
    "signature": "public Object getThis()",
    "source_code": "\tpublic Object getThis() {\n\t\treturn this.methodInvocation.getProxy();\n\t}"
  },
  "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint#proceed()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "Object",
    "signature": "public Object proceed()",
    "source_code": "\tpublic @Nullable Object proceed() throws Throwable {\n\t\treturn this.methodInvocation.invocableClone().proceed();\n\t}"
  },
  "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint#proceed(arguments)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "Object",
    "signature": "public Object proceed(Object[] arguments)",
    "source_code": "\tpublic @Nullable Object proceed(Object[] arguments) throws Throwable {\n\t\tAssert.notNull(arguments, \"Argument array passed to proceed cannot be null\");\n\t\tif (arguments.length != this.methodInvocation.getArguments().length) {\n\t\t\tthrow new IllegalArgumentException(\"Expecting \" +\n\t\t\t\t\tthis.methodInvocation.getArguments().length + \" arguments to proceed, \" +\n\t\t\t\t\t\"but was passed \" + arguments.length + \" arguments\");\n\t\t}\n\t\tthis.methodInvocation.setArguments(arguments);\n\t\treturn this.methodInvocation.invocableClone(arguments).proceed();\n\t}"
  },
  "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint#toLongString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "String",
    "signature": "public String toLongString()",
    "source_code": "\t\tpublic String toLongString() {\n\t\t\treturn toString(true, true, true, true);\n\t\t}"
  },
  "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint#toShortString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "String",
    "signature": "public String toShortString()",
    "source_code": "\t\tpublic String toShortString() {\n\t\t\treturn toString(false, false, false, false);\n\t\t}"
  },
  "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn toString(false, true, false, true);\n\t\t}"
  },
  "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory#getParameterNames(ctor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ctor"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "String[]",
    "signature": "public String[] getParameterNames(Constructor<?> ctor)",
    "source_code": "\t\tpublic String[] getParameterNames(Constructor<?> ctor) {\n\t\t\tthrow new UnsupportedOperationException(\"Spring AOP cannot handle constructor advice\");\n\t\t}"
  },
  "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory#getParameterNames(method)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "String[]",
    "signature": "public String[] getParameterNames(Method method)",
    "source_code": "\t\tpublic String[] getParameterNames(Method method) {\n\t\t\tif (method.getParameterCount() == 0) {\n\t\t\t\treturn EMPTY_ARRAY;\n\t\t\t}\n\t\t\tAspectJAnnotation annotation = findAspectJAnnotationOnMethod(method);\n\t\t\tif (annotation == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tStringTokenizer nameTokens = new StringTokenizer(annotation.getArgumentNames(), \",\");\n\t\t\tint numTokens = nameTokens.countTokens();\n\t\t\tif (numTokens > 0) {\n\t\t\t\tString[] names = new String[numTokens];\n\t\t\t\tfor (int i = 0; i < names.length; i++) {\n\t\t\t\t\tnames[i] = nameTokens.nextToken();\n\t\t\t\t}\n\t\t\t\treturn names;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.aop.config.AspectComponentDefinition": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link org.springframework.beans.factory.parsing.ComponentDefinition}\n * that holds an aspect definition, including its nested pointcuts.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @since 2.0\n * @see #getNestedComponents()\n * @see PointcutComponentDefinition\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class AspectComponentDefinition",
    "source_code": "public class AspectComponentDefinition extends CompositeComponentDefinition {\n\n\tprivate final BeanDefinition[] beanDefinitions;\n\n\tprivate final BeanReference[] beanReferences;\n\n\n\tpublic AspectComponentDefinition(String aspectName, BeanDefinition @Nullable [] beanDefinitions,\n\t\t\tBeanReference @Nullable [] beanReferences, @Nullable Object source) {\n\n\t\tsuper(aspectName, source);\n\t\tthis.beanDefinitions = (beanDefinitions != null ? beanDefinitions : new BeanDefinition[0]);\n\t\tthis.beanReferences = (beanReferences != null ? beanReferences : new BeanReference[0]);\n\t}\n\n\n\t@Override\n\tpublic BeanDefinition[] getBeanDefinitions() {\n\t\treturn this.beanDefinitions;\n\t}\n\n\t@Override\n\tpublic BeanReference[] getBeanReferences() {\n\t\treturn this.beanReferences;\n\t}\n\n}"
  },
  "org.springframework.aop.config.AspectComponentDefinition#getBeanDefinitions()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "BeanDefinition[]",
    "signature": "public BeanDefinition[] getBeanDefinitions()",
    "source_code": "\tpublic BeanDefinition[] getBeanDefinitions() {\n\t\treturn this.beanDefinitions;\n\t}"
  },
  "org.springframework.aop.config.AspectComponentDefinition#getBeanReferences()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "BeanReference[]",
    "signature": "public BeanReference[] getBeanReferences()",
    "source_code": "\tpublic BeanReference[] getBeanReferences() {\n\t\treturn this.beanReferences;\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean(beanClass,beanName,targetSource)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName",
      "targetSource"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "Object[]",
    "signature": "protected Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanName, @Nullable TargetSource targetSource)",
    "source_code": "\tprotected Object[] getAdvicesAndAdvisorsForBean("
  },
  "org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#getAdvicesAndAdvisorsForBean(beanClass,beanName,customTargetSource)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the given bean is to be proxied, what additional\n\t * advices (for example, AOP Alliance interceptors) and advisors to apply.\n\t * @param beanClass the class of the bean to advise\n\t * @param beanName the name of the bean\n\t * @param customTargetSource the TargetSource returned by the\n\t * {@link #getCustomTargetSource} method: may be ignored.\n\t * Will be {@code null} if no custom target source is in use.\n\t * @return an array of additional interceptors for the particular bean;\n\t * or an empty array if no additional interceptors but just the common ones;\n\t * or {@code null} if no proxy at all, not even with the common interceptors.\n\t * See constants DO_NOT_PROXY and PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS.\n\t * @throws BeansException in case of errors\n\t * @see #DO_NOT_PROXY\n\t * @see #PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName",
      "customTargetSource"
    ],
    "position": {
      "column": 1,
      "line": 637
    },
    "return": "Object[]",
    "signature": "protected Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanName,\n\t\t\t@Nullable TargetSource customTargetSource)",
    "source_code": "\tprotected abstract Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanName,"
  },
  "org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Auto proxy creator that identifies beans to proxy via a list of names.\n * Checks for direct, \"xxx*\", and \"*xxx\" matches.\n *\n * <p>For configuration details, see the javadoc of the parent class\n * AbstractAutoProxyCreator. Typically, you will specify a list of\n * interceptor names to apply to all identified beans, via the\n * \"interceptorNames\" property.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 10.10.2003\n * @see #setBeanNames\n * @see #isMatch\n * @see #setInterceptorNames\n * @see AbstractAutoProxyCreator\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class BeanNameAutoProxyCreator",
    "source_code": "public class BeanNameAutoProxyCreator extends AbstractAutoProxyCreator {\n\n\tprivate static final String[] NO_ALIASES = new String[0];\n\n\tprivate @Nullable List<String> beanNames;\n\n\n\t/**\n\t * Set the names of the beans that should automatically get wrapped with proxies.\n\t * A name can specify a prefix to match by ending with \"*\", for example, \"myBean,tx*\"\n\t * will match the bean named \"myBean\" and all beans whose name start with \"tx\".\n\t * <p><b>NOTE:</b> In case of a FactoryBean, only the objects created by the\n\t * FactoryBean will get proxied. This default behavior applies as of Spring 2.0.\n\t * If you intend to proxy a FactoryBean instance itself (a rare use case, but\n\t * Spring 1.2's default behavior), specify the bean name of the FactoryBean\n\t * including the factory-bean prefix \"&amp;\": for example, \"&amp;myFactoryBean\".\n\t * @see org.springframework.beans.factory.FactoryBean\n\t * @see org.springframework.beans.factory.BeanFactory#FACTORY_BEAN_PREFIX\n\t */\n\tpublic void setBeanNames(String... beanNames) {\n\t\tAssert.notEmpty(beanNames, \"'beanNames' must not be empty\");\n\t\tthis.beanNames = new ArrayList<>(beanNames.length);\n\t\tfor (String mappedName : beanNames) {\n\t\t\tthis.beanNames.add(mappedName.strip());\n\t\t}\n\t}\n\n\n\t/**\n\t * Delegate to {@link AbstractAutoProxyCreator#getCustomTargetSource(Class, String)}\n\t * if the bean name matches one of the names in the configured list of supported\n\t * names, returning {@code null} otherwise.\n\t * @since 5.3\n\t * @see #setBeanNames(String...)\n\t */\n\t@Override\n\tprotected @Nullable TargetSource getCustomTargetSource(Class<?> beanClass, String beanName) {\n\t\treturn (isSupportedBeanName(beanClass, beanName) ?\n\t\t\t\tsuper.getCustomTargetSource(beanClass, beanName) : null);\n\t}\n\n\t/**\n\t * Identify as a bean to proxy if the bean name matches one of the names in\n\t * the configured list of supported names.\n\t * @see #setBeanNames(String...)\n\t */\n\t@Override\n\tprotected Object @Nullable [] getAdvicesAndAdvisorsForBean(\n\t\t\tClass<?> beanClass, String beanName, @Nullable TargetSource targetSource) {\n\n\t\treturn (isSupportedBeanName(beanClass, beanName) ?\n\t\t\t\tPROXY_WITHOUT_ADDITIONAL_INTERCEPTORS : DO_NOT_PROXY);\n\t}\n\n\t/**\n\t * Determine if the bean name for the given bean class matches one of the names\n\t * in the configured list of supported names.\n\t * @param beanClass the class of the bean to advise\n\t * @param beanName the name of the bean\n\t * @return {@code true} if the given bean name is supported\n\t * @see #setBeanNames(String...)\n\t */\n\tprivate boolean isSupportedBeanName(Class<?> beanClass, String beanName) {\n\t\tif (this.beanNames != null) {\n\t\t\tboolean isFactoryBean = FactoryBean.class.isAssignableFrom(beanClass);\n\t\t\tfor (String mappedName : this.beanNames) {\n\t\t\t\tif (isFactoryBean) {\n\t\t\t\t\tif (!mappedName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmappedName = mappedName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length());\n\t\t\t\t}\n\t\t\t\tif (isMatch(beanName, mappedName)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBeanFactory beanFactory = getBeanFactory();\n\t\t\tString[] aliases = (beanFactory != null ? beanFactory.getAliases(beanName) : NO_ALIASES);\n\t\t\tfor (String alias : aliases) {\n\t\t\t\tfor (String mappedName : this.beanNames) {\n\t\t\t\t\tif (isMatch(alias, mappedName)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine if the given bean name matches the mapped name.\n\t * <p>The default implementation checks for \"xxx*\", \"*xxx\" and \"*xxx*\" matches,\n\t * as well as direct equality. Can be overridden in subclasses.\n\t * @param beanName the bean name to check\n\t * @param mappedName the name in the configured list of names\n\t * @return if the names match\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */\n\tprotected boolean isMatch(String beanName, String mappedName) {\n\t\treturn PatternMatchUtils.simpleMatch(mappedName, beanName);\n\t}\n\n}"
  },
  "org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator#getCustomTargetSource(beanClass,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate to {@link AbstractAutoProxyCreator#getCustomTargetSource(Class, String)}\n\t * if the bean name matches one of the names in the configured list of supported\n\t * names, returning {@code null} otherwise.\n\t * @since 5.3\n\t * @see #setBeanNames(String...)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "TargetSource",
    "signature": "protected TargetSource getCustomTargetSource(Class<?> beanClass, String beanName)",
    "source_code": "\tprotected @Nullable TargetSource getCustomTargetSource(Class<?> beanClass, String beanName) {\n\t\treturn (isSupportedBeanName(beanClass, beanName) ?\n\t\t\t\tsuper.getCustomTargetSource(beanClass, beanName) : null);\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator#isMatch(beanName,mappedName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the given bean name matches the mapped name.\n\t * <p>The default implementation checks for \"xxx*\", \"*xxx\" and \"*xxx*\" matches,\n\t * as well as direct equality. Can be overridden in subclasses.\n\t * @param beanName the bean name to check\n\t * @param mappedName the name in the configured list of names\n\t * @return if the names match\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mappedName"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "boolean",
    "signature": "protected boolean isMatch(String beanName, String mappedName)",
    "source_code": "\tprotected boolean isMatch(String beanName, String mappedName) {\n\t\treturn PatternMatchUtils.simpleMatch(mappedName, beanName);\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator#setBeanNames(beanNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the names of the beans that should automatically get wrapped with proxies.\n\t * A name can specify a prefix to match by ending with \"*\", for example, \"myBean,tx*\"\n\t * will match the bean named \"myBean\" and all beans whose name start with \"tx\".\n\t * <p><b>NOTE:</b> In case of a FactoryBean, only the objects created by the\n\t * FactoryBean will get proxied. This default behavior applies as of Spring 2.0.\n\t * If you intend to proxy a FactoryBean instance itself (a rare use case, but\n\t * Spring 1.2's default behavior), specify the bean name of the FactoryBean\n\t * including the factory-bean prefix \"&amp;\": for example, \"&amp;myFactoryBean\".\n\t * @see org.springframework.beans.factory.FactoryBean\n\t * @see org.springframework.beans.factory.BeanFactory#FACTORY_BEAN_PREFIX\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanNames"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "public void setBeanNames(String... beanNames)",
    "source_code": "\tpublic void setBeanNames(String... beanNames) {\n\t\tAssert.notEmpty(beanNames, \"'beanNames' must not be empty\");\n\t\tthis.beanNames = new ArrayList<>(beanNames.length);\n\t\tfor (String mappedName : beanNames) {\n\t\t\tthis.beanNames.add(mappedName.strip());\n\t\t}\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.DO_NOT_PROXY": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience constant for subclasses: Return value for \"do not proxy\".\n\t * @see #getAdvicesAndAdvisorsForBean\n\t */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "signature": "protected Object[] DO_NOT_PROXY",
    "source_code": "\tprotected static final Object[] DO_NOT_PROXY = null;",
    "type": "Object[]"
  },
  "org.springframework.aop.framework.constructorArgs": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "signature": "protected Object[] constructorArgs",
    "source_code": "\tprotected Object[] constructorArgs;",
    "type": "Object[]"
  },
  "org.springframework.aop.support.RegexpMethodPointcutAdvisor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Convenient class for regexp method pointcuts that hold an Advice,\n * making them an {@link org.springframework.aop.Advisor}.\n *\n * <p>Configure this class using the \"pattern\" and \"patterns\"\n * pass-through properties. These are analogous to the pattern\n * and patterns properties of {@link AbstractRegexpMethodPointcut}.\n *\n * <p>Can delegate to any {@link AbstractRegexpMethodPointcut} subclass.\n * By default, {@link JdkRegexpMethodPointcut} will be used. To choose\n * a specific one, override the {@link #createPointcut} method.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @see #setPattern\n * @see #setPatterns\n * @see JdkRegexpMethodPointcut\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class RegexpMethodPointcutAdvisor",
    "source_code": "public class RegexpMethodPointcutAdvisor extends AbstractGenericPointcutAdvisor {\n\n\tprivate String @Nullable [] patterns;\n\n\tprivate @Nullable AbstractRegexpMethodPointcut pointcut;\n\n\tprivate final Object pointcutMonitor = new SerializableMonitor();\n\n\n\t/**\n\t * Create an empty RegexpMethodPointcutAdvisor.\n\t * @see #setPattern\n\t * @see #setPatterns\n\t * @see #setAdvice\n\t */\n\tpublic RegexpMethodPointcutAdvisor() {\n\t}\n\n\t/**\n\t * Create a RegexpMethodPointcutAdvisor for the given advice.\n\t * The pattern still needs to be specified afterwards.\n\t * @param advice the advice to use\n\t * @see #setPattern\n\t * @see #setPatterns\n\t */\n\tpublic RegexpMethodPointcutAdvisor(Advice advice) {\n\t\tsetAdvice(advice);\n\t}\n\n\t/**\n\t * Create a RegexpMethodPointcutAdvisor for the given advice.\n\t * @param pattern the pattern to use\n\t * @param advice the advice to use\n\t */\n\tpublic RegexpMethodPointcutAdvisor(String pattern, Advice advice) {\n\t\tsetPattern(pattern);\n\t\tsetAdvice(advice);\n\t}\n\n\t/**\n\t * Create a RegexpMethodPointcutAdvisor for the given advice.\n\t * @param patterns the patterns to use\n\t * @param advice the advice to use\n\t */\n\tpublic RegexpMethodPointcutAdvisor(String[] patterns, Advice advice) {\n\t\tsetPatterns(patterns);\n\t\tsetAdvice(advice);\n\t}\n\n\n\t/**\n\t * Set the regular expression defining methods to match.\n\t * <p>Use either this method or {@link #setPatterns}, not both.\n\t * @see #setPatterns\n\t */\n\tpublic void setPattern(String pattern) {\n\t\tsetPatterns(pattern);\n\t}\n\n\t/**\n\t * Set the regular expressions defining methods to match.\n\t * To be passed through to the pointcut implementation.\n\t * <p>Matching will be the union of all these; if any of the\n\t * patterns matches, the pointcut matches.\n\t * @see AbstractRegexpMethodPointcut#setPatterns\n\t */\n\tpublic void setPatterns(String... patterns) {\n\t\tthis.patterns = patterns;\n\t}\n\n\n\t/**\n\t * Initialize the singleton Pointcut held within this Advisor.\n\t */\n\t@Override\n\tpublic Pointcut getPointcut() {\n\t\tsynchronized (this.pointcutMonitor) {\n\t\t\tif (this.pointcut == null) {\n\t\t\t\tthis.pointcut = createPointcut();\n\t\t\t\tif (this.patterns != null) {\n\t\t\t\t\tthis.pointcut.setPatterns(this.patterns);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.pointcut;\n\t\t}\n\t}\n\n\t/**\n\t * Create the actual pointcut: By default, a {@link JdkRegexpMethodPointcut}\n\t * will be used.\n\t * @return the Pointcut instance (never {@code null})\n\t */\n\tprotected AbstractRegexpMethodPointcut createPointcut() {\n\t\treturn new JdkRegexpMethodPointcut();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getName() + \": advice [\" + getAdvice() +\n\t\t\t\t\"], pointcut patterns \" + ObjectUtils.nullSafeToString(this.patterns);\n\t}\n\n\n\t/**\n\t * Empty class used for a serializable monitor object.\n\t */\n\tprivate static class SerializableMonitor implements Serializable {\n\t}\n\n}"
  },
  "org.springframework.aop.support.RegexpMethodPointcutAdvisor#createPointcut()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the actual pointcut: By default, a {@link JdkRegexpMethodPointcut}\n\t * will be used.\n\t * @return the Pointcut instance (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "AbstractRegexpMethodPointcut",
    "signature": "protected AbstractRegexpMethodPointcut createPointcut()",
    "source_code": "\tprotected AbstractRegexpMethodPointcut createPointcut() {\n\t\treturn new JdkRegexpMethodPointcut();\n\t}"
  },
  "org.springframework.aop.support.RegexpMethodPointcutAdvisor#getPointcut()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the singleton Pointcut held within this Advisor.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "Pointcut",
    "signature": "public Pointcut getPointcut()",
    "source_code": "\tpublic Pointcut getPointcut() {\n\t\tsynchronized (this.pointcutMonitor) {\n\t\t\tif (this.pointcut == null) {\n\t\t\t\tthis.pointcut = createPointcut();\n\t\t\t\tif (this.patterns != null) {\n\t\t\t\t\tthis.pointcut.setPatterns(this.patterns);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.pointcut;\n\t\t}\n\t}"
  },
  "org.springframework.aop.support.RegexpMethodPointcutAdvisor#setPattern(pattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the regular expression defining methods to match.\n\t * <p>Use either this method or {@link #setPatterns}, not both.\n\t * @see #setPatterns\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "void",
    "signature": "public void setPattern(String pattern)",
    "source_code": "\tpublic void setPattern(String pattern) {\n\t\tsetPatterns(pattern);\n\t}"
  },
  "org.springframework.aop.support.RegexpMethodPointcutAdvisor#setPatterns(patterns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the regular expressions defining methods to match.\n\t * To be passed through to the pointcut implementation.\n\t * <p>Matching will be the union of all these; if any of the\n\t * patterns matches, the pointcut matches.\n\t * @see AbstractRegexpMethodPointcut#setPatterns\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "patterns"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void setPatterns(String... patterns)",
    "source_code": "\tpublic void setPatterns(String... patterns) {\n\t\tthis.patterns = patterns;\n\t}"
  },
  "org.springframework.aop.support.RegexpMethodPointcutAdvisor#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getName() + \": advice [\" + getAdvice() +\n\t\t\t\t\"], pointcut patterns \" + ObjectUtils.nullSafeToString(this.patterns);\n\t}"
  },
  "org.springframework.aot.generate.MethodReference": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A reference to a method with convenient code generation for\n * referencing, or invoking it.\n *\n * @author Stephane Nicoll\n * @author Phillip Webb\n * @since 6.0\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public interface MethodReference",
    "source_code": "public interface MethodReference {\n\n\t/**\n\t * Return this method reference as a {@link CodeBlock}. If the reference is\n\t * to an instance method then {@code this::<method name>} will be returned.\n\t * @return a code block for the method reference.\n\t */\n\tCodeBlock toCodeBlock();\n\n\t/**\n\t * Return this method reference as a {@link CodeBlock} using the specified\n\t * {@link ArgumentCodeGenerator}.\n\t * @param argumentCodeGenerator the argument code generator to use\n\t * @return a code block to invoke the method\n\t */\n\tdefault CodeBlock toInvokeCodeBlock(ArgumentCodeGenerator argumentCodeGenerator) {\n\t\treturn toInvokeCodeBlock(argumentCodeGenerator, null);\n\t}\n\n\t/**\n\t * Return this method reference as a {@link CodeBlock} using the specified\n\t * {@link ArgumentCodeGenerator}. The {@code targetClassName} defines the\n\t * context in which the method invocation is added.\n\t * <p>If the caller has an instance of the type in which this method is\n\t * defined, it can hint that by specifying the type as a target class.\n\t * @param argumentCodeGenerator the argument code generator to use\n\t * @param targetClassName the target class name\n\t * @return a code block to invoke the method\n\t */\n\tCodeBlock toInvokeCodeBlock(ArgumentCodeGenerator argumentCodeGenerator, @Nullable ClassName targetClassName);\n\n\n\t/**\n\t * Strategy for generating code for arguments based on their type.\n\t */\n\tinterface ArgumentCodeGenerator {\n\n\t\t/**\n\t\t * Generate the code for the given argument type. If this type is\n\t\t * not supported, return {@code null}.\n\t\t * @param argumentType the argument type\n\t\t * @return the code for this argument, or {@code null}\n\t\t */\n\t\t@Nullable CodeBlock generateCode(TypeName argumentType);\n\n\t\t/**\n\t\t * Factory method that returns an {@link ArgumentCodeGenerator} that\n\t\t * always returns {@code null}.\n\t\t * @return a new {@link ArgumentCodeGenerator} instance\n\t\t */\n\t\tstatic ArgumentCodeGenerator none() {\n\t\t\treturn from(type -> null);\n\t\t}\n\n\t\t/**\n\t\t * Factory method that can be used to create an {@link ArgumentCodeGenerator}\n\t\t * that support only the given argument type.\n\t\t * @param argumentType the argument type\n\t\t * @param argumentCode the code for an argument of that type\n\t\t * @return a new {@link ArgumentCodeGenerator} instance\n\t\t */\n\t\tstatic ArgumentCodeGenerator of(Class<?> argumentType, String argumentCode) {\n\t\t\treturn from(candidateType -> candidateType.equals(ClassName.get(argumentType)) ?\n\t\t\t\t\tCodeBlock.of(argumentCode) : null);\n\t\t}\n\n\t\t/**\n\t\t * Factory method that creates a new {@link ArgumentCodeGenerator} from\n\t\t * a lambda friendly function. The given function is provided with the\n\t\t * argument type and must provide the code to use or {@code null} if\n\t\t * the type is not supported.\n\t\t * @param function the resolver function\n\t\t * @return a new {@link ArgumentCodeGenerator} instance backed by the function\n\t\t */\n\t\tstatic ArgumentCodeGenerator from(Function<TypeName, @Nullable CodeBlock> function) {\n\t\t\treturn function::apply;\n\t\t}\n\n\t\t/**\n\t\t * Create a new composed {@link ArgumentCodeGenerator} by combining this\n\t\t * generator with supporting the given argument type.\n\t\t * @param argumentType the argument type\n\t\t * @param argumentCode the code for an argument of that type\n\t\t * @return a new composite {@link ArgumentCodeGenerator} instance\n\t\t */\n\t\tdefault ArgumentCodeGenerator and(Class<?> argumentType, String argumentCode) {\n\t\t\treturn and(ArgumentCodeGenerator.of(argumentType, argumentCode));\n\t\t}\n\n\t\t/**\n\t\t * Create a new composed {@link ArgumentCodeGenerator} by combining this\n\t\t * generator with the given generator.\n\t\t * @param argumentCodeGenerator the argument generator to add\n\t\t * @return a new composite {@link ArgumentCodeGenerator} instance\n\t\t */\n\t\tdefault ArgumentCodeGenerator and(ArgumentCodeGenerator argumentCodeGenerator) {\n\t\t\treturn from(type -> {\n\t\t\t\tCodeBlock code = generateCode(type);\n\t\t\t\treturn (code != null ? code : argumentCodeGenerator.generateCode(type));\n\t\t\t});\n\t\t}\n\n\t}\n\n}"
  },
  "org.springframework.aot.hint.ResourcePatternHint#matches(path)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the given path matches the current glob pattern.\n\t * @param path the path to match against\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "boolean",
    "signature": "public boolean matches(String path)",
    "source_code": "\tpublic boolean matches(String path) {\n\t\treturn PATH_MATCHER.match(this.pattern, path);\n\t}"
  },
  "org.springframework.aot.hint.ResourcePatternHint#toRegex()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the regex {@link Pattern} to use for identifying the resources to match.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "Pattern",
    "signature": "public Pattern toRegex()",
    "source_code": "\tpublic Pattern toRegex() {\n\t\tString prefix = (this.pattern.startsWith(\"*\") ? \".*\" : \"\");\n\t\tString suffix = (this.pattern.endsWith(\"*\") ? \".*\" : \"\");\n\t\tString regex = Arrays.stream(this.pattern.split(\"\\\\*\"))\n\t\t\t\t.filter(s -> !s.isEmpty())\n\t\t\t\t.map(Pattern::quote)\n\t\t\t\t.collect(Collectors.joining(\".*\", prefix, suffix));\n\t\treturn Pattern.compile(regex);\n\t}"
  },
  "org.springframework.aot.hint.support.FilePatternResourceHintsRegistrar#withClassPathLocations(classpathLocations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Consider the specified classpath locations.\n\t\t * <p>A location can either be a special {@value ResourceUtils#CLASSPATH_URL_PREFIX}\n\t\t * pseudo location or a standard location, such as {@code com/example/resources}.\n\t\t * An empty String represents the root of the classpath.\n\t\t * @param classpathLocations the classpath locations to consider\n\t\t * @return this builder\n\t\t * @since 7.0\n\t\t * @see #withClassPathLocations(String...)\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classpathLocations"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "Builder",
    "signature": "public Builder withClassPathLocations(List<String> classpathLocations)",
    "source_code": "\t\tpublic Builder withClassPathLocations(List<String> classpathLocations) {\n\t\t\tthis.classpathLocations.addAll(validateClassPathLocations(classpathLocations));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.aot.nativex.<unknown>#jni(hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "Object>>",
    "signature": "public Object>> jni(RuntimeHints hints)",
    "source_code": "\tpublic List<Map<String, Object>> jni(RuntimeHints hints) {\n\t\tList<Map<String, Object>> jniHints = new ArrayList<>();\n\t\tjniHints.addAll(hints.jni().typeHints()\n\t\t\t\t.sorted(Comparator.comparing(TypeHint::getType))\n\t\t\t\t.map(this::toAttributes).toList());\n\t\treturn jniHints;\n\t}"
  },
  "org.springframework.aot.nativex.<unknown>#reflection(hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "Object>>",
    "signature": "public Object>> reflection(RuntimeHints hints)",
    "source_code": "\tpublic List<Map<String, Object>> reflection(RuntimeHints hints) {\n\t\tList<Map<String, Object>> reflectionHints = new ArrayList<>();\n\t\treflectionHints.addAll(hints.reflection().typeHints()\n\t\t\t\t.sorted(Comparator.comparing(TypeHint::getType))\n\t\t\t\t.map(this::toAttributes).toList());\n\t\treflectionHints.addAll(hints.proxies().jdkProxyHints()\n\t\t\t\t.sorted(JDK_PROXY_HINT_COMPARATOR)\n\t\t\t\t.map(this::toAttributes).toList());\n\t\treturn reflectionHints;\n\t}"
  },
  "org.springframework.aot.nativex.<unknown>#write(writer,hints)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "writer",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "void",
    "signature": "public void write(BasicJsonWriter writer, ReflectionHints hints)",
    "source_code": "\tpublic void write(BasicJsonWriter writer, ReflectionHints hints) {\n\t\twriter.writeArray(hints.typeHints()\n\t\t\t\t.sorted(Comparator.comparing(TypeHint::getType))\n\t\t\t\t.map(this::toAttributes).toList());\n\t}"
  },
  "org.springframework.aot.nativex.INSTANCE": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public ReflectionHintsWriter INSTANCE",
    "source_code": "\tpublic static final ReflectionHintsWriter INSTANCE = new ReflectionHintsWriter();",
    "type": "ReflectionHintsWriter"
  },
  "org.springframework.beans.NotWritablePropertyException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Exception thrown on an attempt to set the value of a property that\n * is not writable (typically because there is no setter method).\n *\n * @author Rod Johnson\n * @author Alef Arendsen\n * @author Arjen Poutsma\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 30
    },
    "signature": "public class NotWritablePropertyException",
    "source_code": "public class NotWritablePropertyException extends InvalidPropertyException {\n\n\tprivate final String @Nullable [] possibleMatches;\n\n\n\t/**\n\t * Create a new NotWritablePropertyException.\n\t * @param beanClass the offending bean class\n\t * @param propertyName the offending property name\n\t */\n\tpublic NotWritablePropertyException(Class<?> beanClass, String propertyName) {\n\t\tsuper(beanClass, propertyName,\n\t\t\t\t\"Bean property '\" + propertyName + \"' is not writable or has an invalid setter method: \" +\n\t\t\t\t\"Does the return type of the getter match the parameter type of the setter?\");\n\t\tthis.possibleMatches = null;\n\t}\n\n\t/**\n\t * Create a new NotWritablePropertyException.\n\t * @param beanClass the offending bean class\n\t * @param propertyName the offending property name\n\t * @param msg the detail message\n\t */\n\tpublic NotWritablePropertyException(Class<?> beanClass, String propertyName, String msg) {\n\t\tsuper(beanClass, propertyName, msg);\n\t\tthis.possibleMatches = null;\n\t}\n\n\t/**\n\t * Create a new NotWritablePropertyException.\n\t * @param beanClass the offending bean class\n\t * @param propertyName the offending property name\n\t * @param msg the detail message\n\t * @param cause the root cause\n\t */\n\tpublic NotWritablePropertyException(Class<?> beanClass, String propertyName, String msg, Throwable cause) {\n\t\tsuper(beanClass, propertyName, msg, cause);\n\t\tthis.possibleMatches = null;\n\t}\n\n\t/**\n\t * Create a new NotWritablePropertyException.\n\t * @param beanClass the offending bean class\n\t * @param propertyName the offending property name\n\t * @param msg the detail message\n\t * @param possibleMatches suggestions for actual bean property names\n\t * that closely match the invalid property name\n\t */\n\tpublic NotWritablePropertyException(Class<?> beanClass, String propertyName, String msg, String[] possibleMatches) {\n\t\tsuper(beanClass, propertyName, msg);\n\t\tthis.possibleMatches = possibleMatches;\n\t}\n\n\n\t/**\n\t * Return suggestions for actual bean property names that closely match\n\t * the invalid property name, if any.\n\t */\n\tpublic String @Nullable [] getPossibleMatches() {\n\t\treturn this.possibleMatches;\n\t}\n\n}"
  },
  "org.springframework.beans.PropertyAccessorUtils#canonicalPropertyNames(propertyNames)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the canonical names for the given property paths.\n\t * @param propertyNames the bean property paths (as array)\n\t * @return the canonical representation of the property paths\n\t * (as array of the same size)\n\t * @see #canonicalPropertyName(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyNames"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "String[]",
    "signature": "public String[] canonicalPropertyNames(@Nullable String[] propertyNames)",
    "source_code": "\tpublic static String[] canonicalPropertyNames(@Nullable String[] propertyNames) {\n\t\tif (propertyNames == null) {\n\t\t\treturn null;\n\t\t}\n\t\tString[] result = new String[propertyNames.length];\n\t\tfor (int i = 0; i < propertyNames.length; i++) {\n\t\t\tresult[i] = canonicalPropertyName(propertyNames[i]);\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.TypeConverter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Interface that defines type conversion methods. Typically (but not necessarily)\n * implemented in conjunction with the {@link PropertyEditorRegistry} interface.\n *\n * <p><b>Note:</b> Since TypeConverter implementations are typically based on\n * {@link java.beans.PropertyEditor PropertyEditors} which aren't thread-safe,\n * TypeConverters themselves are <em>not</em> to be considered as thread-safe either.\n *\n * @author Juergen Hoeller\n * @since 2.0\n * @see SimpleTypeConverter\n * @see BeanWrapperImpl\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public interface TypeConverter",
    "source_code": "public interface TypeConverter {\n\n\t/**\n\t * Convert the value to the required type (if necessary from a String).\n\t * <p>Conversions from String to any type will typically use the {@code setAsText}\n\t * method of the PropertyEditor class, or a Spring Converter in a ConversionService.\n\t * @param value the value to convert\n\t * @param requiredType the type we must convert to\n\t * (or {@code null} if not known, for example in case of a collection element)\n\t * @return the new value, possibly the result of type conversion\n\t * @throws TypeMismatchException if type conversion failed\n\t * @see java.beans.PropertyEditor#setAsText(String)\n\t * @see java.beans.PropertyEditor#getValue()\n\t * @see org.springframework.core.convert.ConversionService\n\t * @see org.springframework.core.convert.converter.Converter\n\t */\n\t<T> @Nullable T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType) throws TypeMismatchException;\n\n\t/**\n\t * Convert the value to the required type (if necessary from a String).\n\t * <p>Conversions from String to any type will typically use the {@code setAsText}\n\t * method of the PropertyEditor class, or a Spring Converter in a ConversionService.\n\t * @param value the value to convert\n\t * @param requiredType the type we must convert to\n\t * (or {@code null} if not known, for example in case of a collection element)\n\t * @param methodParam the method parameter that is the target of the conversion\n\t * (for analysis of generic types; may be {@code null})\n\t * @return the new value, possibly the result of type conversion\n\t * @throws TypeMismatchException if type conversion failed\n\t * @see java.beans.PropertyEditor#setAsText(String)\n\t * @see java.beans.PropertyEditor#getValue()\n\t * @see org.springframework.core.convert.ConversionService\n\t * @see org.springframework.core.convert.converter.Converter\n\t */\n\t<T> @Nullable T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable MethodParameter methodParam) throws TypeMismatchException;\n\n\t/**\n\t * Convert the value to the required type (if necessary from a String).\n\t * <p>Conversions from String to any type will typically use the {@code setAsText}\n\t * method of the PropertyEditor class, or a Spring Converter in a ConversionService.\n\t * @param value the value to convert\n\t * @param requiredType the type we must convert to\n\t * (or {@code null} if not known, for example in case of a collection element)\n\t * @param field the reflective field that is the target of the conversion\n\t * (for analysis of generic types; may be {@code null})\n\t * @return the new value, possibly the result of type conversion\n\t * @throws TypeMismatchException if type conversion failed\n\t * @see java.beans.PropertyEditor#setAsText(String)\n\t * @see java.beans.PropertyEditor#getValue()\n\t * @see org.springframework.core.convert.ConversionService\n\t * @see org.springframework.core.convert.converter.Converter\n\t */\n\t<T> @Nullable T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field)\n\t\t\tthrows TypeMismatchException;\n\n\t/**\n\t * Convert the value to the required type (if necessary from a String).\n\t * <p>Conversions from String to any type will typically use the {@code setAsText}\n\t * method of the PropertyEditor class, or a Spring Converter in a ConversionService.\n\t * @param value the value to convert\n\t * @param requiredType the type we must convert to\n\t * (or {@code null} if not known, for example in case of a collection element)\n\t * @param typeDescriptor the type descriptor to use (may be {@code null}))\n\t * @return the new value, possibly the result of type conversion\n\t * @throws TypeMismatchException if type conversion failed\n\t * @since 5.1.4\n\t * @see java.beans.PropertyEditor#setAsText(String)\n\t * @see java.beans.PropertyEditor#getValue()\n\t * @see org.springframework.core.convert.ConversionService\n\t * @see org.springframework.core.convert.converter.Converter\n\t */\n\tdefault <T> @Nullable T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable TypeDescriptor typeDescriptor) throws TypeMismatchException {\n\n\t\tthrow new UnsupportedOperationException(\"TypeDescriptor resolution not supported\");\n\t}\n\n}"
  },
  "org.springframework.beans.TypeConverterSupport": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Base implementation of the {@link TypeConverter} interface, using a package-private delegate.\n * Mainly serves as base class for {@link BeanWrapperImpl}.\n *\n * @author Juergen Hoeller\n * @since 3.2\n * @see SimpleTypeConverter\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class TypeConverterSupport",
    "source_code": "public abstract class TypeConverterSupport extends PropertyEditorRegistrySupport implements TypeConverter {\n\n\t@Nullable TypeConverterDelegate typeConverterDelegate;\n\n\n\t@Override\n\tpublic <T> @Nullable T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType) throws TypeMismatchException {\n\t\treturn convertIfNecessary(null, value, requiredType, TypeDescriptor.valueOf(requiredType));\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable MethodParameter methodParam) throws TypeMismatchException {\n\n\t\treturn convertIfNecessary((methodParam != null ? methodParam.getParameterName() : null), value, requiredType,\n\t\t\t\t(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)));\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field)\n\t\t\tthrows TypeMismatchException {\n\n\t\treturn convertIfNecessary((field != null ? field.getName() : null), value, requiredType,\n\t\t\t\t(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)));\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable TypeDescriptor typeDescriptor) throws TypeMismatchException {\n\n\t\treturn convertIfNecessary(null, value, requiredType, typeDescriptor);\n\t}\n\n\tprivate <T> @Nullable T convertIfNecessary(@Nullable String propertyName, @Nullable Object value,\n\t\t\t@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws TypeMismatchException {\n\n\t\tAssert.state(this.typeConverterDelegate != null, \"No TypeConverterDelegate\");\n\t\ttry {\n\t\t\treturn this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\tpropertyName, null, value, requiredType, typeDescriptor);\n\t\t}\n\t\tcatch (ConverterNotFoundException | IllegalStateException ex) {\n\t\t\tthrow new ConversionNotSupportedException(value, requiredType, ex);\n\t\t}\n\t\tcatch (ConversionException | IllegalArgumentException ex) {\n\t\t\tthrow new TypeMismatchException(value, requiredType, ex);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.beans.TypeConverterSupport#convertIfNecessary(value,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic <T> @Nullable T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType) throws TypeMismatchException {\n\t\treturn convertIfNecessary(null, value, requiredType, TypeDescriptor.valueOf(requiredType));\n\t}"
  },
  "org.springframework.beans.TypeConverterSupport#convertIfNecessary(value,requiredType,field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field)",
    "source_code": "\tpublic <T> @Nullable T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field)"
  },
  "org.springframework.beans.TypeConverterSupport#convertIfNecessary(value,requiredType,methodParam)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "methodParam"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable MethodParameter methodParam)",
    "source_code": "\tpublic <T> @Nullable T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,"
  },
  "org.springframework.beans.TypeConverterSupport#convertIfNecessary(value,requiredType,typeDescriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "typeDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable TypeDescriptor typeDescriptor)",
    "source_code": "\tpublic <T> @Nullable T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,"
  },
  "org.springframework.beans.factory.BeanCreationException#getRelatedCauses()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the related causes, if any.\n\t * @return the array of related causes, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "Throwable[]",
    "signature": "public Throwable[] getRelatedCauses()",
    "source_code": "\tpublic Throwable[] getRelatedCauses() {\n\t\tif (this.relatedCauses == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.relatedCauses.toArray(new Throwable[0]);\n\t}"
  },
  "org.springframework.beans.factory.BeanFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * The root interface for accessing a Spring bean container.\n *\n * <p>This is the basic client view of a bean container;\n * further interfaces such as {@link ListableBeanFactory} and\n * {@link org.springframework.beans.factory.config.ConfigurableBeanFactory}\n * are available for specific purposes.\n *\n * <p>This interface is implemented by objects that hold a number of bean definitions,\n * each uniquely identified by a String name. Depending on the bean definition,\n * the factory will return either an independent instance of a contained object\n * (the Prototype design pattern), or a single shared instance (a superior\n * alternative to the Singleton design pattern, in which the instance is a\n * singleton in the scope of the factory). Which type of instance will be returned\n * depends on the bean factory configuration: the API is the same. Since Spring\n * 2.0, further scopes are available depending on the concrete application\n * context (for example, \"request\" and \"session\" scopes in a web environment).\n *\n * <p>The point of this approach is that the BeanFactory is a central registry\n * of application components, and centralizes configuration of application\n * components (no more do individual objects need to read properties files,\n * for example). See chapters 4 and 11 of \"Expert One-on-One J2EE Design and\n * Development\" for a discussion of the benefits of this approach.\n *\n * <p>Note that it is generally better to rely on Dependency Injection\n * (\"push\" configuration) to configure application objects through setters\n * or constructors, rather than use any form of \"pull\" configuration like a\n * BeanFactory lookup. Spring's Dependency Injection functionality is\n * implemented using this BeanFactory interface and its subinterfaces.\n *\n * <p>Normally a BeanFactory will load bean definitions stored in a configuration\n * source (such as an XML document), and use the {@code org.springframework.beans}\n * package to configure the beans. However, an implementation could simply return\n * Java objects it creates as necessary directly in Java code. There are no\n * constraints on how the definitions could be stored: LDAP, RDBMS, XML,\n * properties file, etc. Implementations are encouraged to support references\n * amongst beans (Dependency Injection).\n *\n * <p>In contrast to the methods in {@link ListableBeanFactory}, all of the\n * operations in this interface will also check parent factories if this is a\n * {@link HierarchicalBeanFactory}. If a bean is not found in this factory instance,\n * the immediate parent factory will be asked. Beans in this factory instance\n * are supposed to override beans of the same name in any parent factory.\n *\n * <p>Bean factory implementations should support the standard bean lifecycle interfaces\n * as far as possible. The full set of initialization methods and their standard order is:\n * <ol>\n * <li>BeanNameAware's {@code setBeanName}\n * <li>BeanClassLoaderAware's {@code setBeanClassLoader}\n * <li>BeanFactoryAware's {@code setBeanFactory}\n * <li>EnvironmentAware's {@code setEnvironment}\n * <li>EmbeddedValueResolverAware's {@code setEmbeddedValueResolver}\n * <li>ResourceLoaderAware's {@code setResourceLoader}\n * (only applicable when running in an application context)\n * <li>ApplicationEventPublisherAware's {@code setApplicationEventPublisher}\n * (only applicable when running in an application context)\n * <li>MessageSourceAware's {@code setMessageSource}\n * (only applicable when running in an application context)\n * <li>ApplicationContextAware's {@code setApplicationContext}\n * (only applicable when running in an application context)\n * <li>ServletContextAware's {@code setServletContext}\n * (only applicable when running in a web application context)\n * <li>{@code postProcessBeforeInitialization} methods of BeanPostProcessors\n * <li>InitializingBean's {@code afterPropertiesSet}\n * <li>a custom {@code init-method} definition\n * <li>{@code postProcessAfterInitialization} methods of BeanPostProcessors\n * </ol>\n *\n * <p>On shutdown of a bean factory, the following lifecycle methods apply:\n * <ol>\n * <li>{@code postProcessBeforeDestruction} methods of DestructionAwareBeanPostProcessors\n * <li>DisposableBean's {@code destroy}\n * <li>a custom {@code destroy-method} definition\n * </ol>\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Chris Beams\n * @since 13 April 2001\n * @see BeanNameAware#setBeanName\n * @see BeanClassLoaderAware#setBeanClassLoader\n * @see BeanFactoryAware#setBeanFactory\n * @see org.springframework.context.EnvironmentAware#setEnvironment\n * @see org.springframework.context.EmbeddedValueResolverAware#setEmbeddedValueResolver\n * @see org.springframework.context.ResourceLoaderAware#setResourceLoader\n * @see org.springframework.context.ApplicationEventPublisherAware#setApplicationEventPublisher\n * @see org.springframework.context.MessageSourceAware#setMessageSource\n * @see org.springframework.context.ApplicationContextAware#setApplicationContext\n * @see org.springframework.web.context.ServletContextAware#setServletContext\n * @see org.springframework.beans.factory.config.BeanPostProcessor#postProcessBeforeInitialization\n * @see InitializingBean#afterPropertiesSet\n * @see org.springframework.beans.factory.support.RootBeanDefinition#getInitMethodName\n * @see org.springframework.beans.factory.config.BeanPostProcessor#postProcessAfterInitialization\n * @see org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor#postProcessBeforeDestruction\n * @see DisposableBean#destroy\n * @see org.springframework.beans.factory.support.RootBeanDefinition#getDestroyMethodName\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "signature": "public interface BeanFactory",
    "source_code": "public interface BeanFactory {\n\n\t/**\n\t * Used to dereference a {@link FactoryBean} instance and distinguish it from\n\t * beans <i>created</i> by the FactoryBean. For example, if the bean named\n\t * {@code myJndiObject} is a FactoryBean, getting {@code &myJndiObject}\n\t * will return the factory, not the instance returned by the factory.\n\t */\n\tString FACTORY_BEAN_PREFIX = \"&\";\n\n\n\t/**\n\t * Return an instance, which may be shared or independent, of the specified bean.\n\t * <p>This method allows a Spring BeanFactory to be used as a replacement for the\n\t * Singleton or Prototype design pattern. Callers may retain references to\n\t * returned objects in the case of Singleton beans.\n\t * <p>Translates aliases back to the corresponding canonical bean name.\n\t * <p>Will ask the parent factory if the bean cannot be found in this factory instance.\n\t * @param name the name of the bean to retrieve\n\t * @return an instance of the bean.\n\t * Note that the return value will never be {@code null} but possibly a stub for\n\t * {@code null} returned from a factory method, to be checked via {@code equals(null)}.\n\t * Consider using {@link #getBeanProvider(Class)} for resolving optional dependencies.\n\t * @throws NoSuchBeanDefinitionException if there is no bean with the specified name\n\t * @throws BeansException if the bean could not be obtained\n\t */\n\tObject getBean(String name) throws BeansException;\n\n\t/**\n\t * Return an instance, which may be shared or independent, of the specified bean.\n\t * <p>Behaves the same as {@link #getBean(String)}, but provides a measure of type\n\t * safety by throwing a BeanNotOfRequiredTypeException if the bean is not of the\n\t * required type. This means that ClassCastException can't be thrown on casting\n\t * the result correctly, as can happen with {@link #getBean(String)}.\n\t * <p>Translates aliases back to the corresponding canonical bean name.\n\t * <p>Will ask the parent factory if the bean cannot be found in this factory instance.\n\t * @param name the name of the bean to retrieve\n\t * @param requiredType type the bean must match; can be an interface or superclass\n\t * @return an instance of the bean.\n\t * Note that the return value will never be {@code null}. In case of a stub for\n\t * {@code null} from a factory method having been resolved for the requested bean, a\n\t * {@code BeanNotOfRequiredTypeException} against the NullBean stub will be raised.\n\t * Consider using {@link #getBeanProvider(Class)} for resolving optional dependencies.\n\t * @throws NoSuchBeanDefinitionException if there is no such bean definition\n\t * @throws BeanNotOfRequiredTypeException if the bean is not of the required type\n\t * @throws BeansException if the bean could not be created\n\t */\n\t<T> T getBean(String name, Class<T> requiredType) throws BeansException;\n\n\t/**\n\t * Return an instance, which may be shared or independent, of the specified bean.\n\t * <p>Allows for specifying explicit constructor arguments / factory method arguments,\n\t * overriding the specified default arguments (if any) in the bean definition.\n\t * Note that the provided arguments need to match a specific candidate constructor /\n\t * factory method in the order of declared parameters.\n\t * @param name the name of the bean to retrieve\n\t * @param args arguments to use when creating a bean instance using explicit arguments\n\t * (only applied when creating a new instance as opposed to retrieving an existing one)\n\t * @return an instance of the bean\n\t * @throws NoSuchBeanDefinitionException if there is no such bean definition\n\t * @throws BeanDefinitionStoreException if arguments have been given but\n\t * the affected bean isn't a prototype\n\t * @throws BeansException if the bean could not be created\n\t * @since 2.5\n\t */\n\tObject getBean(String name, @Nullable Object @Nullable ... args) throws BeansException;\n\n\t/**\n\t * Return the bean instance that uniquely matches the given object type, if any.\n\t * <p>This method goes into {@link ListableBeanFactory} by-type lookup territory\n\t * but may also be translated into a conventional by-name lookup based on the name\n\t * of the given type. For more extensive retrieval operations across sets of beans,\n\t * use {@link ListableBeanFactory} and/or {@link BeanFactoryUtils}.\n\t * @param requiredType type the bean must match; can be an interface or superclass\n\t * @return an instance of the single bean matching the required type\n\t * @throws NoSuchBeanDefinitionException if no bean of the given type was found\n\t * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found\n\t * @throws BeansException if the bean could not be created\n\t * @since 3.0\n\t * @see ListableBeanFactory\n\t */\n\t<T> T getBean(Class<T> requiredType) throws BeansException;\n\n\t/**\n\t * Return an instance, which may be shared or independent, of the specified bean.\n\t * <p>Allows for specifying explicit constructor arguments / factory method arguments,\n\t * overriding the specified default arguments (if any) in the bean definition.\n\t * Note that the provided arguments need to match a specific candidate constructor /\n\t * factory method in the order of declared parameters.\n\t * <p>This method goes into {@link ListableBeanFactory} by-type lookup territory\n\t * but may also be translated into a conventional by-name lookup based on the name\n\t * of the given type. For more extensive retrieval operations across sets of beans,\n\t * use {@link ListableBeanFactory} and/or {@link BeanFactoryUtils}.\n\t * @param requiredType type the bean must match; can be an interface or superclass\n\t * @param args arguments to use when creating a bean instance using explicit arguments\n\t * (only applied when creating a new instance as opposed to retrieving an existing one)\n\t * @return an instance of the bean\n\t * @throws NoSuchBeanDefinitionException if there is no such bean definition\n\t * @throws BeanDefinitionStoreException if arguments have been given but\n\t * the affected bean isn't a prototype\n\t * @throws BeansException if the bean could not be created\n\t * @since 4.1\n\t */\n\t<T> T getBean(Class<T> requiredType, @Nullable Object @Nullable ... args) throws BeansException;\n\n\t/**\n\t * Return a provider for the specified bean, allowing for lazy on-demand retrieval\n\t * of instances, including availability and uniqueness options.\n\t * <p>For matching a generic type, consider {@link #getBeanProvider(ResolvableType)}.\n\t * @param requiredType type the bean must match; can be an interface or superclass\n\t * @return a corresponding provider handle\n\t * @since 5.1\n\t * @see #getBeanProvider(ResolvableType)\n\t */\n\t<T> ObjectProvider<T> getBeanProvider(Class<T> requiredType);\n\n\t/**\n\t * Return a provider for the specified bean, allowing for lazy on-demand retrieval\n\t * of instances, including availability and uniqueness options. This variant allows\n\t * for specifying a generic type to match, similar to reflective injection points\n\t * with generic type declarations in method/constructor parameters.\n\t * <p>Note that collections of beans are not supported here, in contrast to reflective\n\t * injection points. For programmatically retrieving a list of beans matching a\n\t * specific type, specify the actual bean type as an argument here and subsequently\n\t * use {@link ObjectProvider#orderedStream()} or its lazy streaming/iteration options.\n\t * <p>Also, generics matching is strict here, as per the Java assignment rules.\n\t * For lenient fallback matching with unchecked semantics (similar to the 'unchecked'\n\t * Java compiler warning), consider calling {@link #getBeanProvider(Class)} with the\n\t * raw type as a second step if no full generic match is\n\t * {@link ObjectProvider#getIfAvailable() available} with this variant.\n\t * @return a corresponding provider handle\n\t * @param requiredType type the bean must match; can be a generic type declaration\n\t * @since 5.1\n\t * @see ObjectProvider#iterator()\n\t * @see ObjectProvider#stream()\n\t * @see ObjectProvider#orderedStream()\n\t */\n\t<T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType);\n\n\t/**\n\t * Does this bean factory contain a bean definition or externally registered singleton\n\t * instance with the given name?\n\t * <p>If the given name is an alias, it will be translated back to the corresponding\n\t * canonical bean name.\n\t * <p>If this factory is hierarchical, will ask any parent factory if the bean cannot\n\t * be found in this factory instance.\n\t * <p>If a bean definition or singleton instance matching the given name is found,\n\t * this method will return {@code true} whether the named bean definition is concrete\n\t * or abstract, lazy or eager, in scope or not. Therefore, note that a {@code true}\n\t * return value from this method does not necessarily indicate that {@link #getBean}\n\t * will be able to obtain an instance for the same name.\n\t * @param name the name of the bean to query\n\t * @return whether a bean with the given name is present\n\t */\n\tboolean containsBean(String name);\n\n\t/**\n\t * Is this bean a shared singleton? That is, will {@link #getBean} always\n\t * return the same instance?\n\t * <p>Note: This method returning {@code false} does not clearly indicate\n\t * independent instances. It indicates non-singleton instances, which may correspond\n\t * to a scoped bean as well. Use the {@link #isPrototype} operation to explicitly\n\t * check for independent instances.\n\t * <p>Translates aliases back to the corresponding canonical bean name.\n\t * <p>Will ask the parent factory if the bean cannot be found in this factory instance.\n\t * @param name the name of the bean to query\n\t * @return whether this bean corresponds to a singleton instance\n\t * @throws NoSuchBeanDefinitionException if there is no bean with the given name\n\t * @see #getBean\n\t * @see #isPrototype\n\t */\n\tboolean isSingleton(String name) throws NoSuchBeanDefinitionException;\n\n\t/**\n\t * Is this bean a prototype? That is, will {@link #getBean} always return\n\t * independent instances?\n\t * <p>Note: This method returning {@code false} does not clearly indicate\n\t * a singleton object. It indicates non-independent instances, which may correspond\n\t * to a scoped bean as well. Use the {@link #isSingleton} operation to explicitly\n\t * check for a shared singleton instance.\n\t * <p>Translates aliases back to the corresponding canonical bean name.\n\t * <p>Will ask the parent factory if the bean cannot be found in this factory instance.\n\t * @param name the name of the bean to query\n\t * @return whether this bean will always deliver independent instances\n\t * @throws NoSuchBeanDefinitionException if there is no bean with the given name\n\t * @since 2.0.3\n\t * @see #getBean\n\t * @see #isSingleton\n\t */\n\tboolean isPrototype(String name) throws NoSuchBeanDefinitionException;\n\n\t/**\n\t * Check whether the bean with the given name matches the specified type.\n\t * More specifically, check whether a {@link #getBean} call for the given name\n\t * would return an object that is assignable to the specified target type.\n\t * <p>Translates aliases back to the corresponding canonical bean name.\n\t * <p>Will ask the parent factory if the bean cannot be found in this factory instance.\n\t * @param name the name of the bean to query\n\t * @param typeToMatch the type to match against (as a {@code ResolvableType})\n\t * @return {@code true} if the bean type matches,\n\t * {@code false} if it doesn't match or cannot be determined yet\n\t * @throws NoSuchBeanDefinitionException if there is no bean with the given name\n\t * @since 4.2\n\t * @see #getBean\n\t * @see #getType\n\t */\n\tboolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;\n\n\t/**\n\t * Check whether the bean with the given name matches the specified type.\n\t * More specifically, check whether a {@link #getBean} call for the given name\n\t * would return an object that is assignable to the specified target type.\n\t * <p>Translates aliases back to the corresponding canonical bean name.\n\t * <p>Will ask the parent factory if the bean cannot be found in this factory instance.\n\t * @param name the name of the bean to query\n\t * @param typeToMatch the type to match against (as a {@code Class})\n\t * @return {@code true} if the bean type matches,\n\t * {@code false} if it doesn't match or cannot be determined yet\n\t * @throws NoSuchBeanDefinitionException if there is no bean with the given name\n\t * @since 2.0.1\n\t * @see #getBean\n\t * @see #getType\n\t */\n\tboolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException;\n\n\t/**\n\t * Determine the type of the bean with the given name. More specifically,\n\t * determine the type of object that {@link #getBean} would return for the given name.\n\t * <p>For a {@link FactoryBean}, return the type of object that the FactoryBean creates,\n\t * as exposed by {@link FactoryBean#getObjectType()}. This may lead to the initialization\n\t * of a previously uninitialized {@code FactoryBean} (see {@link #getType(String, boolean)}).\n\t * <p>Translates aliases back to the corresponding canonical bean name.\n\t * <p>Will ask the parent factory if the bean cannot be found in this factory instance.\n\t * @param name the name of the bean to query\n\t * @return the type of the bean, or {@code null} if not determinable\n\t * @throws NoSuchBeanDefinitionException if there is no bean with the given name\n\t * @since 1.1.2\n\t * @see #getBean\n\t * @see #isTypeMatch\n\t */\n\t@Nullable Class<?> getType(String name) throws NoSuchBeanDefinitionException;\n\n\t/**\n\t * Determine the type of the bean with the given name. More specifically,\n\t * determine the type of object that {@link #getBean} would return for the given name.\n\t * <p>For a {@link FactoryBean}, return the type of object that the FactoryBean creates,\n\t * as exposed by {@link FactoryBean#getObjectType()}. Depending on the\n\t * {@code allowFactoryBeanInit} flag, this may lead to the initialization of a previously\n\t * uninitialized {@code FactoryBean} if no early type information is available.\n\t * <p>Translates aliases back to the corresponding canonical bean name.\n\t * <p>Will ask the parent factory if the bean cannot be found in this factory instance.\n\t * @param name the name of the bean to query\n\t * @param allowFactoryBeanInit whether a {@code FactoryBean} may get initialized\n\t * just for the purpose of determining its object type\n\t * @return the type of the bean, or {@code null} if not determinable\n\t * @throws NoSuchBeanDefinitionException if there is no bean with the given name\n\t * @since 5.2\n\t * @see #getBean\n\t * @see #isTypeMatch\n\t */\n\t@Nullable Class<?> getType(String name, boolean allowFactoryBeanInit) throws NoSuchBeanDefinitionException;\n\n\t/**\n\t * Return the aliases for the given bean name, if any.\n\t * <p>All of those aliases point to the same bean when used in a {@link #getBean} call.\n\t * <p>If the given name is an alias, the corresponding original bean name\n\t * and other aliases (if any) will be returned, with the original bean name\n\t * being the first element in the array.\n\t * <p>Will ask the parent factory if the bean cannot be found in this factory instance.\n\t * @param name the bean name to check for aliases\n\t * @return the aliases, or an empty array if none\n\t * @see #getBean\n\t */\n\tString[] getAliases(String name);\n\n}"
  },
  "org.springframework.beans.factory.InjectionPoint": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A simple descriptor for an injection point, pointing to a method/constructor\n * parameter or a field.\n *\n * <p>Exposed by {@link UnsatisfiedDependencyException}. Also available as an\n * argument for factory methods, reacting to the requesting injection point\n * for building a customized bean instance.\n *\n * @author Juergen Hoeller\n * @since 4.3\n * @see UnsatisfiedDependencyException#getInjectionPoint()\n * @see org.springframework.beans.factory.config.DependencyDescriptor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class InjectionPoint",
    "source_code": "public class InjectionPoint {\n\n\tprotected @Nullable MethodParameter methodParameter;\n\n\tprotected @Nullable Field field;\n\n\tprivate volatile Annotation @Nullable [] fieldAnnotations;\n\n\n\t/**\n\t * Create an injection point descriptor for a method or constructor parameter.\n\t * @param methodParameter the MethodParameter to wrap\n\t */\n\tpublic InjectionPoint(MethodParameter methodParameter) {\n\t\tAssert.notNull(methodParameter, \"MethodParameter must not be null\");\n\t\tthis.methodParameter = methodParameter;\n\t}\n\n\t/**\n\t * Create an injection point descriptor for a field.\n\t * @param field the field to wrap\n\t */\n\tpublic InjectionPoint(Field field) {\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\tthis.field = field;\n\t}\n\n\t/**\n\t * Copy constructor.\n\t * @param original the original descriptor to create a copy from\n\t */\n\tprotected InjectionPoint(InjectionPoint original) {\n\t\tthis.methodParameter = (original.methodParameter != null ?\n\t\t\t\tnew MethodParameter(original.methodParameter) : null);\n\t\tthis.field = original.field;\n\t\tthis.fieldAnnotations = original.fieldAnnotations;\n\t}\n\n\t/**\n\t * Just available for serialization purposes in subclasses.\n\t */\n\tprotected InjectionPoint() {\n\t}\n\n\n\t/**\n\t * Return the wrapped MethodParameter, if any.\n\t * <p>Note: Either MethodParameter or Field is available.\n\t * @return the MethodParameter, or {@code null} if none\n\t */\n\tpublic @Nullable MethodParameter getMethodParameter() {\n\t\treturn this.methodParameter;\n\t}\n\n\t/**\n\t * Return the wrapped Field, if any.\n\t * <p>Note: Either MethodParameter or Field is available.\n\t * @return the Field, or {@code null} if none\n\t */\n\tpublic @Nullable Field getField() {\n\t\treturn this.field;\n\t}\n\n\t/**\n\t * Return the wrapped MethodParameter, assuming it is present.\n\t * @return the MethodParameter (never {@code null})\n\t * @throws IllegalStateException if no MethodParameter is available\n\t * @since 5.0\n\t */\n\tprotected final MethodParameter obtainMethodParameter() {\n\t\tAssert.state(this.methodParameter != null, \"MethodParameter is not available\");\n\t\treturn this.methodParameter;\n\t}\n\n\t/**\n\t * Obtain the annotations associated with the wrapped field or method/constructor parameter.\n\t */\n\tpublic Annotation[] getAnnotations() {\n\t\tif (this.field != null) {\n\t\t\tAnnotation[] fieldAnnotations = this.fieldAnnotations;\n\t\t\tif (fieldAnnotations == null) {\n\t\t\t\tfieldAnnotations = this.field.getAnnotations();\n\t\t\t\tthis.fieldAnnotations = fieldAnnotations;\n\t\t\t}\n\t\t\treturn fieldAnnotations;\n\t\t}\n\t\telse {\n\t\t\treturn obtainMethodParameter().getParameterAnnotations();\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve a field/parameter annotation of the given type, if any.\n\t * @param annotationType the annotation type to retrieve\n\t * @return the annotation instance, or {@code null} if none found\n\t * @since 4.3.9\n\t */\n\tpublic <A extends Annotation> @Nullable A getAnnotation(Class<A> annotationType) {\n\t\treturn (this.field != null ? this.field.getAnnotation(annotationType) :\n\t\t\t\tobtainMethodParameter().getParameterAnnotation(annotationType));\n\t}\n\n\t/**\n\t * Return the type declared by the underlying field or method/constructor parameter,\n\t * indicating the injection type.\n\t */\n\tpublic Class<?> getDeclaredType() {\n\t\treturn (this.field != null ? this.field.getType() : obtainMethodParameter().getParameterType());\n\t}\n\n\t/**\n\t * Returns the wrapped member, containing the injection point.\n\t * @return the Field / Method / Constructor as Member\n\t */\n\tpublic Member getMember() {\n\t\treturn (this.field != null ? this.field : obtainMethodParameter().getMember());\n\t}\n\n\t/**\n\t * Return the wrapped annotated element.\n\t * <p>Note: In case of a method/constructor parameter, this exposes\n\t * the annotations declared on the method or constructor itself\n\t * (i.e. at the method/constructor level, not at the parameter level).\n\t * Use {@link #getAnnotations()} to obtain parameter-level annotations in\n\t * such a scenario, transparently with corresponding field annotations.\n\t * @return the Field / Method / Constructor as AnnotatedElement\n\t */\n\tpublic AnnotatedElement getAnnotatedElement() {\n\t\treturn (this.field != null ? this.field : obtainMethodParameter().getAnnotatedElement());\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (other == null || getClass() != other.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tInjectionPoint otherPoint = (InjectionPoint) other;\n\t\treturn (ObjectUtils.nullSafeEquals(this.field, otherPoint.field) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.methodParameter, otherPoint.methodParameter));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hash(this.field, this.methodParameter);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn (this.field != null ? \"field '\" + this.field.getName() + \"'\" : String.valueOf(this.methodParameter));\n\t}\n\n}"
  },
  "org.springframework.beans.factory.InjectionPoint#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (other == null || getClass() != other.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tInjectionPoint otherPoint = (InjectionPoint) other;\n\t\treturn (ObjectUtils.nullSafeEquals(this.field, otherPoint.field) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.methodParameter, otherPoint.methodParameter));\n\t}"
  },
  "org.springframework.beans.factory.InjectionPoint#getAnnotatedElement()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the wrapped annotated element.\n\t * <p>Note: In case of a method/constructor parameter, this exposes\n\t * the annotations declared on the method or constructor itself\n\t * (i.e. at the method/constructor level, not at the parameter level).\n\t * Use {@link #getAnnotations()} to obtain parameter-level annotations in\n\t * such a scenario, transparently with corresponding field annotations.\n\t * @return the Field / Method / Constructor as AnnotatedElement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "AnnotatedElement",
    "signature": "public AnnotatedElement getAnnotatedElement()",
    "source_code": "\tpublic AnnotatedElement getAnnotatedElement() {\n\t\treturn (this.field != null ? this.field : obtainMethodParameter().getAnnotatedElement());\n\t}"
  },
  "org.springframework.beans.factory.InjectionPoint#getAnnotation(annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a field/parameter annotation of the given type, if any.\n\t * @param annotationType the annotation type to retrieve\n\t * @return the annotation instance, or {@code null} if none found\n\t * @since 4.3.9\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "A",
    "signature": "public A getAnnotation(Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> @Nullable A getAnnotation(Class<A> annotationType) {\n\t\treturn (this.field != null ? this.field.getAnnotation(annotationType) :\n\t\t\t\tobtainMethodParameter().getParameterAnnotation(annotationType));\n\t}"
  },
  "org.springframework.beans.factory.InjectionPoint#getAnnotations()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the annotations associated with the wrapped field or method/constructor parameter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "Annotation[]",
    "signature": "public Annotation[] getAnnotations()",
    "source_code": "\tpublic Annotation[] getAnnotations() {\n\t\tif (this.field != null) {\n\t\t\tAnnotation[] fieldAnnotations = this.fieldAnnotations;\n\t\t\tif (fieldAnnotations == null) {\n\t\t\t\tfieldAnnotations = this.field.getAnnotations();\n\t\t\t\tthis.fieldAnnotations = fieldAnnotations;\n\t\t\t}\n\t\t\treturn fieldAnnotations;\n\t\t}\n\t\telse {\n\t\t\treturn obtainMethodParameter().getParameterAnnotations();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.InjectionPoint#getField()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the wrapped Field, if any.\n\t * <p>Note: Either MethodParameter or Field is available.\n\t * @return the Field, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "Field",
    "signature": "public Field getField()",
    "source_code": "\tpublic @Nullable Field getField() {\n\t\treturn this.field;\n\t}"
  },
  "org.springframework.beans.factory.InjectionPoint#getMember()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the wrapped member, containing the injection point.\n\t * @return the Field / Method / Constructor as Member\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "Member",
    "signature": "public Member getMember()",
    "source_code": "\tpublic Member getMember() {\n\t\treturn (this.field != null ? this.field : obtainMethodParameter().getMember());\n\t}"
  },
  "org.springframework.beans.factory.InjectionPoint#getMethodParameter()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the wrapped MethodParameter, if any.\n\t * <p>Note: Either MethodParameter or Field is available.\n\t * @return the MethodParameter, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getMethodParameter()",
    "source_code": "\tpublic @Nullable MethodParameter getMethodParameter() {\n\t\treturn this.methodParameter;\n\t}"
  },
  "org.springframework.beans.factory.InjectionPoint#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn Objects.hash(this.field, this.methodParameter);\n\t}"
  },
  "org.springframework.beans.factory.InjectionPoint#obtainMethodParameter()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the wrapped MethodParameter, assuming it is present.\n\t * @return the MethodParameter (never {@code null})\n\t * @throws IllegalStateException if no MethodParameter is available\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "MethodParameter",
    "signature": "protected MethodParameter obtainMethodParameter()",
    "source_code": "\tprotected final MethodParameter obtainMethodParameter() {\n\t\tAssert.state(this.methodParameter != null, \"MethodParameter is not available\");\n\t\treturn this.methodParameter;\n\t}"
  },
  "org.springframework.beans.factory.InjectionPoint#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn (this.field != null ? \"field '\" + this.field.getName() + \"'\" : String.valueOf(this.methodParameter));\n\t}"
  },
  "org.springframework.beans.factory.ListableBeanFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Extension of the {@link BeanFactory} interface to be implemented by bean factories\n * that can enumerate all their bean instances, rather than attempting bean lookup\n * by name one by one as requested by clients. BeanFactory implementations that\n * preload all their bean definitions (such as XML-based factories) may implement\n * this interface.\n *\n * <p>If this is a {@link HierarchicalBeanFactory}, the return values will <i>not</i>\n * take any BeanFactory hierarchy into account, but will relate only to the beans\n * defined in the current factory. Use the {@link BeanFactoryUtils} helper class\n * to consider beans in ancestor factories too.\n *\n * <p>The methods in this interface will just respect bean definitions of this factory.\n * They will ignore any singleton beans that have been registered by other means like\n * {@link org.springframework.beans.factory.config.ConfigurableBeanFactory}'s\n * {@code registerSingleton} method, with the exception of\n * {@code getBeanNamesForType} and {@code getBeansOfType} which will check\n * such manually registered singletons too. Of course, BeanFactory's {@code getBean}\n * does allow transparent access to such special beans as well. However, in typical\n * scenarios, all beans will be defined by external bean definitions anyway, so most\n * applications don't need to worry about this differentiation.\n *\n * <p><b>NOTE:</b> With the exception of {@code getBeanDefinitionCount}\n * and {@code containsBeanDefinition}, the methods in this interface\n * are not designed for frequent invocation. Implementations may be slow.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 16 April 2001\n * @see HierarchicalBeanFactory\n * @see BeanFactoryUtils\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public interface ListableBeanFactory",
    "source_code": "public interface ListableBeanFactory extends BeanFactory {\n\n\t/**\n\t * Check if this bean factory contains a bean definition with the given name.\n\t * <p>Does not consider any hierarchy this factory may participate in,\n\t * and ignores any singleton beans that have been registered by\n\t * other means than bean definitions.\n\t * @param beanName the name of the bean to look for\n\t * @return if this bean factory contains a bean definition with the given name\n\t * @see #containsBean\n\t */\n\tboolean containsBeanDefinition(String beanName);\n\n\t/**\n\t * Return the number of beans defined in the factory.\n\t * <p>Does not consider any hierarchy this factory may participate in,\n\t * and ignores any singleton beans that have been registered by\n\t * other means than bean definitions.\n\t * @return the number of beans defined in the factory\n\t */\n\tint getBeanDefinitionCount();\n\n\t/**\n\t * Return the names of all beans defined in this factory.\n\t * <p>Does not consider any hierarchy this factory may participate in,\n\t * and ignores any singleton beans that have been registered by\n\t * other means than bean definitions.\n\t * @return the names of all beans defined in this factory,\n\t * or an empty array if none defined\n\t */\n\tString[] getBeanDefinitionNames();\n\n\t/**\n\t * Return a provider for the specified bean, allowing for lazy on-demand retrieval\n\t * of instances, including availability and uniqueness options.\n\t * @param requiredType type the bean must match; can be an interface or superclass\n\t * @param allowEagerInit whether stream access may introspect <i>lazy-init singletons</i>\n\t * and <i>objects created by FactoryBeans</i> - or by factory methods with a\n\t * \"factory-bean\" reference - for the type check. Note that FactoryBeans need to be\n\t * eagerly initialized to determine their type: So be aware that passing in \"true\"\n\t * for this flag will initialize FactoryBeans and \"factory-bean\" references. Only\n\t * actually necessary initialization for type checking purposes will be performed;\n\t * constructor and method invocations will still be avoided as far as possible.\n\t * @return a corresponding provider handle\n\t * @since 5.3\n\t * @see #getBeanProvider(ResolvableType, boolean)\n\t * @see #getBeanProvider(Class)\n\t * @see #getBeansOfType(Class, boolean, boolean)\n\t * @see #getBeanNamesForType(Class, boolean, boolean)\n\t */\n\t<T> ObjectProvider<T> getBeanProvider(Class<T> requiredType, boolean allowEagerInit);\n\n\t/**\n\t * Return a provider for the specified bean, allowing for lazy on-demand retrieval\n\t * of instances, including availability and uniqueness options.\n\t * @param requiredType type the bean must match; can be a generic type declaration.\n\t * Note that collection types are not supported here, in contrast to reflective\n\t * injection points. For programmatically retrieving a list of beans matching a\n\t * specific type, specify the actual bean type as an argument here and subsequently\n\t * use {@link ObjectProvider#orderedStream()} or its lazy streaming/iteration options.\n\t * @param allowEagerInit whether stream access may introspect <i>lazy-init singletons</i>\n\t * and <i>objects created by FactoryBeans</i> - or by factory methods with a\n\t * \"factory-bean\" reference - for the type check. Note that FactoryBeans need to be\n\t * eagerly initialized to determine their type: So be aware that passing in \"true\"\n\t * for this flag will initialize FactoryBeans and \"factory-bean\" references. Only\n\t * actually necessary initialization for type checking purposes will be performed;\n\t * constructor and method invocations will still be avoided as far as possible.\n\t * @return a corresponding provider handle\n\t * @since 5.3\n\t * @see #getBeanProvider(ResolvableType)\n\t * @see ObjectProvider#iterator()\n\t * @see ObjectProvider#stream()\n\t * @see ObjectProvider#orderedStream()\n\t * @see #getBeanNamesForType(ResolvableType, boolean, boolean)\n\t */\n\t<T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit);\n\n\t/**\n\t * Return the names of beans matching the given type (including subclasses),\n\t * judging from either bean definitions or the value of {@code getObjectType}\n\t * in the case of FactoryBeans.\n\t * <p><b>NOTE: This method introspects top-level beans only.</b> It does <i>not</i>\n\t * check nested beans which might match the specified type as well.\n\t * <p>Does consider objects created by FactoryBeans, which means that FactoryBeans\n\t * will get initialized. If the object created by the FactoryBean doesn't match,\n\t * the raw FactoryBean itself will be matched against the type.\n\t * <p>Does not consider any hierarchy this factory may participate in.\n\t * Use BeanFactoryUtils' {@code beanNamesForTypeIncludingAncestors}\n\t * to include beans in ancestor factories too.\n\t * <p>Note: Does <i>not</i> ignore singleton beans that have been registered\n\t * by other means than bean definitions.\n\t * <p>This version of {@code getBeanNamesForType} matches all kinds of beans,\n\t * be it singletons, prototypes, or FactoryBeans. In most implementations, the\n\t * result will be the same as for {@code getBeanNamesForType(type, true, true)}.\n\t * <p>Bean names returned by this method should always return bean names <i>in the\n\t * order of definition</i> in the backend configuration, as far as possible.\n\t * @param type the generically typed class or interface to match\n\t * @return the names of beans (or objects created by FactoryBeans) matching\n\t * the given object type (including subclasses), or an empty array if none\n\t * @since 4.2\n\t * @see #isTypeMatch(String, ResolvableType)\n\t * @see FactoryBean#getObjectType\n\t * @see BeanFactoryUtils#beanNamesForTypeIncludingAncestors(ListableBeanFactory, ResolvableType)\n\t */\n\tString[] getBeanNamesForType(ResolvableType type);\n\n\t/**\n\t * Return the names of beans matching the given type (including subclasses),\n\t * judging from either bean definitions or the value of {@code getObjectType}\n\t * in the case of FactoryBeans.\n\t * <p><b>NOTE: This method introspects top-level beans only.</b> It does <i>not</i>\n\t * check nested beans which might match the specified type as well.\n\t * <p>Does consider objects created by FactoryBeans if the \"allowEagerInit\" flag is set,\n\t * which means that FactoryBeans will get initialized. If the object created by the\n\t * FactoryBean doesn't match, the raw FactoryBean itself will be matched against the\n\t * type. If \"allowEagerInit\" is not set, only raw FactoryBeans will be checked\n\t * (which doesn't require initialization of each FactoryBean).\n\t * <p>Does not consider any hierarchy this factory may participate in.\n\t * Use BeanFactoryUtils' {@code beanNamesForTypeIncludingAncestors}\n\t * to include beans in ancestor factories too.\n\t * <p>Note: Does <i>not</i> ignore singleton beans that have been registered\n\t * by other means than bean definitions.\n\t * <p>Bean names returned by this method should always return bean names <i>in the\n\t * order of definition</i> in the backend configuration, as far as possible.\n\t * @param type the generically typed class or interface to match\n\t * @param includeNonSingletons whether to include prototype or scoped beans too\n\t * or just singletons (also applies to FactoryBeans)\n\t * @param allowEagerInit whether to introspect <i>lazy-init singletons</i>\n\t * and <i>objects created by FactoryBeans</i> - or by factory methods with a\n\t * \"factory-bean\" reference - for the type check. Note that FactoryBeans need to be\n\t * eagerly initialized to determine their type: So be aware that passing in \"true\"\n\t * for this flag will initialize FactoryBeans and \"factory-bean\" references. Only\n\t * actually necessary initialization for type checking purposes will be performed;\n\t * constructor and method invocations will still be avoided as far as possible.\n\t * @return the names of beans (or objects created by FactoryBeans) matching\n\t * the given object type (including subclasses), or an empty array if none\n\t * @since 5.2\n\t * @see FactoryBean#getObjectType\n\t * @see BeanFactoryUtils#beanNamesForTypeIncludingAncestors(ListableBeanFactory, ResolvableType, boolean, boolean)\n\t */\n\tString[] getBeanNamesForType(ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit);\n\n\t/**\n\t * Return the names of beans matching the given type (including subclasses),\n\t * judging from either bean definitions or the value of {@code getObjectType}\n\t * in the case of FactoryBeans.\n\t * <p><b>NOTE: This method introspects top-level beans only.</b> It does <i>not</i>\n\t * check nested beans which might match the specified type as well.\n\t * <p>Does consider objects created by FactoryBeans, which means that FactoryBeans\n\t * will get initialized. If the object created by the FactoryBean doesn't match,\n\t * the raw FactoryBean itself will be matched against the type.\n\t * <p>Does not consider any hierarchy this factory may participate in.\n\t * Use BeanFactoryUtils' {@code beanNamesForTypeIncludingAncestors}\n\t * to include beans in ancestor factories too.\n\t * <p>Note: Does <i>not</i> ignore singleton beans that have been registered\n\t * by other means than bean definitions.\n\t * <p>This version of {@code getBeanNamesForType} matches all kinds of beans,\n\t * be it singletons, prototypes, or FactoryBeans. In most implementations, the\n\t * result will be the same as for {@code getBeanNamesForType(type, true, true)}.\n\t * <p>Bean names returned by this method should always return bean names <i>in the\n\t * order of definition</i> in the backend configuration, as far as possible.\n\t * @param type the class or interface to match, or {@code null} for all bean names\n\t * @return the names of beans (or objects created by FactoryBeans) matching\n\t * the given object type (including subclasses), or an empty array if none\n\t * @see FactoryBean#getObjectType\n\t * @see BeanFactoryUtils#beanNamesForTypeIncludingAncestors(ListableBeanFactory, Class)\n\t */\n\tString[] getBeanNamesForType(@Nullable Class<?> type);\n\n\t/**\n\t * Return the names of beans matching the given type (including subclasses),\n\t * judging from either bean definitions or the value of {@code getObjectType}\n\t * in the case of FactoryBeans.\n\t * <p><b>NOTE: This method introspects top-level beans only.</b> It does <i>not</i>\n\t * check nested beans which might match the specified type as well.\n\t * <p>Does consider objects created by FactoryBeans if the \"allowEagerInit\" flag is set,\n\t * which means that FactoryBeans will get initialized. If the object created by the\n\t * FactoryBean doesn't match, the raw FactoryBean itself will be matched against the\n\t * type. If \"allowEagerInit\" is not set, only raw FactoryBeans will be checked\n\t * (which doesn't require initialization of each FactoryBean).\n\t * <p>Does not consider any hierarchy this factory may participate in.\n\t * Use BeanFactoryUtils' {@code beanNamesForTypeIncludingAncestors}\n\t * to include beans in ancestor factories too.\n\t * <p>Note: Does <i>not</i> ignore singleton beans that have been registered\n\t * by other means than bean definitions.\n\t * <p>Bean names returned by this method should always return bean names <i>in the\n\t * order of definition</i> in the backend configuration, as far as possible.\n\t * @param type the class or interface to match, or {@code null} for all bean names\n\t * @param includeNonSingletons whether to include prototype or scoped beans too\n\t * or just singletons (also applies to FactoryBeans)\n\t * @param allowEagerInit whether to introspect <i>lazy-init singletons</i>\n\t * and <i>objects created by FactoryBeans</i> - or by factory methods with a\n\t * \"factory-bean\" reference - for the type check. Note that FactoryBeans need to be\n\t * eagerly initialized to determine their type: So be aware that passing in \"true\"\n\t * for this flag will initialize FactoryBeans and \"factory-bean\" references. Only\n\t * actually necessary initialization for type checking purposes will be performed;\n\t * constructor and method invocations will still be avoided as far as possible.\n\t * @return the names of beans (or objects created by FactoryBeans) matching\n\t * the given object type (including subclasses), or an empty array if none\n\t * @see FactoryBean#getObjectType\n\t * @see BeanFactoryUtils#beanNamesForTypeIncludingAncestors(ListableBeanFactory, Class, boolean, boolean)\n\t */\n\tString[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit);\n\n\t/**\n\t * Return the bean instances that match the given object type (including\n\t * subclasses), judging from either bean definitions or the value of\n\t * {@code getObjectType} in the case of FactoryBeans.\n\t * <p><b>NOTE: This method introspects top-level beans only.</b> It does <i>not</i>\n\t * check nested beans which might match the specified type as well.\n\t * <p>Does consider objects created by FactoryBeans, which means that FactoryBeans\n\t * will get initialized. If the object created by the FactoryBean doesn't match,\n\t * the raw FactoryBean itself will be matched against the type.\n\t * <p>Does not consider any hierarchy this factory may participate in.\n\t * Use BeanFactoryUtils' {@code beansOfTypeIncludingAncestors}\n\t * to include beans in ancestor factories too.\n\t * <p>Note: Does <i>not</i> ignore singleton beans that have been registered\n\t * by other means than bean definitions.\n\t * <p>This version of getBeansOfType matches all kinds of beans, be it\n\t * singletons, prototypes, or FactoryBeans. In most implementations, the\n\t * result will be the same as for {@code getBeansOfType(type, true, true)}.\n\t * <p>The Map returned by this method should always return bean names and\n\t * corresponding bean instances <i>in the order of definition</i> in the\n\t * backend configuration, as far as possible.\n\t * @param type the class or interface to match, or {@code null} for all concrete beans\n\t * @return a Map with the matching beans, containing the bean names as\n\t * keys and the corresponding bean instances as values\n\t * @throws BeansException if a bean could not be created\n\t * @since 1.1.2\n\t * @see FactoryBean#getObjectType\n\t * @see BeanFactoryUtils#beansOfTypeIncludingAncestors(ListableBeanFactory, Class)\n\t */\n\t<T> Map<String, T> getBeansOfType(@Nullable Class<T> type) throws BeansException;\n\n\t/**\n\t * Return the bean instances that match the given object type (including\n\t * subclasses), judging from either bean definitions or the value of\n\t * {@code getObjectType} in the case of FactoryBeans.\n\t * <p><b>NOTE: This method introspects top-level beans only.</b> It does <i>not</i>\n\t * check nested beans which might match the specified type as well.\n\t * <p>Does consider objects created by FactoryBeans if the \"allowEagerInit\" flag is set,\n\t * which means that FactoryBeans will get initialized. If the object created by the\n\t * FactoryBean doesn't match, the raw FactoryBean itself will be matched against the\n\t * type. If \"allowEagerInit\" is not set, only raw FactoryBeans will be checked\n\t * (which doesn't require initialization of each FactoryBean).\n\t * <p>Does not consider any hierarchy this factory may participate in.\n\t * Use BeanFactoryUtils' {@code beansOfTypeIncludingAncestors}\n\t * to include beans in ancestor factories too.\n\t * <p>Note: Does <i>not</i> ignore singleton beans that have been registered\n\t * by other means than bean definitions.\n\t * <p>The Map returned by this method should always return bean names and\n\t * corresponding bean instances <i>in the order of definition</i> in the\n\t * backend configuration, as far as possible.\n\t * @param type the class or interface to match, or {@code null} for all concrete beans\n\t * @param includeNonSingletons whether to include prototype or scoped beans too\n\t * or just singletons (also applies to FactoryBeans)\n\t * @param allowEagerInit whether to introspect <i>lazy-init singletons</i>\n\t * and <i>objects created by FactoryBeans</i> - or by factory methods with a\n\t * \"factory-bean\" reference - for the type check. Note that FactoryBeans need to be\n\t * eagerly initialized to determine their type: So be aware that passing in \"true\"\n\t * for this flag will initialize FactoryBeans and \"factory-bean\" references. Only\n\t * actually necessary initialization for type checking purposes will be performed;\n\t * constructor and method invocations will still be avoided as far as possible.\n\t * @return a Map with the matching beans, containing the bean names as\n\t * keys and the corresponding bean instances as values\n\t * @throws BeansException if a bean could not be created\n\t * @see FactoryBean#getObjectType\n\t * @see BeanFactoryUtils#beansOfTypeIncludingAncestors(ListableBeanFactory, Class, boolean, boolean)\n\t */\n\t<T> Map<String, T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException;\n\n\t/**\n\t * Find all names of beans which are annotated with the supplied {@link Annotation}\n\t * type, without creating corresponding bean instances yet.\n\t * <p>Note that this method considers objects created by FactoryBeans, which means\n\t * that FactoryBeans will get initialized in order to determine their object type.\n\t * @param annotationType the type of annotation to look for\n\t * (at class, interface or factory method level of the specified bean)\n\t * @return the names of all matching beans\n\t * @since 4.0\n\t * @see #getBeansWithAnnotation(Class)\n\t * @see #findAnnotationOnBean(String, Class)\n\t */\n\tString[] getBeanNamesForAnnotation(Class<? extends Annotation> annotationType);\n\n\t/**\n\t * Find all beans which are annotated with the supplied {@link Annotation} type,\n\t * returning a Map of bean names with corresponding bean instances.\n\t * <p>Note that this method considers objects created by FactoryBeans, which means\n\t * that FactoryBeans will get initialized in order to determine their object type.\n\t * @param annotationType the type of annotation to look for\n\t * (at class, interface or factory method level of the specified bean)\n\t * @return a Map with the matching beans, containing the bean names as\n\t * keys and the corresponding bean instances as values\n\t * @throws BeansException if a bean could not be created\n\t * @since 3.0\n\t * @see #findAnnotationOnBean(String, Class)\n\t * @see #findAnnotationOnBean(String, Class, boolean)\n\t * @see #findAllAnnotationsOnBean(String, Class, boolean)\n\t */\n\tMap<String, Object> getBeansWithAnnotation(Class<? extends Annotation> annotationType) throws BeansException;\n\n\t/**\n\t * Find an {@link Annotation} of {@code annotationType} on the specified bean,\n\t * traversing its interfaces and superclasses if no annotation can be found on\n\t * the given class itself, as well as checking the bean's factory method (if any).\n\t * @param beanName the name of the bean to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * (at class, interface or factory method level of the specified bean)\n\t * @return the annotation of the given type if found, or {@code null} otherwise\n\t * @throws NoSuchBeanDefinitionException if there is no bean with the given name\n\t * @since 3.0\n\t * @see #findAnnotationOnBean(String, Class, boolean)\n\t * @see #findAllAnnotationsOnBean(String, Class, boolean)\n\t * @see #getBeanNamesForAnnotation(Class)\n\t * @see #getBeansWithAnnotation(Class)\n\t * @see #getType(String)\n\t */\n\t<A extends Annotation> @Nullable A findAnnotationOnBean(String beanName, Class<A> annotationType)\n\t\t\tthrows NoSuchBeanDefinitionException;\n\n\t/**\n\t * Find an {@link Annotation} of {@code annotationType} on the specified bean,\n\t * traversing its interfaces and superclasses if no annotation can be found on\n\t * the given class itself, as well as checking the bean's factory method (if any).\n\t * @param beanName the name of the bean to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * (at class, interface or factory method level of the specified bean)\n\t * @param allowFactoryBeanInit whether a {@code FactoryBean} may get initialized\n\t * just for the purpose of determining its object type\n\t * @return the annotation of the given type if found, or {@code null} otherwise\n\t * @throws NoSuchBeanDefinitionException if there is no bean with the given name\n\t * @since 5.3.14\n\t * @see #findAnnotationOnBean(String, Class)\n\t * @see #findAllAnnotationsOnBean(String, Class, boolean)\n\t * @see #getBeanNamesForAnnotation(Class)\n\t * @see #getBeansWithAnnotation(Class)\n\t * @see #getType(String, boolean)\n\t */\n\t<A extends Annotation> @Nullable A findAnnotationOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException;\n\n\t/**\n\t * Find all {@link Annotation} instances of {@code annotationType} on the specified\n\t * bean, traversing its interfaces and superclasses if no annotation can be found on\n\t * the given class itself, as well as checking the bean's factory method (if any).\n\t * @param beanName the name of the bean to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * (at class, interface or factory method level of the specified bean)\n\t * @param allowFactoryBeanInit whether a {@code FactoryBean} may get initialized\n\t * just for the purpose of determining its object type\n\t * @return the set of annotations of the given type found (potentially empty)\n\t * @throws NoSuchBeanDefinitionException if there is no bean with the given name\n\t * @since 6.0\n\t * @see #getBeanNamesForAnnotation(Class)\n\t * @see #findAnnotationOnBean(String, Class, boolean)\n\t * @see #getType(String, boolean)\n\t */\n\t<A extends Annotation> Set<A> findAllAnnotationsOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException;\n\n}"
  },
  "org.springframework.beans.factory.annotation.ParameterResolutionDelegate": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Public delegate for resolving autowirable parameters on externally managed\n * constructors and methods.\n *\n * @author Sam Brannen\n * @author Juergen Hoeller\n * @since 5.2\n * @see #isAutowirable\n * @see #resolveDependency\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class ParameterResolutionDelegate",
    "source_code": "public final class ParameterResolutionDelegate {\n\n\tprivate static final AnnotatedElement EMPTY_ANNOTATED_ELEMENT = new AnnotatedElement() {\n\t\t@Override\n\t\tpublic <T extends Annotation> @Nullable T getAnnotation(Class<T> annotationClass) {\n\t\t\treturn null;\n\t\t}\n\t\t@Override\n\t\tpublic Annotation[] getAnnotations() {\n\t\t\treturn new Annotation[0];\n\t\t}\n\t\t@Override\n\t\tpublic Annotation[] getDeclaredAnnotations() {\n\t\t\treturn new Annotation[0];\n\t\t}\n\t};\n\n\n\tprivate ParameterResolutionDelegate() {\n\t}\n\n\n\t/**\n\t * Determine if the supplied {@link Parameter} can <em>potentially</em> be\n\t * autowired from an {@link AutowireCapableBeanFactory}.\n\t * <p>Returns {@code true} if the supplied parameter is annotated or\n\t * meta-annotated with {@link Autowired @Autowired},\n\t * {@link Qualifier @Qualifier}, or {@link Value @Value}.\n\t * <p>Note that {@link #resolveDependency} may still be able to resolve the\n\t * dependency for the supplied parameter even if this method returns {@code false}.\n\t * @param parameter the parameter whose dependency should be autowired\n\t * (must not be {@code null})\n\t * @param parameterIndex the index of the parameter in the constructor or method\n\t * that declares the parameter\n\t * @see #resolveDependency\n\t */\n\tpublic static boolean isAutowirable(Parameter parameter, int parameterIndex) {\n\t\tAssert.notNull(parameter, \"Parameter must not be null\");\n\t\tAnnotatedElement annotatedParameter = getEffectiveAnnotatedParameter(parameter, parameterIndex);\n\t\treturn (AnnotatedElementUtils.hasAnnotation(annotatedParameter, Autowired.class) ||\n\t\t\t\tAnnotatedElementUtils.hasAnnotation(annotatedParameter, Qualifier.class) ||\n\t\t\t\tAnnotatedElementUtils.hasAnnotation(annotatedParameter, Value.class));\n\t}\n\n\t/**\n\t * Resolve the dependency for the supplied {@link Parameter} from the\n\t * supplied {@link AutowireCapableBeanFactory}.\n\t * <p>Provides comprehensive autowiring support for individual method parameters\n\t * on par with Spring's dependency injection facilities for autowired fields and\n\t * methods, including support for {@link Autowired @Autowired},\n\t * {@link Qualifier @Qualifier}, and {@link Value @Value} with support for property\n\t * placeholders and SpEL expressions in {@code @Value} declarations.\n\t * <p>The dependency is required unless the parameter is annotated or meta-annotated\n\t * with {@link Autowired @Autowired} with the {@link Autowired#required required}\n\t * flag set to {@code false}.\n\t * <p>If an explicit <em>qualifier</em> is not declared, the name of the parameter\n\t * will be used as the qualifier for resolving ambiguities.\n\t * @param parameter the parameter whose dependency should be resolved (must not be\n\t * {@code null})\n\t * @param parameterIndex the index of the parameter in the constructor or method\n\t * that declares the parameter\n\t * @param containingClass the concrete class that contains the parameter; this may\n\t * differ from the class that declares the parameter in that it may be a subclass\n\t * thereof, potentially substituting type variables (must not be {@code null})\n\t * @param beanFactory the {@code AutowireCapableBeanFactory} from which to resolve\n\t * the dependency (must not be {@code null})\n\t * @return the resolved object, or {@code null} if none found\n\t * @throws BeansException if dependency resolution failed\n\t * @see #isAutowirable\n\t * @see Autowired#required\n\t * @see SynthesizingMethodParameter#forExecutable(Executable, int)\n\t * @see AutowireCapableBeanFactory#resolveDependency(DependencyDescriptor, String)\n\t */\n\tpublic static @Nullable Object resolveDependency(\n\t\t\tParameter parameter, int parameterIndex, Class<?> containingClass, AutowireCapableBeanFactory beanFactory)\n\t\t\tthrows BeansException {\n\n\t\tAssert.notNull(parameter, \"Parameter must not be null\");\n\t\tAssert.notNull(containingClass, \"Containing class must not be null\");\n\t\tAssert.notNull(beanFactory, \"AutowireCapableBeanFactory must not be null\");\n\n\t\tAnnotatedElement annotatedParameter = getEffectiveAnnotatedParameter(parameter, parameterIndex);\n\t\tAutowired autowired = AnnotatedElementUtils.findMergedAnnotation(annotatedParameter, Autowired.class);\n\t\tboolean required = (autowired == null || autowired.required());\n\n\t\tMethodParameter methodParameter = SynthesizingMethodParameter.forExecutable(\n\t\t\t\tparameter.getDeclaringExecutable(), parameterIndex);\n\t\tDependencyDescriptor descriptor = new DependencyDescriptor(methodParameter, required);\n\t\tdescriptor.setContainingClass(containingClass);\n\t\treturn beanFactory.resolveDependency(descriptor, null);\n\t}\n\n\t/**\n\t * Due to a bug in {@code javac} on JDK versions prior to JDK 9, looking up\n\t * annotations directly on a {@link Parameter} will fail for inner class\n\t * constructors.\n\t * <p>Note: Since Spring 6 may still encounter user code compiled with\n\t * {@code javac 8}, this workaround is kept in place for the time being.\n\t * <h4>Bug in javac in JDK &lt; 9</h4>\n\t * <p>The parameter annotations array in the compiled byte code excludes an entry\n\t * for the implicit <em>enclosing instance</em> parameter for an inner class\n\t * constructor.\n\t * <h4>Workaround</h4>\n\t * <p>This method provides a workaround for this off-by-one error by allowing the\n\t * caller to access annotations on the preceding {@link Parameter} object (i.e.,\n\t * {@code index - 1}). If the supplied {@code index} is zero, this method returns\n\t * an empty {@code AnnotatedElement}.\n\t * <h4>WARNING</h4>\n\t * <p>The {@code AnnotatedElement} returned by this method should never be cast and\n\t * treated as a {@code Parameter} since the metadata (for example, {@link Parameter#getName()},\n\t * {@link Parameter#getType()}, etc.) will not match those for the declared parameter\n\t * at the given index in an inner class constructor.\n\t * @return the supplied {@code parameter} or the <em>effective</em> {@code Parameter}\n\t * if the aforementioned bug is in effect\n\t */\n\tprivate static AnnotatedElement getEffectiveAnnotatedParameter(Parameter parameter, int index) {\n\t\tExecutable executable = parameter.getDeclaringExecutable();\n\t\tif (executable instanceof Constructor && ClassUtils.isInnerClass(executable.getDeclaringClass()) &&\n\t\t\t\texecutable.getParameterAnnotations().length == executable.getParameterCount() - 1) {\n\t\t\t// Bug in javac in JDK <9: annotation array excludes enclosing instance parameter\n\t\t\t// for inner classes, so access it with the actual parameter index lowered by 1\n\t\t\treturn (index == 0 ? EMPTY_ANNOTATED_ELEMENT : executable.getParameters()[index - 1]);\n\t\t}\n\t\treturn parameter;\n\t}\n\n}"
  },
  "org.springframework.beans.factory.annotation.ParameterResolutionDelegate#getAnnotation(annotationClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationClass"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "return": "T",
    "signature": "public T getAnnotation(Class<T> annotationClass)",
    "source_code": "\t\tpublic <T extends Annotation> @Nullable T getAnnotation(Class<T> annotationClass) {\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.ParameterResolutionDelegate#getAnnotations()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "Annotation[]",
    "signature": "public Annotation[] getAnnotations()",
    "source_code": "\t\tpublic Annotation[] getAnnotations() {\n\t\t\treturn new Annotation[0];\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.ParameterResolutionDelegate#getDeclaredAnnotations()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "Annotation[]",
    "signature": "public Annotation[] getDeclaredAnnotations()",
    "source_code": "\t\tpublic Annotation[] getDeclaredAnnotations() {\n\t\t\treturn new Annotation[0];\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.ParameterResolutionDelegate#isAutowirable(parameter,parameterIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied {@link Parameter} can <em>potentially</em> be\n\t * autowired from an {@link AutowireCapableBeanFactory}.\n\t * <p>Returns {@code true} if the supplied parameter is annotated or\n\t * meta-annotated with {@link Autowired @Autowired},\n\t * {@link Qualifier @Qualifier}, or {@link Value @Value}.\n\t * <p>Note that {@link #resolveDependency} may still be able to resolve the\n\t * dependency for the supplied parameter even if this method returns {@code false}.\n\t * @param parameter the parameter whose dependency should be autowired\n\t * (must not be {@code null})\n\t * @param parameterIndex the index of the parameter in the constructor or method\n\t * that declares the parameter\n\t * @see #resolveDependency\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "boolean",
    "signature": "public boolean isAutowirable(Parameter parameter, int parameterIndex)",
    "source_code": "\tpublic static boolean isAutowirable(Parameter parameter, int parameterIndex) {\n\t\tAssert.notNull(parameter, \"Parameter must not be null\");\n\t\tAnnotatedElement annotatedParameter = getEffectiveAnnotatedParameter(parameter, parameterIndex);\n\t\treturn (AnnotatedElementUtils.hasAnnotation(annotatedParameter, Autowired.class) ||\n\t\t\t\tAnnotatedElementUtils.hasAnnotation(annotatedParameter, Qualifier.class) ||\n\t\t\t\tAnnotatedElementUtils.hasAnnotation(annotatedParameter, Value.class));\n\t}"
  },
  "org.springframework.beans.factory.annotation.ParameterResolutionDelegate#resolveDependency(parameter,parameterIndex,containingClass,beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the dependency for the supplied {@link Parameter} from the\n\t * supplied {@link AutowireCapableBeanFactory}.\n\t * <p>Provides comprehensive autowiring support for individual method parameters\n\t * on par with Spring's dependency injection facilities for autowired fields and\n\t * methods, including support for {@link Autowired @Autowired},\n\t * {@link Qualifier @Qualifier}, and {@link Value @Value} with support for property\n\t * placeholders and SpEL expressions in {@code @Value} declarations.\n\t * <p>The dependency is required unless the parameter is annotated or meta-annotated\n\t * with {@link Autowired @Autowired} with the {@link Autowired#required required}\n\t * flag set to {@code false}.\n\t * <p>If an explicit <em>qualifier</em> is not declared, the name of the parameter\n\t * will be used as the qualifier for resolving ambiguities.\n\t * @param parameter the parameter whose dependency should be resolved (must not be\n\t * {@code null})\n\t * @param parameterIndex the index of the parameter in the constructor or method\n\t * that declares the parameter\n\t * @param containingClass the concrete class that contains the parameter; this may\n\t * differ from the class that declares the parameter in that it may be a subclass\n\t * thereof, potentially substituting type variables (must not be {@code null})\n\t * @param beanFactory the {@code AutowireCapableBeanFactory} from which to resolve\n\t * the dependency (must not be {@code null})\n\t * @return the resolved object, or {@code null} if none found\n\t * @throws BeansException if dependency resolution failed\n\t * @see #isAutowirable\n\t * @see Autowired#required\n\t * @see SynthesizingMethodParameter#forExecutable(Executable, int)\n\t * @see AutowireCapableBeanFactory#resolveDependency(DependencyDescriptor, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "parameterIndex",
      "containingClass",
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "Object",
    "signature": "public Object resolveDependency(Parameter parameter, int parameterIndex, Class<?> containingClass, AutowireCapableBeanFactory beanFactory)",
    "source_code": "\tpublic static @Nullable Object resolveDependency("
  },
  "org.springframework.beans.factory.aot.AutowiredArguments": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Resolved arguments to be autowired.\n *\n * @author Phillip Webb\n * @author Stephane Nicoll\n * @since 6.0\n * @see BeanInstanceSupplier\n * @see AutowiredMethodArgumentsResolver\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 34
    },
    "signature": "public interface AutowiredArguments",
    "source_code": "public interface AutowiredArguments {\n\n\t/**\n\t * Return the resolved argument at the specified index.\n\t * @param <T> the type of the argument\n\t * @param index the argument index\n\t * @param requiredType the required argument type\n\t * @return the argument\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tdefault <T> @Nullable T get(int index, Class<T> requiredType) {\n\t\tObject value = getObject(index);\n\t\tif (!ClassUtils.isAssignableValue(requiredType, value)) {\n\t\t\tthrow new IllegalArgumentException(\"Argument type mismatch: expected '\" +\n\t\t\t\t\tClassUtils.getQualifiedName(requiredType) + \"' for value [\" + value + \"]\");\n\t\t}\n\t\treturn (T) value;\n\t}\n\n\t/**\n\t * Return the resolved argument at the specified index.\n\t * @param <T> the type of the argument\n\t * @param index the argument index\n\t * @return the argument\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tdefault <T> @Nullable T get(int index) {\n\t\treturn (T) getObject(index);\n\t}\n\n\t/**\n\t * Return the resolved argument at the specified index.\n\t * @param index the argument index\n\t * @return the argument\n\t */\n\tdefault @Nullable Object getObject(int index) {\n\t\treturn toArray()[index];\n\t}\n\n\t/**\n\t * Return the arguments as an object array.\n\t * @return the arguments as an object array\n\t */\n\t@Nullable Object[] toArray();\n\n\t/**\n\t * Factory method to create a new {@link AutowiredArguments} instance from\n\t * the given object array.\n\t * @param arguments the arguments\n\t * @return a new {@link AutowiredArguments} instance\n\t */\n\tstatic AutowiredArguments of(@Nullable Object[] arguments) {\n\t\tAssert.notNull(arguments, \"'arguments' must not be null\");\n\t\treturn () -> arguments;\n\t}\n\n}"
  },
  "org.springframework.beans.factory.aot.AutowiredFieldValueResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Resolver used to support the autowiring of fields. Typically used in\n * AOT-processed applications as a targeted alternative to the\n * {@link org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor\n * AutowiredAnnotationBeanPostProcessor}.\n *\n * <p>When resolving arguments in a native image, the {@link Field} being used must\n * be marked with an {@link ExecutableMode#INTROSPECT introspection} hint so\n * that field annotations can be read. Full {@link ExecutableMode#INVOKE\n * invocation} hints are only required if the\n * {@link #resolveAndSet(RegisteredBean, Object)} method of this class is being\n * used (typically to support private fields).\n *\n * @author Phillip Webb\n * @author Stephane Nicoll\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public class AutowiredFieldValueResolver",
    "source_code": "public final class AutowiredFieldValueResolver extends AutowiredElementResolver {\n\n\tprivate final String fieldName;\n\n\tprivate final boolean required;\n\n\tprivate final @Nullable String shortcutBeanName;\n\n\n\tprivate AutowiredFieldValueResolver(String fieldName, boolean required, @Nullable String shortcut) {\n\t\tAssert.hasText(fieldName, \"'fieldName' must not be empty\");\n\t\tthis.fieldName = fieldName;\n\t\tthis.required = required;\n\t\tthis.shortcutBeanName = shortcut;\n\t}\n\n\n\t/**\n\t * Create a new {@link AutowiredFieldValueResolver} for the specified field\n\t * where injection is optional.\n\t * @param fieldName the field name\n\t * @return a new {@link AutowiredFieldValueResolver} instance\n\t */\n\tpublic static AutowiredFieldValueResolver forField(String fieldName) {\n\t\treturn new AutowiredFieldValueResolver(fieldName, false, null);\n\t}\n\n\t/**\n\t * Create a new {@link AutowiredFieldValueResolver} for the specified field\n\t * where injection is required.\n\t * @param fieldName the field name\n\t * @return a new {@link AutowiredFieldValueResolver} instance\n\t */\n\tpublic static AutowiredFieldValueResolver forRequiredField(String fieldName) {\n\t\treturn new AutowiredFieldValueResolver(fieldName, true, null);\n\t}\n\n\n\t/**\n\t * Return a new {@link AutowiredFieldValueResolver} instance that uses a\n\t * direct bean name injection shortcut.\n\t * @param beanName the bean name to use as a shortcut\n\t * @return a new {@link AutowiredFieldValueResolver} instance that uses the\n\t * given shortcut bean name\n\t */\n\tpublic AutowiredFieldValueResolver withShortcut(String beanName) {\n\t\treturn new AutowiredFieldValueResolver(this.fieldName, this.required, beanName);\n\t}\n\n\t/**\n\t * Resolve the field for the specified registered bean and provide it to the\n\t * given action.\n\t * @param registeredBean the registered bean\n\t * @param action the action to execute with the resolved field value\n\t */\n\tpublic <T> void resolve(RegisteredBean registeredBean, ThrowingConsumer<T> action) {\n\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\tAssert.notNull(action, \"'action' must not be null\");\n\t\tT resolved = resolve(registeredBean);\n\t\tif (resolved != null) {\n\t\t\taction.accept(resolved);\n\t\t}\n\t}\n\n\t/**\n\t * Resolve the field value for the specified registered bean.\n\t * @param registeredBean the registered bean\n\t * @param requiredType the required type\n\t * @return the resolved field value\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> @Nullable T resolve(RegisteredBean registeredBean, Class<T> requiredType) {\n\t\tObject value = resolveObject(registeredBean);\n\t\tAssert.isInstanceOf(requiredType, value);\n\t\treturn (T) value;\n\t}\n\n\t/**\n\t * Resolve the field value for the specified registered bean.\n\t * @param registeredBean the registered bean\n\t * @return the resolved field value\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> @Nullable T resolve(RegisteredBean registeredBean) {\n\t\treturn (T) resolveObject(registeredBean);\n\t}\n\n\t/**\n\t * Resolve the field value for the specified registered bean.\n\t * @param registeredBean the registered bean\n\t * @return the resolved field value\n\t */\n\tpublic @Nullable Object resolveObject(RegisteredBean registeredBean) {\n\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\treturn resolveValue(registeredBean, getField(registeredBean));\n\t}\n\n\t/**\n\t * Resolve the field value for the specified registered bean and set it\n\t * using reflection.\n\t * @param registeredBean the registered bean\n\t * @param instance the bean instance\n\t */\n\tpublic void resolveAndSet(RegisteredBean registeredBean, Object instance) {\n\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\tAssert.notNull(instance, \"'instance' must not be null\");\n\t\tField field = getField(registeredBean);\n\t\tObject resolved = resolveValue(registeredBean, field);\n\t\tif (resolved != null) {\n\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\tReflectionUtils.setField(field, instance, resolved);\n\t\t}\n\t}\n\n\tprivate @Nullable Object resolveValue(RegisteredBean registeredBean, Field field) {\n\t\tString beanName = registeredBean.getBeanName();\n\t\tClass<?> beanClass = registeredBean.getBeanClass();\n\t\tConfigurableBeanFactory beanFactory = registeredBean.getBeanFactory();\n\t\tDependencyDescriptor descriptor = new DependencyDescriptor(field, this.required);\n\t\tdescriptor.setContainingClass(beanClass);\n\t\tif (this.shortcutBeanName != null) {\n\t\t\tdescriptor = new ShortcutDependencyDescriptor(descriptor, this.shortcutBeanName);\n\t\t}\n\t\tSet<String> autowiredBeanNames = new LinkedHashSet<>(1);\n\t\tTypeConverter typeConverter = beanFactory.getTypeConverter();\n\t\ttry {\n\t\t\tAssert.isInstanceOf(AutowireCapableBeanFactory.class, beanFactory);\n\t\t\tObject value = ((AutowireCapableBeanFactory) beanFactory).resolveDependency(\n\t\t\t\t\tdescriptor, beanName, autowiredBeanNames, typeConverter);\n\t\t\tregisterDependentBeans(beanFactory, beanName, autowiredBeanNames);\n\t\t\treturn value;\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tthrow new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex);\n\t\t}\n\t}\n\n\tprivate Field getField(RegisteredBean registeredBean) {\n\t\tField field = ReflectionUtils.findField(registeredBean.getBeanClass(), this.fieldName);\n\t\tAssert.notNull(field, () -> \"No field '\" + this.fieldName + \"' found on \" +\n\t\t\t\tregisteredBean.getBeanClass().getName());\n\t\treturn field;\n\t}\n\n}"
  },
  "org.springframework.beans.factory.aot.AutowiredFieldValueResolver#forField(fieldName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link AutowiredFieldValueResolver} for the specified field\n\t * where injection is optional.\n\t * @param fieldName the field name\n\t * @return a new {@link AutowiredFieldValueResolver} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fieldName"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "AutowiredFieldValueResolver",
    "signature": "public AutowiredFieldValueResolver forField(String fieldName)",
    "source_code": "\tpublic static AutowiredFieldValueResolver forField(String fieldName) {\n\t\treturn new AutowiredFieldValueResolver(fieldName, false, null);\n\t}"
  },
  "org.springframework.beans.factory.aot.AutowiredFieldValueResolver#forRequiredField(fieldName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link AutowiredFieldValueResolver} for the specified field\n\t * where injection is required.\n\t * @param fieldName the field name\n\t * @return a new {@link AutowiredFieldValueResolver} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fieldName"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "AutowiredFieldValueResolver",
    "signature": "public AutowiredFieldValueResolver forRequiredField(String fieldName)",
    "source_code": "\tpublic static AutowiredFieldValueResolver forRequiredField(String fieldName) {\n\t\treturn new AutowiredFieldValueResolver(fieldName, true, null);\n\t}"
  },
  "org.springframework.beans.factory.aot.AutowiredFieldValueResolver#resolve(registeredBean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the field value for the specified registered bean.\n\t * @param registeredBean the registered bean\n\t * @return the resolved field value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "T",
    "signature": "public T resolve(RegisteredBean registeredBean)",
    "source_code": "\tpublic <T> @Nullable T resolve(RegisteredBean registeredBean) {\n\t\treturn (T) resolveObject(registeredBean);\n\t}"
  },
  "org.springframework.beans.factory.aot.AutowiredFieldValueResolver#resolve(registeredBean,action)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the field for the specified registered bean and provide it to the\n\t * given action.\n\t * @param registeredBean the registered bean\n\t * @param action the action to execute with the resolved field value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void resolve(RegisteredBean registeredBean, ThrowingConsumer<T> action)",
    "source_code": "\tpublic <T> void resolve(RegisteredBean registeredBean, ThrowingConsumer<T> action) {\n\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\tAssert.notNull(action, \"'action' must not be null\");\n\t\tT resolved = resolve(registeredBean);\n\t\tif (resolved != null) {\n\t\t\taction.accept(resolved);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.aot.AutowiredFieldValueResolver#resolve(registeredBean,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the field value for the specified registered bean.\n\t * @param registeredBean the registered bean\n\t * @param requiredType the required type\n\t * @return the resolved field value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "T",
    "signature": "public T resolve(RegisteredBean registeredBean, Class<T> requiredType)",
    "source_code": "\tpublic <T> @Nullable T resolve(RegisteredBean registeredBean, Class<T> requiredType) {\n\t\tObject value = resolveObject(registeredBean);\n\t\tAssert.isInstanceOf(requiredType, value);\n\t\treturn (T) value;\n\t}"
  },
  "org.springframework.beans.factory.aot.AutowiredFieldValueResolver#resolveAndSet(registeredBean,instance)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the field value for the specified registered bean and set it\n\t * using reflection.\n\t * @param registeredBean the registered bean\n\t * @param instance the bean instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "instance"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "public void resolveAndSet(RegisteredBean registeredBean, Object instance)",
    "source_code": "\tpublic void resolveAndSet(RegisteredBean registeredBean, Object instance) {\n\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\tAssert.notNull(instance, \"'instance' must not be null\");\n\t\tField field = getField(registeredBean);\n\t\tObject resolved = resolveValue(registeredBean, field);\n\t\tif (resolved != null) {\n\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\tReflectionUtils.setField(field, instance, resolved);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.aot.AutowiredFieldValueResolver#resolveObject(registeredBean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the field value for the specified registered bean.\n\t * @param registeredBean the registered bean\n\t * @return the resolved field value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "Object",
    "signature": "public Object resolveObject(RegisteredBean registeredBean)",
    "source_code": "\tpublic @Nullable Object resolveObject(RegisteredBean registeredBean) {\n\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\treturn resolveValue(registeredBean, getField(registeredBean));\n\t}"
  },
  "org.springframework.beans.factory.aot.AutowiredFieldValueResolver#withShortcut(beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new {@link AutowiredFieldValueResolver} instance that uses a\n\t * direct bean name injection shortcut.\n\t * @param beanName the bean name to use as a shortcut\n\t * @return a new {@link AutowiredFieldValueResolver} instance that uses the\n\t * given shortcut bean name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "AutowiredFieldValueResolver",
    "signature": "public AutowiredFieldValueResolver withShortcut(String beanName)",
    "source_code": "\tpublic AutowiredFieldValueResolver withShortcut(String beanName) {\n\t\treturn new AutowiredFieldValueResolver(this.fieldName, this.required, beanName);\n\t}"
  },
  "org.springframework.beans.factory.aot.AutowiredMethodArgumentsResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Resolver used to support the autowiring of methods. Typically used in\n * AOT-processed applications as a targeted alternative to the\n * {@link org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor\n * AutowiredAnnotationBeanPostProcessor}.\n *\n * <p>When resolving arguments in a native image, the {@link Method} being used\n * must be marked with an {@link ExecutableMode#INTROSPECT introspection} hint\n * so that field annotations can be read. Full {@link ExecutableMode#INVOKE\n * invocation} hints are only required if the\n * {@link #resolveAndInvoke(RegisteredBean, Object)} method of this class is\n * being used (typically to support private methods).\n *\n * @author Phillip Webb\n * @author Stephane Nicoll\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "signature": "public class AutowiredMethodArgumentsResolver",
    "source_code": "public final class AutowiredMethodArgumentsResolver extends AutowiredElementResolver {\n\n\tprivate final String methodName;\n\n\tprivate final Class<?>[] parameterTypes;\n\n\tprivate final boolean required;\n\n\tprivate final String @Nullable [] shortcutBeanNames;\n\n\n\tprivate AutowiredMethodArgumentsResolver(String methodName, Class<?>[] parameterTypes,\n\t\t\tboolean required, String @Nullable [] shortcutBeanNames) {\n\n\t\tAssert.hasText(methodName, \"'methodName' must not be empty\");\n\t\tthis.methodName = methodName;\n\t\tthis.parameterTypes = parameterTypes;\n\t\tthis.required = required;\n\t\tthis.shortcutBeanNames = shortcutBeanNames;\n\t}\n\n\n\t/**\n\t * Create a new {@link AutowiredMethodArgumentsResolver} for the specified\n\t * method where injection is optional.\n\t * @param methodName the method name\n\t * @param parameterTypes the factory method parameter types\n\t * @return a new {@link AutowiredFieldValueResolver} instance\n\t */\n\tpublic static AutowiredMethodArgumentsResolver forMethod(String methodName, Class<?>... parameterTypes) {\n\t\treturn new AutowiredMethodArgumentsResolver(methodName, parameterTypes, false, null);\n\t}\n\n\t/**\n\t * Create a new {@link AutowiredMethodArgumentsResolver} for the specified\n\t * method where injection is required.\n\t * @param methodName the method name\n\t * @param parameterTypes the factory method parameter types\n\t * @return a new {@link AutowiredFieldValueResolver} instance\n\t */\n\tpublic static AutowiredMethodArgumentsResolver forRequiredMethod(String methodName, Class<?>... parameterTypes) {\n\t\treturn new AutowiredMethodArgumentsResolver(methodName, parameterTypes, true, null);\n\t}\n\n\t/**\n\t * Return a new {@link AutowiredMethodArgumentsResolver} instance\n\t * that uses direct bean name injection shortcuts for specific parameters.\n\t * @param beanNames the bean names to use as shortcuts (aligned with the\n\t * method parameters)\n\t * @return a new {@link AutowiredMethodArgumentsResolver} instance that uses\n\t * the given shortcut bean names\n\t */\n\tpublic AutowiredMethodArgumentsResolver withShortcut(String... beanNames) {\n\t\treturn new AutowiredMethodArgumentsResolver(this.methodName, this.parameterTypes, this.required, beanNames);\n\t}\n\n\t/**\n\t * Resolve the method arguments for the specified registered bean and\n\t * provide it to the given action.\n\t * @param registeredBean the registered bean\n\t * @param action the action to execute with the resolved method arguments\n\t */\n\tpublic void resolve(RegisteredBean registeredBean, ThrowingConsumer<AutowiredArguments> action) {\n\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\tAssert.notNull(action, \"'action' must not be null\");\n\t\tAutowiredArguments resolved = resolve(registeredBean);\n\t\tif (resolved != null) {\n\t\t\taction.accept(resolved);\n\t\t}\n\t}\n\n\t/**\n\t * Resolve the method arguments for the specified registered bean.\n\t * @param registeredBean the registered bean\n\t * @return the resolved method arguments\n\t */\n\tpublic @Nullable AutowiredArguments resolve(RegisteredBean registeredBean) {\n\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\treturn resolveArguments(registeredBean, getMethod(registeredBean));\n\t}\n\n\t/**\n\t * Resolve the method arguments for the specified registered bean and invoke\n\t * the method using reflection.\n\t * @param registeredBean the registered bean\n\t * @param instance the bean instance\n\t */\n\tpublic void resolveAndInvoke(RegisteredBean registeredBean, Object instance) {\n\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\tAssert.notNull(instance, \"'instance' must not be null\");\n\t\tMethod method = getMethod(registeredBean);\n\t\tAutowiredArguments resolved = resolveArguments(registeredBean, method);\n\t\tif (resolved != null) {\n\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\tReflectionUtils.invokeMethod(method, instance, resolved.toArray());\n\t\t}\n\t}\n\n\tprivate @Nullable AutowiredArguments resolveArguments(RegisteredBean registeredBean,\n\t\t\tMethod method) {\n\n\t\tString beanName = registeredBean.getBeanName();\n\t\tClass<?> beanClass = registeredBean.getBeanClass();\n\t\tConfigurableBeanFactory beanFactory = registeredBean.getBeanFactory();\n\t\tAssert.isInstanceOf(AutowireCapableBeanFactory.class, beanFactory);\n\t\tAutowireCapableBeanFactory autowireCapableBeanFactory = (AutowireCapableBeanFactory) beanFactory;\n\t\tint argumentCount = method.getParameterCount();\n\t\t@Nullable Object[] arguments = new Object[argumentCount];\n\t\tSet<String> autowiredBeanNames = CollectionUtils.newLinkedHashSet(argumentCount);\n\t\tTypeConverter typeConverter = beanFactory.getTypeConverter();\n\t\tfor (int i = 0; i < argumentCount; i++) {\n\t\t\tMethodParameter parameter = new MethodParameter(method, i);\n\t\t\tDependencyDescriptor descriptor = new DependencyDescriptor(parameter, this.required);\n\t\t\tdescriptor.setContainingClass(beanClass);\n\t\t\tString shortcut = (this.shortcutBeanNames != null ? this.shortcutBeanNames[i] : null);\n\t\t\tif (shortcut != null) {\n\t\t\t\tdescriptor = new ShortcutDependencyDescriptor(descriptor, shortcut);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tObject argument = autowireCapableBeanFactory.resolveDependency(\n\t\t\t\t\t\tdescriptor, beanName, autowiredBeanNames, typeConverter);\n\t\t\t\tif (argument == null && !this.required) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\targuments[i] = argument;\n\t\t\t}\n\t\t\tcatch (BeansException ex) {\n\t\t\t\tthrow new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(parameter), ex);\n\t\t\t}\n\t\t}\n\t\tregisterDependentBeans(beanFactory, beanName, autowiredBeanNames);\n\t\treturn AutowiredArguments.of(arguments);\n\t}\n\n\tprivate Method getMethod(RegisteredBean registeredBean) {\n\t\tMethod method = ReflectionUtils.findMethod(registeredBean.getBeanClass(),\n\t\t\t\tthis.methodName, this.parameterTypes);\n\t\tAssert.notNull(method, () ->\n\t\t\t\t\"Method '%s' with parameter types [%s] declared on %s could not be found.\".formatted(\n\t\t\t\t\t\tthis.methodName, toCommaSeparatedNames(this.parameterTypes),\n\t\t\t\t\t\tregisteredBean.getBeanClass().getName()));\n\t\treturn method;\n\t}\n\n\tprivate String toCommaSeparatedNames(Class<?>... parameterTypes) {\n\t\treturn Arrays.stream(parameterTypes).map(Class::getName)\n\t\t\t\t.collect(Collectors.joining(\", \"));\n\t}\n\n}"
  },
  "org.springframework.beans.factory.aot.AutowiredMethodArgumentsResolver#forMethod(methodName,parameterTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link AutowiredMethodArgumentsResolver} for the specified\n\t * method where injection is optional.\n\t * @param methodName the method name\n\t * @param parameterTypes the factory method parameter types\n\t * @return a new {@link AutowiredFieldValueResolver} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodName",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "AutowiredMethodArgumentsResolver",
    "signature": "public AutowiredMethodArgumentsResolver forMethod(String methodName, Class<?>... parameterTypes)",
    "source_code": "\tpublic static AutowiredMethodArgumentsResolver forMethod(String methodName, Class<?>... parameterTypes) {\n\t\treturn new AutowiredMethodArgumentsResolver(methodName, parameterTypes, false, null);\n\t}"
  },
  "org.springframework.beans.factory.aot.AutowiredMethodArgumentsResolver#forRequiredMethod(methodName,parameterTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link AutowiredMethodArgumentsResolver} for the specified\n\t * method where injection is required.\n\t * @param methodName the method name\n\t * @param parameterTypes the factory method parameter types\n\t * @return a new {@link AutowiredFieldValueResolver} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodName",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "AutowiredMethodArgumentsResolver",
    "signature": "public AutowiredMethodArgumentsResolver forRequiredMethod(String methodName, Class<?>... parameterTypes)",
    "source_code": "\tpublic static AutowiredMethodArgumentsResolver forRequiredMethod(String methodName, Class<?>... parameterTypes) {\n\t\treturn new AutowiredMethodArgumentsResolver(methodName, parameterTypes, true, null);\n\t}"
  },
  "org.springframework.beans.factory.aot.AutowiredMethodArgumentsResolver#resolve(registeredBean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the method arguments for the specified registered bean.\n\t * @param registeredBean the registered bean\n\t * @return the resolved method arguments\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "AutowiredArguments",
    "signature": "public AutowiredArguments resolve(RegisteredBean registeredBean)",
    "source_code": "\tpublic @Nullable AutowiredArguments resolve(RegisteredBean registeredBean) {\n\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\treturn resolveArguments(registeredBean, getMethod(registeredBean));\n\t}"
  },
  "org.springframework.beans.factory.aot.AutowiredMethodArgumentsResolver#resolve(registeredBean,action)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the method arguments for the specified registered bean and\n\t * provide it to the given action.\n\t * @param registeredBean the registered bean\n\t * @param action the action to execute with the resolved method arguments\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "void",
    "signature": "public void resolve(RegisteredBean registeredBean, ThrowingConsumer<AutowiredArguments> action)",
    "source_code": "\tpublic void resolve(RegisteredBean registeredBean, ThrowingConsumer<AutowiredArguments> action) {\n\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\tAssert.notNull(action, \"'action' must not be null\");\n\t\tAutowiredArguments resolved = resolve(registeredBean);\n\t\tif (resolved != null) {\n\t\t\taction.accept(resolved);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.aot.AutowiredMethodArgumentsResolver#resolveAndInvoke(registeredBean,instance)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the method arguments for the specified registered bean and invoke\n\t * the method using reflection.\n\t * @param registeredBean the registered bean\n\t * @param instance the bean instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "instance"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "public void resolveAndInvoke(RegisteredBean registeredBean, Object instance)",
    "source_code": "\tpublic void resolveAndInvoke(RegisteredBean registeredBean, Object instance) {\n\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\tAssert.notNull(instance, \"'instance' must not be null\");\n\t\tMethod method = getMethod(registeredBean);\n\t\tAutowiredArguments resolved = resolveArguments(registeredBean, method);\n\t\tif (resolved != null) {\n\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\tReflectionUtils.invokeMethod(method, instance, resolved.toArray());\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.aot.AutowiredMethodArgumentsResolver#withShortcut(beanNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new {@link AutowiredMethodArgumentsResolver} instance\n\t * that uses direct bean name injection shortcuts for specific parameters.\n\t * @param beanNames the bean names to use as shortcuts (aligned with the\n\t * method parameters)\n\t * @return a new {@link AutowiredMethodArgumentsResolver} instance that uses\n\t * the given shortcut bean names\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanNames"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "AutowiredMethodArgumentsResolver",
    "signature": "public AutowiredMethodArgumentsResolver withShortcut(String... beanNames)",
    "source_code": "\tpublic AutowiredMethodArgumentsResolver withShortcut(String... beanNames) {\n\t\treturn new AutowiredMethodArgumentsResolver(this.methodName, this.parameterTypes, this.required, beanNames);\n\t}"
  },
  "org.springframework.beans.factory.aot.BeanInstanceSupplier#withGenerator(generator)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new {@link BeanInstanceSupplier} instance that uses the specified\n\t * {@code generator} supplier to instantiate the underlying bean.\n\t * @param generator a {@link ThrowingSupplier} to instantiate the underlying bean\n\t * @return a new {@link BeanInstanceSupplier} instance with the specified generator\n\t * @deprecated in favor of {@link #withGenerator(ThrowingFunction)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generator"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "BeanInstanceSupplier<T>",
    "signature": "public BeanInstanceSupplier<T> withGenerator(ThrowingSupplier<T> generator)",
    "source_code": "\tpublic BeanInstanceSupplier<T> withGenerator(ThrowingSupplier<T> generator) {\n\t\tAssert.notNull(generator, \"'generator' must not be null\");\n\t\treturn new BeanInstanceSupplier<>(this.lookup, registeredBean -> generator.get(),\n\t\t\t\tnull, this.shortcutBeanNames);\n\t}"
  },
  "org.springframework.beans.factory.aot.BeanInstanceSupplier#withShortcuts(beanNames)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new {@link BeanInstanceSupplier} instance\n\t * that uses direct bean name injection shortcuts for specific parameters.\n\t * @deprecated in favor of {@link #withShortcut(String...)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanNames"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "BeanInstanceSupplier<T>",
    "signature": "public BeanInstanceSupplier<T> withShortcuts(String... beanNames)",
    "source_code": "\tpublic BeanInstanceSupplier<T> withShortcuts(String... beanNames) {\n\t\treturn withShortcut(beanNames);\n\t}"
  },
  "org.springframework.beans.factory.config.BeanDefinition": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A BeanDefinition describes a bean instance, which has property values,\n * constructor argument values, and further information supplied by\n * concrete implementations.\n *\n * <p>This is just a minimal interface: The main intention is to allow a\n * {@link BeanFactoryPostProcessor} to introspect and modify property values\n * and other bean metadata.\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @since 19.03.2004\n * @see ConfigurableListableBeanFactory#getBeanDefinition\n * @see org.springframework.beans.factory.support.RootBeanDefinition\n * @see org.springframework.beans.factory.support.ChildBeanDefinition\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public interface BeanDefinition",
    "source_code": "public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {\n\n\t/**\n\t * Scope identifier for the standard singleton scope: {@value}.\n\t * <p>Note that extended bean factories might support further scopes.\n\t * @see #setScope\n\t * @see ConfigurableBeanFactory#SCOPE_SINGLETON\n\t */\n\tString SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;\n\n\t/**\n\t * Scope identifier for the standard prototype scope: {@value}.\n\t * <p>Note that extended bean factories might support further scopes.\n\t * @see #setScope\n\t * @see ConfigurableBeanFactory#SCOPE_PROTOTYPE\n\t */\n\tString SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;\n\n\n\t/**\n\t * Role hint indicating that a {@code BeanDefinition} is a major part\n\t * of the application. Typically corresponds to a user-defined bean.\n\t */\n\tint ROLE_APPLICATION = 0;\n\n\t/**\n\t * Role hint indicating that a {@code BeanDefinition} is a supporting\n\t * part of some larger configuration, typically an outer\n\t * {@link org.springframework.beans.factory.parsing.ComponentDefinition}.\n\t * {@code SUPPORT} beans are considered important enough to be aware\n\t * of when looking more closely at a particular\n\t * {@link org.springframework.beans.factory.parsing.ComponentDefinition},\n\t * but not when looking at the overall configuration of an application.\n\t */\n\tint ROLE_SUPPORT = 1;\n\n\t/**\n\t * Role hint indicating that a {@code BeanDefinition} is providing an\n\t * entirely background role and has no relevance to the end-user. This hint is\n\t * used when registering beans that are completely part of the internal workings\n\t * of a {@link org.springframework.beans.factory.parsing.ComponentDefinition}.\n\t */\n\tint ROLE_INFRASTRUCTURE = 2;\n\n\n\t// Modifiable attributes\n\n\t/**\n\t * Set the name of the parent definition of this bean definition, if any.\n\t */\n\tvoid setParentName(@Nullable String parentName);\n\n\t/**\n\t * Return the name of the parent definition of this bean definition, if any.\n\t */\n\t@Nullable String getParentName();\n\n\t/**\n\t * Specify the bean class name of this bean definition.\n\t * <p>The class name can be modified during bean factory post-processing,\n\t * typically replacing the original class name with a parsed variant of it.\n\t * @see #setParentName\n\t * @see #setFactoryBeanName\n\t * @see #setFactoryMethodName\n\t */\n\tvoid setBeanClassName(@Nullable String beanClassName);\n\n\t/**\n\t * Return the current bean class name of this bean definition.\n\t * <p>Note that this does not have to be the actual class name used at runtime, in\n\t * case of a child definition overriding/inheriting the class name from its parent.\n\t * Also, this may just be the class that a factory method is called on, or it may\n\t * even be empty in case of a factory bean reference that a method is called on.\n\t * Hence, do <i>not</i> consider this to be the definitive bean type at runtime but\n\t * rather only use it for parsing purposes at the individual bean definition level.\n\t * @see #getParentName()\n\t * @see #getFactoryBeanName()\n\t * @see #getFactoryMethodName()\n\t */\n\t@Nullable String getBeanClassName();\n\n\t/**\n\t * Override the target scope of this bean, specifying a new scope name.\n\t * @see #SCOPE_SINGLETON\n\t * @see #SCOPE_PROTOTYPE\n\t */\n\tvoid setScope(@Nullable String scope);\n\n\t/**\n\t * Return the name of the current target scope for this bean,\n\t * or {@code null} if not known yet.\n\t */\n\t@Nullable String getScope();\n\n\t/**\n\t * Set whether this bean should be lazily initialized.\n\t * <p>If {@code false}, the bean will get instantiated on startup by bean\n\t * factories that perform eager initialization of singletons.\n\t */\n\tvoid setLazyInit(boolean lazyInit);\n\n\t/**\n\t * Return whether this bean should be lazily initialized, i.e. not\n\t * eagerly instantiated on startup. Only applicable to a singleton bean.\n\t */\n\tboolean isLazyInit();\n\n\t/**\n\t * Set the names of the beans that this bean depends on being initialized.\n\t * The bean factory will guarantee that these beans get initialized first.\n\t * <p>Note that dependencies are normally expressed through bean properties or\n\t * constructor arguments. This property should just be necessary for other kinds\n\t * of dependencies like statics (*ugh*) or database preparation on startup.\n\t */\n\tvoid setDependsOn(String @Nullable ... dependsOn);\n\n\t/**\n\t * Return the bean names that this bean depends on.\n\t */\n\tString @Nullable [] getDependsOn();\n\n\t/**\n\t * Set whether this bean is a candidate for getting autowired into some other bean.\n\t * <p>Note that this flag is designed to only affect type-based autowiring.\n\t * It does not affect explicit references by name, which will get resolved even\n\t * if the specified bean is not marked as an autowire candidate. As a consequence,\n\t * autowiring by name will nevertheless inject a bean if the name matches.\n\t */\n\tvoid setAutowireCandidate(boolean autowireCandidate);\n\n\t/**\n\t * Return whether this bean is a candidate for getting autowired into some other bean.\n\t */\n\tboolean isAutowireCandidate();\n\n\t/**\n\t * Set whether this bean is a primary autowire candidate.\n\t * <p>If this value is {@code true} for exactly one bean among multiple\n\t * matching candidates, it will serve as a tie-breaker.\n\t * @see #setFallback\n\t */\n\tvoid setPrimary(boolean primary);\n\n\t/**\n\t * Return whether this bean is a primary autowire candidate.\n\t */\n\tboolean isPrimary();\n\n\t/**\n\t * Set whether this bean is a fallback autowire candidate.\n\t * <p>If this value is {@code true} for all beans but one among multiple\n\t * matching candidates, the remaining bean will be selected.\n\t * @since 6.2\n\t * @see #setPrimary\n\t */\n\tvoid setFallback(boolean fallback);\n\n\t/**\n\t * Return whether this bean is a fallback autowire candidate.\n\t * @since 6.2\n\t */\n\tboolean isFallback();\n\n\t/**\n\t * Specify the factory bean to use, if any.\n\t * This is the name of the bean to call the specified factory method on.\n\t * <p>A factory bean name is only necessary for instance-based factory methods.\n\t * For static factory methods, the method will be derived from the bean class.\n\t * @see #setFactoryMethodName\n\t * @see #setBeanClassName\n\t */\n\tvoid setFactoryBeanName(@Nullable String factoryBeanName);\n\n\t/**\n\t * Return the factory bean name, if any.\n\t * <p>This will be {@code null} for static factory methods which will\n\t * be derived from the bean class instead.\n\t * @see #getFactoryMethodName()\n\t * @see #getBeanClassName()\n\t */\n\t@Nullable String getFactoryBeanName();\n\n\t/**\n\t * Specify a factory method, if any. This method will be invoked with\n\t * constructor arguments, or with no arguments if none are specified.\n\t * The method will be invoked on the specified factory bean, if any,\n\t * or otherwise as a static method on the local bean class.\n\t * @see #setFactoryBeanName\n\t * @see #setBeanClassName\n\t */\n\tvoid setFactoryMethodName(@Nullable String factoryMethodName);\n\n\t/**\n\t * Return a factory method, if any.\n\t * @see #getFactoryBeanName()\n\t * @see #getBeanClassName()\n\t */\n\t@Nullable String getFactoryMethodName();\n\n\t/**\n\t * Return the constructor argument values for this bean.\n\t * <p>The returned instance can be modified during bean factory post-processing.\n\t * @return the ConstructorArgumentValues object (never {@code null})\n\t */\n\tConstructorArgumentValues getConstructorArgumentValues();\n\n\t/**\n\t * Return if there are constructor argument values defined for this bean.\n\t * @since 5.0.2\n\t * @see #getConstructorArgumentValues()\n\t */\n\tdefault boolean hasConstructorArgumentValues() {\n\t\treturn !getConstructorArgumentValues().isEmpty();\n\t}\n\n\t/**\n\t * Return the property values to be applied to a new instance of the bean.\n\t * <p>The returned instance can be modified during bean factory post-processing.\n\t * @return the MutablePropertyValues object (never {@code null})\n\t */\n\tMutablePropertyValues getPropertyValues();\n\n\t/**\n\t * Return if there are property values defined for this bean.\n\t * @since 5.0.2\n\t * @see #getPropertyValues()\n\t */\n\tdefault boolean hasPropertyValues() {\n\t\treturn !getPropertyValues().isEmpty();\n\t}\n\n\t/**\n\t * Set the name of the initializer method.\n\t * @since 5.1\n\t */\n\tvoid setInitMethodName(@Nullable String initMethodName);\n\n\t/**\n\t * Return the name of the initializer method.\n\t * @since 5.1\n\t */\n\t@Nullable String getInitMethodName();\n\n\t/**\n\t * Set the name of the destroy method.\n\t * @since 5.1\n\t */\n\tvoid setDestroyMethodName(@Nullable String destroyMethodName);\n\n\t/**\n\t * Return the name of the destroy method.\n\t * @since 5.1\n\t */\n\t@Nullable String getDestroyMethodName();\n\n\t/**\n\t * Set the role hint for this {@code BeanDefinition}. The role hint\n\t * provides the frameworks as well as tools an indication of\n\t * the role and importance of a particular {@code BeanDefinition}.\n\t * @since 5.1\n\t * @see #ROLE_APPLICATION\n\t * @see #ROLE_SUPPORT\n\t * @see #ROLE_INFRASTRUCTURE\n\t */\n\tvoid setRole(int role);\n\n\t/**\n\t * Get the role hint for this {@code BeanDefinition}. The role hint\n\t * provides the frameworks as well as tools an indication of\n\t * the role and importance of a particular {@code BeanDefinition}.\n\t * @see #ROLE_APPLICATION\n\t * @see #ROLE_SUPPORT\n\t * @see #ROLE_INFRASTRUCTURE\n\t */\n\tint getRole();\n\n\t/**\n\t * Set a human-readable description of this bean definition.\n\t * @since 5.1\n\t */\n\tvoid setDescription(@Nullable String description);\n\n\t/**\n\t * Return a human-readable description of this bean definition.\n\t */\n\t@Nullable String getDescription();\n\n\n\t// Read-only attributes\n\n\t/**\n\t * Return a resolvable type for this bean definition,\n\t * based on the bean class or other specific metadata.\n\t * <p>This is typically fully resolved on a runtime-merged bean definition\n\t * but not necessarily on a configuration-time definition instance.\n\t * @return the resolvable type (potentially {@link ResolvableType#NONE})\n\t * @since 5.2\n\t * @see ConfigurableBeanFactory#getMergedBeanDefinition\n\t */\n\tResolvableType getResolvableType();\n\n\t/**\n\t * Return whether this a <b>Singleton</b>, with a single, shared instance\n\t * returned on all calls.\n\t * @see #SCOPE_SINGLETON\n\t */\n\tboolean isSingleton();\n\n\t/**\n\t * Return whether this a <b>Prototype</b>, with an independent instance\n\t * returned for each call.\n\t * @since 3.0\n\t * @see #SCOPE_PROTOTYPE\n\t */\n\tboolean isPrototype();\n\n\t/**\n\t * Return whether this bean is \"abstract\", that is, not meant to be instantiated\n\t * itself but rather just serving as parent for concrete child bean definitions.\n\t */\n\tboolean isAbstract();\n\n\t/**\n\t * Return a description of the resource that this bean definition\n\t * came from (for the purpose of showing context in case of errors).\n\t */\n\t@Nullable String getResourceDescription();\n\n\t/**\n\t * Return the originating BeanDefinition, or {@code null} if none.\n\t * <p>Allows for retrieving the decorated bean definition, if any.\n\t * <p>Note that this method returns the immediate originator. Iterate through the\n\t * originator chain to find the original BeanDefinition as defined by the user.\n\t */\n\t@Nullable BeanDefinition getOriginatingBeanDefinition();\n\n}"
  },
  "org.springframework.beans.factory.config.BeanDefinitionHolder#getAliases()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the alias names for the bean, as specified directly for the bean definition.\n\t * @return the array of alias names, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "String[]",
    "signature": "public String[] getAliases()",
    "source_code": "\tpublic String[] getAliases() {\n\t\treturn this.aliases;\n\t}"
  },
  "org.springframework.beans.factory.config.CustomEditorConfigurer": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link BeanFactoryPostProcessor} implementation that allows for convenient\n * registration of custom {@link PropertyEditor property editors}.\n *\n * <p>In case you want to register {@link PropertyEditor} instances,\n * the recommended usage as of Spring 2.0 is to use custom\n * {@link PropertyEditorRegistrar} implementations that in turn register any\n * desired editor instances on a given\n * {@link org.springframework.beans.PropertyEditorRegistry registry}. Each\n * PropertyEditorRegistrar can register any number of custom editors.\n *\n * <pre class=\"code\">\n * &lt;bean id=\"customEditorConfigurer\" class=\"org.springframework.beans.factory.config.CustomEditorConfigurer\"&gt;\n *   &lt;property name=\"propertyEditorRegistrars\"&gt;\n *     &lt;list&gt;\n *       &lt;bean class=\"mypackage.MyCustomDateEditorRegistrar\"/&gt;\n *       &lt;bean class=\"mypackage.MyObjectEditorRegistrar\"/&gt;\n *     &lt;/list&gt;\n *   &lt;/property&gt;\n * &lt;/bean&gt;\n * </pre>\n *\n * <p>\n * It's perfectly fine to register {@link PropertyEditor} <em>classes</em> via\n * the {@code customEditors} property. Spring will create fresh instances of\n * them for each editing attempt then:\n *\n * <pre class=\"code\">\n * &lt;bean id=\"customEditorConfigurer\" class=\"org.springframework.beans.factory.config.CustomEditorConfigurer\"&gt;\n *   &lt;property name=\"customEditors\"&gt;\n *     &lt;map&gt;\n *       &lt;entry key=\"java.util.Date\" value=\"mypackage.MyCustomDateEditor\"/&gt;\n *       &lt;entry key=\"mypackage.MyObject\" value=\"mypackage.MyObjectEditor\"/&gt;\n *     &lt;/map&gt;\n *   &lt;/property&gt;\n * &lt;/bean&gt;\n * </pre>\n *\n * <p>\n * Note, that you shouldn't register {@link PropertyEditor} bean instances via\n * the {@code customEditors} property as {@link PropertyEditor PropertyEditors} are stateful\n * and the instances will then have to be synchronized for every editing\n * attempt. In case you need control over the instantiation process of\n * {@link PropertyEditor PropertyEditors}, use a {@link PropertyEditorRegistrar} to register\n * them.\n *\n * <p>\n * Also supports \"java.lang.String[]\"-style array class names and primitive\n * class names (for example, \"boolean\"). Delegates to {@link ClassUtils} for actual\n * class name resolution.\n *\n * <p><b>NOTE:</b> Custom property editors registered with this configurer do\n * <i>not</i> apply to data binding. Custom editors for data binding need to\n * be registered on the {@link org.springframework.validation.DataBinder}:\n * Use a common base class or delegate to common PropertyEditorRegistrar\n * implementations to reuse editor registration there.\n *\n * @author Juergen Hoeller\n * @since 27.02.2004\n * @see java.beans.PropertyEditor\n * @see org.springframework.beans.PropertyEditorRegistrar\n * @see ConfigurableBeanFactory#addPropertyEditorRegistrar\n * @see ConfigurableBeanFactory#registerCustomEditor\n * @see org.springframework.validation.DataBinder#registerCustomEditor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "signature": "public class CustomEditorConfigurer",
    "source_code": "public class CustomEditorConfigurer implements BeanFactoryPostProcessor, Ordered {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate int order = Ordered.LOWEST_PRECEDENCE;  // default: same as non-Ordered\n\n\tprivate PropertyEditorRegistrar @Nullable [] propertyEditorRegistrars;\n\n\tprivate @Nullable Map<Class<?>, Class<? extends PropertyEditor>> customEditors;\n\n\n\tpublic void setOrder(int order) {\n\t\tthis.order = order;\n\t}\n\n\t@Override\n\tpublic int getOrder() {\n\t\treturn this.order;\n\t}\n\n\t/**\n\t * Specify the {@link PropertyEditorRegistrar PropertyEditorRegistrars}\n\t * to apply to beans defined within the current application context.\n\t * <p>This allows for sharing {@code PropertyEditorRegistrars} with\n\t * {@link org.springframework.validation.DataBinder DataBinders}, etc.\n\t * Furthermore, it avoids the need for synchronization on custom editors:\n\t * A {@code PropertyEditorRegistrar} will always create fresh editor\n\t * instances for each bean creation attempt.\n\t * @see ConfigurableListableBeanFactory#addPropertyEditorRegistrar\n\t */\n\tpublic void setPropertyEditorRegistrars(PropertyEditorRegistrar[] propertyEditorRegistrars) {\n\t\tthis.propertyEditorRegistrars = propertyEditorRegistrars;\n\t}\n\n\t/**\n\t * Specify the custom editors to register via a {@link Map}, using the\n\t * class name of the required type as the key and the class name of the\n\t * associated {@link PropertyEditor} as value.\n\t * @see ConfigurableListableBeanFactory#registerCustomEditor\n\t */\n\tpublic void setCustomEditors(Map<Class<?>, Class<? extends PropertyEditor>> customEditors) {\n\t\tthis.customEditors = customEditors;\n\t}\n\n\n\t@Override\n\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\t\tif (this.propertyEditorRegistrars != null) {\n\t\t\tfor (PropertyEditorRegistrar propertyEditorRegistrar : this.propertyEditorRegistrars) {\n\t\t\t\tbeanFactory.addPropertyEditorRegistrar(propertyEditorRegistrar);\n\t\t\t}\n\t\t}\n\t\tif (this.customEditors != null) {\n\t\t\tthis.customEditors.forEach(beanFactory::registerCustomEditor);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.beans.factory.config.CustomEditorConfigurer#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic int getOrder() {\n\t\treturn this.order;\n\t}"
  },
  "org.springframework.beans.factory.config.CustomEditorConfigurer#postProcessBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "void",
    "signature": "public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)",
    "source_code": "\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\t\tif (this.propertyEditorRegistrars != null) {\n\t\t\tfor (PropertyEditorRegistrar propertyEditorRegistrar : this.propertyEditorRegistrars) {\n\t\t\t\tbeanFactory.addPropertyEditorRegistrar(propertyEditorRegistrar);\n\t\t\t}\n\t\t}\n\t\tif (this.customEditors != null) {\n\t\t\tthis.customEditors.forEach(beanFactory::registerCustomEditor);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.CustomEditorConfigurer#setCustomEditors(Map<Class<?>,customEditors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the custom editors to register via a {@link Map}, using the\n\t * class name of the required type as the key and the class name of the\n\t * associated {@link PropertyEditor} as value.\n\t * @see ConfigurableListableBeanFactory#registerCustomEditor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "customEditors"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "public void setCustomEditors(Map<Class<?>, Class<? extends PropertyEditor>> customEditors)",
    "source_code": "\tpublic void setCustomEditors(Map<Class<?>, Class<? extends PropertyEditor>> customEditors) {\n\t\tthis.customEditors = customEditors;\n\t}"
  },
  "org.springframework.beans.factory.config.CustomEditorConfigurer#setOrder(order)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "order"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void setOrder(int order)",
    "source_code": "\tpublic void setOrder(int order) {\n\t\tthis.order = order;\n\t}"
  },
  "org.springframework.beans.factory.config.CustomEditorConfigurer#setPropertyEditorRegistrars(propertyEditorRegistrars)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the {@link PropertyEditorRegistrar PropertyEditorRegistrars}\n\t * to apply to beans defined within the current application context.\n\t * <p>This allows for sharing {@code PropertyEditorRegistrars} with\n\t * {@link org.springframework.validation.DataBinder DataBinders}, etc.\n\t * Furthermore, it avoids the need for synchronization on custom editors:\n\t * A {@code PropertyEditorRegistrar} will always create fresh editor\n\t * instances for each bean creation attempt.\n\t * @see ConfigurableListableBeanFactory#addPropertyEditorRegistrar\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyEditorRegistrars"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void setPropertyEditorRegistrars(PropertyEditorRegistrar[] propertyEditorRegistrars)",
    "source_code": "\tpublic void setPropertyEditorRegistrars(PropertyEditorRegistrar[] propertyEditorRegistrars) {\n\t\tthis.propertyEditorRegistrars = propertyEditorRegistrars;\n\t}"
  },
  "org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Extension of the {@link InstantiationAwareBeanPostProcessor} interface,\n * adding a callback for predicting the eventual type of a processed bean.\n *\n * <p><b>NOTE:</b> This interface is a special purpose interface, mainly for\n * internal use within the framework. In general, application-provided\n * post-processors should simply implement the plain {@link BeanPostProcessor}\n * interface.\n *\n * @author Juergen Hoeller\n * @since 2.0.3\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public interface SmartInstantiationAwareBeanPostProcessor",
    "source_code": "public interface SmartInstantiationAwareBeanPostProcessor extends InstantiationAwareBeanPostProcessor {\n\n\t/**\n\t * Predict the type of the bean to be eventually returned from this\n\t * processor's {@link #postProcessBeforeInstantiation} callback.\n\t * <p>The default implementation returns {@code null}.\n\t * Specific implementations should try to predict the bean type as\n\t * far as known/cached already, without extra processing steps.\n\t * @param beanClass the raw class of the bean\n\t * @param beanName the name of the bean\n\t * @return the type of the bean, or {@code null} if not predictable\n\t * @throws org.springframework.beans.BeansException in case of errors\n\t */\n\tdefault @Nullable Class<?> predictBeanType(Class<?> beanClass, String beanName) throws BeansException {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Determine the type of the bean to be eventually returned from this\n\t * processor's {@link #postProcessBeforeInstantiation} callback.\n\t * <p>The default implementation returns the given bean class as-is.\n\t * Specific implementations should fully evaluate their processing steps\n\t * in order to create/initialize a potential proxy class upfront.\n\t * @param beanClass the raw class of the bean\n\t * @param beanName the name of the bean\n\t * @return the type of the bean (never {@code null})\n\t * @throws org.springframework.beans.BeansException in case of errors\n\t * @since 6.0\n\t */\n\tdefault Class<?> determineBeanType(Class<?> beanClass, String beanName) throws BeansException {\n\t\treturn beanClass;\n\t}\n\n\t/**\n\t * Determine the candidate constructors to use for the given bean.\n\t * <p>The default implementation returns {@code null}.\n\t * @param beanClass the raw class of the bean (never {@code null})\n\t * @param beanName the name of the bean\n\t * @return the candidate constructors, or {@code null} if none specified\n\t * @throws org.springframework.beans.BeansException in case of errors\n\t */\n\tdefault Constructor<?> @Nullable [] determineCandidateConstructors(Class<?> beanClass, String beanName)\n\t\t\tthrows BeansException {\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Obtain a reference for early access to the specified bean,\n\t * typically for the purpose of resolving a circular reference.\n\t * <p>This callback gives post-processors a chance to expose a wrapper\n\t * early - that is, before the target bean instance is fully initialized.\n\t * The exposed object should be equivalent to what\n\t * {@link #postProcessBeforeInitialization} / {@link #postProcessAfterInitialization}\n\t * would expose otherwise. Note that the object returned by this method will\n\t * be used as the bean reference unless the post-processor returns a different\n\t * wrapper from said post-process callbacks. In other words, those post-process\n\t * callbacks may either eventually expose the same reference or alternatively\n\t * return the raw bean instance from those subsequent callbacks (if the wrapper\n\t * for the affected bean has been built for a call to this method already,\n\t * it will be exposed as the final bean reference by default).\n\t * <p>The default implementation returns the given {@code bean} as-is.\n\t * @param bean the raw bean instance\n\t * @param beanName the name of the bean\n\t * @return the object to expose as the bean reference\n\t * (typically the passed-in bean instance as default)\n\t * @throws org.springframework.beans.BeansException in case of errors\n\t */\n\tdefault Object getEarlyBeanReference(Object bean, String beanName) throws BeansException {\n\t\treturn bean;\n\t}\n\n}"
  },
  "org.springframework.beans.factory.field": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "protected Field field",
    "source_code": "\tprotected @Nullable Field field;",
    "type": "Field"
  },
  "org.springframework.beans.factory.methodParameter": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "protected MethodParameter methodParameter",
    "source_code": "\tprotected @Nullable MethodParameter methodParameter;",
    "type": "MethodParameter"
  },
  "org.springframework.beans.factory.parsing.ImportDefinition": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Representation of an import that has been processed during the parsing process.\n *\n * @author Juergen Hoeller\n * @since 2.0\n * @see ReaderEventListener#importProcessed(ImportDefinition)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 32
    },
    "signature": "public class ImportDefinition",
    "source_code": "public class ImportDefinition implements BeanMetadataElement {\n\n\tprivate final String importedResource;\n\n\tprivate final Resource @Nullable [] actualResources;\n\n\tprivate final @Nullable Object source;\n\n\n\t/**\n\t * Create a new ImportDefinition.\n\t * @param importedResource the location of the imported resource\n\t */\n\tpublic ImportDefinition(String importedResource) {\n\t\tthis(importedResource, null, null);\n\t}\n\n\t/**\n\t * Create a new ImportDefinition.\n\t * @param importedResource the location of the imported resource\n\t * @param source the source object (may be {@code null})\n\t */\n\tpublic ImportDefinition(String importedResource, @Nullable Object source) {\n\t\tthis(importedResource, null, source);\n\t}\n\n\t/**\n\t * Create a new ImportDefinition.\n\t * @param importedResource the location of the imported resource\n\t * @param source the source object (may be {@code null})\n\t */\n\tpublic ImportDefinition(String importedResource, Resource @Nullable [] actualResources, @Nullable Object source) {\n\t\tAssert.notNull(importedResource, \"Imported resource must not be null\");\n\t\tthis.importedResource = importedResource;\n\t\tthis.actualResources = actualResources;\n\t\tthis.source = source;\n\t}\n\n\n\t/**\n\t * Return the location of the imported resource.\n\t */\n\tpublic final String getImportedResource() {\n\t\treturn this.importedResource;\n\t}\n\n\tpublic final Resource @Nullable [] getActualResources() {\n\t\treturn this.actualResources;\n\t}\n\n\t@Override\n\tpublic final @Nullable Object getSource() {\n\t\treturn this.source;\n\t}\n\n}"
  },
  "org.springframework.beans.factory.parsing.ImportDefinition#getImportedResource()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the location of the imported resource.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "String",
    "signature": "public String getImportedResource()",
    "source_code": "\tpublic final String getImportedResource() {\n\t\treturn this.importedResource;\n\t}"
  },
  "org.springframework.beans.factory.parsing.ImportDefinition#getSource()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "Object",
    "signature": "public Object getSource()",
    "source_code": "\tpublic final @Nullable Object getSource() {\n\t\treturn this.source;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#evaluate(candidate,paramCount)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "candidate",
      "paramCount"
    ],
    "position": {
      "column": 1,
      "line": 1405
    },
    "return": "String[]",
    "signature": "public String[] evaluate(Constructor<?> candidate, int paramCount)",
    "source_code": "\t\tpublic static String[] evaluate(Constructor<?> candidate, int paramCount) {\n\t\t\tConstructorProperties cp = candidate.getAnnotation(ConstructorProperties.class);\n\t\t\tif (cp != null) {\n\t\t\t\tString[] names = cp.value();\n\t\t\t\tif (names.length != paramCount) {\n\t\t\t\t\tthrow new IllegalStateException(\"Constructor annotated with @ConstructorProperties but not \" +\n\t\t\t\t\t\t\t\"corresponding to actual number of parameters (\" + paramCount + \"): \" + candidate);\n\t\t\t\t}\n\t\t\t\treturn names;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#getDependsOn()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>The default is no beans to explicitly depend on.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 723
    },
    "return": "String[]",
    "signature": "public String[] getDependsOn()",
    "source_code": "\tpublic String[] getDependsOn() {\n\t\treturn this.dependsOn;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#getDestroyMethodNames()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the names of the destroy methods.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1110
    },
    "return": "String[]",
    "signature": "public String[] getDestroyMethodNames()",
    "source_code": "\tpublic String[] getDestroyMethodNames() {\n\t\treturn this.destroyMethodNames;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinition#getInitMethodNames()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the names of the initializer methods.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1050
    },
    "return": "String[]",
    "signature": "public String[] getInitMethodNames()",
    "source_code": "\tpublic String[] getInitMethodNames() {\n\t\treturn this.initMethodNames;\n\t}"
  },
  "org.springframework.beans.factory.support.SimpleInstantiationStrategy#setCurrentlyInvokedFactoryMethod(method)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the factory method currently being invoked or {@code null} to remove\n\t * the  current value, if any.\n\t * @param method the factory method currently being invoked or {@code null}\n\t * @since 6.0\n\t * @deprecated in favor of {@link #instantiateWithFactoryMethod(Method, Supplier)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void setCurrentlyInvokedFactoryMethod(@Nullable Method method)",
    "source_code": "\tpublic static void setCurrentlyInvokedFactoryMethod(@Nullable Method method) {\n\t\tif (method != null) {\n\t\t\tcurrentlyInvokedFactoryMethod.set(method);\n\t\t}\n\t\telse {\n\t\t\tcurrentlyInvokedFactoryMethod.remove();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#getAutowireCandidatePatterns()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return any patterns provided in the 'default-autowire-candidates'\n\t * attribute of the top-level {@code <beans/>} element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 392
    },
    "return": "String[]",
    "signature": "public String[] getAutowireCandidatePatterns()",
    "source_code": "\tpublic String[] getAutowireCandidatePatterns() {\n\t\tString candidatePattern = this.defaults.getAutowireCandidates();\n\t\treturn (candidatePattern != null ? StringUtils.commaDelimitedListToStringArray(candidatePattern) : null);\n\t}"
  },
  "org.springframework.beans.keys": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 1090
    },
    "signature": "public String[] keys",
    "source_code": "\t\tpublic String[] keys;",
    "type": "String[]"
  },
  "org.springframework.cache.Cache": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Interface that defines common cache operations.\n *\n * <p>Serves primarily as an SPI for Spring's annotation-based caching\n * model ({@link org.springframework.cache.annotation.Cacheable} and co)\n * and secondarily as an API for direct usage in applications.\n *\n * <p><b>Note:</b> Due to the generic use of caching, it is recommended\n * that implementations allow storage of {@code null} values\n * (for example to cache methods that return {@code null}).\n *\n * @author Costin Leau\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @since 3.1\n * @see CacheManager\n * @see org.springframework.cache.annotation.Cacheable\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public interface Cache",
    "source_code": "public interface Cache {\n\n\t/**\n\t * Return the cache name.\n\t */\n\tString getName();\n\n\t/**\n\t * Return the underlying native cache provider.\n\t */\n\tObject getNativeCache();\n\n\t/**\n\t * Return the value to which this cache maps the specified key.\n\t * <p>Returns {@code null} if the cache contains no mapping for this key;\n\t * otherwise, the cached value (which may be {@code null} itself) will\n\t * be returned in a {@link ValueWrapper}.\n\t * @param key the key whose associated value is to be returned\n\t * @return the value to which this cache maps the specified key,\n\t * contained within a {@link ValueWrapper} which may also hold\n\t * a cached {@code null} value. A straight {@code null} being\n\t * returned means that the cache contains no mapping for this key.\n\t * @see #get(Object, Class)\n\t * @see #get(Object, Callable)\n\t */\n\t@Nullable ValueWrapper get(Object key);\n\n\t/**\n\t * Return the value to which this cache maps the specified key,\n\t * generically specifying a type that return value will be cast to.\n\t * <p>Note: This variant of {@code get} does not allow for differentiating\n\t * between a cached {@code null} value and no cache entry found at all.\n\t * Use the standard {@link #get(Object)} variant for that purpose instead.\n\t * @param key the key whose associated value is to be returned\n\t * @param type the required type of the returned value (may be\n\t * {@code null} to bypass a type check; in case of a {@code null}\n\t * value found in the cache, the specified type is irrelevant)\n\t * @return the value to which this cache maps the specified key\n\t * (which may be {@code null} itself), or also {@code null} if\n\t * the cache contains no mapping for this key\n\t * @throws IllegalStateException if a cache entry has been found\n\t * but failed to match the specified type\n\t * @since 4.0\n\t * @see #get(Object)\n\t */\n\t<T> @Nullable T get(Object key, @Nullable Class<T> type);\n\n\t/**\n\t * Return the value to which this cache maps the specified key, obtaining\n\t * that value from {@code valueLoader} if necessary. This method provides\n\t * a simple substitute for the conventional \"if cached, return; otherwise\n\t * create, cache and return\" pattern.\n\t * <p>If possible, implementations should ensure that the loading operation\n\t * is synchronized so that the specified {@code valueLoader} is only called\n\t * once in case of concurrent access on the same key.\n\t * <p>If the {@code valueLoader} throws an exception, it is wrapped in\n\t * a {@link ValueRetrievalException}\n\t * @param key the key whose associated value is to be returned\n\t * @return the value to which this cache maps the specified key\n\t * @throws ValueRetrievalException if the {@code valueLoader} throws an exception\n\t * @since 4.3\n\t * @see #get(Object)\n\t */\n\t<T> @Nullable T get(Object key, Callable<T> valueLoader);\n\n\t/**\n\t * Return the value to which this cache maps the specified key,\n\t * wrapped in a {@link CompletableFuture}. This operation must not block\n\t * but is allowed to return a completed {@link CompletableFuture} if the\n\t * corresponding value is immediately available.\n\t * <p>Can return {@code null} if the cache can immediately determine that\n\t * it contains no mapping for this key (for example, through an in-memory key map).\n\t * Otherwise, the cached value will be returned in the {@link CompletableFuture},\n\t * with {@code null} indicating a late-determined cache miss. A nested\n\t * {@link ValueWrapper} potentially indicates a nullable cached value;\n\t * the cached value may also be represented as a plain element if null\n\t * values are not supported. Calling code needs to be prepared to handle\n\t * all those variants of the result returned by this method.\n\t * @param key the key whose associated value is to be returned\n\t * @return the value to which this cache maps the specified key, contained\n\t * within a {@link CompletableFuture} which may also be empty when a cache\n\t * miss has been late-determined. A straight {@code null} being returned\n\t * means that the cache immediately determined that it contains no mapping\n\t * for this key. A {@link ValueWrapper} contained within the\n\t * {@code CompletableFuture} indicates a cached value that is potentially\n\t * {@code null}; this is sensible in a late-determined scenario where a regular\n\t * CompletableFuture-contained {@code null} indicates a cache miss. However,\n\t * a cache may also return a plain value if it does not support the actual\n\t * caching of {@code null} values, avoiding the extra level of value wrapping.\n\t * Spring's cache processing can deal with all such implementation strategies.\n\t * @since 6.1\n\t * @see #retrieve(Object, Supplier)\n\t */\n\tdefault @Nullable CompletableFuture<?> retrieve(Object key) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\tgetClass().getName() + \" does not support CompletableFuture-based retrieval\");\n\t}\n\n\t/**\n\t * Return the value to which this cache maps the specified key, obtaining\n\t * that value from {@code valueLoader} if necessary. This method provides\n\t * a simple substitute for the conventional \"if cached, return; otherwise\n\t * create, cache and return\" pattern, based on {@link CompletableFuture}.\n\t * This operation must not block.\n\t * <p>If possible, implementations should ensure that the loading operation\n\t * is synchronized so that the specified {@code valueLoader} is only called\n\t * once in case of concurrent access on the same key.\n\t * <p>Null values always indicate a user-level {@code null} value with this\n\t * method. The provided {@link CompletableFuture} handle produces a value\n\t * or raises an exception. If the {@code valueLoader} raises an exception,\n\t * it will be propagated to the returned {@code CompletableFuture} handle.\n\t * @param key the key whose associated value is to be returned\n\t * @return the value to which this cache maps the specified key, contained\n\t * within a {@link CompletableFuture} which will never be {@code null}.\n\t * The provided future is expected to produce a value or raise an exception.\n\t * @since 6.1\n\t * @see #retrieve(Object)\n\t * @see #get(Object, Callable)\n\t */\n\tdefault <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\tgetClass().getName() + \" does not support CompletableFuture-based retrieval\");\n\t}\n\n\t/**\n\t * Associate the specified value with the specified key in this cache.\n\t * <p>If the cache previously contained a mapping for this key, the old\n\t * value is replaced by the specified value.\n\t * <p>Actual registration may be performed in an asynchronous or deferred\n\t * fashion, with subsequent lookups possibly not seeing the entry yet.\n\t * This may for example be the case with transactional cache decorators.\n\t * Use {@link #putIfAbsent} for guaranteed immediate registration.\n\t * <p>If the cache is supposed to be compatible with {@link CompletableFuture}\n\t * and reactive interactions, the put operation needs to be effectively\n\t * non-blocking, with any backend write-through happening asynchronously.\n\t * This goes along with a cache implemented and configured to support\n\t * {@link #retrieve(Object)} and {@link #retrieve(Object, Supplier)}.\n\t * @param key the key with which the specified value is to be associated\n\t * @param value the value to be associated with the specified key\n\t * @see #putIfAbsent(Object, Object)\n\t */\n\tvoid put(Object key, @Nullable Object value);\n\n\t/**\n\t * Atomically associate the specified value with the specified key in this cache\n\t * if it is not set already.\n\t * <p>This is equivalent to:\n\t * <pre><code>\n\t * ValueWrapper existingValue = cache.get(key);\n\t * if (existingValue == null) {\n\t *     cache.put(key, value);\n\t * }\n\t * return existingValue;\n\t * </code></pre>\n\t * except that the action is performed atomically. While all out-of-the-box\n\t * {@link CacheManager} implementations are able to perform the put atomically,\n\t * the operation may also be implemented in two steps, for example, with a check for\n\t * presence and a subsequent put, in a non-atomic way. Check the documentation\n\t * of the native cache implementation that you are using for more details.\n\t * <p>The default implementation delegates to {@link #get(Object)} and\n\t * {@link #put(Object, Object)} along the lines of the code snippet above.\n\t * @param key the key with which the specified value is to be associated\n\t * @param value the value to be associated with the specified key\n\t * @return the value to which this cache maps the specified key (which may be\n\t * {@code null} itself), or also {@code null} if the cache did not contain any\n\t * mapping for that key prior to this call. Returning {@code null} is therefore\n\t * an indicator that the given {@code value} has been associated with the key.\n\t * @since 4.1\n\t * @see #put(Object, Object)\n\t */\n\tdefault @Nullable ValueWrapper putIfAbsent(Object key, @Nullable Object value) {\n\t\tValueWrapper existingValue = get(key);\n\t\tif (existingValue == null) {\n\t\t\tput(key, value);\n\t\t}\n\t\treturn existingValue;\n\t}\n\n\t/**\n\t * Evict the mapping for this key from this cache if it is present.\n\t * <p>Actual eviction may be performed in an asynchronous or deferred\n\t * fashion, with subsequent lookups possibly still seeing the entry.\n\t * This may for example be the case with transactional cache decorators.\n\t * Use {@link #evictIfPresent} for guaranteed immediate removal.\n\t * <p>If the cache is supposed to be compatible with {@link CompletableFuture}\n\t * and reactive interactions, the evict operation needs to be effectively\n\t * non-blocking, with any backend write-through happening asynchronously.\n\t * This goes along with a cache implemented and configured to support\n\t * {@link #retrieve(Object)} and {@link #retrieve(Object, Supplier)}.\n\t * @param key the key whose mapping is to be removed from the cache\n\t * @see #evictIfPresent(Object)\n\t */\n\tvoid evict(Object key);\n\n\t/**\n\t * Evict the mapping for this key from this cache if it is present,\n\t * expecting the key to be immediately invisible for subsequent lookups.\n\t * <p>The default implementation delegates to {@link #evict(Object)},\n\t * returning {@code false} for not-determined prior presence of the key.\n\t * Cache providers and in particular cache decorators are encouraged\n\t * to perform immediate eviction if possible (for example, in case of generally\n\t * deferred cache operations within a transaction) and to reliably\n\t * determine prior presence of the given key.\n\t * @param key the key whose mapping is to be removed from the cache\n\t * @return {@code true} if the cache was known to have a mapping for\n\t * this key before, {@code false} if it did not (or if prior presence\n\t * could not be determined)\n\t * @since 5.2\n\t * @see #evict(Object)\n\t */\n\tdefault boolean evictIfPresent(Object key) {\n\t\tevict(key);\n\t\treturn false;\n\t}\n\n\t/**\n\t * Clear the cache through removing all mappings.\n\t * <p>Actual clearing may be performed in an asynchronous or deferred\n\t * fashion, with subsequent lookups possibly still seeing the entries.\n\t * This may for example be the case with transactional cache decorators.\n\t * Use {@link #invalidate()} for guaranteed immediate removal of entries.\n\t * <p>If the cache is supposed to be compatible with {@link CompletableFuture}\n\t * and reactive interactions, the clear operation needs to be effectively\n\t * non-blocking, with any backend write-through happening asynchronously.\n\t * This goes along with a cache implemented and configured to support\n\t * {@link #retrieve(Object)} and {@link #retrieve(Object, Supplier)}.\n\t * @see #invalidate()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Invalidate the cache through removing all mappings, expecting all\n\t * entries to be immediately invisible for subsequent lookups.\n\t * @return {@code true} if the cache was known to have mappings before,\n\t * {@code false} if it did not (or if prior presence of entries could\n\t * not be determined)\n\t * @since 5.2\n\t * @see #clear()\n\t */\n\tdefault boolean invalidate() {\n\t\tclear();\n\t\treturn false;\n\t}\n\n\n\t/**\n\t * A (wrapper) object representing a cache value.\n\t */\n\t@FunctionalInterface\n\tinterface ValueWrapper {\n\n\t\t/**\n\t\t * Return the actual value in the cache.\n\t\t */\n\t\t@Nullable Object get();\n\t}\n\n\n\t/**\n\t * Wrapper exception to be thrown from {@link #get(Object, Callable)}\n\t * in case of the value loader callback failing with an exception.\n\t * @since 4.3\n\t */\n\t@SuppressWarnings(\"serial\")\n\tclass ValueRetrievalException extends RuntimeException {\n\n\t\tprivate final @Nullable Object key;\n\n\t\tpublic ValueRetrievalException(@Nullable Object key, Callable<?> loader, @Nullable Throwable ex) {\n\t\t\tsuper(String.format(\"Value for key '%s' could not be loaded using '%s'\", key, loader), ex);\n\t\t\tthis.key = key;\n\t\t}\n\n\t\tpublic @Nullable Object getKey() {\n\t\t\treturn this.key;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.cache.Cache#getKey()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "Object",
    "signature": "public Object getKey()",
    "source_code": "\t\tpublic @Nullable Object getKey() {\n\t\t\treturn this.key;\n\t\t}"
  },
  "org.springframework.cache.annotation.AbstractCachingConfiguration": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base {@code @Configuration} class providing common structure\n * for enabling Spring's annotation-driven cache management capability.\n *\n * @author Chris Beams\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 3.1\n * @see EnableCaching\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class AbstractCachingConfiguration",
    "source_code": "public abstract class AbstractCachingConfiguration implements ImportAware {\n\n\tprotected @Nullable AnnotationAttributes enableCaching;\n\n\tprotected @Nullable Supplier<? extends @Nullable CacheManager> cacheManager;\n\n\tprotected @Nullable Supplier<? extends @Nullable CacheResolver> cacheResolver;\n\n\tprotected @Nullable Supplier<? extends @Nullable KeyGenerator> keyGenerator;\n\n\tprotected @Nullable Supplier<? extends @Nullable CacheErrorHandler> errorHandler;\n\n\n\t@Override\n\tpublic void setImportMetadata(AnnotationMetadata importMetadata) {\n\t\tthis.enableCaching = AnnotationAttributes.fromMap(\n\t\t\t\timportMetadata.getAnnotationAttributes(EnableCaching.class.getName()));\n\t\tif (this.enableCaching == null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"@EnableCaching is not present on importing class \" + importMetadata.getClassName());\n\t\t}\n\t}\n\n\t@Autowired\n\t@SuppressWarnings(\"NullAway\") // https://github.com/uber/NullAway/issues/1126\n\tvoid setConfigurers(ObjectProvider<CachingConfigurer> configurers) {\n\t\tSupplier<? extends @Nullable CachingConfigurer> configurer = () -> {\n\t\t\tList<CachingConfigurer> candidates = configurers.stream().toList();\n\t\t\tif (CollectionUtils.isEmpty(candidates)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (candidates.size() > 1) {\n\t\t\t\tthrow new IllegalStateException(candidates.size() + \" implementations of \" +\n\t\t\t\t\t\t\"CachingConfigurer were found when only 1 was expected. \" +\n\t\t\t\t\t\t\"Refactor the configuration such that CachingConfigurer is \" +\n\t\t\t\t\t\t\"implemented only once or not at all.\");\n\t\t\t}\n\t\t\treturn candidates.get(0);\n\t\t};\n\t\tuseCachingConfigurer(new CachingConfigurerSupplier(configurer));\n\t}\n\n\t/**\n\t * Extract the configuration from the nominated {@link CachingConfigurer}.\n\t */\n\t@SuppressWarnings(\"NullAway\") // https://github.com/uber/NullAway/issues/1126\n\tprotected void useCachingConfigurer(CachingConfigurerSupplier cachingConfigurerSupplier) {\n\t\tthis.cacheManager = cachingConfigurerSupplier.adapt(CachingConfigurer::cacheManager);\n\t\tthis.cacheResolver = cachingConfigurerSupplier.adapt(CachingConfigurer::cacheResolver);\n\t\tthis.keyGenerator = cachingConfigurerSupplier.adapt(CachingConfigurer::keyGenerator);\n\t\tthis.errorHandler = cachingConfigurerSupplier.adapt(CachingConfigurer::errorHandler);\n\t}\n\n\n\tprotected static class CachingConfigurerSupplier {\n\n\t\tprivate final SingletonSupplier<CachingConfigurer> supplier;\n\n\t\tpublic CachingConfigurerSupplier(Supplier<? extends @Nullable CachingConfigurer> supplier) {\n\t\t\tthis.supplier = SingletonSupplier.ofNullable(supplier);\n\t\t}\n\n\t\t/**\n\t\t * Adapt the {@link CachingConfigurer} supplier to another supplier\n\t\t * provided by the specified mapping function. If the underlying\n\t\t * {@link CachingConfigurer} is {@code null}, {@code null} is returned\n\t\t * and the mapping function is not invoked.\n\t\t * @param provider the provider to use to adapt the supplier\n\t\t * @param <T> the type of the supplier\n\t\t * @return another supplier mapped by the specified function\n\t\t */\n\t\tpublic <T> Supplier<@Nullable T> adapt(Function<CachingConfigurer, ? extends @Nullable T> provider) {\n\t\t\treturn () -> {\n\t\t\t\tCachingConfigurer cachingConfigurer = this.supplier.get();\n\t\t\t\treturn (cachingConfigurer != null ? provider.apply(cachingConfigurer) : null);\n\t\t\t};\n\t\t}\n\n\t}\n\n}"
  },
  "org.springframework.cache.annotation.AbstractCachingConfiguration#adapt(Function<CachingConfigurer,provider)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Adapt the {@link CachingConfigurer} supplier to another supplier\n\t\t * provided by the specified mapping function. If the underlying\n\t\t * {@link CachingConfigurer} is {@code null}, {@code null} is returned\n\t\t * and the mapping function is not invoked.\n\t\t * @param provider the provider to use to adapt the supplier\n\t\t * @param <T> the type of the supplier\n\t\t * @return another supplier mapped by the specified function\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<CachingConfigurer",
      "provider"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "T>",
    "signature": "public T> adapt(Function<CachingConfigurer, ? extends @Nullable T> provider)",
    "source_code": "\t\tpublic <T> Supplier<@Nullable T> adapt(Function<CachingConfigurer, ? extends @Nullable T> provider) {\n\t\t\treturn () -> {\n\t\t\t\tCachingConfigurer cachingConfigurer = this.supplier.get();\n\t\t\t\treturn (cachingConfigurer != null ? provider.apply(cachingConfigurer) : null);\n\t\t\t};\n\t\t}"
  },
  "org.springframework.cache.annotation.AbstractCachingConfiguration#setImportMetadata(importMetadata)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "importMetadata"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "void",
    "signature": "public void setImportMetadata(AnnotationMetadata importMetadata)",
    "source_code": "\tpublic void setImportMetadata(AnnotationMetadata importMetadata) {\n\t\tthis.enableCaching = AnnotationAttributes.fromMap(\n\t\t\t\timportMetadata.getAnnotationAttributes(EnableCaching.class.getName()));\n\t\tif (this.enableCaching == null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"@EnableCaching is not present on importing class \" + importMetadata.getClassName());\n\t\t}\n\t}"
  },
  "org.springframework.cache.annotation.AbstractCachingConfiguration#useCachingConfigurer(cachingConfigurerSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract the configuration from the nominated {@link CachingConfigurer}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cachingConfigurerSupplier"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "void",
    "signature": "protected void useCachingConfigurer(CachingConfigurerSupplier cachingConfigurerSupplier)",
    "source_code": "\tprotected void useCachingConfigurer(CachingConfigurerSupplier cachingConfigurerSupplier) {\n\t\tthis.cacheManager = cachingConfigurerSupplier.adapt(CachingConfigurer::cacheManager);\n\t\tthis.cacheResolver = cachingConfigurerSupplier.adapt(CachingConfigurer::cacheResolver);\n\t\tthis.keyGenerator = cachingConfigurerSupplier.adapt(CachingConfigurer::keyGenerator);\n\t\tthis.errorHandler = cachingConfigurerSupplier.adapt(CachingConfigurer::errorHandler);\n\t}"
  },
  "org.springframework.cache.annotation.CachingConfigurerSupplier": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "signature": "protected class CachingConfigurerSupplier",
    "source_code": "\tprotected static class CachingConfigurerSupplier {\n\n\t\tprivate final SingletonSupplier<CachingConfigurer> supplier;\n\n\t\tpublic CachingConfigurerSupplier(Supplier<? extends @Nullable CachingConfigurer> supplier) {\n\t\t\tthis.supplier = SingletonSupplier.ofNullable(supplier);\n\t\t}\n\n\t\t/**\n\t\t * Adapt the {@link CachingConfigurer} supplier to another supplier\n\t\t * provided by the specified mapping function. If the underlying\n\t\t * {@link CachingConfigurer} is {@code null}, {@code null} is returned\n\t\t * and the mapping function is not invoked.\n\t\t * @param provider the provider to use to adapt the supplier\n\t\t * @param <T> the type of the supplier\n\t\t * @return another supplier mapped by the specified function\n\t\t */\n\t\tpublic <T> Supplier<@Nullable T> adapt(Function<CachingConfigurer, ? extends @Nullable T> provider) {\n\t\t\treturn () -> {\n\t\t\t\tCachingConfigurer cachingConfigurer = this.supplier.get();\n\t\t\t\treturn (cachingConfigurer != null ? provider.apply(cachingConfigurer) : null);\n\t\t\t};\n\t\t}\n\n\t}"
  },
  "org.springframework.cache.annotation.SpringCacheAnnotationParser": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Strategy implementation for parsing Spring's {@link Caching}, {@link Cacheable},\n * {@link CacheEvict}, and {@link CachePut} annotations.\n *\n * @author Costin Leau\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Phillip Webb\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class SpringCacheAnnotationParser",
    "source_code": "public class SpringCacheAnnotationParser implements CacheAnnotationParser, Serializable {\n\n\tprivate static final Set<Class<? extends Annotation>> CACHE_OPERATION_ANNOTATIONS =\n\t\t\tSet.of(Cacheable.class, CacheEvict.class, CachePut.class, Caching.class);\n\n\n\t@Override\n\tpublic boolean isCandidateClass(Class<?> targetClass) {\n\t\treturn AnnotationUtils.isCandidateClass(targetClass, CACHE_OPERATION_ANNOTATIONS);\n\t}\n\n\t@Override\n\tpublic @Nullable Collection<CacheOperation> parseCacheAnnotations(Class<?> type) {\n\t\tDefaultCacheConfig defaultConfig = new DefaultCacheConfig(type);\n\t\treturn parseCacheAnnotations(defaultConfig, type);\n\t}\n\n\t@Override\n\tpublic @Nullable Collection<CacheOperation> parseCacheAnnotations(Method method) {\n\t\tDefaultCacheConfig defaultConfig = new DefaultCacheConfig(method.getDeclaringClass());\n\t\treturn parseCacheAnnotations(defaultConfig, method);\n\t}\n\n\tprivate @Nullable Collection<CacheOperation> parseCacheAnnotations(DefaultCacheConfig cachingConfig, AnnotatedElement ae) {\n\t\tCollection<CacheOperation> ops = parseCacheAnnotations(cachingConfig, ae, false);\n\t\tif (ops != null && ops.size() > 1) {\n\t\t\t// More than one operation found -> local declarations override interface-declared ones...\n\t\t\tCollection<CacheOperation> localOps = parseCacheAnnotations(cachingConfig, ae, true);\n\t\t\tif (localOps != null) {\n\t\t\t\treturn localOps;\n\t\t\t}\n\t\t}\n\t\treturn ops;\n\t}\n\n\tprivate @Nullable Collection<CacheOperation> parseCacheAnnotations(\n\t\t\tDefaultCacheConfig cachingConfig, AnnotatedElement ae, boolean localOnly) {\n\n\t\tCollection<? extends Annotation> annotations = (localOnly ?\n\t\t\t\tAnnotatedElementUtils.getAllMergedAnnotations(ae, CACHE_OPERATION_ANNOTATIONS) :\n\t\t\t\tAnnotatedElementUtils.findAllMergedAnnotations(ae, CACHE_OPERATION_ANNOTATIONS));\n\t\tif (annotations.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tCollection<CacheOperation> ops = new ArrayList<>(1);\n\t\tannotations.stream().filter(Cacheable.class::isInstance).map(Cacheable.class::cast).forEach(\n\t\t\t\tcacheable -> ops.add(parseCacheableAnnotation(ae, cachingConfig, cacheable)));\n\t\tannotations.stream().filter(CacheEvict.class::isInstance).map(CacheEvict.class::cast).forEach(\n\t\t\t\tcacheEvict -> ops.add(parseEvictAnnotation(ae, cachingConfig, cacheEvict)));\n\t\tannotations.stream().filter(CachePut.class::isInstance).map(CachePut.class::cast).forEach(\n\t\t\t\tcachePut -> ops.add(parsePutAnnotation(ae, cachingConfig, cachePut)));\n\t\tannotations.stream().filter(Caching.class::isInstance).map(Caching.class::cast).forEach(\n\t\t\t\tcaching -> parseCachingAnnotation(ae, cachingConfig, caching, ops));\n\t\treturn ops;\n\t}\n\n\tprivate CacheableOperation parseCacheableAnnotation(\n\t\t\tAnnotatedElement ae, DefaultCacheConfig defaultConfig, Cacheable cacheable) {\n\n\t\tCacheableOperation.Builder builder = new CacheableOperation.Builder();\n\n\t\tbuilder.setName(ae.toString());\n\t\tbuilder.setCacheNames(cacheable.cacheNames());\n\t\tbuilder.setCondition(cacheable.condition());\n\t\tbuilder.setUnless(cacheable.unless());\n\t\tbuilder.setKey(cacheable.key());\n\t\tbuilder.setKeyGenerator(cacheable.keyGenerator());\n\t\tbuilder.setCacheManager(cacheable.cacheManager());\n\t\tbuilder.setCacheResolver(cacheable.cacheResolver());\n\t\tbuilder.setSync(cacheable.sync());\n\n\t\tdefaultConfig.applyDefault(builder);\n\t\tCacheableOperation op = builder.build();\n\t\tvalidateCacheOperation(ae, op);\n\n\t\treturn op;\n\t}\n\n\tprivate CacheEvictOperation parseEvictAnnotation(\n\t\t\tAnnotatedElement ae, DefaultCacheConfig defaultConfig, CacheEvict cacheEvict) {\n\n\t\tCacheEvictOperation.Builder builder = new CacheEvictOperation.Builder();\n\n\t\tbuilder.setName(ae.toString());\n\t\tbuilder.setCacheNames(cacheEvict.cacheNames());\n\t\tbuilder.setCondition(cacheEvict.condition());\n\t\tbuilder.setKey(cacheEvict.key());\n\t\tbuilder.setKeyGenerator(cacheEvict.keyGenerator());\n\t\tbuilder.setCacheManager(cacheEvict.cacheManager());\n\t\tbuilder.setCacheResolver(cacheEvict.cacheResolver());\n\t\tbuilder.setCacheWide(cacheEvict.allEntries());\n\t\tbuilder.setBeforeInvocation(cacheEvict.beforeInvocation());\n\n\t\tdefaultConfig.applyDefault(builder);\n\t\tCacheEvictOperation op = builder.build();\n\t\tvalidateCacheOperation(ae, op);\n\n\t\treturn op;\n\t}\n\n\tprivate CacheOperation parsePutAnnotation(\n\t\t\tAnnotatedElement ae, DefaultCacheConfig defaultConfig, CachePut cachePut) {\n\n\t\tCachePutOperation.Builder builder = new CachePutOperation.Builder();\n\n\t\tbuilder.setName(ae.toString());\n\t\tbuilder.setCacheNames(cachePut.cacheNames());\n\t\tbuilder.setCondition(cachePut.condition());\n\t\tbuilder.setUnless(cachePut.unless());\n\t\tbuilder.setKey(cachePut.key());\n\t\tbuilder.setKeyGenerator(cachePut.keyGenerator());\n\t\tbuilder.setCacheManager(cachePut.cacheManager());\n\t\tbuilder.setCacheResolver(cachePut.cacheResolver());\n\n\t\tdefaultConfig.applyDefault(builder);\n\t\tCachePutOperation op = builder.build();\n\t\tvalidateCacheOperation(ae, op);\n\n\t\treturn op;\n\t}\n\n\tprivate void parseCachingAnnotation(\n\t\t\tAnnotatedElement ae, DefaultCacheConfig defaultConfig, Caching caching, Collection<CacheOperation> ops) {\n\n\t\tCacheable[] cacheables = caching.cacheable();\n\t\tfor (Cacheable cacheable : cacheables) {\n\t\t\tops.add(parseCacheableAnnotation(ae, defaultConfig, cacheable));\n\t\t}\n\t\tCacheEvict[] cacheEvicts = caching.evict();\n\t\tfor (CacheEvict cacheEvict : cacheEvicts) {\n\t\t\tops.add(parseEvictAnnotation(ae, defaultConfig, cacheEvict));\n\t\t}\n\t\tCachePut[] cachePuts = caching.put();\n\t\tfor (CachePut cachePut : cachePuts) {\n\t\t\tops.add(parsePutAnnotation(ae, defaultConfig, cachePut));\n\t\t}\n\t}\n\n\n\t/**\n\t * Validates the specified {@link CacheOperation}.\n\t * <p>Throws an {@link IllegalStateException} if the state of the operation is\n\t * invalid. As there might be multiple sources for default values, this ensures\n\t * that the operation is in a proper state before being returned.\n\t * @param ae the annotated element of the cache operation\n\t * @param operation the {@link CacheOperation} to validate\n\t */\n\tprivate void validateCacheOperation(AnnotatedElement ae, CacheOperation operation) {\n\t\tif (StringUtils.hasText(operation.getKey()) && StringUtils.hasText(operation.getKeyGenerator())) {\n\t\t\tthrow new IllegalStateException(\"Invalid cache annotation configuration on '\" +\n\t\t\t\t\tae.toString() + \"'. Both 'key' and 'keyGenerator' attributes have been set. \" +\n\t\t\t\t\t\"These attributes are mutually exclusive: either set the SpEL expression used to\" +\n\t\t\t\t\t\"compute the key at runtime or set the name of the KeyGenerator bean to use.\");\n\t\t}\n\t\tif (StringUtils.hasText(operation.getCacheManager()) && StringUtils.hasText(operation.getCacheResolver())) {\n\t\t\tthrow new IllegalStateException(\"Invalid cache annotation configuration on '\" +\n\t\t\t\t\tae.toString() + \"'. Both 'cacheManager' and 'cacheResolver' attributes have been set. \" +\n\t\t\t\t\t\"These attributes are mutually exclusive: the cache manager is used to configure a\" +\n\t\t\t\t\t\"default cache resolver if none is set. If a cache resolver is set, the cache manager\" +\n\t\t\t\t\t\"won't be used.\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (other instanceof SpringCacheAnnotationParser);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn SpringCacheAnnotationParser.class.hashCode();\n\t}\n\n\n\t/**\n\t * Provides default settings for a given set of cache operations.\n\t */\n\tprivate static class DefaultCacheConfig {\n\n\t\tprivate final Class<?> target;\n\n\t\tprivate String @Nullable [] cacheNames;\n\n\t\tprivate @Nullable String keyGenerator;\n\n\t\tprivate @Nullable String cacheManager;\n\n\t\tprivate @Nullable String cacheResolver;\n\n\t\tprivate boolean initialized = false;\n\n\t\tpublic DefaultCacheConfig(Class<?> target) {\n\t\t\tthis.target = target;\n\t\t}\n\n\t\t/**\n\t\t * Apply the defaults to the specified {@link CacheOperation.Builder}.\n\t\t * @param builder the operation builder to update\n\t\t */\n\t\tpublic void applyDefault(CacheOperation.Builder builder) {\n\t\t\tif (!this.initialized) {\n\t\t\t\tCacheConfig annotation = AnnotatedElementUtils.findMergedAnnotation(this.target, CacheConfig.class);\n\t\t\t\tif (annotation != null) {\n\t\t\t\t\tthis.cacheNames = annotation.cacheNames();\n\t\t\t\t\tthis.keyGenerator = annotation.keyGenerator();\n\t\t\t\t\tthis.cacheManager = annotation.cacheManager();\n\t\t\t\t\tthis.cacheResolver = annotation.cacheResolver();\n\t\t\t\t}\n\t\t\t\tthis.initialized = true;\n\t\t\t}\n\n\t\t\tif (builder.getCacheNames().isEmpty() && this.cacheNames != null) {\n\t\t\t\tbuilder.setCacheNames(this.cacheNames);\n\t\t\t}\n\t\t\tif (!StringUtils.hasText(builder.getKey()) && !StringUtils.hasText(builder.getKeyGenerator()) &&\n\t\t\t\t\tStringUtils.hasText(this.keyGenerator)) {\n\t\t\t\tbuilder.setKeyGenerator(this.keyGenerator);\n\t\t\t}\n\n\t\t\tif (StringUtils.hasText(builder.getCacheManager()) || StringUtils.hasText(builder.getCacheResolver())) {\n\t\t\t\t// One of these is set so we should not inherit anything\n\t\t\t}\n\t\t\telse if (StringUtils.hasText(this.cacheResolver)) {\n\t\t\t\tbuilder.setCacheResolver(this.cacheResolver);\n\t\t\t}\n\t\t\telse if (StringUtils.hasText(this.cacheManager)) {\n\t\t\t\tbuilder.setCacheManager(this.cacheManager);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.cache.annotation.SpringCacheAnnotationParser#applyDefault(builder)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Apply the defaults to the specified {@link CacheOperation.Builder}.\n\t\t * @param builder the operation builder to update\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "void",
    "signature": "public void applyDefault(CacheOperation.Builder builder)",
    "source_code": "\t\tpublic void applyDefault(CacheOperation.Builder builder) {\n\t\t\tif (!this.initialized) {\n\t\t\t\tCacheConfig annotation = AnnotatedElementUtils.findMergedAnnotation(this.target, CacheConfig.class);\n\t\t\t\tif (annotation != null) {\n\t\t\t\t\tthis.cacheNames = annotation.cacheNames();\n\t\t\t\t\tthis.keyGenerator = annotation.keyGenerator();\n\t\t\t\t\tthis.cacheManager = annotation.cacheManager();\n\t\t\t\t\tthis.cacheResolver = annotation.cacheResolver();\n\t\t\t\t}\n\t\t\t\tthis.initialized = true;\n\t\t\t}\n\n\t\t\tif (builder.getCacheNames().isEmpty() && this.cacheNames != null) {\n\t\t\t\tbuilder.setCacheNames(this.cacheNames);\n\t\t\t}\n\t\t\tif (!StringUtils.hasText(builder.getKey()) && !StringUtils.hasText(builder.getKeyGenerator()) &&\n\t\t\t\t\tStringUtils.hasText(this.keyGenerator)) {\n\t\t\t\tbuilder.setKeyGenerator(this.keyGenerator);\n\t\t\t}\n\n\t\t\tif (StringUtils.hasText(builder.getCacheManager()) || StringUtils.hasText(builder.getCacheResolver())) {\n\t\t\t\t// One of these is set so we should not inherit anything\n\t\t\t}\n\t\t\telse if (StringUtils.hasText(this.cacheResolver)) {\n\t\t\t\tbuilder.setCacheResolver(this.cacheResolver);\n\t\t\t}\n\t\t\telse if (StringUtils.hasText(this.cacheManager)) {\n\t\t\t\tbuilder.setCacheManager(this.cacheManager);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.cache.annotation.SpringCacheAnnotationParser#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (other instanceof SpringCacheAnnotationParser);\n\t}"
  },
  "org.springframework.cache.annotation.SpringCacheAnnotationParser#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn SpringCacheAnnotationParser.class.hashCode();\n\t}"
  },
  "org.springframework.cache.annotation.SpringCacheAnnotationParser#isCandidateClass(targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "boolean",
    "signature": "public boolean isCandidateClass(Class<?> targetClass)",
    "source_code": "\tpublic boolean isCandidateClass(Class<?> targetClass) {\n\t\treturn AnnotationUtils.isCandidateClass(targetClass, CACHE_OPERATION_ANNOTATIONS);\n\t}"
  },
  "org.springframework.cache.annotation.SpringCacheAnnotationParser#parseCacheAnnotations(method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "Collection<CacheOperation>",
    "signature": "public Collection<CacheOperation> parseCacheAnnotations(Method method)",
    "source_code": "\tpublic @Nullable Collection<CacheOperation> parseCacheAnnotations(Method method) {\n\t\tDefaultCacheConfig defaultConfig = new DefaultCacheConfig(method.getDeclaringClass());\n\t\treturn parseCacheAnnotations(defaultConfig, method);\n\t}"
  },
  "org.springframework.cache.annotation.SpringCacheAnnotationParser#parseCacheAnnotations(type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "Collection<CacheOperation>",
    "signature": "public Collection<CacheOperation> parseCacheAnnotations(Class<?> type)",
    "source_code": "\tpublic @Nullable Collection<CacheOperation> parseCacheAnnotations(Class<?> type) {\n\t\tDefaultCacheConfig defaultConfig = new DefaultCacheConfig(type);\n\t\treturn parseCacheAnnotations(defaultConfig, type);\n\t}"
  },
  "org.springframework.cache.annotation.enableCaching": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "protected AnnotationAttributes enableCaching",
    "source_code": "\tprotected @Nullable AnnotationAttributes enableCaching;",
    "type": "AnnotationAttributes"
  },
  "org.springframework.cache.concurrent.ConcurrentMapCache": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Simple {@link org.springframework.cache.Cache} implementation based on the core\n * JDK {@code java.util.concurrent} package.\n *\n * <p>Useful for testing or simple caching scenarios, typically in combination\n * with {@link org.springframework.cache.support.SimpleCacheManager} or\n * dynamically through {@link ConcurrentMapCacheManager}.\n *\n * <p>Supports the  {@link #retrieve(Object)} and {@link #retrieve(Object, Supplier)}\n * operations in a best-effort fashion, relying on default {@link CompletableFuture}\n * execution (typically within the JVM's {@link ForkJoinPool#commonPool()}).\n *\n * <p><b>Note:</b> As {@link ConcurrentHashMap} (the default implementation used)\n * does not allow for {@code null} values to be stored, this class will replace\n * them with a predefined internal object. This behavior can be changed through the\n * {@link #ConcurrentMapCache(String, ConcurrentMap, boolean)} constructor.\n *\n * @author Costin Leau\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @since 3.1\n * @see ConcurrentMapCacheManager\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public class ConcurrentMapCache",
    "source_code": "public class ConcurrentMapCache extends AbstractValueAdaptingCache {\n\n\tprivate final String name;\n\n\tprivate final ConcurrentMap<Object, Object> store;\n\n\tprivate final @Nullable SerializationDelegate serialization;\n\n\n\t/**\n\t * Create a new ConcurrentMapCache with the specified name.\n\t * @param name the name of the cache\n\t */\n\tpublic ConcurrentMapCache(String name) {\n\t\tthis(name, new ConcurrentHashMap<>(256), true);\n\t}\n\n\t/**\n\t * Create a new ConcurrentMapCache with the specified name.\n\t * @param name the name of the cache\n\t * @param allowNullValues whether to accept and convert {@code null}\n\t * values for this cache\n\t */\n\tpublic ConcurrentMapCache(String name, boolean allowNullValues) {\n\t\tthis(name, new ConcurrentHashMap<>(256), allowNullValues);\n\t}\n\n\t/**\n\t * Create a new ConcurrentMapCache with the specified name and the\n\t * given internal {@link ConcurrentMap} to use.\n\t * @param name the name of the cache\n\t * @param store the ConcurrentMap to use as an internal store\n\t * @param allowNullValues whether to allow {@code null} values\n\t * (adapting them to an internal null holder value)\n\t */\n\tpublic ConcurrentMapCache(String name, ConcurrentMap<Object, Object> store, boolean allowNullValues) {\n\t\tthis(name, store, allowNullValues, null);\n\t}\n\n\t/**\n\t * Create a new ConcurrentMapCache with the specified name and the\n\t * given internal {@link ConcurrentMap} to use. If the\n\t * {@link SerializationDelegate} is specified,\n\t * {@link #isStoreByValue() store-by-value} is enabled\n\t * @param name the name of the cache\n\t * @param store the ConcurrentMap to use as an internal store\n\t * @param allowNullValues whether to allow {@code null} values\n\t * (adapting them to an internal null holder value)\n\t * @param serialization the {@link SerializationDelegate} to use\n\t * to serialize cache entry or {@code null} to store the reference\n\t * @since 4.3\n\t */\n\tprotected ConcurrentMapCache(String name, ConcurrentMap<Object, Object> store,\n\t\t\tboolean allowNullValues, @Nullable SerializationDelegate serialization) {\n\n\t\tsuper(allowNullValues);\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tAssert.notNull(store, \"Store must not be null\");\n\t\tthis.name = name;\n\t\tthis.store = store;\n\t\tthis.serialization = serialization;\n\t}\n\n\n\t/**\n\t * Return whether this cache stores a copy of each entry ({@code true}) or\n\t * a reference ({@code false}, default). If store by value is enabled, each\n\t * entry in the cache must be serializable.\n\t * @since 4.3\n\t */\n\tpublic final boolean isStoreByValue() {\n\t\treturn (this.serialization != null);\n\t}\n\n\t@Override\n\tpublic final String getName() {\n\t\treturn this.name;\n\t}\n\n\t@Override\n\tpublic final ConcurrentMap<Object, Object> getNativeCache() {\n\t\treturn this.store;\n\t}\n\n\t@Override\n\tprotected @Nullable Object lookup(Object key) {\n\t\treturn this.store.get(key);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T> @Nullable T get(Object key, Callable<T> valueLoader) {\n\t\treturn (T) fromStoreValue(this.store.computeIfAbsent(key, k -> {\n\t\t\ttry {\n\t\t\t\treturn toStoreValue(valueLoader.call());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new ValueRetrievalException(key, valueLoader, ex);\n\t\t\t}\n\t\t}));\n\t}\n\n\t@Override\n\tpublic @Nullable CompletableFuture<?> retrieve(Object key) {\n\t\tObject value = lookup(key);\n\t\treturn (value != null ? CompletableFuture.completedFuture(\n\t\t\t\tisAllowNullValues() ? toValueWrapper(value) : fromStoreValue(value)) : null);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\treturn CompletableFuture.supplyAsync(() ->\n\t\t\t\t(T) fromStoreValue(this.store.computeIfAbsent(key, k -> toStoreValue(valueLoader.get().join()))));\n\t}\n\n\t@Override\n\tpublic void put(Object key, @Nullable Object value) {\n\t\tthis.store.put(key, toStoreValue(value));\n\t}\n\n\t@Override\n\tpublic @Nullable ValueWrapper putIfAbsent(Object key, @Nullable Object value) {\n\t\tObject existing = this.store.putIfAbsent(key, toStoreValue(value));\n\t\treturn toValueWrapper(existing);\n\t}\n\n\t@Override\n\tpublic void evict(Object key) {\n\t\tthis.store.remove(key);\n\t}\n\n\t@Override\n\tpublic boolean evictIfPresent(Object key) {\n\t\treturn (this.store.remove(key) != null);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tthis.store.clear();\n\t}\n\n\t@Override\n\tpublic boolean invalidate() {\n\t\tboolean notEmpty = !this.store.isEmpty();\n\t\tthis.store.clear();\n\t\treturn notEmpty;\n\t}\n\n\t@Override\n\tprotected Object toStoreValue(@Nullable Object userValue) {\n\t\tObject storeValue = super.toStoreValue(userValue);\n\t\tif (this.serialization != null) {\n\t\t\ttry {\n\t\t\t\treturn this.serialization.serializeToByteArray(storeValue);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalArgumentException(\"Failed to serialize cache value '\" + userValue +\n\t\t\t\t\t\t\"'. Does it implement Serializable?\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn storeValue;\n\t\t}\n\t}\n\n\t@Override\n\tprotected @Nullable Object fromStoreValue(@Nullable Object storeValue) {\n\t\tif (storeValue != null && this.serialization != null) {\n\t\t\ttry {\n\t\t\t\treturn super.fromStoreValue(this.serialization.deserializeFromByteArray((byte[]) storeValue));\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalArgumentException(\"Failed to deserialize cache value '\" + storeValue + \"'\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn super.fromStoreValue(storeValue);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.cache.concurrent.ConcurrentMapCache#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tthis.store.clear();\n\t}"
  },
  "org.springframework.cache.concurrent.ConcurrentMapCache#evict(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void evict(Object key)",
    "source_code": "\tpublic void evict(Object key) {\n\t\tthis.store.remove(key);\n\t}"
  },
  "org.springframework.cache.concurrent.ConcurrentMapCache#evictIfPresent(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "boolean",
    "signature": "public boolean evictIfPresent(Object key)",
    "source_code": "\tpublic boolean evictIfPresent(Object key) {\n\t\treturn (this.store.remove(key) != null);\n\t}"
  },
  "org.springframework.cache.concurrent.ConcurrentMapCache#fromStoreValue(storeValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "storeValue"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "Object",
    "signature": "protected Object fromStoreValue(@Nullable Object storeValue)",
    "source_code": "\tprotected @Nullable Object fromStoreValue(@Nullable Object storeValue) {\n\t\tif (storeValue != null && this.serialization != null) {\n\t\t\ttry {\n\t\t\t\treturn super.fromStoreValue(this.serialization.deserializeFromByteArray((byte[]) storeValue));\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalArgumentException(\"Failed to deserialize cache value '\" + storeValue + \"'\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn super.fromStoreValue(storeValue);\n\t\t}\n\t}"
  },
  "org.springframework.cache.concurrent.ConcurrentMapCache#get(key,valueLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "T",
    "signature": "public T get(Object key, Callable<T> valueLoader)",
    "source_code": "\tpublic <T> @Nullable T get(Object key, Callable<T> valueLoader) {\n\t\treturn (T) fromStoreValue(this.store.computeIfAbsent(key, k -> {\n\t\t\ttry {\n\t\t\t\treturn toStoreValue(valueLoader.call());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new ValueRetrievalException(key, valueLoader, ex);\n\t\t\t}\n\t\t}));\n\t}"
  },
  "org.springframework.cache.concurrent.ConcurrentMapCache#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "\tpublic final String getName() {\n\t\treturn this.name;\n\t}"
  },
  "org.springframework.cache.concurrent.ConcurrentMapCache#getNativeCache()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "Object>",
    "signature": "public Object> getNativeCache()",
    "source_code": "\tpublic final ConcurrentMap<Object, Object> getNativeCache() {\n\t\treturn this.store;\n\t}"
  },
  "org.springframework.cache.concurrent.ConcurrentMapCache#invalidate()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "boolean",
    "signature": "public boolean invalidate()",
    "source_code": "\tpublic boolean invalidate() {\n\t\tboolean notEmpty = !this.store.isEmpty();\n\t\tthis.store.clear();\n\t\treturn notEmpty;\n\t}"
  },
  "org.springframework.cache.concurrent.ConcurrentMapCache#isStoreByValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this cache stores a copy of each entry ({@code true}) or\n\t * a reference ({@code false}, default). If store by value is enabled, each\n\t * entry in the cache must be serializable.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "boolean",
    "signature": "public boolean isStoreByValue()",
    "source_code": "\tpublic final boolean isStoreByValue() {\n\t\treturn (this.serialization != null);\n\t}"
  },
  "org.springframework.cache.concurrent.ConcurrentMapCache#lookup(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "Object",
    "signature": "protected Object lookup(Object key)",
    "source_code": "\tprotected @Nullable Object lookup(Object key) {\n\t\treturn this.store.get(key);\n\t}"
  },
  "org.springframework.cache.concurrent.ConcurrentMapCache#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "void",
    "signature": "public void put(Object key, @Nullable Object value)",
    "source_code": "\tpublic void put(Object key, @Nullable Object value) {\n\t\tthis.store.put(key, toStoreValue(value));\n\t}"
  },
  "org.springframework.cache.concurrent.ConcurrentMapCache#putIfAbsent(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "ValueWrapper",
    "signature": "public ValueWrapper putIfAbsent(Object key, @Nullable Object value)",
    "source_code": "\tpublic @Nullable ValueWrapper putIfAbsent(Object key, @Nullable Object value) {\n\t\tObject existing = this.store.putIfAbsent(key, toStoreValue(value));\n\t\treturn toValueWrapper(existing);\n\t}"
  },
  "org.springframework.cache.concurrent.ConcurrentMapCache#retrieve(key,valueLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "CompletableFuture<T>",
    "signature": "public CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader)",
    "source_code": "\tpublic <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\treturn CompletableFuture.supplyAsync(() ->\n\t\t\t\t(T) fromStoreValue(this.store.computeIfAbsent(key, k -> toStoreValue(valueLoader.get().join()))));\n\t}"
  },
  "org.springframework.cache.concurrent.ConcurrentMapCache#toStoreValue(userValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "userValue"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "Object",
    "signature": "protected Object toStoreValue(@Nullable Object userValue)",
    "source_code": "\tprotected Object toStoreValue(@Nullable Object userValue) {\n\t\tObject storeValue = super.toStoreValue(userValue);\n\t\tif (this.serialization != null) {\n\t\t\ttry {\n\t\t\t\treturn this.serialization.serializeToByteArray(storeValue);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalArgumentException(\"Failed to serialize cache value '\" + userValue +\n\t\t\t\t\t\t\"'. Does it implement Serializable?\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn storeValue;\n\t\t}\n\t}"
  },
  "org.springframework.cache.config.<unknown>#doParse(element,parserContext,builder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "parserContext",
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)",
    "source_code": "\tprotected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {\n\t\tbuilder.addPropertyReference(\"cacheManager\", CacheNamespaceHandler.extractCacheManager(element));\n\t\tCacheNamespaceHandler.parseKeyGenerator(element, builder.getBeanDefinition());\n\n\t\tList<Element> cacheDefs = DomUtils.getChildElementsByTagName(element, DEFS_ELEMENT);\n\t\tif (!cacheDefs.isEmpty()) {\n\t\t\t// Using attributes source.\n\t\t\tList<RootBeanDefinition> attributeSourceDefinitions = parseDefinitionsSources(cacheDefs, parserContext);\n\t\t\tbuilder.addPropertyValue(\"cacheOperationSources\", attributeSourceDefinitions);\n\t\t}\n\t\telse {\n\t\t\t// Assume annotations source.\n\t\t\tbuilder.addPropertyValue(\"cacheOperationSources\",\n\t\t\t\t\tnew RootBeanDefinition(\"org.springframework.cache.annotation.AnnotationCacheOperationSource\"));\n\t\t}\n\t}"
  },
  "org.springframework.cache.interceptor.AbstractCacheInvoker": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A base component for invoking {@link Cache} operations and using a\n * configurable {@link CacheErrorHandler} when an exception occurs.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @author Simon Basl\u00e9\n * @since 4.1\n * @see org.springframework.cache.interceptor.CacheErrorHandler\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class AbstractCacheInvoker",
    "source_code": "public abstract class AbstractCacheInvoker {\n\n\tprotected SingletonSupplier<CacheErrorHandler> errorHandler;\n\n\n\tprotected AbstractCacheInvoker() {\n\t\tthis.errorHandler = SingletonSupplier.of(SimpleCacheErrorHandler::new);\n\t}\n\n\tprotected AbstractCacheInvoker(CacheErrorHandler errorHandler) {\n\t\tthis.errorHandler = SingletonSupplier.of(errorHandler);\n\t}\n\n\n\t/**\n\t * Set the {@link CacheErrorHandler} instance to use to handle errors\n\t * thrown by the cache provider. By default, a {@link SimpleCacheErrorHandler}\n\t * is used who throws any exception as is.\n\t */\n\tpublic void setErrorHandler(CacheErrorHandler errorHandler) {\n\t\tthis.errorHandler = SingletonSupplier.of(errorHandler);\n\t}\n\n\t/**\n\t * Return the {@link CacheErrorHandler} to use.\n\t */\n\tpublic CacheErrorHandler getErrorHandler() {\n\t\treturn this.errorHandler.obtain();\n\t}\n\n\n\t/**\n\t * Execute {@link Cache#get(Object)} on the specified {@link Cache} and\n\t * invoke the error handler if an exception occurs. Return {@code null}\n\t * if the handler does not throw any exception, which simulates a cache\n\t * miss in case of error.\n\t * @see Cache#get(Object)\n\t */\n\tprotected Cache.@Nullable ValueWrapper doGet(Cache cache, Object key) {\n\t\ttry {\n\t\t\treturn cache.get(key);\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tgetErrorHandler().handleCacheGetError(ex, cache, key);\n\t\t\treturn null;  // If the exception is handled, return a cache miss\n\t\t}\n\t}\n\n\t/**\n\t * Execute {@link Cache#get(Object, Callable)} on the specified\n\t * {@link Cache} and invoke the error handler if an exception occurs.\n\t * Invokes the {@code valueLoader} if the handler does not throw any\n\t * exception, which simulates a cache read-through in case of error.\n\t * @since 6.2\n\t * @see Cache#get(Object, Callable)\n\t */\n\tprotected <T> @Nullable T doGet(Cache cache, Object key, Callable<T> valueLoader) {\n\t\ttry {\n\t\t\treturn cache.get(key, valueLoader);\n\t\t}\n\t\tcatch (Cache.ValueRetrievalException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tgetErrorHandler().handleCacheGetError(ex, cache, key);\n\t\t\ttry {\n\t\t\t\treturn valueLoader.call();\n\t\t\t}\n\t\t\tcatch (Exception ex2) {\n\t\t\t\tthrow new RuntimeException(ex2);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Execute {@link Cache#retrieve(Object)} on the specified {@link Cache}\n\t * and invoke the error handler if an exception occurs.\n\t * Returns {@code null} if the handler does not throw any exception, which\n\t * simulates a cache miss in case of error.\n\t * @since 6.2\n\t * @see Cache#retrieve(Object)\n\t */\n\tprotected @Nullable CompletableFuture<?> doRetrieve(Cache cache, Object key) {\n\t\ttry {\n\t\t\treturn cache.retrieve(key);\n\t\t}\n\t\tcatch (Cache.ValueRetrievalException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tgetErrorHandler().handleCacheGetError(ex, cache, key);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * Execute {@link Cache#retrieve(Object, Supplier)} on the specified\n\t * {@link Cache} and invoke the error handler if an exception occurs.\n\t * Invokes the {@code valueLoader} if the handler does not throw any\n\t * exception, which simulates a cache read-through in case of error.\n\t * @since 6.2\n\t * @see Cache#retrieve(Object, Supplier)\n\t */\n\tprotected <T> CompletableFuture<T> doRetrieve(Cache cache, Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\ttry {\n\t\t\treturn cache.retrieve(key, valueLoader);\n\t\t}\n\t\tcatch (Cache.ValueRetrievalException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tgetErrorHandler().handleCacheGetError(ex, cache, key);\n\t\t\treturn valueLoader.get();\n\t\t}\n\t}\n\n\t/**\n\t * Execute {@link Cache#put(Object, Object)} on the specified {@link Cache}\n\t * and invoke the error handler if an exception occurs.\n\t */\n\tprotected void doPut(Cache cache, Object key, @Nullable Object value) {\n\t\ttry {\n\t\t\tcache.put(key, value);\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tgetErrorHandler().handleCachePutError(ex, cache, key, value);\n\t\t}\n\t}\n\n\t/**\n\t * Execute {@link Cache#evict(Object)}/{@link Cache#evictIfPresent(Object)} on the\n\t * specified {@link Cache} and invoke the error handler if an exception occurs.\n\t */\n\tprotected void doEvict(Cache cache, Object key, boolean immediate) {\n\t\ttry {\n\t\t\tif (immediate) {\n\t\t\t\tcache.evictIfPresent(key);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcache.evict(key);\n\t\t\t}\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tgetErrorHandler().handleCacheEvictError(ex, cache, key);\n\t\t}\n\t}\n\n\t/**\n\t * Execute {@link Cache#clear()} on the specified {@link Cache} and\n\t * invoke the error handler if an exception occurs.\n\t */\n\tprotected void doClear(Cache cache, boolean immediate) {\n\t\ttry {\n\t\t\tif (immediate) {\n\t\t\t\tcache.invalidate();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcache.clear();\n\t\t\t}\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tgetErrorHandler().handleCacheClearError(ex, cache);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.cache.interceptor.AbstractCacheInvoker#doClear(cache,immediate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute {@link Cache#clear()} on the specified {@link Cache} and\n\t * invoke the error handler if an exception occurs.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cache",
      "immediate"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "void",
    "signature": "protected void doClear(Cache cache, boolean immediate)",
    "source_code": "\tprotected void doClear(Cache cache, boolean immediate) {\n\t\ttry {\n\t\t\tif (immediate) {\n\t\t\t\tcache.invalidate();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcache.clear();\n\t\t\t}\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tgetErrorHandler().handleCacheClearError(ex, cache);\n\t\t}\n\t}"
  },
  "org.springframework.cache.interceptor.AbstractCacheInvoker#doEvict(cache,key,immediate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute {@link Cache#evict(Object)}/{@link Cache#evictIfPresent(Object)} on the\n\t * specified {@link Cache} and invoke the error handler if an exception occurs.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cache",
      "key",
      "immediate"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "protected void doEvict(Cache cache, Object key, boolean immediate)",
    "source_code": "\tprotected void doEvict(Cache cache, Object key, boolean immediate) {\n\t\ttry {\n\t\t\tif (immediate) {\n\t\t\t\tcache.evictIfPresent(key);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcache.evict(key);\n\t\t\t}\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tgetErrorHandler().handleCacheEvictError(ex, cache, key);\n\t\t}\n\t}"
  },
  "org.springframework.cache.interceptor.AbstractCacheInvoker#doGet(cache,key,valueLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute {@link Cache#get(Object, Callable)} on the specified\n\t * {@link Cache} and invoke the error handler if an exception occurs.\n\t * Invokes the {@code valueLoader} if the handler does not throw any\n\t * exception, which simulates a cache read-through in case of error.\n\t * @since 6.2\n\t * @see Cache#get(Object, Callable)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cache",
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "T",
    "signature": "protected T doGet(Cache cache, Object key, Callable<T> valueLoader)",
    "source_code": "\tprotected <T> @Nullable T doGet(Cache cache, Object key, Callable<T> valueLoader) {\n\t\ttry {\n\t\t\treturn cache.get(key, valueLoader);\n\t\t}\n\t\tcatch (Cache.ValueRetrievalException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tgetErrorHandler().handleCacheGetError(ex, cache, key);\n\t\t\ttry {\n\t\t\t\treturn valueLoader.call();\n\t\t\t}\n\t\t\tcatch (Exception ex2) {\n\t\t\t\tthrow new RuntimeException(ex2);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.cache.interceptor.AbstractCacheInvoker#doPut(cache,key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute {@link Cache#put(Object, Object)} on the specified {@link Cache}\n\t * and invoke the error handler if an exception occurs.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cache",
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "protected void doPut(Cache cache, Object key, @Nullable Object value)",
    "source_code": "\tprotected void doPut(Cache cache, Object key, @Nullable Object value) {\n\t\ttry {\n\t\t\tcache.put(key, value);\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tgetErrorHandler().handleCachePutError(ex, cache, key, value);\n\t\t}\n\t}"
  },
  "org.springframework.cache.interceptor.AbstractCacheInvoker#doRetrieve(cache,key,valueLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute {@link Cache#retrieve(Object, Supplier)} on the specified\n\t * {@link Cache} and invoke the error handler if an exception occurs.\n\t * Invokes the {@code valueLoader} if the handler does not throw any\n\t * exception, which simulates a cache read-through in case of error.\n\t * @since 6.2\n\t * @see Cache#retrieve(Object, Supplier)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cache",
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "CompletableFuture<T>",
    "signature": "protected CompletableFuture<T> doRetrieve(Cache cache, Object key, Supplier<CompletableFuture<T>> valueLoader)",
    "source_code": "\tprotected <T> CompletableFuture<T> doRetrieve(Cache cache, Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\ttry {\n\t\t\treturn cache.retrieve(key, valueLoader);\n\t\t}\n\t\tcatch (Cache.ValueRetrievalException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tgetErrorHandler().handleCacheGetError(ex, cache, key);\n\t\t\treturn valueLoader.get();\n\t\t}\n\t}"
  },
  "org.springframework.cache.interceptor.AbstractCacheInvoker#getErrorHandler()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link CacheErrorHandler} to use.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "CacheErrorHandler",
    "signature": "public CacheErrorHandler getErrorHandler()",
    "source_code": "\tpublic CacheErrorHandler getErrorHandler() {\n\t\treturn this.errorHandler.obtain();\n\t}"
  },
  "org.springframework.cache.interceptor.AbstractCacheInvoker#setErrorHandler(errorHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link CacheErrorHandler} instance to use to handle errors\n\t * thrown by the cache provider. By default, a {@link SimpleCacheErrorHandler}\n\t * is used who throws any exception as is.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "void",
    "signature": "public void setErrorHandler(CacheErrorHandler errorHandler)",
    "source_code": "\tpublic void setErrorHandler(CacheErrorHandler errorHandler) {\n\t\tthis.errorHandler = SingletonSupplier.of(errorHandler);\n\t}"
  },
  "org.springframework.cache.interceptor.errorHandler": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "protected SingletonSupplier<CacheErrorHandler> errorHandler",
    "source_code": "\tprotected SingletonSupplier<CacheErrorHandler> errorHandler;",
    "type": "SingletonSupplier<CacheErrorHandler>"
  },
  "org.springframework.cache.jcache.JCacheCache": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link org.springframework.cache.Cache} implementation on top of a\n * {@link Cache javax.cache.Cache} instance.\n *\n * <p>Note: This class has been updated for JCache 1.0, as of Spring 4.0.\n *\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @since 3.2\n * @see JCacheCacheManager\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class JCacheCache",
    "source_code": "public class JCacheCache extends AbstractValueAdaptingCache {\n\n\tprivate final Cache<Object, Object> cache;\n\n\tprivate final ValueLoaderEntryProcessor valueLoaderEntryProcessor;\n\n\n\t/**\n\t * Create a {@code JCacheCache} instance.\n\t * @param jcache backing JCache Cache instance\n\t */\n\tpublic JCacheCache(Cache<Object, Object> jcache) {\n\t\tthis(jcache, true);\n\t}\n\n\t/**\n\t * Create a {@code JCacheCache} instance.\n\t * @param jcache backing JCache Cache instance\n\t * @param allowNullValues whether to accept and convert null values for this cache\n\t */\n\tpublic JCacheCache(Cache<Object, Object> jcache, boolean allowNullValues) {\n\t\tsuper(allowNullValues);\n\t\tAssert.notNull(jcache, \"Cache must not be null\");\n\t\tthis.cache = jcache;\n\t\tthis.valueLoaderEntryProcessor = new ValueLoaderEntryProcessor(\n\t\t\t\tthis::fromStoreValue, this::toStoreValue);\n\t}\n\n\n\t@Override\n\tpublic final String getName() {\n\t\treturn this.cache.getName();\n\t}\n\n\t@Override\n\tpublic final Cache<Object, Object> getNativeCache() {\n\t\treturn this.cache;\n\t}\n\n\t@Override\n\tprotected @Nullable Object lookup(Object key) {\n\t\treturn this.cache.get(key);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> @Nullable T get(Object key, Callable<T> valueLoader) {\n\t\ttry {\n\t\t\treturn (T) this.cache.invoke(key, this.valueLoaderEntryProcessor, valueLoader);\n\t\t}\n\t\tcatch (EntryProcessorException ex) {\n\t\t\tthrow new ValueRetrievalException(key, valueLoader, ex.getCause());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void put(Object key, @Nullable Object value) {\n\t\tthis.cache.put(key, toStoreValue(value));\n\t}\n\n\t@Override\n\tpublic @Nullable ValueWrapper putIfAbsent(Object key, @Nullable Object value) {\n\t\tObject previous = this.cache.invoke(key, PutIfAbsentEntryProcessor.INSTANCE, toStoreValue(value));\n\t\treturn (previous != null ? toValueWrapper(previous) : null);\n\t}\n\n\t@Override\n\tpublic void evict(Object key) {\n\t\tthis.cache.remove(key);\n\t}\n\n\t@Override\n\tpublic boolean evictIfPresent(Object key) {\n\t\treturn this.cache.remove(key);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tthis.cache.removeAll();\n\t}\n\n\t@Override\n\tpublic boolean invalidate() {\n\t\tboolean notEmpty = this.cache.iterator().hasNext();\n\t\tthis.cache.removeAll();\n\t\treturn notEmpty;\n\t}\n\n\n\tprivate static class PutIfAbsentEntryProcessor implements EntryProcessor<Object, Object, Object> {\n\n\t\tprivate static final PutIfAbsentEntryProcessor INSTANCE = new PutIfAbsentEntryProcessor();\n\n\t\t@Override\n\t\t@SuppressWarnings(\"NullAway\") // Overridden method does not define nullness\n\t\tpublic @Nullable Object process(MutableEntry<Object, @Nullable Object> entry, @Nullable Object... arguments) throws EntryProcessorException {\n\t\t\tObject existingValue = entry.getValue();\n\t\t\tif (existingValue == null) {\n\t\t\t\tentry.setValue(arguments[0]);\n\t\t\t}\n\t\t\treturn existingValue;\n\t\t}\n\t}\n\n\n\tprivate static final class ValueLoaderEntryProcessor implements EntryProcessor<Object, Object, Object> {\n\n\t\tprivate final Function<Object, @Nullable Object> fromStoreValue;\n\n\t\tprivate final Function<Object, Object> toStoreValue;\n\n\t\tprivate ValueLoaderEntryProcessor(Function<Object, @Nullable Object> fromStoreValue,\n\t\t\t\tFunction<Object, Object> toStoreValue) {\n\n\t\t\tthis.fromStoreValue = fromStoreValue;\n\t\t\tthis.toStoreValue = toStoreValue;\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings({\"unchecked\",\"NullAway\"}) // Overridden method does not define nullness\n\t\tpublic @Nullable Object process(MutableEntry<Object, @Nullable Object> entry, @Nullable Object... arguments) throws EntryProcessorException {\n\t\t\tCallable<Object> valueLoader = (Callable<Object>) arguments[0];\n\t\t\tif (entry.exists()) {\n\t\t\t\treturn this.fromStoreValue.apply(Objects.requireNonNull(entry.getValue()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject value;\n\t\t\t\ttry {\n\t\t\t\t\tvalue = Objects.requireNonNull(valueLoader).call();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new EntryProcessorException(\"Value loader '\" + valueLoader + \"' failed \" +\n\t\t\t\t\t\t\t\"to compute value for key '\" + entry.getKey() + \"'\", ex);\n\t\t\t\t}\n\t\t\t\tentry.setValue(this.toStoreValue.apply(value));\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.cache.jcache.JCacheCache#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tthis.cache.removeAll();\n\t}"
  },
  "org.springframework.cache.jcache.JCacheCache#evict(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void evict(Object key)",
    "source_code": "\tpublic void evict(Object key) {\n\t\tthis.cache.remove(key);\n\t}"
  },
  "org.springframework.cache.jcache.JCacheCache#evictIfPresent(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "boolean",
    "signature": "public boolean evictIfPresent(Object key)",
    "source_code": "\tpublic boolean evictIfPresent(Object key) {\n\t\treturn this.cache.remove(key);\n\t}"
  },
  "org.springframework.cache.jcache.JCacheCache#get(key,valueLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "T",
    "signature": "public T get(Object key, Callable<T> valueLoader)",
    "source_code": "\tpublic <T> @Nullable T get(Object key, Callable<T> valueLoader) {\n\t\ttry {\n\t\t\treturn (T) this.cache.invoke(key, this.valueLoaderEntryProcessor, valueLoader);\n\t\t}\n\t\tcatch (EntryProcessorException ex) {\n\t\t\tthrow new ValueRetrievalException(key, valueLoader, ex.getCause());\n\t\t}\n\t}"
  },
  "org.springframework.cache.jcache.JCacheCache#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "\tpublic final String getName() {\n\t\treturn this.cache.getName();\n\t}"
  },
  "org.springframework.cache.jcache.JCacheCache#getNativeCache()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "Object>",
    "signature": "public Object> getNativeCache()",
    "source_code": "\tpublic final Cache<Object, Object> getNativeCache() {\n\t\treturn this.cache;\n\t}"
  },
  "org.springframework.cache.jcache.JCacheCache#invalidate()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "boolean",
    "signature": "public boolean invalidate()",
    "source_code": "\tpublic boolean invalidate() {\n\t\tboolean notEmpty = this.cache.iterator().hasNext();\n\t\tthis.cache.removeAll();\n\t\treturn notEmpty;\n\t}"
  },
  "org.springframework.cache.jcache.JCacheCache#lookup(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "Object",
    "signature": "protected Object lookup(Object key)",
    "source_code": "\tprotected @Nullable Object lookup(Object key) {\n\t\treturn this.cache.get(key);\n\t}"
  },
  "org.springframework.cache.jcache.JCacheCache#process(MutableEntry<Object,entry,arguments)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MutableEntry<Object",
      "entry",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "Object",
    "signature": "public Object process(MutableEntry<Object, @Nullable Object> entry, @Nullable Object... arguments)",
    "source_code": "\t\tpublic @Nullable Object process(MutableEntry<Object, @Nullable Object> entry, @Nullable Object... arguments) throws EntryProcessorException {\n\t\t\tCallable<Object> valueLoader = (Callable<Object>) arguments[0];\n\t\t\tif (entry.exists()) {\n\t\t\t\treturn this.fromStoreValue.apply(Objects.requireNonNull(entry.getValue()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject value;\n\t\t\t\ttry {\n\t\t\t\t\tvalue = Objects.requireNonNull(valueLoader).call();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new EntryProcessorException(\"Value loader '\" + valueLoader + \"' failed \" +\n\t\t\t\t\t\t\t\"to compute value for key '\" + entry.getKey() + \"'\", ex);\n\t\t\t\t}\n\t\t\t\tentry.setValue(this.toStoreValue.apply(value));\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.cache.jcache.JCacheCache#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void put(Object key, @Nullable Object value)",
    "source_code": "\tpublic void put(Object key, @Nullable Object value) {\n\t\tthis.cache.put(key, toStoreValue(value));\n\t}"
  },
  "org.springframework.cache.jcache.JCacheCache#putIfAbsent(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "ValueWrapper",
    "signature": "public ValueWrapper putIfAbsent(Object key, @Nullable Object value)",
    "source_code": "\tpublic @Nullable ValueWrapper putIfAbsent(Object key, @Nullable Object value) {\n\t\tObject previous = this.cache.invoke(key, PutIfAbsentEntryProcessor.INSTANCE, toStoreValue(value));\n\t\treturn (previous != null ? toValueWrapper(previous) : null);\n\t}"
  },
  "org.springframework.cache.jcache.config.exceptionCacheResolver": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "protected Supplier<CacheResolver> exceptionCacheResolver",
    "source_code": "\tprotected Supplier<CacheResolver> exceptionCacheResolver;",
    "type": "Supplier<CacheResolver>"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#cacheException(exceptionCache,filter,cacheKey,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exceptionCache",
      "filter",
      "cacheKey",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "protected void cacheException(@Nullable Cache exceptionCache, ExceptionTypeFilter filter, Object cacheKey, Throwable ex)",
    "source_code": "\tprotected void cacheException(@Nullable Cache exceptionCache, ExceptionTypeFilter filter, Object cacheKey, Throwable ex) {\n\t\tif (exceptionCache == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (filter.match(ex.getClass())) {\n\t\t\tdoPut(exceptionCache, cacheKey, ex);\n\t\t}\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#checkForCachedException(exceptionCache,cacheKey)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check for a cached exception. If the exception is found, throw it directly.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exceptionCache",
      "cacheKey"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "protected void checkForCachedException(@Nullable Cache exceptionCache, Object cacheKey)",
    "source_code": "\tprotected void checkForCachedException(@Nullable Cache exceptionCache, Object cacheKey) {\n\t\tif (exceptionCache == null) {\n\t\t\treturn;\n\t\t}\n\t\tCache.ValueWrapper result = doGet(exceptionCache, cacheKey);\n\t\tif (result != null) {\n\t\t\tThrowable ex = (Throwable) result.get();\n\t\t\tAssert.state(ex != null, \"No exception in cache\");\n\t\t\tthrow rewriteCallStack(ex, getClass().getName(), \"invoke\");\n\t\t}\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#invoke(context,invoker)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context",
      "invoker"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "Object",
    "signature": "protected Object invoke(CacheOperationInvocationContext<CacheResultOperation> context, CacheOperationInvoker invoker)",
    "source_code": "\tprotected @Nullable Object invoke("
  },
  "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * The default {@link JCacheOperationSource} implementation delegating\n * default operations to configurable services with sensible defaults\n * when not present.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 4.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class DefaultJCacheOperationSource",
    "source_code": "public class DefaultJCacheOperationSource extends AnnotationJCacheOperationSource"
  },
  "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource#afterSingletonsInstantiated()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void afterSingletonsInstantiated()",
    "source_code": "\tpublic void afterSingletonsInstantiated() {\n\t\t// Make sure that the cache resolver is initialized. An exception cache resolver is only\n\t\t// required if the exceptionCacheName attribute is set on an operation.\n\t\tAssert.state(getDefaultCacheResolver() != null, \"Cache resolver should have been initialized\");\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource#getBean(type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "T",
    "signature": "protected T getBean(Class<T> type)",
    "source_code": "\tprotected <T> T getBean(Class<T> type) {\n\t\tAssert.state(this.beanFactory != null, () -> \"BeanFactory required for resolution of [\" + type + \"]\");\n\t\ttry {\n\t\t\treturn this.beanFactory.getBean(type);\n\t\t}\n\t\tcatch (NoUniqueBeanDefinitionException ex) {\n\t\t\tthrow new IllegalStateException(\"No unique [\" + type.getName() + \"] bean found in application context - \" +\n\t\t\t\t\t\"mark one as primary, or declare a more specific implementation type for your cache\", ex);\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"No bean of type [\" + type.getName() + \"] found in application context\", ex);\n\t\t\t}\n\t\t\treturn BeanUtils.instantiateClass(type);\n\t\t}\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource#getCacheManager()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the specified cache manager to use, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "CacheManager",
    "signature": "public CacheManager getCacheManager()",
    "source_code": "\tpublic @Nullable CacheManager getCacheManager() {\n\t\treturn SupplierUtils.resolve(this.cacheManager);\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource#getCacheResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the specified cache resolver to use, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "CacheResolver",
    "signature": "public CacheResolver getCacheResolver()",
    "source_code": "\tpublic @Nullable CacheResolver getCacheResolver() {\n\t\treturn SupplierUtils.resolve(this.cacheResolver);\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource#getDefaultCacheManager()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "CacheManager",
    "signature": "protected CacheManager getDefaultCacheManager()",
    "source_code": "\tprotected CacheManager getDefaultCacheManager() {\n\t\tif (getCacheManager() == null) {\n\t\t\tAssert.state(this.beanFactory != null, \"BeanFactory required for default CacheManager resolution\");\n\t\t\ttry {\n\t\t\t\tthis.cacheManager = SingletonSupplier.of(this.beanFactory.getBean(CacheManager.class));\n\t\t\t}\n\t\t\tcatch (NoUniqueBeanDefinitionException ex) {\n\t\t\t\tthrow new IllegalStateException(\"No unique bean of type CacheManager found. \"+\n\t\t\t\t\t\t\"Mark one as primary or declare a specific CacheManager to use.\");\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\tthrow new IllegalStateException(\"No bean of type CacheManager found. Register a CacheManager \"+\n\t\t\t\t\t\t\"bean or remove the @EnableCaching annotation from your configuration.\");\n\t\t\t}\n\t\t}\n\t\treturn getCacheManager();\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource#getDefaultCacheResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "CacheResolver",
    "signature": "protected CacheResolver getDefaultCacheResolver()",
    "source_code": "\tprotected CacheResolver getDefaultCacheResolver() {\n\t\tif (getCacheResolver() == null) {\n\t\t\tthis.cacheResolver = SingletonSupplier.of(new SimpleCacheResolver(getDefaultCacheManager()));\n\t\t}\n\t\treturn getCacheResolver();\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource#getDefaultExceptionCacheResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "CacheResolver",
    "signature": "protected CacheResolver getDefaultExceptionCacheResolver()",
    "source_code": "\tprotected CacheResolver getDefaultExceptionCacheResolver() {\n\t\tif (getExceptionCacheResolver() == null) {\n\t\t\tthis.exceptionCacheResolver = SingletonSupplier.of(new LazyCacheResolver());\n\t\t}\n\t\treturn getExceptionCacheResolver();\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource#getDefaultKeyGenerator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "KeyGenerator",
    "signature": "protected KeyGenerator getDefaultKeyGenerator()",
    "source_code": "\tprotected KeyGenerator getDefaultKeyGenerator() {\n\t\treturn this.adaptedKeyGenerator.obtain();\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource#getExceptionCacheResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the specified exception cache resolver to use, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "CacheResolver",
    "signature": "public CacheResolver getExceptionCacheResolver()",
    "source_code": "\tpublic @Nullable CacheResolver getExceptionCacheResolver() {\n\t\treturn SupplierUtils.resolve(this.exceptionCacheResolver);\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource#getKeyGenerator()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the specified key generator to use.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "KeyGenerator",
    "signature": "public KeyGenerator getKeyGenerator()",
    "source_code": "\tpublic KeyGenerator getKeyGenerator() {\n\t\treturn this.keyGenerator.obtain();\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource#setCacheManager(cacheManager)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the default {@link CacheManager} to use to lookup cache by name.\n\t * Only mandatory if the {@linkplain CacheResolver cache resolver} has not been set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheManager"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void setCacheManager(@Nullable CacheManager cacheManager)",
    "source_code": "\tpublic void setCacheManager(@Nullable CacheManager cacheManager) {\n\t\tthis.cacheManager = SingletonSupplier.ofNullable(cacheManager);\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource#setCacheResolver(cacheResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link CacheResolver} to resolve regular caches. If none is set, a default\n\t * implementation using the specified cache manager will be used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheResolver"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void setCacheResolver(@Nullable CacheResolver cacheResolver)",
    "source_code": "\tpublic void setCacheResolver(@Nullable CacheResolver cacheResolver) {\n\t\tthis.cacheResolver = SingletonSupplier.ofNullable(cacheResolver);\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource#setExceptionCacheResolver(exceptionCacheResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link CacheResolver} to resolve exception caches. If none is set, a default\n\t * implementation using the specified cache manager will be used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exceptionCacheResolver"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void setExceptionCacheResolver(@Nullable CacheResolver exceptionCacheResolver)",
    "source_code": "\tpublic void setExceptionCacheResolver(@Nullable CacheResolver exceptionCacheResolver) {\n\t\tthis.exceptionCacheResolver = SingletonSupplier.ofNullable(exceptionCacheResolver);\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource#setKeyGenerator(keyGenerator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the default {@link KeyGenerator}. If none is set, a {@link SimpleKeyGenerator}\n\t * honoring the JSR-107 {@link javax.cache.annotation.CacheKey} and\n\t * {@link javax.cache.annotation.CacheValue} will be used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "keyGenerator"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "void",
    "signature": "public void setKeyGenerator(KeyGenerator keyGenerator)",
    "source_code": "\tpublic void setKeyGenerator(KeyGenerator keyGenerator) {\n\t\tthis.keyGenerator = SingletonSupplier.of(keyGenerator);\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.JCacheInterceptor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * AOP Alliance MethodInterceptor for declarative cache\n * management using JSR-107 caching annotations.\n *\n * <p>Derives from the {@link JCacheAspectSupport} class which\n * contains the integration with Spring's underlying caching API.\n * JCacheInterceptor simply calls the relevant superclass method.\n *\n * <p>JCacheInterceptors are thread-safe.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 4.1\n * @see org.springframework.cache.interceptor.CacheInterceptor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class JCacheInterceptor",
    "source_code": "public class JCacheInterceptor extends JCacheAspectSupport implements MethodInterceptor, Serializable {\n\n\t/**\n\t * Construct a new {@code JCacheInterceptor} with the default error handler.\n\t */\n\tpublic JCacheInterceptor() {\n\t}\n\n\t/**\n\t * Construct a new {@code JCacheInterceptor} with the given error handler.\n\t * @param errorHandler a supplier for the error handler to use,\n\t * applying the default error handler if the supplier is not resolvable\n\t * @since 5.1\n\t */\n\tpublic JCacheInterceptor(@Nullable Supplier<? extends @Nullable CacheErrorHandler> errorHandler) {\n\t\tthis.errorHandler = new SingletonSupplier<>(errorHandler, SimpleCacheErrorHandler::new);\n\t}\n\n\n\t@Override\n\tpublic @Nullable Object invoke(final MethodInvocation invocation) throws Throwable {\n\t\tMethod method = invocation.getMethod();\n\n\t\tCacheOperationInvoker aopAllianceInvoker = () -> {\n\t\t\ttry {\n\t\t\t\treturn invocation.proceed();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new CacheOperationInvoker.ThrowableWrapper(ex);\n\t\t\t}\n\t\t};\n\n\t\tObject target = invocation.getThis();\n\t\tAssert.state(target != null, \"Target must not be null\");\n\t\ttry {\n\t\t\treturn execute(aopAllianceInvoker, target, method, invocation.getArguments());\n\t\t}\n\t\tcatch (CacheOperationInvoker.ThrowableWrapper th) {\n\t\t\tthrow th.getOriginal();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.cache.jcache.interceptor.JCacheInterceptor#invoke(invocation)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invocation"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "Object",
    "signature": "public Object invoke(final MethodInvocation invocation)",
    "source_code": "\tpublic @Nullable Object invoke(final MethodInvocation invocation) throws Throwable {\n\t\tMethod method = invocation.getMethod();\n\n\t\tCacheOperationInvoker aopAllianceInvoker = () -> {\n\t\t\ttry {\n\t\t\t\treturn invocation.proceed();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new CacheOperationInvoker.ThrowableWrapper(ex);\n\t\t\t}\n\t\t};\n\n\t\tObject target = invocation.getThis();\n\t\tAssert.state(target != null, \"Target must not be null\");\n\t\ttry {\n\t\t\treturn execute(aopAllianceInvoker, target, method, invocation.getArguments());\n\t\t}\n\t\tcatch (CacheOperationInvoker.ThrowableWrapper th) {\n\t\t\tthrow th.getOriginal();\n\t\t}\n\t}"
  },
  "org.springframework.cache.support.AbstractValueAdaptingCache": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Common base class for {@link Cache} implementations that need to adapt\n * {@code null} values (and potentially other such special values) before\n * passing them on to the underlying store.\n *\n * <p>Transparently replaces given {@code null} user values with an internal\n * {@link NullValue#INSTANCE}, if configured to support {@code null} values\n * (as indicated by {@link #isAllowNullValues()}).\n *\n * @author Juergen Hoeller\n * @since 4.2.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class AbstractValueAdaptingCache",
    "source_code": "public abstract class AbstractValueAdaptingCache implements Cache {\n\n\tprivate final boolean allowNullValues;\n\n\n\t/**\n\t * Create an {@code AbstractValueAdaptingCache} with the given setting.\n\t * @param allowNullValues whether to allow for {@code null} values\n\t */\n\tprotected AbstractValueAdaptingCache(boolean allowNullValues) {\n\t\tthis.allowNullValues = allowNullValues;\n\t}\n\n\n\t/**\n\t * Return whether {@code null} values are allowed in this cache.\n\t */\n\tpublic final boolean isAllowNullValues() {\n\t\treturn this.allowNullValues;\n\t}\n\n\t@Override\n\tpublic @Nullable ValueWrapper get(Object key) {\n\t\treturn toValueWrapper(lookup(key));\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> @Nullable T get(Object key, @Nullable Class<T> type) {\n\t\tObject value = fromStoreValue(lookup(key));\n\t\tif (value != null && type != null && !type.isInstance(value)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Cached value is not of required type [\" + type.getName() + \"]: \" + value);\n\t\t}\n\t\treturn (T) value;\n\t}\n\n\t/**\n\t * Perform an actual lookup in the underlying store.\n\t * @param key the key whose associated value is to be returned\n\t * @return the raw store value for the key, or {@code null} if none\n\t */\n\tprotected abstract @Nullable Object lookup(Object key);\n\n\n\t/**\n\t * Convert the given value from the internal store to a user value\n\t * returned from the get method (adapting {@code null}).\n\t * @param storeValue the store value\n\t * @return the value to return to the user\n\t */\n\tprotected @Nullable Object fromStoreValue(@Nullable Object storeValue) {\n\t\tif (this.allowNullValues && storeValue == NullValue.INSTANCE) {\n\t\t\treturn null;\n\t\t}\n\t\treturn storeValue;\n\t}\n\n\t/**\n\t * Convert the given user value, as passed into the put method,\n\t * to a value in the internal store (adapting {@code null}).\n\t * @param userValue the given user value\n\t * @return the value to store\n\t */\n\tprotected Object toStoreValue(@Nullable Object userValue) {\n\t\tif (userValue == null) {\n\t\t\tif (this.allowNullValues) {\n\t\t\t\treturn NullValue.INSTANCE;\n\t\t\t}\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Cache '\" + getName() + \"' is configured to not allow null values but null was provided\");\n\t\t}\n\t\treturn userValue;\n\t}\n\n\t/**\n\t * Wrap the given store value with a {@link SimpleValueWrapper}, also going\n\t * through {@link #fromStoreValue} conversion. Useful for {@link #get(Object)}\n\t * and {@link #putIfAbsent(Object, Object)} implementations.\n\t * @param storeValue the original value\n\t * @return the wrapped value\n\t */\n\tprotected Cache.@Nullable ValueWrapper toValueWrapper(@Nullable Object storeValue) {\n\t\treturn (storeValue != null ? new SimpleValueWrapper(fromStoreValue(storeValue)) : null);\n\t}\n\n}"
  },
  "org.springframework.cache.support.AbstractValueAdaptingCache#fromStoreValue(storeValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given value from the internal store to a user value\n\t * returned from the get method (adapting {@code null}).\n\t * @param storeValue the store value\n\t * @return the value to return to the user\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "storeValue"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "Object",
    "signature": "protected Object fromStoreValue(@Nullable Object storeValue)",
    "source_code": "\tprotected @Nullable Object fromStoreValue(@Nullable Object storeValue) {\n\t\tif (this.allowNullValues && storeValue == NullValue.INSTANCE) {\n\t\t\treturn null;\n\t\t}\n\t\treturn storeValue;\n\t}"
  },
  "org.springframework.cache.support.AbstractValueAdaptingCache#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "ValueWrapper",
    "signature": "public ValueWrapper get(Object key)",
    "source_code": "\tpublic @Nullable ValueWrapper get(Object key) {\n\t\treturn toValueWrapper(lookup(key));\n\t}"
  },
  "org.springframework.cache.support.AbstractValueAdaptingCache#get(key,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "T",
    "signature": "public T get(Object key, @Nullable Class<T> type)",
    "source_code": "\tpublic <T> @Nullable T get(Object key, @Nullable Class<T> type) {\n\t\tObject value = fromStoreValue(lookup(key));\n\t\tif (value != null && type != null && !type.isInstance(value)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Cached value is not of required type [\" + type.getName() + \"]: \" + value);\n\t\t}\n\t\treturn (T) value;\n\t}"
  },
  "org.springframework.cache.support.AbstractValueAdaptingCache#isAllowNullValues()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether {@code null} values are allowed in this cache.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "boolean",
    "signature": "public boolean isAllowNullValues()",
    "source_code": "\tpublic final boolean isAllowNullValues() {\n\t\treturn this.allowNullValues;\n\t}"
  },
  "org.springframework.cache.support.AbstractValueAdaptingCache#lookup(key)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform an actual lookup in the underlying store.\n\t * @param key the key whose associated value is to be returned\n\t * @return the raw store value for the key, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "Object",
    "signature": "protected Object lookup(Object key)",
    "source_code": "\tprotected abstract @Nullable Object lookup(Object key);"
  },
  "org.springframework.cache.support.AbstractValueAdaptingCache#toStoreValue(userValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given user value, as passed into the put method,\n\t * to a value in the internal store (adapting {@code null}).\n\t * @param userValue the given user value\n\t * @return the value to store\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "userValue"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "Object",
    "signature": "protected Object toStoreValue(@Nullable Object userValue)",
    "source_code": "\tprotected Object toStoreValue(@Nullable Object userValue) {\n\t\tif (userValue == null) {\n\t\t\tif (this.allowNullValues) {\n\t\t\t\treturn NullValue.INSTANCE;\n\t\t\t}\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Cache '\" + getName() + \"' is configured to not allow null values but null was provided\");\n\t\t}\n\t\treturn userValue;\n\t}"
  },
  "org.springframework.cache.support.NoOpCache": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A no operation {@link Cache} implementation suitable for disabling caching.\n *\n * <p>Will simply accept any items into the cache not actually storing them.\n *\n * @author Costin Leau\n * @author Stephane Nicoll\n * @since 4.3.4\n * @see NoOpCacheManager\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class NoOpCache",
    "source_code": "public class NoOpCache implements Cache {\n\n\tprivate final String name;\n\n\n\t/**\n\t * Create a {@link NoOpCache} instance with the specified name.\n\t * @param name the name of the cache\n\t */\n\tpublic NoOpCache(String name) {\n\t\tAssert.notNull(name, \"Cache name must not be null\");\n\t\tthis.name = name;\n\t}\n\n\n\t@Override\n\tpublic String getName() {\n\t\treturn this.name;\n\t}\n\n\t@Override\n\tpublic Object getNativeCache() {\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic @Nullable ValueWrapper get(Object key) {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T get(Object key, @Nullable Class<T> type) {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T get(Object key, Callable<T> valueLoader) {\n\t\ttry {\n\t\t\treturn valueLoader.call();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new ValueRetrievalException(key, valueLoader, ex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic @Nullable CompletableFuture<?> retrieve(Object key) {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\treturn valueLoader.get();\n\t}\n\n\t@Override\n\tpublic void put(Object key, @Nullable Object value) {\n\t}\n\n\t@Override\n\tpublic @Nullable ValueWrapper putIfAbsent(Object key, @Nullable Object value) {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void evict(Object key) {\n\t}\n\n\t@Override\n\tpublic boolean evictIfPresent(Object key) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t}\n\n\t@Override\n\tpublic boolean invalidate() {\n\t\treturn false;\n\t}\n\n}"
  },
  "org.springframework.cache.support.NoOpCache#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t}"
  },
  "org.springframework.cache.support.NoOpCache#evict(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void evict(Object key)",
    "source_code": "\tpublic void evict(Object key) {\n\t}"
  },
  "org.springframework.cache.support.NoOpCache#evictIfPresent(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "boolean",
    "signature": "public boolean evictIfPresent(Object key)",
    "source_code": "\tpublic boolean evictIfPresent(Object key) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.cache.support.NoOpCache#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "ValueWrapper",
    "signature": "public ValueWrapper get(Object key)",
    "source_code": "\tpublic @Nullable ValueWrapper get(Object key) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.cache.support.NoOpCache#get(key,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "T",
    "signature": "public T get(Object key, @Nullable Class<T> type)",
    "source_code": "\tpublic <T> @Nullable T get(Object key, @Nullable Class<T> type) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.cache.support.NoOpCache#get(key,valueLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "T",
    "signature": "public T get(Object key, Callable<T> valueLoader)",
    "source_code": "\tpublic <T> @Nullable T get(Object key, Callable<T> valueLoader) {\n\t\ttry {\n\t\t\treturn valueLoader.call();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new ValueRetrievalException(key, valueLoader, ex);\n\t\t}\n\t}"
  },
  "org.springframework.cache.support.NoOpCache#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "\tpublic String getName() {\n\t\treturn this.name;\n\t}"
  },
  "org.springframework.cache.support.NoOpCache#getNativeCache()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "Object",
    "signature": "public Object getNativeCache()",
    "source_code": "\tpublic Object getNativeCache() {\n\t\treturn this;\n\t}"
  },
  "org.springframework.cache.support.NoOpCache#invalidate()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "boolean",
    "signature": "public boolean invalidate()",
    "source_code": "\tpublic boolean invalidate() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.cache.support.NoOpCache#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void put(Object key, @Nullable Object value)",
    "source_code": "\tpublic void put(Object key, @Nullable Object value) {\n\t}"
  },
  "org.springframework.cache.support.NoOpCache#putIfAbsent(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "ValueWrapper",
    "signature": "public ValueWrapper putIfAbsent(Object key, @Nullable Object value)",
    "source_code": "\tpublic @Nullable ValueWrapper putIfAbsent(Object key, @Nullable Object value) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.cache.support.NoOpCache#retrieve(key,valueLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "CompletableFuture<T>",
    "signature": "public CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader)",
    "source_code": "\tpublic <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\treturn valueLoader.get();\n\t}"
  },
  "org.springframework.cache.transaction.TransactionAwareCacheDecorator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Cache decorator which synchronizes its {@link #put}, {@link #evict} and\n * {@link #clear} operations with Spring-managed transactions (through Spring's\n * {@link TransactionSynchronizationManager}), performing the actual cache\n * put/evict/clear operation only in the after-commit phase of a successful\n * transaction. If no transaction is active, {@link #put}, {@link #evict} and\n * {@link #clear} operations will be performed immediately, as usual.\n *\n * <p><b>Note:</b> Use of immediate operations such as {@link #putIfAbsent} and\n * {@link #evictIfPresent} cannot be deferred to the after-commit phase of a\n * running transaction. Use these with care in a transactional environment.\n *\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @author Stas Volsky\n * @since 3.2\n * @see TransactionAwareCacheManagerProxy\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class TransactionAwareCacheDecorator",
    "source_code": "public class TransactionAwareCacheDecorator implements Cache {\n\n\tprivate final Cache targetCache;\n\n\n\t/**\n\t * Create a new TransactionAwareCache for the given target Cache.\n\t * @param targetCache the target Cache to decorate\n\t */\n\tpublic TransactionAwareCacheDecorator(Cache targetCache) {\n\t\tAssert.notNull(targetCache, \"Target Cache must not be null\");\n\t\tthis.targetCache = targetCache;\n\t}\n\n\n\t/**\n\t * Return the target Cache that this Cache should delegate to.\n\t */\n\tpublic Cache getTargetCache() {\n\t\treturn this.targetCache;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn this.targetCache.getName();\n\t}\n\n\t@Override\n\tpublic Object getNativeCache() {\n\t\treturn this.targetCache.getNativeCache();\n\t}\n\n\t@Override\n\tpublic @Nullable ValueWrapper get(Object key) {\n\t\treturn this.targetCache.get(key);\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T get(Object key, @Nullable Class<T> type) {\n\t\treturn this.targetCache.get(key, type);\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T get(Object key, Callable<T> valueLoader) {\n\t\treturn this.targetCache.get(key, valueLoader);\n\t}\n\n\t@Override\n\tpublic @Nullable CompletableFuture<?> retrieve(Object key) {\n\t\treturn this.targetCache.retrieve(key);\n\t}\n\n\t@Override\n\tpublic <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\treturn this.targetCache.retrieve(key, valueLoader);\n\t}\n\n\t@Override\n\tpublic void put(final Object key, final @Nullable Object value) {\n\t\tif (TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\tTransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() {\n\t\t\t\t@Override\n\t\t\t\tpublic void afterCommit() {\n\t\t\t\t\tTransactionAwareCacheDecorator.this.targetCache.put(key, value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tthis.targetCache.put(key, value);\n\t\t}\n\t}\n\n\t@Override\n\tpublic @Nullable ValueWrapper putIfAbsent(Object key, @Nullable Object value) {\n\t\treturn this.targetCache.putIfAbsent(key, value);\n\t}\n\n\t@Override\n\tpublic void evict(final Object key) {\n\t\tif (TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\tTransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() {\n\t\t\t\t@Override\n\t\t\t\tpublic void afterCommit() {\n\t\t\t\t\tTransactionAwareCacheDecorator.this.targetCache.evict(key);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tthis.targetCache.evict(key);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean evictIfPresent(Object key) {\n\t\treturn this.targetCache.evictIfPresent(key);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tif (TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\tTransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() {\n\t\t\t\t@Override\n\t\t\t\tpublic void afterCommit() {\n\t\t\t\t\ttargetCache.clear();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tthis.targetCache.clear();\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean invalidate() {\n\t\treturn this.targetCache.invalidate();\n\t}\n\n}"
  },
  "org.springframework.cache.transaction.TransactionAwareCacheDecorator#afterCommit()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "public void afterCommit()",
    "source_code": "\t\t\t\tpublic void afterCommit() {\n\t\t\t\t\ttargetCache.clear();\n\t\t\t\t}"
  },
  "org.springframework.cache.transaction.TransactionAwareCacheDecorator#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tif (TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\tTransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() {\n\t\t\t\t@Override\n\t\t\t\tpublic void afterCommit() {\n\t\t\t\t\ttargetCache.clear();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tthis.targetCache.clear();\n\t\t}\n\t}"
  },
  "org.springframework.cache.transaction.TransactionAwareCacheDecorator#evict(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void evict(final Object key)",
    "source_code": "\tpublic void evict(final Object key) {\n\t\tif (TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\tTransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() {\n\t\t\t\t@Override\n\t\t\t\tpublic void afterCommit() {\n\t\t\t\t\tTransactionAwareCacheDecorator.this.targetCache.evict(key);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tthis.targetCache.evict(key);\n\t\t}\n\t}"
  },
  "org.springframework.cache.transaction.TransactionAwareCacheDecorator#evictIfPresent(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "boolean",
    "signature": "public boolean evictIfPresent(Object key)",
    "source_code": "\tpublic boolean evictIfPresent(Object key) {\n\t\treturn this.targetCache.evictIfPresent(key);\n\t}"
  },
  "org.springframework.cache.transaction.TransactionAwareCacheDecorator#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "ValueWrapper",
    "signature": "public ValueWrapper get(Object key)",
    "source_code": "\tpublic @Nullable ValueWrapper get(Object key) {\n\t\treturn this.targetCache.get(key);\n\t}"
  },
  "org.springframework.cache.transaction.TransactionAwareCacheDecorator#get(key,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "T",
    "signature": "public T get(Object key, @Nullable Class<T> type)",
    "source_code": "\tpublic <T> @Nullable T get(Object key, @Nullable Class<T> type) {\n\t\treturn this.targetCache.get(key, type);\n\t}"
  },
  "org.springframework.cache.transaction.TransactionAwareCacheDecorator#get(key,valueLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "T",
    "signature": "public T get(Object key, Callable<T> valueLoader)",
    "source_code": "\tpublic <T> @Nullable T get(Object key, Callable<T> valueLoader) {\n\t\treturn this.targetCache.get(key, valueLoader);\n\t}"
  },
  "org.springframework.cache.transaction.TransactionAwareCacheDecorator#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "\tpublic String getName() {\n\t\treturn this.targetCache.getName();\n\t}"
  },
  "org.springframework.cache.transaction.TransactionAwareCacheDecorator#getNativeCache()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "Object",
    "signature": "public Object getNativeCache()",
    "source_code": "\tpublic Object getNativeCache() {\n\t\treturn this.targetCache.getNativeCache();\n\t}"
  },
  "org.springframework.cache.transaction.TransactionAwareCacheDecorator#getTargetCache()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the target Cache that this Cache should delegate to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "Cache",
    "signature": "public Cache getTargetCache()",
    "source_code": "\tpublic Cache getTargetCache() {\n\t\treturn this.targetCache;\n\t}"
  },
  "org.springframework.cache.transaction.TransactionAwareCacheDecorator#invalidate()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "boolean",
    "signature": "public boolean invalidate()",
    "source_code": "\tpublic boolean invalidate() {\n\t\treturn this.targetCache.invalidate();\n\t}"
  },
  "org.springframework.cache.transaction.TransactionAwareCacheDecorator#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "void",
    "signature": "public void put(final Object key, final @Nullable Object value)",
    "source_code": "\tpublic void put(final Object key, final @Nullable Object value) {\n\t\tif (TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\tTransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() {\n\t\t\t\t@Override\n\t\t\t\tpublic void afterCommit() {\n\t\t\t\t\tTransactionAwareCacheDecorator.this.targetCache.put(key, value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tthis.targetCache.put(key, value);\n\t\t}\n\t}"
  },
  "org.springframework.cache.transaction.TransactionAwareCacheDecorator#putIfAbsent(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "ValueWrapper",
    "signature": "public ValueWrapper putIfAbsent(Object key, @Nullable Object value)",
    "source_code": "\tpublic @Nullable ValueWrapper putIfAbsent(Object key, @Nullable Object value) {\n\t\treturn this.targetCache.putIfAbsent(key, value);\n\t}"
  },
  "org.springframework.cache.transaction.TransactionAwareCacheDecorator#retrieve(key,valueLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "CompletableFuture<T>",
    "signature": "public CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader)",
    "source_code": "\tpublic <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\treturn this.targetCache.retrieve(key, valueLoader);\n\t}"
  },
  "org.springframework.context.MessageSource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Strategy interface for resolving messages, with support for the parameterization\n * and internationalization of such messages.\n *\n * <p>Spring provides two out-of-the-box implementations for production:\n * <ul>\n * <li>{@link org.springframework.context.support.ResourceBundleMessageSource}: built\n * on top of the standard {@link java.util.ResourceBundle}, sharing its limitations.\n * <li>{@link org.springframework.context.support.ReloadableResourceBundleMessageSource}:\n * highly configurable, in particular with respect to reloading message definitions.\n * </ul>\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @see org.springframework.context.support.ResourceBundleMessageSource\n * @see org.springframework.context.support.ReloadableResourceBundleMessageSource\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public interface MessageSource",
    "source_code": "public interface MessageSource {\n\n\t/**\n\t * Try to resolve the message. Return default message if no message was found.\n\t * @param code the message code to look up, for example, 'calculator.noRateSet'.\n\t * MessageSource users are encouraged to base message names on qualified class\n\t * or package names, avoiding potential conflicts and ensuring maximum clarity.\n\t * @param args an array of arguments that will be filled in for params within\n\t * the message (params look like \"{0}\", \"{1,date}\", \"{2,time}\" within a message),\n\t * or {@code null} if none\n\t * @param defaultMessage a default message to return if the lookup fails\n\t * @param locale the locale in which to do the lookup\n\t * @return the resolved message if the lookup was successful, otherwise\n\t * the default message passed as a parameter (which may be {@code null})\n\t * @see #getMessage(MessageSourceResolvable, Locale)\n\t * @see java.text.MessageFormat\n\t */\n\t@Nullable String getMessage(String code, Object @Nullable [] args, @Nullable String defaultMessage, Locale locale);\n\n\t/**\n\t * Try to resolve the message. Treat as an error if the message can't be found.\n\t * @param code the message code to look up, for example, 'calculator.noRateSet'.\n\t * MessageSource users are encouraged to base message names on qualified class\n\t * or package names, avoiding potential conflicts and ensuring maximum clarity.\n\t * @param args an array of arguments that will be filled in for params within\n\t * the message (params look like \"{0}\", \"{1,date}\", \"{2,time}\" within a message),\n\t * or {@code null} if none\n\t * @param locale the locale in which to do the lookup\n\t * @return the resolved message (never {@code null})\n\t * @throws NoSuchMessageException if no corresponding message was found\n\t * @see #getMessage(MessageSourceResolvable, Locale)\n\t * @see java.text.MessageFormat\n\t */\n\tString getMessage(String code, Object @Nullable [] args, Locale locale) throws NoSuchMessageException;\n\n\t/**\n\t * Try to resolve the message using all the attributes contained within the\n\t * {@code MessageSourceResolvable} argument that was passed in.\n\t * <p>NOTE: We must throw a {@code NoSuchMessageException} on this method\n\t * since at the time of calling this method we aren't able to determine if the\n\t * {@code defaultMessage} property of the resolvable is {@code null} or not.\n\t * @param resolvable the value object storing attributes required to resolve a message\n\t * (may include a default message)\n\t * @param locale the locale in which to do the lookup\n\t * @return the resolved message (never {@code null} since even a\n\t * {@code MessageSourceResolvable}-provided default message needs to be non-null)\n\t * @throws NoSuchMessageException if no corresponding message was found\n\t * (and no default message was provided by the {@code MessageSourceResolvable})\n\t * @see MessageSourceResolvable#getCodes()\n\t * @see MessageSourceResolvable#getArguments()\n\t * @see MessageSourceResolvable#getDefaultMessage()\n\t * @see java.text.MessageFormat\n\t */\n\tString getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException;\n\n}"
  },
  "org.springframework.context.MessageSourceResolvable": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Interface for objects that are suitable for message resolution in a\n * {@link MessageSource}.\n *\n * <p>Spring's own validation error classes implement this interface.\n *\n * @author Juergen Hoeller\n * @see MessageSource#getMessage(MessageSourceResolvable, java.util.Locale)\n * @see org.springframework.validation.ObjectError\n * @see org.springframework.validation.FieldError\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 33
    },
    "signature": "public interface MessageSourceResolvable",
    "source_code": "public interface MessageSourceResolvable {\n\n\t/**\n\t * Return the codes to be used to resolve this message, in the order that\n\t * they should get tried. The last code will therefore be the default one.\n\t * @return a String array of codes which are associated with this message\n\t */\n\tString @Nullable [] getCodes();\n\n\t/**\n\t * Return the array of arguments to be used to resolve this message.\n\t * <p>The default implementation simply returns {@code null}.\n\t * @return an array of objects to be used as parameters to replace\n\t * placeholders within the message text\n\t * @see java.text.MessageFormat\n\t */\n\tdefault Object @Nullable [] getArguments() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Return the default message to be used to resolve this message.\n\t * <p>The default implementation simply returns {@code null}.\n\t * Note that the default message may be identical to the primary\n\t * message code ({@link #getCodes()}), which effectively enforces\n\t * {@link org.springframework.context.support.AbstractMessageSource#setUseCodeAsDefaultMessage}\n\t * for this particular message.\n\t * @return the default message, or {@code null} if no default\n\t */\n\tdefault @Nullable String getDefaultMessage() {\n\t\treturn null;\n\t}\n\n}"
  },
  "org.springframework.context.annotation.<unknown>#matches(context,metadata)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "metadata"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "return": "boolean",
    "signature": "public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata)",
    "source_code": "\tpublic boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n\t\tMultiValueMap<String, @Nullable Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());\n\t\tif (attrs != null) {\n\t\t\tfor (Object value : attrs.get(\"value\")) {\n\t\t\t\tif (context.getEnvironment().matchesProfiles((String[]) value)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.context.annotation.AdviceModeImportSelector": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Convenient base class for {@link ImportSelector} implementations that select imports\n * based on an {@link AdviceMode} value from an annotation (such as the {@code @Enable*}\n * annotations).\n *\n * @author Chris Beams\n * @since 3.1\n * @param <A> annotation containing {@linkplain #getAdviceModeAttributeName() AdviceMode attribute}\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class AdviceModeImportSelector",
    "source_code": "public abstract class AdviceModeImportSelector<A extends Annotation> implements ImportSelector {\n\n\t/**\n\t * The default advice mode attribute name.\n\t */\n\tpublic static final String DEFAULT_ADVICE_MODE_ATTRIBUTE_NAME = \"mode\";\n\n\n\t/**\n\t * The name of the {@link AdviceMode} attribute for the annotation specified by the\n\t * generic type {@code A}. The default is {@value #DEFAULT_ADVICE_MODE_ATTRIBUTE_NAME},\n\t * but subclasses may override in order to customize.\n\t */\n\tprotected String getAdviceModeAttributeName() {\n\t\treturn DEFAULT_ADVICE_MODE_ATTRIBUTE_NAME;\n\t}\n\n\t/**\n\t * This implementation resolves the type of annotation from generic metadata and\n\t * validates that (a) the annotation is in fact present on the importing\n\t * {@code @Configuration} class and (b) that the given annotation has an\n\t * {@linkplain #getAdviceModeAttributeName() advice mode attribute} of type\n\t * {@link AdviceMode}.\n\t * <p>The {@link #selectImports(AdviceMode)} method is then invoked, allowing the\n\t * concrete implementation to choose imports in a safe and convenient fashion.\n\t * @throws IllegalArgumentException if expected annotation {@code A} is not present\n\t * on the importing {@code @Configuration} class or if {@link #selectImports(AdviceMode)}\n\t * returns {@code null}\n\t */\n\t@Override\n\tpublic final String[] selectImports(AnnotationMetadata importingClassMetadata) {\n\t\tClass<?> annType = GenericTypeResolver.resolveTypeArgument(getClass(), AdviceModeImportSelector.class);\n\t\tAssert.state(annType != null, \"Unresolvable type argument for AdviceModeImportSelector\");\n\n\t\tAnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(importingClassMetadata, annType);\n\t\tif (attributes == null) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"@%s is not present on importing class '%s' as expected\",\n\t\t\t\t\tannType.getSimpleName(), importingClassMetadata.getClassName()));\n\t\t}\n\n\t\tAdviceMode adviceMode = attributes.getEnum(getAdviceModeAttributeName());\n\t\tString[] imports = selectImports(adviceMode);\n\t\tif (imports == null) {\n\t\t\tthrow new IllegalArgumentException(\"Unknown AdviceMode: \" + adviceMode);\n\t\t}\n\t\treturn imports;\n\t}\n\n\t/**\n\t * Determine which classes should be imported based on the given {@code AdviceMode}.\n\t * <p>Returning {@code null} from this method indicates that the {@code AdviceMode}\n\t * could not be handled or was unknown and that an {@code IllegalArgumentException}\n\t * should be thrown.\n\t * @param adviceMode the value of the {@linkplain #getAdviceModeAttributeName()\n\t * advice mode attribute} for the annotation specified via generics.\n\t * @return array containing classes to import (empty array if none;\n\t * {@code null} if the given {@code AdviceMode} is unknown)\n\t */\n\tprotected abstract String @Nullable [] selectImports(AdviceMode adviceMode);\n\n}"
  },
  "org.springframework.context.annotation.AdviceModeImportSelector#getAdviceModeAttributeName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The name of the {@link AdviceMode} attribute for the annotation specified by the\n\t * generic type {@code A}. The default is {@value #DEFAULT_ADVICE_MODE_ATTRIBUTE_NAME},\n\t * but subclasses may override in order to customize.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 50
    },
    "return": "String",
    "signature": "protected String getAdviceModeAttributeName()",
    "source_code": "\tprotected String getAdviceModeAttributeName() {\n\t\treturn DEFAULT_ADVICE_MODE_ATTRIBUTE_NAME;\n\t}"
  },
  "org.springframework.context.annotation.AdviceModeImportSelector#selectImports(importingClassMetadata)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation resolves the type of annotation from generic metadata and\n\t * validates that (a) the annotation is in fact present on the importing\n\t * {@code @Configuration} class and (b) that the given annotation has an\n\t * {@linkplain #getAdviceModeAttributeName() advice mode attribute} of type\n\t * {@link AdviceMode}.\n\t * <p>The {@link #selectImports(AdviceMode)} method is then invoked, allowing the\n\t * concrete implementation to choose imports in a safe and convenient fashion.\n\t * @throws IllegalArgumentException if expected annotation {@code A} is not present\n\t * on the importing {@code @Configuration} class or if {@link #selectImports(AdviceMode)}\n\t * returns {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "importingClassMetadata"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "String[]",
    "signature": "public String[] selectImports(AnnotationMetadata importingClassMetadata)",
    "source_code": "\tpublic final String[] selectImports(AnnotationMetadata importingClassMetadata) {\n\t\tClass<?> annType = GenericTypeResolver.resolveTypeArgument(getClass(), AdviceModeImportSelector.class);\n\t\tAssert.state(annType != null, \"Unresolvable type argument for AdviceModeImportSelector\");\n\n\t\tAnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(importingClassMetadata, annType);\n\t\tif (attributes == null) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"@%s is not present on importing class '%s' as expected\",\n\t\t\t\t\tannType.getSimpleName(), importingClassMetadata.getClassName()));\n\t\t}\n\n\t\tAdviceMode adviceMode = attributes.getEnum(getAdviceModeAttributeName());\n\t\tString[] imports = selectImports(adviceMode);\n\t\tif (imports == null) {\n\t\t\tthrow new IllegalArgumentException(\"Unknown AdviceMode: \" + adviceMode);\n\t\t}\n\t\treturn imports;\n\t}"
  },
  "org.springframework.context.annotation.DEFAULT_ADVICE_MODE_ATTRIBUTE_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The default advice mode attribute name.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public String DEFAULT_ADVICE_MODE_ATTRIBUTE_NAME",
    "source_code": "\tpublic static final String DEFAULT_ADVICE_MODE_ATTRIBUTE_NAME = \"mode\";",
    "type": "String"
  },
  "org.springframework.context.annotation.MBeanExportConfiguration": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code @Configuration} class that registers a {@link AnnotationMBeanExporter} bean.\n *\n * <p>This configuration class is automatically imported when using the\n * {@link EnableMBeanExport} annotation. See its javadoc for complete usage details.\n *\n * @author Phillip Webb\n * @author Chris Beams\n * @since 3.2\n * @see EnableMBeanExport\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class MBeanExportConfiguration",
    "source_code": "public class MBeanExportConfiguration implements ImportAware, EnvironmentAware, BeanFactoryAware {\n\n\tprivate static final String MBEAN_EXPORTER_BEAN_NAME = \"mbeanExporter\";\n\n\tprivate @Nullable AnnotationAttributes enableMBeanExport;\n\n\tprivate @Nullable Environment environment;\n\n\tprivate @Nullable BeanFactory beanFactory;\n\n\n\t@Override\n\tpublic void setImportMetadata(AnnotationMetadata importMetadata) {\n\t\tMap<String, @Nullable Object> map = importMetadata.getAnnotationAttributes(EnableMBeanExport.class.getName());\n\t\tthis.enableMBeanExport = AnnotationAttributes.fromMap(map);\n\t\tif (this.enableMBeanExport == null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"@EnableMBeanExport is not present on importing class \" + importMetadata.getClassName());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setEnvironment(Environment environment) {\n\t\tthis.environment = environment;\n\t}\n\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t}\n\n\n\t@Bean(name = MBEAN_EXPORTER_BEAN_NAME)\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tpublic AnnotationMBeanExporter mbeanExporter() {\n\t\tAnnotationMBeanExporter exporter = new AnnotationMBeanExporter();\n\t\tAssert.state(this.enableMBeanExport != null, \"No EnableMBeanExport annotation found\");\n\t\tsetupDomain(exporter, this.enableMBeanExport);\n\t\tsetupServer(exporter, this.enableMBeanExport);\n\t\tsetupRegistrationPolicy(exporter, this.enableMBeanExport);\n\t\treturn exporter;\n\t}\n\n\tprivate void setupDomain(AnnotationMBeanExporter exporter, AnnotationAttributes enableMBeanExport) {\n\t\tString defaultDomain = enableMBeanExport.getString(\"defaultDomain\");\n\t\tif (StringUtils.hasLength(defaultDomain) && this.environment != null) {\n\t\t\tdefaultDomain = this.environment.resolvePlaceholders(defaultDomain);\n\t\t}\n\t\tif (StringUtils.hasText(defaultDomain)) {\n\t\t\texporter.setDefaultDomain(defaultDomain);\n\t\t}\n\t}\n\n\tprivate void setupServer(AnnotationMBeanExporter exporter, AnnotationAttributes enableMBeanExport) {\n\t\tString server = enableMBeanExport.getString(\"server\");\n\t\tif (StringUtils.hasLength(server) && this.environment != null) {\n\t\t\tserver = this.environment.resolvePlaceholders(server);\n\t\t}\n\t\tif (StringUtils.hasText(server)) {\n\t\t\tAssert.state(this.beanFactory != null, \"No BeanFactory set\");\n\t\t\texporter.setServer(this.beanFactory.getBean(server, MBeanServer.class));\n\t\t}\n\t}\n\n\tprivate void setupRegistrationPolicy(AnnotationMBeanExporter exporter, AnnotationAttributes enableMBeanExport) {\n\t\tRegistrationPolicy registrationPolicy = enableMBeanExport.getEnum(\"registration\");\n\t\texporter.setRegistrationPolicy(registrationPolicy);\n\t}\n\n}"
  },
  "org.springframework.context.annotation.MBeanExportConfiguration#mbeanExporter()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "AnnotationMBeanExporter",
    "signature": "public AnnotationMBeanExporter mbeanExporter()",
    "source_code": "\tpublic AnnotationMBeanExporter mbeanExporter() {\n\t\tAnnotationMBeanExporter exporter = new AnnotationMBeanExporter();\n\t\tAssert.state(this.enableMBeanExport != null, \"No EnableMBeanExport annotation found\");\n\t\tsetupDomain(exporter, this.enableMBeanExport);\n\t\tsetupServer(exporter, this.enableMBeanExport);\n\t\tsetupRegistrationPolicy(exporter, this.enableMBeanExport);\n\t\treturn exporter;\n\t}"
  },
  "org.springframework.context.annotation.MBeanExportConfiguration#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t}"
  },
  "org.springframework.context.annotation.MBeanExportConfiguration#setEnvironment(environment)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "public void setEnvironment(Environment environment)",
    "source_code": "\tpublic void setEnvironment(Environment environment) {\n\t\tthis.environment = environment;\n\t}"
  },
  "org.springframework.context.annotation.MBeanExportConfiguration#setImportMetadata(importMetadata)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "importMetadata"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "public void setImportMetadata(AnnotationMetadata importMetadata)",
    "source_code": "\tpublic void setImportMetadata(AnnotationMetadata importMetadata) {\n\t\tMap<String, @Nullable Object> map = importMetadata.getAnnotationAttributes(EnableMBeanExport.class.getName());\n\t\tthis.enableMBeanExport = AnnotationAttributes.fromMap(map);\n\t\tif (this.enableMBeanExport == null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"@EnableMBeanExport is not present on importing class \" + importMetadata.getClassName());\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.ResourceElementResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Resolver for the injection of named beans on a field or method element,\n * following the rules of the {@link jakarta.annotation.Resource} annotation\n * but without any JNDI support. This is primarily intended for AOT processing.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 6.1.2\n * @see CommonAnnotationBeanPostProcessor\n * @see jakarta.annotation.Resource\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class ResourceElementResolver",
    "source_code": "public abstract class ResourceElementResolver {\n\n\tprivate final String name;\n\n\tprivate final boolean defaultName;\n\n\n\tResourceElementResolver(String name, boolean defaultName) {\n\t\tthis.name = name;\n\t\tthis.defaultName = defaultName;\n\t}\n\n\n\t/**\n\t * Create a new {@link ResourceFieldResolver} for the specified field.\n\t * @param fieldName the field name\n\t * @return a new {@link ResourceFieldResolver} instance\n\t */\n\tpublic static ResourceElementResolver forField(String fieldName) {\n\t\treturn new ResourceFieldResolver(fieldName, true, fieldName);\n\t}\n\n\t/**\n\t * Create a new {@link ResourceFieldResolver} for the specified field and resource name.\n\t * @param fieldName the field name\n\t * @param resourceName the resource name\n\t * @return a new {@link ResourceFieldResolver} instance\n\t */\n\tpublic static ResourceElementResolver forField(String fieldName, String resourceName) {\n\t\treturn new ResourceFieldResolver(resourceName, false, fieldName);\n\t}\n\n\t/**\n\t * Create a new {@link ResourceMethodResolver} for the specified method\n\t * using a resource name that infers from the method name.\n\t * @param methodName the method name\n\t * @param parameterType the parameter type.\n\t * @return a new {@link ResourceMethodResolver} instance\n\t */\n\tpublic static ResourceElementResolver forMethod(String methodName, Class<?> parameterType) {\n\t\treturn new ResourceMethodResolver(defaultResourceNameForMethod(methodName), true,\n\t\t\t\tmethodName, parameterType);\n\t}\n\n\t/**\n\t * Create a new {@link ResourceMethodResolver} for the specified method\n\t * and resource name.\n\t * @param methodName the method name\n\t * @param parameterType the parameter type\n\t * @param resourceName the resource name\n\t * @return a new {@link ResourceMethodResolver} instance\n\t */\n\tpublic static ResourceElementResolver forMethod(String methodName, Class<?> parameterType, String resourceName) {\n\t\treturn new ResourceMethodResolver(resourceName, false, methodName, parameterType);\n\t}\n\n\tprivate static String defaultResourceNameForMethod(String methodName) {\n\t\tif (methodName.startsWith(\"set\") && methodName.length() > 3) {\n\t\t\treturn StringUtils.uncapitalizeAsProperty(methodName.substring(3));\n\t\t}\n\t\treturn methodName;\n\t}\n\n\n\t/**\n\t * Resolve the value for the specified registered bean.\n\t * @param registeredBean the registered bean\n\t * @return the resolved field or method parameter value\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> @Nullable T resolve(RegisteredBean registeredBean) {\n\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\treturn (T) (isLazyLookup(registeredBean) ? buildLazyResourceProxy(registeredBean) :\n\t\t\t\tresolveValue(registeredBean));\n\t}\n\n\t/**\n\t * Resolve the value for the specified registered bean and set it using reflection.\n\t * @param registeredBean the registered bean\n\t * @param instance the bean instance\n\t */\n\tpublic abstract void resolveAndSet(RegisteredBean registeredBean, Object instance);\n\n\t/**\n\t * Create a suitable {@link DependencyDescriptor} for the specified bean.\n\t * @param registeredBean the registered bean\n\t * @return a descriptor for that bean\n\t */\n\tabstract DependencyDescriptor createDependencyDescriptor(RegisteredBean registeredBean);\n\n\tabstract Class<?> getLookupType(RegisteredBean registeredBean);\n\n\tabstract AnnotatedElement getAnnotatedElement(RegisteredBean registeredBean);\n\n\tboolean isLazyLookup(RegisteredBean registeredBean) {\n\t\tAnnotatedElement ae = getAnnotatedElement(registeredBean);\n\t\tLazy lazy = ae.getAnnotation(Lazy.class);\n\t\treturn (lazy != null && lazy.value());\n\t}\n\n\tprivate Object buildLazyResourceProxy(RegisteredBean registeredBean) {\n\t\tClass<?> lookupType = getLookupType(registeredBean);\n\n\t\tTargetSource ts = new TargetSource() {\n\t\t\t@Override\n\t\t\tpublic Class<?> getTargetClass() {\n\t\t\t\treturn lookupType;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Object getTarget() {\n\t\t\t\treturn resolveValue(registeredBean);\n\t\t\t}\n\t\t};\n\n\t\tProxyFactory pf = new ProxyFactory();\n\t\tpf.setTargetSource(ts);\n\t\tif (lookupType.isInterface()) {\n\t\t\tpf.addInterface(lookupType);\n\t\t}\n\t\treturn pf.getProxy(registeredBean.getBeanFactory().getBeanClassLoader());\n\t}\n\n\t/**\n\t * Resolve the value to inject for this instance.\n\t * @param registeredBean the bean registration\n\t * @return the value to inject\n\t */\n\tprivate Object resolveValue(RegisteredBean registeredBean) {\n\t\tConfigurableListableBeanFactory factory = registeredBean.getBeanFactory();\n\n\t\tObject resource;\n\t\tSet<String> autowiredBeanNames;\n\t\tDependencyDescriptor descriptor = createDependencyDescriptor(registeredBean);\n\t\tif (this.defaultName && !factory.containsBean(this.name)) {\n\t\t\tautowiredBeanNames = new LinkedHashSet<>();\n\t\t\tresource = factory.resolveDependency(descriptor, registeredBean.getBeanName(), autowiredBeanNames, null);\n\t\t\tif (resource == null) {\n\t\t\t\tthrow new NoSuchBeanDefinitionException(descriptor.getDependencyType(), \"No resolvable resource object\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tresource = factory.resolveBeanByName(this.name, descriptor);\n\t\t\tautowiredBeanNames = Collections.singleton(this.name);\n\t\t}\n\n\t\tfor (String autowiredBeanName : autowiredBeanNames) {\n\t\t\tif (factory.containsBean(autowiredBeanName)) {\n\t\t\t\tfactory.registerDependentBean(autowiredBeanName, registeredBean.getBeanName());\n\t\t\t}\n\t\t}\n\t\treturn resource;\n\t}\n\n\n\tprivate static final class ResourceFieldResolver extends ResourceElementResolver {\n\n\t\tprivate final String fieldName;\n\n\t\tpublic ResourceFieldResolver(String name, boolean defaultName, String fieldName) {\n\t\t\tsuper(name, defaultName);\n\t\t\tthis.fieldName = fieldName;\n\t\t}\n\n\t\t@Override\n\t\tpublic void resolveAndSet(RegisteredBean registeredBean, Object instance) {\n\t\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\t\tAssert.notNull(instance, \"'instance' must not be null\");\n\t\t\tField field = getField(registeredBean);\n\t\t\tObject resolved = resolve(registeredBean);\n\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\tReflectionUtils.setField(field, instance, resolved);\n\t\t}\n\n\t\t@Override\n\t\tprotected DependencyDescriptor createDependencyDescriptor(RegisteredBean registeredBean) {\n\t\t\tField field = getField(registeredBean);\n\t\t\treturn new LookupDependencyDescriptor(field, field.getType(), isLazyLookup(registeredBean));\n\t\t}\n\n\t\t@Override\n\t\tprotected Class<?> getLookupType(RegisteredBean registeredBean) {\n\t\t\treturn getField(registeredBean).getType();\n\t\t}\n\n\t\t@Override\n\t\tprotected AnnotatedElement getAnnotatedElement(RegisteredBean registeredBean) {\n\t\t\treturn getField(registeredBean);\n\t\t}\n\n\t\tprivate Field getField(RegisteredBean registeredBean) {\n\t\t\tField field = ReflectionUtils.findField(registeredBean.getBeanClass(), this.fieldName);\n\t\t\tAssert.notNull(field,\n\t\t\t\t\t() -> \"No field '\" + this.fieldName + \"' found on \" + registeredBean.getBeanClass().getName());\n\t\t\treturn field;\n\t\t}\n\t}\n\n\n\tprivate static final class ResourceMethodResolver extends ResourceElementResolver {\n\n\t\tprivate final String methodName;\n\n\t\tprivate final Class<?> lookupType;\n\n\t\tprivate ResourceMethodResolver(String name, boolean defaultName, String methodName, Class<?> lookupType) {\n\t\t\tsuper(name, defaultName);\n\t\t\tthis.methodName = methodName;\n\t\t\tthis.lookupType = lookupType;\n\t\t}\n\n\t\t@Override\n\t\tpublic void resolveAndSet(RegisteredBean registeredBean, Object instance) {\n\t\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\t\tAssert.notNull(instance, \"'instance' must not be null\");\n\t\t\tMethod method = getMethod(registeredBean);\n\t\t\tObject resolved = resolve(registeredBean);\n\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\tReflectionUtils.invokeMethod(method, instance, resolved);\n\t\t}\n\n\t\t@Override\n\t\tprotected DependencyDescriptor createDependencyDescriptor(RegisteredBean registeredBean) {\n\t\t\treturn new LookupDependencyDescriptor(\n\t\t\t\t\tgetMethod(registeredBean), this.lookupType, isLazyLookup(registeredBean));\n\t\t}\n\n\t\t@Override\n\t\tprotected Class<?> getLookupType(RegisteredBean bean) {\n\t\t\treturn this.lookupType;\n\t\t}\n\n\t\t@Override\n\t\tprotected AnnotatedElement getAnnotatedElement(RegisteredBean registeredBean) {\n\t\t\treturn getMethod(registeredBean);\n\t\t}\n\n\t\tprivate Method getMethod(RegisteredBean registeredBean) {\n\t\t\tMethod method = ReflectionUtils.findMethod(registeredBean.getBeanClass(), this.methodName, this.lookupType);\n\t\t\tAssert.notNull(method,\n\t\t\t\t\t() -> \"Method '%s' with parameter type '%s' declared on %s could not be found.\".formatted(\n\t\t\t\t\t\t\tthis.methodName, this.lookupType.getName(), registeredBean.getBeanClass().getName()));\n\t\t\treturn method;\n\t\t}\n\t}\n\n\n\t/**\n\t * Extension of the DependencyDescriptor class,\n\t * overriding the dependency type with the specified resource type.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tstatic class LookupDependencyDescriptor extends DependencyDescriptor {\n\n\t\tprivate final Class<?> lookupType;\n\n\t\tprivate final boolean lazyLookup;\n\n\t\tpublic LookupDependencyDescriptor(Field field, Class<?> lookupType, boolean lazyLookup) {\n\t\t\tsuper(field, true);\n\t\t\tthis.lookupType = lookupType;\n\t\t\tthis.lazyLookup = lazyLookup;\n\t\t}\n\n\t\tpublic LookupDependencyDescriptor(Method method, Class<?> lookupType, boolean lazyLookup) {\n\t\t\tsuper(new MethodParameter(method, 0), true);\n\t\t\tthis.lookupType = lookupType;\n\t\t\tthis.lazyLookup = lazyLookup;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getDependencyType() {\n\t\t\treturn this.lookupType;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean supportsLazyResolution() {\n\t\t\treturn !this.lazyLookup;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.context.annotation.ResourceElementResolver#createDependencyDescriptor(registeredBean)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "registeredBean"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "DependencyDescriptor",
    "signature": "protected DependencyDescriptor createDependencyDescriptor(RegisteredBean registeredBean)",
    "source_code": "\t\tprotected DependencyDescriptor createDependencyDescriptor(RegisteredBean registeredBean) {\n\t\t\treturn new LookupDependencyDescriptor(\n\t\t\t\t\tgetMethod(registeredBean), this.lookupType, isLazyLookup(registeredBean));\n\t\t}"
  },
  "org.springframework.context.annotation.ResourceElementResolver#forField(fieldName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link ResourceFieldResolver} for the specified field.\n\t * @param fieldName the field name\n\t * @return a new {@link ResourceFieldResolver} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fieldName"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "ResourceElementResolver",
    "signature": "public ResourceElementResolver forField(String fieldName)",
    "source_code": "\tpublic static ResourceElementResolver forField(String fieldName) {\n\t\treturn new ResourceFieldResolver(fieldName, true, fieldName);\n\t}"
  },
  "org.springframework.context.annotation.ResourceElementResolver#forField(fieldName,resourceName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link ResourceFieldResolver} for the specified field and resource name.\n\t * @param fieldName the field name\n\t * @param resourceName the resource name\n\t * @return a new {@link ResourceFieldResolver} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fieldName",
      "resourceName"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "ResourceElementResolver",
    "signature": "public ResourceElementResolver forField(String fieldName, String resourceName)",
    "source_code": "\tpublic static ResourceElementResolver forField(String fieldName, String resourceName) {\n\t\treturn new ResourceFieldResolver(resourceName, false, fieldName);\n\t}"
  },
  "org.springframework.context.annotation.ResourceElementResolver#forMethod(methodName,parameterType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link ResourceMethodResolver} for the specified method\n\t * using a resource name that infers from the method name.\n\t * @param methodName the method name\n\t * @param parameterType the parameter type.\n\t * @return a new {@link ResourceMethodResolver} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodName",
      "parameterType"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "ResourceElementResolver",
    "signature": "public ResourceElementResolver forMethod(String methodName, Class<?> parameterType)",
    "source_code": "\tpublic static ResourceElementResolver forMethod(String methodName, Class<?> parameterType) {\n\t\treturn new ResourceMethodResolver(defaultResourceNameForMethod(methodName), true,\n\t\t\t\tmethodName, parameterType);\n\t}"
  },
  "org.springframework.context.annotation.ResourceElementResolver#forMethod(methodName,parameterType,resourceName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link ResourceMethodResolver} for the specified method\n\t * and resource name.\n\t * @param methodName the method name\n\t * @param parameterType the parameter type\n\t * @param resourceName the resource name\n\t * @return a new {@link ResourceMethodResolver} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodName",
      "parameterType",
      "resourceName"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "ResourceElementResolver",
    "signature": "public ResourceElementResolver forMethod(String methodName, Class<?> parameterType, String resourceName)",
    "source_code": "\tpublic static ResourceElementResolver forMethod(String methodName, Class<?> parameterType, String resourceName) {\n\t\treturn new ResourceMethodResolver(resourceName, false, methodName, parameterType);\n\t}"
  },
  "org.springframework.context.annotation.ResourceElementResolver#getAnnotatedElement(registeredBean)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "registeredBean"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "AnnotatedElement",
    "signature": "protected AnnotatedElement getAnnotatedElement(RegisteredBean registeredBean)",
    "source_code": "\t\tprotected AnnotatedElement getAnnotatedElement(RegisteredBean registeredBean) {\n\t\t\treturn getMethod(registeredBean);\n\t\t}"
  },
  "org.springframework.context.annotation.ResourceElementResolver#getTarget()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "Object",
    "signature": "public Object getTarget()",
    "source_code": "\t\t\tpublic Object getTarget() {\n\t\t\t\treturn resolveValue(registeredBean);\n\t\t\t}"
  },
  "org.springframework.context.annotation.ResourceElementResolver#resolve(registeredBean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the value for the specified registered bean.\n\t * @param registeredBean the registered bean\n\t * @return the resolved field or method parameter value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "T",
    "signature": "public T resolve(RegisteredBean registeredBean)",
    "source_code": "\tpublic <T> @Nullable T resolve(RegisteredBean registeredBean) {\n\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\treturn (T) (isLazyLookup(registeredBean) ? buildLazyResourceProxy(registeredBean) :\n\t\t\t\tresolveValue(registeredBean));\n\t}"
  },
  "org.springframework.context.annotation.ResourceElementResolver#resolveAndSet(registeredBean,instance)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "instance"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "void",
    "signature": "public void resolveAndSet(RegisteredBean registeredBean, Object instance)",
    "source_code": "\t\tpublic void resolveAndSet(RegisteredBean registeredBean, Object instance) {\n\t\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\t\tAssert.notNull(instance, \"'instance' must not be null\");\n\t\t\tMethod method = getMethod(registeredBean);\n\t\t\tObject resolved = resolve(registeredBean);\n\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\tReflectionUtils.invokeMethod(method, instance, resolved);\n\t\t}"
  },
  "org.springframework.context.annotation.ResourceElementResolver#supportsLazyResolution()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "boolean",
    "signature": "public boolean supportsLazyResolution()",
    "source_code": "\t\tpublic boolean supportsLazyResolution() {\n\t\t\treturn !this.lazyLookup;\n\t\t}"
  },
  "org.springframework.context.event.ApplicationListenerMethodAdapter#resolveArguments(event)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the method arguments to use for the specified {@link ApplicationEvent}.\n\t * <p>These arguments will be used to invoke the method handled by this instance.\n\t * Can return {@code null} to indicate that no suitable arguments could be resolved\n\t * and therefore the method should not be invoked at all for the specified event.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "Object[]",
    "signature": "protected Object[] resolveArguments(ApplicationEvent event)",
    "source_code": "\tprotected Object[] resolveArguments(ApplicationEvent event) {\n\t\tResolvableType declaredEventType = getResolvableType(event);\n\t\tif (declaredEventType == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this.method.getParameterCount() == 0) {\n\t\t\treturn new Object[0];\n\t\t}\n\t\tClass<?> declaredEventClass = declaredEventType.toClass();\n\t\tif (!ApplicationEvent.class.isAssignableFrom(declaredEventClass) &&\n\t\t\t\tevent instanceof PayloadApplicationEvent<?> payloadEvent) {\n\t\t\tObject payload = payloadEvent.getPayload();\n\t\t\tif (declaredEventClass.isInstance(payload)) {\n\t\t\t\treturn new Object[] {payload};\n\t\t\t}\n\t\t}\n\t\treturn new Object[] {event};\n\t}"
  },
  "org.springframework.context.support.AbstractRefreshableConfigApplicationContext": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link AbstractRefreshableApplicationContext} subclass that adds common handling\n * of specified config locations. Serves as base class for XML-based application\n * context implementations such as {@link ClassPathXmlApplicationContext} and\n * {@link FileSystemXmlApplicationContext}, as well as\n * {@link org.springframework.web.context.support.XmlWebApplicationContext}.\n *\n * @author Juergen Hoeller\n * @since 2.5.2\n * @see #setConfigLocation\n * @see #setConfigLocations\n * @see #getDefaultConfigLocations\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class AbstractRefreshableConfigApplicationContext",
    "source_code": "public abstract class AbstractRefreshableConfigApplicationContext extends AbstractRefreshableApplicationContext"
  },
  "org.springframework.context.support.AbstractRefreshableConfigApplicationContext#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Triggers {@link #refresh()} if not refreshed in the concrete context's\n\t * constructor already.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tif (!isActive()) {\n\t\t\trefresh();\n\t\t}\n\t}"
  },
  "org.springframework.context.support.AbstractRefreshableConfigApplicationContext#resolvePath(path)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given path, replacing placeholders with corresponding\n\t * environment property values if necessary. Applied to config locations.\n\t * @param path the original file path\n\t * @return the resolved file path\n\t * @see org.springframework.core.env.Environment#resolveRequiredPlaceholders(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "String",
    "signature": "protected String resolvePath(String path)",
    "source_code": "\tprotected String resolvePath(String path) {\n\t\treturn getEnvironment().resolveRequiredPlaceholders(path);\n\t}"
  },
  "org.springframework.context.support.AbstractRefreshableConfigApplicationContext#setBeanName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Sets the id of this context to the bean name by default,\n\t * for cases where the context instance is itself defined as a bean.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void setBeanName(String name)",
    "source_code": "\tpublic void setBeanName(String name) {\n\t\tif (!this.setIdCalled) {\n\t\t\tsuper.setId(name);\n\t\t\tsetDisplayName(\"ApplicationContext '\" + name + \"'\");\n\t\t}\n\t}"
  },
  "org.springframework.context.support.AbstractRefreshableConfigApplicationContext#setConfigLocation(location)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the config locations for this application context in init-param style,\n\t * i.e. with distinct locations separated by commas, semicolons or whitespace.\n\t * <p>If not set, the implementation may use a default as appropriate.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "void",
    "signature": "public void setConfigLocation(String location)",
    "source_code": "\tpublic void setConfigLocation(String location) {\n\t\tsetConfigLocations(StringUtils.tokenizeToStringArray(location, CONFIG_LOCATION_DELIMITERS));\n\t}"
  },
  "org.springframework.context.support.AbstractRefreshableConfigApplicationContext#setConfigLocations(locations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the config locations for this application context.\n\t * <p>If not set, the implementation may use a default as appropriate.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "void",
    "signature": "public void setConfigLocations(String @Nullable ... locations)",
    "source_code": "\tpublic void setConfigLocations(String @Nullable ... locations) {\n\t\tif (locations != null) {\n\t\t\tAssert.noNullElements(locations, \"Config locations must not be null\");\n\t\t\tthis.configLocations = new String[locations.length];\n\t\t\tfor (int i = 0; i < locations.length; i++) {\n\t\t\t\tthis.configLocations[i] = resolvePath(locations[i]).trim();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.configLocations = null;\n\t\t}\n\t}"
  },
  "org.springframework.context.support.AbstractRefreshableConfigApplicationContext#setId(id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "id"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "void",
    "signature": "public void setId(String id)",
    "source_code": "\tpublic void setId(String id) {\n\t\tsuper.setId(id);\n\t\tthis.setIdCalled = true;\n\t}"
  },
  "org.springframework.context.support.AbstractXmlApplicationContext": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Convenient base class for {@link org.springframework.context.ApplicationContext}\n * implementations, drawing configuration from XML documents containing bean definitions\n * understood by an {@link org.springframework.beans.factory.xml.XmlBeanDefinitionReader}.\n *\n * <p>Subclasses just have to implement the {@link #getConfigResources} and/or\n * the {@link #getConfigLocations} method. Furthermore, they might override\n * the {@link #getResourceByPath} hook to interpret relative paths in an\n * environment-specific fashion, and/or {@link #getResourcePatternResolver}\n * for extended pattern resolution.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @see #getConfigResources\n * @see #getConfigLocations\n * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class AbstractXmlApplicationContext",
    "source_code": "public abstract class AbstractXmlApplicationContext extends AbstractRefreshableConfigApplicationContext {\n\n\tprivate boolean validating = true;\n\n\n\t/**\n\t * Create a new AbstractXmlApplicationContext with no parent.\n\t */\n\tpublic AbstractXmlApplicationContext() {\n\t}\n\n\t/**\n\t * Create a new AbstractXmlApplicationContext with the given parent context.\n\t * @param parent the parent context\n\t */\n\tpublic AbstractXmlApplicationContext(@Nullable ApplicationContext parent) {\n\t\tsuper(parent);\n\t}\n\n\n\t/**\n\t * Set whether to use XML validation. Default is {@code true}.\n\t */\n\tpublic void setValidating(boolean validating) {\n\t\tthis.validating = validating;\n\t}\n\n\n\t/**\n\t * Loads the bean definitions via an XmlBeanDefinitionReader.\n\t * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader\n\t * @see #initBeanDefinitionReader\n\t * @see #loadBeanDefinitions\n\t */\n\t@Override\n\tprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {\n\t\t// Create a new XmlBeanDefinitionReader for the given BeanFactory.\n\t\tXmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n\n\t\t// Configure the bean definition reader with this context's\n\t\t// resource loading environment.\n\t\tbeanDefinitionReader.setEnvironment(getEnvironment());\n\t\tbeanDefinitionReader.setResourceLoader(this);\n\t\tbeanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n\n\t\t// Allow a subclass to provide custom initialization of the reader,\n\t\t// then proceed with actually loading the bean definitions.\n\t\tinitBeanDefinitionReader(beanDefinitionReader);\n\t\tloadBeanDefinitions(beanDefinitionReader);\n\t}\n\n\t/**\n\t * Initialize the bean definition reader used for loading the bean definitions\n\t * of this context. The default implementation sets the validating flag.\n\t * <p>Can be overridden in subclasses, for example, for turning off XML validation\n\t * or using a different {@link BeanDefinitionDocumentReader} implementation.\n\t * @param reader the bean definition reader used by this context\n\t * @see XmlBeanDefinitionReader#setValidating\n\t * @see XmlBeanDefinitionReader#setDocumentReaderClass\n\t */\n\tprotected void initBeanDefinitionReader(XmlBeanDefinitionReader reader) {\n\t\treader.setValidating(this.validating);\n\t}\n\n\t/**\n\t * Load the bean definitions with the given XmlBeanDefinitionReader.\n\t * <p>The lifecycle of the bean factory is handled by the {@link #refreshBeanFactory}\n\t * method; hence this method is just supposed to load and/or register bean definitions.\n\t * @param reader the XmlBeanDefinitionReader to use\n\t * @throws BeansException in case of bean registration errors\n\t * @throws IOException if the required XML document isn't found\n\t * @see #refreshBeanFactory\n\t * @see #getConfigLocations\n\t * @see #getResources\n\t * @see #getResourcePatternResolver\n\t */\n\tprotected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {\n\t\tResource[] configResources = getConfigResources();\n\t\tif (configResources != null) {\n\t\t\treader.loadBeanDefinitions(configResources);\n\t\t}\n\t\tString[] configLocations = getConfigLocations();\n\t\tif (configLocations != null) {\n\t\t\treader.loadBeanDefinitions(configLocations);\n\t\t}\n\t}\n\n\t/**\n\t * Return an array of Resource objects, referring to the XML bean definition\n\t * files that this context should be built with.\n\t * <p>The default implementation returns {@code null}. Subclasses can override\n\t * this to provide pre-built Resource objects rather than location Strings.\n\t * @return an array of Resource objects, or {@code null} if none\n\t * @see #getConfigLocations()\n\t */\n\tprotected Resource @Nullable [] getConfigResources() {\n\t\treturn null;\n\t}\n\n}"
  },
  "org.springframework.context.support.AbstractXmlApplicationContext#initBeanDefinitionReader(reader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the bean definition reader used for loading the bean definitions\n\t * of this context. The default implementation sets the validating flag.\n\t * <p>Can be overridden in subclasses, for example, for turning off XML validation\n\t * or using a different {@link BeanDefinitionDocumentReader} implementation.\n\t * @param reader the bean definition reader used by this context\n\t * @see XmlBeanDefinitionReader#setValidating\n\t * @see XmlBeanDefinitionReader#setDocumentReaderClass\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "reader"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "protected void initBeanDefinitionReader(XmlBeanDefinitionReader reader)",
    "source_code": "\tprotected void initBeanDefinitionReader(XmlBeanDefinitionReader reader) {\n\t\treader.setValidating(this.validating);\n\t}"
  },
  "org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Loads the bean definitions via an XmlBeanDefinitionReader.\n\t * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader\n\t * @see #initBeanDefinitionReader\n\t * @see #loadBeanDefinitions\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory)",
    "source_code": "\tprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {\n\t\t// Create a new XmlBeanDefinitionReader for the given BeanFactory.\n\t\tXmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n\n\t\t// Configure the bean definition reader with this context's\n\t\t// resource loading environment.\n\t\tbeanDefinitionReader.setEnvironment(getEnvironment());\n\t\tbeanDefinitionReader.setResourceLoader(this);\n\t\tbeanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n\n\t\t// Allow a subclass to provide custom initialization of the reader,\n\t\t// then proceed with actually loading the bean definitions.\n\t\tinitBeanDefinitionReader(beanDefinitionReader);\n\t\tloadBeanDefinitions(beanDefinitionReader);\n\t}"
  },
  "org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions(reader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load the bean definitions with the given XmlBeanDefinitionReader.\n\t * <p>The lifecycle of the bean factory is handled by the {@link #refreshBeanFactory}\n\t * method; hence this method is just supposed to load and/or register bean definitions.\n\t * @param reader the XmlBeanDefinitionReader to use\n\t * @throws BeansException in case of bean registration errors\n\t * @throws IOException if the required XML document isn't found\n\t * @see #refreshBeanFactory\n\t * @see #getConfigLocations\n\t * @see #getResources\n\t * @see #getResourcePatternResolver\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "reader"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "void",
    "signature": "protected void loadBeanDefinitions(XmlBeanDefinitionReader reader)",
    "source_code": "\tprotected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {\n\t\tResource[] configResources = getConfigResources();\n\t\tif (configResources != null) {\n\t\t\treader.loadBeanDefinitions(configResources);\n\t\t}\n\t\tString[] configLocations = getConfigLocations();\n\t\tif (configLocations != null) {\n\t\t\treader.loadBeanDefinitions(configLocations);\n\t\t}\n\t}"
  },
  "org.springframework.context.support.AbstractXmlApplicationContext#setValidating(validating)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to use XML validation. Default is {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "validating"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "public void setValidating(boolean validating)",
    "source_code": "\tpublic void setValidating(boolean validating) {\n\t\tthis.validating = validating;\n\t}"
  },
  "org.springframework.context.support.ClassPathXmlApplicationContext": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Standalone XML application context, taking the context definition files\n * from the class path, interpreting plain paths as class path resource names\n * that include the package path (for example, \"mypackage/myresource.txt\"). Useful for\n * test harnesses as well as for application contexts embedded within JARs.\n *\n * <p>The config location defaults can be overridden via {@link #getConfigLocations},\n * Config locations can either denote concrete files like \"/myfiles/context.xml\"\n * or Ant-style patterns like \"/myfiles/*-context.xml\" (see the\n * {@link org.springframework.util.AntPathMatcher} javadoc for pattern details).\n *\n * <p>Note: In case of multiple config locations, later bean definitions will\n * override ones defined in earlier loaded files. This can be leveraged to\n * deliberately override certain bean definitions via an extra XML file.\n *\n * <p><b>This is a simple, one-stop shop convenience ApplicationContext.\n * Consider using the {@link GenericApplicationContext} class in combination\n * with an {@link org.springframework.beans.factory.xml.XmlBeanDefinitionReader}\n * for more flexible context setup.</b>\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @see #getResource\n * @see #getResourceByPath\n * @see GenericApplicationContext\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "signature": "public class ClassPathXmlApplicationContext",
    "source_code": "public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext {\n\n\tprivate Resource @Nullable [] configResources;\n\n\n\t/**\n\t * Create a new ClassPathXmlApplicationContext for bean-style configuration.\n\t * @see #setConfigLocation\n\t * @see #setConfigLocations\n\t * @see #afterPropertiesSet()\n\t */\n\tpublic ClassPathXmlApplicationContext() {\n\t}\n\n\t/**\n\t * Create a new ClassPathXmlApplicationContext for bean-style configuration.\n\t * @param parent the parent context\n\t * @see #setConfigLocation\n\t * @see #setConfigLocations\n\t * @see #afterPropertiesSet()\n\t */\n\tpublic ClassPathXmlApplicationContext(ApplicationContext parent) {\n\t\tsuper(parent);\n\t}\n\n\t/**\n\t * Create a new ClassPathXmlApplicationContext, loading the definitions\n\t * from the given XML file and automatically refreshing the context.\n\t * @param configLocation resource location\n\t * @throws BeansException if context creation failed\n\t */\n\tpublic ClassPathXmlApplicationContext(String configLocation) throws BeansException {\n\t\tthis(new String[] {configLocation}, true, null);\n\t}\n\n\t/**\n\t * Create a new ClassPathXmlApplicationContext, loading the definitions\n\t * from the given XML files and automatically refreshing the context.\n\t * @param configLocations array of resource locations\n\t * @throws BeansException if context creation failed\n\t */\n\tpublic ClassPathXmlApplicationContext(String... configLocations) throws BeansException {\n\t\tthis(configLocations, true, null);\n\t}\n\n\t/**\n\t * Create a new ClassPathXmlApplicationContext with the given parent,\n\t * loading the definitions from the given XML files and automatically\n\t * refreshing the context.\n\t * @param configLocations array of resource locations\n\t * @param parent the parent context\n\t * @throws BeansException if context creation failed\n\t */\n\tpublic ClassPathXmlApplicationContext(String[] configLocations, @Nullable ApplicationContext parent)\n\t\t\tthrows BeansException {\n\n\t\tthis(configLocations, true, parent);\n\t}\n\n\t/**\n\t * Create a new ClassPathXmlApplicationContext, loading the definitions\n\t * from the given XML files.\n\t * @param configLocations array of resource locations\n\t * @param refresh whether to automatically refresh the context,\n\t * loading all bean definitions and creating all singletons.\n\t * Alternatively, call refresh manually after further configuring the context.\n\t * @throws BeansException if context creation failed\n\t * @see #refresh()\n\t */\n\tpublic ClassPathXmlApplicationContext(String[] configLocations, boolean refresh) throws BeansException {\n\t\tthis(configLocations, refresh, null);\n\t}\n\n\t/**\n\t * Create a new ClassPathXmlApplicationContext with the given parent,\n\t * loading the definitions from the given XML files.\n\t * @param configLocations array of resource locations\n\t * @param refresh whether to automatically refresh the context,\n\t * loading all bean definitions and creating all singletons.\n\t * Alternatively, call refresh manually after further configuring the context.\n\t * @param parent the parent context\n\t * @throws BeansException if context creation failed\n\t * @see #refresh()\n\t */\n\tpublic ClassPathXmlApplicationContext(\n\t\t\tString[] configLocations, boolean refresh, @Nullable ApplicationContext parent)\n\t\t\tthrows BeansException {\n\n\t\tsuper(parent);\n\t\tsetConfigLocations(configLocations);\n\t\tif (refresh) {\n\t\t\trefresh();\n\t\t}\n\t}\n\n\n\t/**\n\t * Create a new ClassPathXmlApplicationContext, loading the definitions\n\t * from the given XML file and automatically refreshing the context.\n\t * <p>This is a convenience method to load class path resources relative to a\n\t * given Class. For full flexibility, consider using a GenericApplicationContext\n\t * with an XmlBeanDefinitionReader and a ClassPathResource argument.\n\t * @param path relative (or absolute) path within the class path\n\t * @param clazz the class to load resources with (basis for the given paths)\n\t * @throws BeansException if context creation failed\n\t * @see org.springframework.core.io.ClassPathResource#ClassPathResource(String, Class)\n\t * @see org.springframework.context.support.GenericApplicationContext\n\t * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader\n\t */\n\tpublic ClassPathXmlApplicationContext(String path, Class<?> clazz) throws BeansException {\n\t\tthis(new String[] {path}, clazz);\n\t}\n\n\t/**\n\t * Create a new ClassPathXmlApplicationContext, loading the definitions\n\t * from the given XML files and automatically refreshing the context.\n\t * @param paths array of relative (or absolute) paths within the class path\n\t * @param clazz the class to load resources with (basis for the given paths)\n\t * @throws BeansException if context creation failed\n\t * @see org.springframework.core.io.ClassPathResource#ClassPathResource(String, Class)\n\t * @see org.springframework.context.support.GenericApplicationContext\n\t * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader\n\t */\n\tpublic ClassPathXmlApplicationContext(String[] paths, Class<?> clazz) throws BeansException {\n\t\tthis(paths, clazz, null);\n\t}\n\n\t/**\n\t * Create a new ClassPathXmlApplicationContext with the given parent,\n\t * loading the definitions from the given XML files and automatically\n\t * refreshing the context.\n\t * @param paths array of relative (or absolute) paths within the class path\n\t * @param clazz the class to load resources with (basis for the given paths)\n\t * @param parent the parent context\n\t * @throws BeansException if context creation failed\n\t * @see org.springframework.core.io.ClassPathResource#ClassPathResource(String, Class)\n\t * @see org.springframework.context.support.GenericApplicationContext\n\t * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader\n\t */\n\tpublic ClassPathXmlApplicationContext(String[] paths, Class<?> clazz, @Nullable ApplicationContext parent)\n\t\t\tthrows BeansException {\n\n\t\tsuper(parent);\n\t\tAssert.notNull(paths, \"Path array must not be null\");\n\t\tAssert.notNull(clazz, \"Class argument must not be null\");\n\t\tthis.configResources = new Resource[paths.length];\n\t\tfor (int i = 0; i < paths.length; i++) {\n\t\t\tthis.configResources[i] = new ClassPathResource(paths[i], clazz);\n\t\t}\n\t\trefresh();\n\t}\n\n\n\t@Override\n\tprotected Resource @Nullable [] getConfigResources() {\n\t\treturn this.configResources;\n\t}\n\n}"
  },
  "org.springframework.context.support.DefaultMessageSourceResolvable#getArguments()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "Object[]",
    "signature": "public Object[] getArguments()",
    "source_code": "\tpublic Object[] getArguments() {\n\t\treturn this.arguments;\n\t}"
  },
  "org.springframework.context.support.DefaultMessageSourceResolvable#getCodes()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "String[]",
    "signature": "public String[] getCodes()",
    "source_code": "\tpublic String[] getCodes() {\n\t\treturn this.codes;\n\t}"
  },
  "org.springframework.context.support.DelegatingMessageSource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Empty {@link MessageSource} that delegates all calls to the parent MessageSource.\n * If no parent is available, it simply won't resolve any message.\n *\n * <p>Used as placeholder by AbstractApplicationContext, if the context doesn't\n * define its own MessageSource. Not intended for direct use in applications.\n *\n * @author Juergen Hoeller\n * @since 1.1.5\n * @see AbstractApplicationContext\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class DelegatingMessageSource",
    "source_code": "public class DelegatingMessageSource extends MessageSourceSupport implements HierarchicalMessageSource {\n\n\tprivate @Nullable MessageSource parentMessageSource;\n\n\n\t@Override\n\tpublic void setParentMessageSource(@Nullable MessageSource parent) {\n\t\tthis.parentMessageSource = parent;\n\t}\n\n\t@Override\n\tpublic @Nullable MessageSource getParentMessageSource() {\n\t\treturn this.parentMessageSource;\n\t}\n\n\n\t@Override\n\tpublic @Nullable String getMessage(String code, Object @Nullable [] args, @Nullable String defaultMessage, Locale locale) {\n\t\tif (this.parentMessageSource != null) {\n\t\t\treturn this.parentMessageSource.getMessage(code, args, defaultMessage, locale);\n\t\t}\n\t\telse if (defaultMessage != null) {\n\t\t\treturn renderDefaultMessage(defaultMessage, args, locale);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getMessage(String code, Object @Nullable [] args, Locale locale) throws NoSuchMessageException {\n\t\tif (this.parentMessageSource != null) {\n\t\t\treturn this.parentMessageSource.getMessage(code, args, locale);\n\t\t}\n\t\telse {\n\t\t\tthrow new NoSuchMessageException(code, locale);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException {\n\t\tif (this.parentMessageSource != null) {\n\t\t\treturn this.parentMessageSource.getMessage(resolvable, locale);\n\t\t}\n\t\telse {\n\t\t\tif (resolvable.getDefaultMessage() != null) {\n\t\t\t\treturn renderDefaultMessage(resolvable.getDefaultMessage(), resolvable.getArguments(), locale);\n\t\t\t}\n\t\t\tString[] codes = resolvable.getCodes();\n\t\t\tString code = (codes != null && codes.length > 0 ? codes[0] : \"\");\n\t\t\tthrow new NoSuchMessageException(code, locale);\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn (this.parentMessageSource != null ? this.parentMessageSource.toString() : \"Empty MessageSource\");\n\t}\n\n}"
  },
  "org.springframework.context.support.DelegatingMessageSource#getMessage(code,args,defaultMessage,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "String",
    "signature": "public String getMessage(String code, Object @Nullable [] args, @Nullable String defaultMessage, Locale locale)",
    "source_code": "\tpublic @Nullable String getMessage(String code, Object @Nullable [] args, @Nullable String defaultMessage, Locale locale) {\n\t\tif (this.parentMessageSource != null) {\n\t\t\treturn this.parentMessageSource.getMessage(code, args, defaultMessage, locale);\n\t\t}\n\t\telse if (defaultMessage != null) {\n\t\t\treturn renderDefaultMessage(defaultMessage, args, locale);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.context.support.DelegatingMessageSource#getMessage(code,args,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "String",
    "signature": "public String getMessage(String code, Object @Nullable [] args, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, Object @Nullable [] args, Locale locale) throws NoSuchMessageException {\n\t\tif (this.parentMessageSource != null) {\n\t\t\treturn this.parentMessageSource.getMessage(code, args, locale);\n\t\t}\n\t\telse {\n\t\t\tthrow new NoSuchMessageException(code, locale);\n\t\t}\n\t}"
  },
  "org.springframework.context.support.DelegatingMessageSource#getMessage(resolvable,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException {\n\t\tif (this.parentMessageSource != null) {\n\t\t\treturn this.parentMessageSource.getMessage(resolvable, locale);\n\t\t}\n\t\telse {\n\t\t\tif (resolvable.getDefaultMessage() != null) {\n\t\t\t\treturn renderDefaultMessage(resolvable.getDefaultMessage(), resolvable.getArguments(), locale);\n\t\t\t}\n\t\t\tString[] codes = resolvable.getCodes();\n\t\t\tString code = (codes != null && codes.length > 0 ? codes[0] : \"\");\n\t\t\tthrow new NoSuchMessageException(code, locale);\n\t\t}\n\t}"
  },
  "org.springframework.context.support.DelegatingMessageSource#getParentMessageSource()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 50
    },
    "return": "MessageSource",
    "signature": "public MessageSource getParentMessageSource()",
    "source_code": "\tpublic @Nullable MessageSource getParentMessageSource() {\n\t\treturn this.parentMessageSource;\n\t}"
  },
  "org.springframework.context.support.DelegatingMessageSource#setParentMessageSource(parent)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parent"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "return": "void",
    "signature": "public void setParentMessageSource(@Nullable MessageSource parent)",
    "source_code": "\tpublic void setParentMessageSource(@Nullable MessageSource parent) {\n\t\tthis.parentMessageSource = parent;\n\t}"
  },
  "org.springframework.context.support.DelegatingMessageSource#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn (this.parentMessageSource != null ? this.parentMessageSource.toString() : \"Empty MessageSource\");\n\t}"
  },
  "org.springframework.context.support.MessageSourceAccessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Helper class for easy access to messages from a MessageSource,\n * providing various overloaded getMessage methods.\n *\n * <p>Available from ApplicationObjectSupport, but also reusable\n * as a standalone helper to delegate to in application objects.\n *\n * @author Juergen Hoeller\n * @since 23.10.2003\n * @see ApplicationObjectSupport#getMessageSourceAccessor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class MessageSourceAccessor",
    "source_code": "public class MessageSourceAccessor {\n\n\tprivate final MessageSource messageSource;\n\n\tprivate final @Nullable Locale defaultLocale;\n\n\n\t/**\n\t * Create a new MessageSourceAccessor, using LocaleContextHolder's locale\n\t * as default locale.\n\t * @param messageSource the MessageSource to wrap\n\t * @see org.springframework.context.i18n.LocaleContextHolder#getLocale()\n\t */\n\tpublic MessageSourceAccessor(MessageSource messageSource) {\n\t\tthis.messageSource = messageSource;\n\t\tthis.defaultLocale = null;\n\t}\n\n\t/**\n\t * Create a new MessageSourceAccessor, using the given default locale.\n\t * @param messageSource the MessageSource to wrap\n\t * @param defaultLocale the default locale to use for message access\n\t */\n\tpublic MessageSourceAccessor(MessageSource messageSource, Locale defaultLocale) {\n\t\tthis.messageSource = messageSource;\n\t\tthis.defaultLocale = defaultLocale;\n\t}\n\n\n\t/**\n\t * Return the default locale to use if no explicit locale has been given.\n\t * <p>The default implementation returns the default locale passed into the\n\t * corresponding constructor, or LocaleContextHolder's locale as fallback.\n\t * Can be overridden in subclasses.\n\t * @see #MessageSourceAccessor(org.springframework.context.MessageSource, java.util.Locale)\n\t * @see org.springframework.context.i18n.LocaleContextHolder#getLocale()\n\t */\n\tprotected Locale getDefaultLocale() {\n\t\treturn (this.defaultLocale != null ? this.defaultLocale : LocaleContextHolder.getLocale());\n\t}\n\n\t/**\n\t * Retrieve the message for the given code and the default Locale.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */\n\tpublic String getMessage(String code, String defaultMessage) {\n\t\tString msg = this.messageSource.getMessage(code, null, defaultMessage, getDefaultLocale());\n\t\treturn (msg != null ? msg : \"\");\n\t}\n\n\t/**\n\t * Retrieve the message for the given code and the given Locale.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @param locale the Locale in which to do lookup\n\t * @return the message\n\t */\n\tpublic String getMessage(String code, String defaultMessage, Locale locale) {\n\t\tString msg = this.messageSource.getMessage(code, null, defaultMessage, locale);\n\t\treturn (msg != null ? msg : \"\");\n\t}\n\n\t/**\n\t * Retrieve the message for the given code and the default Locale.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */\n\tpublic String getMessage(String code, Object @Nullable [] args, String defaultMessage) {\n\t\tString msg = this.messageSource.getMessage(code, args, defaultMessage, getDefaultLocale());\n\t\treturn (msg != null ? msg : \"\");\n\t}\n\n\t/**\n\t * Retrieve the message for the given code and the given Locale.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @param locale the Locale in which to do lookup\n\t * @return the message\n\t */\n\tpublic String getMessage(String code, Object @Nullable [] args, String defaultMessage, Locale locale) {\n\t\tString msg = this.messageSource.getMessage(code, args, defaultMessage, locale);\n\t\treturn (msg != null ? msg : \"\");\n\t}\n\n\t/**\n\t * Retrieve the message for the given code and the default Locale.\n\t * @param code the code of the message\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */\n\tpublic String getMessage(String code) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(code, null, getDefaultLocale());\n\t}\n\n\t/**\n\t * Retrieve the message for the given code and the given Locale.\n\t * @param code the code of the message\n\t * @param locale the Locale in which to do lookup\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */\n\tpublic String getMessage(String code, Locale locale) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(code, null, locale);\n\t}\n\n\t/**\n\t * Retrieve the message for the given code and the default Locale.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */\n\tpublic String getMessage(String code, Object @Nullable [] args) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(code, args, getDefaultLocale());\n\t}\n\n\t/**\n\t * Retrieve the message for the given code and the given Locale.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param locale the Locale in which to do lookup\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */\n\tpublic String getMessage(String code, Object @Nullable [] args, Locale locale) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(code, args, locale);\n\t}\n\n\t/**\n\t * Retrieve the given MessageSourceResolvable (for example, an ObjectError instance)\n\t * in the default Locale.\n\t * @param resolvable the MessageSourceResolvable\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */\n\tpublic String getMessage(MessageSourceResolvable resolvable) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(resolvable, getDefaultLocale());\n\t}\n\n\t/**\n\t * Retrieve the given MessageSourceResolvable (for example, an ObjectError instance)\n\t * in the given Locale.\n\t * @param resolvable the MessageSourceResolvable\n\t * @param locale the Locale in which to do lookup\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */\n\tpublic String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(resolvable, locale);\n\t}\n\n}"
  },
  "org.springframework.context.support.MessageSourceAccessor#getDefaultLocale()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the default locale to use if no explicit locale has been given.\n\t * <p>The default implementation returns the default locale passed into the\n\t * corresponding constructor, or LocaleContextHolder's locale as fallback.\n\t * Can be overridden in subclasses.\n\t * @see #MessageSourceAccessor(org.springframework.context.MessageSource, java.util.Locale)\n\t * @see org.springframework.context.i18n.LocaleContextHolder#getLocale()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "Locale",
    "signature": "protected Locale getDefaultLocale()",
    "source_code": "\tprotected Locale getDefaultLocale() {\n\t\treturn (this.defaultLocale != null ? this.defaultLocale : LocaleContextHolder.getLocale());\n\t}"
  },
  "org.springframework.context.support.MessageSourceAccessor#getMessage(code)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code and the default Locale.\n\t * @param code the code of the message\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "String",
    "signature": "public String getMessage(String code)",
    "source_code": "\tpublic String getMessage(String code) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(code, null, getDefaultLocale());\n\t}"
  },
  "org.springframework.context.support.MessageSourceAccessor#getMessage(code,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code and the default Locale.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "String",
    "signature": "public String getMessage(String code, Object @Nullable [] args)",
    "source_code": "\tpublic String getMessage(String code, Object @Nullable [] args) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(code, args, getDefaultLocale());\n\t}"
  },
  "org.springframework.context.support.MessageSourceAccessor#getMessage(code,args,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code and the default Locale.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "String",
    "signature": "public String getMessage(String code, Object @Nullable [] args, String defaultMessage)",
    "source_code": "\tpublic String getMessage(String code, Object @Nullable [] args, String defaultMessage) {\n\t\tString msg = this.messageSource.getMessage(code, args, defaultMessage, getDefaultLocale());\n\t\treturn (msg != null ? msg : \"\");\n\t}"
  },
  "org.springframework.context.support.MessageSourceAccessor#getMessage(code,args,defaultMessage,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code and the given Locale.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @param locale the Locale in which to do lookup\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "String",
    "signature": "public String getMessage(String code, Object @Nullable [] args, String defaultMessage, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, Object @Nullable [] args, String defaultMessage, Locale locale) {\n\t\tString msg = this.messageSource.getMessage(code, args, defaultMessage, locale);\n\t\treturn (msg != null ? msg : \"\");\n\t}"
  },
  "org.springframework.context.support.MessageSourceAccessor#getMessage(code,args,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code and the given Locale.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param locale the Locale in which to do lookup\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "String",
    "signature": "public String getMessage(String code, Object @Nullable [] args, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, Object @Nullable [] args, Locale locale) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(code, args, locale);\n\t}"
  },
  "org.springframework.context.support.MessageSourceAccessor#getMessage(code,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code and the default Locale.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "String",
    "signature": "public String getMessage(String code, String defaultMessage)",
    "source_code": "\tpublic String getMessage(String code, String defaultMessage) {\n\t\tString msg = this.messageSource.getMessage(code, null, defaultMessage, getDefaultLocale());\n\t\treturn (msg != null ? msg : \"\");\n\t}"
  },
  "org.springframework.context.support.MessageSourceAccessor#getMessage(code,defaultMessage,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code and the given Locale.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @param locale the Locale in which to do lookup\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "defaultMessage",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "String",
    "signature": "public String getMessage(String code, String defaultMessage, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, String defaultMessage, Locale locale) {\n\t\tString msg = this.messageSource.getMessage(code, null, defaultMessage, locale);\n\t\treturn (msg != null ? msg : \"\");\n\t}"
  },
  "org.springframework.context.support.MessageSourceAccessor#getMessage(code,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code and the given Locale.\n\t * @param code the code of the message\n\t * @param locale the Locale in which to do lookup\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "String",
    "signature": "public String getMessage(String code, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, Locale locale) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(code, null, locale);\n\t}"
  },
  "org.springframework.context.support.MessageSourceAccessor#getMessage(resolvable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given MessageSourceResolvable (for example, an ObjectError instance)\n\t * in the default Locale.\n\t * @param resolvable the MessageSourceResolvable\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(resolvable, getDefaultLocale());\n\t}"
  },
  "org.springframework.context.support.MessageSourceAccessor#getMessage(resolvable,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given MessageSourceResolvable (for example, an ObjectError instance)\n\t * in the given Locale.\n\t * @param resolvable the MessageSourceResolvable\n\t * @param locale the Locale in which to do lookup\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(resolvable, locale);\n\t}"
  },
  "org.springframework.context.support.MessageSourceSupport": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Base class for message source implementations, providing support infrastructure\n * such as {@link java.text.MessageFormat} handling but not implementing concrete\n * methods defined in the {@link org.springframework.context.MessageSource}.\n *\n * <p>{@link AbstractMessageSource} derives from this class, providing concrete\n * {@code getMessage} implementations that delegate to a central template\n * method for message code resolution.\n *\n * @author Juergen Hoeller\n * @since 2.5.5\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class MessageSourceSupport",
    "source_code": "public abstract class MessageSourceSupport {\n\n\tprivate static final MessageFormat INVALID_MESSAGE_FORMAT = new MessageFormat(\"\");\n\n\t/** Logger available to subclasses. */\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate boolean alwaysUseMessageFormat = false;\n\n\t/**\n\t * Cache to hold already generated MessageFormats per message.\n\t * Used for passed-in default messages. MessageFormats for resolved\n\t * codes are cached on a specific basis in subclasses.\n\t */\n\tprivate final Map<String, Map<Locale, MessageFormat>> messageFormatsPerMessage = new ConcurrentHashMap<>();\n\n\n\t/**\n\t * Set whether to always apply the {@code MessageFormat} rules, parsing even\n\t * messages without arguments.\n\t * <p>Default is {@code false}: Messages without arguments are by default\n\t * returned as-is, without parsing them through {@code MessageFormat}.\n\t * Set this to {@code true} to enforce {@code MessageFormat} for all messages,\n\t * expecting all message texts to be written with {@code MessageFormat} escaping.\n\t * <p>For example, {@code MessageFormat} expects a single quote to be escaped\n\t * as two adjacent single quotes ({@code \"''\"}). If your message texts are all\n\t * written with such escaping, even when not defining argument placeholders,\n\t * you need to set this flag to {@code true}. Otherwise, only message texts\n\t * with actual arguments are supposed to be written with {@code MessageFormat}\n\t * escaping.\n\t * @see java.text.MessageFormat\n\t */\n\tpublic void setAlwaysUseMessageFormat(boolean alwaysUseMessageFormat) {\n\t\tthis.alwaysUseMessageFormat = alwaysUseMessageFormat;\n\t}\n\n\t/**\n\t * Return whether to always apply the {@code MessageFormat} rules, parsing even\n\t * messages without arguments.\n\t */\n\tprotected boolean isAlwaysUseMessageFormat() {\n\t\treturn this.alwaysUseMessageFormat;\n\t}\n\n\n\t/**\n\t * Render the given default message String. The default message is\n\t * passed in as specified by the caller and can be rendered into\n\t * a fully formatted default message shown to the user.\n\t * <p>The default implementation passes the String to {@code formatMessage},\n\t * resolving any argument placeholders found in them. Subclasses may override\n\t * this method to plug in custom processing of default messages.\n\t * @param defaultMessage the passed-in default message String\n\t * @param args array of arguments that will be filled in for params within\n\t * the message, or {@code null} if none.\n\t * @param locale the Locale used for formatting\n\t * @return the rendered default message (with resolved arguments)\n\t * @see #formatMessage(String, Object[], java.util.Locale)\n\t */\n\tprotected String renderDefaultMessage(String defaultMessage, Object @Nullable [] args, Locale locale) {\n\t\treturn formatMessage(defaultMessage, args, locale);\n\t}\n\n\t/**\n\t * Format the given message String, using cached MessageFormats.\n\t * By default invoked for passed-in default messages, to resolve\n\t * any argument placeholders found in them.\n\t * @param msg the message to format\n\t * @param args array of arguments that will be filled in for params within\n\t * the message, or {@code null} if none\n\t * @param locale the Locale used for formatting\n\t * @return the formatted message (with resolved arguments)\n\t */\n\tprotected String formatMessage(String msg, Object @Nullable [] args, Locale locale) {\n\t\tif (!isAlwaysUseMessageFormat() && ObjectUtils.isEmpty(args)) {\n\t\t\treturn msg;\n\t\t}\n\t\tMap<Locale, MessageFormat> messageFormatsPerLocale = this.messageFormatsPerMessage\n\t\t\t\t.computeIfAbsent(msg, key -> new ConcurrentHashMap<>());\n\t\tMessageFormat messageFormat = messageFormatsPerLocale.computeIfAbsent(locale, key -> {\n\t\t\ttry {\n\t\t\t\treturn createMessageFormat(msg, locale);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t// Invalid message format - probably not intended for formatting,\n\t\t\t\t// rather using a message structure with no arguments involved...\n\t\t\t\tif (isAlwaysUseMessageFormat()) {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\t// Silently proceed with raw message if format not enforced...\n\t\t\t\treturn INVALID_MESSAGE_FORMAT;\n\t\t\t}\n\t\t});\n\t\tif (messageFormat == INVALID_MESSAGE_FORMAT) {\n\t\t\treturn msg;\n\t\t}\n\t\tsynchronized (messageFormat) {\n\t\t\treturn messageFormat.format(resolveArguments(args, locale));\n\t\t}\n\t}\n\n\t/**\n\t * Create a {@code MessageFormat} for the given message and Locale.\n\t * @param msg the message to create a {@code MessageFormat} for\n\t * @param locale the Locale to create a {@code MessageFormat} for\n\t * @return the {@code MessageFormat} instance\n\t */\n\tprotected MessageFormat createMessageFormat(String msg, Locale locale) {\n\t\treturn new MessageFormat(msg, locale);\n\t}\n\n\t/**\n\t * Template method for resolving argument objects.\n\t * <p>The default implementation simply returns the given argument array as-is.\n\t * Can be overridden in subclasses in order to resolve special argument types.\n\t * @param args the original argument array\n\t * @param locale the Locale to resolve against\n\t * @return the resolved argument array\n\t */\n\tprotected Object[] resolveArguments(Object @Nullable [] args, Locale locale) {\n\t\treturn (args != null ? args : new Object[0]);\n\t}\n\n}"
  },
  "org.springframework.context.support.MessageSourceSupport#createMessageFormat(msg,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@code MessageFormat} for the given message and Locale.\n\t * @param msg the message to create a {@code MessageFormat} for\n\t * @param locale the Locale to create a {@code MessageFormat} for\n\t * @return the {@code MessageFormat} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "msg",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "MessageFormat",
    "signature": "protected MessageFormat createMessageFormat(String msg, Locale locale)",
    "source_code": "\tprotected MessageFormat createMessageFormat(String msg, Locale locale) {\n\t\treturn new MessageFormat(msg, locale);\n\t}"
  },
  "org.springframework.context.support.MessageSourceSupport#formatMessage(msg,args,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Format the given message String, using cached MessageFormats.\n\t * By default invoked for passed-in default messages, to resolve\n\t * any argument placeholders found in them.\n\t * @param msg the message to format\n\t * @param args array of arguments that will be filled in for params within\n\t * the message, or {@code null} if none\n\t * @param locale the Locale used for formatting\n\t * @return the formatted message (with resolved arguments)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "msg",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "String",
    "signature": "protected String formatMessage(String msg, Object @Nullable [] args, Locale locale)",
    "source_code": "\tprotected String formatMessage(String msg, Object @Nullable [] args, Locale locale) {\n\t\tif (!isAlwaysUseMessageFormat() && ObjectUtils.isEmpty(args)) {\n\t\t\treturn msg;\n\t\t}\n\t\tMap<Locale, MessageFormat> messageFormatsPerLocale = this.messageFormatsPerMessage\n\t\t\t\t.computeIfAbsent(msg, key -> new ConcurrentHashMap<>());\n\t\tMessageFormat messageFormat = messageFormatsPerLocale.computeIfAbsent(locale, key -> {\n\t\t\ttry {\n\t\t\t\treturn createMessageFormat(msg, locale);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t// Invalid message format - probably not intended for formatting,\n\t\t\t\t// rather using a message structure with no arguments involved...\n\t\t\t\tif (isAlwaysUseMessageFormat()) {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\t// Silently proceed with raw message if format not enforced...\n\t\t\t\treturn INVALID_MESSAGE_FORMAT;\n\t\t\t}\n\t\t});\n\t\tif (messageFormat == INVALID_MESSAGE_FORMAT) {\n\t\t\treturn msg;\n\t\t}\n\t\tsynchronized (messageFormat) {\n\t\t\treturn messageFormat.format(resolveArguments(args, locale));\n\t\t}\n\t}"
  },
  "org.springframework.context.support.MessageSourceSupport#isAlwaysUseMessageFormat()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to always apply the {@code MessageFormat} rules, parsing even\n\t * messages without arguments.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "boolean",
    "signature": "protected boolean isAlwaysUseMessageFormat()",
    "source_code": "\tprotected boolean isAlwaysUseMessageFormat() {\n\t\treturn this.alwaysUseMessageFormat;\n\t}"
  },
  "org.springframework.context.support.MessageSourceSupport#renderDefaultMessage(defaultMessage,args,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Render the given default message String. The default message is\n\t * passed in as specified by the caller and can be rendered into\n\t * a fully formatted default message shown to the user.\n\t * <p>The default implementation passes the String to {@code formatMessage},\n\t * resolving any argument placeholders found in them. Subclasses may override\n\t * this method to plug in custom processing of default messages.\n\t * @param defaultMessage the passed-in default message String\n\t * @param args array of arguments that will be filled in for params within\n\t * the message, or {@code null} if none.\n\t * @param locale the Locale used for formatting\n\t * @return the rendered default message (with resolved arguments)\n\t * @see #formatMessage(String, Object[], java.util.Locale)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "defaultMessage",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "String",
    "signature": "protected String renderDefaultMessage(String defaultMessage, Object @Nullable [] args, Locale locale)",
    "source_code": "\tprotected String renderDefaultMessage(String defaultMessage, Object @Nullable [] args, Locale locale) {\n\t\treturn formatMessage(defaultMessage, args, locale);\n\t}"
  },
  "org.springframework.context.support.MessageSourceSupport#resolveArguments(args,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for resolving argument objects.\n\t * <p>The default implementation simply returns the given argument array as-is.\n\t * Can be overridden in subclasses in order to resolve special argument types.\n\t * @param args the original argument array\n\t * @param locale the Locale to resolve against\n\t * @return the resolved argument array\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "Object[]",
    "signature": "protected Object[] resolveArguments(Object @Nullable [] args, Locale locale)",
    "source_code": "\tprotected Object[] resolveArguments(Object @Nullable [] args, Locale locale) {\n\t\treturn (args != null ? args : new Object[0]);\n\t}"
  },
  "org.springframework.context.support.MessageSourceSupport#setAlwaysUseMessageFormat(alwaysUseMessageFormat)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to always apply the {@code MessageFormat} rules, parsing even\n\t * messages without arguments.\n\t * <p>Default is {@code false}: Messages without arguments are by default\n\t * returned as-is, without parsing them through {@code MessageFormat}.\n\t * Set this to {@code true} to enforce {@code MessageFormat} for all messages,\n\t * expecting all message texts to be written with {@code MessageFormat} escaping.\n\t * <p>For example, {@code MessageFormat} expects a single quote to be escaped\n\t * as two adjacent single quotes ({@code \"''\"}). If your message texts are all\n\t * written with such escaping, even when not defining argument placeholders,\n\t * you need to set this flag to {@code true}. Otherwise, only message texts\n\t * with actual arguments are supposed to be written with {@code MessageFormat}\n\t * escaping.\n\t * @see java.text.MessageFormat\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "alwaysUseMessageFormat"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void setAlwaysUseMessageFormat(boolean alwaysUseMessageFormat)",
    "source_code": "\tpublic void setAlwaysUseMessageFormat(boolean alwaysUseMessageFormat) {\n\t\tthis.alwaysUseMessageFormat = alwaysUseMessageFormat;\n\t}"
  },
  "org.springframework.core.DEFAULT_EXCLUDED_PACKAGES": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Packages that are excluded by default. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public String[] DEFAULT_EXCLUDED_PACKAGES",
    "source_code": "\tpublic static final String[] DEFAULT_EXCLUDED_PACKAGES = new String[]",
    "type": "String[]"
  },
  "org.springframework.core.KotlinReflectionParameterNameDiscoverer#getParameterNames(ctor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ctor"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "String[]",
    "signature": "public String[] getParameterNames(Constructor<?> ctor)",
    "source_code": "\tpublic String[] getParameterNames(Constructor<?> ctor) {\n\t\tif (ctor.getDeclaringClass().isEnum() || !KotlinDetector.isKotlinType(ctor.getDeclaringClass())) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(ctor);\n\t\t\treturn (function != null ? getParameterNames(function.getParameters()) : null);\n\t\t}\n\t\tcatch (UnsupportedOperationException ex) {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.core.KotlinReflectionParameterNameDiscoverer#getParameterNames(method)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "return": "String[]",
    "signature": "public String[] getParameterNames(Method method)",
    "source_code": "\tpublic String[] getParameterNames(Method method) {\n\t\tif (!KotlinDetector.isKotlinType(method.getDeclaringClass())) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\treturn (function != null ? getParameterNames(function.getParameters()) : null);\n\t\t}\n\t\tcatch (UnsupportedOperationException ex) {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.core.Nullness": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Constants that indicate nullness, as well as related utility methods.\n *\n * <p>Nullness applies to type usage, a field, a method return type, or a parameter.\n * <a href=\"https://jspecify.dev/docs/user-guide/\">JSpecify annotations</a> are\n * fully supported, as well as\n * <a href=\"https://kotlinlang.org/docs/null-safety.html\">Kotlin null safety</a>,\n * {@code @Nullable} annotations regardless of their package, and Java primitive\n * types.\n *\n * <p>JSR-305 annotations as well as Spring null safety annotations in the\n * {@code org.springframework.lang} package such as {@code @NonNullApi},\n * {@code @NonNullFields}, and {@code @NonNull} are not supported by this API.\n * However, {@code @Nullable} is supported via the package-less check. Migrating\n * to JSpecify is recommended.\n *\n * @author Sebastien Deleuze\n * @since 7.0\n */",
    "kind": "enum",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "signature": "public enum Nullness",
    "source_code": "public enum Nullness {\n\n\t/**\n\t * Unspecified nullness (Java default for non-primitive types and JSpecify\n\t * {@code @NullUnmarked} code).\n\t */\n\tUNSPECIFIED,\n\n\t/**\n\t * Can include null (typically specified with a {@code @Nullable} annotation).\n\t */\n\tNULLABLE,\n\n\t/**\n\t * Will not include null (Kotlin default and JSpecify {@code @NullMarked} code).\n\t */\n\tNON_NULL;\n\n\n\t/**\n\t * Return the nullness of the return type for the given method.\n\t * @param method the source for the method return type\n\t * @return the corresponding nullness\n\t */\n\tpublic static Nullness forMethodReturnType(Method method) {\n\t\tif (KotlinDetector.isKotlinType(method.getDeclaringClass())) {\n\t\t\treturn KotlinDelegate.forMethodReturnType(method);\n\t\t}\n\t\treturn (hasNullableAnnotation(method) ? Nullness.NULLABLE :\n\t\t\t\tjSpecifyNullness(method, method.getDeclaringClass(), method.getAnnotatedReturnType()));\n\t}\n\n\t/**\n\t * Return the nullness of the given parameter.\n\t * @param parameter the parameter descriptor\n\t * @return the corresponding nullness\n\t */\n\tpublic static Nullness forParameter(Parameter parameter) {\n\t\tif (KotlinDetector.isKotlinType(parameter.getDeclaringExecutable().getDeclaringClass())) {\n\t\t\t// TODO Optimize when kotlin-reflect provide a more direct Parameter to KParameter resolution\n\t\t\tMethodParameter methodParameter = MethodParameter.forParameter(parameter);\n\t\t\treturn KotlinDelegate.forParameter(methodParameter.getExecutable(), methodParameter.getParameterIndex());\n\t\t}\n\t\tExecutable executable = parameter.getDeclaringExecutable();\n\t\treturn (hasNullableAnnotation(parameter) ? Nullness.NULLABLE :\n\t\t\t\tjSpecifyNullness(executable, executable.getDeclaringClass(), parameter.getAnnotatedType()));\n\t}\n\n\t/**\n\t * Return the nullness of the given method parameter.\n\t * @param methodParameter the method parameter descriptor\n\t * @return the corresponding nullness\n\t */\n\tpublic static Nullness forMethodParameter(MethodParameter methodParameter) {\n\t\treturn (methodParameter.getParameterIndex() < 0 ?\n\t\t\t\tforMethodReturnType(Objects.requireNonNull(methodParameter.getMethod())) :\n\t\t\t\tforParameter(methodParameter.getParameter()));\n\t}\n\n\t/**\n\t * Return the nullness of the given field.\n\t * @param field the field descriptor\n\t * @return the corresponding nullness\n\t */\n\tpublic static Nullness forField(Field field) {\n\t\tif (KotlinDetector.isKotlinType(field.getDeclaringClass())) {\n\t\t\treturn KotlinDelegate.forField(field);\n\t\t}\n\t\treturn (hasNullableAnnotation(field) ? Nullness.NULLABLE :\n\t\t\t\tjSpecifyNullness(field, field.getDeclaringClass(), field.getAnnotatedType()));\n\t}\n\n\n\t// Check method and parameter level @Nullable annotations regardless of the package\n\t// (including Spring and JSR 305 annotations)\n\tprivate static boolean hasNullableAnnotation(AnnotatedElement element) {\n\t\tfor (Annotation annotation : element.getDeclaredAnnotations()) {\n\t\t\tif (\"Nullable\".equals(annotation.annotationType().getSimpleName())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static Nullness jSpecifyNullness(\n\t\t\tAnnotatedElement annotatedElement, Class<?> declaringClass, AnnotatedType annotatedType) {\n\n\t\tif (annotatedType.getType() instanceof Class<?> clazz && clazz.isPrimitive()) {\n\t\t\treturn (clazz != void.class ? Nullness.NON_NULL : Nullness.UNSPECIFIED);\n\t\t}\n\t\tif (annotatedType.isAnnotationPresent(Nullable.class)) {\n\t\t\treturn Nullness.NULLABLE;\n\t\t}\n\t\tif (annotatedType.isAnnotationPresent(NonNull.class)) {\n\t\t\treturn Nullness.NON_NULL;\n\t\t}\n\t\tNullness nullness = Nullness.UNSPECIFIED;\n\t\t// Package level\n\t\tPackage declaringPackage = declaringClass.getPackage();\n\t\tif (declaringPackage.isAnnotationPresent(NullMarked.class)) {\n\t\t\tnullness = Nullness.NON_NULL;\n\t\t}\n\t\t// Class level\n\t\tif (declaringClass.isAnnotationPresent(NullMarked.class)) {\n\t\t\tnullness = Nullness.NON_NULL;\n\t\t}\n\t\telse if (declaringClass.isAnnotationPresent(NullUnmarked.class)) {\n\t\t\tnullness = Nullness.UNSPECIFIED;\n\t\t}\n\t\t// Annotated element level\n\t\tif (annotatedElement.isAnnotationPresent(NullMarked.class)) {\n\t\t\tnullness = Nullness.NON_NULL;\n\t\t}\n\t\telse if (annotatedElement.isAnnotationPresent(NullUnmarked.class)) {\n\t\t\tnullness = Nullness.UNSPECIFIED;\n\t\t}\n\t\treturn nullness;\n\t}\n\n\t/**\n\t * Inner class to avoid a hard dependency on Kotlin at runtime.\n\t */\n\tprivate static class KotlinDelegate {\n\n\t\tpublic static Nullness forMethodReturnType(Method method) {\n\t\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\tif (function != null && function.getReturnType().isMarkedNullable()) {\n\t\t\t\treturn Nullness.NULLABLE;\n\t\t\t}\n\t\t\treturn Nullness.NON_NULL;\n\t\t}\n\n\t\tpublic static Nullness forParameter(Executable executable, int parameterIndex) {\n\t\t\tKFunction<?> function;\n\t\t\tPredicate<KParameter> predicate;\n\t\t\tif (executable instanceof Method method) {\n\t\t\t\tfunction = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\t\tpredicate = p -> KParameter.Kind.VALUE.equals(p.getKind());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfunction = ReflectJvmMapping.getKotlinFunction((Constructor<?>) executable);\n\t\t\t\tpredicate = p -> (KParameter.Kind.VALUE.equals(p.getKind()) ||\n\t\t\t\t\t\tKParameter.Kind.INSTANCE.equals(p.getKind()));\n\t\t\t}\n\t\t\tif (function == null) {\n\t\t\t\treturn Nullness.UNSPECIFIED;\n\t\t\t}\n\t\t\tint i = 0;\n\t\t\tfor (KParameter kParameter : function.getParameters()) {\n\t\t\t\tif (predicate.test(kParameter) && parameterIndex == i++) {\n\t\t\t\t\treturn (kParameter.getType().isMarkedNullable() ? Nullness.NULLABLE : Nullness.NON_NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Nullness.UNSPECIFIED;\n\t\t}\n\n\t\tpublic static Nullness forField(Field field) {\n\t\t\tKProperty<?> property = ReflectJvmMapping.getKotlinProperty(field);\n\t\t\tif (property != null && property.getReturnType().isMarkedNullable()) {\n\t\t\t\treturn Nullness.NULLABLE;\n\t\t\t}\n\t\t\treturn Nullness.NON_NULL;\n\t\t}\n\n\t}\n\n}"
  },
  "org.springframework.core.Nullness#forField(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "Nullness",
    "signature": "public Nullness forField(Field field)",
    "source_code": "\t\tpublic static Nullness forField(Field field) {\n\t\t\tKProperty<?> property = ReflectJvmMapping.getKotlinProperty(field);\n\t\t\tif (property != null && property.getReturnType().isMarkedNullable()) {\n\t\t\t\treturn Nullness.NULLABLE;\n\t\t\t}\n\t\t\treturn Nullness.NON_NULL;\n\t\t}"
  },
  "org.springframework.core.Nullness#forMethodParameter(methodParameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the nullness of the given method parameter.\n\t * @param methodParameter the method parameter descriptor\n\t * @return the corresponding nullness\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodParameter"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "Nullness",
    "signature": "public Nullness forMethodParameter(MethodParameter methodParameter)",
    "source_code": "\tpublic static Nullness forMethodParameter(MethodParameter methodParameter) {\n\t\treturn (methodParameter.getParameterIndex() < 0 ?\n\t\t\t\tforMethodReturnType(Objects.requireNonNull(methodParameter.getMethod())) :\n\t\t\t\tforParameter(methodParameter.getParameter()));\n\t}"
  },
  "org.springframework.core.Nullness#forMethodReturnType(method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "Nullness",
    "signature": "public Nullness forMethodReturnType(Method method)",
    "source_code": "\t\tpublic static Nullness forMethodReturnType(Method method) {\n\t\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\tif (function != null && function.getReturnType().isMarkedNullable()) {\n\t\t\t\treturn Nullness.NULLABLE;\n\t\t\t}\n\t\t\treturn Nullness.NON_NULL;\n\t\t}"
  },
  "org.springframework.core.Nullness#forParameter(executable,parameterIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executable",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "Nullness",
    "signature": "public Nullness forParameter(Executable executable, int parameterIndex)",
    "source_code": "\t\tpublic static Nullness forParameter(Executable executable, int parameterIndex) {\n\t\t\tKFunction<?> function;\n\t\t\tPredicate<KParameter> predicate;\n\t\t\tif (executable instanceof Method method) {\n\t\t\t\tfunction = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\t\tpredicate = p -> KParameter.Kind.VALUE.equals(p.getKind());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfunction = ReflectJvmMapping.getKotlinFunction((Constructor<?>) executable);\n\t\t\t\tpredicate = p -> (KParameter.Kind.VALUE.equals(p.getKind()) ||\n\t\t\t\t\t\tKParameter.Kind.INSTANCE.equals(p.getKind()));\n\t\t\t}\n\t\t\tif (function == null) {\n\t\t\t\treturn Nullness.UNSPECIFIED;\n\t\t\t}\n\t\t\tint i = 0;\n\t\t\tfor (KParameter kParameter : function.getParameters()) {\n\t\t\t\tif (predicate.test(kParameter) && parameterIndex == i++) {\n\t\t\t\t\treturn (kParameter.getType().isMarkedNullable() ? Nullness.NULLABLE : Nullness.NON_NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Nullness.UNSPECIFIED;\n\t\t}"
  },
  "org.springframework.core.Nullness#forParameter(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the nullness of the given parameter.\n\t * @param parameter the parameter descriptor\n\t * @return the corresponding nullness\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "Nullness",
    "signature": "public Nullness forParameter(Parameter parameter)",
    "source_code": "\tpublic static Nullness forParameter(Parameter parameter) {\n\t\tif (KotlinDetector.isKotlinType(parameter.getDeclaringExecutable().getDeclaringClass())) {\n\t\t\t// TODO Optimize when kotlin-reflect provide a more direct Parameter to KParameter resolution\n\t\t\tMethodParameter methodParameter = MethodParameter.forParameter(parameter);\n\t\t\treturn KotlinDelegate.forParameter(methodParameter.getExecutable(), methodParameter.getParameterIndex());\n\t\t}\n\t\tExecutable executable = parameter.getDeclaringExecutable();\n\t\treturn (hasNullableAnnotation(parameter) ? Nullness.NULLABLE :\n\t\t\t\tjSpecifyNullness(executable, executable.getDeclaringClass(), parameter.getAnnotatedType()));\n\t}"
  },
  "org.springframework.core.OverridingClassLoader": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code ClassLoader} that does <i>not</i> always delegate to the parent loader\n * as normal class loaders do. This enables, for example, instrumentation to be\n * forced in the overriding ClassLoader, or a \"throwaway\" class loading behavior\n * where selected application classes are temporarily loaded in the overriding\n * {@code ClassLoader} for introspection purposes before eventually loading an\n * instrumented version of the class in the given parent {@code ClassLoader}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 2.0.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class OverridingClassLoader",
    "source_code": "public class OverridingClassLoader extends DecoratingClassLoader {\n\n\t/** Packages that are excluded by default. */\n\tpublic static final String[] DEFAULT_EXCLUDED_PACKAGES = new String[]\n\t\t\t{\"java.\", \"javax.\", \"sun.\", \"oracle.\", \"javassist.\", \"org.aspectj.\", \"net.sf.cglib.\"};\n\n\tprivate static final String CLASS_FILE_SUFFIX = \".class\";\n\n\tstatic {\n\t\tClassLoader.registerAsParallelCapable();\n\t}\n\n\n\tprivate final @Nullable ClassLoader overrideDelegate;\n\n\n\t/**\n\t * Create a new OverridingClassLoader for the given ClassLoader.\n\t * @param parent the ClassLoader to build an overriding ClassLoader for\n\t */\n\tpublic OverridingClassLoader(@Nullable ClassLoader parent) {\n\t\tthis(parent, null);\n\t}\n\n\t/**\n\t * Create a new OverridingClassLoader for the given ClassLoader.\n\t * @param parent the ClassLoader to build an overriding ClassLoader for\n\t * @param overrideDelegate the ClassLoader to delegate to for overriding\n\t * @since 4.3\n\t */\n\tpublic OverridingClassLoader(@Nullable ClassLoader parent, @Nullable ClassLoader overrideDelegate) {\n\t\tsuper(parent);\n\t\tthis.overrideDelegate = overrideDelegate;\n\t\tfor (String packageName : DEFAULT_EXCLUDED_PACKAGES) {\n\t\t\texcludePackage(packageName);\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n\t\tif (this.overrideDelegate != null && isEligibleForOverriding(name)) {\n\t\t\treturn this.overrideDelegate.loadClass(name);\n\t\t}\n\t\treturn super.loadClass(name);\n\t}\n\n\t@Override\n\tprotected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n\t\tif (isEligibleForOverriding(name)) {\n\t\t\tClass<?> result = loadClassForOverriding(name);\n\t\t\tif (result != null) {\n\t\t\t\tif (resolve) {\n\t\t\t\t\tresolveClass(result);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn super.loadClass(name, resolve);\n\t}\n\n\t/**\n\t * Determine whether the specified class is eligible for overriding\n\t * by this class loader.\n\t * @param className the class name to check\n\t * @return whether the specified class is eligible\n\t * @see #isExcluded\n\t */\n\tprotected boolean isEligibleForOverriding(String className) {\n\t\treturn !isExcluded(className);\n\t}\n\n\t/**\n\t * Load the specified class for overriding purposes in this ClassLoader.\n\t * <p>The default implementation delegates to {@link #findLoadedClass},\n\t * {@link #loadBytesForClass} and {@link #defineClass}.\n\t * @param name the name of the class\n\t * @return the Class object, or {@code null} if no class defined for that name\n\t * @throws ClassNotFoundException if the class for the given name couldn't be loaded\n\t */\n\tprotected @Nullable Class<?> loadClassForOverriding(String name) throws ClassNotFoundException {\n\t\tClass<?> result = findLoadedClass(name);\n\t\tif (result == null) {\n\t\t\tbyte[] bytes = loadBytesForClass(name);\n\t\t\tif (bytes != null) {\n\t\t\t\tresult = defineClass(name, bytes, 0, bytes.length);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Load the defining bytes for the given class,\n\t * to be turned into a Class object through a {@link #defineClass} call.\n\t * <p>The default implementation delegates to {@link #openStreamForClass}\n\t * and {@link #transformIfNecessary}.\n\t * @param name the name of the class\n\t * @return the byte content (with transformers already applied),\n\t * or {@code null} if no class defined for that name\n\t * @throws ClassNotFoundException if the class for the given name couldn't be loaded\n\t */\n\tprotected byte @Nullable [] loadBytesForClass(String name) throws ClassNotFoundException {\n\t\tInputStream is = openStreamForClass(name);\n\t\tif (is == null) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\t// Load the raw bytes.\n\t\t\tbyte[] bytes = FileCopyUtils.copyToByteArray(is);\n\t\t\t// Transform if necessary and use the potentially transformed bytes.\n\t\t\treturn transformIfNecessary(name, bytes);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new ClassNotFoundException(\"Cannot load resource for class [\" + name + \"]\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Open an InputStream for the specified class.\n\t * <p>The default implementation loads a standard class file through\n\t * the parent ClassLoader's {@code getResourceAsStream} method.\n\t * @param name the name of the class\n\t * @return the InputStream containing the byte code for the specified class\n\t */\n\tprotected @Nullable InputStream openStreamForClass(String name) {\n\t\tString internalName = name.replace('.', '/') + CLASS_FILE_SUFFIX;\n\t\treturn getParent().getResourceAsStream(internalName);\n\t}\n\n\n\t/**\n\t * Transformation hook to be implemented by subclasses.\n\t * <p>The default implementation simply returns the given bytes as-is.\n\t * @param name the fully-qualified name of the class being transformed\n\t * @param bytes the raw bytes of the class\n\t * @return the transformed bytes (never {@code null};\n\t * same as the input bytes if the transformation produced no changes)\n\t */\n\tprotected byte[] transformIfNecessary(String name, byte[] bytes) {\n\t\treturn bytes;\n\t}\n\n}"
  },
  "org.springframework.core.OverridingClassLoader#isEligibleForOverriding(className)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the specified class is eligible for overriding\n\t * by this class loader.\n\t * @param className the class name to check\n\t * @return whether the specified class is eligible\n\t * @see #isExcluded\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "className"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "boolean",
    "signature": "protected boolean isEligibleForOverriding(String className)",
    "source_code": "\tprotected boolean isEligibleForOverriding(String className) {\n\t\treturn !isExcluded(className);\n\t}"
  },
  "org.springframework.core.OverridingClassLoader#openStreamForClass(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Open an InputStream for the specified class.\n\t * <p>The default implementation loads a standard class file through\n\t * the parent ClassLoader's {@code getResourceAsStream} method.\n\t * @param name the name of the class\n\t * @return the InputStream containing the byte code for the specified class\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "InputStream",
    "signature": "protected InputStream openStreamForClass(String name)",
    "source_code": "\tprotected @Nullable InputStream openStreamForClass(String name) {\n\t\tString internalName = name.replace('.', '/') + CLASS_FILE_SUFFIX;\n\t\treturn getParent().getResourceAsStream(internalName);\n\t}"
  },
  "org.springframework.core.OverridingClassLoader#transformIfNecessary(name,bytes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Transformation hook to be implemented by subclasses.\n\t * <p>The default implementation simply returns the given bytes as-is.\n\t * @param name the fully-qualified name of the class being transformed\n\t * @param bytes the raw bytes of the class\n\t * @return the transformed bytes (never {@code null};\n\t * same as the input bytes if the transformation produced no changes)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "bytes"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "byte[]",
    "signature": "protected byte[] transformIfNecessary(String name, byte[] bytes)",
    "source_code": "\tprotected byte[] transformIfNecessary(String name, byte[] bytes) {\n\t\treturn bytes;\n\t}"
  },
  "org.springframework.core.ParameterNameDiscoverer": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Interface to discover parameter names for methods and constructors.\n *\n * <p>Parameter name discovery is not always possible, but various strategies exist\n * &mdash; for example, using the JDK's reflection facilities for introspecting\n * parameter names (based on the \"-parameters\" compiler flag), looking for\n * {@code argNames} annotation attributes optionally configured for AspectJ\n * annotated methods, etc.\n *\n * @author Rod Johnson\n * @author Adrian Colyer\n * @since 2.0\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public interface ParameterNameDiscoverer",
    "source_code": "public interface ParameterNameDiscoverer {\n\n\t/**\n\t * Return parameter names for a method, or {@code null} if they cannot be determined.\n\t * <p>Individual entries in the array may be {@code null} if parameter names are only\n\t * available for some parameters of the given method but not for others. However,\n\t * it is recommended to use stub parameter names instead wherever feasible.\n\t * @param method the method to find parameter names for\n\t * @return an array of parameter names if the names can be resolved,\n\t * or {@code null} if they cannot\n\t */\n\t@Nullable String @Nullable [] getParameterNames(Method method);\n\n\t/**\n\t * Return parameter names for a constructor, or {@code null} if they cannot be determined.\n\t * <p>Individual entries in the array may be {@code null} if parameter names are only\n\t * available for some parameters of the given constructor but not for others. However,\n\t * it is recommended to use stub parameter names instead wherever feasible.\n\t * @param ctor the constructor to find parameter names for\n\t * @return an array of parameter names if the names can be resolved,\n\t * or {@code null} if they cannot\n\t */\n\t@Nullable String @Nullable [] getParameterNames(Constructor<?> ctor);\n\n}"
  },
  "org.springframework.core.PrioritizedParameterNameDiscoverer": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link ParameterNameDiscoverer} implementation that tries several discoverer\n * delegates in succession. Those added first in the {@code addDiscoverer} method\n * have the highest priority. If one returns {@code null}, the next will be tried.\n *\n * <p>The default behavior is to return {@code null} if no discoverer matches.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 2.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class PrioritizedParameterNameDiscoverer",
    "source_code": "public class PrioritizedParameterNameDiscoverer implements ParameterNameDiscoverer {\n\n\tprivate final List<ParameterNameDiscoverer> parameterNameDiscoverers = new ArrayList<>(2);\n\n\n\t/**\n\t * Add a further {@link ParameterNameDiscoverer} delegate to the list of\n\t * discoverers that this {@code PrioritizedParameterNameDiscoverer} checks.\n\t */\n\tpublic void addDiscoverer(ParameterNameDiscoverer pnd) {\n\t\tthis.parameterNameDiscoverers.add(pnd);\n\t}\n\n\n\t@Override\n\tpublic @Nullable String @Nullable [] getParameterNames(Method method) {\n\t\tfor (ParameterNameDiscoverer pnd : this.parameterNameDiscoverers) {\n\t\t\t@Nullable String[] result = pnd.getParameterNames(method);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic @Nullable String @Nullable [] getParameterNames(Constructor<?> ctor) {\n\t\tfor (ParameterNameDiscoverer pnd : this.parameterNameDiscoverers) {\n\t\t\t@Nullable String[] result = pnd.getParameterNames(ctor);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n}"
  },
  "org.springframework.core.PrioritizedParameterNameDiscoverer#addDiscoverer(pnd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a further {@link ParameterNameDiscoverer} delegate to the list of\n\t * discoverers that this {@code PrioritizedParameterNameDiscoverer} checks.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pnd"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "void",
    "signature": "public void addDiscoverer(ParameterNameDiscoverer pnd)",
    "source_code": "\tpublic void addDiscoverer(ParameterNameDiscoverer pnd) {\n\t\tthis.parameterNameDiscoverers.add(pnd);\n\t}"
  },
  "org.springframework.core.StandardReflectionParameterNameDiscoverer": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link ParameterNameDiscoverer} implementation which uses JDK 8's reflection facilities\n * for introspecting parameter names (based on the \"-parameters\" compiler flag).\n *\n * <p>This is a key element of {@link DefaultParameterNameDiscoverer} where it is being\n * combined with {@link KotlinReflectionParameterNameDiscoverer} if Kotlin is present.\n *\n * @author Juergen Hoeller\n * @since 4.0\n * @see java.lang.reflect.Method#getParameters()\n * @see java.lang.reflect.Parameter#getName()\n * @see KotlinReflectionParameterNameDiscoverer\n * @see DefaultParameterNameDiscoverer\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class StandardReflectionParameterNameDiscoverer",
    "source_code": "public class StandardReflectionParameterNameDiscoverer implements ParameterNameDiscoverer {\n\n\t@Override\n\tpublic @Nullable String @Nullable [] getParameterNames(Method method) {\n\t\treturn getParameterNames(method.getParameters());\n\t}\n\n\t@Override\n\tpublic @Nullable String @Nullable [] getParameterNames(Constructor<?> ctor) {\n\t\treturn getParameterNames(ctor.getParameters());\n\t}\n\n\tprivate String @Nullable [] getParameterNames(Parameter[] parameters) {\n\t\tString[] parameterNames = new String[parameters.length];\n\t\tfor (int i = 0; i < parameters.length; i++) {\n\t\t\tParameter param = parameters[i];\n\t\t\tif (!param.isNamePresent()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tparameterNames[i] = param.getName();\n\t\t}\n\t\treturn parameterNames;\n\t}\n\n}"
  },
  "org.springframework.core.annotation.<unknown>#asAnnotationAttributes(adaptations)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "adaptations"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes asAnnotationAttributes(Adapt... adaptations)",
    "source_code": "\tpublic AnnotationAttributes asAnnotationAttributes(Adapt... adaptations) {\n\t\treturn asMap(mergedAnnotation -> new AnnotationAttributes(mergedAnnotation.getType()), adaptations);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#characteristics()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "int",
    "signature": "public int characteristics()",
    "source_code": "\t\tpublic int characteristics() {\n\t\t\treturn NONNULL | IMMUTABLE;\n\t\t}"
  },
  "org.springframework.core.annotation.<unknown>#doWithAggregate(context,aggregateIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "aggregateIndex"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "MergedAnnotation<A>",
    "signature": "public MergedAnnotation<A> doWithAggregate(Object context, int aggregateIndex)",
    "source_code": "\t\tpublic @Nullable MergedAnnotation<A> doWithAggregate(Object context, int aggregateIndex) {\n\t\t\treturn this.result;\n\t\t}"
  },
  "org.springframework.core.annotation.<unknown>#doWithAnnotations(criteria,aggregateIndex,source,annotations)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "criteria",
      "aggregateIndex",
      "source",
      "annotations"
    ],
    "position": {
      "column": 1,
      "line": 453
    },
    "return": "List<Aggregate>",
    "signature": "public List<Aggregate> doWithAnnotations(Object criteria, int aggregateIndex,\n\t\t\t\t@Nullable Object source, @Nullable Annotation[] annotations)",
    "source_code": "\t\tpublic @Nullable List<Aggregate> doWithAnnotations(Object criteria, int aggregateIndex,"
  },
  "org.springframework.core.annotation.<unknown>#doWithAnnotations(requiredType,aggregateIndex,source,annotations)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "aggregateIndex",
      "source",
      "annotations"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "Boolean",
    "signature": "public Boolean doWithAnnotations(Object requiredType, int aggregateIndex,\n\t\t\t\t@Nullable Object source, @Nullable Annotation[] annotations)",
    "source_code": "\t\tpublic @Nullable Boolean doWithAnnotations(Object requiredType, int aggregateIndex,"
  },
  "org.springframework.core.annotation.<unknown>#doWithAnnotations(type,aggregateIndex,source,annotations)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "aggregateIndex",
      "source",
      "annotations"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "MergedAnnotation<A>",
    "signature": "public MergedAnnotation<A> doWithAnnotations(Object type, int aggregateIndex,\n\t\t\t\t@Nullable Object source, @Nullable Annotation[] annotations)",
    "source_code": "\t\tpublic @Nullable MergedAnnotation<A> doWithAnnotations(Object type, int aggregateIndex,"
  },
  "org.springframework.core.annotation.<unknown>#estimateSize()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "long",
    "signature": "public long estimateSize()",
    "source_code": "\t\tpublic long estimateSize() {\n\t\t\tint size = 0;\n\t\t\tfor (int i = 0; i < annotations.length; i++) {\n\t\t\t\tAnnotationTypeMappings mappings = MergedAnnotationsCollection.this.mappings[i];\n\t\t\t\tint numberOfMappings = mappings.size();\n\t\t\t\tnumberOfMappings -= Math.min(this.mappingCursors[i], mappings.size());\n\t\t\t\tsize += numberOfMappings;\n\t\t\t}\n\t\t\treturn size;\n\t\t}"
  },
  "org.springframework.core.annotation.<unknown>#filterDefaultValues()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "MergedAnnotation<A>",
    "signature": "public MergedAnnotation<A> filterDefaultValues()",
    "source_code": "\tpublic MergedAnnotation<A> filterDefaultValues() {\n\t\treturn filterAttributes(this::hasNonDefaultValue);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#finish(processResult)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "processResult"
    ],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "List<Aggregate>",
    "signature": "public List<Aggregate> finish(@Nullable List<Aggregate> processResult)",
    "source_code": "\t\tpublic @NonNull List<Aggregate> finish(@Nullable List<Aggregate> processResult) {\n\t\t\treturn this.aggregates;\n\t\t}"
  },
  "org.springframework.core.annotation.<unknown>#finish(result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result"
    ],
    "position": {
      "column": 1,
      "line": 439
    },
    "return": "MergedAnnotation<A>",
    "signature": "public MergedAnnotation<A> finish(@Nullable MergedAnnotation<A> result)",
    "source_code": "\t\tpublic @Nullable MergedAnnotation<A> finish(@Nullable MergedAnnotation<A> result) {\n\t\t\treturn (result != null ? result : this.result);\n\t\t}"
  },
  "org.springframework.core.annotation.<unknown>#get(annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "MergedAnnotation<A>",
    "signature": "public MergedAnnotation<A> get(String annotationType)",
    "source_code": "\tpublic <A extends Annotation> MergedAnnotation<A> get(String annotationType) {\n\t\treturn get(annotationType, null, null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#get(annotationType,predicate)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "predicate"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "MergedAnnotation<A>",
    "signature": "public MergedAnnotation<A> get(String annotationType,\n\t\t\t@Nullable Predicate<? super MergedAnnotation<A>> predicate)",
    "source_code": "\tpublic <A extends Annotation> MergedAnnotation<A> get(String annotationType,"
  },
  "org.springframework.core.annotation.<unknown>#get(annotationType,predicate,selector)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "predicate",
      "selector"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "MergedAnnotation<A>",
    "signature": "public MergedAnnotation<A> get(String annotationType,\n\t\t\t@Nullable Predicate<? super MergedAnnotation<A>> predicate,\n\t\t\t@Nullable MergedAnnotationSelector<A> selector)",
    "source_code": "\tpublic <A extends Annotation> MergedAnnotation<A> get(String annotationType,"
  },
  "org.springframework.core.annotation.<unknown>#getBoolean(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "boolean",
    "signature": "public boolean getBoolean(String attributeName)",
    "source_code": "\tpublic boolean getBoolean(String attributeName) {\n\t\treturn getRequiredAttributeValue(attributeName, Boolean.class);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getBooleanArray(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "boolean[]",
    "signature": "public boolean[] getBooleanArray(String attributeName)",
    "source_code": "\tpublic boolean[] getBooleanArray(String attributeName) {\n\t\treturn getRequiredAttributeValue(attributeName, boolean[].class);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getByte(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "byte",
    "signature": "public byte getByte(String attributeName)",
    "source_code": "\tpublic byte getByte(String attributeName) {\n\t\treturn getRequiredAttributeValue(attributeName, Byte.class);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getByteArray(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "byte[]",
    "signature": "public byte[] getByteArray(String attributeName)",
    "source_code": "\tpublic byte[] getByteArray(String attributeName) {\n\t\treturn getRequiredAttributeValue(attributeName, byte[].class);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getChar(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "char",
    "signature": "public char getChar(String attributeName)",
    "source_code": "\tpublic char getChar(String attributeName) {\n\t\treturn getRequiredAttributeValue(attributeName, Character.class);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getCharArray(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "char[]",
    "signature": "public char[] getCharArray(String attributeName)",
    "source_code": "\tpublic char[] getCharArray(String attributeName) {\n\t\treturn getRequiredAttributeValue(attributeName, char[].class);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getDefaultValue(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "Optional<Object>",
    "signature": "public Optional<Object> getDefaultValue(String attributeName)",
    "source_code": "\tpublic Optional<Object> getDefaultValue(String attributeName) {\n\t\treturn getDefaultValue(attributeName, Object.class);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getDouble(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "double",
    "signature": "public double getDouble(String attributeName)",
    "source_code": "\tpublic double getDouble(String attributeName) {\n\t\treturn getRequiredAttributeValue(attributeName, Double.class);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getDoubleArray(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "double[]",
    "signature": "public double[] getDoubleArray(String attributeName)",
    "source_code": "\tpublic double[] getDoubleArray(String attributeName) {\n\t\treturn getRequiredAttributeValue(attributeName, double[].class);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getEnum(attributeName,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "E",
    "signature": "public E getEnum(String attributeName, Class<E> type)",
    "source_code": "\tpublic <E extends Enum<E>> E getEnum(String attributeName, Class<E> type) {\n\t\tAssert.notNull(type, \"Type must not be null\");\n\t\treturn getRequiredAttributeValue(attributeName, type);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getEnumArray(attributeName,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "E[]",
    "signature": "public E[] getEnumArray(String attributeName, Class<E> type)",
    "source_code": "\tpublic <E extends Enum<E>> E[] getEnumArray(String attributeName, Class<E> type) {\n\t\tAssert.notNull(type, \"Type must not be null\");\n\t\treturn (E[]) getRequiredAttributeValue(attributeName, type.arrayType());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getFloat(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "float",
    "signature": "public float getFloat(String attributeName)",
    "source_code": "\tpublic float getFloat(String attributeName) {\n\t\treturn getRequiredAttributeValue(attributeName, Float.class);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getFloatArray(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "float[]",
    "signature": "public float[] getFloatArray(String attributeName)",
    "source_code": "\tpublic float[] getFloatArray(String attributeName) {\n\t\treturn getRequiredAttributeValue(attributeName, float[].class);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getInt(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "int",
    "signature": "public int getInt(String attributeName)",
    "source_code": "\tpublic int getInt(String attributeName) {\n\t\treturn getRequiredAttributeValue(attributeName, Integer.class);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getIntArray(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "int[]",
    "signature": "public int[] getIntArray(String attributeName)",
    "source_code": "\tpublic int[] getIntArray(String attributeName) {\n\t\treturn getRequiredAttributeValue(attributeName, int[].class);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getLong(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "long",
    "signature": "public long getLong(String attributeName)",
    "source_code": "\tpublic long getLong(String attributeName) {\n\t\treturn getRequiredAttributeValue(attributeName, Long.class);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getLongArray(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "long[]",
    "signature": "public long[] getLongArray(String attributeName)",
    "source_code": "\tpublic long[] getLongArray(String attributeName) {\n\t\treturn getRequiredAttributeValue(attributeName, long[].class);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getShort(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "short",
    "signature": "public short getShort(String attributeName)",
    "source_code": "\tpublic short getShort(String attributeName) {\n\t\treturn getRequiredAttributeValue(attributeName, Short.class);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getShortArray(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "short[]",
    "signature": "public short[] getShortArray(String attributeName)",
    "source_code": "\tpublic short[] getShortArray(String attributeName) {\n\t\treturn getRequiredAttributeValue(attributeName, short[].class);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getString(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "String",
    "signature": "public String getString(String attributeName)",
    "source_code": "\tpublic String getString(String attributeName) {\n\t\treturn getRequiredAttributeValue(attributeName, String.class);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getStringArray(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "String[]",
    "signature": "public String[] getStringArray(String attributeName)",
    "source_code": "\tpublic String[] getStringArray(String attributeName) {\n\t\treturn getRequiredAttributeValue(attributeName, String[].class);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getValue(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "Optional<Object>",
    "signature": "public Optional<Object> getValue(String attributeName)",
    "source_code": "\tpublic Optional<Object> getValue(String attributeName) {\n\t\treturn getValue(attributeName, Object.class);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getValue(attributeName,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "Optional<T>",
    "signature": "public Optional<T> getValue(String attributeName, Class<T> type)",
    "source_code": "\tpublic <T> Optional<T> getValue(String attributeName, Class<T> type) {\n\t\treturn Optional.ofNullable(getAttributeValue(attributeName, type));\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#hasNonDefaultValue(attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "boolean",
    "signature": "public boolean hasNonDefaultValue(String attributeName)",
    "source_code": "\tpublic boolean hasNonDefaultValue(String attributeName) {\n\t\treturn !hasDefaultValue(attributeName);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isDirectlyPresent()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 42
    },
    "return": "boolean",
    "signature": "public boolean isDirectlyPresent()",
    "source_code": "\tpublic boolean isDirectlyPresent() {\n\t\treturn isPresent() && getDistance() == 0;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isDirectlyPresent(annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "boolean",
    "signature": "public boolean isDirectlyPresent(String annotationType)",
    "source_code": "\tpublic boolean isDirectlyPresent(String annotationType) {\n\t\treturn isPresent(annotationType, true);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isMetaPresent()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "boolean",
    "signature": "public boolean isMetaPresent()",
    "source_code": "\tpublic boolean isMetaPresent() {\n\t\treturn isPresent() && getDistance() > 0;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isPresent(annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "boolean",
    "signature": "public boolean isPresent(String annotationType)",
    "source_code": "\tpublic boolean isPresent(String annotationType) {\n\t\treturn isPresent(annotationType, false);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#iterator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "Iterator<MergedAnnotation<Annotation>>",
    "signature": "public Iterator<MergedAnnotation<Annotation>> iterator()",
    "source_code": "\tpublic Iterator<MergedAnnotation<Annotation>> iterator() {\n\t\treturn Spliterators.iterator(spliterator());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#spliterator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "Spliterator<MergedAnnotation<Annotation>>",
    "signature": "public Spliterator<MergedAnnotation<Annotation>> spliterator()",
    "source_code": "\tpublic Spliterator<MergedAnnotation<Annotation>> spliterator() {\n\t\treturn spliterator(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#stream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "Stream<MergedAnnotation<Annotation>>",
    "signature": "public Stream<MergedAnnotation<Annotation>> stream()",
    "source_code": "\tpublic Stream<MergedAnnotation<Annotation>> stream() {\n\t\treturn StreamSupport.stream(spliterator(), false);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#stream(annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "Stream<MergedAnnotation<A>>",
    "signature": "public Stream<MergedAnnotation<A>> stream(String annotationType)",
    "source_code": "\tpublic <A extends Annotation> Stream<MergedAnnotation<A>> stream(String annotationType) {\n\t\treturn StreamSupport.stream(spliterator(annotationType), false);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#synthesize()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "A",
    "signature": "public A synthesize()",
    "source_code": "\tpublic A synthesize() {\n\t\tif (!isPresent()) {\n\t\t\tthrow new NoSuchElementException(\"Unable to synthesize missing annotation\");\n\t\t}\n\t\tA synthesized = this.synthesizedAnnotation;\n\t\tif (synthesized == null) {\n\t\t\tsynthesized = createSynthesizedAnnotation();\n\t\t\tthis.synthesizedAnnotation = synthesized;\n\t\t}\n\t\treturn synthesized;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#synthesize(condition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "condition"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "Optional<A>",
    "signature": "public Optional<A> synthesize(Predicate<? super MergedAnnotation<A>> condition)",
    "source_code": "\tpublic Optional<A> synthesize(Predicate<? super MergedAnnotation<A>> condition)"
  },
  "org.springframework.core.annotation.<unknown>#tryAdvance(action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "action"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "boolean",
    "signature": "public boolean tryAdvance(Consumer<? super MergedAnnotation<A>> action)",
    "source_code": "\t\tpublic boolean tryAdvance(Consumer<? super MergedAnnotation<A>> action) {\n\t\t\tint lowestDistance = Integer.MAX_VALUE;\n\t\t\tint annotationResult = -1;\n\t\t\tfor (int annotationIndex = 0; annotationIndex < annotations.length; annotationIndex++) {\n\t\t\t\tAnnotationTypeMapping mapping = getNextSuitableMapping(annotationIndex);\n\t\t\t\tif (mapping != null && mapping.getDistance() < lowestDistance) {\n\t\t\t\t\tannotationResult = annotationIndex;\n\t\t\t\t\tlowestDistance = mapping.getDistance();\n\t\t\t\t}\n\t\t\t\tif (lowestDistance == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (annotationResult != -1) {\n\t\t\t\tMergedAnnotation<A> mergedAnnotation = createMergedAnnotationIfPossible(\n\t\t\t\t\t\tannotationResult, this.mappingCursors[annotationResult]);\n\t\t\t\tthis.mappingCursors[annotationResult]++;\n\t\t\t\tif (mergedAnnotation == null) {\n\t\t\t\t\treturn tryAdvance(action);\n\t\t\t\t}\n\t\t\t\taction.accept(mergedAnnotation);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.core.annotation.<unknown>#trySplit()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "Spliterator<MergedAnnotation<A>>",
    "signature": "public Spliterator<MergedAnnotation<A>> trySplit()",
    "source_code": "\t\tpublic @Nullable Spliterator<MergedAnnotation<A>> trySplit() {\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * General utility methods for finding annotations, meta-annotations, and\n * repeatable annotations on {@link AnnotatedElement AnnotatedElements}.\n *\n * <p>{@code AnnotatedElementUtils} defines the public API for Spring's\n * meta-annotation programming model with support for <em>annotation attribute\n * overrides</em>. If you do not need support for annotation attribute\n * overrides, consider using {@link AnnotationUtils} instead.\n *\n * <p>Note that the features of this class are not provided by the JDK's\n * introspection facilities themselves.\n *\n * <h3>Annotation Attribute Overrides</h3>\n * <p>Support for meta-annotations with <em>attribute overrides</em> in\n * <em>composed annotations</em> is provided by all variants of the\n * {@code getMergedAnnotationAttributes()}, {@code getMergedAnnotation()},\n * {@code getAllMergedAnnotations()}, {@code getMergedRepeatableAnnotations()},\n * {@code findMergedAnnotationAttributes()}, {@code findMergedAnnotation()},\n * {@code findAllMergedAnnotations()}, and {@code findMergedRepeatableAnnotations()}\n * methods.\n *\n * <h3>Find vs. Get Semantics</h3>\n * <p>The search algorithms used by methods in this class follow either\n * <em>find</em> or <em>get</em> semantics. Consult the javadocs for each\n * individual method for details on which search algorithm is used.\n *\n * <p><strong>Get semantics</strong> are limited to searching for annotations\n * that are either <em>present</em> on an {@code AnnotatedElement} (i.e. declared\n * locally or {@linkplain java.lang.annotation.Inherited inherited}) or declared\n * within the annotation hierarchy <em>above</em> the {@code AnnotatedElement}.\n *\n * <p><strong>Find semantics</strong> are much more exhaustive, providing\n * <em>get semantics</em> plus support for the following:\n *\n * <ul>\n * <li>Searching on interfaces, if the annotated element is a class\n * <li>Searching on superclasses, if the annotated element is a class\n * <li>Resolving bridged methods, if the annotated element is a method\n * <li>Searching on methods in interfaces, if the annotated element is a method\n * <li>Searching on methods in superclasses, if the annotated element is a method\n * </ul>\n *\n * <h3>Support for {@code @Inherited}</h3>\n * <p>Methods following <em>get semantics</em> will honor the contract of Java's\n * {@link java.lang.annotation.Inherited @Inherited} annotation except that locally\n * declared annotations (including custom composed annotations) will be favored over\n * inherited annotations. In contrast, methods following <em>find semantics</em>\n * will completely ignore the presence of {@code @Inherited} since the <em>find</em>\n * search algorithm manually traverses type and method hierarchies and thereby\n * implicitly supports annotation inheritance without a need for {@code @Inherited}.\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 4.0\n * @see AliasFor\n * @see AnnotationAttributes\n * @see AnnotationUtils\n * @see BridgeMethodResolver\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "signature": "public class AnnotatedElementUtils",
    "source_code": "public abstract class AnnotatedElementUtils {\n\n\t/**\n\t * Build an adapted {@link AnnotatedElement} for the given annotations,\n\t * typically for use with other methods on {@link AnnotatedElementUtils}.\n\t * @param annotations the annotations to expose through the {@code AnnotatedElement}\n\t * @since 4.3\n\t */\n\tpublic static AnnotatedElement forAnnotations(Annotation... annotations) {\n\t\treturn new AnnotatedElementForAnnotations(annotations);\n\t}\n\n\t/**\n\t * Get the fully qualified class names of all meta-annotation types\n\t * <em>present</em> on the annotation (of the specified {@code annotationType})\n\t * on the supplied {@link AnnotatedElement}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type on which to find meta-annotations\n\t * @return the names of all meta-annotations present on the annotation,\n\t * or an empty set if not found\n\t * @since 4.2\n\t * @see #getMetaAnnotationTypes(AnnotatedElement, String)\n\t * @see #hasMetaAnnotationTypes\n\t */\n\tpublic static Set<String> getMetaAnnotationTypes(AnnotatedElement element,\n\t\t\tClass<? extends Annotation> annotationType) {\n\n\t\treturn getMetaAnnotationTypes(element, element.getAnnotation(annotationType));\n\t}\n\n\t/**\n\t * Get the fully qualified class names of all meta-annotation\n\t * types <em>present</em> on the annotation (of the specified\n\t * {@code annotationName}) on the supplied {@link AnnotatedElement}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation\n\t * type on which to find meta-annotations\n\t * @return the names of all meta-annotations present on the annotation,\n\t * or an empty set if none found\n\t * @see #getMetaAnnotationTypes(AnnotatedElement, Class)\n\t * @see #hasMetaAnnotationTypes\n\t */\n\tpublic static Set<String> getMetaAnnotationTypes(AnnotatedElement element, String annotationName) {\n\t\tfor (Annotation annotation : element.getAnnotations()) {\n\t\t\tif (annotation.annotationType().getName().equals(annotationName)) {\n\t\t\t\treturn getMetaAnnotationTypes(element, annotation);\n\t\t\t}\n\t\t}\n\t\treturn Collections.emptySet();\n\t}\n\n\tprivate static Set<String> getMetaAnnotationTypes(AnnotatedElement element, @Nullable Annotation annotation) {\n\t\tif (annotation == null) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t\treturn getAnnotations(annotation.annotationType()).stream()\n\t\t\t\t.map(mergedAnnotation -> mergedAnnotation.getType().getName())\n\t\t\t\t.collect(Collectors.toCollection(LinkedHashSet::new));\n\t}\n\n\t/**\n\t * Determine if the supplied {@link AnnotatedElement} is annotated with\n\t * a <em>composed annotation</em> that is meta-annotated with an\n\t * annotation of the specified {@code annotationType}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the meta-annotation type to find\n\t * @return {@code true} if a matching meta-annotation is present\n\t * @since 4.2.3\n\t * @see #getMetaAnnotationTypes\n\t */\n\tpublic static boolean hasMetaAnnotationTypes(AnnotatedElement element, Class<? extends Annotation> annotationType) {\n\t\treturn getAnnotations(element).stream(annotationType).anyMatch(MergedAnnotation::isMetaPresent);\n\t}\n\n\t/**\n\t * Determine if the supplied {@link AnnotatedElement} is annotated with a\n\t * <em>composed annotation</em> that is meta-annotated with an annotation\n\t * of the specified {@code annotationName}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the\n\t * meta-annotation type to find\n\t * @return {@code true} if a matching meta-annotation is present\n\t * @see #getMetaAnnotationTypes\n\t */\n\tpublic static boolean hasMetaAnnotationTypes(AnnotatedElement element, String annotationName) {\n\t\treturn getAnnotations(element).stream(annotationName).anyMatch(MergedAnnotation::isMetaPresent);\n\t}\n\n\t/**\n\t * Determine if an annotation of the specified {@code annotationType}\n\t * is <em>present</em> on the supplied {@link AnnotatedElement} or\n\t * within the annotation hierarchy <em>above</em> the specified element.\n\t * <p>If this method returns {@code true}, then {@link #getMergedAnnotationAttributes}\n\t * will return a non-null value.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return {@code true} if a matching annotation is present\n\t * @since 4.2.3\n\t * @see #hasAnnotation(AnnotatedElement, Class)\n\t */\n\tpublic static boolean isAnnotated(AnnotatedElement element, Class<? extends Annotation> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.isAnnotationPresent(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn getAnnotations(element).isPresent(annotationType);\n\t}\n\n\t/**\n\t * Determine if an annotation of the specified {@code annotationName} is\n\t * <em>present</em> on the supplied {@link AnnotatedElement} or within the\n\t * annotation hierarchy <em>above</em> the specified element.\n\t * <p>If this method returns {@code true}, then {@link #getMergedAnnotationAttributes}\n\t * will return a non-null value.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @return {@code true} if a matching annotation is present\n\t */\n\tpublic static boolean isAnnotated(AnnotatedElement element, String annotationName) {\n\t\treturn getAnnotations(element).isPresent(annotationName);\n\t}\n\n\t/**\n\t * Get the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t */\n\tpublic static @Nullable AnnotationAttributes getMergedAnnotationAttributes(\n\t\t\tAnnotatedElement element, Class<? extends Annotation> annotationType) {\n\n\t\tMergedAnnotation<?> mergedAnnotation = getAnnotations(element)\n\t\t\t\t.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared());\n\t\treturn getAnnotationAttributes(mergedAnnotation, false, false);\n\t}\n\n\t/**\n\t * Get the first annotation of the specified {@code annotationName} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)},\n\t * supplying {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String)\n\t */\n\tpublic static @Nullable AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName) {\n\n\t\treturn getMergedAnnotationAttributes(element, annotationName, false, false);\n\t}\n\n\t/**\n\t * Get the first annotation of the specified {@code annotationName} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>Attributes from lower levels in the annotation hierarchy override attributes\n\t * of the same name from higher levels, and {@link AliasFor @AliasFor} semantics are\n\t * fully supported, both within a single annotation and within the annotation hierarchy.\n\t * <p>In contrast to {@link #getAllAnnotationAttributes}, the search algorithm used by\n\t * this method will stop searching the annotation hierarchy once the first annotation\n\t * of the specified {@code annotationName} has been found. As a consequence,\n\t * additional annotations of the specified {@code annotationName} will be ignored.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into Strings or to\n\t * preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances\n\t * into {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t */\n\tpublic static @Nullable AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\n\n\t\tMergedAnnotation<?> mergedAnnotation = getAnnotations(element)\n\t\t\t\t.get(annotationName, null, MergedAnnotationSelectors.firstDirectlyDeclared());\n\t\treturn getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);\n\t}\n\n\t/**\n\t * Get the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t */\n\tpublic static <A extends Annotation> @Nullable A getMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.getDeclaredAnnotation(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn getAnnotations(element)\n\t\t\t\t.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared())\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}\n\n\t/**\n\t * Get <strong>all</strong> annotations of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 4.3\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String)\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t */\n\tpublic static <A extends Annotation> Set<A> getAllMergedAnnotations(\n\t\t\tAnnotatedElement element, Class<A> annotationType) {\n\n\t\treturn getAnnotations(element).stream(annotationType)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}\n\n\t/**\n\t * Get <strong>all</strong> annotations of the specified {@code annotationTypes}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the\n\t * annotation hierarchy and synthesize the results back into an annotation\n\t * of the corresponding {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationTypes the annotation types to find\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 5.1\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t */\n\tpublic static Set<Annotation> getAllMergedAnnotations(AnnotatedElement element,\n\t\t\tSet<Class<? extends Annotation>> annotationTypes) {\n\n\t\treturn getAnnotations(element).stream()\n\t\t\t\t.filter(MergedAnnotationPredicates.typeIn(annotationTypes))\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}\n\n\t/**\n\t * Get all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>The container type that holds the repeatable annotations will be looked up\n\t * via {@link java.lang.annotation.Repeatable}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @since 4.3\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t * @see #getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t */\n\tpublic static <A extends Annotation> Set<A> getMergedRepeatableAnnotations(\n\t\t\tAnnotatedElement element, Class<A> annotationType) {\n\n\t\treturn getMergedRepeatableAnnotations(element, annotationType, null);\n\t}\n\n\t/**\n\t * Get all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * <p><strong>WARNING</strong>: if the supplied {@code containerType} is not\n\t * {@code null}, the search will be restricted to supporting only repeatable\n\t * annotations whose container is the supplied {@code containerType}. This\n\t * prevents the search from finding repeatable annotations declared as\n\t * meta-annotations on other types of repeatable annotations. If you need to\n\t * support such a use case, favor {@link #getMergedRepeatableAnnotations(AnnotatedElement, Class)}\n\t * over this method or alternatively use the {@link MergedAnnotations} API\n\t * directly in conjunction with {@link RepeatableContainers} that are\n\t * {@linkplain RepeatableContainers#and(Class, Class) composed} to support\n\t * multiple repeatable annotation types.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @param containerType the type of the container that holds the annotations;\n\t * may be {@code null} if the container type should be looked up via\n\t * {@link java.lang.annotation.Repeatable}\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @throws AnnotationConfigurationException if the supplied {@code containerType}\n\t * is not a valid container annotation for the supplied {@code annotationType}\n\t * @since 4.3\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t */\n\tpublic static <A extends Annotation> Set<A> getMergedRepeatableAnnotations(\n\t\t\tAnnotatedElement element, Class<A> annotationType,\n\t\t\t@Nullable Class<? extends Annotation> containerType) {\n\n\t\treturn getRepeatableAnnotations(element, containerType, annotationType)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}\n\n\t/**\n\t * Get the annotation attributes of <strong>all</strong> annotations of the specified\n\t * {@code annotationName} in the annotation hierarchy above the supplied\n\t * {@link AnnotatedElement} and store the results in a {@link MultiValueMap}.\n\t * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},\n\t * this method does <em>not</em> support attribute overrides.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation\n\t * attributes from all annotations found, or {@code null} if not found\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t */\n\tpublic static MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(\n\t\t\tAnnotatedElement element, String annotationName) {\n\n\t\treturn getAllAnnotationAttributes(element, annotationName, false, false);\n\t}\n\n\t/**\n\t * Get the annotation attributes of <strong>all</strong> annotations of\n\t * the specified {@code annotationName} in the annotation hierarchy above\n\t * the supplied {@link AnnotatedElement} and store the results in a\n\t * {@link MultiValueMap}.\n\t * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},\n\t * this method does <em>not</em> support attribute overrides.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into Strings or to\n\t * preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\n\t * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation\n\t * attributes from all annotations found, or {@code null} if not found\n\t */\n\tpublic static MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName, final boolean classValuesAsString, final boolean nestedAnnotationsAsMap) {\n\n\t\tAdapt[] adaptations = Adapt.values(classValuesAsString, nestedAnnotationsAsMap);\n\t\treturn getAnnotations(element).stream(annotationName)\n\t\t\t\t.filter(MergedAnnotationPredicates.unique(MergedAnnotation::getMetaTypes))\n\t\t\t\t.map(MergedAnnotation::withNonMergedAttributes)\n\t\t\t\t.collect(MergedAnnotationCollectors.toMultiValueMap(AnnotatedElementUtils::nullIfEmpty, adaptations));\n\t}\n\n\t/**\n\t * Determine if an annotation of the specified {@code annotationType}\n\t * is <em>available</em> on the supplied {@link AnnotatedElement} or\n\t * within the annotation hierarchy <em>above</em> the specified element.\n\t * <p>If this method returns {@code true}, then {@link #findMergedAnnotationAttributes}\n\t * will return a non-null value.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return {@code true} if a matching annotation is present\n\t * @since 4.3\n\t * @see #isAnnotated(AnnotatedElement, Class)\n\t */\n\tpublic static boolean hasAnnotation(AnnotatedElement element, Class<? extends Annotation> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.isAnnotationPresent(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn findAnnotations(element).isPresent(annotationType);\n\t}\n\n\t/**\n\t * Find the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>Attributes from lower levels in the annotation hierarchy override\n\t * attributes of the same name from higher levels, and\n\t * {@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>In contrast to {@link #getAllAnnotationAttributes}, the search algorithm\n\t * used by this method will stop searching the annotation hierarchy once the\n\t * first annotation of the specified {@code annotationType} has been found.\n\t * As a consequence, additional annotations of the specified\n\t * {@code annotationType} will be ignored.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into\n\t * Strings or to preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\n\t * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t */\n\tpublic static @Nullable AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,\n\t\t\tClass<? extends Annotation> annotationType, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\n\n\t\tMergedAnnotation<?> mergedAnnotation = findAnnotations(element)\n\t\t\t\t.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared());\n\t\treturn getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);\n\t}\n\n\t/**\n\t * Find the first annotation of the specified {@code annotationName} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>Attributes from lower levels in the annotation hierarchy override\n\t * attributes of the same name from higher levels, and\n\t * {@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>In contrast to {@link #getAllAnnotationAttributes}, the search\n\t * algorithm used by this method will stop searching the annotation\n\t * hierarchy once the first annotation of the specified\n\t * {@code annotationName} has been found. As a consequence, additional\n\t * annotations of the specified {@code annotationName} will be ignored.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into Strings or to\n\t * preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\n\t * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t */\n\tpublic static @Nullable AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\n\n\t\tMergedAnnotation<?> mergedAnnotation = findAnnotations(element)\n\t\t\t\t.get(annotationName, null, MergedAnnotationSelectors.firstDirectlyDeclared());\n\t\treturn getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);\n\t}\n\n\t/**\n\t * Find the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, Class)\n\t */\n\tpublic static <A extends Annotation> @Nullable A findMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.getDeclaredAnnotation(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn findAnnotations(element)\n\t\t\t\t.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared())\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}\n\n\t/**\n\t * Find <strong>all</strong> annotations of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 4.3\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t */\n\tpublic static <A extends Annotation> Set<A> findAllMergedAnnotations(AnnotatedElement element, Class<A> annotationType) {\n\t\treturn findAnnotations(element).stream(annotationType)\n\t\t\t\t.sorted(highAggregateIndexesFirst())\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}\n\n\t/**\n\t * Find <strong>all</strong> annotations of the specified {@code annotationTypes}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the\n\t * annotation hierarchy and synthesize the results back into an annotation\n\t * of the corresponding {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationTypes the annotation types to find\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 5.1\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t */\n\tpublic static Set<Annotation> findAllMergedAnnotations(AnnotatedElement element, Set<Class<? extends Annotation>> annotationTypes) {\n\t\treturn findAnnotations(element).stream()\n\t\t\t\t.filter(MergedAnnotationPredicates.typeIn(annotationTypes))\n\t\t\t\t.sorted(highAggregateIndexesFirst())\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}\n\n\t/**\n\t * Find all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>The container type that holds the repeatable annotations will be looked up\n\t * via {@link java.lang.annotation.Repeatable}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @since 4.3\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t * @see #findMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t */\n\tpublic static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,\n\t\t\tClass<A> annotationType) {\n\n\t\treturn findMergedRepeatableAnnotations(element, annotationType, null);\n\t}\n\n\t/**\n\t * Find all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * <p><strong>WARNING</strong>: if the supplied {@code containerType} is not\n\t * {@code null}, the search will be restricted to supporting only repeatable\n\t * annotations whose container is the supplied {@code containerType}. This\n\t * prevents the search from finding repeatable annotations declared as\n\t * meta-annotations on other types of repeatable annotations. If you need to\n\t * support such a use case, favor {@link #findMergedRepeatableAnnotations(AnnotatedElement, Class)}\n\t * over this method or alternatively use the {@link MergedAnnotations} API\n\t * directly in conjunction with {@link RepeatableContainers} that are\n\t * {@linkplain RepeatableContainers#and(Class, Class) composed} to support\n\t * multiple repeatable annotation types.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @param containerType the type of the container that holds the annotations;\n\t * may be {@code null} if the container type should be looked up via\n\t * {@link java.lang.annotation.Repeatable}\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @throws AnnotationConfigurationException if the supplied {@code containerType}\n\t * is not a valid container annotation for the supplied {@code annotationType}\n\t * @since 4.3\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t */\n\tpublic static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,\n\t\t\tClass<A> annotationType, @Nullable Class<? extends Annotation> containerType) {\n\n\t\treturn findRepeatableAnnotations(element, containerType, annotationType)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.sorted(highAggregateIndexesFirst())\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}\n\n\tprivate static MergedAnnotations getAnnotations(AnnotatedElement element) {\n\t\treturn MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none());\n\t}\n\n\tprivate static MergedAnnotations getRepeatableAnnotations(AnnotatedElement element,\n\t\t\t@Nullable Class<? extends Annotation> containerType, Class<? extends Annotation> annotationType) {\n\n\t\tRepeatableContainers repeatableContainers;\n\t\tif (containerType == null) {\n\t\t\t// Invoke RepeatableContainers.of() in order to adhere to the contract of\n\t\t\t// getMergedRepeatableAnnotations() which states that an IllegalArgumentException\n\t\t\t// will be thrown if the container cannot be resolved.\n\t\t\t//\n\t\t\t// In any case, we use standardRepeatables() in order to support repeatable\n\t\t\t// annotations on other types of repeatable annotations (i.e., nested repeatable\n\t\t\t// annotation types).\n\t\t\t//\n\t\t\t// See https://github.com/spring-projects/spring-framework/issues/20279\n\t\t\tRepeatableContainers.of(annotationType, null);\n\t\t\trepeatableContainers = RepeatableContainers.standardRepeatables();\n\t\t}\n\t\telse {\n\t\t\trepeatableContainers = RepeatableContainers.of(annotationType, containerType);\n\t\t}\n\t\treturn MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS, repeatableContainers);\n\t}\n\n\tprivate static MergedAnnotations findAnnotations(AnnotatedElement element) {\n\t\treturn MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none());\n\t}\n\n\tprivate static MergedAnnotations findRepeatableAnnotations(AnnotatedElement element,\n\t\t\t@Nullable Class<? extends Annotation> containerType, Class<? extends Annotation> annotationType) {\n\n\t\tRepeatableContainers repeatableContainers;\n\t\tif (containerType == null) {\n\t\t\t// Invoke RepeatableContainers.of() in order to adhere to the contract of\n\t\t\t// findMergedRepeatableAnnotations() which states that an IllegalArgumentException\n\t\t\t// will be thrown if the container cannot be resolved.\n\t\t\t//\n\t\t\t// In any case, we use standardRepeatables() in order to support repeatable\n\t\t\t// annotations on other types of repeatable annotations (i.e., nested repeatable\n\t\t\t// annotation types).\n\t\t\t//\n\t\t\t// See https://github.com/spring-projects/spring-framework/issues/20279\n\t\t\tRepeatableContainers.of(annotationType, null);\n\t\t\trepeatableContainers = RepeatableContainers.standardRepeatables();\n\t\t}\n\t\telse {\n\t\t\trepeatableContainers = RepeatableContainers.of(annotationType, containerType);\n\t\t}\n\t\treturn MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY, repeatableContainers);\n\t}\n\n\tprivate static @Nullable MultiValueMap<String, Object> nullIfEmpty(MultiValueMap<String, Object> map) {\n\t\treturn (map.isEmpty() ? null : map);\n\t}\n\n\tprivate static <A extends Annotation> Comparator<MergedAnnotation<A>> highAggregateIndexesFirst() {\n\t\treturn Comparator.<MergedAnnotation<A>> comparingInt(MergedAnnotation::getAggregateIndex).reversed();\n\t}\n\n\tprivate static @Nullable AnnotationAttributes getAnnotationAttributes(MergedAnnotation<?> annotation,\n\t\t\tboolean classValuesAsString, boolean nestedAnnotationsAsMap) {\n\n\t\tif (!annotation.isPresent()) {\n\t\t\treturn null;\n\t\t}\n\t\treturn annotation.asAnnotationAttributes(Adapt.values(classValuesAsString, nestedAnnotationsAsMap));\n\t}\n\n\n\t/**\n\t * Adapted {@link AnnotatedElement} that holds specific annotations.\n\t */\n\tprivate static class AnnotatedElementForAnnotations implements AnnotatedElement {\n\n\t\tprivate final Annotation[] annotations;\n\n\t\tAnnotatedElementForAnnotations(Annotation... annotations) {\n\t\t\tthis.annotations = annotations;\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Annotation> @Nullable T getAnnotation(Class<T> annotationClass) {\n\t\t\tfor (Annotation annotation : this.annotations) {\n\t\t\t\tif (annotation.annotationType() == annotationClass) {\n\t\t\t\t\treturn (T) annotation;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getAnnotations() {\n\t\t\treturn this.annotations.clone();\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getDeclaredAnnotations() {\n\t\t\treturn this.annotations.clone();\n\t\t}\n\n\t}\n\n}"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#findAllMergedAnnotations(element,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find <strong>all</strong> annotations of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 4.3\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 658
    },
    "return": "Set<A>",
    "signature": "public Set<A> findAllMergedAnnotations(AnnotatedElement element, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> findAllMergedAnnotations(AnnotatedElement element, Class<A> annotationType) {\n\t\treturn findAnnotations(element).stream(annotationType)\n\t\t\t\t.sorted(highAggregateIndexesFirst())\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#findAllMergedAnnotations(element,annotationTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find <strong>all</strong> annotations of the specified {@code annotationTypes}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the\n\t * annotation hierarchy and synthesize the results back into an annotation\n\t * of the corresponding {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationTypes the annotation types to find\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 5.1\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationTypes"
    ],
    "position": {
      "column": 1,
      "line": 682
    },
    "return": "Set<Annotation>",
    "signature": "public Set<Annotation> findAllMergedAnnotations(AnnotatedElement element, Set<Class<? extends Annotation>> annotationTypes)",
    "source_code": "\tpublic static Set<Annotation> findAllMergedAnnotations(AnnotatedElement element, Set<Class<? extends Annotation>> annotationTypes) {\n\t\treturn findAnnotations(element).stream()\n\t\t\t\t.filter(MergedAnnotationPredicates.typeIn(annotationTypes))\n\t\t\t\t.sorted(highAggregateIndexesFirst())\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#findMergedAnnotation(element,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 627
    },
    "return": "A",
    "signature": "public A findMergedAnnotation(AnnotatedElement element, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> @Nullable A findMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.getDeclaredAnnotation(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn findAnnotations(element)\n\t\t\t\t.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared())\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#findMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the first annotation of the specified {@code annotationName} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>Attributes from lower levels in the annotation hierarchy override\n\t * attributes of the same name from higher levels, and\n\t * {@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>In contrast to {@link #getAllAnnotationAttributes}, the search\n\t * algorithm used by this method will stop searching the annotation\n\t * hierarchy once the first annotation of the specified\n\t * {@code annotationName} has been found. As a consequence, additional\n\t * annotations of the specified {@code annotationName} will be ignored.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into Strings or to\n\t * preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\n\t * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationName",
      "classValuesAsString",
      "nestedAnnotationsAsMap"
    ],
    "position": {
      "column": 1,
      "line": 601
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap)",
    "source_code": "\tpublic static @Nullable AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#findMergedAnnotationAttributes(element,annotationType,classValuesAsString,nestedAnnotationsAsMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>Attributes from lower levels in the annotation hierarchy override\n\t * attributes of the same name from higher levels, and\n\t * {@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>In contrast to {@link #getAllAnnotationAttributes}, the search algorithm\n\t * used by this method will stop searching the annotation hierarchy once the\n\t * first annotation of the specified {@code annotationType} has been found.\n\t * As a consequence, additional annotations of the specified\n\t * {@code annotationType} will be ignored.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into\n\t * Strings or to preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\n\t * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType",
      "classValuesAsString",
      "nestedAnnotationsAsMap"
    ],
    "position": {
      "column": 1,
      "line": 566
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,\n\t\t\tClass<? extends Annotation> annotationType, boolean classValuesAsString, boolean nestedAnnotationsAsMap)",
    "source_code": "\tpublic static @Nullable AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#findMergedRepeatableAnnotations(element,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>The container type that holds the repeatable annotations will be looked up\n\t * via {@link java.lang.annotation.Repeatable}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @since 4.3\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t * @see #findMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 713
    },
    "return": "Set<A>",
    "signature": "public Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,\n\t\t\tClass<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#findMergedRepeatableAnnotations(element,annotationType,containerType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * <p><strong>WARNING</strong>: if the supplied {@code containerType} is not\n\t * {@code null}, the search will be restricted to supporting only repeatable\n\t * annotations whose container is the supplied {@code containerType}. This\n\t * prevents the search from finding repeatable annotations declared as\n\t * meta-annotations on other types of repeatable annotations. If you need to\n\t * support such a use case, favor {@link #findMergedRepeatableAnnotations(AnnotatedElement, Class)}\n\t * over this method or alternatively use the {@link MergedAnnotations} API\n\t * directly in conjunction with {@link RepeatableContainers} that are\n\t * {@linkplain RepeatableContainers#and(Class, Class) composed} to support\n\t * multiple repeatable annotation types.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @param containerType the type of the container that holds the annotations;\n\t * may be {@code null} if the container type should be looked up via\n\t * {@link java.lang.annotation.Repeatable}\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @throws AnnotationConfigurationException if the supplied {@code containerType}\n\t * is not a valid container annotation for the supplied {@code annotationType}\n\t * @since 4.3\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType",
      "containerType"
    ],
    "position": {
      "column": 1,
      "line": 755
    },
    "return": "Set<A>",
    "signature": "public Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,\n\t\t\tClass<A> annotationType, @Nullable Class<? extends Annotation> containerType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#forAnnotations(annotations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build an adapted {@link AnnotatedElement} for the given annotations,\n\t * typically for use with other methods on {@link AnnotatedElementUtils}.\n\t * @param annotations the annotations to expose through the {@code AnnotatedElement}\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotations"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "AnnotatedElement",
    "signature": "public AnnotatedElement forAnnotations(Annotation... annotations)",
    "source_code": "\tpublic static AnnotatedElement forAnnotations(Annotation... annotations) {\n\t\treturn new AnnotatedElementForAnnotations(annotations);\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#getAllAnnotationAttributes(element,annotationName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the annotation attributes of <strong>all</strong> annotations of the specified\n\t * {@code annotationName} in the annotation hierarchy above the supplied\n\t * {@link AnnotatedElement} and store the results in a {@link MultiValueMap}.\n\t * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},\n\t * this method does <em>not</em> support attribute overrides.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation\n\t * attributes from all annotations found, or {@code null} if not found\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationName"
    ],
    "position": {
      "column": 1,
      "line": 481
    },
    "return": "Object>",
    "signature": "public Object> getAllAnnotationAttributes(AnnotatedElement element, String annotationName)",
    "source_code": "\tpublic static MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes("
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#getAllAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the annotation attributes of <strong>all</strong> annotations of\n\t * the specified {@code annotationName} in the annotation hierarchy above\n\t * the supplied {@link AnnotatedElement} and store the results in a\n\t * {@link MultiValueMap}.\n\t * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},\n\t * this method does <em>not</em> support attribute overrides.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into Strings or to\n\t * preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\n\t * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation\n\t * attributes from all annotations found, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationName",
      "classValuesAsString",
      "nestedAnnotationsAsMap"
    ],
    "position": {
      "column": 1,
      "line": 505
    },
    "return": "Object>",
    "signature": "public Object> getAllAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName, final boolean classValuesAsString, final boolean nestedAnnotationsAsMap)",
    "source_code": "\tpublic static MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(AnnotatedElement element,"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#getAllMergedAnnotations(element,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get <strong>all</strong> annotations of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 4.3\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String)\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 359
    },
    "return": "Set<A>",
    "signature": "public Set<A> getAllMergedAnnotations(AnnotatedElement element, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> getAllMergedAnnotations("
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#getAllMergedAnnotations(element,annotationTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get <strong>all</strong> annotations of the specified {@code annotationTypes}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the\n\t * annotation hierarchy and synthesize the results back into an annotation\n\t * of the corresponding {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationTypes the annotation types to find\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 5.1\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationTypes"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "Set<Annotation>",
    "signature": "public Set<Annotation> getAllMergedAnnotations(AnnotatedElement element,\n\t\t\tSet<Class<? extends Annotation>> annotationTypes)",
    "source_code": "\tpublic static Set<Annotation> getAllMergedAnnotations(AnnotatedElement element,"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#getAnnotation(annotationClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationClass"
    ],
    "position": {
      "column": 1,
      "line": 849
    },
    "return": "T",
    "signature": "public T getAnnotation(Class<T> annotationClass)",
    "source_code": "\t\tpublic <T extends Annotation> @Nullable T getAnnotation(Class<T> annotationClass) {\n\t\t\tfor (Annotation annotation : this.annotations) {\n\t\t\t\tif (annotation.annotationType() == annotationClass) {\n\t\t\t\t\treturn (T) annotation;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#getAnnotations()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 859
    },
    "return": "Annotation[]",
    "signature": "public Annotation[] getAnnotations()",
    "source_code": "\t\tpublic Annotation[] getAnnotations() {\n\t\t\treturn this.annotations.clone();\n\t\t}"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#getDeclaredAnnotations()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 864
    },
    "return": "Annotation[]",
    "signature": "public Annotation[] getDeclaredAnnotations()",
    "source_code": "\t\tpublic Annotation[] getDeclaredAnnotations() {\n\t\t\treturn this.annotations.clone();\n\t\t}"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#getMergedAnnotation(element,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "A",
    "signature": "public A getMergedAnnotation(AnnotatedElement element, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> @Nullable A getMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.getDeclaredAnnotation(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn getAnnotations(element)\n\t\t\t\t.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared())\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#getMergedAnnotationAttributes(element,annotationName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the first annotation of the specified {@code annotationName} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)},\n\t * supplying {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationName"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName)",
    "source_code": "\tpublic static @Nullable AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the first annotation of the specified {@code annotationName} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>Attributes from lower levels in the annotation hierarchy override attributes\n\t * of the same name from higher levels, and {@link AliasFor @AliasFor} semantics are\n\t * fully supported, both within a single annotation and within the annotation hierarchy.\n\t * <p>In contrast to {@link #getAllAnnotationAttributes}, the search algorithm used by\n\t * this method will stop searching the annotation hierarchy once the first annotation\n\t * of the specified {@code annotationName} has been found. As a consequence,\n\t * additional annotations of the specified {@code annotationName} will be ignored.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into Strings or to\n\t * preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances\n\t * into {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationName",
      "classValuesAsString",
      "nestedAnnotationsAsMap"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap)",
    "source_code": "\tpublic static @Nullable AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#getMergedAnnotationAttributes(element,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element, Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic static @Nullable AnnotationAttributes getMergedAnnotationAttributes("
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#getMergedRepeatableAnnotations(element,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>The container type that holds the repeatable annotations will be looked up\n\t * via {@link java.lang.annotation.Repeatable}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @since 4.3\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t * @see #getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 416
    },
    "return": "Set<A>",
    "signature": "public Set<A> getMergedRepeatableAnnotations(AnnotatedElement element, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> getMergedRepeatableAnnotations("
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#getMergedRepeatableAnnotations(element,annotationType,containerType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * <p><strong>WARNING</strong>: if the supplied {@code containerType} is not\n\t * {@code null}, the search will be restricted to supporting only repeatable\n\t * annotations whose container is the supplied {@code containerType}. This\n\t * prevents the search from finding repeatable annotations declared as\n\t * meta-annotations on other types of repeatable annotations. If you need to\n\t * support such a use case, favor {@link #getMergedRepeatableAnnotations(AnnotatedElement, Class)}\n\t * over this method or alternatively use the {@link MergedAnnotations} API\n\t * directly in conjunction with {@link RepeatableContainers} that are\n\t * {@linkplain RepeatableContainers#and(Class, Class) composed} to support\n\t * multiple repeatable annotation types.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @param containerType the type of the container that holds the annotations;\n\t * may be {@code null} if the container type should be looked up via\n\t * {@link java.lang.annotation.Repeatable}\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @throws AnnotationConfigurationException if the supplied {@code containerType}\n\t * is not a valid container annotation for the supplied {@code annotationType}\n\t * @since 4.3\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType",
      "containerType"
    ],
    "position": {
      "column": 1,
      "line": 458
    },
    "return": "Set<A>",
    "signature": "public Set<A> getMergedRepeatableAnnotations(AnnotatedElement element, Class<A> annotationType,\n\t\t\t@Nullable Class<? extends Annotation> containerType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> getMergedRepeatableAnnotations("
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#getMetaAnnotationTypes(element,annotationName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the fully qualified class names of all meta-annotation\n\t * types <em>present</em> on the annotation (of the specified\n\t * {@code annotationName}) on the supplied {@link AnnotatedElement}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation\n\t * type on which to find meta-annotations\n\t * @return the names of all meta-annotations present on the annotation,\n\t * or an empty set if none found\n\t * @see #getMetaAnnotationTypes(AnnotatedElement, Class)\n\t * @see #hasMetaAnnotationTypes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationName"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "Set<String>",
    "signature": "public Set<String> getMetaAnnotationTypes(AnnotatedElement element, String annotationName)",
    "source_code": "\tpublic static Set<String> getMetaAnnotationTypes(AnnotatedElement element, String annotationName) {\n\t\tfor (Annotation annotation : element.getAnnotations()) {\n\t\t\tif (annotation.annotationType().getName().equals(annotationName)) {\n\t\t\t\treturn getMetaAnnotationTypes(element, annotation);\n\t\t\t}\n\t\t}\n\t\treturn Collections.emptySet();\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#getMetaAnnotationTypes(element,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the fully qualified class names of all meta-annotation types\n\t * <em>present</em> on the annotation (of the specified {@code annotationType})\n\t * on the supplied {@link AnnotatedElement}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type on which to find meta-annotations\n\t * @return the names of all meta-annotations present on the annotation,\n\t * or an empty set if not found\n\t * @since 4.2\n\t * @see #getMetaAnnotationTypes(AnnotatedElement, String)\n\t * @see #hasMetaAnnotationTypes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "Set<String>",
    "signature": "public Set<String> getMetaAnnotationTypes(AnnotatedElement element,\n\t\t\tClass<? extends Annotation> annotationType)",
    "source_code": "\tpublic static Set<String> getMetaAnnotationTypes(AnnotatedElement element,"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#hasAnnotation(element,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if an annotation of the specified {@code annotationType}\n\t * is <em>available</em> on the supplied {@link AnnotatedElement} or\n\t * within the annotation hierarchy <em>above</em> the specified element.\n\t * <p>If this method returns {@code true}, then {@link #findMergedAnnotationAttributes}\n\t * will return a non-null value.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return {@code true} if a matching annotation is present\n\t * @since 4.3\n\t * @see #isAnnotated(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 529
    },
    "return": "boolean",
    "signature": "public boolean hasAnnotation(AnnotatedElement element, Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic static boolean hasAnnotation(AnnotatedElement element, Class<? extends Annotation> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.isAnnotationPresent(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn findAnnotations(element).isPresent(annotationType);\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#hasMetaAnnotationTypes(element,annotationName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied {@link AnnotatedElement} is annotated with a\n\t * <em>composed annotation</em> that is meta-annotated with an annotation\n\t * of the specified {@code annotationName}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the\n\t * meta-annotation type to find\n\t * @return {@code true} if a matching meta-annotation is present\n\t * @see #getMetaAnnotationTypes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationName"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "boolean",
    "signature": "public boolean hasMetaAnnotationTypes(AnnotatedElement element, String annotationName)",
    "source_code": "\tpublic static boolean hasMetaAnnotationTypes(AnnotatedElement element, String annotationName) {\n\t\treturn getAnnotations(element).stream(annotationName).anyMatch(MergedAnnotation::isMetaPresent);\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#hasMetaAnnotationTypes(element,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied {@link AnnotatedElement} is annotated with\n\t * a <em>composed annotation</em> that is meta-annotated with an\n\t * annotation of the specified {@code annotationType}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the meta-annotation type to find\n\t * @return {@code true} if a matching meta-annotation is present\n\t * @since 4.2.3\n\t * @see #getMetaAnnotationTypes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "boolean",
    "signature": "public boolean hasMetaAnnotationTypes(AnnotatedElement element, Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic static boolean hasMetaAnnotationTypes(AnnotatedElement element, Class<? extends Annotation> annotationType) {\n\t\treturn getAnnotations(element).stream(annotationType).anyMatch(MergedAnnotation::isMetaPresent);\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#isAnnotated(element,annotationName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if an annotation of the specified {@code annotationName} is\n\t * <em>present</em> on the supplied {@link AnnotatedElement} or within the\n\t * annotation hierarchy <em>above</em> the specified element.\n\t * <p>If this method returns {@code true}, then {@link #getMergedAnnotationAttributes}\n\t * will return a non-null value.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @return {@code true} if a matching annotation is present\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationName"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "boolean",
    "signature": "public boolean isAnnotated(AnnotatedElement element, String annotationName)",
    "source_code": "\tpublic static boolean isAnnotated(AnnotatedElement element, String annotationName) {\n\t\treturn getAnnotations(element).isPresent(annotationName);\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedElementUtils#isAnnotated(element,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if an annotation of the specified {@code annotationType}\n\t * is <em>present</em> on the supplied {@link AnnotatedElement} or\n\t * within the annotation hierarchy <em>above</em> the specified element.\n\t * <p>If this method returns {@code true}, then {@link #getMergedAnnotationAttributes}\n\t * will return a non-null value.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return {@code true} if a matching annotation is present\n\t * @since 4.2.3\n\t * @see #hasAnnotation(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "boolean",
    "signature": "public boolean isAnnotated(AnnotatedElement element, Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic static boolean isAnnotated(AnnotatedElement element, Class<? extends Annotation> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.isAnnotationPresent(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn getAnnotations(element).isPresent(annotationType);\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A convenient wrapper for a {@link Method} handle, providing deep annotation\n * introspection on methods and method parameters, including the exposure of\n * interface-declared parameter annotations from the concrete target method.\n *\n * @author Juergen Hoeller\n * @since 6.1\n * @see #getMethodAnnotation(Class)\n * @see #getMethodParameters()\n * @see AnnotatedElementUtils\n * @see SynthesizingMethodParameter\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public class AnnotatedMethod",
    "source_code": "public class AnnotatedMethod {\n\n\tprivate final Method method;\n\n\tprivate final Method bridgedMethod;\n\n\tprivate final MethodParameter[] parameters;\n\n\tprivate volatile @Nullable List<Annotation[][]> inheritedParameterAnnotations;\n\n\n\t/**\n\t * Create an instance that wraps the given {@link Method}.\n\t * @param method the {@code Method} handle to wrap\n\t */\n\tpublic AnnotatedMethod(Method method) {\n\t\tAssert.notNull(method, \"Method is required\");\n\t\tthis.method = method;\n\t\tthis.bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n\t\tReflectionUtils.makeAccessible(this.bridgedMethod);\n\t\tthis.parameters = initMethodParameters();\n\t}\n\n\t/**\n\t * Copy constructor for use in subclasses.\n\t */\n\tprotected AnnotatedMethod(AnnotatedMethod annotatedMethod) {\n\t\tAssert.notNull(annotatedMethod, \"AnnotatedMethod is required\");\n\t\tthis.method = annotatedMethod.method;\n\t\tthis.bridgedMethod = annotatedMethod.bridgedMethod;\n\t\tthis.parameters = annotatedMethod.parameters;\n\t\tthis.inheritedParameterAnnotations = annotatedMethod.inheritedParameterAnnotations;\n\t}\n\n\n\t/**\n\t * Return the annotated method.\n\t */\n\tpublic final Method getMethod() {\n\t\treturn this.method;\n\t}\n\n\t/**\n\t * If the annotated method is a bridge method, this method returns the bridged\n\t * (user-defined) method. Otherwise, it returns the same method as {@link #getMethod()}.\n\t */\n\tprotected final Method getBridgedMethod() {\n\t\treturn this.bridgedMethod;\n\t}\n\n\t/**\n\t * Expose the containing class for method parameters.\n\t * @see MethodParameter#getContainingClass()\n\t */\n\tprotected Class<?> getContainingClass() {\n\t\treturn this.method.getDeclaringClass();\n\t}\n\n\t/**\n\t * Return the method parameters for this {@code AnnotatedMethod}.\n\t */\n\tpublic final MethodParameter[] getMethodParameters() {\n\t\treturn this.parameters;\n\t}\n\n\tprivate MethodParameter[] initMethodParameters() {\n\t\tint count = this.bridgedMethod.getParameterCount();\n\t\tMethodParameter[] result = new MethodParameter[count];\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tresult[i] = new AnnotatedMethodParameter(i);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Return a {@link MethodParameter} for the declared return type.\n\t */\n\tpublic MethodParameter getReturnType() {\n\t\treturn new AnnotatedMethodParameter(-1);\n\t}\n\n\t/**\n\t * Return a {@link MethodParameter} for the actual return value type.\n\t */\n\tpublic MethodParameter getReturnValueType(@Nullable Object returnValue) {\n\t\treturn new ReturnValueMethodParameter(returnValue);\n\t}\n\n\t/**\n\t * Return {@code true} if the method's return type is void, {@code false} otherwise.\n\t */\n\tpublic boolean isVoid() {\n\t\treturn (getReturnType().getParameterType() == void.class);\n\t}\n\n\t/**\n\t * Return a single annotation on the underlying method, traversing its super methods\n\t * if no annotation can be found on the given method itself.\n\t * <p>Supports <em>merged</em> composed annotations with attribute overrides.\n\t * @param annotationType the annotation type to look for\n\t * @return the annotation, or {@code null} if none found\n\t * @see AnnotatedElementUtils#findMergedAnnotation\n\t */\n\tpublic <A extends Annotation> @Nullable A getMethodAnnotation(Class<A> annotationType) {\n\t\treturn AnnotatedElementUtils.findMergedAnnotation(this.method, annotationType);\n\t}\n\n\t/**\n\t * Determine if an annotation of the given type is <em>present</em> or\n\t * <em>meta-present</em> on the method.\n\t * @param annotationType the annotation type to look for\n\t * @see AnnotatedElementUtils#hasAnnotation\n\t */\n\tpublic <A extends Annotation> boolean hasMethodAnnotation(Class<A> annotationType) {\n\t\treturn AnnotatedElementUtils.hasAnnotation(this.method, annotationType);\n\t}\n\n\tprivate List<Annotation[][]> getInheritedParameterAnnotations() {\n\t\tList<Annotation[][]> parameterAnnotations = this.inheritedParameterAnnotations;\n\t\tif (parameterAnnotations == null) {\n\t\t\tparameterAnnotations = new ArrayList<>();\n\t\t\tClass<?> clazz = this.method.getDeclaringClass();\n\t\t\twhile (clazz != null) {\n\t\t\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\t\t\t\t\tfor (Method candidate : ifc.getMethods()) {\n\t\t\t\t\t\tif (isOverrideFor(candidate)) {\n\t\t\t\t\t\t\tparameterAnnotations.add(candidate.getParameterAnnotations());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclazz = clazz.getSuperclass();\n\t\t\t\tif (clazz == Object.class) {\n\t\t\t\t\tclazz = null;\n\t\t\t\t}\n\t\t\t\tif (clazz != null) {\n\t\t\t\t\tfor (Method candidate : clazz.getMethods()) {\n\t\t\t\t\t\tif (isOverrideFor(candidate)) {\n\t\t\t\t\t\t\tparameterAnnotations.add(candidate.getParameterAnnotations());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.inheritedParameterAnnotations = parameterAnnotations;\n\t\t}\n\t\treturn parameterAnnotations;\n\t}\n\n\tprivate boolean isOverrideFor(Method candidate) {\n\t\tif (!candidate.getName().equals(this.method.getName()) ||\n\t\t\t\tcandidate.getParameterCount() != this.method.getParameterCount()) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?>[] paramTypes = this.method.getParameterTypes();\n\t\tif (Arrays.equals(candidate.getParameterTypes(), paramTypes)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (int i = 0; i < paramTypes.length; i++) {\n\t\t\tif (paramTypes[i] !=\n\t\t\t\t\tResolvableType.forMethodParameter(candidate, i, this.method.getDeclaringClass()).resolve()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other != null && getClass() == other.getClass() &&\n\t\t\t\tthis.method.equals(((AnnotatedMethod) other).method)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.method.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.method.toGenericString();\n\t}\n\n\n\t// Support methods for use in subclass variants\n\n\tprotected static @Nullable Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\n\t\tif (!ObjectUtils.isEmpty(providedArgs)) {\n\t\t\tfor (Object providedArg : providedArgs) {\n\t\t\t\tif (parameter.getParameterType().isInstance(providedArg)) {\n\t\t\t\t\treturn providedArg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected static String formatArgumentError(MethodParameter param, String message) {\n\t\treturn \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" +\n\t\t\t\tparam.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\n\t}\n\n\n\t/**\n\t * A MethodParameter with AnnotatedMethod-specific behavior.\n\t */\n\tprotected class AnnotatedMethodParameter extends SynthesizingMethodParameter {\n\n\t\tprivate volatile Annotation @Nullable [] combinedAnnotations;\n\n\t\tpublic AnnotatedMethodParameter(int index) {\n\t\t\tsuper(AnnotatedMethod.this.getBridgedMethod(), index);\n\t\t}\n\n\t\tprotected AnnotatedMethodParameter(AnnotatedMethodParameter original) {\n\t\t\tsuper(original);\n\t\t\tthis.combinedAnnotations = original.combinedAnnotations;\n\t\t}\n\n\t\t@Override\n\t\tpublic Method getMethod() {\n\t\t\treturn AnnotatedMethod.this.getBridgedMethod();\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getContainingClass() {\n\t\t\treturn AnnotatedMethod.this.getContainingClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> @Nullable T getMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn AnnotatedMethod.this.getMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn AnnotatedMethod.this.hasMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\tint index = getParameterIndex();\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tfor (Annotation[][] ifcAnns : getInheritedParameterAnnotations()) {\n\t\t\t\t\t\tif (index < ifcAnns.length) {\n\t\t\t\t\t\t\tAnnotation[] paramAnns = ifcAnns[index];\n\t\t\t\t\t\t\tif (paramAnns.length > 0) {\n\t\t\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + paramAnns.length);\n\t\t\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\t\t\tfor (Annotation paramAnn : paramAnns) {\n\t\t\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\t\t\tif (ann.annotationType() == paramAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\t\t\tmerged.add(adaptAnnotation(paramAnn));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}\n\n\t\t@Override\n\t\tpublic AnnotatedMethodParameter clone() {\n\t\t\treturn new AnnotatedMethodParameter(this);\n\t\t}\n\t}\n\n\n\t/**\n\t * A MethodParameter for an AnnotatedMethod return type based on an actual return value.\n\t */\n\tprivate class ReturnValueMethodParameter extends AnnotatedMethodParameter {\n\n\t\tprivate final @Nullable Class<?> returnValueType;\n\n\t\tpublic ReturnValueMethodParameter(@Nullable Object returnValue) {\n\t\t\tsuper(-1);\n\t\t\tthis.returnValueType = (returnValue != null ? returnValue.getClass() : null);\n\t\t}\n\n\t\tprotected ReturnValueMethodParameter(ReturnValueMethodParameter original) {\n\t\t\tsuper(original);\n\t\t\tthis.returnValueType = original.returnValueType;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getParameterType() {\n\t\t\treturn (this.returnValueType != null ? this.returnValueType : super.getParameterType());\n\t\t}\n\n\t\t@Override\n\t\tpublic ReturnValueMethodParameter clone() {\n\t\t\treturn new ReturnValueMethodParameter(this);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#clone()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 350
    },
    "return": "ReturnValueMethodParameter",
    "signature": "public ReturnValueMethodParameter clone()",
    "source_code": "\t\tpublic ReturnValueMethodParameter clone() {\n\t\t\treturn new ReturnValueMethodParameter(this);\n\t\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other != null && getClass() == other.getClass() &&\n\t\t\t\tthis.method.equals(((AnnotatedMethod) other).method)));\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#findProvidedArgument(parameter,providedArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "Object",
    "signature": "protected Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs)",
    "source_code": "\tprotected static @Nullable Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\n\t\tif (!ObjectUtils.isEmpty(providedArgs)) {\n\t\t\tfor (Object providedArg : providedArgs) {\n\t\t\t\tif (parameter.getParameterType().isInstance(providedArg)) {\n\t\t\t\t\treturn providedArg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#formatArgumentError(param,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "param",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "String",
    "signature": "protected String formatArgumentError(MethodParameter param, String message)",
    "source_code": "\tprotected static String formatArgumentError(MethodParameter param, String message) {\n\t\treturn \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" +\n\t\t\t\tparam.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#getBridgedMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * If the annotated method is a bridge method, this method returns the bridged\n\t * (user-defined) method. Otherwise, it returns the same method as {@link #getMethod()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "Method",
    "signature": "protected Method getBridgedMethod()",
    "source_code": "\tprotected final Method getBridgedMethod() {\n\t\treturn this.bridgedMethod;\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#getMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "Method",
    "signature": "public Method getMethod()",
    "source_code": "\t\tpublic Method getMethod() {\n\t\t\treturn AnnotatedMethod.this.getBridgedMethod();\n\t\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#getMethodAnnotation(annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "T",
    "signature": "public T getMethodAnnotation(Class<T> annotationType)",
    "source_code": "\t\tpublic <T extends Annotation> @Nullable T getMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn AnnotatedMethod.this.getMethodAnnotation(annotationType);\n\t\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#getMethodParameters()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the method parameters for this {@code AnnotatedMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "MethodParameter[]",
    "signature": "public MethodParameter[] getMethodParameters()",
    "source_code": "\tpublic final MethodParameter[] getMethodParameters() {\n\t\treturn this.parameters;\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#getParameterAnnotations()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "Annotation[]",
    "signature": "public Annotation[] getParameterAnnotations()",
    "source_code": "\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\tint index = getParameterIndex();\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tfor (Annotation[][] ifcAnns : getInheritedParameterAnnotations()) {\n\t\t\t\t\t\tif (index < ifcAnns.length) {\n\t\t\t\t\t\t\tAnnotation[] paramAnns = ifcAnns[index];\n\t\t\t\t\t\t\tif (paramAnns.length > 0) {\n\t\t\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + paramAnns.length);\n\t\t\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\t\t\tfor (Annotation paramAnn : paramAnns) {\n\t\t\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\t\t\tif (ann.annotationType() == paramAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\t\t\tmerged.add(adaptAnnotation(paramAnn));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#getReturnType()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link MethodParameter} for the declared return type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getReturnType()",
    "source_code": "\tpublic MethodParameter getReturnType() {\n\t\treturn new AnnotatedMethodParameter(-1);\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#getReturnValueType(returnValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link MethodParameter} for the actual return value type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getReturnValueType(@Nullable Object returnValue)",
    "source_code": "\tpublic MethodParameter getReturnValueType(@Nullable Object returnValue) {\n\t\treturn new ReturnValueMethodParameter(returnValue);\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#hasMethodAnnotation(annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "boolean",
    "signature": "public boolean hasMethodAnnotation(Class<T> annotationType)",
    "source_code": "\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn AnnotatedMethod.this.hasMethodAnnotation(annotationType);\n\t\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.method.hashCode();\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#isVoid()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if the method's return type is void, {@code false} otherwise.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "boolean",
    "signature": "public boolean isVoid()",
    "source_code": "\tpublic boolean isVoid() {\n\t\treturn (getReturnType().getParameterType() == void.class);\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethod#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn this.method.toGenericString();\n\t}"
  },
  "org.springframework.core.annotation.AnnotatedMethodParameter": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A MethodParameter with AnnotatedMethod-specific behavior.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "signature": "protected class AnnotatedMethodParameter",
    "source_code": "\tprotected class AnnotatedMethodParameter extends SynthesizingMethodParameter {\n\n\t\tprivate volatile Annotation @Nullable [] combinedAnnotations;\n\n\t\tpublic AnnotatedMethodParameter(int index) {\n\t\t\tsuper(AnnotatedMethod.this.getBridgedMethod(), index);\n\t\t}\n\n\t\tprotected AnnotatedMethodParameter(AnnotatedMethodParameter original) {\n\t\t\tsuper(original);\n\t\t\tthis.combinedAnnotations = original.combinedAnnotations;\n\t\t}\n\n\t\t@Override\n\t\tpublic Method getMethod() {\n\t\t\treturn AnnotatedMethod.this.getBridgedMethod();\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getContainingClass() {\n\t\t\treturn AnnotatedMethod.this.getContainingClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> @Nullable T getMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn AnnotatedMethod.this.getMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn AnnotatedMethod.this.hasMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\tint index = getParameterIndex();\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tfor (Annotation[][] ifcAnns : getInheritedParameterAnnotations()) {\n\t\t\t\t\t\tif (index < ifcAnns.length) {\n\t\t\t\t\t\t\tAnnotation[] paramAnns = ifcAnns[index];\n\t\t\t\t\t\t\tif (paramAnns.length > 0) {\n\t\t\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + paramAnns.length);\n\t\t\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\t\t\tfor (Annotation paramAnn : paramAnns) {\n\t\t\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\t\t\tif (ann.annotationType() == paramAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\t\t\tmerged.add(adaptAnnotation(paramAnn));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}\n\n\t\t@Override\n\t\tpublic AnnotatedMethodParameter clone() {\n\t\t\treturn new AnnotatedMethodParameter(this);\n\t\t}\n\t}"
  },
  "org.springframework.core.annotation.AnnotationUtils#getAnnotations(annotatedElement)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get all {@link Annotation Annotations} that are <em>present</em> on the\n\t * supplied {@link AnnotatedElement}.\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * @param annotatedElement the Method, Constructor or Field to retrieve annotations from\n\t * @return the annotations found, an empty array, or {@code null} if not\n\t * resolvable (for example, because nested Class values in annotation attributes\n\t * failed to resolve at runtime)\n\t * @since 4.0.8\n\t * @see AnnotatedElement#getAnnotations()\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "Annotation[]",
    "signature": "public Annotation[] getAnnotations(AnnotatedElement annotatedElement)",
    "source_code": "\tpublic static Annotation[] getAnnotations(AnnotatedElement annotatedElement) {\n\t\ttry {\n\t\t\treturn synthesizeAnnotationArray(annotatedElement.getAnnotations(), annotatedElement);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\thandleIntrospectionFailure(annotatedElement, ex);\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.core.annotation.AnnotationUtils#getAnnotations(method)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get all {@link Annotation Annotations} that are <em>present</em> on the\n\t * supplied {@link Method}.\n\t * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * @param method the Method to retrieve annotations from\n\t * @return the annotations found, an empty array, or {@code null} if not\n\t * resolvable (for example, because nested Class values in annotation attributes\n\t * failed to resolve at runtime)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)\n\t * @see AnnotatedElement#getAnnotations()\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "Annotation[]",
    "signature": "public Annotation[] getAnnotations(Method method)",
    "source_code": "\tpublic static Annotation[] getAnnotations(Method method) {\n\t\ttry {\n\t\t\treturn synthesizeAnnotationArray(BridgeMethodResolver.findBridgedMethod(method).getAnnotations(), method);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\thandleIntrospectionFailure(method, ex);\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.core.annotation.RepeatableContainers": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Strategy used to determine annotations that act as containers for other\n * annotations. The {@link #standardRepeatables()} method provides a default\n * strategy that respects Java's {@link Repeatable @Repeatable} support and\n * should be suitable for most situations.\n *\n * <p>The {@link #of} method can be used to register relationships for\n * annotations that do not wish to use {@link Repeatable @Repeatable}.\n *\n * <p>To completely disable repeatable support use {@link #none()}.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 5.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public class RepeatableContainers",
    "source_code": "public abstract class RepeatableContainers {\n\n\tstatic final Map<Class<? extends Annotation>, Object> cache = new ConcurrentReferenceHashMap<>();\n\n\tprivate final @Nullable RepeatableContainers parent;\n\n\n\tprivate RepeatableContainers(@Nullable RepeatableContainers parent) {\n\t\tthis.parent = parent;\n\t}\n\n\n\t/**\n\t * Add an additional explicit relationship between a container and\n\t * repeatable annotation.\n\t * <p>WARNING: the arguments supplied to this method are in the reverse order\n\t * of those supplied to {@link #of(Class, Class)}.\n\t * @param container the container annotation type\n\t * @param repeatable the repeatable annotation type\n\t * @return a new {@link RepeatableContainers} instance\n\t */\n\tpublic RepeatableContainers and(Class<? extends Annotation> container,\n\t\t\tClass<? extends Annotation> repeatable) {\n\n\t\treturn new ExplicitRepeatableContainer(this, repeatable, container);\n\t}\n\n\tAnnotation @Nullable [] findRepeatedAnnotations(Annotation annotation) {\n\t\tif (this.parent == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.parent.findRepeatedAnnotations(annotation);\n\t}\n\n\n\t@Override\n\t@Contract(\"null -> false\")\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (other == this) {\n\t\t\treturn true;\n\t\t}\n\t\tif (other == null || getClass() != other.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn ObjectUtils.nullSafeEquals(this.parent, ((RepeatableContainers) other).parent);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hashCode(this.parent);\n\t}\n\n\n\t/**\n\t * Create a {@link RepeatableContainers} instance that searches using Java's\n\t * {@link Repeatable @Repeatable} annotation.\n\t * @return a {@link RepeatableContainers} instance\n\t */\n\tpublic static RepeatableContainers standardRepeatables() {\n\t\treturn StandardRepeatableContainers.INSTANCE;\n\t}\n\n\t/**\n\t * Create a {@link RepeatableContainers} instance that uses predefined\n\t * repeatable and container types.\n\t * <p>WARNING: the arguments supplied to this method are in the reverse order\n\t * of those supplied to {@link #and(Class, Class)}.\n\t * @param repeatable the repeatable annotation type\n\t * @param container the container annotation type or {@code null}. If specified,\n\t * this annotation must declare a {@code value} attribute returning an array\n\t * of repeatable annotations. If not specified, the container will be\n\t * deduced by inspecting the {@code @Repeatable} annotation on\n\t * {@code repeatable}.\n\t * @return a {@link RepeatableContainers} instance\n\t * @throws IllegalArgumentException if the supplied container type is\n\t * {@code null} and the annotation type is not a repeatable annotation\n\t * @throws AnnotationConfigurationException if the supplied container type\n\t * is not a properly configured container for a repeatable annotation\n\t */\n\tpublic static RepeatableContainers of(\n\t\t\tClass<? extends Annotation> repeatable, @Nullable Class<? extends Annotation> container) {\n\n\t\treturn new ExplicitRepeatableContainer(null, repeatable, container);\n\t}\n\n\t/**\n\t * Create a {@link RepeatableContainers} instance that does not support any\n\t * repeatable annotations.\n\t * @return a {@link RepeatableContainers} instance\n\t */\n\tpublic static RepeatableContainers none() {\n\t\treturn NoRepeatableContainers.INSTANCE;\n\t}\n\n\n\t/**\n\t * Standard {@link RepeatableContainers} implementation that searches using\n\t * Java's {@link Repeatable @Repeatable} annotation.\n\t */\n\tprivate static class StandardRepeatableContainers extends RepeatableContainers {\n\n\t\tprivate static final Object NONE = new Object();\n\n\t\tprivate static final StandardRepeatableContainers INSTANCE = new StandardRepeatableContainers();\n\n\t\tStandardRepeatableContainers() {\n\t\t\tsuper(null);\n\t\t}\n\n\t\t@Override\n\t\tAnnotation @Nullable [] findRepeatedAnnotations(Annotation annotation) {\n\t\t\tMethod method = getRepeatedAnnotationsMethod(annotation.annotationType());\n\t\t\tif (method != null) {\n\t\t\t\treturn (Annotation[]) AnnotationUtils.invokeAnnotationMethod(method, annotation);\n\t\t\t}\n\t\t\treturn super.findRepeatedAnnotations(annotation);\n\t\t}\n\n\t\tprivate static @Nullable Method getRepeatedAnnotationsMethod(Class<? extends Annotation> annotationType) {\n\t\t\tObject result = cache.computeIfAbsent(annotationType,\n\t\t\t\t\tStandardRepeatableContainers::computeRepeatedAnnotationsMethod);\n\t\t\treturn (result != NONE ? (Method) result : null);\n\t\t}\n\n\t\tprivate static Object computeRepeatedAnnotationsMethod(Class<? extends Annotation> annotationType) {\n\t\t\tAttributeMethods methods = AttributeMethods.forAnnotationType(annotationType);\n\t\t\tMethod method = methods.get(MergedAnnotation.VALUE);\n\t\t\tif (method != null) {\n\t\t\t\tClass<?> returnType = method.getReturnType();\n\t\t\t\tif (returnType.isArray()) {\n\t\t\t\t\tClass<?> componentType = returnType.componentType();\n\t\t\t\t\tif (Annotation.class.isAssignableFrom(componentType) &&\n\t\t\t\t\t\t\tcomponentType.isAnnotationPresent(Repeatable.class)) {\n\t\t\t\t\t\treturn method;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn NONE;\n\t\t}\n\t}\n\n\n\t/**\n\t * A single explicit mapping.\n\t */\n\tprivate static class ExplicitRepeatableContainer extends RepeatableContainers {\n\n\t\tprivate final Class<? extends Annotation> repeatable;\n\n\t\tprivate final Class<? extends Annotation> container;\n\n\t\tprivate final Method valueMethod;\n\n\t\tExplicitRepeatableContainer(@Nullable RepeatableContainers parent,\n\t\t\t\tClass<? extends Annotation> repeatable, @Nullable Class<? extends Annotation> container) {\n\n\t\t\tsuper(parent);\n\t\t\tAssert.notNull(repeatable, \"Repeatable must not be null\");\n\t\t\tif (container == null) {\n\t\t\t\tcontainer = deduceContainer(repeatable);\n\t\t\t}\n\t\t\tMethod valueMethod = AttributeMethods.forAnnotationType(container).get(MergedAnnotation.VALUE);\n\t\t\ttry {\n\t\t\t\tif (valueMethod == null) {\n\t\t\t\t\tthrow new NoSuchMethodException(\"No value method found\");\n\t\t\t\t}\n\t\t\t\tClass<?> returnType = valueMethod.getReturnType();\n\t\t\t\tif (!returnType.isArray() || returnType.componentType() != repeatable) {\n\t\t\t\t\tthrow new AnnotationConfigurationException(\n\t\t\t\t\t\t\t\"Container type [%s] must declare a 'value' attribute for an array of type [%s]\"\n\t\t\t\t\t\t\t\t.formatted(container.getName(), repeatable.getName()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (AnnotationConfigurationException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new AnnotationConfigurationException(\n\t\t\t\t\t\t\"Invalid declaration of container type [%s] for repeatable annotation [%s]\"\n\t\t\t\t\t\t\t.formatted(container.getName(), repeatable.getName()), ex);\n\t\t\t}\n\t\t\tthis.repeatable = repeatable;\n\t\t\tthis.container = container;\n\t\t\tthis.valueMethod = valueMethod;\n\t\t}\n\n\t\tprivate Class<? extends Annotation> deduceContainer(Class<? extends Annotation> repeatable) {\n\t\t\tRepeatable annotation = repeatable.getAnnotation(Repeatable.class);\n\t\t\tAssert.notNull(annotation, () -> \"Annotation type must be a repeatable annotation: \" +\n\t\t\t\t\t\t\"failed to resolve container type for \" + repeatable.getName());\n\t\t\treturn annotation.value();\n\t\t}\n\n\t\t@Override\n\t\tAnnotation @Nullable [] findRepeatedAnnotations(Annotation annotation) {\n\t\t\tif (this.container.isAssignableFrom(annotation.annotationType())) {\n\t\t\t\treturn (Annotation[]) AnnotationUtils.invokeAnnotationMethod(this.valueMethod, annotation);\n\t\t\t}\n\t\t\treturn super.findRepeatedAnnotations(annotation);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\tif (!super.equals(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tExplicitRepeatableContainer otherErc = (ExplicitRepeatableContainer) other;\n\t\t\treturn (this.container.equals(otherErc.container) && this.repeatable.equals(otherErc.repeatable));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tint hashCode = super.hashCode();\n\t\t\thashCode = 31 * hashCode + this.container.hashCode();\n\t\t\thashCode = 31 * hashCode + this.repeatable.hashCode();\n\t\t\treturn hashCode;\n\t\t}\n\t}\n\n\n\t/**\n\t * No repeatable containers.\n\t */\n\tprivate static class NoRepeatableContainers extends RepeatableContainers {\n\n\t\tprivate static final NoRepeatableContainers INSTANCE = new NoRepeatableContainers();\n\n\t\tNoRepeatableContainers() {\n\t\t\tsuper(null);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.core.annotation.RepeatableContainers#and(container,repeatable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an additional explicit relationship between a container and\n\t * repeatable annotation.\n\t * <p>WARNING: the arguments supplied to this method are in the reverse order\n\t * of those supplied to {@link #of(Class, Class)}.\n\t * @param container the container annotation type\n\t * @param repeatable the repeatable annotation type\n\t * @return a new {@link RepeatableContainers} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "container",
      "repeatable"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "RepeatableContainers",
    "signature": "public RepeatableContainers and(Class<? extends Annotation> container,\n\t\t\tClass<? extends Annotation> repeatable)",
    "source_code": "\tpublic RepeatableContainers and(Class<? extends Annotation> container,"
  },
  "org.springframework.core.annotation.RepeatableContainers#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\tif (!super.equals(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tExplicitRepeatableContainer otherErc = (ExplicitRepeatableContainer) other;\n\t\t\treturn (this.container.equals(otherErc.container) && this.repeatable.equals(otherErc.repeatable));\n\t\t}"
  },
  "org.springframework.core.annotation.RepeatableContainers#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\tint hashCode = super.hashCode();\n\t\t\thashCode = 31 * hashCode + this.container.hashCode();\n\t\t\thashCode = 31 * hashCode + this.repeatable.hashCode();\n\t\t\treturn hashCode;\n\t\t}"
  },
  "org.springframework.core.annotation.RepeatableContainers#none()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RepeatableContainers} instance that does not support any\n\t * repeatable annotations.\n\t * @return a {@link RepeatableContainers} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "RepeatableContainers",
    "signature": "public RepeatableContainers none()",
    "source_code": "\tpublic static RepeatableContainers none() {\n\t\treturn NoRepeatableContainers.INSTANCE;\n\t}"
  },
  "org.springframework.core.annotation.RepeatableContainers#of(repeatable,container)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RepeatableContainers} instance that uses predefined\n\t * repeatable and container types.\n\t * <p>WARNING: the arguments supplied to this method are in the reverse order\n\t * of those supplied to {@link #and(Class, Class)}.\n\t * @param repeatable the repeatable annotation type\n\t * @param container the container annotation type or {@code null}. If specified,\n\t * this annotation must declare a {@code value} attribute returning an array\n\t * of repeatable annotations. If not specified, the container will be\n\t * deduced by inspecting the {@code @Repeatable} annotation on\n\t * {@code repeatable}.\n\t * @return a {@link RepeatableContainers} instance\n\t * @throws IllegalArgumentException if the supplied container type is\n\t * {@code null} and the annotation type is not a repeatable annotation\n\t * @throws AnnotationConfigurationException if the supplied container type\n\t * is not a properly configured container for a repeatable annotation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "repeatable",
      "container"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "RepeatableContainers",
    "signature": "public RepeatableContainers of(Class<? extends Annotation> repeatable, @Nullable Class<? extends Annotation> container)",
    "source_code": "\tpublic static RepeatableContainers of("
  },
  "org.springframework.core.annotation.RepeatableContainers#standardRepeatables()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RepeatableContainers} instance that searches using Java's\n\t * {@link Repeatable @Repeatable} annotation.\n\t * @return a {@link RepeatableContainers} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "RepeatableContainers",
    "signature": "public RepeatableContainers standardRepeatables()",
    "source_code": "\tpublic static RepeatableContainers standardRepeatables() {\n\t\treturn StandardRepeatableContainers.INSTANCE;\n\t}"
  },
  "org.springframework.core.convert.ConversionService": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A service interface for type conversion. This is the entry point into the convert system.\n * Call {@link #convert(Object, Class)} to perform a thread-safe type conversion using this system.\n *\n * @author Keith Donald\n * @author Phillip Webb\n * @since 3.0\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 29
    },
    "signature": "public interface ConversionService",
    "source_code": "public interface ConversionService {\n\n\t/**\n\t * Return {@code true} if objects of {@code sourceType} can be converted to the {@code targetType}.\n\t * <p>If this method returns {@code true}, it means {@link #convert(Object, Class)} is capable\n\t * of converting an instance of {@code sourceType} to {@code targetType}.\n\t * <p>Special note on collections, arrays, and maps types:\n\t * For conversion between collection, array, and map types, this method will return {@code true}\n\t * even though a convert invocation may still generate a {@link ConversionException} if the\n\t * underlying elements are not convertible. Callers are expected to handle this exceptional case\n\t * when working with collections and maps.\n\t * @param sourceType the source type to convert from (may be {@code null} if source is {@code null})\n\t * @param targetType the target type to convert to (required)\n\t * @return {@code true} if a conversion can be performed, {@code false} if not\n\t * @throws IllegalArgumentException if {@code targetType} is {@code null}\n\t */\n\tboolean canConvert(@Nullable Class<?> sourceType, Class<?> targetType);\n\n\t/**\n\t * Return {@code true} if objects of {@code sourceType} can be converted to the {@code targetType}.\n\t * The TypeDescriptors provide additional context about the source and target locations\n\t * where conversion would occur, often object fields or property locations.\n\t * <p>If this method returns {@code true}, it means {@link #convert(Object, TypeDescriptor, TypeDescriptor)}\n\t * is capable of converting an instance of {@code sourceType} to {@code targetType}.\n\t * <p>Special note on collections, arrays, and maps types:\n\t * For conversion between collection, array, and map types, this method will return {@code true}\n\t * even though a convert invocation may still generate a {@link ConversionException} if the\n\t * underlying elements are not convertible. Callers are expected to handle this exceptional case\n\t * when working with collections and maps.\n\t * @param sourceType context about the source type to convert from\n\t * (may be {@code null} if source is {@code null})\n\t * @param targetType context about the target type to convert to (required)\n\t * @return {@code true} if a conversion can be performed between the source and target types,\n\t * {@code false} if not\n\t * @throws IllegalArgumentException if {@code targetType} is {@code null}\n\t */\n\tboolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType);\n\n\t/**\n\t * Convert the given {@code source} to the specified {@code targetType}.\n\t * @param source the source object to convert (may be {@code null})\n\t * @param targetType the target type to convert to (required)\n\t * @return the converted object, an instance of targetType\n\t * @throws ConversionException if a conversion exception occurred\n\t * @throws IllegalArgumentException if targetType is {@code null}\n\t */\n\t<T> @Nullable T convert(@Nullable Object source, Class<T> targetType);\n\n\t/**\n\t * Convert the given {@code source} to the specified {@code targetType}.\n\t * <p>Delegates to {@link #convert(Object, TypeDescriptor, TypeDescriptor)}\n\t * and encapsulates the construction of the source type descriptor using\n\t * {@link TypeDescriptor#forObject(Object)}.\n\t * @param source the source object\n\t * @param targetType the target type\n\t * @return the converted value\n\t * @throws ConversionException if a conversion exception occurred\n\t * @throws IllegalArgumentException if targetType is {@code null}\n\t * @since 6.1\n\t */\n\tdefault @Nullable Object convert(@Nullable Object source, TypeDescriptor targetType) {\n\t\treturn convert(source, TypeDescriptor.forObject(source), targetType);\n\t}\n\n\t/**\n\t * Convert the given {@code source} to the specified {@code targetType}.\n\t * The TypeDescriptors provide additional context about the source and target locations\n\t * where conversion will occur, often object fields or property locations.\n\t * @param source the source object to convert (may be {@code null})\n\t * @param sourceType context about the source type to convert from\n\t * (may be {@code null} if source is {@code null})\n\t * @param targetType context about the target type to convert to (required)\n\t * @return the converted object, an instance of {@link TypeDescriptor#getObjectType() targetType}\n\t * @throws ConversionException if a conversion exception occurred\n\t * @throws IllegalArgumentException if targetType is {@code null},\n\t * or {@code sourceType} is {@code null} but source is not {@code null}\n\t */\n\t@Nullable Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType);\n\n}"
  },
  "org.springframework.core.env.ACTIVE_PROFILES_PROPERTY_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Name of the property to set to specify active profiles: {@value}.\n\t * <p>The value may be comma delimited.\n\t * <p>Note that certain shell environments such as Bash disallow the use of the period\n\t * character in variable names. Assuming that Spring's {@link SystemEnvironmentPropertySource}\n\t * is in use, this property may be specified as an environment variable named\n\t * {@code SPRING_PROFILES_ACTIVE}.\n\t * @see ConfigurableEnvironment#setActiveProfiles\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "signature": "public String ACTIVE_PROFILES_PROPERTY_NAME",
    "source_code": "\tpublic static final String ACTIVE_PROFILES_PROPERTY_NAME = \"spring.profiles.active\";",
    "type": "String"
  },
  "org.springframework.core.env.AbstractEnvironment": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for {@link Environment} implementations. Supports the notion of\n * reserved default profile names and enables specifying active and default profiles\n * through the {@link #ACTIVE_PROFILES_PROPERTY_NAME} and\n * {@link #DEFAULT_PROFILES_PROPERTY_NAME} properties.\n *\n * <p>Concrete subclasses differ primarily on which {@link PropertySource} objects they\n * add by default. {@code AbstractEnvironment} adds none. Subclasses should contribute\n * property sources through the protected {@link #customizePropertySources(MutablePropertySources)}\n * hook, while clients should customize using {@link ConfigurableEnvironment#getPropertySources()}\n * and working against the {@link MutablePropertySources} API.\n * See {@link ConfigurableEnvironment} javadoc for usage examples.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @author Phillip Webb\n * @since 3.1\n * @see ConfigurableEnvironment\n * @see StandardEnvironment\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public class AbstractEnvironment",
    "source_code": "public abstract class AbstractEnvironment implements ConfigurableEnvironment {\n\n\t/**\n\t * System property that instructs Spring to ignore system environment variables,\n\t * i.e. to never attempt to retrieve such a variable via {@link System#getenv()}.\n\t * <p>The default is \"false\", falling back to system environment variable checks if a\n\t * Spring environment property (for example, a placeholder in a configuration String) isn't\n\t * resolvable otherwise. Consider switching this flag to \"true\" if you experience\n\t * log warnings from {@code getenv} calls coming from Spring.\n\t * @see #suppressGetenvAccess()\n\t */\n\tpublic static final String IGNORE_GETENV_PROPERTY_NAME = \"spring.getenv.ignore\";\n\n\t/**\n\t * Name of the property to set to specify active profiles: {@value}.\n\t * <p>The value may be comma delimited.\n\t * <p>Note that certain shell environments such as Bash disallow the use of the period\n\t * character in variable names. Assuming that Spring's {@link SystemEnvironmentPropertySource}\n\t * is in use, this property may be specified as an environment variable named\n\t * {@code SPRING_PROFILES_ACTIVE}.\n\t * @see ConfigurableEnvironment#setActiveProfiles\n\t */\n\tpublic static final String ACTIVE_PROFILES_PROPERTY_NAME = \"spring.profiles.active\";\n\n\t/**\n\t * Name of the property to set to specify profiles that are active by default: {@value}.\n\t * <p>The value may be comma delimited.\n\t * <p>Note that certain shell environments such as Bash disallow the use of the period\n\t * character in variable names. Assuming that Spring's {@link SystemEnvironmentPropertySource}\n\t * is in use, this property may be specified as an environment variable named\n\t * {@code SPRING_PROFILES_DEFAULT}.\n\t * @see ConfigurableEnvironment#setDefaultProfiles\n\t */\n\tpublic static final String DEFAULT_PROFILES_PROPERTY_NAME = \"spring.profiles.default\";\n\n\t/**\n\t * Name of the reserved default profile name: {@value}.\n\t * <p>If no default profile names are explicitly set and no active profile names\n\t * are explicitly set, this profile will automatically be activated by default.\n\t * @see #getReservedDefaultProfiles\n\t * @see ConfigurableEnvironment#setDefaultProfiles\n\t * @see ConfigurableEnvironment#setActiveProfiles\n\t * @see AbstractEnvironment#DEFAULT_PROFILES_PROPERTY_NAME\n\t * @see AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME\n\t */\n\tpublic static final String RESERVED_DEFAULT_PROFILE_NAME = \"default\";\n\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate final Set<String> activeProfiles = new LinkedHashSet<>();\n\n\tprivate final Set<String> defaultProfiles = new LinkedHashSet<>(getReservedDefaultProfiles());\n\n\tprivate final MutablePropertySources propertySources;\n\n\tprivate final ConfigurablePropertyResolver propertyResolver;\n\n\n\t/**\n\t * Create a new {@code Environment} instance, calling back to\n\t * {@link #customizePropertySources(MutablePropertySources)} during construction to\n\t * allow subclasses to contribute or manipulate {@link PropertySource} instances as\n\t * appropriate.\n\t * @see #customizePropertySources(MutablePropertySources)\n\t */\n\tpublic AbstractEnvironment() {\n\t\tthis(new MutablePropertySources());\n\t}\n\n\t/**\n\t * Create a new {@code Environment} instance with a specific\n\t * {@link MutablePropertySources} instance, calling back to\n\t * {@link #customizePropertySources(MutablePropertySources)} during\n\t * construction to allow subclasses to contribute or manipulate\n\t * {@link PropertySource} instances as appropriate.\n\t * @param propertySources property sources to use\n\t * @since 5.3.4\n\t * @see #customizePropertySources(MutablePropertySources)\n\t */\n\tprotected AbstractEnvironment(MutablePropertySources propertySources) {\n\t\tthis.propertySources = propertySources;\n\t\tthis.propertyResolver = createPropertyResolver(propertySources);\n\t\tcustomizePropertySources(propertySources);\n\t}\n\n\n\t/**\n\t * Factory method used to create the {@link ConfigurablePropertyResolver}\n\t * instance used by the Environment.\n\t * @since 5.3.4\n\t * @see #getPropertyResolver()\n\t */\n\tprotected ConfigurablePropertyResolver createPropertyResolver(MutablePropertySources propertySources) {\n\t\treturn new PropertySourcesPropertyResolver(propertySources);\n\t}\n\n\t/**\n\t * Return the {@link ConfigurablePropertyResolver} being used by the\n\t * {@link Environment}.\n\t * @since 5.3.4\n\t * @see #createPropertyResolver(MutablePropertySources)\n\t */\n\tprotected final ConfigurablePropertyResolver getPropertyResolver() {\n\t\treturn this.propertyResolver;\n\t}\n\n\t/**\n\t * Customize the set of {@link PropertySource} objects to be searched by this\n\t * {@code Environment} during calls to {@link #getProperty(String)} and related\n\t * methods.\n\t *\n\t * <p>Subclasses that override this method are encouraged to add property\n\t * sources using {@link MutablePropertySources#addLast(PropertySource)} such that\n\t * further subclasses may call {@code super.customizePropertySources()} with\n\t * predictable results. For example:\n\t *\n\t * <pre class=\"code\">\n\t * public class Level1Environment extends AbstractEnvironment {\n\t *     &#064;Override\n\t *     protected void customizePropertySources(MutablePropertySources propertySources) {\n\t *         super.customizePropertySources(propertySources); // no-op from base class\n\t *         propertySources.addLast(new PropertySourceA(...));\n\t *         propertySources.addLast(new PropertySourceB(...));\n\t *     }\n\t * }\n\t *\n\t * public class Level2Environment extends Level1Environment {\n\t *     &#064;Override\n\t *     protected void customizePropertySources(MutablePropertySources propertySources) {\n\t *         super.customizePropertySources(propertySources); // add all from superclass\n\t *         propertySources.addLast(new PropertySourceC(...));\n\t *         propertySources.addLast(new PropertySourceD(...));\n\t *     }\n\t * }\n\t * </pre>\n\t *\n\t * <p>In this arrangement, properties will be resolved against sources A, B, C, D in that\n\t * order. That is to say that property source \"A\" has precedence over property source\n\t * \"D\". If the {@code Level2Environment} subclass wished to give property sources C\n\t * and D higher precedence than A and B, it could simply call\n\t * {@code super.customizePropertySources} after, rather than before adding its own:\n\t *\n\t * <pre class=\"code\">\n\t * public class Level2Environment extends Level1Environment {\n\t *     &#064;Override\n\t *     protected void customizePropertySources(MutablePropertySources propertySources) {\n\t *         propertySources.addLast(new PropertySourceC(...));\n\t *         propertySources.addLast(new PropertySourceD(...));\n\t *         super.customizePropertySources(propertySources); // add all from superclass\n\t *     }\n\t * }\n\t * </pre>\n\t *\n\t * <p>The search order is now C, D, A, B as desired.\n\t *\n\t * <p>Beyond these recommendations, subclasses may use any of the {@code add*},\n\t * {@code remove}, or {@code replace} methods exposed by {@link MutablePropertySources}\n\t * in order to create the exact arrangement of property sources desired.\n\t *\n\t * <p>The base implementation registers no property sources.\n\t *\n\t * <p>Note that clients of any {@link ConfigurableEnvironment} may further customize\n\t * property sources via the {@link #getPropertySources()} accessor, typically within\n\t * an {@link org.springframework.context.ApplicationContextInitializer\n\t * ApplicationContextInitializer}. For example:\n\t *\n\t * <pre class=\"code\">\n\t * ConfigurableEnvironment env = new StandardEnvironment();\n\t * env.getPropertySources().addLast(new PropertySourceX(...));\n\t * </pre>\n\t *\n\t * <h2>A warning about instance variable access</h2>\n\t * <p>Instance variables declared in subclasses and having default initial values should\n\t * <em>not</em> be accessed from within this method. Due to Java object creation\n\t * lifecycle constraints, any initial value will not yet be assigned when this\n\t * callback is invoked by the {@link #AbstractEnvironment()} constructor, which may\n\t * lead to a {@code NullPointerException} or other problems. If you need to access\n\t * default values of instance variables, leave this method as a no-op and perform\n\t * property source manipulation and instance variable access directly within the\n\t * subclass constructor. Note that <em>assigning</em> values to instance variables is\n\t * not problematic; it is only attempting to read default values that must be avoided.\n\t * @see MutablePropertySources\n\t * @see PropertySourcesPropertyResolver\n\t * @see org.springframework.context.ApplicationContextInitializer\n\t */\n\tprotected void customizePropertySources(MutablePropertySources propertySources) {\n\t}\n\n\t/**\n\t * Return the set of reserved default profile names. This implementation returns\n\t * {@value #RESERVED_DEFAULT_PROFILE_NAME}. Subclasses may override in order to\n\t * customize the set of reserved names.\n\t * @see #RESERVED_DEFAULT_PROFILE_NAME\n\t * @see #doGetDefaultProfiles()\n\t */\n\tprotected Set<String> getReservedDefaultProfiles() {\n\t\treturn Collections.singleton(RESERVED_DEFAULT_PROFILE_NAME);\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of ConfigurableEnvironment interface\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic String[] getActiveProfiles() {\n\t\treturn StringUtils.toStringArray(doGetActiveProfiles());\n\t}\n\n\t/**\n\t * Return the set of active profiles as explicitly set through\n\t * {@link #setActiveProfiles} or if the current set of active profiles\n\t * is empty, check for the presence of {@link #doGetActiveProfilesProperty()}\n\t * and assign its value to the set of active profiles.\n\t * @see #getActiveProfiles()\n\t * @see #doGetActiveProfilesProperty()\n\t */\n\tprotected Set<String> doGetActiveProfiles() {\n\t\tsynchronized (this.activeProfiles) {\n\t\t\tif (this.activeProfiles.isEmpty()) {\n\t\t\t\tString profiles = doGetActiveProfilesProperty();\n\t\t\t\tif (StringUtils.hasText(profiles)) {\n\t\t\t\t\tsetActiveProfiles(StringUtils.commaDelimitedListToStringArray(\n\t\t\t\t\t\t\tStringUtils.trimAllWhitespace(profiles)));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.activeProfiles;\n\t\t}\n\t}\n\n\t/**\n\t * Return the property value for the active profiles.\n\t * @since 5.3.4\n\t * @see #ACTIVE_PROFILES_PROPERTY_NAME\n\t */\n\tprotected @Nullable String doGetActiveProfilesProperty() {\n\t\treturn getProperty(ACTIVE_PROFILES_PROPERTY_NAME);\n\t}\n\n\t@Override\n\tpublic void setActiveProfiles(String... profiles) {\n\t\tAssert.notNull(profiles, \"Profile array must not be null\");\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Activating profiles \" + Arrays.toString(profiles));\n\t\t}\n\t\tsynchronized (this.activeProfiles) {\n\t\t\tthis.activeProfiles.clear();\n\t\t\tfor (String profile : profiles) {\n\t\t\t\tvalidateProfile(profile);\n\t\t\t\tthis.activeProfiles.add(profile);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addActiveProfile(String profile) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Activating profile '\" + profile + \"'\");\n\t\t}\n\t\tvalidateProfile(profile);\n\t\tdoGetActiveProfiles();\n\t\tsynchronized (this.activeProfiles) {\n\t\t\tthis.activeProfiles.add(profile);\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic String[] getDefaultProfiles() {\n\t\treturn StringUtils.toStringArray(doGetDefaultProfiles());\n\t}\n\n\t/**\n\t * Return the set of default profiles explicitly set via\n\t * {@link #setDefaultProfiles(String...)} or if the current set of default profiles\n\t * consists only of {@linkplain #getReservedDefaultProfiles() reserved default\n\t * profiles}, then check for the presence of {@link #doGetActiveProfilesProperty()}\n\t * and assign its value (if any) to the set of default profiles.\n\t * @see #AbstractEnvironment()\n\t * @see #getDefaultProfiles()\n\t * @see #getReservedDefaultProfiles()\n\t * @see #doGetDefaultProfilesProperty()\n\t */\n\tprotected Set<String> doGetDefaultProfiles() {\n\t\tsynchronized (this.defaultProfiles) {\n\t\t\tif (this.defaultProfiles.equals(getReservedDefaultProfiles())) {\n\t\t\t\tString profiles = doGetDefaultProfilesProperty();\n\t\t\t\tif (StringUtils.hasText(profiles)) {\n\t\t\t\t\tsetDefaultProfiles(StringUtils.commaDelimitedListToStringArray(\n\t\t\t\t\t\t\tStringUtils.trimAllWhitespace(profiles)));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.defaultProfiles;\n\t\t}\n\t}\n\n\t/**\n\t * Return the property value for the default profiles.\n\t * @since 5.3.4\n\t * @see #DEFAULT_PROFILES_PROPERTY_NAME\n\t */\n\tprotected @Nullable String doGetDefaultProfilesProperty() {\n\t\treturn getProperty(DEFAULT_PROFILES_PROPERTY_NAME);\n\t}\n\n\t/**\n\t * Specify the set of profiles to be made active by default if no other profiles\n\t * are explicitly made active through {@link #setActiveProfiles}.\n\t * <p>Calling this method removes overrides any reserved default profiles\n\t * that may have been added during construction of the environment.\n\t * @see #AbstractEnvironment()\n\t * @see #getReservedDefaultProfiles()\n\t */\n\t@Override\n\tpublic void setDefaultProfiles(String... profiles) {\n\t\tAssert.notNull(profiles, \"Profile array must not be null\");\n\t\tsynchronized (this.defaultProfiles) {\n\t\t\tthis.defaultProfiles.clear();\n\t\t\tfor (String profile : profiles) {\n\t\t\t\tvalidateProfile(profile);\n\t\t\t\tthis.defaultProfiles.add(profile);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\t@Deprecated\n\tpublic boolean acceptsProfiles(String... profiles) {\n\t\tAssert.notEmpty(profiles, \"Must specify at least one profile\");\n\t\tfor (String profile : profiles) {\n\t\t\tif (StringUtils.hasLength(profile) && profile.charAt(0) == '!') {\n\t\t\t\tif (!isProfileActive(profile.substring(1))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (isProfileActive(profile)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean acceptsProfiles(Profiles profiles) {\n\t\tAssert.notNull(profiles, \"Profiles must not be null\");\n\t\treturn profiles.matches(this::isProfileActive);\n\t}\n\n\t/**\n\t * Return whether the given profile is active, or if active profiles are empty\n\t * whether the profile should be active by default.\n\t * @throws IllegalArgumentException per {@link #validateProfile(String)}\n\t */\n\tprotected boolean isProfileActive(String profile) {\n\t\tvalidateProfile(profile);\n\t\tSet<String> currentActiveProfiles = doGetActiveProfiles();\n\t\treturn (currentActiveProfiles.contains(profile) ||\n\t\t\t\t(currentActiveProfiles.isEmpty() && doGetDefaultProfiles().contains(profile)));\n\t}\n\n\t/**\n\t * Validate the given profile, called internally prior to adding to the set of\n\t * active or default profiles.\n\t * <p>Subclasses may override to impose further restrictions on profile syntax.\n\t * @throws IllegalArgumentException if the profile is null, empty, whitespace-only or\n\t * begins with the profile NOT operator (!).\n\t * @see #acceptsProfiles\n\t * @see #addActiveProfile\n\t * @see #setDefaultProfiles\n\t */\n\tprotected void validateProfile(String profile) {\n\t\tif (!StringUtils.hasText(profile)) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid profile [\" + profile + \"]: must contain text\");\n\t\t}\n\t\tif (profile.charAt(0) == '!') {\n\t\t\tthrow new IllegalArgumentException(\"Invalid profile [\" + profile + \"]: must not begin with ! operator\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic MutablePropertySources getPropertySources() {\n\t\treturn this.propertySources;\n\t}\n\n\t@Override\n\t@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n\tpublic Map<String, Object> getSystemProperties() {\n\t\treturn (Map) System.getProperties();\n\t}\n\n\t@Override\n\t@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n\tpublic Map<String, Object> getSystemEnvironment() {\n\t\tif (suppressGetenvAccess()) {\n\t\t\treturn Collections.emptyMap();\n\t\t}\n\t\treturn (Map) System.getenv();\n\t}\n\n\t/**\n\t * Determine whether to suppress {@link System#getenv()}/{@link System#getenv(String)}\n\t * access for the purposes of {@link #getSystemEnvironment()}.\n\t * <p>If this method returns {@code true}, an empty dummy Map will be used instead\n\t * of the regular system environment Map, never even trying to call {@code getenv}\n\t * and therefore avoiding security manager warnings (if any).\n\t * <p>The default implementation checks for the \"spring.getenv.ignore\" system property,\n\t * returning {@code true} if its value equals \"true\" in any case.\n\t * @see #IGNORE_GETENV_PROPERTY_NAME\n\t * @see SpringProperties#getFlag\n\t */\n\tprotected boolean suppressGetenvAccess() {\n\t\treturn SpringProperties.getFlag(IGNORE_GETENV_PROPERTY_NAME);\n\t}\n\n\t@Override\n\tpublic void merge(ConfigurableEnvironment parent) {\n\t\tfor (PropertySource<?> ps : parent.getPropertySources()) {\n\t\t\tif (!this.propertySources.contains(ps.getName())) {\n\t\t\t\tthis.propertySources.addLast(ps);\n\t\t\t}\n\t\t}\n\t\tString[] parentActiveProfiles = parent.getActiveProfiles();\n\t\tif (!ObjectUtils.isEmpty(parentActiveProfiles)) {\n\t\t\tsynchronized (this.activeProfiles) {\n\t\t\t\tCollections.addAll(this.activeProfiles, parentActiveProfiles);\n\t\t\t}\n\t\t}\n\t\tString[] parentDefaultProfiles = parent.getDefaultProfiles();\n\t\tif (!ObjectUtils.isEmpty(parentDefaultProfiles)) {\n\t\t\tsynchronized (this.defaultProfiles) {\n\t\t\t\tthis.defaultProfiles.remove(RESERVED_DEFAULT_PROFILE_NAME);\n\t\t\t\tCollections.addAll(this.defaultProfiles, parentDefaultProfiles);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of ConfigurablePropertyResolver interface\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic ConfigurableConversionService getConversionService() {\n\t\treturn this.propertyResolver.getConversionService();\n\t}\n\n\t@Override\n\tpublic void setConversionService(ConfigurableConversionService conversionService) {\n\t\tthis.propertyResolver.setConversionService(conversionService);\n\t}\n\n\t@Override\n\tpublic void setPlaceholderPrefix(String placeholderPrefix) {\n\t\tthis.propertyResolver.setPlaceholderPrefix(placeholderPrefix);\n\t}\n\n\t@Override\n\tpublic void setPlaceholderSuffix(String placeholderSuffix) {\n\t\tthis.propertyResolver.setPlaceholderSuffix(placeholderSuffix);\n\t}\n\n\t@Override\n\tpublic void setValueSeparator(@Nullable String valueSeparator) {\n\t\tthis.propertyResolver.setValueSeparator(valueSeparator);\n\t}\n\n\t@Override\n\tpublic void setEscapeCharacter(@Nullable Character escapeCharacter) {\n\t\tthis.propertyResolver.setEscapeCharacter(escapeCharacter);\n\t}\n\n\t@Override\n\tpublic void setIgnoreUnresolvableNestedPlaceholders(boolean ignoreUnresolvableNestedPlaceholders) {\n\t\tthis.propertyResolver.setIgnoreUnresolvableNestedPlaceholders(ignoreUnresolvableNestedPlaceholders);\n\t}\n\n\t@Override\n\tpublic void setRequiredProperties(String... requiredProperties) {\n\t\tthis.propertyResolver.setRequiredProperties(requiredProperties);\n\t}\n\n\t@Override\n\tpublic void validateRequiredProperties() throws MissingRequiredPropertiesException {\n\t\tthis.propertyResolver.validateRequiredProperties();\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of PropertyResolver interface\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic boolean containsProperty(String key) {\n\t\treturn this.propertyResolver.containsProperty(key);\n\t}\n\n\t@Override\n\tpublic @Nullable String getProperty(String key) {\n\t\treturn this.propertyResolver.getProperty(key);\n\t}\n\n\t@Override\n\tpublic String getProperty(String key, String defaultValue) {\n\t\treturn this.propertyResolver.getProperty(key, defaultValue);\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T getProperty(String key, Class<T> targetType) {\n\t\treturn this.propertyResolver.getProperty(key, targetType);\n\t}\n\n\t@Override\n\tpublic <T> T getProperty(String key, Class<T> targetType, T defaultValue) {\n\t\treturn this.propertyResolver.getProperty(key, targetType, defaultValue);\n\t}\n\n\t@Override\n\tpublic String getRequiredProperty(String key) throws IllegalStateException {\n\t\treturn this.propertyResolver.getRequiredProperty(key);\n\t}\n\n\t@Override\n\tpublic <T> T getRequiredProperty(String key, Class<T> targetType) throws IllegalStateException {\n\t\treturn this.propertyResolver.getRequiredProperty(key, targetType);\n\t}\n\n\t@Override\n\tpublic String resolvePlaceholders(String text) {\n\t\treturn this.propertyResolver.resolvePlaceholders(text);\n\t}\n\n\t@Override\n\tpublic String resolveRequiredPlaceholders(String text) throws IllegalArgumentException {\n\t\treturn this.propertyResolver.resolveRequiredPlaceholders(text);\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" {activeProfiles=\" + this.activeProfiles +\n\t\t\t\t\", defaultProfiles=\" + this.defaultProfiles + \", propertySources=\" + this.propertySources + \"}\";\n\t}\n\n}"
  },
  "org.springframework.core.env.AbstractEnvironment#acceptsProfiles(profiles)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "profiles"
    ],
    "position": {
      "column": 1,
      "line": 399
    },
    "return": "boolean",
    "signature": "public boolean acceptsProfiles(Profiles profiles)",
    "source_code": "\tpublic boolean acceptsProfiles(Profiles profiles) {\n\t\tAssert.notNull(profiles, \"Profiles must not be null\");\n\t\treturn profiles.matches(this::isProfileActive);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#addActiveProfile(profile)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "profile"
    ],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "void",
    "signature": "public void addActiveProfile(String profile)",
    "source_code": "\tpublic void addActiveProfile(String profile) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Activating profile '\" + profile + \"'\");\n\t\t}\n\t\tvalidateProfile(profile);\n\t\tdoGetActiveProfiles();\n\t\tsynchronized (this.activeProfiles) {\n\t\t\tthis.activeProfiles.add(profile);\n\t\t}\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#containsProperty(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 548
    },
    "return": "boolean",
    "signature": "public boolean containsProperty(String key)",
    "source_code": "\tpublic boolean containsProperty(String key) {\n\t\treturn this.propertyResolver.containsProperty(key);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#createPropertyResolver(propertySources)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Factory method used to create the {@link ConfigurablePropertyResolver}\n\t * instance used by the Environment.\n\t * @since 5.3.4\n\t * @see #getPropertyResolver()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertySources"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "ConfigurablePropertyResolver",
    "signature": "protected ConfigurablePropertyResolver createPropertyResolver(MutablePropertySources propertySources)",
    "source_code": "\tprotected ConfigurablePropertyResolver createPropertyResolver(MutablePropertySources propertySources) {\n\t\treturn new PropertySourcesPropertyResolver(propertySources);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#customizePropertySources(propertySources)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the set of {@link PropertySource} objects to be searched by this\n\t * {@code Environment} during calls to {@link #getProperty(String)} and related\n\t * methods.\n\t *\n\t * <p>Subclasses that override this method are encouraged to add property\n\t * sources using {@link MutablePropertySources#addLast(PropertySource)} such that\n\t * further subclasses may call {@code super.customizePropertySources()} with\n\t * predictable results. For example:\n\t *\n\t * <pre class=\"code\">\n\t * public class Level1Environment extends AbstractEnvironment {\n\t *     &#064;Override\n\t *     protected void customizePropertySources(MutablePropertySources propertySources) {\n\t *         super.customizePropertySources(propertySources); // no-op from base class\n\t *         propertySources.addLast(new PropertySourceA(...));\n\t *         propertySources.addLast(new PropertySourceB(...));\n\t *     }\n\t * }\n\t *\n\t * public class Level2Environment extends Level1Environment {\n\t *     &#064;Override\n\t *     protected void customizePropertySources(MutablePropertySources propertySources) {\n\t *         super.customizePropertySources(propertySources); // add all from superclass\n\t *         propertySources.addLast(new PropertySourceC(...));\n\t *         propertySources.addLast(new PropertySourceD(...));\n\t *     }\n\t * }\n\t * </pre>\n\t *\n\t * <p>In this arrangement, properties will be resolved against sources A, B, C, D in that\n\t * order. That is to say that property source \"A\" has precedence over property source\n\t * \"D\". If the {@code Level2Environment} subclass wished to give property sources C\n\t * and D higher precedence than A and B, it could simply call\n\t * {@code super.customizePropertySources} after, rather than before adding its own:\n\t *\n\t * <pre class=\"code\">\n\t * public class Level2Environment extends Level1Environment {\n\t *     &#064;Override\n\t *     protected void customizePropertySources(MutablePropertySources propertySources) {\n\t *         propertySources.addLast(new PropertySourceC(...));\n\t *         propertySources.addLast(new PropertySourceD(...));\n\t *         super.customizePropertySources(propertySources); // add all from superclass\n\t *     }\n\t * }\n\t * </pre>\n\t *\n\t * <p>The search order is now C, D, A, B as desired.\n\t *\n\t * <p>Beyond these recommendations, subclasses may use any of the {@code add*},\n\t * {@code remove}, or {@code replace} methods exposed by {@link MutablePropertySources}\n\t * in order to create the exact arrangement of property sources desired.\n\t *\n\t * <p>The base implementation registers no property sources.\n\t *\n\t * <p>Note that clients of any {@link ConfigurableEnvironment} may further customize\n\t * property sources via the {@link #getPropertySources()} accessor, typically within\n\t * an {@link org.springframework.context.ApplicationContextInitializer\n\t * ApplicationContextInitializer}. For example:\n\t *\n\t * <pre class=\"code\">\n\t * ConfigurableEnvironment env = new StandardEnvironment();\n\t * env.getPropertySources().addLast(new PropertySourceX(...));\n\t * </pre>\n\t *\n\t * <h2>A warning about instance variable access</h2>\n\t * <p>Instance variables declared in subclasses and having default initial values should\n\t * <em>not</em> be accessed from within this method. Due to Java object creation\n\t * lifecycle constraints, any initial value will not yet be assigned when this\n\t * callback is invoked by the {@link #AbstractEnvironment()} constructor, which may\n\t * lead to a {@code NullPointerException} or other problems. If you need to access\n\t * default values of instance variables, leave this method as a no-op and perform\n\t * property source manipulation and instance variable access directly within the\n\t * subclass constructor. Note that <em>assigning</em> values to instance variables is\n\t * not problematic; it is only attempting to read default values that must be avoided.\n\t * @see MutablePropertySources\n\t * @see PropertySourcesPropertyResolver\n\t * @see org.springframework.context.ApplicationContextInitializer\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertySources"
    ],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "void",
    "signature": "protected void customizePropertySources(MutablePropertySources propertySources)",
    "source_code": "\tprotected void customizePropertySources(MutablePropertySources propertySources) {\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#doGetActiveProfiles()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the set of active profiles as explicitly set through\n\t * {@link #setActiveProfiles} or if the current set of active profiles\n\t * is empty, check for the presence of {@link #doGetActiveProfilesProperty()}\n\t * and assign its value to the set of active profiles.\n\t * @see #getActiveProfiles()\n\t * @see #doGetActiveProfilesProperty()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "Set<String>",
    "signature": "protected Set<String> doGetActiveProfiles()",
    "source_code": "\tprotected Set<String> doGetActiveProfiles() {\n\t\tsynchronized (this.activeProfiles) {\n\t\t\tif (this.activeProfiles.isEmpty()) {\n\t\t\t\tString profiles = doGetActiveProfilesProperty();\n\t\t\t\tif (StringUtils.hasText(profiles)) {\n\t\t\t\t\tsetActiveProfiles(StringUtils.commaDelimitedListToStringArray(\n\t\t\t\t\t\t\tStringUtils.trimAllWhitespace(profiles)));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.activeProfiles;\n\t\t}\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#doGetActiveProfilesProperty()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the property value for the active profiles.\n\t * @since 5.3.4\n\t * @see #ACTIVE_PROFILES_PROPERTY_NAME\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "String",
    "signature": "protected String doGetActiveProfilesProperty()",
    "source_code": "\tprotected @Nullable String doGetActiveProfilesProperty() {\n\t\treturn getProperty(ACTIVE_PROFILES_PROPERTY_NAME);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#doGetDefaultProfiles()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the set of default profiles explicitly set via\n\t * {@link #setDefaultProfiles(String...)} or if the current set of default profiles\n\t * consists only of {@linkplain #getReservedDefaultProfiles() reserved default\n\t * profiles}, then check for the presence of {@link #doGetActiveProfilesProperty()}\n\t * and assign its value (if any) to the set of default profiles.\n\t * @see #AbstractEnvironment()\n\t * @see #getDefaultProfiles()\n\t * @see #getReservedDefaultProfiles()\n\t * @see #doGetDefaultProfilesProperty()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "Set<String>",
    "signature": "protected Set<String> doGetDefaultProfiles()",
    "source_code": "\tprotected Set<String> doGetDefaultProfiles() {\n\t\tsynchronized (this.defaultProfiles) {\n\t\t\tif (this.defaultProfiles.equals(getReservedDefaultProfiles())) {\n\t\t\t\tString profiles = doGetDefaultProfilesProperty();\n\t\t\t\tif (StringUtils.hasText(profiles)) {\n\t\t\t\t\tsetDefaultProfiles(StringUtils.commaDelimitedListToStringArray(\n\t\t\t\t\t\t\tStringUtils.trimAllWhitespace(profiles)));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.defaultProfiles;\n\t\t}\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#doGetDefaultProfilesProperty()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the property value for the default profiles.\n\t * @since 5.3.4\n\t * @see #DEFAULT_PROFILES_PROPERTY_NAME\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "String",
    "signature": "protected String doGetDefaultProfilesProperty()",
    "source_code": "\tprotected @Nullable String doGetDefaultProfilesProperty() {\n\t\treturn getProperty(DEFAULT_PROFILES_PROPERTY_NAME);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#getActiveProfiles()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "String[]",
    "signature": "public String[] getActiveProfiles()",
    "source_code": "\tpublic String[] getActiveProfiles() {\n\t\treturn StringUtils.toStringArray(doGetActiveProfiles());\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#getConversionService()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 498
    },
    "return": "ConfigurableConversionService",
    "signature": "public ConfigurableConversionService getConversionService()",
    "source_code": "\tpublic ConfigurableConversionService getConversionService() {\n\t\treturn this.propertyResolver.getConversionService();\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#getDefaultProfiles()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "String[]",
    "signature": "public String[] getDefaultProfiles()",
    "source_code": "\tpublic String[] getDefaultProfiles() {\n\t\treturn StringUtils.toStringArray(doGetDefaultProfiles());\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#getProperty(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 553
    },
    "return": "String",
    "signature": "public String getProperty(String key)",
    "source_code": "\tpublic @Nullable String getProperty(String key) {\n\t\treturn this.propertyResolver.getProperty(key);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#getProperty(key,defaultValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "defaultValue"
    ],
    "position": {
      "column": 1,
      "line": 558
    },
    "return": "String",
    "signature": "public String getProperty(String key, String defaultValue)",
    "source_code": "\tpublic String getProperty(String key, String defaultValue) {\n\t\treturn this.propertyResolver.getProperty(key, defaultValue);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#getProperty(key,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "T",
    "signature": "public T getProperty(String key, Class<T> targetType)",
    "source_code": "\tpublic <T> @Nullable T getProperty(String key, Class<T> targetType) {\n\t\treturn this.propertyResolver.getProperty(key, targetType);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#getProperty(key,targetType,defaultValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "targetType",
      "defaultValue"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "T",
    "signature": "public T getProperty(String key, Class<T> targetType, T defaultValue)",
    "source_code": "\tpublic <T> T getProperty(String key, Class<T> targetType, T defaultValue) {\n\t\treturn this.propertyResolver.getProperty(key, targetType, defaultValue);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#getPropertyResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link ConfigurablePropertyResolver} being used by the\n\t * {@link Environment}.\n\t * @since 5.3.4\n\t * @see #createPropertyResolver(MutablePropertySources)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "ConfigurablePropertyResolver",
    "signature": "protected ConfigurablePropertyResolver getPropertyResolver()",
    "source_code": "\tprotected final ConfigurablePropertyResolver getPropertyResolver() {\n\t\treturn this.propertyResolver;\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#getPropertySources()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "MutablePropertySources",
    "signature": "public MutablePropertySources getPropertySources()",
    "source_code": "\tpublic MutablePropertySources getPropertySources() {\n\t\treturn this.propertySources;\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#getRequiredProperty(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 573
    },
    "return": "String",
    "signature": "public String getRequiredProperty(String key)",
    "source_code": "\tpublic String getRequiredProperty(String key) throws IllegalStateException {\n\t\treturn this.propertyResolver.getRequiredProperty(key);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#getRequiredProperty(key,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 578
    },
    "return": "T",
    "signature": "public T getRequiredProperty(String key, Class<T> targetType)",
    "source_code": "\tpublic <T> T getRequiredProperty(String key, Class<T> targetType) throws IllegalStateException {\n\t\treturn this.propertyResolver.getRequiredProperty(key, targetType);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#getReservedDefaultProfiles()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the set of reserved default profile names. This implementation returns\n\t * {@value #RESERVED_DEFAULT_PROFILE_NAME}. Subclasses may override in order to\n\t * customize the set of reserved names.\n\t * @see #RESERVED_DEFAULT_PROFILE_NAME\n\t * @see #doGetDefaultProfiles()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "Set<String>",
    "signature": "protected Set<String> getReservedDefaultProfiles()",
    "source_code": "\tprotected Set<String> getReservedDefaultProfiles() {\n\t\treturn Collections.singleton(RESERVED_DEFAULT_PROFILE_NAME);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#getSystemEnvironment()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 448
    },
    "return": "Object>",
    "signature": "public Object> getSystemEnvironment()",
    "source_code": "\tpublic Map<String, Object> getSystemEnvironment() {\n\t\tif (suppressGetenvAccess()) {\n\t\t\treturn Collections.emptyMap();\n\t\t}\n\t\treturn (Map) System.getenv();\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#getSystemProperties()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 442
    },
    "return": "Object>",
    "signature": "public Object> getSystemProperties()",
    "source_code": "\tpublic Map<String, Object> getSystemProperties() {\n\t\treturn (Map) System.getProperties();\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#isProfileActive(profile)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the given profile is active, or if active profiles are empty\n\t * whether the profile should be active by default.\n\t * @throws IllegalArgumentException per {@link #validateProfile(String)}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "profile"
    ],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "boolean",
    "signature": "protected boolean isProfileActive(String profile)",
    "source_code": "\tprotected boolean isProfileActive(String profile) {\n\t\tvalidateProfile(profile);\n\t\tSet<String> currentActiveProfiles = doGetActiveProfiles();\n\t\treturn (currentActiveProfiles.contains(profile) ||\n\t\t\t\t(currentActiveProfiles.isEmpty() && doGetDefaultProfiles().contains(profile)));\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#merge(parent)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parent"
    ],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "void",
    "signature": "public void merge(ConfigurableEnvironment parent)",
    "source_code": "\tpublic void merge(ConfigurableEnvironment parent) {\n\t\tfor (PropertySource<?> ps : parent.getPropertySources()) {\n\t\t\tif (!this.propertySources.contains(ps.getName())) {\n\t\t\t\tthis.propertySources.addLast(ps);\n\t\t\t}\n\t\t}\n\t\tString[] parentActiveProfiles = parent.getActiveProfiles();\n\t\tif (!ObjectUtils.isEmpty(parentActiveProfiles)) {\n\t\t\tsynchronized (this.activeProfiles) {\n\t\t\t\tCollections.addAll(this.activeProfiles, parentActiveProfiles);\n\t\t\t}\n\t\t}\n\t\tString[] parentDefaultProfiles = parent.getDefaultProfiles();\n\t\tif (!ObjectUtils.isEmpty(parentDefaultProfiles)) {\n\t\t\tsynchronized (this.defaultProfiles) {\n\t\t\t\tthis.defaultProfiles.remove(RESERVED_DEFAULT_PROFILE_NAME);\n\t\t\t\tCollections.addAll(this.defaultProfiles, parentDefaultProfiles);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#resolvePlaceholders(text)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text"
    ],
    "position": {
      "column": 1,
      "line": 583
    },
    "return": "String",
    "signature": "public String resolvePlaceholders(String text)",
    "source_code": "\tpublic String resolvePlaceholders(String text) {\n\t\treturn this.propertyResolver.resolvePlaceholders(text);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#resolveRequiredPlaceholders(text)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text"
    ],
    "position": {
      "column": 1,
      "line": 588
    },
    "return": "String",
    "signature": "public String resolveRequiredPlaceholders(String text)",
    "source_code": "\tpublic String resolveRequiredPlaceholders(String text) throws IllegalArgumentException {\n\t\treturn this.propertyResolver.resolveRequiredPlaceholders(text);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#setActiveProfiles(profiles)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "profiles"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "void",
    "signature": "public void setActiveProfiles(String... profiles)",
    "source_code": "\tpublic void setActiveProfiles(String... profiles) {\n\t\tAssert.notNull(profiles, \"Profile array must not be null\");\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Activating profiles \" + Arrays.toString(profiles));\n\t\t}\n\t\tsynchronized (this.activeProfiles) {\n\t\t\tthis.activeProfiles.clear();\n\t\t\tfor (String profile : profiles) {\n\t\t\t\tvalidateProfile(profile);\n\t\t\t\tthis.activeProfiles.add(profile);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#setConversionService(conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 503
    },
    "return": "void",
    "signature": "public void setConversionService(ConfigurableConversionService conversionService)",
    "source_code": "\tpublic void setConversionService(ConfigurableConversionService conversionService) {\n\t\tthis.propertyResolver.setConversionService(conversionService);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#setDefaultProfiles(profiles)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the set of profiles to be made active by default if no other profiles\n\t * are explicitly made active through {@link #setActiveProfiles}.\n\t * <p>Calling this method removes overrides any reserved default profiles\n\t * that may have been added during construction of the environment.\n\t * @see #AbstractEnvironment()\n\t * @see #getReservedDefaultProfiles()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "profiles"
    ],
    "position": {
      "column": 1,
      "line": 370
    },
    "return": "void",
    "signature": "public void setDefaultProfiles(String... profiles)",
    "source_code": "\tpublic void setDefaultProfiles(String... profiles) {\n\t\tAssert.notNull(profiles, \"Profile array must not be null\");\n\t\tsynchronized (this.defaultProfiles) {\n\t\t\tthis.defaultProfiles.clear();\n\t\t\tfor (String profile : profiles) {\n\t\t\t\tvalidateProfile(profile);\n\t\t\t\tthis.defaultProfiles.add(profile);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#setEscapeCharacter(escapeCharacter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "escapeCharacter"
    ],
    "position": {
      "column": 1,
      "line": 523
    },
    "return": "void",
    "signature": "public void setEscapeCharacter(@Nullable Character escapeCharacter)",
    "source_code": "\tpublic void setEscapeCharacter(@Nullable Character escapeCharacter) {\n\t\tthis.propertyResolver.setEscapeCharacter(escapeCharacter);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#setIgnoreUnresolvableNestedPlaceholders(ignoreUnresolvableNestedPlaceholders)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ignoreUnresolvableNestedPlaceholders"
    ],
    "position": {
      "column": 1,
      "line": 528
    },
    "return": "void",
    "signature": "public void setIgnoreUnresolvableNestedPlaceholders(boolean ignoreUnresolvableNestedPlaceholders)",
    "source_code": "\tpublic void setIgnoreUnresolvableNestedPlaceholders(boolean ignoreUnresolvableNestedPlaceholders) {\n\t\tthis.propertyResolver.setIgnoreUnresolvableNestedPlaceholders(ignoreUnresolvableNestedPlaceholders);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#setPlaceholderPrefix(placeholderPrefix)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "placeholderPrefix"
    ],
    "position": {
      "column": 1,
      "line": 508
    },
    "return": "void",
    "signature": "public void setPlaceholderPrefix(String placeholderPrefix)",
    "source_code": "\tpublic void setPlaceholderPrefix(String placeholderPrefix) {\n\t\tthis.propertyResolver.setPlaceholderPrefix(placeholderPrefix);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#setPlaceholderSuffix(placeholderSuffix)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "placeholderSuffix"
    ],
    "position": {
      "column": 1,
      "line": 513
    },
    "return": "void",
    "signature": "public void setPlaceholderSuffix(String placeholderSuffix)",
    "source_code": "\tpublic void setPlaceholderSuffix(String placeholderSuffix) {\n\t\tthis.propertyResolver.setPlaceholderSuffix(placeholderSuffix);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#setRequiredProperties(requiredProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredProperties"
    ],
    "position": {
      "column": 1,
      "line": 533
    },
    "return": "void",
    "signature": "public void setRequiredProperties(String... requiredProperties)",
    "source_code": "\tpublic void setRequiredProperties(String... requiredProperties) {\n\t\tthis.propertyResolver.setRequiredProperties(requiredProperties);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#setValueSeparator(valueSeparator)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "valueSeparator"
    ],
    "position": {
      "column": 1,
      "line": 518
    },
    "return": "void",
    "signature": "public void setValueSeparator(@Nullable String valueSeparator)",
    "source_code": "\tpublic void setValueSeparator(@Nullable String valueSeparator) {\n\t\tthis.propertyResolver.setValueSeparator(valueSeparator);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#suppressGetenvAccess()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether to suppress {@link System#getenv()}/{@link System#getenv(String)}\n\t * access for the purposes of {@link #getSystemEnvironment()}.\n\t * <p>If this method returns {@code true}, an empty dummy Map will be used instead\n\t * of the regular system environment Map, never even trying to call {@code getenv}\n\t * and therefore avoiding security manager warnings (if any).\n\t * <p>The default implementation checks for the \"spring.getenv.ignore\" system property,\n\t * returning {@code true} if its value equals \"true\" in any case.\n\t * @see #IGNORE_GETENV_PROPERTY_NAME\n\t * @see SpringProperties#getFlag\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 466
    },
    "return": "boolean",
    "signature": "protected boolean suppressGetenvAccess()",
    "source_code": "\tprotected boolean suppressGetenvAccess() {\n\t\treturn SpringProperties.getFlag(IGNORE_GETENV_PROPERTY_NAME);\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 594
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" {activeProfiles=\" + this.activeProfiles +\n\t\t\t\t\", defaultProfiles=\" + this.defaultProfiles + \", propertySources=\" + this.propertySources + \"}\";\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#validateProfile(profile)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the given profile, called internally prior to adding to the set of\n\t * active or default profiles.\n\t * <p>Subclasses may override to impose further restrictions on profile syntax.\n\t * @throws IllegalArgumentException if the profile is null, empty, whitespace-only or\n\t * begins with the profile NOT operator (!).\n\t * @see #acceptsProfiles\n\t * @see #addActiveProfile\n\t * @see #setDefaultProfiles\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "profile"
    ],
    "position": {
      "column": 1,
      "line": 426
    },
    "return": "void",
    "signature": "protected void validateProfile(String profile)",
    "source_code": "\tprotected void validateProfile(String profile) {\n\t\tif (!StringUtils.hasText(profile)) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid profile [\" + profile + \"]: must contain text\");\n\t\t}\n\t\tif (profile.charAt(0) == '!') {\n\t\t\tthrow new IllegalArgumentException(\"Invalid profile [\" + profile + \"]: must not begin with ! operator\");\n\t\t}\n\t}"
  },
  "org.springframework.core.env.AbstractEnvironment#validateRequiredProperties()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 538
    },
    "return": "void",
    "signature": "public void validateRequiredProperties()",
    "source_code": "\tpublic void validateRequiredProperties() throws MissingRequiredPropertiesException {\n\t\tthis.propertyResolver.validateRequiredProperties();\n\t}"
  },
  "org.springframework.core.env.AbstractPropertyResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for resolving properties against any underlying source.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class AbstractPropertyResolver",
    "source_code": "public abstract class AbstractPropertyResolver implements ConfigurablePropertyResolver {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate volatile @Nullable ConfigurableConversionService conversionService;\n\n\tprivate @Nullable PropertyPlaceholderHelper nonStrictHelper;\n\n\tprivate @Nullable PropertyPlaceholderHelper strictHelper;\n\n\tprivate boolean ignoreUnresolvableNestedPlaceholders = false;\n\n\tprivate String placeholderPrefix = SystemPropertyUtils.PLACEHOLDER_PREFIX;\n\n\tprivate String placeholderSuffix = SystemPropertyUtils.PLACEHOLDER_SUFFIX;\n\n\tprivate @Nullable String valueSeparator = SystemPropertyUtils.VALUE_SEPARATOR;\n\n\tprivate @Nullable Character escapeCharacter = SystemPropertyUtils.ESCAPE_CHARACTER;\n\n\tprivate final Set<String> requiredProperties = new LinkedHashSet<>();\n\n\n\t@Override\n\tpublic ConfigurableConversionService getConversionService() {\n\t\t// Need to provide an independent DefaultConversionService, not the\n\t\t// shared DefaultConversionService used by PropertySourcesPropertyResolver.\n\t\tConfigurableConversionService cs = this.conversionService;\n\t\tif (cs == null) {\n\t\t\tsynchronized (this) {\n\t\t\t\tcs = this.conversionService;\n\t\t\t\tif (cs == null) {\n\t\t\t\t\tcs = new DefaultConversionService();\n\t\t\t\t\tthis.conversionService = cs;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cs;\n\t}\n\n\t@Override\n\tpublic void setConversionService(ConfigurableConversionService conversionService) {\n\t\tAssert.notNull(conversionService, \"ConversionService must not be null\");\n\t\tthis.conversionService = conversionService;\n\t}\n\n\t/**\n\t * Set the prefix that placeholders replaced by this resolver must begin with.\n\t * <p>The default is \"${\".\n\t * @see org.springframework.util.SystemPropertyUtils#PLACEHOLDER_PREFIX\n\t */\n\t@Override\n\tpublic void setPlaceholderPrefix(String placeholderPrefix) {\n\t\tAssert.notNull(placeholderPrefix, \"'placeholderPrefix' must not be null\");\n\t\tthis.placeholderPrefix = placeholderPrefix;\n\t}\n\n\t/**\n\t * Set the suffix that placeholders replaced by this resolver must end with.\n\t * <p>The default is \"}\".\n\t * @see org.springframework.util.SystemPropertyUtils#PLACEHOLDER_SUFFIX\n\t */\n\t@Override\n\tpublic void setPlaceholderSuffix(String placeholderSuffix) {\n\t\tAssert.notNull(placeholderSuffix, \"'placeholderSuffix' must not be null\");\n\t\tthis.placeholderSuffix = placeholderSuffix;\n\t}\n\n\t/**\n\t * Specify the separating character between the placeholders replaced by this\n\t * resolver and their associated default value, or {@code null} if no such\n\t * special character should be processed as a value separator.\n\t * <p>The default is \":\".\n\t * @see org.springframework.util.SystemPropertyUtils#VALUE_SEPARATOR\n\t */\n\t@Override\n\tpublic void setValueSeparator(@Nullable String valueSeparator) {\n\t\tthis.valueSeparator = valueSeparator;\n\t}\n\n\t/**\n\t * Specify the escape character to use to ignore placeholder prefix\n\t * or value separator, or {@code null} if no escaping should take\n\t * place.\n\t * <p>The default is \"\\\".\n\t * @since 6.2\n\t * @see org.springframework.util.SystemPropertyUtils#ESCAPE_CHARACTER\n\t */\n\t@Override\n\tpublic void setEscapeCharacter(@Nullable Character escapeCharacter) {\n\t\tthis.escapeCharacter = escapeCharacter;\n\t}\n\n\t/**\n\t * Set whether to throw an exception when encountering an unresolvable placeholder\n\t * nested within the value of a given property. A {@code false} value indicates strict\n\t * resolution, i.e. that an exception will be thrown. A {@code true} value indicates\n\t * that unresolvable nested placeholders should be passed through in their unresolved\n\t * ${...} form.\n\t * <p>The default is {@code false}.\n\t * @since 3.2\n\t */\n\t@Override\n\tpublic void setIgnoreUnresolvableNestedPlaceholders(boolean ignoreUnresolvableNestedPlaceholders) {\n\t\tthis.ignoreUnresolvableNestedPlaceholders = ignoreUnresolvableNestedPlaceholders;\n\t}\n\n\t@Override\n\tpublic void setRequiredProperties(String... requiredProperties) {\n\t\tCollections.addAll(this.requiredProperties, requiredProperties);\n\t}\n\n\t@Override\n\tpublic void validateRequiredProperties() {\n\t\tMissingRequiredPropertiesException ex = new MissingRequiredPropertiesException();\n\t\tfor (String key : this.requiredProperties) {\n\t\t\tif (this.getProperty(key) == null) {\n\t\t\t\tex.addMissingRequiredProperty(key);\n\t\t\t}\n\t\t}\n\t\tif (!ex.getMissingRequiredProperties().isEmpty()) {\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean containsProperty(String key) {\n\t\treturn (getProperty(key) != null);\n\t}\n\n\t@Override\n\tpublic @Nullable String getProperty(String key) {\n\t\treturn getProperty(key, String.class);\n\t}\n\n\t@Override\n\tpublic String getProperty(String key, String defaultValue) {\n\t\tString value = getProperty(key);\n\t\treturn (value != null ? value : defaultValue);\n\t}\n\n\t@Override\n\tpublic <T> T getProperty(String key, Class<T> targetType, T defaultValue) {\n\t\tT value = getProperty(key, targetType);\n\t\treturn (value != null ? value : defaultValue);\n\t}\n\n\t@Override\n\tpublic String getRequiredProperty(String key) throws IllegalStateException {\n\t\tString value = getProperty(key);\n\t\tif (value == null) {\n\t\t\tthrow new IllegalStateException(\"Required key '\" + key + \"' not found\");\n\t\t}\n\t\treturn value;\n\t}\n\n\t@Override\n\tpublic <T> T getRequiredProperty(String key, Class<T> valueType) throws IllegalStateException {\n\t\tT value = getProperty(key, valueType);\n\t\tif (value == null) {\n\t\t\tthrow new IllegalStateException(\"Required key '\" + key + \"' not found\");\n\t\t}\n\t\treturn value;\n\t}\n\n\t@Override\n\tpublic String resolvePlaceholders(String text) {\n\t\tif (this.nonStrictHelper == null) {\n\t\t\tthis.nonStrictHelper = createPlaceholderHelper(true);\n\t\t}\n\t\treturn doResolvePlaceholders(text, this.nonStrictHelper);\n\t}\n\n\t@Override\n\tpublic String resolveRequiredPlaceholders(String text) throws IllegalArgumentException {\n\t\tif (this.strictHelper == null) {\n\t\t\tthis.strictHelper = createPlaceholderHelper(false);\n\t\t}\n\t\treturn doResolvePlaceholders(text, this.strictHelper);\n\t}\n\n\t/**\n\t * Resolve placeholders within the given string, deferring to the value of\n\t * {@link #setIgnoreUnresolvableNestedPlaceholders} to determine whether any\n\t * unresolvable placeholders should raise an exception or be ignored.\n\t * <p>Invoked from {@link #getProperty} and its variants, implicitly resolving\n\t * nested placeholders. In contrast, {@link #resolvePlaceholders} and\n\t * {@link #resolveRequiredPlaceholders} do <i>not</i> delegate\n\t * to this method but rather perform their own handling of unresolvable\n\t * placeholders, as specified by each of those methods.\n\t * @since 3.2\n\t * @see #setIgnoreUnresolvableNestedPlaceholders\n\t */\n\tprotected String resolveNestedPlaceholders(String value) {\n\t\tif (value.isEmpty()) {\n\t\t\treturn value;\n\t\t}\n\t\treturn (this.ignoreUnresolvableNestedPlaceholders ?\n\t\t\t\tresolvePlaceholders(value) : resolveRequiredPlaceholders(value));\n\t}\n\n\tprivate PropertyPlaceholderHelper createPlaceholderHelper(boolean ignoreUnresolvablePlaceholders) {\n\t\treturn new PropertyPlaceholderHelper(this.placeholderPrefix, this.placeholderSuffix,\n\t\t\t\tthis.valueSeparator, this.escapeCharacter, ignoreUnresolvablePlaceholders);\n\t}\n\n\tprivate String doResolvePlaceholders(String text, PropertyPlaceholderHelper helper) {\n\t\treturn helper.replacePlaceholders(text, this::getPropertyAsRawString);\n\t}\n\n\t/**\n\t * Convert the given value to the specified target type, if necessary.\n\t * @param value the original property value\n\t * @param targetType the specified target type for property retrieval\n\t * @return the converted value, or the original value if no conversion\n\t * is necessary\n\t * @since 4.3.5\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected <T> @Nullable T convertValueIfNecessary(Object value, @Nullable Class<T> targetType) {\n\t\tif (targetType == null) {\n\t\t\treturn (T) value;\n\t\t}\n\t\tConversionService conversionServiceToUse = this.conversionService;\n\t\tif (conversionServiceToUse == null) {\n\t\t\t// Avoid initialization of shared DefaultConversionService if\n\t\t\t// no standard type conversion is needed in the first place...\n\t\t\tif (ClassUtils.isAssignableValue(targetType, value)) {\n\t\t\t\treturn (T) value;\n\t\t\t}\n\t\t\tconversionServiceToUse = DefaultConversionService.getSharedInstance();\n\t\t}\n\t\treturn conversionServiceToUse.convert(value, targetType);\n\t}\n\n\n\t/**\n\t * Retrieve the specified property as a raw String,\n\t * i.e. without resolution of nested placeholders.\n\t * @param key the property name to resolve\n\t * @return the property value or {@code null} if none found\n\t */\n\tprotected abstract @Nullable String getPropertyAsRawString(String key);\n\n}"
  },
  "org.springframework.core.env.AbstractPropertyResolver#containsProperty(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "boolean",
    "signature": "public boolean containsProperty(String key)",
    "source_code": "\tpublic boolean containsProperty(String key) {\n\t\treturn (getProperty(key) != null);\n\t}"
  },
  "org.springframework.core.env.AbstractPropertyResolver#convertValueIfNecessary(value,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given value to the specified target type, if necessary.\n\t * @param value the original property value\n\t * @param targetType the specified target type for property retrieval\n\t * @return the converted value, or the original value if no conversion\n\t * is necessary\n\t * @since 4.3.5\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "T",
    "signature": "protected T convertValueIfNecessary(Object value, @Nullable Class<T> targetType)",
    "source_code": "\tprotected <T> @Nullable T convertValueIfNecessary(Object value, @Nullable Class<T> targetType) {\n\t\tif (targetType == null) {\n\t\t\treturn (T) value;\n\t\t}\n\t\tConversionService conversionServiceToUse = this.conversionService;\n\t\tif (conversionServiceToUse == null) {\n\t\t\t// Avoid initialization of shared DefaultConversionService if\n\t\t\t// no standard type conversion is needed in the first place...\n\t\t\tif (ClassUtils.isAssignableValue(targetType, value)) {\n\t\t\t\treturn (T) value;\n\t\t\t}\n\t\t\tconversionServiceToUse = DefaultConversionService.getSharedInstance();\n\t\t}\n\t\treturn conversionServiceToUse.convert(value, targetType);\n\t}"
  },
  "org.springframework.core.env.AbstractPropertyResolver#getConversionService()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "ConfigurableConversionService",
    "signature": "public ConfigurableConversionService getConversionService()",
    "source_code": "\tpublic ConfigurableConversionService getConversionService() {\n\t\t// Need to provide an independent DefaultConversionService, not the\n\t\t// shared DefaultConversionService used by PropertySourcesPropertyResolver.\n\t\tConfigurableConversionService cs = this.conversionService;\n\t\tif (cs == null) {\n\t\t\tsynchronized (this) {\n\t\t\t\tcs = this.conversionService;\n\t\t\t\tif (cs == null) {\n\t\t\t\t\tcs = new DefaultConversionService();\n\t\t\t\t\tthis.conversionService = cs;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cs;\n\t}"
  },
  "org.springframework.core.env.AbstractPropertyResolver#getProperty(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "String",
    "signature": "public String getProperty(String key)",
    "source_code": "\tpublic @Nullable String getProperty(String key) {\n\t\treturn getProperty(key, String.class);\n\t}"
  },
  "org.springframework.core.env.AbstractPropertyResolver#getProperty(key,defaultValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "defaultValue"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "String",
    "signature": "public String getProperty(String key, String defaultValue)",
    "source_code": "\tpublic String getProperty(String key, String defaultValue) {\n\t\tString value = getProperty(key);\n\t\treturn (value != null ? value : defaultValue);\n\t}"
  },
  "org.springframework.core.env.AbstractPropertyResolver#getProperty(key,targetType,defaultValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "targetType",
      "defaultValue"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "T",
    "signature": "public T getProperty(String key, Class<T> targetType, T defaultValue)",
    "source_code": "\tpublic <T> T getProperty(String key, Class<T> targetType, T defaultValue) {\n\t\tT value = getProperty(key, targetType);\n\t\treturn (value != null ? value : defaultValue);\n\t}"
  },
  "org.springframework.core.env.AbstractPropertyResolver#getPropertyAsRawString(key)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the specified property as a raw String,\n\t * i.e. without resolution of nested placeholders.\n\t * @param key the property name to resolve\n\t * @return the property value or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "String",
    "signature": "protected String getPropertyAsRawString(String key)",
    "source_code": "\tprotected abstract @Nullable String getPropertyAsRawString(String key);"
  },
  "org.springframework.core.env.AbstractPropertyResolver#getRequiredProperty(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "String",
    "signature": "public String getRequiredProperty(String key)",
    "source_code": "\tpublic String getRequiredProperty(String key) throws IllegalStateException {\n\t\tString value = getProperty(key);\n\t\tif (value == null) {\n\t\t\tthrow new IllegalStateException(\"Required key '\" + key + \"' not found\");\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.core.env.AbstractPropertyResolver#getRequiredProperty(key,valueType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueType"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "T",
    "signature": "public T getRequiredProperty(String key, Class<T> valueType)",
    "source_code": "\tpublic <T> T getRequiredProperty(String key, Class<T> valueType) throws IllegalStateException {\n\t\tT value = getProperty(key, valueType);\n\t\tif (value == null) {\n\t\t\tthrow new IllegalStateException(\"Required key '\" + key + \"' not found\");\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.core.env.AbstractPropertyResolver#resolveNestedPlaceholders(value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve placeholders within the given string, deferring to the value of\n\t * {@link #setIgnoreUnresolvableNestedPlaceholders} to determine whether any\n\t * unresolvable placeholders should raise an exception or be ignored.\n\t * <p>Invoked from {@link #getProperty} and its variants, implicitly resolving\n\t * nested placeholders. In contrast, {@link #resolvePlaceholders} and\n\t * {@link #resolveRequiredPlaceholders} do <i>not</i> delegate\n\t * to this method but rather perform their own handling of unresolvable\n\t * placeholders, as specified by each of those methods.\n\t * @since 3.2\n\t * @see #setIgnoreUnresolvableNestedPlaceholders\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "String",
    "signature": "protected String resolveNestedPlaceholders(String value)",
    "source_code": "\tprotected String resolveNestedPlaceholders(String value) {\n\t\tif (value.isEmpty()) {\n\t\t\treturn value;\n\t\t}\n\t\treturn (this.ignoreUnresolvableNestedPlaceholders ?\n\t\t\t\tresolvePlaceholders(value) : resolveRequiredPlaceholders(value));\n\t}"
  },
  "org.springframework.core.env.AbstractPropertyResolver#resolvePlaceholders(text)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "String",
    "signature": "public String resolvePlaceholders(String text)",
    "source_code": "\tpublic String resolvePlaceholders(String text) {\n\t\tif (this.nonStrictHelper == null) {\n\t\t\tthis.nonStrictHelper = createPlaceholderHelper(true);\n\t\t}\n\t\treturn doResolvePlaceholders(text, this.nonStrictHelper);\n\t}"
  },
  "org.springframework.core.env.AbstractPropertyResolver#resolveRequiredPlaceholders(text)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "String",
    "signature": "public String resolveRequiredPlaceholders(String text)",
    "source_code": "\tpublic String resolveRequiredPlaceholders(String text) throws IllegalArgumentException {\n\t\tif (this.strictHelper == null) {\n\t\t\tthis.strictHelper = createPlaceholderHelper(false);\n\t\t}\n\t\treturn doResolvePlaceholders(text, this.strictHelper);\n\t}"
  },
  "org.springframework.core.env.AbstractPropertyResolver#setConversionService(conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void setConversionService(ConfigurableConversionService conversionService)",
    "source_code": "\tpublic void setConversionService(ConfigurableConversionService conversionService) {\n\t\tAssert.notNull(conversionService, \"ConversionService must not be null\");\n\t\tthis.conversionService = conversionService;\n\t}"
  },
  "org.springframework.core.env.AbstractPropertyResolver#setEscapeCharacter(escapeCharacter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the escape character to use to ignore placeholder prefix\n\t * or value separator, or {@code null} if no escaping should take\n\t * place.\n\t * <p>The default is \"\\\".\n\t * @since 6.2\n\t * @see org.springframework.util.SystemPropertyUtils#ESCAPE_CHARACTER\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "escapeCharacter"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void setEscapeCharacter(@Nullable Character escapeCharacter)",
    "source_code": "\tpublic void setEscapeCharacter(@Nullable Character escapeCharacter) {\n\t\tthis.escapeCharacter = escapeCharacter;\n\t}"
  },
  "org.springframework.core.env.AbstractPropertyResolver#setIgnoreUnresolvableNestedPlaceholders(ignoreUnresolvableNestedPlaceholders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to throw an exception when encountering an unresolvable placeholder\n\t * nested within the value of a given property. A {@code false} value indicates strict\n\t * resolution, i.e. that an exception will be thrown. A {@code true} value indicates\n\t * that unresolvable nested placeholders should be passed through in their unresolved\n\t * ${...} form.\n\t * <p>The default is {@code false}.\n\t * @since 3.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ignoreUnresolvableNestedPlaceholders"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "public void setIgnoreUnresolvableNestedPlaceholders(boolean ignoreUnresolvableNestedPlaceholders)",
    "source_code": "\tpublic void setIgnoreUnresolvableNestedPlaceholders(boolean ignoreUnresolvableNestedPlaceholders) {\n\t\tthis.ignoreUnresolvableNestedPlaceholders = ignoreUnresolvableNestedPlaceholders;\n\t}"
  },
  "org.springframework.core.env.AbstractPropertyResolver#setPlaceholderPrefix(placeholderPrefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the prefix that placeholders replaced by this resolver must begin with.\n\t * <p>The default is \"${\".\n\t * @see org.springframework.util.SystemPropertyUtils#PLACEHOLDER_PREFIX\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "placeholderPrefix"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void setPlaceholderPrefix(String placeholderPrefix)",
    "source_code": "\tpublic void setPlaceholderPrefix(String placeholderPrefix) {\n\t\tAssert.notNull(placeholderPrefix, \"'placeholderPrefix' must not be null\");\n\t\tthis.placeholderPrefix = placeholderPrefix;\n\t}"
  },
  "org.springframework.core.env.AbstractPropertyResolver#setPlaceholderSuffix(placeholderSuffix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the suffix that placeholders replaced by this resolver must end with.\n\t * <p>The default is \"}\".\n\t * @see org.springframework.util.SystemPropertyUtils#PLACEHOLDER_SUFFIX\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "placeholderSuffix"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void setPlaceholderSuffix(String placeholderSuffix)",
    "source_code": "\tpublic void setPlaceholderSuffix(String placeholderSuffix) {\n\t\tAssert.notNull(placeholderSuffix, \"'placeholderSuffix' must not be null\");\n\t\tthis.placeholderSuffix = placeholderSuffix;\n\t}"
  },
  "org.springframework.core.env.AbstractPropertyResolver#setRequiredProperties(requiredProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredProperties"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "public void setRequiredProperties(String... requiredProperties)",
    "source_code": "\tpublic void setRequiredProperties(String... requiredProperties) {\n\t\tCollections.addAll(this.requiredProperties, requiredProperties);\n\t}"
  },
  "org.springframework.core.env.AbstractPropertyResolver#setValueSeparator(valueSeparator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the separating character between the placeholders replaced by this\n\t * resolver and their associated default value, or {@code null} if no such\n\t * special character should be processed as a value separator.\n\t * <p>The default is \":\".\n\t * @see org.springframework.util.SystemPropertyUtils#VALUE_SEPARATOR\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "valueSeparator"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "void",
    "signature": "public void setValueSeparator(@Nullable String valueSeparator)",
    "source_code": "\tpublic void setValueSeparator(@Nullable String valueSeparator) {\n\t\tthis.valueSeparator = valueSeparator;\n\t}"
  },
  "org.springframework.core.env.AbstractPropertyResolver#validateRequiredProperties()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "void",
    "signature": "public void validateRequiredProperties()",
    "source_code": "\tpublic void validateRequiredProperties() {\n\t\tMissingRequiredPropertiesException ex = new MissingRequiredPropertiesException();\n\t\tfor (String key : this.requiredProperties) {\n\t\t\tif (this.getProperty(key) == null) {\n\t\t\t\tex.addMissingRequiredProperty(key);\n\t\t\t}\n\t\t}\n\t\tif (!ex.getMissingRequiredProperties().isEmpty()) {\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.core.env.DEFAULT_PROFILES_PROPERTY_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Name of the property to set to specify profiles that are active by default: {@value}.\n\t * <p>The value may be comma delimited.\n\t * <p>Note that certain shell environments such as Bash disallow the use of the period\n\t * character in variable names. Assuming that Spring's {@link SystemEnvironmentPropertySource}\n\t * is in use, this property may be specified as an environment variable named\n\t * {@code SPRING_PROFILES_DEFAULT}.\n\t * @see ConfigurableEnvironment#setDefaultProfiles\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "signature": "public String DEFAULT_PROFILES_PROPERTY_NAME",
    "source_code": "\tpublic static final String DEFAULT_PROFILES_PROPERTY_NAME = \"spring.profiles.default\";",
    "type": "String"
  },
  "org.springframework.core.env.IGNORE_GETENV_PROPERTY_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * System property that instructs Spring to ignore system environment variables,\n\t * i.e. to never attempt to retrieve such a variable via {@link System#getenv()}.\n\t * <p>The default is \"false\", falling back to system environment variable checks if a\n\t * Spring environment property (for example, a placeholder in a configuration String) isn't\n\t * resolvable otherwise. Consider switching this flag to \"true\" if you experience\n\t * log warnings from {@code getenv} calls coming from Spring.\n\t * @see #suppressGetenvAccess()\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "signature": "public String IGNORE_GETENV_PROPERTY_NAME",
    "source_code": "\tpublic static final String IGNORE_GETENV_PROPERTY_NAME = \"spring.getenv.ignore\";",
    "type": "String"
  },
  "org.springframework.core.env.PropertyResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Interface for resolving properties against any underlying source.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.1\n * @see Environment\n * @see PropertySourcesPropertyResolver\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 30
    },
    "signature": "public interface PropertyResolver",
    "source_code": "public interface PropertyResolver {\n\n\t/**\n\t * Return whether the given property key is available for resolution,\n\t * i.e. if the value for the given key is not {@code null}.\n\t */\n\tboolean containsProperty(String key);\n\n\t/**\n\t * Return the property value associated with the given key,\n\t * or {@code null} if the key cannot be resolved.\n\t * @param key the property name to resolve\n\t * @see #getProperty(String, String)\n\t * @see #getProperty(String, Class)\n\t * @see #getRequiredProperty(String)\n\t */\n\t@Nullable String getProperty(String key);\n\n\t/**\n\t * Return the property value associated with the given key, or\n\t * {@code defaultValue} if the key cannot be resolved.\n\t * @param key the property name to resolve\n\t * @param defaultValue the default value to return if no value is found\n\t * @see #getRequiredProperty(String)\n\t * @see #getProperty(String, Class)\n\t */\n\tString getProperty(String key, String defaultValue);\n\n\t/**\n\t * Return the property value associated with the given key,\n\t * or {@code null} if the key cannot be resolved.\n\t * @param key the property name to resolve\n\t * @param targetType the expected type of the property value\n\t * @see #getRequiredProperty(String, Class)\n\t */\n\t<T> @Nullable T getProperty(String key, Class<T> targetType);\n\n\t/**\n\t * Return the property value associated with the given key,\n\t * or {@code defaultValue} if the key cannot be resolved.\n\t * @param key the property name to resolve\n\t * @param targetType the expected type of the property value\n\t * @param defaultValue the default value to return if no value is found\n\t * @see #getRequiredProperty(String, Class)\n\t */\n\t<T> T getProperty(String key, Class<T> targetType, T defaultValue);\n\n\t/**\n\t * Return the property value associated with the given key (never {@code null}).\n\t * @throws IllegalStateException if the key cannot be resolved\n\t * @see #getRequiredProperty(String, Class)\n\t */\n\tString getRequiredProperty(String key) throws IllegalStateException;\n\n\t/**\n\t * Return the property value associated with the given key, converted to the given\n\t * targetType (never {@code null}).\n\t * @throws IllegalStateException if the given key cannot be resolved\n\t */\n\t<T> T getRequiredProperty(String key, Class<T> targetType) throws IllegalStateException;\n\n\t/**\n\t * Resolve ${...} placeholders in the given text, replacing them with corresponding\n\t * property values as resolved by {@link #getProperty}. Unresolvable placeholders with\n\t * no default value are ignored and passed through unchanged.\n\t * @param text the String to resolve\n\t * @return the resolved String (never {@code null})\n\t * @throws IllegalArgumentException if given text is {@code null}\n\t * @see #resolveRequiredPlaceholders\n\t */\n\tString resolvePlaceholders(String text);\n\n\t/**\n\t * Resolve ${...} placeholders in the given text, replacing them with corresponding\n\t * property values as resolved by {@link #getProperty}. Unresolvable placeholders with\n\t * no default value will cause an IllegalArgumentException to be thrown.\n\t * @return the resolved String (never {@code null})\n\t * @throws IllegalArgumentException if given text is {@code null}\n\t * or if any placeholders are unresolvable\n\t */\n\tString resolveRequiredPlaceholders(String text) throws IllegalArgumentException;\n\n}"
  },
  "org.springframework.core.env.RESERVED_DEFAULT_PROFILE_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Name of the reserved default profile name: {@value}.\n\t * <p>If no default profile names are explicitly set and no active profile names\n\t * are explicitly set, this profile will automatically be activated by default.\n\t * @see #getReservedDefaultProfiles\n\t * @see ConfigurableEnvironment#setDefaultProfiles\n\t * @see ConfigurableEnvironment#setActiveProfiles\n\t * @see AbstractEnvironment#DEFAULT_PROFILES_PROPERTY_NAME\n\t * @see AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "signature": "public String RESERVED_DEFAULT_PROFILE_NAME",
    "source_code": "\tpublic static final String RESERVED_DEFAULT_PROFILE_NAME = \"default\";",
    "type": "String"
  },
  "org.springframework.core.io.support.ArgumentResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Strategy for resolving constructor arguments based on their type.\n\t * @since 6.0\n\t * @see ArgumentResolver#of(Class, Object)\n\t * @see ArgumentResolver#ofSupplied(Class, Supplier)\n\t * @see ArgumentResolver#from(Function)\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 496
    },
    "signature": "public interface ArgumentResolver",
    "source_code": "\tpublic interface ArgumentResolver {\n\n\t\t/**\n\t\t * Resolve the given argument if possible.\n\t\t * @param <T> the argument type\n\t\t * @param type the argument type\n\t\t * @return the resolved argument value or {@code null}\n\t\t */\n\t\t<T> @Nullable T resolve(Class<T> type);\n\n\t\t/**\n\t\t * Create a new composed {@link ArgumentResolver} by combining this resolver\n\t\t * with the given type and value.\n\t\t * @param <T> the argument type\n\t\t * @param type the argument type\n\t\t * @param value the argument value\n\t\t * @return a new composite {@link ArgumentResolver} instance\n\t\t */\n\t\tdefault <T> ArgumentResolver and(Class<T> type, T value) {\n\t\t\treturn and(ArgumentResolver.of(type, value));\n\t\t}\n\n\t\t/**\n\t\t * Create a new composed {@link ArgumentResolver} by combining this resolver\n\t\t * with the given type and value.\n\t\t * @param <T> the argument type\n\t\t * @param type the argument type\n\t\t * @param valueSupplier the argument value supplier\n\t\t * @return a new composite {@link ArgumentResolver} instance\n\t\t */\n\t\tdefault <T> ArgumentResolver andSupplied(Class<T> type, Supplier<T> valueSupplier) {\n\t\t\treturn and(ArgumentResolver.ofSupplied(type, valueSupplier));\n\t\t}\n\n\t\t/**\n\t\t * Create a new composed {@link ArgumentResolver} by combining this resolver\n\t\t * with the given resolver.\n\t\t * @param argumentResolver the argument resolver to add\n\t\t * @return a new composite {@link ArgumentResolver} instance\n\t\t */\n\t\tdefault ArgumentResolver and(ArgumentResolver argumentResolver) {\n\t\t\treturn from(type -> {\n\t\t\t\tObject resolved = resolve(type);\n\t\t\t\treturn (resolved != null ? resolved : argumentResolver.resolve(type));\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Factory method that returns an {@link ArgumentResolver} that always\n\t\t * returns {@code null}.\n\t\t * @return a new {@link ArgumentResolver} instance\n\t\t */\n\t\tstatic ArgumentResolver none() {\n\t\t\treturn from(type -> null);\n\t\t}\n\n\t\t/**\n\t\t * Factory method that can be used to create an {@link ArgumentResolver}\n\t\t * that resolves only the given type.\n\t\t * @param <T> the argument type\n\t\t * @param type the argument type\n\t\t * @param value the argument value\n\t\t * @return a new {@link ArgumentResolver} instance\n\t\t */\n\t\tstatic <T> ArgumentResolver of(Class<T> type, T value) {\n\t\t\treturn ofSupplied(type, () -> value);\n\t\t}\n\n\t\t/**\n\t\t * Factory method that can be used to create an {@link ArgumentResolver}\n\t\t * that resolves only the given type.\n\t\t * @param <T> the argument type\n\t\t * @param type the argument type\n\t\t * @param valueSupplier the argument value supplier\n\t\t * @return a new {@link ArgumentResolver} instance\n\t\t */\n\t\tstatic <T> ArgumentResolver ofSupplied(Class<T> type, Supplier<T> valueSupplier) {\n\t\t\treturn from(candidateType -> (candidateType.equals(type) ? valueSupplier.get() : null));\n\t\t}\n\n\t\t/**\n\t\t * Factory method that creates a new {@link ArgumentResolver} from a\n\t\t * lambda friendly function. The given function is provided with the\n\t\t * argument type and must provide an instance of that type or {@code null}.\n\t\t * @param function the resolver function\n\t\t * @return a new {@link ArgumentResolver} instance backed by the function\n\t\t */\n\t\tstatic ArgumentResolver from(Function<Class<?>, @Nullable Object> function) {\n\t\t\treturn new ArgumentResolver() {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t@Override\n\t\t\t\tpublic <T> @Nullable T resolve(Class<T> type) {\n\t\t\t\t\treturn (T) function.apply(type);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}"
  },
  "org.springframework.core.io.support.FACTORIES_RESOURCE_LOCATION": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The location to look for factories.\n\t * <p>Can be present in multiple JAR files.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "signature": "public String FACTORIES_RESOURCE_LOCATION",
    "source_code": "\tpublic static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";",
    "type": "String"
  },
  "org.springframework.core.io.support.FailureHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Strategy for handling a failure that occurs when instantiating a factory.\n\t * @since 6.0\n\t * @see FailureHandler#throwing()\n\t * @see FailureHandler#logging(Log)\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 602
    },
    "signature": "public interface FailureHandler",
    "source_code": "\tpublic interface FailureHandler {\n\n\t\t/**\n\t\t * Handle the {@code failure} that occurred when instantiating the\n\t\t * {@code factoryImplementationName} that was expected to be of the\n\t\t * given {@code factoryType}.\n\t\t * @param factoryType the type of the factory\n\t\t * @param factoryImplementationName the name of the factory implementation\n\t\t * @param failure the failure that occurred\n\t\t * @see #throwing()\n\t\t * @see #logging\n\t\t */\n\t\tvoid handleFailure(Class<?> factoryType, String factoryImplementationName, Throwable failure);\n\n\n\t\t/**\n\t\t * Create a new {@link FailureHandler} that handles errors by throwing an\n\t\t * {@link IllegalArgumentException}.\n\t\t * @return a new {@link FailureHandler} instance\n\t\t * @see #throwing(BiFunction)\n\t\t */\n\t\tstatic FailureHandler throwing() {\n\t\t\treturn throwing(IllegalArgumentException::new);\n\t\t}\n\n\t\t/**\n\t\t * Create a new {@link FailureHandler} that handles errors by throwing an\n\t\t * exception.\n\t\t * @param exceptionFactory factory used to create the exception\n\t\t * @return a new {@link FailureHandler} instance\n\t\t */\n\t\tstatic FailureHandler throwing(BiFunction<String, Throwable, ? extends RuntimeException> exceptionFactory) {\n\t\t\treturn handleMessage((messageSupplier, failure) -> {\n\t\t\t\tthrow exceptionFactory.apply(messageSupplier.get(), failure);\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Create a new {@link FailureHandler} that handles errors by logging trace\n\t\t * messages.\n\t\t * @param logger the logger used to log messages\n\t\t * @return a new {@link FailureHandler} instance\n\t\t */\n\t\tstatic FailureHandler logging(Log logger) {\n\t\t\treturn handleMessage((messageSupplier, failure) -> logger.trace(LogMessage.of(messageSupplier), failure));\n\t\t}\n\n\t\t/**\n\t\t * Create a new {@link FailureHandler} that handles errors using a standard\n\t\t * formatted message.\n\t\t * @param messageHandler the message handler used to handle the problem\n\t\t * @return a new {@link FailureHandler} instance\n\t\t */\n\t\tstatic FailureHandler handleMessage(BiConsumer<Supplier<String>, Throwable> messageHandler) {\n\t\t\treturn (factoryType, factoryImplementationName, failure) -> {\n\t\t\t\tSupplier<String> messageSupplier = () -> \"Unable to instantiate factory class [%s] for factory type [%s]\"\n\t\t\t\t\t\t.formatted(factoryImplementationName, factoryType.getName());\n\t\t\t\tmessageHandler.accept(messageSupplier, failure);\n\t\t\t};\n\t\t}\n\t}"
  },
  "org.springframework.core.io.support.PropertiesLoaderSupport": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Base class for JavaBean-style components that need to load properties\n * from one or more resources. Supports local properties as well, with\n * configurable overriding.\n *\n * @author Juergen Hoeller\n * @since 1.2.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class PropertiesLoaderSupport",
    "source_code": "public abstract class PropertiesLoaderSupport {\n\n\t/** Logger available to subclasses. */\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprotected Properties @Nullable [] localProperties;\n\n\tprotected boolean localOverride = false;\n\n\tprivate Resource @Nullable [] locations;\n\n\tprivate boolean ignoreResourceNotFound = false;\n\n\tprivate @Nullable String fileEncoding;\n\n\tprivate PropertiesPersister propertiesPersister = DefaultPropertiesPersister.INSTANCE;\n\n\n\t/**\n\t * Set local properties, for example, via the \"props\" tag in XML bean definitions.\n\t * These can be considered defaults, to be overridden by properties\n\t * loaded from files.\n\t */\n\tpublic void setProperties(Properties properties) {\n\t\tthis.localProperties = new Properties[] {properties};\n\t}\n\n\t/**\n\t * Set local properties, for example, via the \"props\" tag in XML bean definitions,\n\t * allowing for merging multiple properties sets into one.\n\t */\n\tpublic void setPropertiesArray(Properties... propertiesArray) {\n\t\tthis.localProperties = propertiesArray;\n\t}\n\n\t/**\n\t * Set a location of a properties file to be loaded.\n\t * <p>Can point to a classic properties file or to an XML file\n\t * that follows Java's properties XML format.\n\t */\n\tpublic void setLocation(Resource location) {\n\t\tthis.locations = new Resource[] {location};\n\t}\n\n\t/**\n\t * Set locations of properties files to be loaded.\n\t * <p>Can point to classic properties files or to XML files\n\t * that follow Java's properties XML format.\n\t * <p>Note: Properties defined in later files will override\n\t * properties defined earlier files, in case of overlapping keys.\n\t * Hence, make sure that the most specific files are the last\n\t * ones in the given list of locations.\n\t */\n\tpublic void setLocations(Resource... locations) {\n\t\tthis.locations = locations;\n\t}\n\n\t/**\n\t * Set whether local properties override properties from files.\n\t * <p>Default is \"false\": Properties from files override local defaults.\n\t * Can be switched to \"true\" to let local properties override defaults\n\t * from files.\n\t */\n\tpublic void setLocalOverride(boolean localOverride) {\n\t\tthis.localOverride = localOverride;\n\t}\n\n\t/**\n\t * Set if failure to find the property resource should be ignored.\n\t * <p>\"true\" is appropriate if the properties file is completely optional.\n\t * Default is \"false\".\n\t */\n\tpublic void setIgnoreResourceNotFound(boolean ignoreResourceNotFound) {\n\t\tthis.ignoreResourceNotFound = ignoreResourceNotFound;\n\t}\n\n\t/**\n\t * Set the encoding to use for parsing properties files.\n\t * <p>Default is none, using the {@code java.util.Properties}\n\t * default encoding.\n\t * <p>Only applies to classic properties files, not to XML files.\n\t * @see org.springframework.util.PropertiesPersister#load\n\t */\n\tpublic void setFileEncoding(String encoding) {\n\t\tthis.fileEncoding = encoding;\n\t}\n\n\t/**\n\t * Set the PropertiesPersister to use for parsing properties files.\n\t * The default is {@code DefaultPropertiesPersister}.\n\t * @see DefaultPropertiesPersister#INSTANCE\n\t */\n\tpublic void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister) {\n\t\tthis.propertiesPersister =\n\t\t\t\t(propertiesPersister != null ? propertiesPersister : DefaultPropertiesPersister.INSTANCE);\n\t}\n\n\n\t/**\n\t * Return a merged Properties instance containing both the\n\t * loaded properties and properties set on this FactoryBean.\n\t */\n\tprotected Properties mergeProperties() throws IOException {\n\t\tProperties result = new Properties();\n\n\t\tif (this.localOverride) {\n\t\t\t// Load properties from file upfront, to let local properties override.\n\t\t\tloadProperties(result);\n\t\t}\n\n\t\tif (this.localProperties != null) {\n\t\t\tfor (Properties localProp : this.localProperties) {\n\t\t\t\tCollectionUtils.mergePropertiesIntoMap(localProp, result);\n\t\t\t}\n\t\t}\n\n\t\tif (!this.localOverride) {\n\t\t\t// Load properties from file afterwards, to let those properties override.\n\t\t\tloadProperties(result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Load properties into the given instance.\n\t * @param props the Properties instance to load into\n\t * @throws IOException in case of I/O errors\n\t * @see #setLocations\n\t */\n\tprotected void loadProperties(Properties props) throws IOException {\n\t\tif (this.locations != null) {\n\t\t\tfor (Resource location : this.locations) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Loading properties file from \" + location);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tPropertiesLoaderUtils.fillProperties(\n\t\t\t\t\t\t\tprops, new EncodedResource(location, this.fileEncoding), this.propertiesPersister);\n\t\t\t\t}\n\t\t\t\tcatch (FileNotFoundException | UnknownHostException | SocketException ex) {\n\t\t\t\t\tif (this.ignoreResourceNotFound) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Properties resource not found: \" + ex.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.core.io.support.PropertiesLoaderSupport#loadProperties(props)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load properties into the given instance.\n\t * @param props the Properties instance to load into\n\t * @throws IOException in case of I/O errors\n\t * @see #setLocations\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "props"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "void",
    "signature": "protected void loadProperties(Properties props)",
    "source_code": "\tprotected void loadProperties(Properties props) throws IOException {\n\t\tif (this.locations != null) {\n\t\t\tfor (Resource location : this.locations) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Loading properties file from \" + location);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tPropertiesLoaderUtils.fillProperties(\n\t\t\t\t\t\t\tprops, new EncodedResource(location, this.fileEncoding), this.propertiesPersister);\n\t\t\t\t}\n\t\t\t\tcatch (FileNotFoundException | UnknownHostException | SocketException ex) {\n\t\t\t\t\tif (this.ignoreResourceNotFound) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Properties resource not found: \" + ex.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.io.support.PropertiesLoaderSupport#mergeProperties()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a merged Properties instance containing both the\n\t * loaded properties and properties set on this FactoryBean.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "Properties",
    "signature": "protected Properties mergeProperties()",
    "source_code": "\tprotected Properties mergeProperties() throws IOException {\n\t\tProperties result = new Properties();\n\n\t\tif (this.localOverride) {\n\t\t\t// Load properties from file upfront, to let local properties override.\n\t\t\tloadProperties(result);\n\t\t}\n\n\t\tif (this.localProperties != null) {\n\t\t\tfor (Properties localProp : this.localProperties) {\n\t\t\t\tCollectionUtils.mergePropertiesIntoMap(localProp, result);\n\t\t\t}\n\t\t}\n\n\t\tif (!this.localOverride) {\n\t\t\t// Load properties from file afterwards, to let those properties override.\n\t\t\tloadProperties(result);\n\t\t}\n\n\t\treturn result;\n\t}"
  },
  "org.springframework.core.io.support.PropertiesLoaderSupport#setFileEncoding(encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the encoding to use for parsing properties files.\n\t * <p>Default is none, using the {@code java.util.Properties}\n\t * default encoding.\n\t * <p>Only applies to classic properties files, not to XML files.\n\t * @see org.springframework.util.PropertiesPersister#load\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void setFileEncoding(String encoding)",
    "source_code": "\tpublic void setFileEncoding(String encoding) {\n\t\tthis.fileEncoding = encoding;\n\t}"
  },
  "org.springframework.core.io.support.PropertiesLoaderSupport#setIgnoreResourceNotFound(ignoreResourceNotFound)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set if failure to find the property resource should be ignored.\n\t * <p>\"true\" is appropriate if the properties file is completely optional.\n\t * Default is \"false\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ignoreResourceNotFound"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "void",
    "signature": "public void setIgnoreResourceNotFound(boolean ignoreResourceNotFound)",
    "source_code": "\tpublic void setIgnoreResourceNotFound(boolean ignoreResourceNotFound) {\n\t\tthis.ignoreResourceNotFound = ignoreResourceNotFound;\n\t}"
  },
  "org.springframework.core.io.support.PropertiesLoaderSupport#setLocalOverride(localOverride)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether local properties override properties from files.\n\t * <p>Default is \"false\": Properties from files override local defaults.\n\t * Can be switched to \"true\" to let local properties override defaults\n\t * from files.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "localOverride"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void setLocalOverride(boolean localOverride)",
    "source_code": "\tpublic void setLocalOverride(boolean localOverride) {\n\t\tthis.localOverride = localOverride;\n\t}"
  },
  "org.springframework.core.io.support.PropertiesLoaderSupport#setLocation(location)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a location of a properties file to be loaded.\n\t * <p>Can point to a classic properties file or to an XML file\n\t * that follows Java's properties XML format.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "public void setLocation(Resource location)",
    "source_code": "\tpublic void setLocation(Resource location) {\n\t\tthis.locations = new Resource[] {location};\n\t}"
  },
  "org.springframework.core.io.support.PropertiesLoaderSupport#setLocations(locations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set locations of properties files to be loaded.\n\t * <p>Can point to classic properties files or to XML files\n\t * that follow Java's properties XML format.\n\t * <p>Note: Properties defined in later files will override\n\t * properties defined earlier files, in case of overlapping keys.\n\t * Hence, make sure that the most specific files are the last\n\t * ones in the given list of locations.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "void",
    "signature": "public void setLocations(Resource... locations)",
    "source_code": "\tpublic void setLocations(Resource... locations) {\n\t\tthis.locations = locations;\n\t}"
  },
  "org.springframework.core.io.support.PropertiesLoaderSupport#setProperties(properties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set local properties, for example, via the \"props\" tag in XML bean definitions.\n\t * These can be considered defaults, to be overridden by properties\n\t * loaded from files.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void setProperties(Properties properties)",
    "source_code": "\tpublic void setProperties(Properties properties) {\n\t\tthis.localProperties = new Properties[] {properties};\n\t}"
  },
  "org.springframework.core.io.support.PropertiesLoaderSupport#setPropertiesArray(propertiesArray)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set local properties, for example, via the \"props\" tag in XML bean definitions,\n\t * allowing for merging multiple properties sets into one.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertiesArray"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "public void setPropertiesArray(Properties... propertiesArray)",
    "source_code": "\tpublic void setPropertiesArray(Properties... propertiesArray) {\n\t\tthis.localProperties = propertiesArray;\n\t}"
  },
  "org.springframework.core.io.support.PropertiesLoaderSupport#setPropertiesPersister(propertiesPersister)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the PropertiesPersister to use for parsing properties files.\n\t * The default is {@code DefaultPropertiesPersister}.\n\t * @see DefaultPropertiesPersister#INSTANCE\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertiesPersister"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister)",
    "source_code": "\tpublic void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister) {\n\t\tthis.propertiesPersister =\n\t\t\t\t(propertiesPersister != null ? propertiesPersister : DefaultPropertiesPersister.INSTANCE);\n\t}"
  },
  "org.springframework.core.io.support.SpringFactoriesLoader": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * General purpose factory loading mechanism for internal use within the framework.\n *\n * <p>{@code SpringFactoriesLoader} {@linkplain #loadFactories loads} and instantiates\n * factories of a given type from {@value #FACTORIES_RESOURCE_LOCATION} files which\n * may be present in multiple JAR files in the classpath. The {@code spring.factories}\n * file must be in {@link Properties} format, where the key is the fully qualified\n * name of the interface or abstract class, and the value is a comma-separated list of\n * implementation class names. For example:\n *\n * <pre class=\"code\">example.MyService=example.MyServiceImpl1,example.MyServiceImpl2</pre>\n *\n * where {@code example.MyService} is the name of the interface, and {@code MyServiceImpl1}\n * and {@code MyServiceImpl2} are two implementations.\n *\n * <p>Implementation classes <b>must</b> have a single resolvable constructor that will\n * be used to create the instance, either:\n * <ul>\n * <li>a primary or single constructor</li>\n * <li>a single public constructor</li>\n * <li>the default constructor</li>\n * </ul>\n *\n * <p>If the resolvable constructor has arguments, a suitable {@link ArgumentResolver\n * ArgumentResolver} should be provided. To customize how instantiation failures\n * are handled, consider providing a {@link FailureHandler FailureHandler}.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Andy Wilkinson\n * @author Madhura Bhave\n * @author Phillip Webb\n * @since 3.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "signature": "public class SpringFactoriesLoader",
    "source_code": "public class SpringFactoriesLoader {\n\n\t/**\n\t * The location to look for factories.\n\t * <p>Can be present in multiple JAR files.\n\t */\n\tpublic static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";\n\n\tprivate static final FailureHandler THROWING_FAILURE_HANDLER = FailureHandler.throwing();\n\n\tprivate static final Log logger = LogFactory.getLog(SpringFactoriesLoader.class);\n\n\tstatic final Map<ClassLoader, Map<String, SpringFactoriesLoader>> cache = new ConcurrentReferenceHashMap<>();\n\n\n\tprivate final @Nullable ClassLoader classLoader;\n\n\tprivate final Map<String, List<String>> factories;\n\n\n\t/**\n\t * Create a new {@link SpringFactoriesLoader} instance.\n\t * @param classLoader the classloader used to instantiate the factories\n\t * @param factories a map of factory class name to implementation class names\n\t * @since 6.0\n\t */\n\tprotected SpringFactoriesLoader(@Nullable ClassLoader classLoader, Map<String, List<String>> factories) {\n\t\tthis.classLoader = classLoader;\n\t\tthis.factories = factories;\n\t}\n\n\n\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\n\t * and a default argument resolver that expects a no-arg constructor.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>If a custom instantiation strategy is required, use {@code load(...)}\n\t * with a custom {@link ArgumentResolver ArgumentResolver} and/or\n\t * {@link FailureHandler FailureHandler}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @throws IllegalArgumentException if any factory implementation class cannot\n\t * be loaded or if an error occurs while instantiating any factory\n\t * @since 6.0\n\t */\n\tpublic <T> List<T> load(Class<T> factoryType) {\n\t\treturn load(factoryType, null, null);\n\t}\n\n\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\n\t * and the given argument resolver.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param argumentResolver strategy used to resolve constructor arguments by their type\n\t * @throws IllegalArgumentException if any factory implementation class cannot\n\t * be loaded or if an error occurs while instantiating any factory\n\t * @since 6.0\n\t */\n\tpublic <T> List<T> load(Class<T> factoryType, @Nullable ArgumentResolver argumentResolver) {\n\t\treturn load(factoryType, argumentResolver, null);\n\t}\n\n\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\n\t * with custom failure handling provided by the given failure handler.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * <p>For any factory implementation class that cannot be loaded or error that\n\t * occurs while instantiating it, the given failure handler is called.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param failureHandler strategy used to handle factory instantiation failures\n\t * @since 6.0\n\t */\n\tpublic <T> List<T> load(Class<T> factoryType, @Nullable FailureHandler failureHandler) {\n\t\treturn load(factoryType, null, failureHandler);\n\t}\n\n\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader,\n\t * the given argument resolver, and custom failure handling provided by the given\n\t * failure handler.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * <p>For any factory implementation class that cannot be loaded or error that\n\t * occurs while instantiating it, the given failure handler is called.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param argumentResolver strategy used to resolve constructor arguments by their type\n\t * @param failureHandler strategy used to handle factory instantiation failures\n\t * @since 6.0\n\t */\n\tpublic <T> List<T> load(Class<T> factoryType, @Nullable ArgumentResolver argumentResolver,\n\t\t\t@Nullable FailureHandler failureHandler) {\n\n\t\tAssert.notNull(factoryType, \"'factoryType' must not be null\");\n\t\tList<String> implementationNames = loadFactoryNames(factoryType);\n\t\tlogger.trace(LogMessage.format(\"Loaded [%s] names: %s\", factoryType.getName(), implementationNames));\n\t\tList<T> result = new ArrayList<>(implementationNames.size());\n\t\tFailureHandler failureHandlerToUse = (failureHandler != null) ? failureHandler : THROWING_FAILURE_HANDLER;\n\t\tfor (String implementationName : implementationNames) {\n\t\t\tT factory = instantiateFactory(implementationName, factoryType, argumentResolver, failureHandlerToUse);\n\t\t\tif (factory != null) {\n\t\t\t\tresult.add(factory);\n\t\t\t}\n\t\t}\n\t\tAnnotationAwareOrderComparator.sort(result);\n\t\treturn result;\n\t}\n\n\tprivate List<String> loadFactoryNames(Class<?> factoryType) {\n\t\treturn this.factories.getOrDefault(factoryType.getName(), Collections.emptyList());\n\t}\n\n\tprotected <T> @Nullable T instantiateFactory(String implementationName, Class<T> type,\n\t\t\t@Nullable ArgumentResolver argumentResolver, FailureHandler failureHandler) {\n\n\t\ttry {\n\t\t\tClass<?> factoryImplementationClass = ClassUtils.forName(implementationName, this.classLoader);\n\t\t\tAssert.isTrue(type.isAssignableFrom(factoryImplementationClass), () ->\n\t\t\t\t\t\"Class [%s] is not assignable to factory type [%s]\".formatted(implementationName, type.getName()));\n\t\t\tFactoryInstantiator<T> factoryInstantiator = FactoryInstantiator.forClass(factoryImplementationClass);\n\t\t\treturn factoryInstantiator.instantiate(argumentResolver);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tfailureHandler.handleFailure(type, implementationName, ex);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the given class loader.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * <p>For more advanced factory loading with {@link ArgumentResolver} or\n\t * {@link FailureHandler} support use {@link #forDefaultResourceLocation(ClassLoader)}\n\t * to obtain a {@link SpringFactoriesLoader} instance.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param classLoader the ClassLoader to use for loading (can be {@code null}\n\t * to use the default)\n\t * @throws IllegalArgumentException if any factory implementation class cannot\n\t * be loaded or if an error occurs while instantiating any factory\n\t */\n\tpublic static <T> List<T> loadFactories(Class<T> factoryType, @Nullable ClassLoader classLoader) {\n\t\treturn forDefaultResourceLocation(classLoader).load(factoryType);\n\t}\n\n\t/**\n\t * Load the fully qualified class names of factory implementations of the\n\t * given type from {@value #FACTORIES_RESOURCE_LOCATION}, using the given\n\t * class loader.\n\t * <p>As of Spring Framework 5.3, if a particular implementation class name\n\t * is discovered more than once for the given factory type, duplicates will\n\t * be ignored.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param classLoader the ClassLoader to use for loading resources; can be\n\t * {@code null} to use the default\n\t * @throws IllegalArgumentException if an error occurs while loading factory names\n\t * @see #loadFactories\n\t * @deprecated as of 6.0 in favor of {@link #load(Class, ArgumentResolver, FailureHandler)}\n\t */\n\t@Deprecated(since = \"6.0\")\n\tpublic static List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader) {\n\t\treturn forDefaultResourceLocation(classLoader).loadFactoryNames(factoryType);\n\t}\n\n\t/**\n\t * Create a {@link SpringFactoriesLoader} instance that will load and\n\t * instantiate the factory implementations from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the default class loader.\n\t * @return a {@link SpringFactoriesLoader} instance\n\t * @since 6.0\n\t * @see #forDefaultResourceLocation(ClassLoader)\n\t */\n\tpublic static SpringFactoriesLoader forDefaultResourceLocation() {\n\t\treturn forDefaultResourceLocation(null);\n\t}\n\n\t/**\n\t * Create a {@link SpringFactoriesLoader} instance that will load and\n\t * instantiate the factory implementations from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the given class loader.\n\t * @param classLoader the ClassLoader to use for loading resources; can be\n\t * {@code null} to use the default\n\t * @return a {@link SpringFactoriesLoader} instance\n\t * @since 6.0\n\t * @see #forDefaultResourceLocation()\n\t */\n\tpublic static SpringFactoriesLoader forDefaultResourceLocation(@Nullable ClassLoader classLoader) {\n\t\treturn forResourceLocation(FACTORIES_RESOURCE_LOCATION, classLoader);\n\t}\n\n\t/**\n\t * Create a {@link SpringFactoriesLoader} instance that will load and\n\t * instantiate the factory implementations from the given location,\n\t * using the default class loader.\n\t * @param resourceLocation the resource location to look for factories\n\t * @return a {@link SpringFactoriesLoader} instance\n\t * @since 6.0\n\t * @see #forResourceLocation(String, ClassLoader)\n\t */\n\tpublic static SpringFactoriesLoader forResourceLocation(String resourceLocation) {\n\t\treturn forResourceLocation(resourceLocation, null);\n\t}\n\n\t/**\n\t * Create a {@link SpringFactoriesLoader} instance that will load and\n\t * instantiate the factory implementations from the given location,\n\t * using the given class loader.\n\t * @param resourceLocation the resource location to look for factories\n\t * @param classLoader the ClassLoader to use for loading resources;\n\t * can be {@code null} to use the default\n\t * @return a {@link SpringFactoriesLoader} instance\n\t * @since 6.0\n\t * @see #forResourceLocation(String)\n\t */\n\tpublic static SpringFactoriesLoader forResourceLocation(String resourceLocation, @Nullable ClassLoader classLoader) {\n\t\tAssert.hasText(resourceLocation, \"'resourceLocation' must not be empty\");\n\t\tClassLoader resourceClassLoader = (classLoader != null ? classLoader :\n\t\t\t\tSpringFactoriesLoader.class.getClassLoader());\n\t\tMap<String, SpringFactoriesLoader> loaders = cache.computeIfAbsent(\n\t\t\t\tresourceClassLoader, key -> new ConcurrentReferenceHashMap<>());\n\t\treturn loaders.computeIfAbsent(resourceLocation, key ->\n\t\t\t\tnew SpringFactoriesLoader(classLoader, loadFactoriesResource(resourceClassLoader, resourceLocation)));\n\t}\n\n\tprotected static Map<String, List<String>> loadFactoriesResource(ClassLoader classLoader, String resourceLocation) {\n\t\tMap<String, List<String>> result = new LinkedHashMap<>();\n\t\ttry {\n\t\t\tEnumeration<URL> urls = classLoader.getResources(resourceLocation);\n\t\t\twhile (urls.hasMoreElements()) {\n\t\t\t\tUrlResource resource = new UrlResource(urls.nextElement());\n\t\t\t\tProperties properties = PropertiesLoaderUtils.loadProperties(resource);\n\t\t\t\tproperties.forEach((name, value) -> {\n\t\t\t\t\tString[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String) value);\n\t\t\t\t\tList<String> implementations = result.computeIfAbsent(((String) name).trim(),\n\t\t\t\t\t\t\tkey -> new ArrayList<>(factoryImplementationNames.length));\n\t\t\t\t\tArrays.stream(factoryImplementationNames).map(String::trim).forEach(implementations::add);\n\t\t\t\t});\n\t\t\t}\n\t\t\tresult.replaceAll(SpringFactoriesLoader::toDistinctUnmodifiableList);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to load factories from location [\" + resourceLocation + \"]\", ex);\n\t\t}\n\t\treturn Collections.unmodifiableMap(result);\n\t}\n\n\tprivate static List<String> toDistinctUnmodifiableList(String factoryType, List<String> implementations) {\n\t\treturn implementations.stream().distinct().toList();\n\t}\n\n\n\t/**\n\t * Internal instantiator used to create the factory instance.\n\t * @since 6.0\n\t * @param <T> the instance implementation type\n\t */\n\tstatic final class FactoryInstantiator<T> {\n\n\t\tprivate final Constructor<T> constructor;\n\n\t\tprivate FactoryInstantiator(Constructor<T> constructor) {\n\t\t\tReflectionUtils.makeAccessible(constructor);\n\t\t\tthis.constructor = constructor;\n\t\t}\n\n\t\tT instantiate(@Nullable ArgumentResolver argumentResolver) throws Exception {\n\t\t\tObject[] args = resolveArgs(argumentResolver);\n\t\t\tif (KotlinDetector.isKotlinType(this.constructor.getDeclaringClass())) {\n\t\t\t\treturn KotlinDelegate.instantiate(this.constructor, args);\n\t\t\t}\n\t\t\treturn this.constructor.newInstance(args);\n\t\t}\n\n\t\tprivate Object[] resolveArgs(@Nullable ArgumentResolver argumentResolver) {\n\t\t\tClass<?>[] types = this.constructor.getParameterTypes();\n\t\t\treturn (argumentResolver != null ?\n\t\t\t\t\tArrays.stream(types).map(argumentResolver::resolve).toArray() :\n\t\t\t\t\tnew Object[types.length]);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tstatic <T> FactoryInstantiator<T> forClass(Class<?> factoryImplementationClass) {\n\t\t\tConstructor<?> constructor = findConstructor(factoryImplementationClass);\n\t\t\tAssert.state(constructor != null, () ->\n\t\t\t\t\t\"Class [%s] has no suitable constructor\".formatted(factoryImplementationClass.getName()));\n\t\t\treturn new FactoryInstantiator<>((Constructor<T>) constructor);\n\t\t}\n\n\t\tprivate static @Nullable Constructor<?> findConstructor(Class<?> factoryImplementationClass) {\n\t\t\t// Same algorithm as BeanUtils.getResolvableConstructor\n\t\t\tConstructor<?> constructor = findPrimaryKotlinConstructor(factoryImplementationClass);\n\t\t\tconstructor = (constructor != null ? constructor :\n\t\t\t\t\tfindSingleConstructor(factoryImplementationClass.getConstructors()));\n\t\t\tconstructor = (constructor != null ? constructor :\n\t\t\t\t\tfindSingleConstructor(factoryImplementationClass.getDeclaredConstructors()));\n\t\t\tconstructor = (constructor != null ? constructor :\n\t\t\t\t\tfindDeclaredConstructor(factoryImplementationClass));\n\t\t\treturn constructor;\n\t\t}\n\n\t\tprivate static @Nullable Constructor<?> findPrimaryKotlinConstructor(Class<?> factoryImplementationClass) {\n\t\t\treturn (KotlinDetector.isKotlinType(factoryImplementationClass) ?\n\t\t\t\t\tKotlinDelegate.findPrimaryConstructor(factoryImplementationClass) : null);\n\t\t}\n\n\t\tprivate static @Nullable Constructor<?> findSingleConstructor(Constructor<?>[] constructors) {\n\t\t\treturn (constructors.length == 1 ? constructors[0] : null);\n\t\t}\n\n\t\tprivate static @Nullable Constructor<?> findDeclaredConstructor(Class<?> factoryImplementationClass) {\n\t\t\ttry {\n\t\t\t\treturn factoryImplementationClass.getDeclaredConstructor();\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Nested class to avoid a hard dependency on Kotlin at runtime.\n\t * @since 6.0\n\t */\n\tprivate static class KotlinDelegate {\n\n\t\tstatic <T> @Nullable Constructor<T> findPrimaryConstructor(Class<T> clazz) {\n\t\t\ttry {\n\t\t\t\tKFunction<T> primaryConstructor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz));\n\t\t\t\tif (primaryConstructor != null) {\n\t\t\t\t\tConstructor<T> constructor = ReflectJvmMapping.getJavaConstructor(\n\t\t\t\t\t\t\tprimaryConstructor);\n\t\t\t\t\tAssert.state(constructor != null, () ->\n\t\t\t\t\t\t\t\"Failed to find Java constructor for Kotlin primary constructor: \" + clazz.getName());\n\t\t\t\t\treturn constructor;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (UnsupportedOperationException ex) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tstatic <T> T instantiate(Constructor<T> constructor, Object[] args) throws Exception {\n\t\t\tKFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(constructor);\n\t\t\tif (kotlinConstructor == null) {\n\t\t\t\treturn constructor.newInstance(args);\n\t\t\t}\n\t\t\tmakeAccessible(constructor, kotlinConstructor);\n\t\t\treturn instantiate(kotlinConstructor, convertArgs(args, kotlinConstructor.getParameters()));\n\t\t}\n\n\t\tprivate static <T> void makeAccessible(Constructor<T> constructor,\n\t\t\t\tKFunction<T> kotlinConstructor) {\n\t\t\tif ((!Modifier.isPublic(constructor.getModifiers())\n\t\t\t\t\t|| !Modifier.isPublic(constructor.getDeclaringClass().getModifiers()))) {\n\t\t\t\tKCallablesJvm.setAccessible(kotlinConstructor, true);\n\t\t\t}\n\t\t}\n\n\t\tprivate static Map<KParameter, Object> convertArgs(Object[] args, List<KParameter> parameters) {\n\t\t\tMap<KParameter, Object> result = CollectionUtils.newHashMap(parameters.size());\n\t\t\tAssert.isTrue(args.length <= parameters.size(),\n\t\t\t\t\t\"Number of provided arguments should be less than or equal to the number of constructor parameters\");\n\t\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\t\tif (!parameters.get(i).isOptional() || args[i] != null) {\n\t\t\t\t\tresult.put(parameters.get(i), args[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate static <T> T instantiate(KFunction<T> kotlinConstructor, Map<KParameter, Object> args) {\n\t\t\treturn kotlinConstructor.callBy(args);\n\t\t}\n\t}\n\n\n\t/**\n\t * Strategy for resolving constructor arguments based on their type.\n\t * @since 6.0\n\t * @see ArgumentResolver#of(Class, Object)\n\t * @see ArgumentResolver#ofSupplied(Class, Supplier)\n\t * @see ArgumentResolver#from(Function)\n\t */\n\t@FunctionalInterface\n\tpublic interface ArgumentResolver {\n\n\t\t/**\n\t\t * Resolve the given argument if possible.\n\t\t * @param <T> the argument type\n\t\t * @param type the argument type\n\t\t * @return the resolved argument value or {@code null}\n\t\t */\n\t\t<T> @Nullable T resolve(Class<T> type);\n\n\t\t/**\n\t\t * Create a new composed {@link ArgumentResolver} by combining this resolver\n\t\t * with the given type and value.\n\t\t * @param <T> the argument type\n\t\t * @param type the argument type\n\t\t * @param value the argument value\n\t\t * @return a new composite {@link ArgumentResolver} instance\n\t\t */\n\t\tdefault <T> ArgumentResolver and(Class<T> type, T value) {\n\t\t\treturn and(ArgumentResolver.of(type, value));\n\t\t}\n\n\t\t/**\n\t\t * Create a new composed {@link ArgumentResolver} by combining this resolver\n\t\t * with the given type and value.\n\t\t * @param <T> the argument type\n\t\t * @param type the argument type\n\t\t * @param valueSupplier the argument value supplier\n\t\t * @return a new composite {@link ArgumentResolver} instance\n\t\t */\n\t\tdefault <T> ArgumentResolver andSupplied(Class<T> type, Supplier<T> valueSupplier) {\n\t\t\treturn and(ArgumentResolver.ofSupplied(type, valueSupplier));\n\t\t}\n\n\t\t/**\n\t\t * Create a new composed {@link ArgumentResolver} by combining this resolver\n\t\t * with the given resolver.\n\t\t * @param argumentResolver the argument resolver to add\n\t\t * @return a new composite {@link ArgumentResolver} instance\n\t\t */\n\t\tdefault ArgumentResolver and(ArgumentResolver argumentResolver) {\n\t\t\treturn from(type -> {\n\t\t\t\tObject resolved = resolve(type);\n\t\t\t\treturn (resolved != null ? resolved : argumentResolver.resolve(type));\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Factory method that returns an {@link ArgumentResolver} that always\n\t\t * returns {@code null}.\n\t\t * @return a new {@link ArgumentResolver} instance\n\t\t */\n\t\tstatic ArgumentResolver none() {\n\t\t\treturn from(type -> null);\n\t\t}\n\n\t\t/**\n\t\t * Factory method that can be used to create an {@link ArgumentResolver}\n\t\t * that resolves only the given type.\n\t\t * @param <T> the argument type\n\t\t * @param type the argument type\n\t\t * @param value the argument value\n\t\t * @return a new {@link ArgumentResolver} instance\n\t\t */\n\t\tstatic <T> ArgumentResolver of(Class<T> type, T value) {\n\t\t\treturn ofSupplied(type, () -> value);\n\t\t}\n\n\t\t/**\n\t\t * Factory method that can be used to create an {@link ArgumentResolver}\n\t\t * that resolves only the given type.\n\t\t * @param <T> the argument type\n\t\t * @param type the argument type\n\t\t * @param valueSupplier the argument value supplier\n\t\t * @return a new {@link ArgumentResolver} instance\n\t\t */\n\t\tstatic <T> ArgumentResolver ofSupplied(Class<T> type, Supplier<T> valueSupplier) {\n\t\t\treturn from(candidateType -> (candidateType.equals(type) ? valueSupplier.get() : null));\n\t\t}\n\n\t\t/**\n\t\t * Factory method that creates a new {@link ArgumentResolver} from a\n\t\t * lambda friendly function. The given function is provided with the\n\t\t * argument type and must provide an instance of that type or {@code null}.\n\t\t * @param function the resolver function\n\t\t * @return a new {@link ArgumentResolver} instance backed by the function\n\t\t */\n\t\tstatic ArgumentResolver from(Function<Class<?>, @Nullable Object> function) {\n\t\t\treturn new ArgumentResolver() {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t@Override\n\t\t\t\tpublic <T> @Nullable T resolve(Class<T> type) {\n\t\t\t\t\treturn (T) function.apply(type);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\n\t/**\n\t * Strategy for handling a failure that occurs when instantiating a factory.\n\t * @since 6.0\n\t * @see FailureHandler#throwing()\n\t * @see FailureHandler#logging(Log)\n\t */\n\t@FunctionalInterface\n\tpublic interface FailureHandler {\n\n\t\t/**\n\t\t * Handle the {@code failure} that occurred when instantiating the\n\t\t * {@code factoryImplementationName} that was expected to be of the\n\t\t * given {@code factoryType}.\n\t\t * @param factoryType the type of the factory\n\t\t * @param factoryImplementationName the name of the factory implementation\n\t\t * @param failure the failure that occurred\n\t\t * @see #throwing()\n\t\t * @see #logging\n\t\t */\n\t\tvoid handleFailure(Class<?> factoryType, String factoryImplementationName, Throwable failure);\n\n\n\t\t/**\n\t\t * Create a new {@link FailureHandler} that handles errors by throwing an\n\t\t * {@link IllegalArgumentException}.\n\t\t * @return a new {@link FailureHandler} instance\n\t\t * @see #throwing(BiFunction)\n\t\t */\n\t\tstatic FailureHandler throwing() {\n\t\t\treturn throwing(IllegalArgumentException::new);\n\t\t}\n\n\t\t/**\n\t\t * Create a new {@link FailureHandler} that handles errors by throwing an\n\t\t * exception.\n\t\t * @param exceptionFactory factory used to create the exception\n\t\t * @return a new {@link FailureHandler} instance\n\t\t */\n\t\tstatic FailureHandler throwing(BiFunction<String, Throwable, ? extends RuntimeException> exceptionFactory) {\n\t\t\treturn handleMessage((messageSupplier, failure) -> {\n\t\t\t\tthrow exceptionFactory.apply(messageSupplier.get(), failure);\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Create a new {@link FailureHandler} that handles errors by logging trace\n\t\t * messages.\n\t\t * @param logger the logger used to log messages\n\t\t * @return a new {@link FailureHandler} instance\n\t\t */\n\t\tstatic FailureHandler logging(Log logger) {\n\t\t\treturn handleMessage((messageSupplier, failure) -> logger.trace(LogMessage.of(messageSupplier), failure));\n\t\t}\n\n\t\t/**\n\t\t * Create a new {@link FailureHandler} that handles errors using a standard\n\t\t * formatted message.\n\t\t * @param messageHandler the message handler used to handle the problem\n\t\t * @return a new {@link FailureHandler} instance\n\t\t */\n\t\tstatic FailureHandler handleMessage(BiConsumer<Supplier<String>, Throwable> messageHandler) {\n\t\t\treturn (factoryType, factoryImplementationName, failure) -> {\n\t\t\t\tSupplier<String> messageSupplier = () -> \"Unable to instantiate factory class [%s] for factory type [%s]\"\n\t\t\t\t\t\t.formatted(factoryImplementationName, factoryType.getName());\n\t\t\t\tmessageHandler.accept(messageSupplier, failure);\n\t\t\t};\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.core.io.support.SpringFactoriesLoader#forDefaultResourceLocation()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link SpringFactoriesLoader} instance that will load and\n\t * instantiate the factory implementations from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the default class loader.\n\t * @return a {@link SpringFactoriesLoader} instance\n\t * @since 6.0\n\t * @see #forDefaultResourceLocation(ClassLoader)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "SpringFactoriesLoader",
    "signature": "public SpringFactoriesLoader forDefaultResourceLocation()",
    "source_code": "\tpublic static SpringFactoriesLoader forDefaultResourceLocation() {\n\t\treturn forDefaultResourceLocation(null);\n\t}"
  },
  "org.springframework.core.io.support.SpringFactoriesLoader#forDefaultResourceLocation(classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link SpringFactoriesLoader} instance that will load and\n\t * instantiate the factory implementations from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the given class loader.\n\t * @param classLoader the ClassLoader to use for loading resources; can be\n\t * {@code null} to use the default\n\t * @return a {@link SpringFactoriesLoader} instance\n\t * @since 6.0\n\t * @see #forDefaultResourceLocation()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "SpringFactoriesLoader",
    "signature": "public SpringFactoriesLoader forDefaultResourceLocation(@Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static SpringFactoriesLoader forDefaultResourceLocation(@Nullable ClassLoader classLoader) {\n\t\treturn forResourceLocation(FACTORIES_RESOURCE_LOCATION, classLoader);\n\t}"
  },
  "org.springframework.core.io.support.SpringFactoriesLoader#forResourceLocation(resourceLocation)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link SpringFactoriesLoader} instance that will load and\n\t * instantiate the factory implementations from the given location,\n\t * using the default class loader.\n\t * @param resourceLocation the resource location to look for factories\n\t * @return a {@link SpringFactoriesLoader} instance\n\t * @since 6.0\n\t * @see #forResourceLocation(String, ClassLoader)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLocation"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "SpringFactoriesLoader",
    "signature": "public SpringFactoriesLoader forResourceLocation(String resourceLocation)",
    "source_code": "\tpublic static SpringFactoriesLoader forResourceLocation(String resourceLocation) {\n\t\treturn forResourceLocation(resourceLocation, null);\n\t}"
  },
  "org.springframework.core.io.support.SpringFactoriesLoader#forResourceLocation(resourceLocation,classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link SpringFactoriesLoader} instance that will load and\n\t * instantiate the factory implementations from the given location,\n\t * using the given class loader.\n\t * @param resourceLocation the resource location to look for factories\n\t * @param classLoader the ClassLoader to use for loading resources;\n\t * can be {@code null} to use the default\n\t * @return a {@link SpringFactoriesLoader} instance\n\t * @since 6.0\n\t * @see #forResourceLocation(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLocation",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "SpringFactoriesLoader",
    "signature": "public SpringFactoriesLoader forResourceLocation(String resourceLocation, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static SpringFactoriesLoader forResourceLocation(String resourceLocation, @Nullable ClassLoader classLoader) {\n\t\tAssert.hasText(resourceLocation, \"'resourceLocation' must not be empty\");\n\t\tClassLoader resourceClassLoader = (classLoader != null ? classLoader :\n\t\t\t\tSpringFactoriesLoader.class.getClassLoader());\n\t\tMap<String, SpringFactoriesLoader> loaders = cache.computeIfAbsent(\n\t\t\t\tresourceClassLoader, key -> new ConcurrentReferenceHashMap<>());\n\t\treturn loaders.computeIfAbsent(resourceLocation, key ->\n\t\t\t\tnew SpringFactoriesLoader(classLoader, loadFactoriesResource(resourceClassLoader, resourceLocation)));\n\t}"
  },
  "org.springframework.core.io.support.SpringFactoriesLoader#instantiateFactory(implementationName,type,argumentResolver,failureHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "implementationName",
      "type",
      "argumentResolver",
      "failureHandler"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "T",
    "signature": "protected T instantiateFactory(String implementationName, Class<T> type,\n\t\t\t@Nullable ArgumentResolver argumentResolver, FailureHandler failureHandler)",
    "source_code": "\tprotected <T> @Nullable T instantiateFactory(String implementationName, Class<T> type,"
  },
  "org.springframework.core.io.support.SpringFactoriesLoader#load(factoryType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\n\t * and a default argument resolver that expects a no-arg constructor.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>If a custom instantiation strategy is required, use {@code load(...)}\n\t * with a custom {@link ArgumentResolver ArgumentResolver} and/or\n\t * {@link FailureHandler FailureHandler}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @throws IllegalArgumentException if any factory implementation class cannot\n\t * be loaded or if an error occurs while instantiating any factory\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "List<T>",
    "signature": "public List<T> load(Class<T> factoryType)",
    "source_code": "\tpublic <T> List<T> load(Class<T> factoryType) {\n\t\treturn load(factoryType, null, null);\n\t}"
  },
  "org.springframework.core.io.support.SpringFactoriesLoader#load(factoryType,argumentResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\n\t * and the given argument resolver.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param argumentResolver strategy used to resolve constructor arguments by their type\n\t * @throws IllegalArgumentException if any factory implementation class cannot\n\t * be loaded or if an error occurs while instantiating any factory\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "argumentResolver"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "List<T>",
    "signature": "public List<T> load(Class<T> factoryType, @Nullable ArgumentResolver argumentResolver)",
    "source_code": "\tpublic <T> List<T> load(Class<T> factoryType, @Nullable ArgumentResolver argumentResolver) {\n\t\treturn load(factoryType, argumentResolver, null);\n\t}"
  },
  "org.springframework.core.io.support.SpringFactoriesLoader#load(factoryType,argumentResolver,failureHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader,\n\t * the given argument resolver, and custom failure handling provided by the given\n\t * failure handler.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * <p>For any factory implementation class that cannot be loaded or error that\n\t * occurs while instantiating it, the given failure handler is called.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param argumentResolver strategy used to resolve constructor arguments by their type\n\t * @param failureHandler strategy used to handle factory instantiation failures\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "argumentResolver",
      "failureHandler"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "List<T>",
    "signature": "public List<T> load(Class<T> factoryType, @Nullable ArgumentResolver argumentResolver,\n\t\t\t@Nullable FailureHandler failureHandler)",
    "source_code": "\tpublic <T> List<T> load(Class<T> factoryType, @Nullable ArgumentResolver argumentResolver,"
  },
  "org.springframework.core.io.support.SpringFactoriesLoader#load(factoryType,failureHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\n\t * with custom failure handling provided by the given failure handler.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * <p>For any factory implementation class that cannot be loaded or error that\n\t * occurs while instantiating it, the given failure handler is called.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param failureHandler strategy used to handle factory instantiation failures\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "failureHandler"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "List<T>",
    "signature": "public List<T> load(Class<T> factoryType, @Nullable FailureHandler failureHandler)",
    "source_code": "\tpublic <T> List<T> load(Class<T> factoryType, @Nullable FailureHandler failureHandler) {\n\t\treturn load(factoryType, null, failureHandler);\n\t}"
  },
  "org.springframework.core.io.support.SpringFactoriesLoader#loadFactories(factoryType,classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the given class loader.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * <p>For more advanced factory loading with {@link ArgumentResolver} or\n\t * {@link FailureHandler} support use {@link #forDefaultResourceLocation(ClassLoader)}\n\t * to obtain a {@link SpringFactoriesLoader} instance.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param classLoader the ClassLoader to use for loading (can be {@code null}\n\t * to use the default)\n\t * @throws IllegalArgumentException if any factory implementation class cannot\n\t * be loaded or if an error occurs while instantiating any factory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "List<T>",
    "signature": "public List<T> loadFactories(Class<T> factoryType, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static <T> List<T> loadFactories(Class<T> factoryType, @Nullable ClassLoader classLoader) {\n\t\treturn forDefaultResourceLocation(classLoader).load(factoryType);\n\t}"
  },
  "org.springframework.core.io.support.SpringFactoriesLoader#loadFactoriesResource(classLoader,resourceLocation)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "classLoader",
      "resourceLocation"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "List<String>>",
    "signature": "protected List<String>> loadFactoriesResource(ClassLoader classLoader, String resourceLocation)",
    "source_code": "\tprotected static Map<String, List<String>> loadFactoriesResource(ClassLoader classLoader, String resourceLocation) {\n\t\tMap<String, List<String>> result = new LinkedHashMap<>();\n\t\ttry {\n\t\t\tEnumeration<URL> urls = classLoader.getResources(resourceLocation);\n\t\t\twhile (urls.hasMoreElements()) {\n\t\t\t\tUrlResource resource = new UrlResource(urls.nextElement());\n\t\t\t\tProperties properties = PropertiesLoaderUtils.loadProperties(resource);\n\t\t\t\tproperties.forEach((name, value) -> {\n\t\t\t\t\tString[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String) value);\n\t\t\t\t\tList<String> implementations = result.computeIfAbsent(((String) name).trim(),\n\t\t\t\t\t\t\tkey -> new ArrayList<>(factoryImplementationNames.length));\n\t\t\t\t\tArrays.stream(factoryImplementationNames).map(String::trim).forEach(implementations::add);\n\t\t\t\t});\n\t\t\t}\n\t\t\tresult.replaceAll(SpringFactoriesLoader::toDistinctUnmodifiableList);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to load factories from location [\" + resourceLocation + \"]\", ex);\n\t\t}\n\t\treturn Collections.unmodifiableMap(result);\n\t}"
  },
  "org.springframework.core.io.support.SpringFactoriesLoader#loadFactoryNames(factoryType,classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load the fully qualified class names of factory implementations of the\n\t * given type from {@value #FACTORIES_RESOURCE_LOCATION}, using the given\n\t * class loader.\n\t * <p>As of Spring Framework 5.3, if a particular implementation class name\n\t * is discovered more than once for the given factory type, duplicates will\n\t * be ignored.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param classLoader the ClassLoader to use for loading resources; can be\n\t * {@code null} to use the default\n\t * @throws IllegalArgumentException if an error occurs while loading factory names\n\t * @see #loadFactories\n\t * @deprecated as of 6.0 in favor of {@link #load(Class, ArgumentResolver, FailureHandler)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "List<String>",
    "signature": "public List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader) {\n\t\treturn forDefaultResourceLocation(classLoader).loadFactoryNames(factoryType);\n\t}"
  },
  "org.springframework.core.io.support.SpringFactoriesLoader#resolve(type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 587
    },
    "return": "T",
    "signature": "public T resolve(Class<T> type)",
    "source_code": "\t\t\t\tpublic <T> @Nullable T resolve(Class<T> type) {\n\t\t\t\t\treturn (T) function.apply(type);\n\t\t\t\t}"
  },
  "org.springframework.core.io.support.localOverride": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "protected boolean localOverride",
    "source_code": "\tprotected boolean localOverride = false;",
    "type": "boolean"
  },
  "org.springframework.core.io.support.logger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Logger available to subclasses. */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.core.task.support.TaskExecutorAdapter#submitListenable(task)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "ListenableFuture<T>",
    "signature": "public ListenableFuture<T> submitListenable(Callable<T> task)",
    "source_code": "\tpublic <T> ListenableFuture<T> submitListenable(Callable<T> task) {\n\t\ttry {\n\t\t\tListenableFutureTask<T> future = new ListenableFutureTask<>(task);\n\t\t\tdoExecute(this.concurrentExecutor, this.taskDecorator, future);\n\t\t\treturn future;\n\t\t}\n\t\tcatch (RejectedExecutionException ex) {\n\t\t\tthrow new TaskRejectedException(this.concurrentExecutor, task, ex);\n\t\t}\n\t}"
  },
  "org.springframework.core.test.io.support.MockSpringFactoriesLoader": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Simple mock {@link SpringFactoriesLoader} implementation that can be used for testing\n * purposes.\n *\n * @author Phillip Webb\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class MockSpringFactoriesLoader",
    "source_code": "public class MockSpringFactoriesLoader extends SpringFactoriesLoader {\n\n\tprivate final AtomicInteger sequence = new AtomicInteger();\n\n\tprivate final Map<String, List<String>> factories;\n\n\tprivate final Map<String, Object> implementations = new HashMap<>();\n\n\n\t/**\n\t * Create a new {@link MockSpringFactoriesLoader} instance with the default\n\t * classloader.\n\t */\n\tpublic MockSpringFactoriesLoader() {\n\t\tthis(null);\n\t}\n\n\t/**\n\t * Create a new {@link MockSpringFactoriesLoader} instance with the given classloader.\n\t * @param classLoader the classloader to use\n\t */\n\tpublic MockSpringFactoriesLoader(@Nullable ClassLoader classLoader) {\n\t\tthis(classLoader, new LinkedHashMap<>());\n\t}\n\n\tprotected MockSpringFactoriesLoader(@Nullable ClassLoader classLoader,\n\t\t\tMap<String, List<String>> factories) {\n\t\tsuper(classLoader, factories);\n\t\tthis.factories = factories;\n\t}\n\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tprotected <T> @Nullable T instantiateFactory(String implementationName, Class<T> type,\n\t\t\t@Nullable ArgumentResolver argumentResolver, FailureHandler failureHandler) {\n\t\tif (implementationName.startsWith(\"!\")) {\n\t\t\tObject implementation = this.implementations.get(implementationName);\n\t\t\tif (implementation != null) {\n\t\t\t\treturn (T) implementation;\n\t\t\t}\n\t\t}\n\t\treturn super.instantiateFactory(implementationName, type, argumentResolver, failureHandler);\n\t}\n\n\t/**\n\t * Add factory implementations to this instance.\n\t * @param factoryType the factory type class\n\t * @param factoryImplementations the implementation classes\n\t */\n\t@SafeVarargs\n\tpublic final <T> void add(Class<T> factoryType, Class<? extends T>... factoryImplementations) {\n\t\tfor (Class<? extends T> factoryImplementation : factoryImplementations) {\n\t\t\tadd(factoryType.getName(), factoryImplementation.getName());\n\t\t}\n\t}\n\n\t/**\n\t * Add factory implementations to this instance.\n\t * @param factoryType the factory type class name\n\t * @param factoryImplementations the implementation class names\n\t */\n\tpublic void add(String factoryType, String... factoryImplementations) {\n\t\tList<String> implementations = this.factories.computeIfAbsent(\n\t\t\t\tfactoryType, key -> new ArrayList<>());\n\t\tCollections.addAll(implementations, factoryImplementations);\n\t}\n\n\t/**\n\t * Add factory instances to this instance.\n\t * @param factoryType the factory type class\n\t * @param factoryInstances the implementation instances to add\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> void addInstance(Class<T> factoryType, T... factoryInstances) {\n\t\taddInstance(factoryType.getName(), factoryInstances);\n\t}\n\n\t/**\n\t * Add factory instances to this instance.\n\t * @param factoryType the factory type class name\n\t * @param factoryInstance the implementation instances to add\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> void addInstance(String factoryType, T... factoryInstance) {\n\t\tList<String> implementations = this.factories.computeIfAbsent(factoryType, key -> new ArrayList<>());\n\t\tfor (T factoryImplementation : factoryInstance) {\n\t\t\tString reference = \"!\" + factoryType + \":\" + factoryImplementation.getClass().getName()\n\t\t\t\t\t+ this.sequence.getAndIncrement();\n\t\t\timplementations.add(reference);\n\t\t\tthis.implementations.put(reference, factoryImplementation);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.core.test.io.support.MockSpringFactoriesLoader#add(factoryType,factoryImplementations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add factory implementations to this instance.\n\t * @param factoryType the factory type class name\n\t * @param factoryImplementations the implementation class names\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "factoryImplementations"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void add(String factoryType, String... factoryImplementations)",
    "source_code": "\tpublic void add(String factoryType, String... factoryImplementations) {\n\t\tList<String> implementations = this.factories.computeIfAbsent(\n\t\t\t\tfactoryType, key -> new ArrayList<>());\n\t\tCollections.addAll(implementations, factoryImplementations);\n\t}"
  },
  "org.springframework.core.test.io.support.MockSpringFactoriesLoader#addInstance(factoryType,factoryInstance)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add factory instances to this instance.\n\t * @param factoryType the factory type class name\n\t * @param factoryInstance the implementation instances to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "factoryInstance"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void addInstance(String factoryType, T... factoryInstance)",
    "source_code": "\tpublic <T> void addInstance(String factoryType, T... factoryInstance) {\n\t\tList<String> implementations = this.factories.computeIfAbsent(factoryType, key -> new ArrayList<>());\n\t\tfor (T factoryImplementation : factoryInstance) {\n\t\t\tString reference = \"!\" + factoryType + \":\" + factoryImplementation.getClass().getName()\n\t\t\t\t\t+ this.sequence.getAndIncrement();\n\t\t\timplementations.add(reference);\n\t\t\tthis.implementations.put(reference, factoryImplementation);\n\t\t}\n\t}"
  },
  "org.springframework.core.test.io.support.MockSpringFactoriesLoader#addInstance(factoryType,factoryInstances)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add factory instances to this instance.\n\t * @param factoryType the factory type class\n\t * @param factoryInstances the implementation instances to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "factoryInstances"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void addInstance(Class<T> factoryType, T... factoryInstances)",
    "source_code": "\tpublic <T> void addInstance(Class<T> factoryType, T... factoryInstances) {\n\t\taddInstance(factoryType.getName(), factoryInstances);\n\t}"
  },
  "org.springframework.core.test.io.support.MockSpringFactoriesLoader#instantiateFactory(implementationName,type,argumentResolver,failureHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "implementationName",
      "type",
      "argumentResolver",
      "failureHandler"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "T",
    "signature": "protected T instantiateFactory(String implementationName, Class<T> type,\n\t\t\t@Nullable ArgumentResolver argumentResolver, FailureHandler failureHandler)",
    "source_code": "\tprotected <T> @Nullable T instantiateFactory(String implementationName, Class<T> type,"
  },
  "org.springframework.core.test.tools.<unknown>#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\t\tpublic void close() {\n\t\t\tcloseOutputStream(toByteArray());\n\t\t}"
  },
  "org.springframework.core.test.tools.<unknown>#openInputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "InputStream",
    "signature": "public InputStream openInputStream()",
    "source_code": "\tpublic InputStream openInputStream() throws IOException {\n\t\tbyte[] content = this.bytes;\n\t\tif (content == null) {\n\t\t\tthrow new IOException(\"No data written\");\n\t\t}\n\t\treturn new ByteArrayInputStream(content);\n\t}"
  },
  "org.springframework.core.test.tools.<unknown>#openOutputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "OutputStream",
    "signature": "public OutputStream openOutputStream()",
    "source_code": "\tpublic OutputStream openOutputStream() {\n\t\treturn new JavaResourceOutputStream();\n\t}"
  },
  "org.springframework.core.test.tools.DynamicClassLoader": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link ClassLoader} used to expose dynamically generated content.\n *\n * @author Phillip Webb\n * @author Andy Wilkinson\n * @author Scott Frederick\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class DynamicClassLoader",
    "source_code": "public class DynamicClassLoader extends ClassLoader {\n\n\tprivate final ClassFiles classFiles;\n\n\tprivate final ResourceFiles resourceFiles;\n\n\tprivate final Map<String, DynamicClassFileObject> dynamicClassFiles;\n\n\tprivate final Map<String, DynamicResourceFileObject> dynamicResourceFiles;\n\n\tprivate final @Nullable Method defineClassMethod;\n\n\n\tpublic DynamicClassLoader(ClassLoader parent, ClassFiles classFiles, ResourceFiles resourceFiles,\n\t\t\tMap<String, DynamicClassFileObject> dynamicClassFiles,\n\t\t\tMap<String, DynamicResourceFileObject> dynamicResourceFiles) {\n\n\t\tsuper(parent);\n\t\tthis.classFiles = classFiles;\n\t\tthis.resourceFiles = resourceFiles;\n\t\tthis.dynamicClassFiles = dynamicClassFiles;\n\t\tthis.dynamicResourceFiles = dynamicResourceFiles;\n\t\tClass<? extends ClassLoader> parentClass = parent.getClass();\n\t\tif (parentClass.getName().equals(CompileWithForkedClassLoaderClassLoader.class.getName())) {\n\t\t\tMethod setClassResourceLookupMethod = lookupMethod(parentClass,\n\t\t\t\t\t\"setClassResourceLookup\", Function.class);\n\t\t\tReflectionUtils.makeAccessible(setClassResourceLookupMethod);\n\t\t\tReflectionUtils.invokeMethod(setClassResourceLookupMethod,\n\t\t\t\t\tgetParent(), (Function<String, byte @Nullable []>) this::findClassBytes);\n\t\t\tthis.defineClassMethod = lookupMethod(parentClass,\n\t\t\t\t\t\"defineDynamicClass\", String.class, byte[].class, int.class, int.class);\n\t\t\tReflectionUtils.makeAccessible(this.defineClassMethod);\n\t\t\tthis.dynamicClassFiles.forEach((name, file) -> defineClass(name, file.getBytes()));\n\t\t}\n\t\telse {\n\t\t\tthis.defineClassMethod = null;\n\t\t}\n\t}\n\n\n\t@Override\n\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n\t\tClass<?> clazz = defineClass(name, findClassBytes(name));\n\t\treturn (clazz != null ? clazz : super.findClass(name));\n\t}\n\n\tprivate @Nullable Class<?> defineClass(String name, byte @Nullable [] bytes) {\n\t\tif (bytes == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this.defineClassMethod != null) {\n\t\t\treturn (Class<?>) ReflectionUtils.invokeMethod(this.defineClassMethod,\n\t\t\t\t\tgetParent(), name, bytes, 0, bytes.length);\n\t\t}\n\t\treturn defineClass(name, bytes, 0, bytes.length);\n\t}\n\n\t@Override\n\tprotected Enumeration<URL> findResources(String name) throws IOException {\n\t\tURL resource = findResource(name);\n\t\tif (resource != null) {\n\t\t\treturn new SingletonEnumeration<>(resource);\n\t\t}\n\t\treturn super.findResources(name);\n\t}\n\n\t@Override\n\tprotected @Nullable URL findResource(String name) {\n\t\tif (name.endsWith(ClassUtils.CLASS_FILE_SUFFIX)) {\n\t\t\tString className = ClassUtils.convertResourcePathToClassName(name.substring(0,\n\t\t\t\t\tname.length() - ClassUtils.CLASS_FILE_SUFFIX.length()));\n\t\t\tbyte[] classBytes = findClassBytes(className);\n\t\t\tif (classBytes != null) {\n\t\t\t\treturn createResourceUrl(name, () -> classBytes);\n\t\t\t}\n\t\t}\n\t\tDynamicResourceFileObject dynamicResourceFile = this.dynamicResourceFiles.get(name);\n\t\tif (dynamicResourceFile != null && dynamicResourceFile.getBytes() != null) {\n\t\t\treturn createResourceUrl(dynamicResourceFile.getName(), dynamicResourceFile::getBytes);\n\t\t}\n\t\tResourceFile resourceFile = this.resourceFiles.get(name);\n\t\tif (resourceFile != null) {\n\t\t\treturn createResourceUrl(resourceFile.getPath(), resourceFile::getBytes);\n\t\t}\n\t\treturn super.findResource(name);\n\t}\n\n\tprivate byte @Nullable [] findClassBytes(String name) {\n\t\tClassFile classFile = this.classFiles.get(name);\n\t\tif (classFile != null) {\n\t\t\treturn classFile.getContent();\n\t\t}\n\t\tDynamicClassFileObject dynamicClassFile = this.dynamicClassFiles.get(name);\n\t\treturn (dynamicClassFile != null ? dynamicClassFile.getBytes() : null);\n\t}\n\n\t@SuppressWarnings(\"deprecation\")  // on JDK 20\n\tprivate URL createResourceUrl(String name, Supplier<byte[]> bytesSupplier) {\n\t\ttry {\n\t\t\treturn new URL(null, \"resource:///\" + name,\n\t\t\t\t\tnew ResourceFileHandler(bytesSupplier));\n\t\t}\n\t\tcatch (MalformedURLException ex) {\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t}\n\n\tprivate static Method lookupMethod(Class<?> target, String name, Class<?>... parameterTypes) {\n\t\tMethod method = ReflectionUtils.findMethod(target, name, parameterTypes);\n\t\tAssert.notNull(method, () -> \"Could not find method '%s' on '%s'\".formatted(name, target.getName()));\n\t\treturn method;\n\t}\n\n\n\tprivate static class SingletonEnumeration<E> implements Enumeration<E> {\n\n\t\tprivate @Nullable E element;\n\n\n\t\tSingletonEnumeration(@Nullable E element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\n\t\t@Override\n\t\tpublic boolean hasMoreElements() {\n\t\t\treturn this.element != null;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable E nextElement() {\n\t\t\tE next = this.element;\n\t\t\tthis.element = null;\n\t\t\treturn next;\n\t\t}\n\n\t}\n\n\n\tprivate static class ResourceFileHandler extends URLStreamHandler {\n\n\t\tprivate final Supplier<byte[]> bytesSupplier;\n\n\n\t\tResourceFileHandler(Supplier<byte[]> bytesSupplier) {\n\t\t\tthis.bytesSupplier = bytesSupplier;\n\t\t}\n\n\n\t\t@Override\n\t\tprotected URLConnection openConnection(URL url) {\n\t\t\treturn new ResourceFileConnection(url, this.bytesSupplier);\n\t\t}\n\n\t}\n\n\n\tprivate static class ResourceFileConnection extends URLConnection {\n\n\t\tprivate final Supplier<byte[]> bytesSupplier;\n\n\n\t\tprotected ResourceFileConnection(URL url, Supplier<byte[]> bytesSupplier) {\n\t\t\tsuper(url);\n\t\t\tthis.bytesSupplier = bytesSupplier;\n\t\t}\n\n\n\t\t@Override\n\t\tpublic void connect() {\n\t\t}\n\n\t\t@Override\n\t\tpublic InputStream getInputStream() {\n\t\t\treturn new ByteArrayInputStream(this.bytesSupplier.get());\n\t\t}\n\n\t}\n\n}"
  },
  "org.springframework.core.test.tools.DynamicClassLoader#connect()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "public void connect()",
    "source_code": "\t\tpublic void connect() {\n\t\t}"
  },
  "org.springframework.core.test.tools.DynamicClassLoader#findResource(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "URL",
    "signature": "protected URL findResource(String name)",
    "source_code": "\tprotected @Nullable URL findResource(String name) {\n\t\tif (name.endsWith(ClassUtils.CLASS_FILE_SUFFIX)) {\n\t\t\tString className = ClassUtils.convertResourcePathToClassName(name.substring(0,\n\t\t\t\t\tname.length() - ClassUtils.CLASS_FILE_SUFFIX.length()));\n\t\t\tbyte[] classBytes = findClassBytes(className);\n\t\t\tif (classBytes != null) {\n\t\t\t\treturn createResourceUrl(name, () -> classBytes);\n\t\t\t}\n\t\t}\n\t\tDynamicResourceFileObject dynamicResourceFile = this.dynamicResourceFiles.get(name);\n\t\tif (dynamicResourceFile != null && dynamicResourceFile.getBytes() != null) {\n\t\t\treturn createResourceUrl(dynamicResourceFile.getName(), dynamicResourceFile::getBytes);\n\t\t}\n\t\tResourceFile resourceFile = this.resourceFiles.get(name);\n\t\tif (resourceFile != null) {\n\t\t\treturn createResourceUrl(resourceFile.getPath(), resourceFile::getBytes);\n\t\t}\n\t\treturn super.findResource(name);\n\t}"
  },
  "org.springframework.core.test.tools.DynamicClassLoader#findResources(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "Enumeration<URL>",
    "signature": "protected Enumeration<URL> findResources(String name)",
    "source_code": "\tprotected Enumeration<URL> findResources(String name) throws IOException {\n\t\tURL resource = findResource(name);\n\t\tif (resource != null) {\n\t\t\treturn new SingletonEnumeration<>(resource);\n\t\t}\n\t\treturn super.findResources(name);\n\t}"
  },
  "org.springframework.core.test.tools.DynamicClassLoader#getInputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "InputStream",
    "signature": "public InputStream getInputStream()",
    "source_code": "\t\tpublic InputStream getInputStream() {\n\t\t\treturn new ByteArrayInputStream(this.bytesSupplier.get());\n\t\t}"
  },
  "org.springframework.core.test.tools.DynamicClassLoader#hasMoreElements()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "boolean",
    "signature": "public boolean hasMoreElements()",
    "source_code": "\t\tpublic boolean hasMoreElements() {\n\t\t\treturn this.element != null;\n\t\t}"
  },
  "org.springframework.core.test.tools.DynamicClassLoader#nextElement()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "E",
    "signature": "public E nextElement()",
    "source_code": "\t\tpublic @Nullable E nextElement() {\n\t\t\tE next = this.element;\n\t\t\tthis.element = null;\n\t\t\treturn next;\n\t\t}"
  },
  "org.springframework.core.test.tools.DynamicClassLoader#openConnection(url)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "url"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "URLConnection",
    "signature": "protected URLConnection openConnection(URL url)",
    "source_code": "\t\tprotected URLConnection openConnection(URL url) {\n\t\t\treturn new ResourceFileConnection(url, this.bytesSupplier);\n\t\t}"
  },
  "org.springframework.core.type.AnnotatedTypeMetadata": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Defines access to the annotations of a specific type ({@link AnnotationMetadata class}\n * or {@link MethodMetadata method}), in a form that does not necessarily require\n * class loading of the types being inspected. Note, however, that classes for\n * encountered annotations will be loaded.\n *\n * @author Juergen Hoeller\n * @author Mark Fisher\n * @author Mark Pollack\n * @author Chris Beams\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 4.0\n * @see AnnotationMetadata\n * @see MethodMetadata\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public interface AnnotatedTypeMetadata",
    "source_code": "public interface AnnotatedTypeMetadata {\n\n\t/**\n\t * Get annotation details based on the direct annotations and meta-annotations\n\t * of the underlying element.\n\t * @return merged annotations based on the direct annotations and meta-annotations\n\t * @since 5.2\n\t */\n\tMergedAnnotations getAnnotations();\n\n\t/**\n\t * Determine whether the underlying element has an annotation or meta-annotation\n\t * of the given type defined.\n\t * <p>If this method returns {@code true}, then\n\t * {@link #getAnnotationAttributes} will return a non-null Map.\n\t * @param annotationName the fully-qualified class name of the annotation\n\t * type to look for\n\t * @return whether a matching annotation is defined\n\t */\n\tdefault boolean isAnnotated(String annotationName) {\n\t\treturn getAnnotations().isPresent(annotationName);\n\t}\n\n\t/**\n\t * Retrieve the attributes of the annotation of the given type, if any (i.e. if\n\t * defined on the underlying element, as direct annotation or meta-annotation).\n\t * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\n\t * are fully supported, both within a single annotation and within annotation\n\t * hierarchies.\n\t * @param annotationName the fully-qualified class name of the annotation\n\t * type to look for\n\t * @return a {@link Map} of attributes, with each annotation attribute name\n\t * as map key (for example, \"location\") and the attribute's value as map value; or\n\t * {@code null} if no matching annotation is found\n\t */\n\tdefault @Nullable Map<String, @Nullable Object> getAnnotationAttributes(String annotationName) {\n\t\treturn getAnnotationAttributes(annotationName, false);\n\t}\n\n\t/**\n\t * Retrieve the attributes of the annotation of the given type, if any (i.e. if\n\t * defined on the underlying element, as direct annotation or meta-annotation).\n\t * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\n\t * are fully supported, both within a single annotation and within annotation\n\t * hierarchies.\n\t * @param annotationName the fully-qualified class name of the annotation\n\t * type to look for\n\t * @param classValuesAsString whether to convert class references to String\n\t * class names for exposure as values in the returned Map, instead of Class\n\t * references which might potentially have to be loaded first\n\t * @return a {@link Map} of attributes, with each annotation attribute name\n\t * as map key (for example, \"location\") and the attribute's value as map value; or\n\t * {@code null} if no matching annotation is found\n\t */\n\tdefault @Nullable Map<String, @Nullable Object> getAnnotationAttributes(String annotationName,\n\t\t\tboolean classValuesAsString) {\n\n\t\tMergedAnnotation<Annotation> annotation = getAnnotations().get(annotationName,\n\t\t\t\tnull, MergedAnnotationSelectors.firstDirectlyDeclared());\n\t\tif (!annotation.isPresent()) {\n\t\t\treturn null;\n\t\t}\n\t\treturn annotation.asAnnotationAttributes(Adapt.values(classValuesAsString, true));\n\t}\n\n\t/**\n\t * Retrieve all attributes of all annotations of the given type, if any (i.e. if\n\t * defined on the underlying element, as direct annotation or meta-annotation).\n\t * <p>Note: this method does <i>not</i> take attribute overrides on composed\n\t * annotations into account.\n\t * @param annotationName the fully-qualified class name of the annotation\n\t * type to look for\n\t * @return a {@link MultiValueMap} of attributes, with each annotation attribute\n\t * name as map key (for example, \"location\") and a list of the attribute's values as\n\t * map value; or {@code null} if no matching annotation is found\n\t * @see #getAllAnnotationAttributes(String, boolean)\n\t */\n\tdefault @Nullable MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(String annotationName) {\n\t\treturn getAllAnnotationAttributes(annotationName, false);\n\t}\n\n\t/**\n\t * Retrieve all attributes of all annotations of the given type, if any (i.e. if\n\t * defined on the underlying element, as direct annotation or meta-annotation).\n\t * <p>Note: this method does <i>not</i> take attribute overrides on composed\n\t * annotations into account.\n\t * @param annotationName the fully-qualified class name of the annotation\n\t * type to look for\n\t * @param classValuesAsString whether to convert class references to String\n\t * class names for exposure as values in the returned Map, instead of Class\n\t * references which might potentially have to be loaded first\n\t * @return a {@link MultiValueMap} of attributes, with each annotation attribute\n\t * name as map key (for example, \"location\") and a list of the attribute's values as\n\t * map value; or {@code null} if no matching annotation is found\n\t * @see #getAllAnnotationAttributes(String)\n\t */\n\tdefault @Nullable MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(\n\t\t\tString annotationName, boolean classValuesAsString) {\n\n\t\tAdapt[] adaptations = Adapt.values(classValuesAsString, true);\n\t\treturn getAnnotations().stream(annotationName)\n\t\t\t\t.filter(MergedAnnotationPredicates.unique(MergedAnnotation::getMetaTypes))\n\t\t\t\t.map(MergedAnnotation::withNonMergedAttributes)\n\t\t\t\t.collect(MergedAnnotationCollectors.toMultiValueMap(\n\t\t\t\t\t\t(MultiValueMap<String, @Nullable Object> map) -> (map.isEmpty() ? null : map), adaptations));\n\t}\n\n\t/**\n\t * Retrieve all <em>repeatable annotations</em> of the given type within the\n\t * annotation hierarchy <em>above</em> the underlying element (as direct\n\t * annotation or meta-annotation); and for each annotation found, merge that\n\t * annotation's attributes with <em>matching</em> attributes from annotations\n\t * in lower levels of the annotation hierarchy and store the results in an\n\t * instance of {@link AnnotationAttributes}.\n\t * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\n\t * are fully supported, both within a single annotation and within annotation\n\t * hierarchies.\n\t * @param annotationType the annotation type to find\n\t * @param containerType the type of the container that holds the annotations\n\t * @param classValuesAsString whether to convert class references to {@code String}\n\t * class names for exposure as values in the returned {@code AnnotationAttributes},\n\t * instead of {@code Class} references which might potentially have to be loaded\n\t * first\n\t * @return the set of all merged repeatable {@code AnnotationAttributes} found,\n\t * or an empty set if none were found\n\t * @since 6.1\n\t * @see #getMergedRepeatableAnnotationAttributes(Class, Class, boolean, boolean)\n\t * @see #getMergedRepeatableAnnotationAttributes(Class, Class, Predicate, boolean, boolean)\n\t */\n\tdefault Set<AnnotationAttributes> getMergedRepeatableAnnotationAttributes(\n\t\t\tClass<? extends Annotation> annotationType, Class<? extends Annotation> containerType,\n\t\t\tboolean classValuesAsString) {\n\n\t\treturn getMergedRepeatableAnnotationAttributes(annotationType, containerType, classValuesAsString, false);\n\t}\n\n\t/**\n\t * Retrieve all <em>repeatable annotations</em> of the given type within the\n\t * annotation hierarchy <em>above</em> the underlying element (as direct\n\t * annotation or meta-annotation); and for each annotation found, merge that\n\t * annotation's attributes with <em>matching</em> attributes from annotations\n\t * in lower levels of the annotation hierarchy and store the results in an\n\t * instance of {@link AnnotationAttributes}.\n\t * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\n\t * are fully supported, both within a single annotation and within annotation\n\t * hierarchies.\n\t * <p>If the {@code sortByReversedMetaDistance} flag is set to {@code true},\n\t * the results will be sorted in {@link Comparator#reversed() reversed} order\n\t * based on each annotation's {@linkplain MergedAnnotation#getDistance()\n\t * meta distance}, which effectively orders meta-annotations before annotations\n\t * that are declared directly on the underlying element.\n\t * @param annotationType the annotation type to find\n\t * @param containerType the type of the container that holds the annotations\n\t * @param classValuesAsString whether to convert class references to {@code String}\n\t * class names for exposure as values in the returned {@code AnnotationAttributes},\n\t * instead of {@code Class} references which might potentially have to be loaded\n\t * first\n\t * @param sortByReversedMetaDistance {@code true} if the results should be\n\t * sorted in reversed order based on each annotation's meta distance\n\t * @return the set of all merged repeatable {@code AnnotationAttributes} found,\n\t * or an empty set if none were found\n\t * @since 6.1\n\t * @see #getMergedRepeatableAnnotationAttributes(Class, Class, boolean)\n\t * @see #getMergedRepeatableAnnotationAttributes(Class, Class, Predicate, boolean, boolean)\n\t */\n\tdefault Set<AnnotationAttributes> getMergedRepeatableAnnotationAttributes(\n\t\t\tClass<? extends Annotation> annotationType, Class<? extends Annotation> containerType,\n\t\t\tboolean classValuesAsString, boolean sortByReversedMetaDistance) {\n\n\t\treturn getMergedRepeatableAnnotationAttributes(annotationType, containerType,\n\t\t\t\tmergedAnnotation -> true, classValuesAsString, sortByReversedMetaDistance);\n\t}\n\n\t/**\n\t * Retrieve all <em>repeatable annotations</em> of the given type within the\n\t * annotation hierarchy <em>above</em> the underlying element (as direct\n\t * annotation or meta-annotation); and for each annotation found, merge that\n\t * annotation's attributes with <em>matching</em> attributes from annotations\n\t * in lower levels of the annotation hierarchy and store the results in an\n\t * instance of {@link AnnotationAttributes}.\n\t * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\n\t * are fully supported, both within a single annotation and within annotation\n\t * hierarchies.\n\t * <p>The supplied {@link Predicate} will be used to filter the results. For\n\t * example, supply {@code mergedAnnotation -> true} to include all annotations\n\t * in the results; supply {@code MergedAnnotation::isDirectlyPresent} to limit\n\t * the results to directly declared annotations, etc.\n\t * <p>If the {@code sortByReversedMetaDistance} flag is set to {@code true},\n\t * the results will be sorted in {@link Comparator#reversed() reversed} order\n\t * based on each annotation's {@linkplain MergedAnnotation#getDistance()\n\t * meta distance}, which effectively orders meta-annotations before annotations\n\t * that are declared directly on the underlying element.\n\t * @param annotationType the annotation type to find\n\t * @param containerType the type of the container that holds the annotations\n\t * @param predicate a {@code Predicate} to apply to each {@code MergedAnnotation}\n\t * to determine if it should be included in the results\n\t * @param classValuesAsString whether to convert class references to {@code String}\n\t * class names for exposure as values in the returned {@code AnnotationAttributes},\n\t * instead of {@code Class} references which might potentially have to be loaded\n\t * first\n\t * @param sortByReversedMetaDistance {@code true} if the results should be\n\t * sorted in reversed order based on each annotation's meta distance\n\t * @return the set of all merged repeatable {@code AnnotationAttributes} found,\n\t * or an empty set if none were found\n\t * @since 6.1.2\n\t * @see #getMergedRepeatableAnnotationAttributes(Class, Class, boolean)\n\t * @see #getMergedRepeatableAnnotationAttributes(Class, Class, boolean, boolean)\n\t */\n\tdefault Set<AnnotationAttributes> getMergedRepeatableAnnotationAttributes(\n\t\t\tClass<? extends Annotation> annotationType, Class<? extends Annotation> containerType,\n\t\t\tPredicate<MergedAnnotation<? extends Annotation>> predicate, boolean classValuesAsString,\n\t\t\tboolean sortByReversedMetaDistance) {\n\n\t\tStream<MergedAnnotation<Annotation>> stream = getAnnotations().stream()\n\t\t\t\t.filter(predicate)\n\t\t\t\t.filter(MergedAnnotationPredicates.typeIn(containerType, annotationType));\n\n\t\tif (sortByReversedMetaDistance) {\n\t\t\tstream = stream.sorted(reversedMetaDistance());\n\t\t}\n\n\t\tAdapt[] adaptations = Adapt.values(classValuesAsString, true);\n\t\treturn stream\n\t\t\t\t.map(annotation -> annotation.asAnnotationAttributes(adaptations))\n\t\t\t\t.flatMap(attributes -> {\n\t\t\t\t\tif (containerType.equals(attributes.annotationType())) {\n\t\t\t\t\t\treturn Stream.of(attributes.getAnnotationArray(MergedAnnotation.VALUE));\n\t\t\t\t\t}\n\t\t\t\t\treturn Stream.of(attributes);\n\t\t\t\t})\n\t\t\t\t.collect(Collectors.toCollection(LinkedHashSet::new));\n\t}\n\n\n\tprivate static Comparator<MergedAnnotation<Annotation>> reversedMetaDistance() {\n\t\treturn Comparator.<MergedAnnotation<Annotation>> comparingInt(MergedAnnotation::getDistance).reversed();\n\t}\n\n}"
  },
  "org.springframework.core.type.StandardAnnotationMetadata": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link AnnotationMetadata} implementation that uses standard reflection\n * to introspect a given {@link Class}.\n *\n * @author Juergen Hoeller\n * @author Mark Fisher\n * @author Chris Beams\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 2.5\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class StandardAnnotationMetadata",
    "source_code": "public class StandardAnnotationMetadata extends StandardClassMetadata implements AnnotationMetadata {\n\n\tprivate final MergedAnnotations mergedAnnotations;\n\n\tprivate final boolean nestedAnnotationsAsMap;\n\n\tprivate @Nullable Set<String> annotationTypes;\n\n\n\t/**\n\t * Create a new {@code StandardAnnotationMetadata} wrapper for the given Class.\n\t * @param introspectedClass the Class to introspect\n\t * @see #StandardAnnotationMetadata(Class, boolean)\n\t * @deprecated since 5.2 in favor of the factory method {@link AnnotationMetadata#introspect(Class)}\n\t */\n\t@Deprecated\n\tpublic StandardAnnotationMetadata(Class<?> introspectedClass) {\n\t\tthis(introspectedClass, false);\n\t}\n\n\t/**\n\t * Create a new {@link StandardAnnotationMetadata} wrapper for the given Class,\n\t * providing the option to return any nested annotations or annotation arrays in the\n\t * form of {@link org.springframework.core.annotation.AnnotationAttributes} instead\n\t * of actual {@link Annotation} instances.\n\t * @param introspectedClass the Class to introspect\n\t * @param nestedAnnotationsAsMap return nested annotations and annotation arrays as\n\t * {@link org.springframework.core.annotation.AnnotationAttributes} for compatibility\n\t * with ASM-based {@link AnnotationMetadata} implementations\n\t * @since 3.1.1\n\t * @deprecated since 5.2 in favor of the factory method {@link AnnotationMetadata#introspect(Class)}.\n\t * Use {@link MergedAnnotation#asMap(org.springframework.core.annotation.MergedAnnotation.Adapt...) MergedAnnotation.asMap}\n\t * from {@link #getAnnotations()} rather than {@link #getAnnotationAttributes(String)}\n\t * if {@code nestedAnnotationsAsMap} is {@code false}\n\t */\n\t@Deprecated\n\tpublic StandardAnnotationMetadata(Class<?> introspectedClass, boolean nestedAnnotationsAsMap) {\n\t\tsuper(introspectedClass);\n\t\tthis.mergedAnnotations = MergedAnnotations.from(introspectedClass,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none());\n\t\tthis.nestedAnnotationsAsMap = nestedAnnotationsAsMap;\n\t}\n\n\n\t@Override\n\tpublic MergedAnnotations getAnnotations() {\n\t\treturn this.mergedAnnotations;\n\t}\n\n\t@Override\n\tpublic Set<String> getAnnotationTypes() {\n\t\tSet<String> annotationTypes = this.annotationTypes;\n\t\tif (annotationTypes == null) {\n\t\t\tannotationTypes = Collections.unmodifiableSet(AnnotationMetadata.super.getAnnotationTypes());\n\t\t\tthis.annotationTypes = annotationTypes;\n\t\t}\n\t\treturn annotationTypes;\n\t}\n\n\t@Override\n\tpublic @Nullable Map<String, @Nullable Object> getAnnotationAttributes(String annotationName, boolean classValuesAsString) {\n\t\tif (this.nestedAnnotationsAsMap) {\n\t\t\treturn AnnotationMetadata.super.getAnnotationAttributes(annotationName, classValuesAsString);\n\t\t}\n\t\treturn AnnotatedElementUtils.getMergedAnnotationAttributes(\n\t\t\t\tgetIntrospectedClass(), annotationName, classValuesAsString, false);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"NullAway\") // Null-safety of Java super method not yet managed\n\tpublic @Nullable MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(String annotationName, boolean classValuesAsString) {\n\t\tif (this.nestedAnnotationsAsMap) {\n\t\t\treturn AnnotationMetadata.super.getAllAnnotationAttributes(annotationName, classValuesAsString);\n\t\t}\n\t\treturn AnnotatedElementUtils.getAllAnnotationAttributes(\n\t\t\t\tgetIntrospectedClass(), annotationName, classValuesAsString, false);\n\t}\n\n\t@Override\n\tpublic boolean hasAnnotatedMethods(String annotationName) {\n\t\tif (AnnotationUtils.isCandidateClass(getIntrospectedClass(), annotationName)) {\n\t\t\ttry {\n\t\t\t\tMethod[] methods = ReflectionUtils.getDeclaredMethods(getIntrospectedClass());\n\t\t\t\tfor (Method method : methods) {\n\t\t\t\t\tif (isAnnotatedMethod(method, annotationName)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to introspect annotated methods on \" + getIntrospectedClass(), ex);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Set<MethodMetadata> getAnnotatedMethods(String annotationName) {\n\t\tSet<MethodMetadata> result = new LinkedHashSet<>(4);\n\t\tif (AnnotationUtils.isCandidateClass(getIntrospectedClass(), annotationName)) {\n\t\t\tReflectionUtils.doWithLocalMethods(getIntrospectedClass(), method -> {\n\t\t\t\tif (isAnnotatedMethod(method, annotationName)) {\n\t\t\t\t\tresult.add(new StandardMethodMetadata(method, this.nestedAnnotationsAsMap));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic Set<MethodMetadata> getDeclaredMethods() {\n\t\tSet<MethodMetadata> result = new LinkedHashSet<>(16);\n\t\tReflectionUtils.doWithLocalMethods(getIntrospectedClass(), method ->\n\t\t\t\tresult.add(new StandardMethodMetadata(method, this.nestedAnnotationsAsMap)));\n\t\treturn result;\n\t}\n\n\n\tprivate static boolean isAnnotatedMethod(Method method, String annotationName) {\n\t\treturn !method.isBridge() && method.getAnnotations().length > 0 &&\n\t\t\t\tAnnotatedElementUtils.isAnnotated(method, annotationName);\n\t}\n\n\tstatic AnnotationMetadata from(Class<?> introspectedClass) {\n\t\treturn new StandardAnnotationMetadata(introspectedClass, true);\n\t}\n\n}"
  },
  "org.springframework.core.type.StandardAnnotationMetadata#getAllAnnotationAttributes(annotationName,classValuesAsString)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationName",
      "classValuesAsString"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "Object>",
    "signature": "public Object> getAllAnnotationAttributes(String annotationName, boolean classValuesAsString)",
    "source_code": "\tpublic @Nullable MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(String annotationName, boolean classValuesAsString) {\n\t\tif (this.nestedAnnotationsAsMap) {\n\t\t\treturn AnnotationMetadata.super.getAllAnnotationAttributes(annotationName, classValuesAsString);\n\t\t}\n\t\treturn AnnotatedElementUtils.getAllAnnotationAttributes(\n\t\t\t\tgetIntrospectedClass(), annotationName, classValuesAsString, false);\n\t}"
  },
  "org.springframework.core.type.StandardAnnotationMetadata#getAnnotatedMethods(annotationName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationName"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "Set<MethodMetadata>",
    "signature": "public Set<MethodMetadata> getAnnotatedMethods(String annotationName)",
    "source_code": "\tpublic Set<MethodMetadata> getAnnotatedMethods(String annotationName) {\n\t\tSet<MethodMetadata> result = new LinkedHashSet<>(4);\n\t\tif (AnnotationUtils.isCandidateClass(getIntrospectedClass(), annotationName)) {\n\t\t\tReflectionUtils.doWithLocalMethods(getIntrospectedClass(), method -> {\n\t\t\t\tif (isAnnotatedMethod(method, annotationName)) {\n\t\t\t\t\tresult.add(new StandardMethodMetadata(method, this.nestedAnnotationsAsMap));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.core.type.StandardAnnotationMetadata#getAnnotationAttributes(annotationName,classValuesAsString)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationName",
      "classValuesAsString"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "Object>",
    "signature": "public Object> getAnnotationAttributes(String annotationName, boolean classValuesAsString)",
    "source_code": "\tpublic @Nullable Map<String, @Nullable Object> getAnnotationAttributes(String annotationName, boolean classValuesAsString) {\n\t\tif (this.nestedAnnotationsAsMap) {\n\t\t\treturn AnnotationMetadata.super.getAnnotationAttributes(annotationName, classValuesAsString);\n\t\t}\n\t\treturn AnnotatedElementUtils.getMergedAnnotationAttributes(\n\t\t\t\tgetIntrospectedClass(), annotationName, classValuesAsString, false);\n\t}"
  },
  "org.springframework.core.type.StandardAnnotationMetadata#getAnnotationTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "Set<String>",
    "signature": "public Set<String> getAnnotationTypes()",
    "source_code": "\tpublic Set<String> getAnnotationTypes() {\n\t\tSet<String> annotationTypes = this.annotationTypes;\n\t\tif (annotationTypes == null) {\n\t\t\tannotationTypes = Collections.unmodifiableSet(AnnotationMetadata.super.getAnnotationTypes());\n\t\t\tthis.annotationTypes = annotationTypes;\n\t\t}\n\t\treturn annotationTypes;\n\t}"
  },
  "org.springframework.core.type.StandardAnnotationMetadata#getAnnotations()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "MergedAnnotations",
    "signature": "public MergedAnnotations getAnnotations()",
    "source_code": "\tpublic MergedAnnotations getAnnotations() {\n\t\treturn this.mergedAnnotations;\n\t}"
  },
  "org.springframework.core.type.StandardAnnotationMetadata#getDeclaredMethods()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "Set<MethodMetadata>",
    "signature": "public Set<MethodMetadata> getDeclaredMethods()",
    "source_code": "\tpublic Set<MethodMetadata> getDeclaredMethods() {\n\t\tSet<MethodMetadata> result = new LinkedHashSet<>(16);\n\t\tReflectionUtils.doWithLocalMethods(getIntrospectedClass(), method ->\n\t\t\t\tresult.add(new StandardMethodMetadata(method, this.nestedAnnotationsAsMap)));\n\t\treturn result;\n\t}"
  },
  "org.springframework.core.type.StandardAnnotationMetadata#hasAnnotatedMethods(annotationName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationName"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "boolean",
    "signature": "public boolean hasAnnotatedMethods(String annotationName)",
    "source_code": "\tpublic boolean hasAnnotatedMethods(String annotationName) {\n\t\tif (AnnotationUtils.isCandidateClass(getIntrospectedClass(), annotationName)) {\n\t\t\ttry {\n\t\t\t\tMethod[] methods = ReflectionUtils.getDeclaredMethods(getIntrospectedClass());\n\t\t\t\tfor (Method method : methods) {\n\t\t\t\t\tif (isAnnotatedMethod(method, annotationName)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to introspect annotated methods on \" + getIntrospectedClass(), ex);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.docs.integration.resthttpinterface.customresolver.CustomHttpServiceArgumentResolver": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 29
    },
    "signature": "public class CustomHttpServiceArgumentResolver",
    "source_code": "public class CustomHttpServiceArgumentResolver {\n\n\t// tag::httpinterface[]\n\tinterface RepositoryService {\n\n\t\t@GetExchange(\"/repos/search\")\n\t\tList<Repository> searchRepository(Search search);\n\n\t}\n\t// end::httpinterface[]\n\n\tclass Sample {\n\n\t\tvoid sample() {\n\t\t\t// tag::usage[]\n\t\t\tRestClient restClient = RestClient.builder().baseUrl(\"https://api.github.com/\").build();\n\t\t\tRestClientAdapter adapter = RestClientAdapter.create(restClient);\n\t\t\tHttpServiceProxyFactory factory = HttpServiceProxyFactory\n\t\t\t\t\t.builderFor(adapter)\n\t\t\t\t\t.customArgumentResolver(new SearchQueryArgumentResolver())\n\t\t\t\t\t.build();\n\t\t\tRepositoryService repositoryService = factory.createClient(RepositoryService.class);\n\n\t\t\tSearch search = Search.create()\n\t\t\t\t\t.owner(\"spring-projects\")\n\t\t\t\t\t.language(\"java\")\n\t\t\t\t\t.query(\"rest\")\n\t\t\t\t\t.build();\n\t\t\tList<Repository> repositories = repositoryService.searchRepository(search);\n\t\t\t// end::usage[]\n\t\t}\n\n\t}\n\n\t// tag::argumentresolver[]\n\tstatic class SearchQueryArgumentResolver implements HttpServiceArgumentResolver {\n\t\t@Override\n\t\tpublic boolean resolve(Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues) {\n\t\t\tif (parameter.getParameterType().equals(Search.class)) {\n\t\t\t\tSearch search = (Search) argument;\n\t\t\t\trequestValues.addRequestParameter(\"owner\", search.owner());\n\t\t\t\trequestValues.addRequestParameter(\"language\", search.language());\n\t\t\t\trequestValues.addRequestParameter(\"query\", search.query());\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t// end::argumentresolver[]\n\n\n\trecord Search (String query, String owner, String language) {\n\n\t\tstatic Builder create() {\n\t\t\treturn new Builder();\n\t\t}\n\n\t\tstatic class Builder {\n\n\t\t\tBuilder query(String query) { return this;}\n\n\t\t\tBuilder owner(String owner) { return this;}\n\n\t\t\tBuilder language(String language) { return this;}\n\n\t\t\tSearch build() {\n\t\t\t\treturn new Search(null, null, null);\n\t\t\t}\n\t\t}\n\n\t}\n\n\trecord Repository(String name) {\n\n\t}\n\n}"
  },
  "org.springframework.docs.integration.resthttpinterface.customresolver.CustomHttpServiceArgumentResolver#resolve(argument,parameter,requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argument",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "boolean",
    "signature": "public boolean resolve(Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues)",
    "source_code": "\t\tpublic boolean resolve(Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues) {\n\t\t\tif (parameter.getParameterType().equals(Search.class)) {\n\t\t\t\tSearch search = (Search) argument;\n\t\t\t\trequestValues.addRequestParameter(\"owner\", search.owner());\n\t\t\t\trequestValues.addRequestParameter(\"language\", search.language());\n\t\t\t\trequestValues.addRequestParameter(\"query\", search.query());\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.expression.Expression": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An expression capable of evaluating itself against context objects.\n *\n * <p>Encapsulates the details of a previously parsed expression string.\n *\n * <p>Provides a common abstraction for expression evaluation.\n *\n * @author Keith Donald\n * @author Andy Clement\n * @author Juergen Hoeller\n * @since 3.0\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public interface Expression",
    "source_code": "public interface Expression {\n\n\t/**\n\t * Return the original string used to create this expression (unmodified).\n\t * @return the original expression string\n\t */\n\tString getExpressionString();\n\n\t/**\n\t * Evaluate this expression in the default context and return the result of evaluation.\n\t * @return the evaluation result\n\t * @throws EvaluationException if there is a problem during evaluation\n\t */\n\t@Nullable Object getValue() throws EvaluationException;\n\n\t/**\n\t * Evaluate this expression in the default context and return the result of evaluation.\n\t * <p>If the result of the evaluation does not match (and cannot be converted to)\n\t * the expected result type then an exception will be thrown.\n\t * @param desiredResultType the type the caller would like the result to be\n\t * @return the evaluation result\n\t * @throws EvaluationException if there is a problem during evaluation\n\t */\n\t<T> @Nullable T getValue(@Nullable Class<T> desiredResultType) throws EvaluationException;\n\n\t/**\n\t * Evaluate this expression in the default context against the specified root object\n\t * and return the result of evaluation.\n\t * @param rootObject the root object against which to evaluate the expression\n\t * @return the evaluation result\n\t * @throws EvaluationException if there is a problem during evaluation\n\t */\n\t@Nullable Object getValue(@Nullable Object rootObject) throws EvaluationException;\n\n\t/**\n\t * Evaluate this expression in the default context against the specified root object\n\t * and return the result of evaluation.\n\t * <p>If the result of the evaluation does not match (and cannot be converted to)\n\t * the expected result type then an exception will be thrown.\n\t * @param rootObject the root object against which to evaluate the expression\n\t * @param desiredResultType the type the caller would like the result to be\n\t * @return the evaluation result\n\t * @throws EvaluationException if there is a problem during evaluation\n\t */\n\t<T> @Nullable T getValue(@Nullable Object rootObject, @Nullable Class<T> desiredResultType)\n\t\t\tthrows EvaluationException;\n\n\t/**\n\t * Evaluate this expression in the provided context and return the result of evaluation.\n\t * @param context the context in which to evaluate the expression\n\t * @return the evaluation result\n\t * @throws EvaluationException if there is a problem during evaluation\n\t */\n\t@Nullable Object getValue(EvaluationContext context) throws EvaluationException;\n\n\t/**\n\t * Evaluate this expression in the provided context against the specified root object\n\t * and return the result of evaluation.\n\t * <p>The supplied root object will be used as an override for any default root object\n\t * configured in the context.\n\t * @param context the context in which to evaluate the expression\n\t * @param rootObject the root object against which to evaluate the expression\n\t * @return the evaluation result\n\t * @throws EvaluationException if there is a problem during evaluation\n\t */\n\t@Nullable Object getValue(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException;\n\n\t/**\n\t * Evaluate this expression in the provided context and return the result of evaluation.\n\t * <p>If the result of the evaluation does not match (and cannot be converted to)\n\t * the expected result type then an exception will be thrown.\n\t * @param context the context in which to evaluate the expression\n\t * @param desiredResultType the type the caller would like the result to be\n\t * @return the evaluation result\n\t * @throws EvaluationException if there is a problem during evaluation\n\t */\n\t<T> @Nullable T getValue(EvaluationContext context, @Nullable Class<T> desiredResultType)\n\t\t\tthrows EvaluationException;\n\n\t/**\n\t * Evaluate this expression in the provided context against the specified root object\n\t * and return the result of evaluation.\n\t * <p>The supplied root object will be used as an override for any default root object\n\t * configured in the context.\n\t * <p>If the result of the evaluation does not match (and cannot be converted to)\n\t * the expected result type then an exception will be thrown.\n\t * @param context the context in which to evaluate the expression\n\t * @param rootObject the root object against which to evaluate the expression\n\t * @param desiredResultType the type the caller would like the result to be\n\t * @return the evaluation result\n\t * @throws EvaluationException if there is a problem during evaluation\n\t */\n\t<T> @Nullable T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> desiredResultType)\n\t\t\tthrows EvaluationException;\n\n\t/**\n\t * Return the most general type that can be passed to the\n\t * {@link #setValue(EvaluationContext, Object)} method using the default context.\n\t * @return the most general type of value that can be set in this context\n\t * @throws EvaluationException if there is a problem determining the type\n\t */\n\t@Nullable Class<?> getValueType() throws EvaluationException;\n\n\t/**\n\t * Return the most general type that can be passed to the\n\t * {@link #setValue(Object, Object)} method using the default context.\n\t * @param rootObject the root object against which to evaluate the expression\n\t * @return the most general type of value that can be set in this context\n\t * @throws EvaluationException if there is a problem determining the type\n\t */\n\t@Nullable Class<?> getValueType(@Nullable Object rootObject) throws EvaluationException;\n\n\t/**\n\t * Return the most general type that can be passed to the\n\t * {@link #setValue(EvaluationContext, Object)} method for the given context.\n\t * @param context the context in which to evaluate the expression\n\t * @return the most general type of value that can be set in this context\n\t * @throws EvaluationException if there is a problem determining the type\n\t */\n\t@Nullable Class<?> getValueType(EvaluationContext context) throws EvaluationException;\n\n\t/**\n\t * Return the most general type that can be passed to the\n\t * {@link #setValue(EvaluationContext, Object, Object)} method for the given context.\n\t * <p>The supplied root object will be used as an override for any default root object\n\t * configured in the context.\n\t * @param context the context in which to evaluate the expression\n\t * @param rootObject the root object against which to evaluate the expression\n\t * @return the most general type of value that can be set in this context\n\t * @throws EvaluationException if there is a problem determining the type\n\t */\n\t@Nullable Class<?> getValueType(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException;\n\n\t/**\n\t * Return a descriptor for the most general type that can be passed to one of\n\t * the {@code setValue(...)} methods using the default context.\n\t * @return a type descriptor for values that can be set in this context\n\t * @throws EvaluationException if there is a problem determining the type\n\t */\n\t@Nullable TypeDescriptor getValueTypeDescriptor() throws EvaluationException;\n\n\t/**\n\t * Return a descriptor for the most general type that can be passed to the\n\t * {@link #setValue(Object, Object)} method using the default context.\n\t * @param rootObject the root object against which to evaluate the expression\n\t * @return a type descriptor for values that can be set in this context\n\t * @throws EvaluationException if there is a problem determining the type\n\t */\n\t@Nullable TypeDescriptor getValueTypeDescriptor(@Nullable Object rootObject) throws EvaluationException;\n\n\t/**\n\t * Return a descriptor for the most general type that can be passed to the\n\t * {@link #setValue(EvaluationContext, Object)} method for the given context.\n\t * @param context the context in which to evaluate the expression\n\t * @return a type descriptor for values that can be set in this context\n\t * @throws EvaluationException if there is a problem determining the type\n\t */\n\t@Nullable TypeDescriptor getValueTypeDescriptor(EvaluationContext context) throws EvaluationException;\n\n\t/**\n\t * Return a descriptor for the most general type that can be passed to the\n\t * {@link #setValue(EvaluationContext, Object, Object)} method for the given\n\t * context.\n\t * <p>The supplied root object will be used as an override for any default root object\n\t * configured in the context.\n\t * @param context the context in which to evaluate the expression\n\t * @param rootObject the root object against which to evaluate the expression\n\t * @return a type descriptor for values that can be set in this context\n\t * @throws EvaluationException if there is a problem determining the type\n\t */\n\t@Nullable TypeDescriptor getValueTypeDescriptor(EvaluationContext context, @Nullable Object rootObject)\n\t\t\tthrows EvaluationException;\n\n\t/**\n\t * Determine if this expression can be written to, i.e. setValue() can be called.\n\t * @param rootObject the root object against which to evaluate the expression\n\t * @return {@code true} if the expression is writable; {@code false} otherwise\n\t * @throws EvaluationException if there is a problem determining if it is writable\n\t */\n\tboolean isWritable(@Nullable Object rootObject) throws EvaluationException;\n\n\t/**\n\t * Determine if this expression can be written to, i.e. setValue() can be called.\n\t * @param context the context in which the expression should be checked\n\t * @return {@code true} if the expression is writable; {@code false} otherwise\n\t * @throws EvaluationException if there is a problem determining if it is writable\n\t */\n\tboolean isWritable(EvaluationContext context) throws EvaluationException;\n\n\t/**\n\t * Determine if this expression can be written to, i.e. setValue() can be called.\n\t * <p>The supplied root object will be used as an override for any default root object\n\t * configured in the context.\n\t * @param context the context in which the expression should be checked\n\t * @param rootObject the root object against which to evaluate the expression\n\t * @return {@code true} if the expression is writable; {@code false} otherwise\n\t * @throws EvaluationException if there is a problem determining if it is writable\n\t */\n\tboolean isWritable(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException;\n\n\t/**\n\t * Set this expression in the default context to the value provided.\n\t * @param rootObject the root object against which to evaluate the expression\n\t * @param value the new value\n\t * @throws EvaluationException if there is a problem during evaluation\n\t */\n\tvoid setValue(@Nullable Object rootObject, @Nullable Object value) throws EvaluationException;\n\n\t/**\n\t * Set this expression in the provided context to the value provided.\n\t * @param context the context in which to set the value of the expression\n\t * @param value the new value\n\t * @throws EvaluationException if there is a problem during evaluation\n\t */\n\tvoid setValue(EvaluationContext context, @Nullable Object value) throws EvaluationException;\n\n\t/**\n\t * Set this expression in the provided context to the value provided.\n\t * <p>The supplied root object will be used as an override for any default root object\n\t * configured in the context.\n\t * @param context the context in which to set the value of the expression\n\t * @param rootObject the root object against which to evaluate the expression\n\t * @param value the new value\n\t * @throws EvaluationException if there is a problem during evaluation\n\t */\n\tvoid setValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Object value)\n\t\t\tthrows EvaluationException;\n\n}"
  },
  "org.springframework.expression.TargetedAccessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Strategy for types that access elements of specific target classes.\n *\n * <p>This interface places no restrictions on what constitutes an element.\n *\n * <p>A targeted accessor can specify a set of target classes for which it should\n * be called. However, if it returns {@code null} or an empty array from\n * {@link #getSpecificTargetClasses()}, it will typically be called for all\n * access operations and given a chance to determine if it supports a concrete\n * access attempt.\n *\n * <p>Targeted accessors are considered to be ordered, and each will be called\n * in turn. The only rule that affects the call order is that any accessor which\n * specifies explicit support for a given target type via\n * {@link #getSpecificTargetClasses()} will be called first, before other generic\n * accessors that do not specify support for explicit target types. In addition,\n * accessors that support the exact target type will be called before accessors\n * that support a supertype of the target type.\n *\n * @author Sam Brannen\n * @since 6.2\n * @see PropertyAccessor\n * @see IndexAccessor\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public interface TargetedAccessor",
    "source_code": "public interface TargetedAccessor {\n\n\t/**\n\t * Get the set of classes for which this accessor should be called.\n\t * <p>Returning {@code null} or an empty array indicates this is a generic\n\t * accessor that can be called in an attempt to access an element on any\n\t * type.\n\t * @return an array of classes that this accessor is suitable for\n\t * (or {@code null} or an empty array if a generic accessor)\n\t */\n\tClass<?> @Nullable [] getSpecificTargetClasses();\n\n}"
  },
  "org.springframework.expression.common.CompositeStringExpression": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Represents a template expression broken into pieces.\n *\n * <p>Each piece will be an {@link Expression}, but pure text parts of the\n * template will be represented as {@link LiteralExpression} objects. An example\n * of a template expression might be:\n *\n * <pre class=\"code\">\n * &quot;Hello ${getName()}&quot;\n * </pre>\n *\n * which will be represented as a {@code CompositeStringExpression} of two parts:\n * the first part being a {@link LiteralExpression} representing 'Hello ' and the\n * second part being a real expression that will call {@code getName()} when invoked.\n *\n * @author Andy Clement\n * @author Juergen Hoeller\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class CompositeStringExpression",
    "source_code": "public class CompositeStringExpression implements Expression {\n\n\tprivate final String expressionString;\n\n\t/** The array of expressions that make up the composite expression. */\n\tprivate final Expression[] expressions;\n\n\n\tpublic CompositeStringExpression(String expressionString, Expression[] expressions) {\n\t\tthis.expressionString = expressionString;\n\t\tthis.expressions = expressions;\n\t}\n\n\n\t@Override\n\tpublic final String getExpressionString() {\n\t\treturn this.expressionString;\n\t}\n\n\tpublic final Expression[] getExpressions() {\n\t\treturn this.expressions;\n\t}\n\n\t@Override\n\tpublic String getValue() throws EvaluationException {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (Expression expression : this.expressions) {\n\t\t\tString value = expression.getValue(String.class);\n\t\t\tif (value != null) {\n\t\t\t\tsb.append(value);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T getValue(@Nullable Class<T> expectedResultType) throws EvaluationException {\n\t\tString value = getValue();\n\t\treturn ExpressionUtils.convertTypedValue(null, new TypedValue(value), expectedResultType);\n\t}\n\n\t@Override\n\tpublic String getValue(@Nullable Object rootObject) throws EvaluationException {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (Expression expression : this.expressions) {\n\t\t\tString value = expression.getValue(rootObject, String.class);\n\t\t\tif (value != null) {\n\t\t\t\tsb.append(value);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T getValue(@Nullable Object rootObject, @Nullable Class<T> desiredResultType) throws EvaluationException {\n\t\tString value = getValue(rootObject);\n\t\treturn ExpressionUtils.convertTypedValue(null, new TypedValue(value), desiredResultType);\n\t}\n\n\t@Override\n\tpublic String getValue(EvaluationContext context) throws EvaluationException {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (Expression expression : this.expressions) {\n\t\t\tString value = expression.getValue(context, String.class);\n\t\t\tif (value != null) {\n\t\t\t\tsb.append(value);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Class<T> expectedResultType)\n\t\t\tthrows EvaluationException {\n\n\t\tString value = getValue(context);\n\t\treturn ExpressionUtils.convertTypedValue(context, new TypedValue(value), expectedResultType);\n\t}\n\n\t@Override\n\tpublic String getValue(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (Expression expression : this.expressions) {\n\t\t\tString value = expression.getValue(context, rootObject, String.class);\n\t\t\tif (value != null) {\n\t\t\t\tsb.append(value);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> desiredResultType)\n\t\t\tthrows EvaluationException {\n\n\t\tString value = getValue(context,rootObject);\n\t\treturn ExpressionUtils.convertTypedValue(context, new TypedValue(value), desiredResultType);\n\t}\n\n\t@Override\n\tpublic Class<?> getValueType() {\n\t\treturn String.class;\n\t}\n\n\t@Override\n\tpublic Class<?> getValueType(EvaluationContext context) {\n\t\treturn String.class;\n\t}\n\n\t@Override\n\tpublic Class<?> getValueType(@Nullable Object rootObject) throws EvaluationException {\n\t\treturn String.class;\n\t}\n\n\t@Override\n\tpublic Class<?> getValueType(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\treturn String.class;\n\t}\n\n\t@Override\n\tpublic TypeDescriptor getValueTypeDescriptor() {\n\t\treturn TypeDescriptor.valueOf(String.class);\n\t}\n\n\t@Override\n\tpublic TypeDescriptor getValueTypeDescriptor(@Nullable Object rootObject) throws EvaluationException {\n\t\treturn TypeDescriptor.valueOf(String.class);\n\t}\n\n\t@Override\n\tpublic TypeDescriptor getValueTypeDescriptor(EvaluationContext context) {\n\t\treturn TypeDescriptor.valueOf(String.class);\n\t}\n\n\t@Override\n\tpublic TypeDescriptor getValueTypeDescriptor(EvaluationContext context, @Nullable Object rootObject)\n\t\t\tthrows EvaluationException {\n\n\t\treturn TypeDescriptor.valueOf(String.class);\n\t}\n\n\t@Override\n\tpublic boolean isWritable(@Nullable Object rootObject) throws EvaluationException {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isWritable(EvaluationContext context) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isWritable(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void setValue(@Nullable Object rootObject, @Nullable Object value) throws EvaluationException {\n\t\tthrow new EvaluationException(this.expressionString, \"Cannot call setValue on a composite expression\");\n\t}\n\n\t@Override\n\tpublic void setValue(EvaluationContext context, @Nullable Object value) throws EvaluationException {\n\t\tthrow new EvaluationException(this.expressionString, \"Cannot call setValue on a composite expression\");\n\t}\n\n\t@Override\n\tpublic void setValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Object value) throws EvaluationException {\n\t\tthrow new EvaluationException(this.expressionString, \"Cannot call setValue on a composite expression\");\n\t}\n\n}"
  },
  "org.springframework.expression.common.CompositeStringExpression#getExpressionString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "String",
    "signature": "public String getExpressionString()",
    "source_code": "\tpublic final String getExpressionString() {\n\t\treturn this.expressionString;\n\t}"
  },
  "org.springframework.expression.common.CompositeStringExpression#getExpressions()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "Expression[]",
    "signature": "public Expression[] getExpressions()",
    "source_code": "\tpublic final Expression[] getExpressions() {\n\t\treturn this.expressions;\n\t}"
  },
  "org.springframework.expression.common.CompositeStringExpression#getValue()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "String",
    "signature": "public String getValue()",
    "source_code": "\tpublic String getValue() throws EvaluationException {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (Expression expression : this.expressions) {\n\t\t\tString value = expression.getValue(String.class);\n\t\t\tif (value != null) {\n\t\t\t\tsb.append(value);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.expression.common.CompositeStringExpression#getValue(context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "String",
    "signature": "public String getValue(EvaluationContext context)",
    "source_code": "\tpublic String getValue(EvaluationContext context) throws EvaluationException {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (Expression expression : this.expressions) {\n\t\t\tString value = expression.getValue(context, String.class);\n\t\t\tif (value != null) {\n\t\t\t\tsb.append(value);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.expression.common.CompositeStringExpression#getValue(context,expectedResultType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "expectedResultType"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "T",
    "signature": "public T getValue(EvaluationContext context, @Nullable Class<T> expectedResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Class<T> expectedResultType)"
  },
  "org.springframework.expression.common.CompositeStringExpression#getValue(context,rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "String",
    "signature": "public String getValue(EvaluationContext context, @Nullable Object rootObject)",
    "source_code": "\tpublic String getValue(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (Expression expression : this.expressions) {\n\t\t\tString value = expression.getValue(context, rootObject, String.class);\n\t\t\tif (value != null) {\n\t\t\t\tsb.append(value);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.expression.common.CompositeStringExpression#getValue(context,rootObject,desiredResultType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject",
      "desiredResultType"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "T",
    "signature": "public T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> desiredResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> desiredResultType)"
  },
  "org.springframework.expression.common.CompositeStringExpression#getValue(expectedResultType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedResultType"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "T",
    "signature": "public T getValue(@Nullable Class<T> expectedResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(@Nullable Class<T> expectedResultType) throws EvaluationException {\n\t\tString value = getValue();\n\t\treturn ExpressionUtils.convertTypedValue(null, new TypedValue(value), expectedResultType);\n\t}"
  },
  "org.springframework.expression.common.CompositeStringExpression#getValue(rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "String",
    "signature": "public String getValue(@Nullable Object rootObject)",
    "source_code": "\tpublic String getValue(@Nullable Object rootObject) throws EvaluationException {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (Expression expression : this.expressions) {\n\t\t\tString value = expression.getValue(rootObject, String.class);\n\t\t\tif (value != null) {\n\t\t\t\tsb.append(value);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.expression.common.CompositeStringExpression#getValue(rootObject,desiredResultType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject",
      "desiredResultType"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "T",
    "signature": "public T getValue(@Nullable Object rootObject, @Nullable Class<T> desiredResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(@Nullable Object rootObject, @Nullable Class<T> desiredResultType) throws EvaluationException {\n\t\tString value = getValue(rootObject);\n\t\treturn ExpressionUtils.convertTypedValue(null, new TypedValue(value), desiredResultType);\n\t}"
  },
  "org.springframework.expression.common.CompositeStringExpression#getValueTypeDescriptor()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getValueTypeDescriptor()",
    "source_code": "\tpublic TypeDescriptor getValueTypeDescriptor() {\n\t\treturn TypeDescriptor.valueOf(String.class);\n\t}"
  },
  "org.springframework.expression.common.CompositeStringExpression#getValueTypeDescriptor(context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getValueTypeDescriptor(EvaluationContext context)",
    "source_code": "\tpublic TypeDescriptor getValueTypeDescriptor(EvaluationContext context) {\n\t\treturn TypeDescriptor.valueOf(String.class);\n\t}"
  },
  "org.springframework.expression.common.CompositeStringExpression#getValueTypeDescriptor(context,rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getValueTypeDescriptor(EvaluationContext context, @Nullable Object rootObject)",
    "source_code": "\tpublic TypeDescriptor getValueTypeDescriptor(EvaluationContext context, @Nullable Object rootObject)"
  },
  "org.springframework.expression.common.CompositeStringExpression#getValueTypeDescriptor(rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getValueTypeDescriptor(@Nullable Object rootObject)",
    "source_code": "\tpublic TypeDescriptor getValueTypeDescriptor(@Nullable Object rootObject) throws EvaluationException {\n\t\treturn TypeDescriptor.valueOf(String.class);\n\t}"
  },
  "org.springframework.expression.common.CompositeStringExpression#isWritable(context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "boolean",
    "signature": "public boolean isWritable(EvaluationContext context)",
    "source_code": "\tpublic boolean isWritable(EvaluationContext context) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.common.CompositeStringExpression#isWritable(context,rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "boolean",
    "signature": "public boolean isWritable(EvaluationContext context, @Nullable Object rootObject)",
    "source_code": "\tpublic boolean isWritable(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.common.CompositeStringExpression#isWritable(rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "boolean",
    "signature": "public boolean isWritable(@Nullable Object rootObject)",
    "source_code": "\tpublic boolean isWritable(@Nullable Object rootObject) throws EvaluationException {\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.common.CompositeStringExpression#setValue(context,rootObject,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "void",
    "signature": "public void setValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Object value)",
    "source_code": "\tpublic void setValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Object value) throws EvaluationException {\n\t\tthrow new EvaluationException(this.expressionString, \"Cannot call setValue on a composite expression\");\n\t}"
  },
  "org.springframework.expression.common.CompositeStringExpression#setValue(context,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "void",
    "signature": "public void setValue(EvaluationContext context, @Nullable Object value)",
    "source_code": "\tpublic void setValue(EvaluationContext context, @Nullable Object value) throws EvaluationException {\n\t\tthrow new EvaluationException(this.expressionString, \"Cannot call setValue on a composite expression\");\n\t}"
  },
  "org.springframework.expression.common.CompositeStringExpression#setValue(rootObject,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void setValue(@Nullable Object rootObject, @Nullable Object value)",
    "source_code": "\tpublic void setValue(@Nullable Object rootObject, @Nullable Object value) throws EvaluationException {\n\t\tthrow new EvaluationException(this.expressionString, \"Cannot call setValue on a composite expression\");\n\t}"
  },
  "org.springframework.expression.common.ExpressionUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Common utility functions that may be used by any Expression Language provider.\n *\n * @author Andy Clement\n * @author Juergen Hoeller\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class ExpressionUtils",
    "source_code": "public abstract class ExpressionUtils {\n\n\t/**\n\t * Determines if there is a type converter available in the specified context and\n\t * attempts to use it to convert the supplied value to the specified type. Throws an\n\t * exception if conversion is not possible.\n\t * @param context the evaluation context that may define a type converter\n\t * @param typedValue the value to convert and a type descriptor describing it\n\t * @param targetType the type to attempt conversion to\n\t * @return the converted value\n\t * @throws EvaluationException if there is a problem during conversion or conversion\n\t * of the value to the specified type is not supported\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T> @Nullable T convertTypedValue(\n\t\t\t@Nullable EvaluationContext context, TypedValue typedValue, @Nullable Class<T> targetType) {\n\n\t\tObject value = typedValue.getValue();\n\t\tif (targetType == null) {\n\t\t\treturn (T) value;\n\t\t}\n\t\tif (context != null) {\n\t\t\treturn (T) context.getTypeConverter().convertValue(\n\t\t\t\t\tvalue, typedValue.getTypeDescriptor(), TypeDescriptor.valueOf(targetType));\n\t\t}\n\t\tif (ClassUtils.isAssignableValue(targetType, value)) {\n\t\t\treturn (T) value;\n\t\t}\n\t\tthrow new EvaluationException(\"Cannot convert value '\" + value + \"' to type '\" + targetType.getName() + \"'\");\n\t}\n\n\t/**\n\t * Attempt to convert a typed value to an int using the supplied type converter.\n\t */\n\tpublic static int toInt(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Integer.class);\n\t}\n\n\t/**\n\t * Attempt to convert a typed value to a boolean using the supplied type converter.\n\t */\n\tpublic static boolean toBoolean(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Boolean.class);\n\t}\n\n\t/**\n\t * Attempt to convert a typed value to a double using the supplied type converter.\n\t */\n\tpublic static double toDouble(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Double.class);\n\t}\n\n\t/**\n\t * Attempt to convert a typed value to a long using the supplied type converter.\n\t */\n\tpublic static long toLong(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Long.class);\n\t}\n\n\t/**\n\t * Attempt to convert a typed value to a char using the supplied type converter.\n\t */\n\tpublic static char toChar(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Character.class);\n\t}\n\n\t/**\n\t * Attempt to convert a typed value to a short using the supplied type converter.\n\t */\n\tpublic static short toShort(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Short.class);\n\t}\n\n\t/**\n\t * Attempt to convert a typed value to a float using the supplied type converter.\n\t */\n\tpublic static float toFloat(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Float.class);\n\t}\n\n\t/**\n\t * Attempt to convert a typed value to a byte using the supplied type converter.\n\t */\n\tpublic static byte toByte(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Byte.class);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static <T> T convertValue(TypeConverter typeConverter, TypedValue typedValue, Class<T> targetType) {\n\t\tObject result = typeConverter.convertValue(typedValue.getValue(), typedValue.getTypeDescriptor(),\n\t\t\t\tTypeDescriptor.valueOf(targetType));\n\t\tif (result == null) {\n\t\t\tthrow new IllegalStateException(\"Null conversion result for value [\" + typedValue.getValue() + \"]\");\n\t\t}\n\t\treturn (T) result;\n\t}\n\n}"
  },
  "org.springframework.expression.common.ExpressionUtils#convertTypedValue(context,typedValue,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determines if there is a type converter available in the specified context and\n\t * attempts to use it to convert the supplied value to the specified type. Throws an\n\t * exception if conversion is not possible.\n\t * @param context the evaluation context that may define a type converter\n\t * @param typedValue the value to convert and a type descriptor describing it\n\t * @param targetType the type to attempt conversion to\n\t * @return the converted value\n\t * @throws EvaluationException if there is a problem during conversion or conversion\n\t * of the value to the specified type is not supported\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "typedValue",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "T",
    "signature": "public T convertTypedValue(@Nullable EvaluationContext context, TypedValue typedValue, @Nullable Class<T> targetType)",
    "source_code": "\tpublic static <T> @Nullable T convertTypedValue("
  },
  "org.springframework.expression.common.ExpressionUtils#toBoolean(typeConverter,typedValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to a boolean using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "boolean",
    "signature": "public boolean toBoolean(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static boolean toBoolean(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Boolean.class);\n\t}"
  },
  "org.springframework.expression.common.ExpressionUtils#toByte(typeConverter,typedValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to a byte using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "byte",
    "signature": "public byte toByte(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static byte toByte(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Byte.class);\n\t}"
  },
  "org.springframework.expression.common.ExpressionUtils#toChar(typeConverter,typedValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to a char using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "char",
    "signature": "public char toChar(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static char toChar(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Character.class);\n\t}"
  },
  "org.springframework.expression.common.ExpressionUtils#toDouble(typeConverter,typedValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to a double using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "double",
    "signature": "public double toDouble(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static double toDouble(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Double.class);\n\t}"
  },
  "org.springframework.expression.common.ExpressionUtils#toFloat(typeConverter,typedValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to a float using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "float",
    "signature": "public float toFloat(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static float toFloat(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Float.class);\n\t}"
  },
  "org.springframework.expression.common.ExpressionUtils#toInt(typeConverter,typedValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to an int using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "int",
    "signature": "public int toInt(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static int toInt(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Integer.class);\n\t}"
  },
  "org.springframework.expression.common.ExpressionUtils#toLong(typeConverter,typedValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to a long using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "long",
    "signature": "public long toLong(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static long toLong(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Long.class);\n\t}"
  },
  "org.springframework.expression.common.ExpressionUtils#toShort(typeConverter,typedValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to a short using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "short",
    "signature": "public short toShort(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static short toShort(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Short.class);\n\t}"
  },
  "org.springframework.expression.common.LiteralExpression": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A very simple, hard-coded implementation of the {@link Expression} interface\n * that represents a string literal.\n *\n * <p>It is used with {@link CompositeStringExpression} when representing a template\n * expression which is made up of pieces, some being real expressions to be handled by\n * an EL implementation like SpEL, and some being just textual elements.\n *\n * @author Andy Clement\n * @author Juergen Hoeller\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class LiteralExpression",
    "source_code": "public class LiteralExpression implements Expression {\n\n\t/** Fixed literal value of this expression. */\n\tprivate final String literalValue;\n\n\n\tpublic LiteralExpression(String literalValue) {\n\t\tthis.literalValue = literalValue;\n\t}\n\n\n\t@Override\n\tpublic final String getExpressionString() {\n\t\treturn this.literalValue;\n\t}\n\n\t@Override\n\tpublic Class<?> getValueType(EvaluationContext context) {\n\t\treturn String.class;\n\t}\n\n\t@Override\n\tpublic String getValue() {\n\t\treturn this.literalValue;\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T getValue(@Nullable Class<T> expectedResultType) throws EvaluationException {\n\t\tString value = getValue();\n\t\treturn ExpressionUtils.convertTypedValue(null, new TypedValue(value), expectedResultType);\n\t}\n\n\t@Override\n\tpublic String getValue(@Nullable Object rootObject) {\n\t\treturn this.literalValue;\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T getValue(@Nullable Object rootObject, @Nullable Class<T> desiredResultType) throws EvaluationException {\n\t\tString value = getValue(rootObject);\n\t\treturn ExpressionUtils.convertTypedValue(null, new TypedValue(value), desiredResultType);\n\t}\n\n\t@Override\n\tpublic String getValue(EvaluationContext context) {\n\t\treturn this.literalValue;\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Class<T> expectedResultType) throws EvaluationException {\n\t\tString value = getValue(context);\n\t\treturn ExpressionUtils.convertTypedValue(context, new TypedValue(value), expectedResultType);\n\t}\n\n\t@Override\n\tpublic String getValue(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\treturn this.literalValue;\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> desiredResultType)\n\t\t\tthrows EvaluationException {\n\n\t\tString value = getValue(context, rootObject);\n\t\treturn ExpressionUtils.convertTypedValue(context, new TypedValue(value), desiredResultType);\n\t}\n\n\t@Override\n\tpublic Class<?> getValueType() {\n\t\treturn String.class;\n\t}\n\n\t@Override\n\tpublic Class<?> getValueType(@Nullable Object rootObject) throws EvaluationException {\n\t\treturn String.class;\n\t}\n\n\t@Override\n\tpublic Class<?> getValueType(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\treturn String.class;\n\t}\n\n\t@Override\n\tpublic TypeDescriptor getValueTypeDescriptor() {\n\t\treturn TypeDescriptor.valueOf(String.class);\n\t}\n\n\t@Override\n\tpublic TypeDescriptor getValueTypeDescriptor(@Nullable Object rootObject) throws EvaluationException {\n\t\treturn TypeDescriptor.valueOf(String.class);\n\t}\n\n\t@Override\n\tpublic TypeDescriptor getValueTypeDescriptor(EvaluationContext context) {\n\t\treturn TypeDescriptor.valueOf(String.class);\n\t}\n\n\t@Override\n\tpublic TypeDescriptor getValueTypeDescriptor(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\treturn TypeDescriptor.valueOf(String.class);\n\t}\n\n\t@Override\n\tpublic boolean isWritable(@Nullable Object rootObject) throws EvaluationException {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isWritable(EvaluationContext context) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isWritable(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void setValue(@Nullable Object rootObject, @Nullable Object value) throws EvaluationException {\n\t\tthrow new EvaluationException(this.literalValue, \"Cannot call setValue() on a LiteralExpression\");\n\t}\n\n\t@Override\n\tpublic void setValue(EvaluationContext context, @Nullable Object value) throws EvaluationException {\n\t\tthrow new EvaluationException(this.literalValue, \"Cannot call setValue() on a LiteralExpression\");\n\t}\n\n\t@Override\n\tpublic void setValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Object value) throws EvaluationException {\n\t\tthrow new EvaluationException(this.literalValue, \"Cannot call setValue() on a LiteralExpression\");\n\t}\n\n}"
  },
  "org.springframework.expression.common.LiteralExpression#getExpressionString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "String",
    "signature": "public String getExpressionString()",
    "source_code": "\tpublic final String getExpressionString() {\n\t\treturn this.literalValue;\n\t}"
  },
  "org.springframework.expression.common.LiteralExpression#getValue()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "String",
    "signature": "public String getValue()",
    "source_code": "\tpublic String getValue() {\n\t\treturn this.literalValue;\n\t}"
  },
  "org.springframework.expression.common.LiteralExpression#getValue(context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "String",
    "signature": "public String getValue(EvaluationContext context)",
    "source_code": "\tpublic String getValue(EvaluationContext context) {\n\t\treturn this.literalValue;\n\t}"
  },
  "org.springframework.expression.common.LiteralExpression#getValue(context,expectedResultType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "expectedResultType"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "T",
    "signature": "public T getValue(EvaluationContext context, @Nullable Class<T> expectedResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Class<T> expectedResultType) throws EvaluationException {\n\t\tString value = getValue(context);\n\t\treturn ExpressionUtils.convertTypedValue(context, new TypedValue(value), expectedResultType);\n\t}"
  },
  "org.springframework.expression.common.LiteralExpression#getValue(context,rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "String",
    "signature": "public String getValue(EvaluationContext context, @Nullable Object rootObject)",
    "source_code": "\tpublic String getValue(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\treturn this.literalValue;\n\t}"
  },
  "org.springframework.expression.common.LiteralExpression#getValue(context,rootObject,desiredResultType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject",
      "desiredResultType"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "T",
    "signature": "public T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> desiredResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> desiredResultType)"
  },
  "org.springframework.expression.common.LiteralExpression#getValue(expectedResultType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedResultType"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "T",
    "signature": "public T getValue(@Nullable Class<T> expectedResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(@Nullable Class<T> expectedResultType) throws EvaluationException {\n\t\tString value = getValue();\n\t\treturn ExpressionUtils.convertTypedValue(null, new TypedValue(value), expectedResultType);\n\t}"
  },
  "org.springframework.expression.common.LiteralExpression#getValue(rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "String",
    "signature": "public String getValue(@Nullable Object rootObject)",
    "source_code": "\tpublic String getValue(@Nullable Object rootObject) {\n\t\treturn this.literalValue;\n\t}"
  },
  "org.springframework.expression.common.LiteralExpression#getValue(rootObject,desiredResultType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject",
      "desiredResultType"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "T",
    "signature": "public T getValue(@Nullable Object rootObject, @Nullable Class<T> desiredResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(@Nullable Object rootObject, @Nullable Class<T> desiredResultType) throws EvaluationException {\n\t\tString value = getValue(rootObject);\n\t\treturn ExpressionUtils.convertTypedValue(null, new TypedValue(value), desiredResultType);\n\t}"
  },
  "org.springframework.expression.common.LiteralExpression#getValueTypeDescriptor()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getValueTypeDescriptor()",
    "source_code": "\tpublic TypeDescriptor getValueTypeDescriptor() {\n\t\treturn TypeDescriptor.valueOf(String.class);\n\t}"
  },
  "org.springframework.expression.common.LiteralExpression#getValueTypeDescriptor(context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getValueTypeDescriptor(EvaluationContext context)",
    "source_code": "\tpublic TypeDescriptor getValueTypeDescriptor(EvaluationContext context) {\n\t\treturn TypeDescriptor.valueOf(String.class);\n\t}"
  },
  "org.springframework.expression.common.LiteralExpression#getValueTypeDescriptor(context,rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getValueTypeDescriptor(EvaluationContext context, @Nullable Object rootObject)",
    "source_code": "\tpublic TypeDescriptor getValueTypeDescriptor(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\treturn TypeDescriptor.valueOf(String.class);\n\t}"
  },
  "org.springframework.expression.common.LiteralExpression#getValueTypeDescriptor(rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getValueTypeDescriptor(@Nullable Object rootObject)",
    "source_code": "\tpublic TypeDescriptor getValueTypeDescriptor(@Nullable Object rootObject) throws EvaluationException {\n\t\treturn TypeDescriptor.valueOf(String.class);\n\t}"
  },
  "org.springframework.expression.common.LiteralExpression#isWritable(context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "boolean",
    "signature": "public boolean isWritable(EvaluationContext context)",
    "source_code": "\tpublic boolean isWritable(EvaluationContext context) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.common.LiteralExpression#isWritable(context,rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "boolean",
    "signature": "public boolean isWritable(EvaluationContext context, @Nullable Object rootObject)",
    "source_code": "\tpublic boolean isWritable(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.common.LiteralExpression#isWritable(rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "boolean",
    "signature": "public boolean isWritable(@Nullable Object rootObject)",
    "source_code": "\tpublic boolean isWritable(@Nullable Object rootObject) throws EvaluationException {\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.common.LiteralExpression#setValue(context,rootObject,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "public void setValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Object value)",
    "source_code": "\tpublic void setValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Object value) throws EvaluationException {\n\t\tthrow new EvaluationException(this.literalValue, \"Cannot call setValue() on a LiteralExpression\");\n\t}"
  },
  "org.springframework.expression.common.LiteralExpression#setValue(context,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void setValue(EvaluationContext context, @Nullable Object value)",
    "source_code": "\tpublic void setValue(EvaluationContext context, @Nullable Object value) throws EvaluationException {\n\t\tthrow new EvaluationException(this.literalValue, \"Cannot call setValue() on a LiteralExpression\");\n\t}"
  },
  "org.springframework.expression.common.LiteralExpression#setValue(rootObject,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "public void setValue(@Nullable Object rootObject, @Nullable Object value)",
    "source_code": "\tpublic void setValue(@Nullable Object rootObject, @Nullable Object value) throws EvaluationException {\n\t\tthrow new EvaluationException(this.literalValue, \"Cannot call setValue() on a LiteralExpression\");\n\t}"
  },
  "org.springframework.expression.spel.SpelEvaluationException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Root exception for Spring EL related exceptions.\n *\n * <p>Rather than holding a hard-coded string indicating the problem, it records\n * a message key and the inserts for the message.\n *\n * <p>See {@link SpelMessage} for the list of all possible messages that can occur.\n *\n * @author Andy Clement\n * @author Juergen Hoeller\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public class SpelEvaluationException",
    "source_code": "public class SpelEvaluationException extends EvaluationException {\n\n\tprivate final SpelMessage message;\n\n\tprivate final @Nullable Object[] inserts;\n\n\n\tpublic SpelEvaluationException(SpelMessage message, @Nullable Object... inserts) {\n\t\tsuper(message.formatMessage(inserts));\n\t\tthis.message = message;\n\t\tthis.inserts = inserts;\n\t}\n\n\tpublic SpelEvaluationException(int position, SpelMessage message, @Nullable Object... inserts) {\n\t\tsuper(position, message.formatMessage(inserts));\n\t\tthis.message = message;\n\t\tthis.inserts = inserts;\n\t}\n\n\tpublic SpelEvaluationException(int position, @Nullable Throwable cause, SpelMessage message, @Nullable Object... inserts) {\n\t\tsuper(position, message.formatMessage(inserts), cause);\n\t\tthis.message = message;\n\t\tthis.inserts = inserts;\n\t}\n\n\tpublic SpelEvaluationException(@Nullable Throwable cause, SpelMessage message, @Nullable Object... inserts) {\n\t\tsuper(message.formatMessage(inserts), cause);\n\t\tthis.message = message;\n\t\tthis.inserts = inserts;\n\t}\n\n\n\t/**\n\t * Set the position in the related expression which gave rise to this exception.\n\t */\n\tpublic void setPosition(int position) {\n\t\tthis.position = position;\n\t}\n\n\t/**\n\t * Return the message code.\n\t */\n\tpublic SpelMessage getMessageCode() {\n\t\treturn this.message;\n\t}\n\n\t/**\n\t * Return the message inserts.\n\t */\n\tpublic @Nullable Object @Nullable [] getInserts() {\n\t\treturn this.inserts;\n\t}\n\n}"
  },
  "org.springframework.expression.spel.SpelEvaluationException#getMessageCode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the message code.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "SpelMessage",
    "signature": "public SpelMessage getMessageCode()",
    "source_code": "\tpublic SpelMessage getMessageCode() {\n\t\treturn this.message;\n\t}"
  },
  "org.springframework.expression.spel.SpelEvaluationException#setPosition(position)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the position in the related expression which gave rise to this exception.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "position"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "public void setPosition(int position)",
    "source_code": "\tpublic void setPosition(int position) {\n\t\tthis.position = position;\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#asBetweenToken()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "Token",
    "signature": "public Token asBetweenToken()",
    "source_code": "\tpublic Token asBetweenToken() {\n\t\treturn new Token(TokenKind.BETWEEN, this.startPos, this.endPos);\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#asInstanceOfToken()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "Token",
    "signature": "public Token asInstanceOfToken()",
    "source_code": "\tpublic Token asInstanceOfToken() {\n\t\treturn new Token(TokenKind.INSTANCEOF, this.startPos, this.endPos);\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#asMatchesToken()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "Token",
    "signature": "public Token asMatchesToken()",
    "source_code": "\tpublic Token asMatchesToken() {\n\t\treturn new Token(TokenKind.MATCHES, this.startPos, this.endPos);\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#doParseExpression(expressionString,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "expressionString",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "SpelExpression",
    "signature": "protected SpelExpression doParseExpression(String expressionString, @Nullable ParserContext context)",
    "source_code": "\tprotected SpelExpression doParseExpression(String expressionString, @Nullable ParserContext context)"
  },
  "org.springframework.expression.spel.standard.<unknown>#getKind()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "TokenKind",
    "signature": "public TokenKind getKind()",
    "source_code": "\tpublic TokenKind getKind() {\n\t\treturn this.kind;\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#isIdentifier()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "boolean",
    "signature": "public boolean isIdentifier()",
    "source_code": "\tpublic boolean isIdentifier() {\n\t\treturn (this.kind == TokenKind.IDENTIFIER);\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#isNumericRelationalOperator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "boolean",
    "signature": "public boolean isNumericRelationalOperator()",
    "source_code": "\tpublic boolean isNumericRelationalOperator() {\n\t\treturn (this.kind == TokenKind.GT || this.kind == TokenKind.GE || this.kind == TokenKind.LT ||\n\t\t\t\tthis.kind == TokenKind.LE || this.kind == TokenKind.EQ || this.kind == TokenKind.NE);\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#stringValue()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "String",
    "signature": "public String stringValue()",
    "source_code": "\tpublic String stringValue() {\n\t\treturn (this.data != null ? this.data : \"\");\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append('[').append(this.kind);\n\t\tif (this.kind.hasPayload()) {\n\t\t\tsb.append(':').append(this.data);\n\t\t}\n\t\tsb.append(']');\n\t\tsb.append('(').append(this.startPos).append(',').append(this.endPos).append(')');\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#toString(t)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t"
    ],
    "position": {
      "column": 1,
      "line": 1026
    },
    "return": "String",
    "signature": "public String toString(@Nullable Token t)",
    "source_code": "\tpublic String toString(@Nullable Token t) {\n\t\tif (t == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tif (t.getKind().hasPayload()) {\n\t\t\treturn t.stringValue();\n\t\t}\n\t\treturn t.kind.toString().toLowerCase(Locale.ROOT);\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@code SpelExpression} represents a parsed (valid) expression that is ready to be\n * evaluated in a specified context. An expression can be evaluated standalone or in a\n * specified context. During expression evaluation the context may be asked to resolve\n * references to types, beans, properties, and methods.\n *\n * @author Andy Clement\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class SpelExpression",
    "source_code": "public class SpelExpression implements Expression {\n\n\t// Number of times to interpret an expression before compiling it\n\tprivate static final int INTERPRETED_COUNT_THRESHOLD = 100;\n\n\t// Number of times to try compiling an expression before giving up\n\tprivate static final int FAILED_ATTEMPTS_THRESHOLD = 100;\n\n\n\tprivate final String expression;\n\n\tprivate final SpelNodeImpl ast;\n\n\tprivate final SpelParserConfiguration configuration;\n\n\t// The default context is used if no override is supplied by the user\n\tprivate @Nullable EvaluationContext evaluationContext;\n\n\t// Holds the compiled form of the expression (if it has been compiled)\n\tprivate volatile @Nullable CompiledExpression compiledAst;\n\n\t// Count of many times as the expression been interpreted - can trigger compilation\n\t// when certain limit reached\n\tprivate final AtomicInteger interpretedCount = new AtomicInteger();\n\n\t// The number of times compilation was attempted and failed - enables us to eventually\n\t// give up trying to compile it when it just doesn't seem to be possible.\n\tprivate final AtomicInteger failedAttempts = new AtomicInteger();\n\n\n\t/**\n\t * Construct an expression, only used by the parser.\n\t */\n\tpublic SpelExpression(String expression, SpelNodeImpl ast, SpelParserConfiguration configuration) {\n\t\tthis.expression = expression;\n\t\tthis.ast = ast;\n\t\tthis.configuration = configuration;\n\t}\n\n\n\t/**\n\t * Set the evaluation context that will be used if none is specified on an evaluation call.\n\t * @param evaluationContext the evaluation context to use\n\t */\n\tpublic void setEvaluationContext(EvaluationContext evaluationContext) {\n\t\tthis.evaluationContext = evaluationContext;\n\t}\n\n\t/**\n\t * Return the default evaluation context that will be used if none is supplied on an evaluation call.\n\t * @return the default evaluation context\n\t */\n\tpublic EvaluationContext getEvaluationContext() {\n\t\tif (this.evaluationContext == null) {\n\t\t\tthis.evaluationContext = new StandardEvaluationContext();\n\t\t}\n\t\treturn this.evaluationContext;\n\t}\n\n\n\t// implementing Expression\n\n\t@Override\n\tpublic String getExpressionString() {\n\t\treturn this.expression;\n\t}\n\n\t@Override\n\tpublic @Nullable Object getValue() throws EvaluationException {\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\tEvaluationContext context = getEvaluationContext();\n\t\t\t\treturn compiledAst.getValue(context.getRootObject().getValue(), context);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState = new ExpressionState(getEvaluationContext(), this.configuration);\n\t\tObject result = this.ast.getValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn result;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T> @Nullable T getValue(@Nullable Class<T> expectedResultType) throws EvaluationException {\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\tEvaluationContext context = getEvaluationContext();\n\t\t\t\tObject result = compiledAst.getValue(context.getRootObject().getValue(), context);\n\t\t\t\tif (expectedResultType == null) {\n\t\t\t\t\treturn (T) result;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn ExpressionUtils.convertTypedValue(\n\t\t\t\t\t\t\tgetEvaluationContext(), new TypedValue(result), expectedResultType);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState = new ExpressionState(getEvaluationContext(), this.configuration);\n\t\tTypedValue typedResultValue = this.ast.getTypedValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn ExpressionUtils.convertTypedValue(\n\t\t\t\texpressionState.getEvaluationContext(), typedResultValue, expectedResultType);\n\t}\n\n\t@Override\n\tpublic @Nullable Object getValue(@Nullable Object rootObject) throws EvaluationException {\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\treturn compiledAst.getValue(rootObject, getEvaluationContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState =\n\t\t\t\tnew ExpressionState(getEvaluationContext(), toTypedValue(rootObject), this.configuration);\n\t\tObject result = this.ast.getValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn result;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T> @Nullable T getValue(@Nullable Object rootObject, @Nullable Class<T> expectedResultType) throws EvaluationException {\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\tObject result = compiledAst.getValue(rootObject, getEvaluationContext());\n\t\t\t\tif (expectedResultType == null) {\n\t\t\t\t\treturn (T)result;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn ExpressionUtils.convertTypedValue(\n\t\t\t\t\t\t\tgetEvaluationContext(), new TypedValue(result), expectedResultType);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState =\n\t\t\t\tnew ExpressionState(getEvaluationContext(), toTypedValue(rootObject), this.configuration);\n\t\tTypedValue typedResultValue = this.ast.getTypedValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn ExpressionUtils.convertTypedValue(\n\t\t\t\texpressionState.getEvaluationContext(), typedResultValue, expectedResultType);\n\t}\n\n\t@Override\n\tpublic @Nullable Object getValue(EvaluationContext context) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\treturn compiledAst.getValue(context.getRootObject().getValue(), context);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState = new ExpressionState(context, this.configuration);\n\t\tObject result = this.ast.getValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn result;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Class<T> expectedResultType) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\tObject result = compiledAst.getValue(context.getRootObject().getValue(), context);\n\t\t\t\tif (expectedResultType != null) {\n\t\t\t\t\treturn ExpressionUtils.convertTypedValue(context, new TypedValue(result), expectedResultType);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn (T) result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState = new ExpressionState(context, this.configuration);\n\t\tTypedValue typedResultValue = this.ast.getTypedValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn ExpressionUtils.convertTypedValue(context, typedResultValue, expectedResultType);\n\t}\n\n\t@Override\n\tpublic @Nullable Object getValue(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\treturn compiledAst.getValue(rootObject, context);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState = new ExpressionState(context, toTypedValue(rootObject), this.configuration);\n\t\tObject result = this.ast.getValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn result;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> expectedResultType)\n\t\t\tthrows EvaluationException {\n\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\tObject result = compiledAst.getValue(rootObject, context);\n\t\t\t\tif (expectedResultType != null) {\n\t\t\t\t\treturn ExpressionUtils.convertTypedValue(context, new TypedValue(result), expectedResultType);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn (T) result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState = new ExpressionState(context, toTypedValue(rootObject), this.configuration);\n\t\tTypedValue typedResultValue = this.ast.getTypedValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn ExpressionUtils.convertTypedValue(context, typedResultValue, expectedResultType);\n\t}\n\n\t@Override\n\tpublic @Nullable Class<?> getValueType() throws EvaluationException {\n\t\treturn getValueType(getEvaluationContext());\n\t}\n\n\t@Override\n\tpublic @Nullable Class<?> getValueType(@Nullable Object rootObject) throws EvaluationException {\n\t\treturn getValueType(getEvaluationContext(), rootObject);\n\t}\n\n\t@Override\n\tpublic @Nullable Class<?> getValueType(EvaluationContext context) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\t\tExpressionState expressionState = new ExpressionState(context, this.configuration);\n\t\tTypeDescriptor typeDescriptor = this.ast.getValueInternal(expressionState).getTypeDescriptor();\n\t\treturn (typeDescriptor != null ? typeDescriptor.getType() : null);\n\t}\n\n\t@Override\n\tpublic @Nullable Class<?> getValueType(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\tExpressionState expressionState = new ExpressionState(context, toTypedValue(rootObject), this.configuration);\n\t\tTypeDescriptor typeDescriptor = this.ast.getValueInternal(expressionState).getTypeDescriptor();\n\t\treturn (typeDescriptor != null ? typeDescriptor.getType() : null);\n\t}\n\n\t@Override\n\tpublic @Nullable TypeDescriptor getValueTypeDescriptor() throws EvaluationException {\n\t\treturn getValueTypeDescriptor(getEvaluationContext());\n\t}\n\n\t@Override\n\tpublic @Nullable TypeDescriptor getValueTypeDescriptor(@Nullable Object rootObject) throws EvaluationException {\n\t\tExpressionState expressionState =\n\t\t\t\tnew ExpressionState(getEvaluationContext(), toTypedValue(rootObject), this.configuration);\n\t\treturn this.ast.getValueInternal(expressionState).getTypeDescriptor();\n\t}\n\n\t@Override\n\tpublic @Nullable TypeDescriptor getValueTypeDescriptor(EvaluationContext context) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\t\tExpressionState expressionState = new ExpressionState(context, this.configuration);\n\t\treturn this.ast.getValueInternal(expressionState).getTypeDescriptor();\n\t}\n\n\t@Override\n\tpublic @Nullable TypeDescriptor getValueTypeDescriptor(EvaluationContext context, @Nullable Object rootObject)\n\t\t\tthrows EvaluationException {\n\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\t\tExpressionState expressionState = new ExpressionState(context, toTypedValue(rootObject), this.configuration);\n\t\treturn this.ast.getValueInternal(expressionState).getTypeDescriptor();\n\t}\n\n\t@Override\n\tpublic boolean isWritable(@Nullable Object rootObject) throws EvaluationException {\n\t\treturn this.ast.isWritable(\n\t\t\t\tnew ExpressionState(getEvaluationContext(), toTypedValue(rootObject), this.configuration));\n\t}\n\n\t@Override\n\tpublic boolean isWritable(EvaluationContext context) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\t\treturn this.ast.isWritable(new ExpressionState(context, this.configuration));\n\t}\n\n\t@Override\n\tpublic boolean isWritable(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\t\treturn this.ast.isWritable(new ExpressionState(context, toTypedValue(rootObject), this.configuration));\n\t}\n\n\t@Override\n\tpublic void setValue(@Nullable Object rootObject, @Nullable Object value) throws EvaluationException {\n\t\tthis.ast.setValue(\n\t\t\t\tnew ExpressionState(getEvaluationContext(), toTypedValue(rootObject), this.configuration), value);\n\t}\n\n\t@Override\n\tpublic void setValue(EvaluationContext context, @Nullable Object value) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\t\tthis.ast.setValue(new ExpressionState(context, this.configuration), value);\n\t}\n\n\t@Override\n\tpublic void setValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Object value)\n\t\t\tthrows EvaluationException {\n\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\t\tthis.ast.setValue(new ExpressionState(context, toTypedValue(rootObject), this.configuration), value);\n\t}\n\n\n\t/**\n\t * Compile the expression if it has been evaluated more than the threshold number\n\t * of times to trigger compilation.\n\t * @param expressionState the expression state used to determine compilation mode\n\t */\n\tprivate void checkCompile(ExpressionState expressionState) {\n\t\tthis.interpretedCount.incrementAndGet();\n\t\tSpelCompilerMode compilerMode = expressionState.getConfiguration().getCompilerMode();\n\t\tif (compilerMode != SpelCompilerMode.OFF) {\n\t\t\tif (compilerMode == SpelCompilerMode.IMMEDIATE) {\n\t\t\t\tif (this.interpretedCount.get() > 1) {\n\t\t\t\t\tcompileExpression();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// compilerMode = SpelCompilerMode.MIXED\n\t\t\t\tif (this.interpretedCount.get() > INTERPRETED_COUNT_THRESHOLD) {\n\t\t\t\t\tcompileExpression();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Perform expression compilation. This will only succeed once exit descriptors for\n\t * all nodes have been determined. If the compilation fails and has failed more than\n\t * 100 times the expression is no longer considered suitable for compilation.\n\t * @return whether this expression has been successfully compiled\n\t */\n\tpublic boolean compileExpression() {\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\t// Previously compiled\n\t\t\treturn true;\n\t\t}\n\t\tif (this.failedAttempts.get() > FAILED_ATTEMPTS_THRESHOLD) {\n\t\t\t// Don't try again\n\t\t\treturn false;\n\t\t}\n\n\t\tsynchronized (this) {\n\t\t\tif (this.compiledAst != null) {\n\t\t\t\t// Compiled by another thread before this thread got into the sync block\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tSpelCompiler compiler = SpelCompiler.getCompiler(this.configuration.getCompilerClassLoader());\n\t\t\t\tcompiledAst = compiler.compile(this.ast);\n\t\t\t\tif (compiledAst != null) {\n\t\t\t\t\t// Successfully compiled\n\t\t\t\t\tthis.compiledAst = compiledAst;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Failed to compile\n\t\t\t\t\tthis.failedAttempts.incrementAndGet();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\t// Failed to compile\n\t\t\t\tthis.failedAttempts.incrementAndGet();\n\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_COMPILING_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Cause an expression to revert to being interpreted if it has been using a compiled\n\t * form. It also resets the compilation attempt failure count (an expression is normally no\n\t * longer considered compilable if it cannot be compiled after 100 attempts).\n\t */\n\tpublic void revertToInterpreted() {\n\t\tthis.compiledAst = null;\n\t\tthis.interpretedCount.set(0);\n\t\tthis.failedAttempts.set(0);\n\t}\n\n\t/**\n\t * Return the Abstract Syntax Tree for the expression.\n\t */\n\tpublic SpelNode getAST() {\n\t\treturn this.ast;\n\t}\n\n\t/**\n\t * Produce a string representation of the Abstract Syntax Tree for the expression.\n\t * This should ideally look like the input expression, but properly formatted since any\n\t * unnecessary whitespace will have been discarded during the parse of the expression.\n\t * @return the string representation of the AST\n\t */\n\tpublic String toStringAST() {\n\t\treturn this.ast.toStringAST();\n\t}\n\n\tprivate TypedValue toTypedValue(@Nullable Object object) {\n\t\treturn (object != null ? new TypedValue(object) : TypedValue.NULL);\n\t}\n\n}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#compileExpression()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform expression compilation. This will only succeed once exit descriptors for\n\t * all nodes have been determined. If the compilation fails and has failed more than\n\t * 100 times the expression is no longer considered suitable for compilation.\n\t * @return whether this expression has been successfully compiled\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 493
    },
    "return": "boolean",
    "signature": "public boolean compileExpression()",
    "source_code": "\tpublic boolean compileExpression() {\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\t// Previously compiled\n\t\t\treturn true;\n\t\t}\n\t\tif (this.failedAttempts.get() > FAILED_ATTEMPTS_THRESHOLD) {\n\t\t\t// Don't try again\n\t\t\treturn false;\n\t\t}\n\n\t\tsynchronized (this) {\n\t\t\tif (this.compiledAst != null) {\n\t\t\t\t// Compiled by another thread before this thread got into the sync block\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tSpelCompiler compiler = SpelCompiler.getCompiler(this.configuration.getCompilerClassLoader());\n\t\t\t\tcompiledAst = compiler.compile(this.ast);\n\t\t\t\tif (compiledAst != null) {\n\t\t\t\t\t// Successfully compiled\n\t\t\t\t\tthis.compiledAst = compiledAst;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Failed to compile\n\t\t\t\t\tthis.failedAttempts.incrementAndGet();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\t// Failed to compile\n\t\t\t\tthis.failedAttempts.incrementAndGet();\n\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_COMPILING_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#getAST()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Abstract Syntax Tree for the expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 555
    },
    "return": "SpelNode",
    "signature": "public SpelNode getAST()",
    "source_code": "\tpublic SpelNode getAST() {\n\t\treturn this.ast;\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#getEvaluationContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the default evaluation context that will be used if none is supplied on an evaluation call.\n\t * @return the default evaluation context\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "EvaluationContext",
    "signature": "public EvaluationContext getEvaluationContext()",
    "source_code": "\tpublic EvaluationContext getEvaluationContext() {\n\t\tif (this.evaluationContext == null) {\n\t\t\tthis.evaluationContext = new StandardEvaluationContext();\n\t\t}\n\t\treturn this.evaluationContext;\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#getExpressionString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "String",
    "signature": "public String getExpressionString()",
    "source_code": "\tpublic String getExpressionString() {\n\t\treturn this.expression;\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#getValue()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "Object",
    "signature": "public Object getValue()",
    "source_code": "\tpublic @Nullable Object getValue() throws EvaluationException {\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\tEvaluationContext context = getEvaluationContext();\n\t\t\t\treturn compiledAst.getValue(context.getRootObject().getValue(), context);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState = new ExpressionState(getEvaluationContext(), this.configuration);\n\t\tObject result = this.ast.getValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn result;\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#getValue(context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "Object",
    "signature": "public Object getValue(EvaluationContext context)",
    "source_code": "\tpublic @Nullable Object getValue(EvaluationContext context) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\treturn compiledAst.getValue(context.getRootObject().getValue(), context);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState = new ExpressionState(context, this.configuration);\n\t\tObject result = this.ast.getValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn result;\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#getValue(context,expectedResultType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "expectedResultType"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "T",
    "signature": "public T getValue(EvaluationContext context, @Nullable Class<T> expectedResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Class<T> expectedResultType) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\tObject result = compiledAst.getValue(context.getRootObject().getValue(), context);\n\t\t\t\tif (expectedResultType != null) {\n\t\t\t\t\treturn ExpressionUtils.convertTypedValue(context, new TypedValue(result), expectedResultType);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn (T) result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState = new ExpressionState(context, this.configuration);\n\t\tTypedValue typedResultValue = this.ast.getTypedValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn ExpressionUtils.convertTypedValue(context, typedResultValue, expectedResultType);\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#getValue(context,rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "Object",
    "signature": "public Object getValue(EvaluationContext context, @Nullable Object rootObject)",
    "source_code": "\tpublic @Nullable Object getValue(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\treturn compiledAst.getValue(rootObject, context);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState = new ExpressionState(context, toTypedValue(rootObject), this.configuration);\n\t\tObject result = this.ast.getValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn result;\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#getValue(context,rootObject,expectedResultType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject",
      "expectedResultType"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "T",
    "signature": "public T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> expectedResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> expectedResultType)"
  },
  "org.springframework.expression.spel.standard.SpelExpression#getValue(expectedResultType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedResultType"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "T",
    "signature": "public T getValue(@Nullable Class<T> expectedResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(@Nullable Class<T> expectedResultType) throws EvaluationException {\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\tEvaluationContext context = getEvaluationContext();\n\t\t\t\tObject result = compiledAst.getValue(context.getRootObject().getValue(), context);\n\t\t\t\tif (expectedResultType == null) {\n\t\t\t\t\treturn (T) result;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn ExpressionUtils.convertTypedValue(\n\t\t\t\t\t\t\tgetEvaluationContext(), new TypedValue(result), expectedResultType);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState = new ExpressionState(getEvaluationContext(), this.configuration);\n\t\tTypedValue typedResultValue = this.ast.getTypedValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn ExpressionUtils.convertTypedValue(\n\t\t\t\texpressionState.getEvaluationContext(), typedResultValue, expectedResultType);\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#getValue(rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "Object",
    "signature": "public Object getValue(@Nullable Object rootObject)",
    "source_code": "\tpublic @Nullable Object getValue(@Nullable Object rootObject) throws EvaluationException {\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\treturn compiledAst.getValue(rootObject, getEvaluationContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState =\n\t\t\t\tnew ExpressionState(getEvaluationContext(), toTypedValue(rootObject), this.configuration);\n\t\tObject result = this.ast.getValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn result;\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#getValue(rootObject,expectedResultType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject",
      "expectedResultType"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "T",
    "signature": "public T getValue(@Nullable Object rootObject, @Nullable Class<T> expectedResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(@Nullable Object rootObject, @Nullable Class<T> expectedResultType) throws EvaluationException {\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\tObject result = compiledAst.getValue(rootObject, getEvaluationContext());\n\t\t\t\tif (expectedResultType == null) {\n\t\t\t\t\treturn (T)result;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn ExpressionUtils.convertTypedValue(\n\t\t\t\t\t\t\tgetEvaluationContext(), new TypedValue(result), expectedResultType);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState =\n\t\t\t\tnew ExpressionState(getEvaluationContext(), toTypedValue(rootObject), this.configuration);\n\t\tTypedValue typedResultValue = this.ast.getTypedValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn ExpressionUtils.convertTypedValue(\n\t\t\t\texpressionState.getEvaluationContext(), typedResultValue, expectedResultType);\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#getValueTypeDescriptor()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getValueTypeDescriptor()",
    "source_code": "\tpublic @Nullable TypeDescriptor getValueTypeDescriptor() throws EvaluationException {\n\t\treturn getValueTypeDescriptor(getEvaluationContext());\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#getValueTypeDescriptor(context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 410
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getValueTypeDescriptor(EvaluationContext context)",
    "source_code": "\tpublic @Nullable TypeDescriptor getValueTypeDescriptor(EvaluationContext context) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\t\tExpressionState expressionState = new ExpressionState(context, this.configuration);\n\t\treturn this.ast.getValueInternal(expressionState).getTypeDescriptor();\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#getValueTypeDescriptor(context,rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getValueTypeDescriptor(EvaluationContext context, @Nullable Object rootObject)",
    "source_code": "\tpublic @Nullable TypeDescriptor getValueTypeDescriptor(EvaluationContext context, @Nullable Object rootObject)"
  },
  "org.springframework.expression.spel.standard.SpelExpression#getValueTypeDescriptor(rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 403
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getValueTypeDescriptor(@Nullable Object rootObject)",
    "source_code": "\tpublic @Nullable TypeDescriptor getValueTypeDescriptor(@Nullable Object rootObject) throws EvaluationException {\n\t\tExpressionState expressionState =\n\t\t\t\tnew ExpressionState(getEvaluationContext(), toTypedValue(rootObject), this.configuration);\n\t\treturn this.ast.getValueInternal(expressionState).getTypeDescriptor();\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#isWritable(context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "boolean",
    "signature": "public boolean isWritable(EvaluationContext context)",
    "source_code": "\tpublic boolean isWritable(EvaluationContext context) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\t\treturn this.ast.isWritable(new ExpressionState(context, this.configuration));\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#isWritable(context,rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 438
    },
    "return": "boolean",
    "signature": "public boolean isWritable(EvaluationContext context, @Nullable Object rootObject)",
    "source_code": "\tpublic boolean isWritable(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\t\treturn this.ast.isWritable(new ExpressionState(context, toTypedValue(rootObject), this.configuration));\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#isWritable(rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 426
    },
    "return": "boolean",
    "signature": "public boolean isWritable(@Nullable Object rootObject)",
    "source_code": "\tpublic boolean isWritable(@Nullable Object rootObject) throws EvaluationException {\n\t\treturn this.ast.isWritable(\n\t\t\t\tnew ExpressionState(getEvaluationContext(), toTypedValue(rootObject), this.configuration));\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#revertToInterpreted()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Cause an expression to revert to being interpreted if it has been using a compiled\n\t * form. It also resets the compilation attempt failure count (an expression is normally no\n\t * longer considered compilable if it cannot be compiled after 100 attempts).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 546
    },
    "return": "void",
    "signature": "public void revertToInterpreted()",
    "source_code": "\tpublic void revertToInterpreted() {\n\t\tthis.compiledAst = null;\n\t\tthis.interpretedCount.set(0);\n\t\tthis.failedAttempts.set(0);\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#setEvaluationContext(evaluationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the evaluation context that will be used if none is specified on an evaluation call.\n\t * @param evaluationContext the evaluation context to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "evaluationContext"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "void",
    "signature": "public void setEvaluationContext(EvaluationContext evaluationContext)",
    "source_code": "\tpublic void setEvaluationContext(EvaluationContext evaluationContext) {\n\t\tthis.evaluationContext = evaluationContext;\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#setValue(context,rootObject,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 456
    },
    "return": "void",
    "signature": "public void setValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Object value)",
    "source_code": "\tpublic void setValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Object value)"
  },
  "org.springframework.expression.spel.standard.SpelExpression#setValue(context,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 450
    },
    "return": "void",
    "signature": "public void setValue(EvaluationContext context, @Nullable Object value)",
    "source_code": "\tpublic void setValue(EvaluationContext context, @Nullable Object value) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\t\tthis.ast.setValue(new ExpressionState(context, this.configuration), value);\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#setValue(rootObject,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 444
    },
    "return": "void",
    "signature": "public void setValue(@Nullable Object rootObject, @Nullable Object value)",
    "source_code": "\tpublic void setValue(@Nullable Object rootObject, @Nullable Object value) throws EvaluationException {\n\t\tthis.ast.setValue(\n\t\t\t\tnew ExpressionState(getEvaluationContext(), toTypedValue(rootObject), this.configuration), value);\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelExpression#toStringAST()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Produce a string representation of the Abstract Syntax Tree for the expression.\n\t * This should ideally look like the input expression, but properly formatted since any\n\t * unnecessary whitespace will have been discarded during the parse of the expression.\n\t * @return the string representation of the AST\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 565
    },
    "return": "String",
    "signature": "public String toStringAST()",
    "source_code": "\tpublic String toStringAST() {\n\t\treturn this.ast.toStringAST();\n\t}"
  },
  "org.springframework.format.datetime.standard.DurationFormatter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link Formatter} implementation for a JSR-310 {@link Duration},\n * following JSR-310's parsing rules for a Duration by default and\n * supporting additional {@code DurationFormat.Style} styles.\n *\n * @author Juergen Hoeller\n * @since 6.2\n * @see DurationFormatterUtils\n * @see DurationFormat.Style\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class DurationFormatter",
    "source_code": "public class DurationFormatter implements Formatter<Duration> {\n\n\tprivate final DurationFormat.Style style;\n\n\tprivate final DurationFormat.@Nullable Unit defaultUnit;\n\n\t/**\n\t * Create a {@code DurationFormatter} following JSR-310's parsing rules for a Duration\n\t * (the {@link DurationFormat.Style#ISO8601 ISO-8601} style).\n\t */\n\tDurationFormatter() {\n\t\tthis(DurationFormat.Style.ISO8601);\n\t}\n\n\t/**\n\t * Create a {@code DurationFormatter} in a specific {@link DurationFormat.Style}.\n\t * <p>When a unit is needed but cannot be determined (for example, printing a Duration in the\n\t * {@code SIMPLE} style), {@code DurationFormat.Unit#MILLIS} is used.\n\t */\n\tpublic DurationFormatter(DurationFormat.Style style) {\n\t\tthis(style, null);\n\t}\n\n\t/**\n\t * Create a {@code DurationFormatter} in a specific {@link DurationFormat.Style} with an\n\t * optional {@code DurationFormat.Unit}.\n\t * <p>If a {@code defaultUnit} is specified, it may be used in parsing cases when no\n\t * unit is present in the string (provided the style allows for such a case). It will\n\t * also be used as the representation's resolution when printing in the\n\t * {@link DurationFormat.Style#SIMPLE} style. Otherwise, the style defines its default\n\t * unit.\n\t *\n\t * @param style the {@code DurationStyle} to use\n\t * @param defaultUnit the {@code DurationFormat.Unit} to fall back to when parsing and printing\n\t */\n\tpublic DurationFormatter(DurationFormat.Style style, DurationFormat.@Nullable Unit defaultUnit) {\n\t\tthis.style = style;\n\t\tthis.defaultUnit = defaultUnit;\n\t}\n\n\t@Override\n\tpublic Duration parse(String text, Locale locale) throws ParseException {\n\t\tif (this.defaultUnit == null) {\n\t\t\t//delegate to the style\n\t\t\treturn DurationFormatterUtils.parse(text, this.style);\n\t\t}\n\t\treturn DurationFormatterUtils.parse(text, this.style, this.defaultUnit);\n\t}\n\n\t@Override\n\tpublic String print(Duration object, Locale locale) {\n\t\tif (this.defaultUnit == null) {\n\t\t\t//delegate the ultimate of the default unit to the style\n\t\t\treturn DurationFormatterUtils.print(object, this.style);\n\t\t}\n\t\treturn DurationFormatterUtils.print(object, this.style, this.defaultUnit);\n\t}\n\n}"
  },
  "org.springframework.format.datetime.standard.DurationFormatter#parse(text,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "Duration",
    "signature": "public Duration parse(String text, Locale locale)",
    "source_code": "\tpublic Duration parse(String text, Locale locale) throws ParseException {\n\t\tif (this.defaultUnit == null) {\n\t\t\t//delegate to the style\n\t\t\treturn DurationFormatterUtils.parse(text, this.style);\n\t\t}\n\t\treturn DurationFormatterUtils.parse(text, this.style, this.defaultUnit);\n\t}"
  },
  "org.springframework.format.datetime.standard.DurationFormatter#print(object,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "String",
    "signature": "public String print(Duration object, Locale locale)",
    "source_code": "\tpublic String print(Duration object, Locale locale) {\n\t\tif (this.defaultUnit == null) {\n\t\t\t//delegate the ultimate of the default unit to the style\n\t\t\treturn DurationFormatterUtils.print(object, this.style);\n\t\t}\n\t\treturn DurationFormatterUtils.print(object, this.style, this.defaultUnit);\n\t}"
  },
  "org.springframework.format.datetime.standard.TemporalAccessorParser": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link Parser} implementation for a JSR-310 {@link java.time.temporal.TemporalAccessor},\n * using a {@link java.time.format.DateTimeFormatter} (the contextual one, if available).\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Kazuki Shimizu\n * @since 4.0\n * @see DateTimeContextHolder#getFormatter\n * @see java.time.LocalDate#parse(CharSequence, java.time.format.DateTimeFormatter)\n * @see java.time.LocalTime#parse(CharSequence, java.time.format.DateTimeFormatter)\n * @see java.time.LocalDateTime#parse(CharSequence, java.time.format.DateTimeFormatter)\n * @see java.time.ZonedDateTime#parse(CharSequence, java.time.format.DateTimeFormatter)\n * @see java.time.OffsetDateTime#parse(CharSequence, java.time.format.DateTimeFormatter)\n * @see java.time.OffsetTime#parse(CharSequence, java.time.format.DateTimeFormatter)\n * @see java.time.YearMonth#parse(CharSequence, java.time.format.DateTimeFormatter)\n * @see java.time.MonthDay#parse(CharSequence, java.time.format.DateTimeFormatter)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "signature": "public class TemporalAccessorParser",
    "source_code": "public final class TemporalAccessorParser implements Parser<TemporalAccessor> {\n\n\tprivate final Class<? extends TemporalAccessor> temporalAccessorType;\n\n\tprivate final DateTimeFormatter formatter;\n\n\tprivate final String @Nullable [] fallbackPatterns;\n\n\tprivate final @Nullable Object source;\n\n\n\t/**\n\t * Create a new TemporalAccessorParser for the given TemporalAccessor type.\n\t * @param temporalAccessorType the specific TemporalAccessor class\n\t * (LocalDate, LocalTime, LocalDateTime, ZonedDateTime, OffsetDateTime, OffsetTime)\n\t * @param formatter the base DateTimeFormatter instance\n\t */\n\tpublic TemporalAccessorParser(Class<? extends TemporalAccessor> temporalAccessorType, DateTimeFormatter formatter) {\n\t\tthis(temporalAccessorType, formatter, null, null);\n\t}\n\n\tTemporalAccessorParser(Class<? extends TemporalAccessor> temporalAccessorType, DateTimeFormatter formatter,\n\t\t\tString @Nullable [] fallbackPatterns, @Nullable Object source) {\n\n\t\tthis.temporalAccessorType = temporalAccessorType;\n\t\tthis.formatter = formatter;\n\t\tthis.fallbackPatterns = fallbackPatterns;\n\t\tthis.source = source;\n\t}\n\n\n\t@Override\n\tpublic TemporalAccessor parse(String text, Locale locale) throws ParseException {\n\t\ttry {\n\t\t\treturn doParse(text, locale, this.formatter);\n\t\t}\n\t\tcatch (DateTimeParseException ex) {\n\t\t\tif (!ObjectUtils.isEmpty(this.fallbackPatterns)) {\n\t\t\t\tfor (String pattern : this.fallbackPatterns) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDateTimeFormatter fallbackFormatter = DateTimeFormatterUtils.createStrictDateTimeFormatter(pattern);\n\t\t\t\t\t\treturn doParse(text, locale, fallbackFormatter);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (DateTimeParseException ignoredException) {\n\t\t\t\t\t\t// Ignore fallback parsing exceptions since the exception thrown below\n\t\t\t\t\t\t// will include information from the \"source\" if available -- for example,\n\t\t\t\t\t\t// the toString() of a @DateTimeFormat annotation.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Fallback to ISO-based default java.time type parsing\n\t\t\t\ttry {\n\t\t\t\t\treturn defaultParse(text);\n\t\t\t\t}\n\t\t\t\tcatch (DateTimeParseException ignoredException) {\n\t\t\t\t\t// Ignore fallback parsing exception like above\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.source != null) {\n\t\t\t\tthrow new DateTimeParseException(\n\t\t\t\t\t\tString.format(\"Unable to parse date time value \\\"%s\\\" using configuration from %s\", text, this.source),\n\t\t\t\t\t\ttext, ex.getErrorIndex(), ex);\n\t\t\t}\n\t\t\t// else rethrow original exception\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\tprivate TemporalAccessor doParse(String text, Locale locale, DateTimeFormatter formatter) throws DateTimeParseException {\n\t\tDateTimeFormatter formatterToUse = DateTimeContextHolder.getFormatter(formatter, locale);\n\t\tif (Instant.class == this.temporalAccessorType) {\n\t\t\treturn formatterToUse.parse(text, Instant::from);\n\t\t}\n\t\telse if (LocalDate.class == this.temporalAccessorType) {\n\t\t\treturn LocalDate.parse(text, formatterToUse);\n\t\t}\n\t\telse if (LocalTime.class == this.temporalAccessorType) {\n\t\t\treturn LocalTime.parse(text, formatterToUse);\n\t\t}\n\t\telse if (LocalDateTime.class == this.temporalAccessorType) {\n\t\t\treturn LocalDateTime.parse(text, formatterToUse);\n\t\t}\n\t\telse if (ZonedDateTime.class == this.temporalAccessorType) {\n\t\t\treturn ZonedDateTime.parse(text, formatterToUse);\n\t\t}\n\t\telse if (OffsetDateTime.class == this.temporalAccessorType) {\n\t\t\treturn OffsetDateTime.parse(text, formatterToUse);\n\t\t}\n\t\telse if (OffsetTime.class == this.temporalAccessorType) {\n\t\t\treturn OffsetTime.parse(text, formatterToUse);\n\t\t}\n\t\telse if (YearMonth.class == this.temporalAccessorType) {\n\t\t\treturn YearMonth.parse(text, formatterToUse);\n\t\t}\n\t\telse if (MonthDay.class == this.temporalAccessorType) {\n\t\t\treturn MonthDay.parse(text, formatterToUse);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Unsupported TemporalAccessor type: \" + this.temporalAccessorType);\n\t\t}\n\t}\n\n\tprivate TemporalAccessor defaultParse(String text) throws DateTimeParseException {\n\t\tif (Instant.class == this.temporalAccessorType) {\n\t\t\treturn Instant.parse(text);\n\t\t}\n\t\telse if (LocalDate.class == this.temporalAccessorType) {\n\t\t\treturn LocalDate.parse(text);\n\t\t}\n\t\telse if (LocalTime.class == this.temporalAccessorType) {\n\t\t\treturn LocalTime.parse(text);\n\t\t}\n\t\telse if (LocalDateTime.class == this.temporalAccessorType) {\n\t\t\treturn LocalDateTime.parse(text);\n\t\t}\n\t\telse if (ZonedDateTime.class == this.temporalAccessorType) {\n\t\t\treturn ZonedDateTime.parse(text);\n\t\t}\n\t\telse if (OffsetDateTime.class == this.temporalAccessorType) {\n\t\t\treturn OffsetDateTime.parse(text);\n\t\t}\n\t\telse if (OffsetTime.class == this.temporalAccessorType) {\n\t\t\treturn OffsetTime.parse(text);\n\t\t}\n\t\telse if (YearMonth.class == this.temporalAccessorType) {\n\t\t\treturn YearMonth.parse(text);\n\t\t}\n\t\telse if (MonthDay.class == this.temporalAccessorType) {\n\t\t\treturn MonthDay.parse(text);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Unsupported TemporalAccessor type: \" + this.temporalAccessorType);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.format.datetime.standard.TemporalAccessorParser#parse(text,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "TemporalAccessor",
    "signature": "public TemporalAccessor parse(String text, Locale locale)",
    "source_code": "\tpublic TemporalAccessor parse(String text, Locale locale) throws ParseException {\n\t\ttry {\n\t\t\treturn doParse(text, locale, this.formatter);\n\t\t}\n\t\tcatch (DateTimeParseException ex) {\n\t\t\tif (!ObjectUtils.isEmpty(this.fallbackPatterns)) {\n\t\t\t\tfor (String pattern : this.fallbackPatterns) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDateTimeFormatter fallbackFormatter = DateTimeFormatterUtils.createStrictDateTimeFormatter(pattern);\n\t\t\t\t\t\treturn doParse(text, locale, fallbackFormatter);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (DateTimeParseException ignoredException) {\n\t\t\t\t\t\t// Ignore fallback parsing exceptions since the exception thrown below\n\t\t\t\t\t\t// will include information from the \"source\" if available -- for example,\n\t\t\t\t\t\t// the toString() of a @DateTimeFormat annotation.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Fallback to ISO-based default java.time type parsing\n\t\t\t\ttry {\n\t\t\t\t\treturn defaultParse(text);\n\t\t\t\t}\n\t\t\t\tcatch (DateTimeParseException ignoredException) {\n\t\t\t\t\t// Ignore fallback parsing exception like above\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.source != null) {\n\t\t\t\tthrow new DateTimeParseException(\n\t\t\t\t\t\tString.format(\"Unable to parse date time value \\\"%s\\\" using configuration from %s\", text, this.source),\n\t\t\t\t\t\ttext, ex.getErrorIndex(), ex);\n\t\t\t}\n\t\t\t// else rethrow original exception\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.http.APPLICATION_GRAPHQL": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Public constant media type for {@code application/graphql+json}.\n\t * @since 5.3.19\n\t * @see <a href=\"https://github.com/graphql/graphql-over-http/pull/215\">GraphQL over HTTP spec change</a>\n\t * @deprecated as of 6.0.3, in favor of {@link MediaType#APPLICATION_GRAPHQL_RESPONSE}\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "signature": "public MediaType APPLICATION_GRAPHQL",
    "source_code": "\tpublic static final MediaType APPLICATION_GRAPHQL;",
    "type": "MediaType"
  },
  "org.springframework.http.APPLICATION_GRAPHQL_VALUE": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * A String equivalent of {@link MediaType#APPLICATION_GRAPHQL}.\n\t * @since 5.3.19\n\t * @deprecated as of 6.0.3, in favor of {@link MediaType#APPLICATION_GRAPHQL_RESPONSE_VALUE}\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "signature": "public String APPLICATION_GRAPHQL_VALUE",
    "source_code": "\tpublic static final String APPLICATION_GRAPHQL_VALUE = \"application/graphql+json\";",
    "type": "String"
  },
  "org.springframework.http.APPLICATION_JSON_UTF8": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Public constant media type for {@code application/json;charset=UTF-8}.\n\t * @deprecated as of 5.2 in favor of {@link #APPLICATION_JSON}\n\t * since major browsers like Chrome\n\t * <a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=438464\">\n\t * now comply with the specification</a> and interpret correctly UTF-8 special\n\t * characters without requiring a {@code charset=UTF-8} parameter.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "signature": "public MediaType APPLICATION_JSON_UTF8",
    "source_code": "\tpublic static final MediaType APPLICATION_JSON_UTF8;",
    "type": "MediaType"
  },
  "org.springframework.http.APPLICATION_JSON_UTF8_VALUE": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * A String equivalent of {@link MediaType#APPLICATION_JSON_UTF8}.\n\t * @deprecated as of 5.2 in favor of {@link #APPLICATION_JSON_VALUE}\n\t * since major browsers like Chrome\n\t * <a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=438464\">\n\t * now comply with the specification</a> and interpret correctly UTF-8 special\n\t * characters without requiring a {@code charset=UTF-8} parameter.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "signature": "public String APPLICATION_JSON_UTF8_VALUE",
    "source_code": "\tpublic static final String APPLICATION_JSON_UTF8_VALUE = \"application/json;charset=UTF-8\";",
    "type": "String"
  },
  "org.springframework.http.APPLICATION_PROBLEM_JSON_UTF8": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Public constant media type for {@code application/problem+json}.\n\t * @since 5.0\n\t * @see <a href=\"https://www.iana.org/assignments/media-types/application/problem+json\">\n\t *     Problem Details for HTTP APIs, 6.1. application/problem+json</a>\n\t * @deprecated as of 5.2 in favor of {@link #APPLICATION_PROBLEM_JSON}\n\t * since major browsers like Chrome\n\t * <a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=438464\">\n\t * now comply with the specification</a> and interpret correctly UTF-8 special\n\t * characters without requiring a {@code charset=UTF-8} parameter.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "signature": "public MediaType APPLICATION_PROBLEM_JSON_UTF8",
    "source_code": "\tpublic static final MediaType APPLICATION_PROBLEM_JSON_UTF8;",
    "type": "MediaType"
  },
  "org.springframework.http.APPLICATION_PROBLEM_JSON_UTF8_VALUE": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * A String equivalent of {@link MediaType#APPLICATION_PROBLEM_JSON_UTF8}.\n\t * @since 5.0\n\t * @deprecated as of 5.2 in favor of {@link #APPLICATION_PROBLEM_JSON_VALUE}\n\t * since major browsers like Chrome\n\t * <a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=438464\">\n\t * now comply with the specification</a> and interpret correctly UTF-8 special\n\t * characters without requiring a {@code charset=UTF-8} parameter.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "signature": "public String APPLICATION_PROBLEM_JSON_UTF8_VALUE",
    "source_code": "\tpublic static final String APPLICATION_PROBLEM_JSON_UTF8_VALUE = \"application/problem+json;charset=UTF-8\";",
    "type": "String"
  },
  "org.springframework.http.APPLICATION_STREAM_JSON": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Public constant media type for {@code application/stream+json}.\n\t * @since 5.0\n\t * @deprecated as of 5.3, see notice on {@link #APPLICATION_STREAM_JSON_VALUE}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 285
    },
    "signature": "public MediaType APPLICATION_STREAM_JSON",
    "source_code": "\tpublic static final MediaType APPLICATION_STREAM_JSON;",
    "type": "MediaType"
  },
  "org.springframework.http.APPLICATION_STREAM_JSON_VALUE": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * A String equivalent of {@link MediaType#APPLICATION_STREAM_JSON}.\n\t * @since 5.0\n\t * @deprecated as of 5.3 since it originates from the W3C Activity Streams\n\t * specification which has a more specific purpose and has been since\n\t * replaced with a different mime type. Use {@link #APPLICATION_NDJSON} as\n\t * a replacement or any other line-delimited JSON format (for example, JSON Lines,\n\t * JSON Text Sequences).\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "signature": "public String APPLICATION_STREAM_JSON_VALUE",
    "source_code": "\tpublic static final String APPLICATION_STREAM_JSON_VALUE = \"application/stream+json\";",
    "type": "String"
  },
  "org.springframework.http.ContentDisposition#creationDate(creationDate)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "creationDate"
    ],
    "position": {
      "column": 1,
      "line": 818
    },
    "return": "Builder",
    "signature": "public Builder creationDate(@Nullable ZonedDateTime creationDate)",
    "source_code": "\t\tpublic Builder creationDate(@Nullable ZonedDateTime creationDate) {\n\t\t\tthis.creationDate = creationDate;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.ContentDisposition#getCreationDate()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the value of the {@literal creation-date} parameter, or {@code null} if not defined.\n\t * @deprecated since 5.2.3 as per\n\t * <a href=\"https://tools.ietf.org/html/rfc6266#appendix-B\">RFC 6266, Appendix B</a>,\n\t * to be removed in a future release.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "ZonedDateTime",
    "signature": "public ZonedDateTime getCreationDate()",
    "source_code": "\tpublic ZonedDateTime getCreationDate() {\n\t\treturn this.creationDate;\n\t}"
  },
  "org.springframework.http.ContentDisposition#getModificationDate()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the value of the {@literal modification-date} parameter, or {@code null} if not defined.\n\t * @deprecated since 5.2.3 as per\n\t * <a href=\"https://tools.ietf.org/html/rfc6266#appendix-B\">RFC 6266, Appendix B</a>,\n\t * to be removed in a future release.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "ZonedDateTime",
    "signature": "public ZonedDateTime getModificationDate()",
    "source_code": "\tpublic ZonedDateTime getModificationDate() {\n\t\treturn this.modificationDate;\n\t}"
  },
  "org.springframework.http.ContentDisposition#getReadDate()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the value of the {@literal read-date} parameter, or {@code null} if not defined.\n\t * @deprecated since 5.2.3 as per\n\t * <a href=\"https://tools.ietf.org/html/rfc6266#appendix-B\">RFC 6266, Appendix B</a>,\n\t * to be removed in a future release.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "ZonedDateTime",
    "signature": "public ZonedDateTime getReadDate()",
    "source_code": "\tpublic ZonedDateTime getReadDate() {\n\t\treturn this.readDate;\n\t}"
  },
  "org.springframework.http.ContentDisposition#getSize()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the value of the {@literal size} parameter, or {@code null} if not defined.\n\t * @deprecated since 5.2.3 as per\n\t * <a href=\"https://tools.ietf.org/html/rfc6266#appendix-B\">RFC 6266, Appendix B</a>,\n\t * to be removed in a future release.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "Long",
    "signature": "public Long getSize()",
    "source_code": "\tpublic Long getSize() {\n\t\treturn this.size;\n\t}"
  },
  "org.springframework.http.ContentDisposition#modificationDate(modificationDate)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "modificationDate"
    ],
    "position": {
      "column": 1,
      "line": 825
    },
    "return": "Builder",
    "signature": "public Builder modificationDate(@Nullable ZonedDateTime modificationDate)",
    "source_code": "\t\tpublic Builder modificationDate(@Nullable ZonedDateTime modificationDate) {\n\t\t\tthis.modificationDate = modificationDate;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.ContentDisposition#readDate(readDate)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readDate"
    ],
    "position": {
      "column": 1,
      "line": 832
    },
    "return": "Builder",
    "signature": "public Builder readDate(@Nullable ZonedDateTime readDate)",
    "source_code": "\t\tpublic Builder readDate(@Nullable ZonedDateTime readDate) {\n\t\t\tthis.readDate = readDate;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.ContentDisposition#size(size)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "size"
    ],
    "position": {
      "column": 1,
      "line": 811
    },
    "return": "Builder",
    "signature": "public Builder size(@Nullable Long size)",
    "source_code": "\t\tpublic Builder size(@Nullable Long size) {\n\t\t\tthis.size = size;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.HttpHeaders#addAll(MultiValueMap<String,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1771
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tthis.headers.addAll(values);\n\t}"
  },
  "org.springframework.http.HttpHeaders#addAll(headerName,headerValues)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add all the given values under the given name.\n\t * <p>As values are represented as a {@code List}, duplicate values can be\n\t * introduced. See {@link #put(String, List)} to replace the list of values\n\t * instead.\n\t * @param headerName the header name\n\t * @param headerValues the values to add\n\t * @see #put(String, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 1789
    },
    "return": "void",
    "signature": "public void addAll(String headerName, List<? extends String> headerValues)",
    "source_code": "\tpublic void addAll(String headerName, List<? extends String> headerValues) {\n\t\tthis.headers.addAll(headerName, headerValues);\n\t}"
  },
  "org.springframework.http.HttpHeaders#addAll(headers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add all the values of the given {@code HttpHeaders} to the current header.\n\t * <p>As values are represented as a {@code List}, duplicate values can be\n\t * introduced. See {@link #putAll(HttpHeaders)} to replace the list of\n\t * values of each individual header name instead.\n\t * @param headers the headers to add\n\t * @since 7.0\n\t * @see #putAll(HttpHeaders)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 1802
    },
    "return": "void",
    "signature": "public void addAll(HttpHeaders headers)",
    "source_code": "\tpublic void addAll(HttpHeaders headers) {\n\t\tthis.headers.addAll(headers.headers);\n\t}"
  },
  "org.springframework.http.HttpHeaders#addAll(key,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1766
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tthis.headers.addAll(key, values);\n\t}"
  },
  "org.springframework.http.HttpHeaders#asMultiValueMap()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return this HttpHeaders as a {@code MultiValueMap} with the full list\n\t * of values for each header name.\n\t * <p>Note that some backing server headers implementations can store header\n\t * names in a case-sensitive manner, which will lead to duplicates during\n\t * iteration in methods like {@code entrySet()}, where multiple occurrences\n\t * of a header name can surface depending on letter casing but each such\n\t * entry has the full {@code List} of values.\n\t * @return a MultiValueMap representation of these headers\n\t * @since 7.0\n\t * @deprecated This method is provided for backward compatibility with APIs\n\t * that would only accept maps. Generally avoid using HttpHeaders as a Map\n\t * or MultiValueMap.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1874
    },
    "return": "String>",
    "signature": "public String> asMultiValueMap()",
    "source_code": "\tpublic MultiValueMap<String, String> asMultiValueMap() {\n\t\treturn this.headers;\n\t}"
  },
  "org.springframework.http.HttpHeaders#contains(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 2195
    },
    "return": "boolean",
    "signature": "public boolean contains(Object o)",
    "source_code": "\t\tpublic boolean contains(Object o) {\n\t\t\treturn this.headers.containsKey(o);\n\t\t}"
  },
  "org.springframework.http.HttpHeaders#containsHeader(headerName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@code true} if this HttpHeaders contains an entry for the\n\t * given header name.\n\t * @param headerName the header name\n\t * @since 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName"
    ],
    "position": {
      "column": 1,
      "line": 1893
    },
    "return": "boolean",
    "signature": "public boolean containsHeader(String headerName)",
    "source_code": "\tpublic boolean containsHeader(String headerName) {\n\t\treturn this.headers.containsKey(headerName);\n\t}"
  },
  "org.springframework.http.HttpHeaders#containsHeaderValue(headerName,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@code true} if this HttpHeaders contains the given header and\n\t * its list of values contains the given value.\n\t * @param headerName the header name\n\t * @param value the value expected to be in the list of values\n\t * @since 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1915
    },
    "return": "boolean",
    "signature": "public boolean containsHeaderValue(String headerName, String value)",
    "source_code": "\tpublic boolean containsHeaderValue(String headerName, String value) {\n\t\tfinal List<String> values = this.headers.get(headerName);\n\t\tif (values == null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn values.contains(value);\n\t}"
  },
  "org.springframework.http.HttpHeaders#containsKey(key)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 1811
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn this.headers.containsKey(key);\n\t}"
  },
  "org.springframework.http.HttpHeaders#containsValue(value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1816
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn this.headers.containsValue(value);\n\t}"
  },
  "org.springframework.http.HttpHeaders#entrySet()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link Set} views of header entries, reconstructed from\n\t * iterating over the {@link #keySet()}. This can include duplicate entries\n\t * if multiple casing variants of a given header name are tracked, see\n\t * {@link HttpHeaders class level javadoc}.\n\t * @see #headerSet()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1891
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> entrySet()",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn this.headers.entrySet();\n\t}"
  },
  "org.springframework.http.HttpHeaders#equals(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 2320
    },
    "return": "boolean",
    "signature": "public boolean equals(Object o)",
    "source_code": "\t\t\tpublic boolean equals(Object o) {\n\t\t\t\tif (this == o) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (!(o instanceof Map.Entry<?,?> that)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn ObjectUtils.nullSafeEquals(getKey(), that.getKey()) && ObjectUtils.nullSafeEquals(getValue(), that.getValue());\n\t\t\t}"
  },
  "org.springframework.http.HttpHeaders#get(headerName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the list of values associated with the given header name, or null.\n\t * <p>To ensure support for double-quoted values, see also\n\t * {@link #getValuesAsList(String)}.\n\t * @param headerName the header name\n\t * @since 7.0\n\t * @see #getValuesAsList(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName"
    ],
    "position": {
      "column": 1,
      "line": 1931
    },
    "return": "List<String>",
    "signature": "public List<String> get(String headerName)",
    "source_code": "\tpublic @Nullable List<String> get(String headerName) {\n\t\treturn this.headers.get(headerName);\n\t}"
  },
  "org.springframework.http.HttpHeaders#get(key)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 1822
    },
    "return": "List<String>",
    "signature": "public List<String> get(Object key)",
    "source_code": "\tpublic List<String> get(Object key) {\n\t\treturn this.headers.get(key);\n\t}"
  },
  "org.springframework.http.HttpHeaders#getOrDefault(headerName,defaultValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the list of header values for the given header name, or the given\n\t * default list of values if the header is not present.\n\t * @param headerName the header name\n\t * @param defaultValue the fallback list if header is not present\n\t * @return the list of header values, or a default list of values\n\t * @since 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "defaultValue"
    ],
    "position": {
      "column": 1,
      "line": 513
    },
    "return": "List<String>",
    "signature": "public List<String> getOrDefault(String headerName, List<String> defaultValue)",
    "source_code": "\tpublic List<String> getOrDefault(String headerName, List<String> defaultValue) {\n\t\tList<String> values = get(headerName);\n\t\treturn (values != null ? values : defaultValue);\n\t}"
  },
  "org.springframework.http.HttpHeaders#hasHeaderValues(headerName,values)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@code true} if this HttpHeaders contains exactly the given list\n\t * of values for the given header name.\n\t * @param headerName the header name\n\t * @param values the expected list of values\n\t * @since 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1904
    },
    "return": "boolean",
    "signature": "public boolean hasHeaderValues(String headerName, List<String> values)",
    "source_code": "\tpublic boolean hasHeaderValues(String headerName, List<String> values) {\n\t\treturn ObjectUtils.nullSafeEquals(this.headers.get(headerName), values);\n\t}"
  },
  "org.springframework.http.HttpHeaders#headerNames()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the set of header names. Both {@link Set#remove(Object)} and\n\t * {@link Set#clear()} operations are supported and mutate the headers.\n\t * <p>This collection is guaranteed to contain only one casing variant\n\t * of each header name even if the backing structure stores multiple casing\n\t * variants of names. The first encountered variant is the one that is\n\t * retained.\n\t * @return a {@code Set} of all the headers names\n\t * @since 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 2039
    },
    "return": "Set<String>",
    "signature": "public Set<String> headerNames()",
    "source_code": "\tpublic Set<String> headerNames() {\n\t\treturn new CaseInsensitiveHeaderNameSet(this.headers);\n\t}"
  },
  "org.springframework.http.HttpHeaders#iterator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 2260
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> iterator()",
    "source_code": "\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\treturn new CaseInsensitiveIterator(this.nameSet.iterator());\n\t\t}"
  },
  "org.springframework.http.HttpHeaders#keySet()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link Set} view of header names. This can include multiple\n\t * casing variants of a given header name, see\n\t * {@link HttpHeaders class level javadoc}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1868
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\tpublic Set<String> keySet() {\n\t\treturn this.headers.keySet();\n\t}"
  },
  "org.springframework.http.HttpHeaders#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 2283
    },
    "return": "List<String>>",
    "signature": "public List<String>> next()",
    "source_code": "\t\t\tpublic Entry<String, List<String>> next() {\n\t\t\t\treturn new CaseInsensitiveEntrySet.CaseInsensitiveEntry(this.namesIterator.next());\n\t\t\t}"
  },
  "org.springframework.http.HttpHeaders#put(headerName,headerValues)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the list of values associated with the given header name. Returns the\n\t * previous list of values, or {@code null} if the header was not present.\n\t * @param headerName the header name\n\t * @param headerValues the new values\n\t * @return the old values for the given header name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 1942
    },
    "return": "List<String>",
    "signature": "public List<String> put(String headerName, List<String> headerValues)",
    "source_code": "\tpublic @Nullable List<String> put(String headerName, List<String> headerValues) {\n\t\treturn this.headers.put(headerName, headerValues);\n\t}"
  },
  "org.springframework.http.HttpHeaders#put(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1827
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\treturn this.headers.put(key, value);\n\t}"
  },
  "org.springframework.http.HttpHeaders#putAll(String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Put all the entries from the given {@code MultiValueMap} into this\n\t * HttpHeaders.\n\t * @param headers the given headers\n\t * @see #put(String, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 1974
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> headers)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> headers) {\n\t\tthis.headers.putAll(headers);\n\t}"
  },
  "org.springframework.http.HttpHeaders#putAll(String,map)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 1837
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tthis.headers.putAll(map);\n\t}"
  },
  "org.springframework.http.HttpHeaders#putAll(headers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Put all the entries from the given HttpHeaders into this HttpHeaders.\n\t * @param headers the given headers\n\t * @since 7.0\n\t * @see #put(String, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 1964
    },
    "return": "void",
    "signature": "public void putAll(HttpHeaders headers)",
    "source_code": "\tpublic void putAll(HttpHeaders headers) {\n\t\tthis.headers.putAll(headers.headers);\n\t}"
  },
  "org.springframework.http.HttpHeaders#putIfAbsent(headerName,headerValues)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set header values for the given header name if that header name isn't\n\t * already present in this HttpHeaders and return {@code null}. If the\n\t * header is already present, returns the associated value list instead.\n\t * @param headerName the header name\n\t * @param headerValues the header values to set if header is not present\n\t * @return the previous value or {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 1954
    },
    "return": "List<String>",
    "signature": "public List<String> putIfAbsent(String headerName, List<String> headerValues)",
    "source_code": "\tpublic @Nullable List<String> putIfAbsent(String headerName, List<String> headerValues) {\n\t\treturn this.headers.putIfAbsent(headerName, headerValues);\n\t}"
  },
  "org.springframework.http.HttpHeaders#putIfAbsent(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1847
    },
    "return": "List<String>",
    "signature": "public List<String> putIfAbsent(String key, List<String> value)",
    "source_code": "\tpublic List<String> putIfAbsent(String key, List<String> value) {\n\t\treturn this.headers.putIfAbsent(key, value);\n\t}"
  },
  "org.springframework.http.HttpHeaders#remove(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 2200
    },
    "return": "boolean",
    "signature": "public boolean remove(Object o)",
    "source_code": "\t\tpublic boolean remove(Object o) {\n\t\t\treturn this.headers.remove(o) != null && this.deduplicatedNames.remove(o) != null;\n\t\t}"
  },
  "org.springframework.http.HttpHeaders#values()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link Collection} view of all the header values, reconstructed\n\t * from iterating over the {@link #keySet()}. This can include duplicates if\n\t * multiple casing variants of a given header name are tracked, see\n\t * {@link HttpHeaders class level javadoc}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1879
    },
    "return": "Collection<List<String>>",
    "signature": "public Collection<List<String>> values()",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.values();\n\t}"
  },
  "org.springframework.http.HttpHeaders#writableHttpHeaders(headers)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Remove any read-only wrapper that may have been previously applied around\n\t * the given headers via {@link #readOnlyHttpHeaders(HttpHeaders)}.\n\t * <p>Once the writable instance is mutated, the read-only instance is likely\n\t * to be out of sync and should be discarded.\n\t * @param headers the headers to expose\n\t * @return a writable variant of the headers, or the original headers as-is\n\t * @since 5.1.1\n\t * @deprecated as of 6.2 in favor of {@link #HttpHeaders(MultiValueMap)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 1975
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders writableHttpHeaders(HttpHeaders headers)",
    "source_code": "\tpublic static HttpHeaders writableHttpHeaders(HttpHeaders headers) {\n\t\treturn new HttpHeaders(headers);\n\t}"
  },
  "org.springframework.http.MediaType#compareParameters(mediaType1,mediaType2)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mediaType1",
      "mediaType2"
    ],
    "position": {
      "column": 1,
      "line": 976
    },
    "return": "int",
    "signature": "protected int compareParameters(MediaType mediaType1, MediaType mediaType2)",
    "source_code": "\t\tprotected int compareParameters(MediaType mediaType1, MediaType mediaType2) {\n\t\t\tdouble quality1 = mediaType1.getQualityValue();\n\t\t\tdouble quality2 = mediaType2.getQualityValue();\n\t\t\tint qualityComparison = Double.compare(quality2, quality1);\n\t\t\tif (qualityComparison != 0) {\n\t\t\t\treturn qualityComparison;  // audio/*;q=0.7 < audio/*;q=0.3\n\t\t\t}\n\t\t\treturn super.compareParameters(mediaType1, mediaType2);\n\t\t}"
  },
  "org.springframework.http.MediaType#sortByQualityValue(mediaTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Sorts the given list of {@code MediaType} objects by quality value.\n\t * <p>Given two media types:\n\t * <ol>\n\t * <li>if the two media types have different {@linkplain #getQualityValue() quality value}, then the media type\n\t * with the highest quality value is ordered before the other.</li>\n\t * <li>if either media type has a {@linkplain #isWildcardType() wildcard type}, then the media type without the\n\t * wildcard is ordered before the other.</li>\n\t * <li>if the two media types have different {@linkplain #getType() types}, then they are considered equal and\n\t * remain their current order.</li>\n\t * <li>if either media type has a {@linkplain #isWildcardSubtype() wildcard subtype}, then the media type without\n\t * the wildcard is sorted before the other.</li>\n\t * <li>if the two media types have different {@linkplain #getSubtype() subtypes}, then they are considered equal\n\t * and remain their current order.</li>\n\t * <li>if the two media types have a different amount of {@linkplain #getParameter(String) parameters}, then the\n\t * media type with the most parameters is ordered before the other.</li>\n\t * </ol>\n\t * @param mediaTypes the list of media types to be sorted\n\t * @see #getQualityValue()\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 906
    },
    "return": "void",
    "signature": "public void sortByQualityValue(List<MediaType> mediaTypes)",
    "source_code": "\tpublic static void sortByQualityValue(List<MediaType> mediaTypes) {\n\t\tAssert.notNull(mediaTypes, \"'mediaTypes' must not be null\");\n\t\tif (mediaTypes.size() > 1) {\n\t\t\tmediaTypes.sort(QUALITY_VALUE_COMPARATOR);\n\t\t}\n\t}"
  },
  "org.springframework.http.MediaType#sortBySpecificity(mediaTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Sorts the given list of {@code MediaType} objects by specificity.\n\t * <p>Given two media types:\n\t * <ol>\n\t * <li>if either media type has a {@linkplain #isWildcardType() wildcard type}, then the media type without the\n\t * wildcard is ordered before the other.</li>\n\t * <li>if the two media types have different {@linkplain #getType() types}, then they are considered equal and\n\t * remain their current order.</li>\n\t * <li>if either media type has a {@linkplain #isWildcardSubtype() wildcard subtype}, then the media type without\n\t * the wildcard is sorted before the other.</li>\n\t * <li>if the two media types have different {@linkplain #getSubtype() subtypes}, then they are considered equal\n\t * and remain their current order.</li>\n\t * <li>if the two media types have different {@linkplain #getQualityValue() quality value}, then the media type\n\t * with the highest quality value is ordered before the other.</li>\n\t * <li>if the two media types have a different amount of {@linkplain #getParameter(String) parameters}, then the\n\t * media type with the most parameters is ordered before the other.</li>\n\t * </ol>\n\t * <p>For example:\n\t * <blockquote>audio/basic &lt; audio/* &lt; *&#047;*</blockquote>\n\t * <blockquote>audio/* &lt; audio/*;q=0.7; audio/*;q=0.3</blockquote>\n\t * <blockquote>audio/basic;level=1 &lt; audio/basic</blockquote>\n\t * <blockquote>audio/basic == text/html</blockquote>\n\t * <blockquote>audio/basic == audio/wave</blockquote>\n\t * @param mediaTypes the list of media types to be sorted\n\t * @deprecated as of 6.0, in favor of {@link MimeTypeUtils#sortBySpecificity(List)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 877
    },
    "return": "void",
    "signature": "public void sortBySpecificity(List<MediaType> mediaTypes)",
    "source_code": "\tpublic static void sortBySpecificity(List<MediaType> mediaTypes) {\n\t\tAssert.notNull(mediaTypes, \"'mediaTypes' must not be null\");\n\t\tif (mediaTypes.size() > 1) {\n\t\t\tmediaTypes.sort(SPECIFICITY_COMPARATOR);\n\t\t}\n\t}"
  },
  "org.springframework.http.MediaType#sortBySpecificityAndQuality(mediaTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Sorts the given list of {@code MediaType} objects by specificity as the\n\t * primary criteria and quality value the secondary.\n\t * @deprecated as of 6.0, in favor of {@link MimeTypeUtils#sortBySpecificity(List)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 919
    },
    "return": "void",
    "signature": "public void sortBySpecificityAndQuality(List<MediaType> mediaTypes)",
    "source_code": "\tpublic static void sortBySpecificityAndQuality(List<MediaType> mediaTypes) {\n\t\tAssert.notNull(mediaTypes, \"'mediaTypes' must not be null\");\n\t\tif (mediaTypes.size() > 1) {\n\t\t\tmediaTypes.sort(MediaType.SPECIFICITY_COMPARATOR.thenComparing(MediaType.QUALITY_VALUE_COMPARATOR));\n\t\t}\n\t}"
  },
  "org.springframework.http.QUALITY_VALUE_COMPARATOR": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Comparator used by {@link #sortByQualityValue(List)}.\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 932
    },
    "signature": "public Comparator<MediaType> QUALITY_VALUE_COMPARATOR",
    "source_code": "\tpublic static final Comparator<MediaType> QUALITY_VALUE_COMPARATOR = (mediaType1, mediaType2) -> {\n\t\tdouble quality1 = mediaType1.getQualityValue();\n\t\tdouble quality2 = mediaType2.getQualityValue();\n\t\tint qualityComparison = Double.compare(quality2, quality1);\n\t\tif (qualityComparison != 0) {\n\t\t\treturn qualityComparison;  // audio/*;q=0.7 < audio/*;q=0.3\n\t\t}\n\t\telse if (mediaType1.isWildcardType() && !mediaType2.isWildcardType()) {  // */* < audio/*\n\t\t\treturn 1;\n\t\t}\n\t\telse if (mediaType2.isWildcardType() && !mediaType1.isWildcardType()) {  // audio/* > */*\n\t\t\treturn -1;\n\t\t}\n\t\telse if (!mediaType1.getType().equals(mediaType2.getType())) {  // audio/basic == text/html\n\t\t\treturn 0;\n\t\t}\n\t\telse {  // mediaType1.getType().equals(mediaType2.getType())\n\t\t\tif (mediaType1.isWildcardSubtype() && !mediaType2.isWildcardSubtype()) {  // audio/* < audio/basic\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if (mediaType2.isWildcardSubtype() && !mediaType1.isWildcardSubtype()) {  // audio/basic > audio/*\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (!mediaType1.getSubtype().equals(mediaType2.getSubtype())) {  // audio/basic == audio/wave\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint paramsSize1 = mediaType1.getParameters().size();\n\t\t\t\tint paramsSize2 = mediaType2.getParameters().size();\n\t\t\t\treturn Integer.compare(paramsSize2, paramsSize1);  // audio/basic;level=1 < audio/basic\n\t\t\t}\n\t\t}\n\t};",
    "type": "Comparator<MediaType>"
  },
  "org.springframework.http.RequestEntity#getVars()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 722
    },
    "return": "Object[]",
    "signature": "public Object[] getVars()",
    "source_code": "\t\tpublic Object[] getVars() {\n\t\t\treturn this.uriVarsArray;\n\t\t}"
  },
  "org.springframework.http.ResponseEntity#getStatusCodeValue()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HTTP status code of the response.\n\t * @return the HTTP status as an int value\n\t * @since 4.3\n\t * @deprecated as of 6.0, in favor of {@link #getStatusCode()}; scheduled\n\t * for removal in 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "int",
    "signature": "public int getStatusCodeValue()",
    "source_code": "\tpublic int getStatusCodeValue() {\n\t\treturn getStatusCode().value();\n\t}"
  },
  "org.springframework.http.SPECIFICITY_COMPARATOR": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Comparator used by {@link #sortBySpecificity(List)}.\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 973
    },
    "signature": "public Comparator<MediaType> SPECIFICITY_COMPARATOR",
    "source_code": "\tpublic static final Comparator<MediaType> SPECIFICITY_COMPARATOR = new SpecificityComparator<>() {\n\n\t\t@Override\n\t\tprotected int compareParameters(MediaType mediaType1, MediaType mediaType2) {\n\t\t\tdouble quality1 = mediaType1.getQualityValue();\n\t\t\tdouble quality2 = mediaType2.getQualityValue();\n\t\t\tint qualityComparison = Double.compare(quality2, quality1);\n\t\t\tif (qualityComparison != 0) {\n\t\t\t\treturn qualityComparison;  // audio/*;q=0.7 < audio/*;q=0.3\n\t\t\t}\n\t\t\treturn super.compareParameters(mediaType1, mediaType2);\n\t\t}\n\t};",
    "type": "Comparator<MediaType>"
  },
  "org.springframework.http.client.<unknown>#execute(request,body)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "body"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "ClientHttpResponse",
    "signature": "public ClientHttpResponse execute(HttpRequest request, byte[] body)",
    "source_code": "\t\tpublic ClientHttpResponse execute(HttpRequest request, byte[] body) throws IOException {\n\t\t\tif (this.iterator.hasNext()) {\n\t\t\t\tClientHttpRequestInterceptor nextInterceptor = this.iterator.next();\n\t\t\t\treturn nextInterceptor.intercept(request, body, this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tHttpMethod method = request.getMethod();\n\t\t\t\tClientHttpRequest delegate = requestFactory.createRequest(request.getURI(), method);\n\t\t\t\trequest.getHeaders().forEach((key, value) -> delegate.getHeaders().addAll(key, value));\n\t\t\t\trequest.getAttributes().forEach((key, value) -> delegate.getAttributes().put(key, value));\n\t\t\t\tif (body.length > 0) {\n\t\t\t\t\tlong contentLength = delegate.getHeaders().getContentLength();\n\t\t\t\t\tif (contentLength > -1 && contentLength != body.length) {\n\t\t\t\t\t\tdelegate.getHeaders().setContentLength(body.length);\n\t\t\t\t\t}\n\t\t\t\t\tif (delegate instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\t\t\t\tstreamingOutputMessage.setBody(new StreamingHttpOutputMessage.Body() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void writeTo(OutputStream outputStream) throws IOException {\n\t\t\t\t\t\t\t\tStreamUtils.copy(body, outputStream);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic boolean repeatable() {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tStreamUtils.copy(body, delegate.getBody());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn delegate.execute();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.client.<unknown>#executeInternal(headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "return": "ClientHttpResponse",
    "signature": "protected ClientHttpResponse executeInternal(HttpHeaders headers)",
    "source_code": "\tprotected ClientHttpResponse executeInternal(HttpHeaders headers) throws IOException {\n\t\tbyte[] bytes = this.bufferedOutput.toByteArrayUnsafe();\n\t\tif (headers.getContentLength() < 0) {\n\t\t\theaders.setContentLength(bytes.length);\n\t\t}\n\t\tClientHttpResponse result = executeInternal(headers, bytes);\n\t\tthis.bufferedOutput.reset();\n\t\treturn result;\n\t}"
  },
  "org.springframework.http.client.<unknown>#executeWithRequest(request,bufferedOutput,bufferResponse)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute with the given request and body.\n\t * @param request the request to execute with\n\t * @param bufferedOutput the body to write\n\t * @param bufferResponse whether to buffer the response\n\t * @return the resulting response\n\t * @throws IOException in case of I/O errors from execution\n\t * @since 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "bufferedOutput",
      "bufferResponse"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "ClientHttpResponse",
    "signature": "protected ClientHttpResponse executeWithRequest(ClientHttpRequest request, byte[] bufferedOutput, boolean bufferResponse)",
    "source_code": "\tprotected ClientHttpResponse executeWithRequest("
  },
  "org.springframework.http.client.<unknown>#getBodyInternal(headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "return": "OutputStream",
    "signature": "protected OutputStream getBodyInternal(HttpHeaders headers)",
    "source_code": "\tprotected OutputStream getBodyInternal(HttpHeaders headers) throws IOException {\n\t\treturn this.bufferedOutput;\n\t}"
  },
  "org.springframework.http.client.<unknown>#onComplete()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "void",
    "signature": "public void onComplete()",
    "source_code": "\tpublic void onComplete() {\n\t\tif (this.done) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.done = true;\n\n\t\tif (addWork() == 0) {\n\t\t\tresume();\n\t\t}\n\t}"
  },
  "org.springframework.http.client.<unknown>#onError(throwable)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "throwable"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "public void onError(Throwable throwable)",
    "source_code": "\tpublic void onError(Throwable throwable) {\n\t\tif (this.done) {\n\t\t\treturn;\n\t\t}\n\t\tthis.error = throwable;\n\t\tthis.done = true;\n\n\t\tif (addWork() == 0) {\n\t\t\tresume();\n\t\t}\n\t}"
  },
  "org.springframework.http.client.<unknown>#onNext(buffer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "buffer"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void onNext(T buffer)",
    "source_code": "\tpublic void onNext(T buffer) {\n\t\tAssert.notNull(buffer, \"Buffer must not be null\");\n\n\t\tif (this.done) {\n\t\t\tdiscard(buffer);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.queue.offer(buffer)) {\n\t\t\tdiscard(buffer);\n\t\t\tthis.error = new RuntimeException(\"Buffer overflow\");\n\t\t\tthis.done = true;\n\t\t}\n\n\t\tint previousWorkState = addWork();\n\t\tif (previousWorkState == Integer.MIN_VALUE) {\n\t\t\tT value = this.queue.poll();\n\t\t\tif (value != null) {\n\t\t\t\tdiscard(value);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (previousWorkState == 0) {\n\t\t\tresume();\n\t\t}\n\t}"
  },
  "org.springframework.http.client.<unknown>#onSubscribe(subscription)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void onSubscribe(Flow.Subscription subscription)",
    "source_code": "\tpublic void onSubscribe(Flow.Subscription subscription) {\n\t\tif (this.subscription != null) {\n\t\t\tsubscription.cancel();\n\t\t\treturn;\n\t\t}\n\n\t\tthis.subscription = subscription;\n\t\tsubscription.request(this.prefetch == Integer.MAX_VALUE ? Long.MAX_VALUE : this.prefetch);\n\t}"
  },
  "org.springframework.http.client.<unknown>#read()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance.\n\t * @param mapper function to transform byte buffers to {@code byte[]};\n\t * the function should also release the byte buffer if necessary.\n\t * @param onDiscardHandler a callback to release byte buffers if the\n\t * {@link InputStream} is closed prematurely.\n\t * @param demand the number of buffers to request initially, and buffer\n\t * internally on an ongoing basis.\n\t */\n\tSubscriberInputStream(Function<T, byte[]> mapper, Consumer<T> onDiscardHandler, int demand) {\n\t\tAssert.notNull(mapper, \"mapper must not be null\");\n\t\tAssert.notNull(onDiscardHandler, \"onDiscardHandler must not be null\");\n\t\tAssert.isTrue(demand > 0, \"demand must be greater than 0\");\n\n\t\tthis.mapper = mapper;\n\t\tthis.onDiscardHandler = onDiscardHandler;\n\t\tthis.prefetch = demand;\n\t\tthis.limit = (demand == Integer.MAX_VALUE ? Integer.MAX_VALUE : demand - (demand >> 2));\n\t\tthis.queue = new ArrayBlockingQueue<>(demand);\n\t\tthis.lock = new ReentrantLock(false);\n\t}\n\n\n\t@Override\n\tpublic void onSubscribe(Flow.Subscription subscription) {\n\t\tif (this.subscription != null) {\n\t\t\tsubscription.cancel();\n\t\t\treturn;\n\t\t}\n\n\t\tthis.subscription = subscription;\n\t\tsubscription.request(this.prefetch == Integer.MAX_VALUE ? Long.MAX_VALUE : this.prefetch);\n\t}\n\n\t@Override\n\tpublic void onNext(T buffer) {\n\t\tAssert.notNull(buffer, \"Buffer must not be null\");\n\n\t\tif (this.done) {\n\t\t\tdiscard(buffer);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.queue.offer(buffer)) {\n\t\t\tdiscard(buffer);\n\t\t\tthis.error = new RuntimeException(\"Buffer overflow\");\n\t\t\tthis.done = true;\n\t\t}\n\n\t\tint previousWorkState = addWork();\n\t\tif (previousWorkState == Integer.MIN_VALUE) {\n\t\t\tT value = this.queue.poll();\n\t\t\tif (value != null) {\n\t\t\t\tdiscard(value);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (previousWorkState == 0) {\n\t\t\tresume();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onError(Throwable throwable) {\n\t\tif (this.done) {\n\t\t\treturn;\n\t\t}\n\t\tthis.error = throwable;\n\t\tthis.done = true;\n\n\t\tif (addWork() == 0) {\n\t\t\tresume();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onComplete() {\n\t\tif (this.done) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.done = true;\n\n\t\tif (addWork() == 0) {\n\t\t\tresume();\n\t\t}\n\t}\n\n\tint addWork() {\n\t\tfor (;;) {\n\t\t\tint produced = this.workAmount.getPlain();\n\n\t\t\tif (produced == Integer.MIN_VALUE) {\n\t\t\t\treturn Integer.MIN_VALUE;\n\t\t\t}\n\n\t\t\tint nextProduced = (produced == Integer.MAX_VALUE ? 1 : produced + 1);\n\n\t\t\tif (this.workAmount.weakCompareAndSetRelease(produced, nextProduced)) {\n\t\t\t\treturn produced;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void resume() {\n\t\tif (this.parkedThread != READY) {\n\t\t\tObject old = this.parkedThread.getAndSet(READY);\n\t\t\tif (old != READY) {\n\t\t\t\tLockSupport.unpark((Thread) old);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* InputStream implementation */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "int",
    "signature": "public int read()",
    "source_code": "\tpublic int read() throws IOException {\n\t\tif (!this.lock.tryLock()) {\n\t\t\tif (this.closed) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tthrow new ConcurrentModificationException(\"Concurrent access is not allowed\");\n\t\t}\n\n\t\ttry {\n\t\t\tbyte[] next = getNextOrAwait();\n\n\t\t\tif (next == DONE) {\n\t\t\t\tthis.closed = true;\n\t\t\t\tcleanAndFinalize();\n\t\t\t\tif (this.error == null) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow Exceptions.propagate(this.error);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (next == CLOSED) {\n\t\t\t\tcleanAndFinalize();\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\treturn next[this.position++] & 0xFF;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthis.closed = true;\n\t\t\trequiredSubscriber().cancel();\n\t\t\tcleanAndFinalize();\n\t\t\tthrow Exceptions.propagate(ex);\n\t\t}\n\t\tfinally {\n\t\t\tthis.lock.unlock();\n\t\t}\n\t}"
  },
  "org.springframework.http.client.<unknown>#read(b,off,len)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "int",
    "signature": "public int read(byte[] b, int off, int len)",
    "source_code": "\tpublic int read(byte[] b, int off, int len) throws IOException {\n\t\tObjects.checkFromIndexSize(off, len, b.length);\n\t\tif (len == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!this.lock.tryLock()) {\n\t\t\tif (this.closed) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tthrow new ConcurrentModificationException(\"concurrent access is disallowed\");\n\t\t}\n\n\t\ttry {\n\t\t\tfor (int j = 0; j < len;) {\n\t\t\t\tbyte[] next = getNextOrAwait();\n\n\t\t\t\tif (next == DONE) {\n\t\t\t\t\tcleanAndFinalize();\n\t\t\t\t\tif (this.error == null) {\n\t\t\t\t\t\tthis.closed = true;\n\t\t\t\t\t\treturn j == 0 ? -1 : j;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\tthis.closed = true;\n\t\t\t\t\t\t\tthrow Exceptions.propagate(this.error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (next == CLOSED) {\n\t\t\t\t\trequiredSubscriber().cancel();\n\t\t\t\t\tcleanAndFinalize();\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tint i = this.position;\n\t\t\t\tfor (; i < next.length && j < len; i++, j++) {\n\t\t\t\t\tb[off + j] = next[i];\n\t\t\t\t}\n\t\t\t\tthis.position = i;\n\t\t\t}\n\n\t\t\treturn len;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthis.closed = true;\n\t\t\trequiredSubscriber().cancel();\n\t\t\tcleanAndFinalize();\n\t\t\tthrow Exceptions.propagate(ex);\n\t\t}\n\t\tfinally {\n\t\t\tthis.lock.unlock();\n\t\t}\n\t}"
  },
  "org.springframework.http.client.<unknown>#repeatable()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "boolean",
    "signature": "public boolean repeatable()",
    "source_code": "\t\t\t\t\tpublic boolean repeatable() {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}"
  },
  "org.springframework.http.client.<unknown>#writeTo(outputStream)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStream"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "public void writeTo(OutputStream outputStream)",
    "source_code": "\t\t\t\t\tpublic void writeTo(OutputStream outputStream) throws IOException {\n\t\t\t\t\t\tStreamUtils.copy(bufferedOutput, outputStream);\n\t\t\t\t\t}"
  },
  "org.springframework.http.client.HttpComponentsClientHttpRequestFactory#setBufferRequestBody(bufferRequestBody)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicates whether this request factory should buffer the request body internally.\n\t * <p>Default is {@code true}. When sending large amounts of data via POST or PUT, it is\n\t * recommended to change this property to {@code false}, so as not to run out of memory.\n\t * @since 4.0\n\t * @deprecated since 6.1 requests are never buffered, as if this property is {@code false}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bufferRequestBody"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "void",
    "signature": "public void setBufferRequestBody(boolean bufferRequestBody)",
    "source_code": "\tpublic void setBufferRequestBody(boolean bufferRequestBody) {\n\t\t// no-op\n\t}"
  },
  "org.springframework.http.client.SimpleClientHttpRequestFactory#setBufferRequestBody(bufferRequestBody)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicate whether this request factory should buffer the\n\t * {@linkplain ClientHttpRequest#getBody() request body} internally.\n\t * @see #setChunkSize(int)\n\t * @deprecated since 6.1 requests are never buffered,\n\t * as if this property is {@code false}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bufferRequestBody"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "public void setBufferRequestBody(boolean bufferRequestBody)",
    "source_code": "\tpublic void setBufferRequestBody(boolean bufferRequestBody) {\n\t}"
  },
  "org.springframework.http.client.SimpleClientHttpRequestFactory#setOutputStreaming(outputStreaming)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set if the underlying URLConnection can be set to 'output streaming' mode.\n\t * Default is {@code true}.\n\t * <p>When output streaming is enabled, authentication and redirection cannot be handled automatically.\n\t * If output streaming is disabled, the {@link HttpURLConnection#setFixedLengthStreamingMode} and\n\t * {@link HttpURLConnection#setChunkedStreamingMode} methods of the underlying connection will never\n\t * be called.\n\t * @param outputStreaming if output streaming is enabled\n\t * @deprecated as of 6.1 requests are always streamed, as if this property is {@code true}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStreaming"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "public void setOutputStreaming(boolean outputStreaming)",
    "source_code": "\tpublic void setOutputStreaming(boolean outputStreaming) {\n\t}"
  },
  "org.springframework.http.codec.json.AbstractJackson2Encoder#getStreamingMediaTypeSeparator(mimeType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the separator to use for the given mime type.\n\t * <p>By default, this method returns new line {@code \"\\n\"} if the given\n\t * mime type is one of the configured {@link #setStreamingMediaTypes(List)\n\t * streaming} mime types.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "byte[]",
    "signature": "protected byte[] getStreamingMediaTypeSeparator(@Nullable MimeType mimeType)",
    "source_code": "\tprotected byte[] getStreamingMediaTypeSeparator(@Nullable MimeType mimeType) {\n\t\tfor (MediaType streamingMediaType : this.streamingMediaTypes) {\n\t\t\tif (streamingMediaType.isCompatibleWith(mimeType)) {\n\t\t\t\treturn NEWLINE_SEPARATOR;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.codec.json.Jackson2SmileEncoder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Encode from an {@code Object} stream to a byte stream of Smile objects using Jackson 2.x.\n * For non-streaming use cases, {@link Flux} elements are collected into a {@link List}\n * before serialization for performance reason.\n *\n * @author Sebastien Deleuze\n * @since 5.0\n * @see Jackson2SmileDecoder\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public class Jackson2SmileEncoder",
    "source_code": "public class Jackson2SmileEncoder extends AbstractJackson2Encoder {\n\n\tprivate static final MimeType[] DEFAULT_SMILE_MIME_TYPES = new MimeType[] {\n\t\t\tnew MimeType(\"application\", \"x-jackson-smile\"),\n\t\t\tnew MimeType(\"application\", \"*+x-jackson-smile\")};\n\n\tprivate static final byte[] STREAM_SEPARATOR = new byte[0];\n\n\n\tpublic Jackson2SmileEncoder() {\n\t\tthis(Jackson2ObjectMapperBuilder.smile().build(), DEFAULT_SMILE_MIME_TYPES);\n\t}\n\n\tpublic Jackson2SmileEncoder(ObjectMapper mapper, MimeType... mimeTypes) {\n\t\tsuper(mapper, mimeTypes);\n\t\tAssert.isAssignable(SmileFactory.class, mapper.getFactory().getClass());\n\t\tsetStreamingMediaTypes(Collections.singletonList(new MediaType(\"application\", \"stream+x-jackson-smile\")));\n\t}\n\n\n\t/**\n\t * Return the separator to use for the given mime type.\n\t * <p>By default, this method returns a single byte 0 if the given\n\t * mime type is one of the configured {@link #setStreamingMediaTypes(List)\n\t * streaming} mime types.\n\t * @since 5.3\n\t */\n\t@Override\n\tprotected byte @Nullable [] getStreamingMediaTypeSeparator(@Nullable MimeType mimeType) {\n\t\tfor (MediaType streamingMediaType : getStreamingMediaTypes()) {\n\t\t\tif (streamingMediaType.isCompatibleWith(mimeType)) {\n\t\t\t\treturn STREAM_SEPARATOR;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}"
  },
  "org.springframework.http.codec.multipart.<unknown>#charset(headers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the character set of the given headers, as defined in the\n\t * {@link HttpHeaders#getContentType()} header.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "Charset",
    "signature": "public Charset charset(HttpHeaders headers)",
    "source_code": "\tpublic static Charset charset(HttpHeaders headers) {\n\t\tMediaType contentType = headers.getContentType();\n\t\tif (contentType != null) {\n\t\t\tCharset charset = contentType.getCharset();\n\t\t\tif (charset != null) {\n\t\t\t\treturn charset;\n\t\t\t}\n\t\t}\n\t\treturn StandardCharsets.UTF_8;\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#closeChannel(channel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channel"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void closeChannel(Channel channel)",
    "source_code": "\tpublic static void closeChannel(Channel channel) {\n\t\ttry {\n\t\t\tif (channel.isOpen()) {\n\t\t\t\tchannel.close();\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ignore) {\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#concat(byteArrays)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Concatenates the given array of byte arrays.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "byteArrays"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "byte[]",
    "signature": "public byte[] concat(byte[]... byteArrays)",
    "source_code": "\tpublic static byte[] concat(byte[]... byteArrays) {\n\t\tint len = 0;\n\t\tfor (byte[] byteArray : byteArrays) {\n\t\t\tlen += byteArray.length;\n\t\t}\n\t\tbyte[] result = new byte[len];\n\t\tlen = 0;\n\t\tfor (byte[] byteArray : byteArrays) {\n\t\t\tSystem.arraycopy(byteArray, 0, result, len, byteArray.length);\n\t\t\tlen += byteArray.length;\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#deleteFile(file)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "file"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "public void deleteFile(Path file)",
    "source_code": "\tpublic static void deleteFile(Path file) {\n\t\ttry {\n\t\t\tFiles.delete(file);\n\t\t}\n\t\tcatch (IOException ignore) {\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#isFormField(headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "boolean",
    "signature": "public boolean isFormField(HttpHeaders headers)",
    "source_code": "\tpublic static boolean isFormField(HttpHeaders headers) {\n\t\tMediaType contentType = headers.getContentType();\n\t\treturn (contentType == null || MediaType.TEXT_PLAIN.equalsTypeAndSubtype(contentType))\n\t\t\t\t&& headers.getContentDisposition().getFilename() == null;\n\t}"
  },
  "org.springframework.http.codec.support.DefaultCustomCodecs#decoder(decoder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "void",
    "signature": "public void decoder(Decoder<?> decoder)",
    "source_code": "\t\tpublic void decoder(Decoder<?> decoder) {\n\t\t\taddCodec(decoder, false);\n\t\t}"
  },
  "org.springframework.http.codec.support.DefaultCustomCodecs#encoder(encoder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "void",
    "signature": "public void encoder(Encoder<?> encoder)",
    "source_code": "\t\tpublic void encoder(Encoder<?> encoder) {\n\t\t\taddCodec(encoder, false);\n\t\t}"
  },
  "org.springframework.http.codec.support.DefaultCustomCodecs#reader(reader)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reader"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void reader(HttpMessageReader<?> reader)",
    "source_code": "\t\tpublic void reader(HttpMessageReader<?> reader) {\n\t\t\taddCodec(reader, false);\n\t\t}"
  },
  "org.springframework.http.codec.support.DefaultCustomCodecs#withDefaultCodecConfig(codecsConfigConsumer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codecsConfigConsumer"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "void",
    "signature": "public void withDefaultCodecConfig(Consumer<DefaultCodecConfig> codecsConfigConsumer)",
    "source_code": "\t\tpublic void withDefaultCodecConfig(Consumer<DefaultCodecConfig> codecsConfigConsumer) {\n\t\t\tthis.defaultConfigConsumers.add(codecsConfigConsumer);\n\t\t}"
  },
  "org.springframework.http.codec.support.DefaultCustomCodecs#writer(writer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "writer"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "void",
    "signature": "public void writer(HttpMessageWriter<?> writer)",
    "source_code": "\t\tpublic void writer(HttpMessageWriter<?> writer) {\n\t\t\taddCodec(writer, false);\n\t\t}"
  },
  "org.springframework.http.converter.FormHttpMessageConverter#repeatable()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "boolean",
    "signature": "public boolean repeatable()",
    "source_code": "\t\t\t\tpublic boolean repeatable() {\n\t\t\t\t\treturn true;\n\t\t\t\t}"
  },
  "org.springframework.http.converter.FormHttpMessageConverter#writeTo(outputStream)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStream"
    ],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "void",
    "signature": "public void writeTo(OutputStream outputStream)",
    "source_code": "\t\t\t\tpublic void writeTo(OutputStream outputStream) throws IOException {\n\t\t\t\t\tStreamUtils.copy(bytes, outputStream);\n\t\t\t\t}"
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#annotationIntrospector(AnnotationIntrospector,pairingFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Alternative to {@link #annotationIntrospector(AnnotationIntrospector)}\n\t * that allows combining with rather than replacing the currently set\n\t * introspector, for example, via\n\t * {@link AnnotationIntrospectorPair#pair(AnnotationIntrospector, AnnotationIntrospector)}.\n\t * @param pairingFunction a function to apply to the currently set\n\t * introspector (possibly {@code null}); the result of the function becomes\n\t * the new introspector.\n\t * @since 5.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "AnnotationIntrospector",
      "pairingFunction"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder annotationIntrospector(Function<@Nullable AnnotationIntrospector, @Nullable AnnotationIntrospector> pairingFunction)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder annotationIntrospector("
  },
  "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#annotationIntrospector(Function<AnnotationIntrospector,pairingFunction)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Alternative to {@link #annotationIntrospector(AnnotationIntrospector)}\n\t * that allows combining with rather than replacing the currently set\n\t * introspector, for example, via\n\t * {@link AnnotationIntrospectorPair#pair(AnnotationIntrospector, AnnotationIntrospector)}.\n\t * @param pairingFunction a function to apply to the currently set\n\t * introspector (possibly {@code null}); the result of the function becomes\n\t * the new introspector.\n\t * @since 5.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<AnnotationIntrospector",
      "pairingFunction"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder annotationIntrospector(Function<AnnotationIntrospector, AnnotationIntrospector> pairingFunction)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder annotationIntrospector("
  },
  "org.springframework.http.converter.protobuf.DEFAULT_CHARSET": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The default charset used by the converter.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public Charset DEFAULT_CHARSET",
    "source_code": "\tpublic static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;",
    "type": "Charset"
  },
  "org.springframework.http.converter.protobuf.PROTOBUF": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The media-type for protobuf {@code application/x-protobuf}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "signature": "public MediaType PROTOBUF",
    "source_code": "\tpublic static final MediaType PROTOBUF = new MediaType(\"application\", \"x-protobuf\", DEFAULT_CHARSET);",
    "type": "MediaType"
  },
  "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An {@code HttpMessageConverter} that reads and writes\n * {@link com.google.protobuf.Message com.google.protobuf.Messages} using\n * <a href=\"https://developers.google.com/protocol-buffers/\">Google Protocol Buffers</a>.\n *\n * <p>To generate {@code Message} Java classes, you need to install the {@code protoc} binary.\n *\n * <p>This converter supports by default {@code \"application/x-protobuf\"} and {@code \"text/plain\"}\n * with the official {@code \"com.google.protobuf:protobuf-java\"} library.\n * The {@code \"application/json\"} format is also supported with the {@code \"com.google.protobuf:protobuf-java-util\"}\n * dependency. See {@link ProtobufJsonFormatHttpMessageConverter} for a configurable variant.\n *\n * <p>This converter requires Protobuf 3 or higher as of Spring Framework 6.1.\n *\n * @author Alex Antonov\n * @author Brian Clozel\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @since 4.1\n * @see JsonFormat\n * @see ProtobufJsonFormatHttpMessageConverter\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "signature": "public class ProtobufHttpMessageConverter",
    "source_code": "public class ProtobufHttpMessageConverter extends AbstractHttpMessageConverter<Message> {\n\n\t/**\n\t * The default charset used by the converter.\n\t */\n\tpublic static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;\n\n\t/**\n\t * The media-type for protobuf {@code application/x-protobuf}.\n\t */\n\tpublic static final MediaType PROTOBUF = new MediaType(\"application\", \"x-protobuf\", DEFAULT_CHARSET);\n\n\t/**\n\t * The HTTP header containing the protobuf schema.\n\t */\n\tpublic static final String X_PROTOBUF_SCHEMA_HEADER = \"X-Protobuf-Schema\";\n\n\t/**\n\t * The HTTP header containing the protobuf message.\n\t */\n\tpublic static final String X_PROTOBUF_MESSAGE_HEADER = \"X-Protobuf-Message\";\n\n\tprivate static final boolean protobufJsonFormatPresent = ClassUtils.isPresent(\"com.google.protobuf.util.JsonFormat\", ProtobufHttpMessageConverter.class.getClassLoader());\n\n\tprivate static final Map<Class<?>, Method> methodCache = new ConcurrentReferenceHashMap<>();\n\n\n\tfinal ExtensionRegistry extensionRegistry;\n\n\tprivate final @Nullable ProtobufFormatSupport protobufFormatSupport;\n\n\n\t/**\n\t * Construct a new {@code ProtobufHttpMessageConverter}.\n\t */\n\tpublic ProtobufHttpMessageConverter() {\n\t\tthis(null, null);\n\t}\n\n\t/**\n\t * Construct a new {@code ProtobufHttpMessageConverter} with a registry that specifies\n\t * protocol message extensions.\n\t * @param extensionRegistry the registry to populate\n\t */\n\tpublic ProtobufHttpMessageConverter(ExtensionRegistry extensionRegistry) {\n\t\tthis(null, extensionRegistry);\n\t}\n\n\tProtobufHttpMessageConverter(@Nullable ProtobufFormatSupport formatSupport,\n\t\t\t@Nullable ExtensionRegistry extensionRegistry) {\n\n\t\tif (formatSupport != null) {\n\t\t\tthis.protobufFormatSupport = formatSupport;\n\t\t}\n\t\telse if (protobufJsonFormatPresent) {\n\t\t\tthis.protobufFormatSupport = new ProtobufJavaUtilSupport(null, null);\n\t\t}\n\t\telse {\n\t\t\tthis.protobufFormatSupport = null;\n\t\t}\n\n\t\tsetSupportedMediaTypes(Arrays.asList(this.protobufFormatSupport != null ?\n\t\t\t\tthis.protobufFormatSupport.supportedMediaTypes() : new MediaType[] {PROTOBUF, TEXT_PLAIN}));\n\n\t\tthis.extensionRegistry = (extensionRegistry == null ? ExtensionRegistry.newInstance() : extensionRegistry);\n\t}\n\n\n\t@Override\n\tprotected boolean supports(Class<?> clazz) {\n\t\treturn Message.class.isAssignableFrom(clazz);\n\t}\n\n\t@Override\n\tprotected MediaType getDefaultContentType(Message message) {\n\t\treturn PROTOBUF;\n\t}\n\n\t@Override\n\tprotected Message readInternal(Class<? extends Message> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tMediaType contentType = inputMessage.getHeaders().getContentType();\n\t\tif (contentType == null) {\n\t\t\tcontentType = PROTOBUF;\n\t\t}\n\t\tCharset charset = contentType.getCharset();\n\t\tif (charset == null) {\n\t\t\tcharset = DEFAULT_CHARSET;\n\t\t}\n\n\t\tMessage.Builder builder = getMessageBuilder(clazz);\n\t\tif (PROTOBUF.isCompatibleWith(contentType)) {\n\t\t\tbuilder.mergeFrom(inputMessage.getBody(), this.extensionRegistry);\n\t\t}\n\t\telse if (TEXT_PLAIN.isCompatibleWith(contentType)) {\n\t\t\tInputStreamReader reader = new InputStreamReader(inputMessage.getBody(), charset);\n\t\t\tTextFormat.merge(reader, this.extensionRegistry, builder);\n\t\t}\n\t\telse if (this.protobufFormatSupport != null) {\n\t\t\tthis.protobufFormatSupport.merge(\n\t\t\t\t\tinputMessage.getBody(), charset, contentType, this.extensionRegistry, builder);\n\t\t}\n\t\treturn builder.build();\n\t}\n\n\t/**\n\t * Create a new {@code Message.Builder} instance for the given class.\n\t * <p>This method uses a ConcurrentReferenceHashMap for caching method lookups.\n\t */\n\tprivate Message.Builder getMessageBuilder(Class<? extends Message> clazz) {\n\t\ttry {\n\t\t\tMethod method = methodCache.get(clazz);\n\t\t\tif (method == null) {\n\t\t\t\tmethod = clazz.getMethod(\"newBuilder\");\n\t\t\t\tmethodCache.put(clazz, method);\n\t\t\t}\n\t\t\treturn (Message.Builder) method.invoke(clazz);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new HttpMessageConversionException(\n\t\t\t\t\t\"Invalid Protobuf Message type: no invocable newBuilder() method on \" + clazz, ex);\n\t\t}\n\t}\n\n\n\t@Override\n\tprotected boolean canWrite(@Nullable MediaType mediaType) {\n\t\treturn (super.canWrite(mediaType) ||\n\t\t\t\t(this.protobufFormatSupport != null && this.protobufFormatSupport.supportsWriteOnly(mediaType)));\n\t}\n\n\t@Override\n\tprotected void writeInternal(Message message, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n\t\tif (contentType == null) {\n\t\t\tcontentType = getDefaultContentType(message);\n\t\t\tAssert.state(contentType != null, \"No content type\");\n\t\t}\n\t\tCharset charset = contentType.getCharset();\n\t\tif (charset == null) {\n\t\t\tcharset = DEFAULT_CHARSET;\n\t\t}\n\n\t\tif (PROTOBUF.isCompatibleWith(contentType)) {\n\t\t\tsetProtoHeader(outputMessage, message);\n\t\t\tCodedOutputStream codedOutputStream = CodedOutputStream.newInstance(outputMessage.getBody());\n\t\t\tmessage.writeTo(codedOutputStream);\n\t\t\tcodedOutputStream.flush();\n\t\t}\n\t\telse if (TEXT_PLAIN.isCompatibleWith(contentType)) {\n\t\t\tOutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputMessage.getBody(), charset);\n\t\t\tTextFormat.printer().print(message, outputStreamWriter);\n\t\t\toutputStreamWriter.flush();\n\t\t\toutputMessage.getBody().flush();\n\t\t}\n\t\telse if (this.protobufFormatSupport != null) {\n\t\t\tthis.protobufFormatSupport.print(message, outputMessage.getBody(), contentType, charset);\n\t\t\toutputMessage.getBody().flush();\n\t\t}\n\t}\n\n\t/**\n\t * Set the \"X-Protobuf-*\" HTTP headers when responding with a message of\n\t * content type \"application/x-protobuf\"\n\t * <p><b>Note:</b> <code>outputMessage.getBody()</code> should not have been called\n\t * before because it writes HTTP headers (making them read only).</p>\n\t */\n\tprivate void setProtoHeader(HttpOutputMessage response, Message message) {\n\t\tresponse.getHeaders().set(X_PROTOBUF_SCHEMA_HEADER, message.getDescriptorForType().getFile().getName());\n\t\tresponse.getHeaders().set(X_PROTOBUF_MESSAGE_HEADER, message.getDescriptorForType().getFullName());\n\t}\n\n\t@Override\n\tprotected boolean supportsRepeatableWrites(Message message) {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Protobuf format support.\n\t */\n\tinterface ProtobufFormatSupport {\n\n\t\tMediaType[] supportedMediaTypes();\n\n\t\tboolean supportsWriteOnly(@Nullable MediaType mediaType);\n\n\t\tvoid merge(InputStream input, Charset charset, MediaType contentType,\n\t\t\t\tExtensionRegistry extensionRegistry, Message.Builder builder)\n\t\t\t\tthrows IOException, HttpMessageConversionException;\n\n\t\tvoid print(Message message, OutputStream output, MediaType contentType, Charset charset)\n\t\t\t\tthrows IOException, HttpMessageConversionException;\n\t}\n\n\n\t/**\n\t * {@link ProtobufFormatSupport} implementation used when\n\t * {@code com.google.protobuf.util.JsonFormat} is available.\n\t */\n\tstatic class ProtobufJavaUtilSupport implements ProtobufFormatSupport {\n\n\t\tprivate final JsonFormat.Parser parser;\n\n\t\tprivate final JsonFormat.Printer printer;\n\n\t\tpublic ProtobufJavaUtilSupport(JsonFormat.@Nullable Parser parser, JsonFormat.@Nullable Printer printer) {\n\t\t\tthis.parser = (parser != null ? parser : JsonFormat.parser());\n\t\t\tthis.printer = (printer != null ? printer : JsonFormat.printer());\n\t\t}\n\n\t\t@Override\n\t\tpublic MediaType[] supportedMediaTypes() {\n\t\t\treturn new MediaType[] {PROTOBUF, TEXT_PLAIN, APPLICATION_JSON};\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean supportsWriteOnly(@Nullable MediaType mediaType) {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void merge(InputStream input, Charset charset, MediaType contentType,\n\t\t\t\tExtensionRegistry extensionRegistry, Message.Builder builder)\n\t\t\t\tthrows IOException, HttpMessageConversionException {\n\n\t\t\tif (contentType.isCompatibleWith(APPLICATION_JSON)) {\n\t\t\t\tInputStreamReader reader = new InputStreamReader(input, charset);\n\t\t\t\tthis.parser.merge(reader, builder);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new HttpMessageConversionException(\n\t\t\t\t\t\t\"protobuf-java-util does not support parsing \" + contentType);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void print(Message message, OutputStream output, MediaType contentType, Charset charset)\n\t\t\t\tthrows IOException, HttpMessageConversionException {\n\n\t\t\tif (contentType.isCompatibleWith(APPLICATION_JSON)) {\n\t\t\t\tOutputStreamWriter writer = new OutputStreamWriter(output, charset);\n\t\t\t\tthis.printer.appendTo(message, writer);\n\t\t\t\twriter.flush();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new HttpMessageConversionException(\n\t\t\t\t\t\t\"protobuf-java-util does not support printing \" + contentType);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter#canWrite(mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "boolean",
    "signature": "protected boolean canWrite(@Nullable MediaType mediaType)",
    "source_code": "\tprotected boolean canWrite(@Nullable MediaType mediaType) {\n\t\treturn (super.canWrite(mediaType) ||\n\t\t\t\t(this.protobufFormatSupport != null && this.protobufFormatSupport.supportsWriteOnly(mediaType)));\n\t}"
  },
  "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter#getDefaultContentType(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "MediaType",
    "signature": "protected MediaType getDefaultContentType(Message message)",
    "source_code": "\tprotected MediaType getDefaultContentType(Message message) {\n\t\treturn PROTOBUF;\n\t}"
  },
  "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter#merge(input,charset,contentType,extensionRegistry,builder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "charset",
      "contentType",
      "extensionRegistry",
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "void",
    "signature": "public void merge(InputStream input, Charset charset, MediaType contentType,\n\t\t\t\tExtensionRegistry extensionRegistry, Message.Builder builder)",
    "source_code": "\t\tpublic void merge(InputStream input, Charset charset, MediaType contentType,"
  },
  "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter#print(message,output,contentType,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "output",
      "contentType",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "void",
    "signature": "public void print(Message message, OutputStream output, MediaType contentType, Charset charset)",
    "source_code": "\t\tpublic void print(Message message, OutputStream output, MediaType contentType, Charset charset)"
  },
  "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter#readInternal(clazz,inputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "Message",
    "signature": "protected Message readInternal(Class<? extends Message> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tprotected Message readInternal(Class<? extends Message> clazz, HttpInputMessage inputMessage)"
  },
  "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter#supportedMediaTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "MediaType[]",
    "signature": "public MediaType[] supportedMediaTypes()",
    "source_code": "\t\tpublic MediaType[] supportedMediaTypes() {\n\t\t\treturn new MediaType[] {PROTOBUF, TEXT_PLAIN, APPLICATION_JSON};\n\t\t}"
  },
  "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter#supports(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "boolean",
    "signature": "protected boolean supports(Class<?> clazz)",
    "source_code": "\tprotected boolean supports(Class<?> clazz) {\n\t\treturn Message.class.isAssignableFrom(clazz);\n\t}"
  },
  "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter#supportsRepeatableWrites(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "boolean",
    "signature": "protected boolean supportsRepeatableWrites(Message message)",
    "source_code": "\tprotected boolean supportsRepeatableWrites(Message message) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter#supportsWriteOnly(mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "boolean",
    "signature": "public boolean supportsWriteOnly(@Nullable MediaType mediaType)",
    "source_code": "\t\tpublic boolean supportsWriteOnly(@Nullable MediaType mediaType) {\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter#writeInternal(message,outputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "void",
    "signature": "protected void writeInternal(Message message, HttpOutputMessage outputMessage)",
    "source_code": "\tprotected void writeInternal(Message message, HttpOutputMessage outputMessage)"
  },
  "org.springframework.http.converter.protobuf.ProtobufJsonFormatHttpMessageConverter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Subclass of {@link ProtobufHttpMessageConverter} which enforces the use of Protobuf 3 and\n * its official library {@code \"com.google.protobuf:protobuf-java-util\"} for JSON processing.\n *\n * <p>Most importantly, this class allows for custom JSON parser and printer configurations\n * through the {@link JsonFormat} utility. If no special parser or printer configuration is\n * given, default variants will be used instead.\n *\n * <p>Requires Protobuf 3.x and {@code \"com.google.protobuf:protobuf-java-util\"} 3.x,\n * with 3.3 or higher recommended.\n *\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @since 5.0\n * @see JsonFormat#parser()\n * @see JsonFormat#printer()\n * @see #ProtobufJsonFormatHttpMessageConverter(com.google.protobuf.util.JsonFormat.Parser, com.google.protobuf.util.JsonFormat.Printer)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public class ProtobufJsonFormatHttpMessageConverter",
    "source_code": "public class ProtobufJsonFormatHttpMessageConverter extends ProtobufHttpMessageConverter {\n\n\t/**\n\t * Constructor with default instances of\n\t * {@link com.google.protobuf.util.JsonFormat.Parser JsonFormat.Parser},\n\t * {@link com.google.protobuf.util.JsonFormat.Printer JsonFormat.Printer},\n\t * and {@link ExtensionRegistry}.\n\t */\n\tpublic ProtobufJsonFormatHttpMessageConverter() {\n\t\tthis(null, null);\n\t}\n\n\t/**\n\t * Constructor with given instances of\n\t * {@link com.google.protobuf.util.JsonFormat.Parser JsonFormat.Parser},\n\t * {@link com.google.protobuf.util.JsonFormat.Printer JsonFormat.Printer},\n\t * and a default instance of {@link ExtensionRegistry}.\n\t */\n\tpublic ProtobufJsonFormatHttpMessageConverter(\n\t\t\tJsonFormat.@Nullable Parser parser, JsonFormat.@Nullable Printer printer) {\n\n\t\tthis(parser, printer, (ExtensionRegistry) null);\n\t}\n\n\t/**\n\t * Constructor with given instances of\n\t * {@link com.google.protobuf.util.JsonFormat.Parser JsonFormat.Parser},\n\t * {@link com.google.protobuf.util.JsonFormat.Printer JsonFormat.Printer},\n\t * and {@link ExtensionRegistry}.\n\t */\n\tpublic ProtobufJsonFormatHttpMessageConverter(JsonFormat.@Nullable Parser parser,\n\t\t\tJsonFormat.@Nullable Printer printer, @Nullable ExtensionRegistry extensionRegistry) {\n\n\t\tsuper(new ProtobufJavaUtilSupport(parser, printer), extensionRegistry);\n\t}\n\n}"
  },
  "org.springframework.http.converter.protobuf.X_PROTOBUF_MESSAGE_HEADER": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The HTTP header containing the protobuf message.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "signature": "public String X_PROTOBUF_MESSAGE_HEADER",
    "source_code": "\tpublic static final String X_PROTOBUF_MESSAGE_HEADER = \"X-Protobuf-Message\";",
    "type": "String"
  },
  "org.springframework.http.converter.protobuf.X_PROTOBUF_SCHEMA_HEADER": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The HTTP header containing the protobuf schema.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "signature": "public String X_PROTOBUF_SCHEMA_HEADER",
    "source_code": "\tpublic static final String X_PROTOBUF_SCHEMA_HEADER = \"X-Protobuf-Schema\";",
    "type": "String"
  },
  "org.springframework.http.server.reactive.<unknown>#getInputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link ServletInputStream} for the current response.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "ServletInputStream",
    "signature": "protected ServletInputStream getInputStream()",
    "source_code": "\tprotected final ServletInputStream getInputStream() {\n\t\treturn this.inputStream;\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#getPeerCertificates()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "X509Certificate[]",
    "signature": "public X509Certificate[] getPeerCertificates()",
    "source_code": "\tpublic X509Certificate[] getPeerCertificates() {\n\t\treturn this.peerCertificates;\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#getRawStatusCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "Integer",
    "signature": "public Integer getRawStatusCode()",
    "source_code": "\tpublic Integer getRawStatusCode() {\n\t\tInteger status = super.getRawStatusCode();\n\t\treturn (status != null ? status : this.response.status().code());\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#logBytesRead(read)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "read"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "void",
    "signature": "protected void logBytesRead(int read)",
    "source_code": "\tprotected final void logBytesRead(int read) {\n\t\tLog rsReadLogger = AbstractListenerReadPublisher.rsReadLogger;\n\t\tif (rsReadLogger.isTraceEnabled()) {\n\t\t\trsReadLogger.trace(getLogPrefix() + \"Read \" + read + (read != -1 ? \" bytes\" : \"\"));\n\t\t}\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#onAllDataRead()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "void",
    "signature": "public void onAllDataRead()",
    "source_code": "\t\t\tpublic void onAllDataRead() throws IOException {\n\t\t\t\tRequestBodyPublisher.this.onAllDataRead();\n\t\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#onComplete(event)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "void",
    "signature": "public void onComplete(AsyncEvent event)",
    "source_code": "\t\tpublic void onComplete(AsyncEvent event) {\n\t\t\tbodyPublisher.onAllDataRead();\n\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#onDataAvailable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "void",
    "signature": "public void onDataAvailable()",
    "source_code": "\t\t\tpublic void onDataAvailable() throws IOException {\n\t\t\t\tRequestBodyPublisher.this.onDataAvailable();\n\t\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#onError(event)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "void",
    "signature": "public void onError(AsyncEvent event)",
    "source_code": "\t\tpublic void onError(AsyncEvent event) {\n\t\t\tbodyPublisher.onError(event.getThrowable());\n\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#onError(throwable)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "throwable"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "void",
    "signature": "public void onError(Throwable throwable)",
    "source_code": "\t\t\tpublic void onError(Throwable throwable) {\n\t\t\t\tRequestBodyPublisher.this.onError(throwable);\n\n\t\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#onStartAsync(event)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "void",
    "signature": "public void onStartAsync(AsyncEvent event)",
    "source_code": "\t\tpublic void onStartAsync(AsyncEvent event) {\n\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#onTimeout(event)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "void",
    "signature": "public void onTimeout(AsyncEvent event)",
    "source_code": "\t\tpublic void onTimeout(AsyncEvent event) {\n\t\t\tThrowable ex = event.getThrowable();\n\t\t\tex = ex != null ? ex : new IllegalStateException(\"Async operation timeout.\");\n\t\t\tbodyPublisher.onError(ex);\n\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#registerReadListener()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "void",
    "signature": "public void registerReadListener()",
    "source_code": "\t\tpublic void registerReadListener() throws IOException {\n\t\t\tthis.inputStream.setReadListener(new RequestBodyPublisherReadListener());\n\t\t}"
  },
  "org.springframework.http.server.reactive.JettyHttpHandlerAdapter": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * {@link ServletHttpHandlerAdapter} extension that uses Jetty APIs for writing\n * to the response with {@link ByteBuffer}.\n *\n * @author Violeta Georgieva\n * @author Brian Clozel\n * @author Juergen Hoeller\n * @since 5.0\n * @see org.springframework.web.server.adapter.AbstractReactiveWebInitializer\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class JettyHttpHandlerAdapter",
    "source_code": "public class JettyHttpHandlerAdapter extends ServletHttpHandlerAdapter {\n\n\tpublic JettyHttpHandlerAdapter(HttpHandler httpHandler) {\n\t\tsuper(httpHandler);\n\t}\n\n\n\t@Override\n\tprotected ServletServerHttpResponse createResponse(HttpServletResponse response,\n\t\t\tAsyncContext context, ServletServerHttpRequest request) throws IOException {\n\n\t\treturn new Jetty12ServerHttpResponse(\n\t\t\t\tresponse, context, getDataBufferFactory(), getBufferSize(), request);\n\t}\n\n\n\tprivate static final class Jetty12ServerHttpResponse extends ServletServerHttpResponse {\n\n\t\tJetty12ServerHttpResponse(HttpServletResponse response, AsyncContext asyncContext,\n\t\t\t\tDataBufferFactory bufferFactory, int bufferSize, ServletServerHttpRequest request)\n\t\t\t\tthrows IOException {\n\n\t\t\tsuper(response, asyncContext, bufferFactory, bufferSize, request);\n\t\t}\n\n\t\t@Override\n\t\tprotected int writeToOutputStream(DataBuffer dataBuffer) throws IOException {\n\t\t\tOutputStream output = getOutputStream();\n\t\t\tif (output instanceof HttpOutput httpOutput) {\n\t\t\t\tint len = 0;\n\t\t\t\ttry (DataBuffer.ByteBufferIterator iterator = dataBuffer.readableByteBuffers()) {\n\t\t\t\t\twhile (iterator.hasNext() && httpOutput.isReady()) {\n\t\t\t\t\t\tByteBuffer byteBuffer = iterator.next();\n\t\t\t\t\t\tlen += byteBuffer.remaining();\n\t\t\t\t\t\thttpOutput.write(byteBuffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn len;\n\t\t\t}\n\t\t\treturn super.writeToOutputStream(dataBuffer);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.server.reactive.JettyHttpHandlerAdapter#createResponse(response,context,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "context",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "ServletServerHttpResponse",
    "signature": "protected ServletServerHttpResponse createResponse(HttpServletResponse response,\n\t\t\tAsyncContext context, ServletServerHttpRequest request)",
    "source_code": "\tprotected ServletServerHttpResponse createResponse(HttpServletResponse response,"
  },
  "org.springframework.http.server.reactive.JettyHttpHandlerAdapter#writeToOutputStream(dataBuffer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "dataBuffer"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "int",
    "signature": "protected int writeToOutputStream(DataBuffer dataBuffer)",
    "source_code": "\t\tprotected int writeToOutputStream(DataBuffer dataBuffer) throws IOException {\n\t\t\tOutputStream output = getOutputStream();\n\t\t\tif (output instanceof HttpOutput httpOutput) {\n\t\t\t\tint len = 0;\n\t\t\t\ttry (DataBuffer.ByteBufferIterator iterator = dataBuffer.readableByteBuffers()) {\n\t\t\t\t\twhile (iterator.hasNext() && httpOutput.isReady()) {\n\t\t\t\t\t\tByteBuffer byteBuffer = iterator.next();\n\t\t\t\t\t\tlen += byteBuffer.remaining();\n\t\t\t\t\t\thttpOutput.write(byteBuffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn len;\n\t\t\t}\n\t\t\treturn super.writeToOutputStream(dataBuffer);\n\t\t}"
  },
  "org.springframework.http.server.reactive.ServerHttpResponseDecorator#getRawStatusCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "Integer",
    "signature": "public Integer getRawStatusCode()",
    "source_code": "\tpublic Integer getRawStatusCode() {\n\t\treturn getDelegate().getRawStatusCode();\n\t}"
  },
  "org.springframework.http.server.reactive.SslInfo": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A holder for SSL session information.\n *\n * @author Rossen Stoyanchev\n * @since 5.0.2\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 29
    },
    "signature": "public interface SslInfo",
    "source_code": "public interface SslInfo {\n\n\t/**\n\t * Return the SSL session id, if any.\n\t */\n\t@Nullable String getSessionId();\n\n\t/**\n\t * Return SSL certificates associated with the request, if any.\n\t */\n\tX509Certificate @Nullable [] getPeerCertificates();\n\n}"
  },
  "org.springframework.http.server.reactive.TomcatHttpHandlerAdapter#readFromInputStream()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "DataBuffer",
    "signature": "protected DataBuffer readFromInputStream()",
    "source_code": "\t\tprotected DataBuffer readFromInputStream() throws IOException {\n\t\t\tif (getInputStream() instanceof CoyoteInputStream coyoteInputStream) {\n\t\t\t\tDataBuffer dataBuffer = this.factory.allocateBuffer(this.bufferSize);\n\t\t\t\tint read = -1;\n\t\t\t\ttry {\n\t\t\t\t\ttry (DataBuffer.ByteBufferIterator iterator = dataBuffer.writableByteBuffers()) {\n\t\t\t\t\t\tAssert.state(iterator.hasNext(), \"No ByteBuffer available\");\n\t\t\t\t\t\tByteBuffer byteBuffer = iterator.next();\n\t\t\t\t\t\tread = coyoteInputStream.read(byteBuffer);\n\t\t\t\t\t}\n\t\t\t\t\tlogBytesRead(read);\n\t\t\t\t\tif (read > 0) {\n\t\t\t\t\t\tdataBuffer.writePosition(read);\n\t\t\t\t\t\treturn dataBuffer;\n\t\t\t\t\t}\n\t\t\t\t\telse if (read == -1) {\n\t\t\t\t\t\treturn EOF_BUFFER;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn AbstractListenerReadPublisher.EMPTY_BUFFER;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tif (read <= 0) {\n\t\t\t\t\t\tDataBufferUtils.release(dataBuffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// It's possible InputStream can be wrapped, preventing use of CoyoteInputStream\n\t\t\t\treturn super.readFromInputStream();\n\t\t\t}\n\n\t\t}"
  },
  "org.springframework.http.server.reactive.TomcatHttpHandlerAdapter#writeToOutputStream(dataBuffer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "dataBuffer"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "int",
    "signature": "protected int writeToOutputStream(DataBuffer dataBuffer)",
    "source_code": "\t\tprotected int writeToOutputStream(DataBuffer dataBuffer) throws IOException {\n\t\t\tif (getOutputStream() instanceof CoyoteOutputStream coyoteOutputStream) {\n\t\t\t\tint len = 0;\n\t\t\t\ttry (DataBuffer.ByteBufferIterator iterator = dataBuffer.readableByteBuffers()) {\n\t\t\t\t\twhile (iterator.hasNext() && coyoteOutputStream.isReady()) {\n\t\t\t\t\t\tByteBuffer byteBuffer = iterator.next();\n\t\t\t\t\t\tlen += byteBuffer.remaining();\n\t\t\t\t\t\tcoyoteOutputStream.write(byteBuffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn len;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn super.writeToOutputStream(dataBuffer);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link LoadTimeWeaver} relying on VM {@link Instrumentation}.\n *\n * <p>Start the JVM specifying the Java agent to be used &mdash; for example, as\n * follows where <code>spring-instrument-{version}.jar</code> is a JAR file\n * containing the {@link InstrumentationSavingAgent} class shipped with Spring\n * and where <code>{version}</code> is the release version of the Spring\n * Framework (for example, {@code 5.1.5.RELEASE}).\n *\n * <p><code>-javaagent:path/to/spring-instrument-{version}.jar</code>\n *\n * <p>In Eclipse, for example, add something similar to the following to the\n * JVM arguments for the Eclipse \"Run configuration\":\n *\n * <p><code>-javaagent:${project_loc}/lib/spring-instrument-{version}.jar</code>\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 2.0\n * @see InstrumentationSavingAgent\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "signature": "public class InstrumentationLoadTimeWeaver",
    "source_code": "public class InstrumentationLoadTimeWeaver implements LoadTimeWeaver {\n\n\tprivate static final boolean AGENT_CLASS_PRESENT = ClassUtils.isPresent(\n\t\t\t\"org.springframework.instrument.InstrumentationSavingAgent\",\n\t\t\tInstrumentationLoadTimeWeaver.class.getClassLoader());\n\n\n\tprivate final @Nullable ClassLoader classLoader;\n\n\tprivate final @Nullable Instrumentation instrumentation;\n\n\tprivate final List<ClassFileTransformer> transformers = new ArrayList<>(4);\n\n\n\t/**\n\t * Create a new InstrumentationLoadTimeWeaver for the default ClassLoader.\n\t */\n\tpublic InstrumentationLoadTimeWeaver() {\n\t\tthis(ClassUtils.getDefaultClassLoader());\n\t}\n\n\t/**\n\t * Create a new InstrumentationLoadTimeWeaver for the given ClassLoader.\n\t * @param classLoader the ClassLoader that registered transformers are supposed to apply to\n\t */\n\tpublic InstrumentationLoadTimeWeaver(@Nullable ClassLoader classLoader) {\n\t\tthis.classLoader = classLoader;\n\t\tthis.instrumentation = getInstrumentation();\n\t}\n\n\n\t@Override\n\tpublic void addTransformer(ClassFileTransformer transformer) {\n\t\tAssert.notNull(transformer, \"Transformer must not be null\");\n\t\tFilteringClassFileTransformer actualTransformer =\n\t\t\t\tnew FilteringClassFileTransformer(transformer, this.classLoader);\n\t\tsynchronized (this.transformers) {\n\t\t\tAssert.state(this.instrumentation != null,\n\t\t\t\t\t\"Must start with Java agent to use InstrumentationLoadTimeWeaver. See Spring documentation.\");\n\t\t\tthis.instrumentation.addTransformer(actualTransformer);\n\t\t\tthis.transformers.add(actualTransformer);\n\t\t}\n\t}\n\n\t/**\n\t * We have the ability to weave the current class loader when starting the\n\t * JVM in this way, so the instrumentable class loader will always be the\n\t * current loader.\n\t */\n\t@Override\n\tpublic ClassLoader getInstrumentableClassLoader() {\n\t\tAssert.state(this.classLoader != null, \"No ClassLoader available\");\n\t\treturn this.classLoader;\n\t}\n\n\t/**\n\t * This implementation always returns a {@link SimpleThrowawayClassLoader}.\n\t */\n\t@Override\n\tpublic ClassLoader getThrowawayClassLoader() {\n\t\treturn new SimpleThrowawayClassLoader(getInstrumentableClassLoader());\n\t}\n\n\t/**\n\t * Remove all registered transformers, in inverse order of registration.\n\t */\n\tpublic void removeTransformers() {\n\t\tsynchronized (this.transformers) {\n\t\t\tif (this.instrumentation != null && !this.transformers.isEmpty()) {\n\t\t\t\tfor (int i = this.transformers.size() - 1; i >= 0; i--) {\n\t\t\t\t\tthis.instrumentation.removeTransformer(this.transformers.get(i));\n\t\t\t\t}\n\t\t\t\tthis.transformers.clear();\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Check whether an Instrumentation instance is available for the current VM.\n\t * @see #getInstrumentation()\n\t */\n\tpublic static boolean isInstrumentationAvailable() {\n\t\treturn (getInstrumentation() != null);\n\t}\n\n\t/**\n\t * Obtain the Instrumentation instance for the current VM, if available.\n\t * @return the Instrumentation instance, or {@code null} if none found\n\t * @see #isInstrumentationAvailable()\n\t */\n\tprivate static @Nullable Instrumentation getInstrumentation() {\n\t\tif (AGENT_CLASS_PRESENT) {\n\t\t\treturn InstrumentationAccessor.getInstrumentation();\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * Inner class to avoid InstrumentationSavingAgent dependency.\n\t */\n\tprivate static class InstrumentationAccessor {\n\n\t\tpublic static Instrumentation getInstrumentation() {\n\t\t\treturn InstrumentationSavingAgent.getInstrumentation();\n\t\t}\n\t}\n\n\n\t/**\n\t * Decorator that only applies the given target transformer to a specific ClassLoader.\n\t */\n\tprivate static class FilteringClassFileTransformer implements ClassFileTransformer {\n\n\t\tprivate final ClassFileTransformer targetTransformer;\n\n\t\tprivate final @Nullable ClassLoader targetClassLoader;\n\n\t\tpublic FilteringClassFileTransformer(\n\t\t\t\tClassFileTransformer targetTransformer, @Nullable ClassLoader targetClassLoader) {\n\n\t\t\tthis.targetTransformer = targetTransformer;\n\t\t\tthis.targetClassLoader = targetClassLoader;\n\t\t}\n\n\t\t@Override\n\t\tpublic byte @Nullable [] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,\n\t\t\t\tProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n\n\t\t\tif (this.targetClassLoader != loader) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn this.targetTransformer.transform(\n\t\t\t\t\tloader, className, classBeingRedefined, protectionDomain, classfileBuffer);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"FilteringClassFileTransformer for: \" + this.targetTransformer.toString();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver#addTransformer(transformer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transformer"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "void",
    "signature": "public void addTransformer(ClassFileTransformer transformer)",
    "source_code": "\tpublic void addTransformer(ClassFileTransformer transformer) {\n\t\tAssert.notNull(transformer, \"Transformer must not be null\");\n\t\tFilteringClassFileTransformer actualTransformer =\n\t\t\t\tnew FilteringClassFileTransformer(transformer, this.classLoader);\n\t\tsynchronized (this.transformers) {\n\t\t\tAssert.state(this.instrumentation != null,\n\t\t\t\t\t\"Must start with Java agent to use InstrumentationLoadTimeWeaver. See Spring documentation.\");\n\t\t\tthis.instrumentation.addTransformer(actualTransformer);\n\t\t\tthis.transformers.add(actualTransformer);\n\t\t}\n\t}"
  },
  "org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver#getInstrumentableClassLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * We have the ability to weave the current class loader when starting the\n\t * JVM in this way, so the instrumentable class loader will always be the\n\t * current loader.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "ClassLoader",
    "signature": "public ClassLoader getInstrumentableClassLoader()",
    "source_code": "\tpublic ClassLoader getInstrumentableClassLoader() {\n\t\tAssert.state(this.classLoader != null, \"No ClassLoader available\");\n\t\treturn this.classLoader;\n\t}"
  },
  "org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver#getInstrumentation()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "Instrumentation",
    "signature": "public Instrumentation getInstrumentation()",
    "source_code": "\t\tpublic static Instrumentation getInstrumentation() {\n\t\t\treturn InstrumentationSavingAgent.getInstrumentation();\n\t\t}"
  },
  "org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver#getThrowawayClassLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation always returns a {@link SimpleThrowawayClassLoader}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "ClassLoader",
    "signature": "public ClassLoader getThrowawayClassLoader()",
    "source_code": "\tpublic ClassLoader getThrowawayClassLoader() {\n\t\treturn new SimpleThrowawayClassLoader(getInstrumentableClassLoader());\n\t}"
  },
  "org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver#isInstrumentationAvailable()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether an Instrumentation instance is available for the current VM.\n\t * @see #getInstrumentation()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "boolean",
    "signature": "public boolean isInstrumentationAvailable()",
    "source_code": "\tpublic static boolean isInstrumentationAvailable() {\n\t\treturn (getInstrumentation() != null);\n\t}"
  },
  "org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver#removeTransformers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Remove all registered transformers, in inverse order of registration.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void removeTransformers()",
    "source_code": "\tpublic void removeTransformers() {\n\t\tsynchronized (this.transformers) {\n\t\t\tif (this.instrumentation != null && !this.transformers.isEmpty()) {\n\t\t\t\tfor (int i = this.transformers.size() - 1; i >= 0; i--) {\n\t\t\t\t\tthis.instrumentation.removeTransformer(this.transformers.get(i));\n\t\t\t\t}\n\t\t\t\tthis.transformers.clear();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn \"FilteringClassFileTransformer for: \" + this.targetTransformer.toString();\n\t\t}"
  },
  "org.springframework.jdbc.core.DataClassRowMapper": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link RowMapper} implementation that converts a row into a new instance\n * of the specified mapped target class. The mapped target class must be a\n * top-level class or {@code static} nested class, and it may expose either a\n * <em>data class</em> constructor with named parameters corresponding to column\n * names or classic bean property setter methods with property names corresponding\n * to column names (or even a combination of both).\n *\n * <p>The term \"data class\" applies to Java <em>records</em>, Kotlin <em>data\n * classes</em>, and any class which has a constructor with named parameters\n * that are intended to be mapped to corresponding column names.\n *\n * <p>When combining a data class constructor with setter methods, any property\n * mapped successfully via a constructor argument will not be mapped additionally\n * via a corresponding setter method. This means that constructor arguments take\n * precedence over property setter methods.\n *\n * <p>Note that this class extends {@link BeanPropertyRowMapper} and can\n * therefore serve as a common choice for any mapped target class, flexibly\n * adapting to constructor style versus setter methods in the mapped class.\n *\n * <p>Please note that this class is designed to provide convenience rather than\n * high performance. For best performance, consider using a custom {@code RowMapper}\n * implementation.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 5.3\n * @param <T> the result type\n * @see SimplePropertyRowMapper\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "signature": "public class DataClassRowMapper",
    "source_code": "public class DataClassRowMapper<T> extends BeanPropertyRowMapper<T> {\n\n\tprivate @Nullable Constructor<T> mappedConstructor;\n\n\tprivate @Nullable String @Nullable [] constructorParameterNames;\n\n\tprivate TypeDescriptor @Nullable [] constructorParameterTypes;\n\n\n\t/**\n\t * Create a new {@code DataClassRowMapper} for bean-style configuration.\n\t * @see #setMappedClass\n\t * @see #setConversionService\n\t */\n\tpublic DataClassRowMapper() {\n\t}\n\n\t/**\n\t * Create a new {@code DataClassRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t */\n\tpublic DataClassRowMapper(Class<T> mappedClass) {\n\t\tsuper(mappedClass);\n\t}\n\n\n\t@Override\n\tprotected void initialize(Class<T> mappedClass) {\n\t\tsuper.initialize(mappedClass);\n\n\t\tthis.mappedConstructor = BeanUtils.getResolvableConstructor(mappedClass);\n\t\tint paramCount = this.mappedConstructor.getParameterCount();\n\t\tif (paramCount > 0) {\n\t\t\tthis.constructorParameterNames = BeanUtils.getParameterNames(this.mappedConstructor);\n\t\t\tfor (String name : this.constructorParameterNames) {\n\t\t\t\tsuppressProperty(name);\n\t\t\t}\n\t\t\tthis.constructorParameterTypes = new TypeDescriptor[paramCount];\n\t\t\tfor (int i = 0; i < paramCount; i++) {\n\t\t\t\tthis.constructorParameterTypes[i] = new TypeDescriptor(new MethodParameter(this.mappedConstructor, i));\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tprotected T constructMappedInstance(ResultSet rs, TypeConverter tc) throws SQLException {\n\t\tAssert.state(this.mappedConstructor != null, \"Mapped constructor was not initialized\");\n\n\t\t@Nullable Object[] args;\n\t\tif (this.constructorParameterNames != null && this.constructorParameterTypes != null) {\n\t\t\targs = new Object[this.constructorParameterNames.length];\n\t\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\t\tString name = this.constructorParameterNames[i];\n\t\t\t\tint index;\n\t\t\t\ttry {\n\t\t\t\t\t// Try direct name match first\n\t\t\t\t\tindex = rs.findColumn(lowerCaseName(name));\n\t\t\t\t}\n\t\t\t\tcatch (SQLException ex) {\n\t\t\t\t\t// Try underscored name match instead\n\t\t\t\t\tindex = rs.findColumn(underscoreName(name));\n\t\t\t\t}\n\t\t\t\tTypeDescriptor td = this.constructorParameterTypes[i];\n\t\t\t\tObject value = getColumnValue(rs, index, td.getType());\n\t\t\t\targs[i] = tc.convertIfNecessary(value, td.getType(), td);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\targs = new Object[0];\n\t\t}\n\n\t\treturn BeanUtils.instantiateClass(this.mappedConstructor, args);\n\t}\n\n\n\t/**\n\t * Static factory method to create a new {@code DataClassRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @see #newInstance(Class, ConversionService)\n\t */\n\tpublic static <T> DataClassRowMapper<T> newInstance(Class<T> mappedClass) {\n\t\treturn new DataClassRowMapper<>(mappedClass);\n\t}\n\n\t/**\n\t * Static factory method to create a new {@code DataClassRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param conversionService the {@link ConversionService} for binding\n\t * JDBC values to bean properties, or {@code null} for none\n\t * @see #newInstance(Class)\n\t * @see #setConversionService\n\t */\n\tpublic static <T> DataClassRowMapper<T> newInstance(\n\t\t\tClass<T> mappedClass, @Nullable ConversionService conversionService) {\n\n\t\tDataClassRowMapper<T> rowMapper = newInstance(mappedClass);\n\t\trowMapper.setConversionService(conversionService);\n\t\treturn rowMapper;\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.DataClassRowMapper#constructMappedInstance(rs,tc)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "tc"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "T",
    "signature": "protected T constructMappedInstance(ResultSet rs, TypeConverter tc)",
    "source_code": "\tprotected T constructMappedInstance(ResultSet rs, TypeConverter tc) throws SQLException {\n\t\tAssert.state(this.mappedConstructor != null, \"Mapped constructor was not initialized\");\n\n\t\t@Nullable Object[] args;\n\t\tif (this.constructorParameterNames != null && this.constructorParameterTypes != null) {\n\t\t\targs = new Object[this.constructorParameterNames.length];\n\t\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\t\tString name = this.constructorParameterNames[i];\n\t\t\t\tint index;\n\t\t\t\ttry {\n\t\t\t\t\t// Try direct name match first\n\t\t\t\t\tindex = rs.findColumn(lowerCaseName(name));\n\t\t\t\t}\n\t\t\t\tcatch (SQLException ex) {\n\t\t\t\t\t// Try underscored name match instead\n\t\t\t\t\tindex = rs.findColumn(underscoreName(name));\n\t\t\t\t}\n\t\t\t\tTypeDescriptor td = this.constructorParameterTypes[i];\n\t\t\t\tObject value = getColumnValue(rs, index, td.getType());\n\t\t\t\targs[i] = tc.convertIfNecessary(value, td.getType(), td);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\targs = new Object[0];\n\t\t}\n\n\t\treturn BeanUtils.instantiateClass(this.mappedConstructor, args);\n\t}"
  },
  "org.springframework.jdbc.core.DataClassRowMapper#initialize(mappedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mappedClass"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "void",
    "signature": "protected void initialize(Class<T> mappedClass)",
    "source_code": "\tprotected void initialize(Class<T> mappedClass) {\n\t\tsuper.initialize(mappedClass);\n\n\t\tthis.mappedConstructor = BeanUtils.getResolvableConstructor(mappedClass);\n\t\tint paramCount = this.mappedConstructor.getParameterCount();\n\t\tif (paramCount > 0) {\n\t\t\tthis.constructorParameterNames = BeanUtils.getParameterNames(this.mappedConstructor);\n\t\t\tfor (String name : this.constructorParameterNames) {\n\t\t\t\tsuppressProperty(name);\n\t\t\t}\n\t\t\tthis.constructorParameterTypes = new TypeDescriptor[paramCount];\n\t\t\tfor (int i = 0; i < paramCount; i++) {\n\t\t\t\tthis.constructorParameterTypes[i] = new TypeDescriptor(new MethodParameter(this.mappedConstructor, i));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.DataClassRowMapper#newInstance(mappedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new {@code DataClassRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @see #newInstance(Class, ConversionService)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "DataClassRowMapper<T>",
    "signature": "public DataClassRowMapper<T> newInstance(Class<T> mappedClass)",
    "source_code": "\tpublic static <T> DataClassRowMapper<T> newInstance(Class<T> mappedClass) {\n\t\treturn new DataClassRowMapper<>(mappedClass);\n\t}"
  },
  "org.springframework.jdbc.core.DataClassRowMapper#newInstance(mappedClass,conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new {@code DataClassRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param conversionService the {@link ConversionService} for binding\n\t * JDBC values to bean properties, or {@code null} for none\n\t * @see #newInstance(Class)\n\t * @see #setConversionService\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "DataClassRowMapper<T>",
    "signature": "public DataClassRowMapper<T> newInstance(Class<T> mappedClass, @Nullable ConversionService conversionService)",
    "source_code": "\tpublic static <T> DataClassRowMapper<T> newInstance("
  },
  "org.springframework.jdbc.core.JdbcOperations": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Interface specifying a basic set of JDBC operations.\n *\n * <p>Implemented by {@link JdbcTemplate}. Not often used directly, but a useful\n * option to enhance testability, as it can easily be mocked or stubbed.\n *\n * <p>Alternatively, the standard JDBC infrastructure can be mocked.\n * However, mocking this interface constitutes significantly less work.\n * As an alternative to a mock objects approach to testing data access code,\n * consider the powerful integration testing support provided via the\n * <em>Spring TestContext Framework</em>, in the {@code spring-test} artifact.\n *\n * <p><b>NOTE: As of 6.1, there is a unified JDBC access facade available in\n * the form of {@link org.springframework.jdbc.core.simple.JdbcClient}.</b>\n * {@code JdbcClient} provides a fluent API style for common JDBC queries/updates\n * with flexible use of indexed or named parameters. It delegates to\n * {@code JdbcOperations}/{@code NamedParameterJdbcOperations} for actual execution.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @see JdbcTemplate\n * @see org.springframework.jdbc.core.namedparam.NamedParameterJdbcOperations\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "signature": "public interface JdbcOperations",
    "source_code": "public interface JdbcOperations {\n\n\t//-------------------------------------------------------------------------\n\t// Methods dealing with a plain java.sql.Connection\n\t//-------------------------------------------------------------------------\n\n\t/**\n\t * Execute a JDBC data access operation, implemented as callback action\n\t * working on a JDBC Connection. This allows for implementing arbitrary\n\t * data access operations, within Spring's managed JDBC environment:\n\t * that is, participating in Spring-managed transactions and converting\n\t * JDBC SQLExceptions into Spring's DataAccessException hierarchy.\n\t * <p>The callback action can return a result object, for example a domain\n\t * object or a collection of domain objects.\n\t * @param action a callback object that specifies the action\n\t * @return a result object returned by the action, or {@code null} if none\n\t * @throws DataAccessException if there is any problem\n\t */\n\t<T> @Nullable T execute(ConnectionCallback<T> action) throws DataAccessException;\n\n\n\t//-------------------------------------------------------------------------\n\t// Methods dealing with static SQL (java.sql.Statement)\n\t//-------------------------------------------------------------------------\n\n\t/**\n\t * Execute a JDBC data access operation, implemented as callback action\n\t * working on a JDBC Statement. This allows for implementing arbitrary data\n\t * access operations on a single Statement, within Spring's managed JDBC\n\t * environment: that is, participating in Spring-managed transactions and\n\t * converting JDBC SQLExceptions into Spring's DataAccessException hierarchy.\n\t * <p>The callback action can return a result object, for example a domain\n\t * object or a collection of domain objects.\n\t * @param action a callback that specifies the action\n\t * @return a result object returned by the action, or {@code null} if none\n\t * @throws DataAccessException if there is any problem\n\t */\n\t<T> @Nullable T execute(StatementCallback<T> action) throws DataAccessException;\n\n\t/**\n\t * Issue a single SQL execute, typically a DDL statement.\n\t * @param sql static SQL to execute\n\t * @throws DataAccessException if there is any problem\n\t */\n\tvoid execute(String sql) throws DataAccessException;\n\n\t/**\n\t * Execute a query given static SQL, reading the ResultSet with a\n\t * ResultSetExtractor.\n\t * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to\n\t * execute a static query with a PreparedStatement, use the overloaded\n\t * {@code query} method with {@code null} as argument array.\n\t * @param sql the SQL query to execute\n\t * @param rse a callback that will extract all rows of results\n\t * @return an arbitrary result object, as returned by the ResultSetExtractor\n\t * @throws DataAccessException if there is any problem executing the query\n\t * @see #query(String, ResultSetExtractor, Object...)\n\t */\n\t<T> @Nullable T query(String sql, ResultSetExtractor<T> rse) throws DataAccessException;\n\n\t/**\n\t * Execute a query given static SQL, reading the ResultSet on a per-row\n\t * basis with a RowCallbackHandler.\n\t * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to\n\t * execute a static query with a PreparedStatement, use the overloaded\n\t * {@code query} method with {@code null} as argument array.\n\t * @param sql the SQL query to execute\n\t * @param rch a callback that will extract results, one row at a time\n\t * @throws DataAccessException if there is any problem executing the query\n\t * @see #query(String, RowCallbackHandler, Object...)\n\t */\n\tvoid query(String sql, RowCallbackHandler rch) throws DataAccessException;\n\n\t/**\n\t * Execute a query given static SQL, mapping each row to a result object\n\t * via a RowMapper.\n\t * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to\n\t * execute a static query with a PreparedStatement, use the overloaded\n\t * {@code query} method with {@code null} as argument array.\n\t * @param sql the SQL query to execute\n\t * @param rowMapper a callback that will map one object per row\n\t * @return the result List, containing mapped objects\n\t * @throws DataAccessException if there is any problem executing the query\n\t * @see #query(String, RowMapper, Object...)\n\t */\n\t<T> List<T> query(String sql, RowMapper<T> rowMapper) throws DataAccessException;\n\n\t/**\n\t * Execute a query given static SQL, mapping each row to a result object\n\t * via a RowMapper, and turning it into an iterable and closeable Stream.\n\t * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to\n\t * execute a static query with a PreparedStatement, use the overloaded\n\t * {@code query} method with {@code null} as argument array.\n\t * @param sql the SQL query to execute\n\t * @param rowMapper a callback that will map one object per row\n\t * @return the result Stream, containing mapped objects, needing to be\n\t * closed once fully processed (for example, through a try-with-resources clause)\n\t * @throws DataAccessException if there is any problem executing the query\n\t * @since 5.3\n\t * @see #queryForStream(String, RowMapper, Object...)\n\t */\n\t<T> Stream<T> queryForStream(String sql, RowMapper<T> rowMapper) throws DataAccessException;\n\n\t/**\n\t * Execute a query given static SQL, mapping a single result row to a\n\t * result object via a RowMapper.\n\t * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to\n\t * execute a static query with a PreparedStatement, use the overloaded\n\t * {@link #queryForObject(String, RowMapper, Object...)} method with\n\t * {@code null} as argument array.\n\t * @param sql the SQL query to execute\n\t * @param rowMapper a callback that will map one object per row\n\t * @return the single mapped object (may be {@code null} if the given\n\t * {@link RowMapper} returned {@code} null)\n\t * @throws org.springframework.dao.IncorrectResultSizeDataAccessException\n\t * if the query does not return exactly one row\n\t * @throws DataAccessException if there is any problem executing the query\n\t * @see #queryForObject(String, RowMapper, Object...)\n\t */\n\t<T> @Nullable T queryForObject(String sql, RowMapper<T> rowMapper) throws DataAccessException;\n\n\t/**\n\t * Execute a query for a result object, given static SQL.\n\t * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to\n\t * execute a static query with a PreparedStatement, use the overloaded\n\t * {@link #queryForObject(String, Class, Object...)} method with\n\t * {@code null} as argument array.\n\t * <p>This method is useful for running static SQL with a known outcome.\n\t * The query is expected to be a single row/single column query; the returned\n\t * result will be directly mapped to the corresponding object type.\n\t * @param sql the SQL query to execute\n\t * @param requiredType the type that the result object is expected to match\n\t * @return the result object of the required type, or {@code null} in case of SQL NULL\n\t * @throws org.springframework.dao.IncorrectResultSizeDataAccessException\n\t * if the query does not return exactly one row\n\t * @throws org.springframework.jdbc.IncorrectResultSetColumnCountException\n\t * if the query does not return a row containing a single column\n\t * @throws DataAccessException if there is any problem executing the query\n\t * @see #queryForObject(String, Class, Object...)\n\t */\n\t<T> @Nullable T queryForObject(String sql, Class<T> requiredType) throws DataAccessException;\n\n\t/**\n\t * Execute a query for a result map, given static SQL.\n\t * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to\n\t * execute a static query with a PreparedStatement, use the overloaded\n\t * {@link #queryForMap(String, Object...)} method with {@code null}\n\t * as argument array.\n\t * <p>The query is expected to be a single row query; the result row will be\n\t * mapped to a Map (one entry for each column, using the column name as the key).\n\t * @param sql the SQL query to execute\n\t * @return the result Map (one entry per column, with column name as key)\n\t * @throws org.springframework.dao.IncorrectResultSizeDataAccessException\n\t * if the query does not return exactly one row\n\t * @throws DataAccessException if there is any problem executing the query\n\t * @see #queryForMap(String, Object...)\n\t * @see ColumnMapRowMapper\n\t */\n\tMap<String, Object> queryForMap(String sql) throws DataAccessException;\n\n\t/**\n\t * Execute a query for a result list, given static SQL.\n\t * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to\n\t * execute a static query with a PreparedStatement, use the overloaded\n\t * {@code queryForList} method with {@code null} as argument array.\n\t * <p>The results will be mapped to a List (one entry for each row) of\n\t * result objects, each of them matching the specified element type.\n\t * @param sql the SQL query to execute\n\t * @param elementType the required type of element in the result list\n\t * (for example, {@code Integer.class})\n\t * @return a List of objects that match the specified element type\n\t * @throws DataAccessException if there is any problem executing the query\n\t * @see #queryForList(String, Class, Object...)\n\t * @see SingleColumnRowMapper\n\t */\n\t<T> List<T> queryForList(String sql, Class<T> elementType) throws DataAccessException;\n\n\t/**\n\t * Execute a query for a result list, given static SQL.\n\t * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to\n\t * execute a static query with a PreparedStatement, use the overloaded\n\t * {@code queryForList} method with {@code null} as argument array.\n\t * <p>The results will be mapped to a List (one entry for each row) of\n\t * Maps (one entry for each column using the column name as the key).\n\t * Each element in the list will be of the form returned by this interface's\n\t * {@code queryForMap} methods.\n\t * @param sql the SQL query to execute\n\t * @return a List that contains a Map per row\n\t * @throws DataAccessException if there is any problem executing the query\n\t * @see #queryForList(String, Object...)\n\t */\n\tList<Map<String, Object>> queryForList(String sql) throws DataAccessException;\n\n\t/**\n\t * Execute a query for an SqlRowSet, given static SQL.\n\t * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to\n\t * execute a static query with a PreparedStatement, use the overloaded\n\t * {@code queryForRowSet} method with {@code null} as argument array.\n\t * <p>The results will be mapped to an SqlRowSet which holds the data in a\n\t * disconnected fashion. This wrapper will translate any SQLExceptions thrown.\n\t * <p>Note that, for the default implementation, JDBC RowSet support needs to\n\t * be available at runtime: by default, a standard JDBC {@code CachedRowSet}\n\t * is used.\n\t * @param sql the SQL query to execute\n\t * @return an SqlRowSet representation (possibly a wrapper around a\n\t * {@code javax.sql.rowset.CachedRowSet})\n\t * @throws DataAccessException if there is any problem executing the query\n\t * @see #queryForRowSet(String, Object...)\n\t * @see SqlRowSetResultSetExtractor\n\t * @see javax.sql.rowset.CachedRowSet\n\t */\n\tSqlRowSet queryForRowSet(String sql) throws DataAccessException;\n\n\t/**\n\t * Issue a single SQL update operation (such as an insert, update or delete statement).\n\t * @param sql static SQL to execute\n\t * @return the number of rows affected\n\t * @throws DataAccessException if there is any problem.\n\t */\n\tint update(String sql) throws DataAccessException;\n\n\t/**\n\t * Issue multiple SQL updates on a single JDBC Statement using batching.\n\t * <p>Will fall back to separate updates on a single Statement if the JDBC\n\t * driver does not support batch updates.\n\t * @param sql defining an array of SQL statements that will be executed.\n\t * @return an array of the number of rows affected by each statement\n\t * @throws DataAccessException if there is any problem executing the batch\n\t */\n\tint[] batchUpdate(String... sql) throws DataAccessException;\n\n\n\t//-------------------------------------------------------------------------\n\t// Methods dealing with prepared statements\n\t//-------------------------------------------------------------------------\n\n\t/**\n\t * Execute a JDBC data access operation, implemented as callback action\n\t * working on a JDBC PreparedStatement. This allows for implementing arbitrary\n\t * data access operations on a single Statement, within Spring's managed JDBC\n\t * environment: that is, participating in Spring-managed transactions and\n\t * converting JDBC SQLExceptions into Spring's DataAccessException hierarchy.\n\t * <p>The callback action can return a result object, for example a domain\n\t * object or a collection of domain objects.\n\t * @param psc a callback that creates a PreparedStatement given a Connection\n\t * @param action a callback that specifies the action\n\t * @return a result object returned by the action, or {@code null} if none\n\t * @throws DataAccessException if there is any problem\n\t */\n\t<T> @Nullable T execute(PreparedStatementCreator psc, PreparedStatementCallback<T> action) throws DataAccessException;\n\n\t/**\n\t * Execute a JDBC data access operation, implemented as callback action\n\t * working on a JDBC PreparedStatement. This allows for implementing arbitrary\n\t * data access operations on a single Statement, within Spring's managed JDBC\n\t * environment: that is, participating in Spring-managed transactions and\n\t * converting JDBC SQLExceptions into Spring's DataAccessException hierarchy.\n\t * <p>The callback action can return a result object, for example a domain\n\t * object or a collection of domain objects.\n\t * @param sql the SQL to execute\n\t * @param action a callback that specifies the action\n\t * @return a result object returned by the action, or {@code null} if none\n\t * @throws DataAccessException if there is any problem\n\t */\n\t<T> @Nullable T execute(String sql, PreparedStatementCallback<T> action) throws DataAccessException;\n\n\t/**\n\t * Query using a prepared statement, reading the ResultSet with a ResultSetExtractor.\n\t * <p>A PreparedStatementCreator can either be implemented directly or\n\t * configured through a PreparedStatementCreatorFactory.\n\t * @param psc a callback that creates a PreparedStatement given a Connection\n\t * @param rse a callback that will extract results\n\t * @return an arbitrary result object, as returned by the ResultSetExtractor\n\t * @throws DataAccessException if there is any problem\n\t * @see PreparedStatementCreatorFactory\n\t */\n\t<T> @Nullable T query(PreparedStatementCreator psc, ResultSetExtractor<T> rse) throws DataAccessException;\n\n\t/**\n\t * Query using a prepared statement, reading the ResultSet with a ResultSetExtractor.\n\t * @param sql the SQL query to execute\n\t * @param pss a callback that knows how to set values on the prepared statement.\n\t * If this is {@code null}, the SQL will be assumed to contain no bind parameters.\n\t * Even if there are no bind parameters, this callback may be used to set the\n\t * fetch size and other performance options.\n\t * @param rse a callback that will extract results\n\t * @return an arbitrary result object, as returned by the ResultSetExtractor\n\t * @throws DataAccessException if there is any problem\n\t */\n\t<T> @Nullable T query(String sql, @Nullable PreparedStatementSetter pss, ResultSetExtractor<T> rse)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of arguments\n\t * to bind to the query, reading the ResultSet with a ResultSetExtractor.\n\t * @param sql the SQL query to execute\n\t * @param args arguments to bind to the query\n\t * @param argTypes the SQL types of the arguments\n\t * (constants from {@code java.sql.Types})\n\t * @param rse a callback that will extract results\n\t * @return an arbitrary result object, as returned by the ResultSetExtractor\n\t * @throws DataAccessException if the query fails\n\t * @see java.sql.Types\n\t */\n\t<T> @Nullable T query(String sql, @Nullable Object @Nullable [] args, int[] argTypes, ResultSetExtractor<T> rse) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of arguments\n\t * to bind to the query, reading the ResultSet with a ResultSetExtractor.\n\t * @param sql the SQL query to execute\n\t * @param args arguments to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type);\n\t * may also contain {@link SqlParameterValue} objects which indicate not\n\t * only the argument value but also the SQL type and optionally the scale\n\t * @param rse a callback that will extract results\n\t * @return an arbitrary result object, as returned by the ResultSetExtractor\n\t * @throws DataAccessException if the query fails\n\t * @deprecated as of 5.3, in favor of {@link #query(String, ResultSetExtractor, Object...)}\n\t */\n\t@Deprecated\n\t<T> @Nullable T query(String sql, @Nullable Object @Nullable [] args, ResultSetExtractor<T> rse) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of arguments\n\t * to bind to the query, reading the ResultSet with a ResultSetExtractor.\n\t * @param sql the SQL query to execute\n\t * @param rse a callback that will extract results\n\t * @param args arguments to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type);\n\t * may also contain {@link SqlParameterValue} objects which indicate not\n\t * only the argument value but also the SQL type and optionally the scale\n\t * @return an arbitrary result object, as returned by the ResultSetExtractor\n\t * @throws DataAccessException if the query fails\n\t * @since 3.0.1\n\t */\n\t<T> @Nullable T query(String sql, ResultSetExtractor<T> rse, @Nullable Object @Nullable ... args) throws DataAccessException;\n\n\t/**\n\t * Query using a prepared statement, reading the ResultSet on a per-row basis\n\t * with a RowCallbackHandler.\n\t * <p>A PreparedStatementCreator can either be implemented directly or\n\t * configured through a PreparedStatementCreatorFactory.\n\t * @param psc a callback that creates a PreparedStatement given a Connection\n\t * @param rch a callback that will extract results, one row at a time\n\t * @throws DataAccessException if there is any problem\n\t * @see PreparedStatementCreatorFactory\n\t */\n\tvoid query(PreparedStatementCreator psc, RowCallbackHandler rch) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a\n\t * PreparedStatementSetter implementation that knows how to bind values to the\n\t * query, reading the ResultSet on a per-row basis with a RowCallbackHandler.\n\t * @param sql the SQL query to execute\n\t * @param pss a callback that knows how to set values on the prepared statement.\n\t * If this is {@code null}, the SQL will be assumed to contain no bind parameters.\n\t * Even if there are no bind parameters, this callback may be used to set the\n\t * fetch size and other performance options.\n\t * @param rch a callback that will extract results, one row at a time\n\t * @throws DataAccessException if the query fails\n\t */\n\tvoid query(String sql, @Nullable PreparedStatementSetter pss, RowCallbackHandler rch) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, reading the ResultSet on a per-row basis\n\t * with a RowCallbackHandler.\n\t * @param sql the SQL query to execute\n\t * @param args arguments to bind to the query\n\t * @param argTypes the SQL types of the arguments\n\t * (constants from {@code java.sql.Types})\n\t * @param rch a callback that will extract results, one row at a time\n\t * @throws DataAccessException if the query fails\n\t * @see java.sql.Types\n\t */\n\tvoid query(String sql, @Nullable Object @Nullable [] args, int[] argTypes, RowCallbackHandler rch) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, reading the ResultSet on a per-row basis\n\t * with a RowCallbackHandler.\n\t * @param sql the SQL query to execute\n\t * @param args arguments to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type);\n\t * may also contain {@link SqlParameterValue} objects which indicate not\n\t * only the argument value but also the SQL type and optionally the scale\n\t * @param rch a callback that will extract results, one row at a time\n\t * @throws DataAccessException if the query fails\n\t * @deprecated as of 5.3, in favor of {@link #query(String, RowCallbackHandler, Object...)}\n\t */\n\t@Deprecated\n\tvoid query(String sql, @Nullable Object @Nullable [] args, RowCallbackHandler rch) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, reading the ResultSet on a per-row basis\n\t * with a RowCallbackHandler.\n\t * @param sql the SQL query to execute\n\t * @param rch a callback that will extract results, one row at a time\n\t * @param args arguments to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type);\n\t * may also contain {@link SqlParameterValue} objects which indicate not\n\t * only the argument value but also the SQL type and optionally the scale\n\t * @throws DataAccessException if the query fails\n\t * @since 3.0.1\n\t */\n\tvoid query(String sql, RowCallbackHandler rch, @Nullable Object @Nullable ... args) throws DataAccessException;\n\n\t/**\n\t * Query using a prepared statement, mapping each row to a result object\n\t * via a RowMapper.\n\t * <p>A PreparedStatementCreator can either be implemented directly or\n\t * configured through a PreparedStatementCreatorFactory.\n\t * @param psc a callback that creates a PreparedStatement given a Connection\n\t * @param rowMapper a callback that will map one object per row\n\t * @return the result List, containing mapped objects\n\t * @throws DataAccessException if there is any problem\n\t * @see PreparedStatementCreatorFactory\n\t */\n\t<T> List<T> query(PreparedStatementCreator psc, RowMapper<T> rowMapper) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a\n\t * PreparedStatementSetter implementation that knows how to bind values\n\t * to the query, mapping each row to a result object via a RowMapper.\n\t * @param sql the SQL query to execute\n\t * @param pss a callback that knows how to set values on the prepared statement.\n\t * If this is {@code null}, the SQL will be assumed to contain no bind parameters.\n\t * Even if there are no bind parameters, this callback may be used to set the\n\t * fetch size and other performance options.\n\t * @param rowMapper a callback that will map one object per row\n\t * @return the result List, containing mapped objects\n\t * @throws DataAccessException if the query fails\n\t */\n\t<T> List<T> query(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, mapping each row to a result object\n\t * via a RowMapper.\n\t * @param sql the SQL query to execute\n\t * @param args arguments to bind to the query\n\t * @param argTypes the SQL types of the arguments\n\t * (constants from {@code java.sql.Types})\n\t * @param rowMapper a callback that will map one object per row\n\t * @return the result List, containing mapped objects\n\t * @throws DataAccessException if the query fails\n\t * @see java.sql.Types\n\t */\n\t<T> List<T> query(String sql, @Nullable Object @Nullable [] args, int[] argTypes, RowMapper<T> rowMapper) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, mapping each row to a result object\n\t * via a RowMapper.\n\t * @param sql the SQL query to execute\n\t * @param args arguments to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type);\n\t * may also contain {@link SqlParameterValue} objects which indicate not\n\t * only the argument value but also the SQL type and optionally the scale\n\t * @param rowMapper a callback that will map one object per row\n\t * @return the result List, containing mapped objects\n\t * @throws DataAccessException if the query fails\n\t * @deprecated as of 5.3, in favor of {@link #query(String, RowMapper, Object...)}\n\t */\n\t@Deprecated\n\t<T> List<T> query(String sql, @Nullable Object @Nullable [] args, RowMapper<T> rowMapper) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, mapping each row to a result object\n\t * via a RowMapper.\n\t * @param sql the SQL query to execute\n\t * @param rowMapper a callback that will map one object per row\n\t * @param args arguments to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type);\n\t * may also contain {@link SqlParameterValue} objects which indicate not\n\t * only the argument value but also the SQL type and optionally the scale\n\t * @return the result List, containing mapped objects\n\t * @throws DataAccessException if the query fails\n\t * @since 3.0.1\n\t */\n\t<T> List<T> query(String sql, RowMapper<T> rowMapper, @Nullable Object @Nullable ... args) throws DataAccessException;\n\n\t/**\n\t * Query using a prepared statement, mapping each row to a result object\n\t * via a RowMapper, and turning it into an iterable and closeable Stream.\n\t * <p>A PreparedStatementCreator can either be implemented directly or\n\t * configured through a PreparedStatementCreatorFactory.\n\t * @param psc a callback that creates a PreparedStatement given a Connection\n\t * @param rowMapper a callback that will map one object per row\n\t * @return the result Stream, containing mapped objects, needing to be\n\t * closed once fully processed (for example, through a try-with-resources clause)\n\t * @throws DataAccessException if there is any problem\n\t * @see PreparedStatementCreatorFactory\n\t * @since 5.3\n\t */\n\t<T> Stream<T> queryForStream(PreparedStatementCreator psc, RowMapper<T> rowMapper) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a\n\t * PreparedStatementSetter implementation that knows how to bind values\n\t * to the query, mapping each row to a result object via a RowMapper,\n\t * and turning it into an iterable and closeable Stream.\n\t * @param sql the SQL query to execute\n\t * @param pss a callback that knows how to set values on the prepared statement.\n\t * If this is {@code null}, the SQL will be assumed to contain no bind parameters.\n\t * Even if there are no bind parameters, this callback may be used to set the\n\t * fetch size and other performance options.\n\t * @param rowMapper a callback that will map one object per row\n\t * @return the result Stream, containing mapped objects, needing to be\n\t * closed once fully processed (for example, through a try-with-resources clause)\n\t * @throws DataAccessException if the query fails\n\t * @since 5.3\n\t */\n\t<T> Stream<T> queryForStream(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, mapping each row to a result object\n\t * via a RowMapper, and turning it into an iterable and closeable Stream.\n\t * @param sql the SQL query to execute\n\t * @param rowMapper a callback that will map one object per row\n\t * @param args arguments to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type);\n\t * may also contain {@link SqlParameterValue} objects which indicate not\n\t * only the argument value but also the SQL type and optionally the scale\n\t * @return the result Stream, containing mapped objects, needing to be\n\t * closed once fully processed (for example, through a try-with-resources clause)\n\t * @throws DataAccessException if the query fails\n\t * @since 5.3\n\t */\n\t<T> Stream<T> queryForStream(String sql, RowMapper<T> rowMapper, @Nullable Object @Nullable ... args)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list\n\t * of arguments to bind to the query, mapping a single result row to a\n\t * result object via a RowMapper.\n\t * @param sql the SQL query to execute\n\t * @param args arguments to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type)\n\t * @param argTypes the SQL types of the arguments\n\t * (constants from {@code java.sql.Types})\n\t * @param rowMapper a callback that will map one object per row\n\t * @return the single mapped object (may be {@code null} if the given\n\t * {@link RowMapper} returned {@code} null)\n\t * @throws org.springframework.dao.IncorrectResultSizeDataAccessException\n\t * if the query does not return exactly one row\n\t * @throws DataAccessException if the query fails\n\t */\n\t<T> @Nullable T queryForObject(String sql, @Nullable Object @Nullable [] args, int[] argTypes, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list\n\t * of arguments to bind to the query, mapping a single result row to a\n\t * result object via a RowMapper.\n\t * @param sql the SQL query to execute\n\t * @param args arguments to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type);\n\t * may also contain {@link SqlParameterValue} objects which indicate not\n\t * only the argument value but also the SQL type and optionally the scale\n\t * @param rowMapper a callback that will map one object per row\n\t * @return the single mapped object (may be {@code null} if the given\n\t * {@link RowMapper} returned {@code} null)\n\t * @throws org.springframework.dao.IncorrectResultSizeDataAccessException\n\t * if the query does not return exactly one row\n\t * @throws DataAccessException if the query fails\n\t * @deprecated as of 5.3, in favor of {@link #queryForObject(String, RowMapper, Object...)}\n\t */\n\t@Deprecated\n\t<T> @Nullable T queryForObject(String sql, @Nullable Object @Nullable [] args, RowMapper<T> rowMapper) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list\n\t * of arguments to bind to the query, mapping a single result row to a\n\t * result object via a RowMapper.\n\t * @param sql the SQL query to execute\n\t * @param rowMapper a callback that will map one object per row\n\t * @param args arguments to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type);\n\t * may also contain {@link SqlParameterValue} objects which indicate not\n\t * only the argument value but also the SQL type and optionally the scale\n\t * @return the single mapped object (may be {@code null} if the given\n\t * {@link RowMapper} returned {@code} null)\n\t * @throws org.springframework.dao.IncorrectResultSizeDataAccessException\n\t * if the query does not return exactly one row\n\t * @throws DataAccessException if the query fails\n\t * @since 3.0.1\n\t */\n\t<T> @Nullable T queryForObject(String sql, RowMapper<T> rowMapper, @Nullable Object @Nullable ... args) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, expecting a result object.\n\t * <p>The query is expected to be a single row/single column query; the returned\n\t * result will be directly mapped to the corresponding object type.\n\t * @param sql the SQL query to execute\n\t * @param args arguments to bind to the query\n\t * @param argTypes the SQL types of the arguments\n\t * (constants from {@code java.sql.Types})\n\t * @param requiredType the type that the result object is expected to match\n\t * @return the result object of the required type, or {@code null} in case of SQL NULL\n\t * @throws org.springframework.dao.IncorrectResultSizeDataAccessException\n\t * if the query does not return exactly one row\n\t * @throws org.springframework.jdbc.IncorrectResultSetColumnCountException\n\t * if the query does not return a row containing a single column\n\t * @throws DataAccessException if the query fails\n\t * @see #queryForObject(String, Class)\n\t * @see java.sql.Types\n\t */\n\t<T> @Nullable T queryForObject(String sql, @Nullable Object @Nullable [] args, int[] argTypes, Class<T> requiredType)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, expecting a result object.\n\t * <p>The query is expected to be a single row/single column query; the returned\n\t * result will be directly mapped to the corresponding object type.\n\t * @param sql the SQL query to execute\n\t * @param args arguments to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type);\n\t * may also contain {@link SqlParameterValue} objects which indicate not\n\t * only the argument value but also the SQL type and optionally the scale\n\t * @param requiredType the type that the result object is expected to match\n\t * @return the result object of the required type, or {@code null} in case of SQL NULL\n\t * @throws org.springframework.dao.IncorrectResultSizeDataAccessException\n\t * if the query does not return exactly one row\n\t * @throws org.springframework.jdbc.IncorrectResultSetColumnCountException\n\t * if the query does not return a row containing a single column\n\t * @throws DataAccessException if the query fails\n\t * @see #queryForObject(String, Class)\n\t * @deprecated as of 5.3, in favor of {@link #queryForObject(String, Class, Object...)}\n\t */\n\t@Deprecated\n\t<T> @Nullable T queryForObject(String sql, @Nullable Object @Nullable [] args, Class<T> requiredType) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, expecting a result object.\n\t * <p>The query is expected to be a single row/single column query; the returned\n\t * result will be directly mapped to the corresponding object type.\n\t * @param sql the SQL query to execute\n\t * @param requiredType the type that the result object is expected to match\n\t * @param args arguments to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type);\n\t * may also contain {@link SqlParameterValue} objects which indicate not\n\t * only the argument value but also the SQL type and optionally the scale\n\t * @return the result object of the required type, or {@code null} in case of SQL NULL\n\t * @throws org.springframework.dao.IncorrectResultSizeDataAccessException\n\t * if the query does not return exactly one row\n\t * @throws org.springframework.jdbc.IncorrectResultSetColumnCountException\n\t * if the query does not return a row containing a single column\n\t * @throws DataAccessException if the query fails\n\t * @since 3.0.1\n\t * @see #queryForObject(String, Class)\n\t */\n\t<T> @Nullable T queryForObject(String sql, Class<T> requiredType, @Nullable Object @Nullable ... args) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, expecting a result map.\n\t * <p>The query is expected to be a single row query; the result row will be\n\t * mapped to a Map (one entry for each column, using the column name as the key).\n\t * @param sql the SQL query to execute\n\t * @param args arguments to bind to the query\n\t * @param argTypes the SQL types of the arguments\n\t * (constants from {@code java.sql.Types})\n\t * @return the result Map (one entry per column, with column name as key)\n\t * @throws org.springframework.dao.IncorrectResultSizeDataAccessException\n\t * if the query does not return exactly one row\n\t * @throws DataAccessException if the query fails\n\t * @see #queryForMap(String)\n\t * @see ColumnMapRowMapper\n\t * @see java.sql.Types\n\t */\n\tMap<String, Object> queryForMap(String sql, @Nullable Object @Nullable [] args, int[] argTypes) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, expecting a result map.\n\t * <p>The {@code queryForMap} methods defined by this interface are appropriate\n\t * when you don't have a domain model. Otherwise, consider using one of the\n\t * {@code queryForObject} methods.\n\t * <p>The query is expected to be a single row query; the result row will be\n\t * mapped to a Map (one entry for each column, using the column name as the key).\n\t * @param sql the SQL query to execute\n\t * @param args arguments to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type);\n\t * may also contain {@link SqlParameterValue} objects which indicate not\n\t * only the argument value but also the SQL type and optionally the scale\n\t * @return the result Map (one entry for each column, using the\n\t * column name as the key)\n\t * @throws org.springframework.dao.IncorrectResultSizeDataAccessException\n\t * if the query does not return exactly one row\n\t * @throws DataAccessException if the query fails\n\t * @see #queryForMap(String)\n\t * @see ColumnMapRowMapper\n\t */\n\tMap<String, Object> queryForMap(String sql, @Nullable Object @Nullable ... args) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, expecting a result list.\n\t * <p>The results will be mapped to a List (one entry for each row) of\n\t * result objects, each of them matching the specified element type.\n\t * @param sql the SQL query to execute\n\t * @param args arguments to bind to the query\n\t * @param argTypes the SQL types of the arguments\n\t * (constants from {@code java.sql.Types})\n\t * @param elementType the required type of element in the result list\n\t * (for example, {@code Integer.class})\n\t * @return a List of objects that match the specified element type\n\t * @throws DataAccessException if the query fails\n\t * @see #queryForList(String, Class)\n\t * @see SingleColumnRowMapper\n\t */\n\t<T> List<T> queryForList(String sql, @Nullable Object @Nullable [] args, int[] argTypes, Class<T> elementType)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, expecting a result list.\n\t * <p>The results will be mapped to a List (one entry for each row) of\n\t * result objects, each of them matching the specified element type.\n\t * @param sql the SQL query to execute\n\t * @param args arguments to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type);\n\t * may also contain {@link SqlParameterValue} objects which indicate not\n\t * only the argument value but also the SQL type and optionally the scale\n\t * @param elementType the required type of element in the result list\n\t * (for example, {@code Integer.class})\n\t * @return a List of objects that match the specified element type\n\t * @throws DataAccessException if the query fails\n\t * @see #queryForList(String, Class)\n\t * @see SingleColumnRowMapper\n\t * @deprecated as of 5.3, in favor of {@link #queryForList(String, Class, Object...)}\n\t */\n\t@Deprecated\n\t<T> List<T> queryForList(String sql, @Nullable Object @Nullable [] args, Class<T> elementType) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, expecting a result list.\n\t * <p>The results will be mapped to a List (one entry for each row) of\n\t * result objects, each of them matching the specified element type.\n\t * @param sql the SQL query to execute\n\t * @param elementType the required type of element in the result list\n\t * (for example, {@code Integer.class})\n\t * @param args arguments to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type);\n\t * may also contain {@link SqlParameterValue} objects which indicate not\n\t * only the argument value but also the SQL type and optionally the scale\n\t * @return a List of objects that match the specified element type\n\t * @throws DataAccessException if the query fails\n\t * @since 3.0.1\n\t * @see #queryForList(String, Class)\n\t * @see SingleColumnRowMapper\n\t */\n\t<T> List<T> queryForList(String sql, Class<T> elementType, @Nullable Object @Nullable ... args) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, expecting a result list.\n\t * <p>The results will be mapped to a List (one entry for each row) of\n\t * Maps (one entry for each column, using the column name as the key).\n\t * Each element in the list will be of the form returned by this interface's\n\t * {@code queryForMap} methods.\n\t * @param sql the SQL query to execute\n\t * @param args arguments to bind to the query\n\t * @param argTypes the SQL types of the arguments\n\t * (constants from {@code java.sql.Types})\n\t * @return a List that contains a Map per row\n\t * @throws DataAccessException if the query fails\n\t * @see #queryForList(String)\n\t * @see java.sql.Types\n\t */\n\tList<Map<String, Object>> queryForList(String sql, @Nullable Object @Nullable [] args, int[] argTypes) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, expecting a result list.\n\t * <p>The results will be mapped to a List (one entry for each row) of\n\t * Maps (one entry for each column, using the column name as the key).\n\t * Each element in the list will be of the form returned by this interface's\n\t * {@code queryForMap} methods.\n\t * @param sql the SQL query to execute\n\t * @param args arguments to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type);\n\t * may also contain {@link SqlParameterValue} objects which indicate not\n\t * only the argument value but also the SQL type and optionally the scale\n\t * @return a List that contains a Map per row\n\t * @throws DataAccessException if the query fails\n\t * @see #queryForList(String)\n\t */\n\tList<Map<String, Object>> queryForList(String sql, @Nullable Object @Nullable ... args) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, expecting an SqlRowSet.\n\t * <p>The results will be mapped to an SqlRowSet which holds the data in a\n\t * disconnected fashion. This wrapper will translate any SQLExceptions thrown.\n\t * <p>Note that, for the default implementation, JDBC RowSet support needs to\n\t * be available at runtime: by default, a standard JDBC {@code CachedRowSet}\n\t * is used.\n\t * @param sql the SQL query to execute\n\t * @param args arguments to bind to the query\n\t * @param argTypes the SQL types of the arguments\n\t * (constants from {@code java.sql.Types})\n\t * @return an SqlRowSet representation (possibly a wrapper around a\n\t * {@code javax.sql.rowset.CachedRowSet})\n\t * @throws DataAccessException if there is any problem executing the query\n\t * @see #queryForRowSet(String)\n\t * @see SqlRowSetResultSetExtractor\n\t * @see javax.sql.rowset.CachedRowSet\n\t * @see java.sql.Types\n\t */\n\tSqlRowSet queryForRowSet(String sql, @Nullable Object @Nullable [] args, int[] argTypes) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, expecting an SqlRowSet.\n\t * <p>The results will be mapped to an SqlRowSet which holds the data in a\n\t * disconnected fashion. This wrapper will translate any SQLExceptions thrown.\n\t * <p>Note that, for the default implementation, JDBC RowSet support needs to\n\t * be available at runtime: by default, a standard JDBC {@code CachedRowSet}\n\t * is used.\n\t * @param sql the SQL query to execute\n\t * @param args arguments to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type);\n\t * may also contain {@link SqlParameterValue} objects which indicate not\n\t * only the argument value but also the SQL type and optionally the scale\n\t * @return an SqlRowSet representation (possibly a wrapper around a\n\t * {@code javax.sql.rowset.CachedRowSet})\n\t * @throws DataAccessException if there is any problem executing the query\n\t * @see #queryForRowSet(String)\n\t * @see SqlRowSetResultSetExtractor\n\t * @see javax.sql.rowset.CachedRowSet\n\t */\n\tSqlRowSet queryForRowSet(String sql, @Nullable Object @Nullable ... args) throws DataAccessException;\n\n\t/**\n\t * Issue a single SQL update operation (such as an insert, update or delete\n\t * statement) using a PreparedStatementCreator to provide SQL and any\n\t * required parameters.\n\t * <p>A PreparedStatementCreator can either be implemented directly or\n\t * configured through a PreparedStatementCreatorFactory.\n\t * @param psc a callback that provides SQL and any necessary parameters\n\t * @return the number of rows affected\n\t * @throws DataAccessException if there is any problem issuing the update\n\t * @see PreparedStatementCreatorFactory\n\t */\n\tint update(PreparedStatementCreator psc) throws DataAccessException;\n\n\t/**\n\t * Issue an update statement using a PreparedStatementCreator to provide SQL and\n\t * any required parameters. Generated keys will be put into the given KeyHolder.\n\t * <p>Note that the given PreparedStatementCreator has to create a statement\n\t * with activated extraction of generated keys (a JDBC 3.0 feature). This can\n\t * either be done directly or through using a PreparedStatementCreatorFactory.\n\t * <p>This method requires support for generated keys in the JDBC driver.\n\t * @param psc a callback that provides SQL and any necessary parameters\n\t * @param generatedKeyHolder a KeyHolder that will hold the generated keys\n\t * @return the number of rows affected\n\t * @throws DataAccessException if there is any problem issuing the update\n\t * @see PreparedStatementCreatorFactory\n\t * @see org.springframework.jdbc.support.GeneratedKeyHolder\n\t * @see java.sql.DatabaseMetaData#supportsGetGeneratedKeys()\n\t */\n\tint update(PreparedStatementCreator psc, KeyHolder generatedKeyHolder) throws DataAccessException;\n\n\t/**\n\t * Issue an update statement using a PreparedStatementSetter to set bind parameters,\n\t * with given SQL. Simpler than using a PreparedStatementCreator as this method\n\t * will create the PreparedStatement: The PreparedStatementSetter just needs to\n\t * set parameters.\n\t * @param sql the SQL containing bind parameters\n\t * @param pss helper that sets bind parameters. If this is {@code null}\n\t * we run an update with static SQL.\n\t * @return the number of rows affected\n\t * @throws DataAccessException if there is any problem issuing the update\n\t */\n\tint update(String sql, @Nullable PreparedStatementSetter pss) throws DataAccessException;\n\n\t/**\n\t * Issue a single SQL update operation (such as an insert, update or delete statement)\n\t * via a prepared statement, binding the given arguments.\n\t * @param sql the SQL containing bind parameters\n\t * @param args arguments to bind to the query\n\t * @param argTypes the SQL types of the arguments\n\t * (constants from {@code java.sql.Types})\n\t * @return the number of rows affected\n\t * @throws DataAccessException if there is any problem issuing the update\n\t * @see java.sql.Types\n\t */\n\tint update(String sql, @Nullable Object @Nullable [] args, int[] argTypes) throws DataAccessException;\n\n\t/**\n\t * Issue a single SQL update operation (such as an insert, update or delete statement)\n\t * via a prepared statement, binding the given arguments.\n\t * @param sql the SQL containing bind parameters\n\t * @param args arguments to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type);\n\t * may also contain {@link SqlParameterValue} objects which indicate not\n\t * only the argument value but also the SQL type and optionally the scale\n\t * @return the number of rows affected\n\t * @throws DataAccessException if there is any problem issuing the update\n\t */\n\tint update(String sql, @Nullable Object @Nullable ... args) throws DataAccessException;\n\n\t/**\n\t * Issue multiple update statements on a single PreparedStatement,\n\t * using batch updates and a BatchPreparedStatementSetter to set values.\n\t * <p>Will fall back to separate updates on a single PreparedStatement\n\t * if the JDBC driver does not support batch updates.\n\t * @param sql defining PreparedStatement that will be reused.\n\t * All statements in the batch will use the same SQL.\n\t * @param pss object to set parameters on the PreparedStatement\n\t * created by this method\n\t * @return an array of the number of rows affected by each statement\n\t * (may also contain special JDBC-defined negative values for affected rows such as\n\t * {@link java.sql.Statement#SUCCESS_NO_INFO}/{@link java.sql.Statement#EXECUTE_FAILED})\n\t * @throws DataAccessException if there is any problem issuing the update\n\t */\n\tint[] batchUpdate(String sql, BatchPreparedStatementSetter pss) throws DataAccessException;\n\n\t/**\n\t * Issue multiple update statements on a single PreparedStatement,\n\t * using batch updates and a BatchPreparedStatementSetter to set values.\n\t * Generated keys will be put into the given KeyHolder.\n\t * <p>Note that the given PreparedStatementCreator has to create a statement\n\t * with activated extraction of generated keys (a JDBC 3.0 feature). This can\n\t * either be done directly or through using a PreparedStatementCreatorFactory.\n\t * <p>This method requires support for generated keys in the JDBC driver.\n\t * It will fall back to separate updates on a single PreparedStatement\n\t * if the JDBC driver does not support batch updates.\n\t * @param psc a callback that creates a PreparedStatement given a Connection\n\t * @param pss object to set parameters on the PreparedStatement\n\t * created by this method\n\t * @param generatedKeyHolder a KeyHolder that will hold the generated keys\n\t * @return an array of the number of rows affected by each statement\n\t * (may also contain special JDBC-defined negative values for affected rows such as\n\t * {@link java.sql.Statement#SUCCESS_NO_INFO}/{@link java.sql.Statement#EXECUTE_FAILED})\n\t * @throws DataAccessException if there is any problem issuing the update\n\t * @since 6.1\n\t * @see org.springframework.jdbc.support.GeneratedKeyHolder\n\t * @see java.sql.DatabaseMetaData#supportsGetGeneratedKeys()\n\t */\n\tint[] batchUpdate(PreparedStatementCreator psc, BatchPreparedStatementSetter pss,\n\t\t\tKeyHolder generatedKeyHolder) throws DataAccessException;\n\n\t/**\n\t * Execute a batch using the supplied SQL statement with the batch of supplied arguments.\n\t * @param sql the SQL statement to execute\n\t * @param batchArgs the List of Object arrays containing the batch of arguments for the query\n\t * @return an array containing the numbers of rows affected by each update in the batch\n\t * (may also contain special JDBC-defined negative values for affected rows such as\n\t * {@link java.sql.Statement#SUCCESS_NO_INFO}/{@link java.sql.Statement#EXECUTE_FAILED})\n\t * @throws DataAccessException if there is any problem issuing the update\n\t */\n\tint[] batchUpdate(String sql, List<Object[]> batchArgs) throws DataAccessException;\n\n\t/**\n\t * Execute a batch using the supplied SQL statement with the batch of supplied arguments.\n\t * @param sql the SQL statement to execute.\n\t * @param batchArgs the List of Object arrays containing the batch of arguments for the query\n\t * @param argTypes the SQL types of the arguments\n\t * (constants from {@code java.sql.Types})\n\t * @return an array containing the numbers of rows affected by each update in the batch\n\t * (may also contain special JDBC-defined negative values for affected rows such as\n\t * {@link java.sql.Statement#SUCCESS_NO_INFO}/{@link java.sql.Statement#EXECUTE_FAILED})\n\t * @throws DataAccessException if there is any problem issuing the update\n\t */\n\tint[] batchUpdate(String sql, List<Object[]> batchArgs, int[] argTypes) throws DataAccessException;\n\n\t/**\n\t * Execute multiple batches using the supplied SQL statement with the collect of supplied\n\t * arguments. The arguments' values will be set using the ParameterizedPreparedStatementSetter.\n\t * Each batch should be of size indicated in 'batchSize'.\n\t * @param sql the SQL statement to execute.\n\t * @param batchArgs the List of Object arrays containing the batch of arguments for the query\n\t * @param batchSize batch size\n\t * @param pss the ParameterizedPreparedStatementSetter to use\n\t * @return an array containing for each batch another array containing the numbers of\n\t * rows affected by each update in the batch\n\t * (may also contain special JDBC-defined negative values for affected rows such as\n\t * {@link java.sql.Statement#SUCCESS_NO_INFO}/{@link java.sql.Statement#EXECUTE_FAILED})\n\t * @throws DataAccessException if there is any problem issuing the update\n\t * @since 3.1\n\t */\n\t<T> int[][] batchUpdate(String sql, Collection<T> batchArgs, int batchSize,\n\t\t\tParameterizedPreparedStatementSetter<T> pss) throws DataAccessException;\n\n\n\t//-------------------------------------------------------------------------\n\t// Methods dealing with callable statements\n\t//-------------------------------------------------------------------------\n\n\t/**\n\t * Execute a JDBC data access operation, implemented as callback action\n\t * working on a JDBC CallableStatement. This allows for implementing arbitrary\n\t * data access operations on a single Statement, within Spring's managed JDBC\n\t * environment: that is, participating in Spring-managed transactions and\n\t * converting JDBC SQLExceptions into Spring's DataAccessException hierarchy.\n\t * <p>The callback action can return a result object, for example a domain\n\t * object or a collection of domain objects.\n\t * @param csc a callback that creates a CallableStatement given a Connection\n\t * @param action a callback that specifies the action\n\t * @return a result object returned by the action, or {@code null} if none\n\t * @throws DataAccessException if there is any problem\n\t */\n\t<T> @Nullable T execute(CallableStatementCreator csc, CallableStatementCallback<T> action) throws DataAccessException;\n\n\t/**\n\t * Execute a JDBC data access operation, implemented as callback action\n\t * working on a JDBC CallableStatement. This allows for implementing arbitrary\n\t * data access operations on a single Statement, within Spring's managed JDBC\n\t * environment: that is, participating in Spring-managed transactions and\n\t * converting JDBC SQLExceptions into Spring's DataAccessException hierarchy.\n\t * <p>The callback action can return a result object, for example a domain\n\t * object or a collection of domain objects.\n\t * @param callString the SQL call string to execute\n\t * @param action a callback that specifies the action\n\t * @return a result object returned by the action, or {@code null} if none\n\t * @throws DataAccessException if there is any problem\n\t */\n\t<T> @Nullable T execute(String callString, CallableStatementCallback<T> action) throws DataAccessException;\n\n\t/**\n\t * Execute an SQL call using a CallableStatementCreator to provide SQL and\n\t * any required parameters.\n\t * @param csc a callback that provides SQL and any necessary parameters\n\t * @param declaredParameters list of declared SqlParameter objects\n\t * @return a Map of extracted out parameters\n\t * @throws DataAccessException if there is any problem issuing the update\n\t */\n\tMap<String, Object> call(CallableStatementCreator csc, List<SqlParameter> declaredParameters)\n\t\t\tthrows DataAccessException;\n\n}"
  },
  "org.springframework.jdbc.core.RowCountCallbackHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Implementation of RowCallbackHandler. Convenient superclass for callback handlers.\n * An instance can only be used once.\n *\n * <p>We can either use this on its own (for example, in a test case, to ensure\n * that our result sets have valid dimensions), or use it as a superclass\n * for callback handlers that actually do something, and will benefit\n * from the dimension information it provides.\n *\n * <p>A usage example with JdbcTemplate:\n *\n * <pre class=\"code\">JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);  // reusable object\n *\n * RowCountCallbackHandler countCallback = new RowCountCallbackHandler();  // not reusable\n * jdbcTemplate.query(\"select * from user\", countCallback);\n * int rowCount = countCallback.getRowCount();</pre>\n *\n * @author Rod Johnson\n * @since May 3, 2001\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public class RowCountCallbackHandler",
    "source_code": "public class RowCountCallbackHandler implements RowCallbackHandler {\n\n\t/** Rows we've seen so far. */\n\tprivate int rowCount;\n\n\t/** Columns we've seen so far. */\n\tprivate int columnCount;\n\n\t/**\n\t * Indexed from 0. Type (as in java.sql.Types) for the columns\n\t * as returned by ResultSetMetaData object.\n\t */\n\tprivate int @Nullable [] columnTypes;\n\n\t/**\n\t * Indexed from 0. Column name as returned by ResultSetMetaData object.\n\t */\n\tprivate String @Nullable [] columnNames;\n\n\n\t/**\n\t * Implementation of ResultSetCallbackHandler.\n\t * Work out column size if this is the first row, otherwise just count rows.\n\t * <p>Subclasses can perform custom extraction or processing\n\t * by overriding the {@code processRow(ResultSet, int)} method.\n\t * @see #processRow(java.sql.ResultSet, int)\n\t */\n\t@Override\n\tpublic final void processRow(ResultSet rs) throws SQLException {\n\t\tif (this.rowCount == 0) {\n\t\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\t\tthis.columnCount = rsmd.getColumnCount();\n\t\t\tthis.columnTypes = new int[this.columnCount];\n\t\t\tthis.columnNames = new String[this.columnCount];\n\t\t\tfor (int i = 0; i < this.columnCount; i++) {\n\t\t\t\tthis.columnTypes[i] = rsmd.getColumnType(i + 1);\n\t\t\t\tthis.columnNames[i] = JdbcUtils.lookupColumnName(rsmd, i + 1);\n\t\t\t}\n\t\t\t// could also get column names\n\t\t}\n\t\tprocessRow(rs, this.rowCount++);\n\t}\n\n\t/**\n\t * Subclasses may override this to perform custom extraction\n\t * or processing. This class's implementation does nothing.\n\t * @param rs the ResultSet to extract data from. This method is\n\t * invoked for each row\n\t * @param rowNum number of the current row (starting from 0)\n\t */\n\tprotected void processRow(ResultSet rs, int rowNum) throws SQLException {\n\t}\n\n\n\t/**\n\t * Return the types of the columns as java.sql.Types constants\n\t * Valid after processRow is invoked the first time.\n\t * @return the types of the columns as java.sql.Types constants.\n\t * <b>Indexed from 0 to n-1.</b>\n\t */\n\tpublic final int @Nullable [] getColumnTypes() {\n\t\treturn this.columnTypes;\n\t}\n\n\t/**\n\t * Return the names of the columns.\n\t * Valid after processRow is invoked the first time.\n\t * @return the names of the columns.\n\t * <b>Indexed from 0 to n-1.</b>\n\t */\n\tpublic final String @Nullable [] getColumnNames() {\n\t\treturn this.columnNames;\n\t}\n\n\t/**\n\t * Return the row count of this ResultSet.\n\t * Only valid after processing is complete\n\t * @return the number of rows in this ResultSet\n\t */\n\tpublic final int getRowCount() {\n\t\treturn this.rowCount;\n\t}\n\n\t/**\n\t * Return the number of columns in this result set.\n\t * Valid once we've seen the first row,\n\t * so subclasses can use it during processing\n\t * @return the number of columns in this result set\n\t */\n\tpublic final int getColumnCount() {\n\t\treturn this.columnCount;\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.RowCountCallbackHandler#getColumnCount()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the number of columns in this result set.\n\t * Valid once we've seen the first row,\n\t * so subclasses can use it during processing\n\t * @return the number of columns in this result set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "int",
    "signature": "public int getColumnCount()",
    "source_code": "\tpublic final int getColumnCount() {\n\t\treturn this.columnCount;\n\t}"
  },
  "org.springframework.jdbc.core.RowCountCallbackHandler#getRowCount()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the row count of this ResultSet.\n\t * Only valid after processing is complete\n\t * @return the number of rows in this ResultSet\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "int",
    "signature": "public int getRowCount()",
    "source_code": "\tpublic final int getRowCount() {\n\t\treturn this.rowCount;\n\t}"
  },
  "org.springframework.jdbc.core.RowCountCallbackHandler#processRow(rs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Implementation of ResultSetCallbackHandler.\n\t * Work out column size if this is the first row, otherwise just count rows.\n\t * <p>Subclasses can perform custom extraction or processing\n\t * by overriding the {@code processRow(ResultSet, int)} method.\n\t * @see #processRow(java.sql.ResultSet, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "void",
    "signature": "public void processRow(ResultSet rs)",
    "source_code": "\tpublic final void processRow(ResultSet rs) throws SQLException {\n\t\tif (this.rowCount == 0) {\n\t\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\t\tthis.columnCount = rsmd.getColumnCount();\n\t\t\tthis.columnTypes = new int[this.columnCount];\n\t\t\tthis.columnNames = new String[this.columnCount];\n\t\t\tfor (int i = 0; i < this.columnCount; i++) {\n\t\t\t\tthis.columnTypes[i] = rsmd.getColumnType(i + 1);\n\t\t\t\tthis.columnNames[i] = JdbcUtils.lookupColumnName(rsmd, i + 1);\n\t\t\t}\n\t\t\t// could also get column names\n\t\t}\n\t\tprocessRow(rs, this.rowCount++);\n\t}"
  },
  "org.springframework.jdbc.core.RowCountCallbackHandler#processRow(rs,rowNum)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses may override this to perform custom extraction\n\t * or processing. This class's implementation does nothing.\n\t * @param rs the ResultSet to extract data from. This method is\n\t * invoked for each row\n\t * @param rowNum number of the current row (starting from 0)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "rowNum"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "protected void processRow(ResultSet rs, int rowNum)",
    "source_code": "\tprotected void processRow(ResultSet rs, int rowNum) throws SQLException {\n\t}"
  },
  "org.springframework.jdbc.core.SqlParameter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Object to represent an SQL parameter definition.\n *\n * <p>Parameters may be anonymous, in which case \"name\" is {@code null}.\n * However, all parameters must define an SQL type according to {@link java.sql.Types}.\n *\n * @author Rod Johnson\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @see java.sql.Types\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class SqlParameter",
    "source_code": "public class SqlParameter {\n\n\t// The name of the parameter, if any\n\tprivate @Nullable String name;\n\n\t// SQL type constant from {@code java.sql.Types}\n\tprivate final int sqlType;\n\n\t// Used for types that are user-named like: STRUCT, DISTINCT, JAVA_OBJECT, named array types\n\tprivate @Nullable String typeName;\n\n\t// The scale to apply in case of a NUMERIC or DECIMAL type, if any\n\tprivate @Nullable Integer scale;\n\n\n\t/**\n\t * Create a new anonymous SqlParameter, supplying the SQL type.\n\t * @param sqlType the SQL type of the parameter according to {@code java.sql.Types}\n\t */\n\tpublic SqlParameter(int sqlType) {\n\t\tthis.sqlType = sqlType;\n\t}\n\n\t/**\n\t * Create a new anonymous SqlParameter, supplying the SQL type.\n\t * @param sqlType the SQL type of the parameter according to {@code java.sql.Types}\n\t * @param typeName the type name of the parameter (optional)\n\t */\n\tpublic SqlParameter(int sqlType, @Nullable String typeName) {\n\t\tthis.sqlType = sqlType;\n\t\tthis.typeName = typeName;\n\t}\n\n\t/**\n\t * Create a new anonymous SqlParameter, supplying the SQL type.\n\t * @param sqlType the SQL type of the parameter according to {@code java.sql.Types}\n\t * @param scale the number of digits after the decimal point\n\t * (for DECIMAL and NUMERIC types)\n\t */\n\tpublic SqlParameter(int sqlType, int scale) {\n\t\tthis.sqlType = sqlType;\n\t\tthis.scale = scale;\n\t}\n\n\t/**\n\t * Create a new SqlParameter, supplying name and SQL type.\n\t * @param name the name of the parameter, as used in input and output maps\n\t * @param sqlType the SQL type of the parameter according to {@code java.sql.Types}\n\t */\n\tpublic SqlParameter(String name, int sqlType) {\n\t\tthis.name = name;\n\t\tthis.sqlType = sqlType;\n\t}\n\n\t/**\n\t * Create a new SqlParameter, supplying name and SQL type.\n\t * @param name the name of the parameter, as used in input and output maps\n\t * @param sqlType the SQL type of the parameter according to {@code java.sql.Types}\n\t * @param typeName the type name of the parameter (optional)\n\t */\n\tpublic SqlParameter(String name, int sqlType, @Nullable String typeName) {\n\t\tthis.name = name;\n\t\tthis.sqlType = sqlType;\n\t\tthis.typeName = typeName;\n\t}\n\n\t/**\n\t * Create a new SqlParameter, supplying name and SQL type.\n\t * @param name the name of the parameter, as used in input and output maps\n\t * @param sqlType the SQL type of the parameter according to {@code java.sql.Types}\n\t * @param scale the number of digits after the decimal point\n\t * (for DECIMAL and NUMERIC types)\n\t */\n\tpublic SqlParameter(String name, int sqlType, int scale) {\n\t\tthis.name = name;\n\t\tthis.sqlType = sqlType;\n\t\tthis.scale = scale;\n\t}\n\n\t/**\n\t * Copy constructor.\n\t * @param otherParam the SqlParameter object to copy from\n\t */\n\tpublic SqlParameter(SqlParameter otherParam) {\n\t\tAssert.notNull(otherParam, \"SqlParameter object must not be null\");\n\t\tthis.name = otherParam.name;\n\t\tthis.sqlType = otherParam.sqlType;\n\t\tthis.typeName = otherParam.typeName;\n\t\tthis.scale = otherParam.scale;\n\t}\n\n\n\t/**\n\t * Return the name of the parameter, or {@code null} if anonymous.\n\t */\n\tpublic @Nullable String getName() {\n\t\treturn this.name;\n\t}\n\n\t/**\n\t * Return the SQL type of the parameter.\n\t */\n\tpublic int getSqlType() {\n\t\treturn this.sqlType;\n\t}\n\n\t/**\n\t * Return the type name of the parameter, if any.\n\t */\n\tpublic @Nullable String getTypeName() {\n\t\treturn this.typeName;\n\t}\n\n\t/**\n\t * Return the scale of the parameter, if any.\n\t */\n\tpublic @Nullable Integer getScale() {\n\t\treturn this.scale;\n\t}\n\n\n\t/**\n\t * Return whether this parameter holds input values that should be set\n\t * before execution even if they are {@code null}.\n\t * <p>This implementation always returns {@code true}.\n\t */\n\tpublic boolean isInputValueProvided() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Return whether this parameter is an implicit return parameter used during the\n\t * results processing of {@code CallableStatement.getMoreResults/getUpdateCount}.\n\t * <p>This implementation always returns {@code false}.\n\t */\n\tpublic boolean isResultsParameter() {\n\t\treturn false;\n\t}\n\n\n\t/**\n\t * Convert a list of JDBC types, as defined in {@code java.sql.Types},\n\t * to a List of SqlParameter objects as used in this package.\n\t */\n\tpublic static List<SqlParameter> sqlTypesToAnonymousParameterList(int @Nullable ... types) {\n\t\tif (types == null) {\n\t\t\treturn new ArrayList<>();\n\t\t}\n\t\tList<SqlParameter> result = new ArrayList<>(types.length);\n\t\tfor (int type : types) {\n\t\t\tresult.add(new SqlParameter(type));\n\t\t}\n\t\treturn result;\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.SqlParameter#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the parameter, or {@code null} if anonymous.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "\tpublic @Nullable String getName() {\n\t\treturn this.name;\n\t}"
  },
  "org.springframework.jdbc.core.SqlParameter#getScale()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the scale of the parameter, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Integer",
    "signature": "public Integer getScale()",
    "source_code": "\tpublic @Nullable Integer getScale() {\n\t\treturn this.scale;\n\t}"
  },
  "org.springframework.jdbc.core.SqlParameter#getSqlType()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the SQL type of the parameter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "int",
    "signature": "public int getSqlType()",
    "source_code": "\tpublic int getSqlType() {\n\t\treturn this.sqlType;\n\t}"
  },
  "org.springframework.jdbc.core.SqlParameter#getTypeName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the type name of the parameter, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "String",
    "signature": "public String getTypeName()",
    "source_code": "\tpublic @Nullable String getTypeName() {\n\t\treturn this.typeName;\n\t}"
  },
  "org.springframework.jdbc.core.SqlParameter#isInputValueProvided()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this parameter holds input values that should be set\n\t * before execution even if they are {@code null}.\n\t * <p>This implementation always returns {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "boolean",
    "signature": "public boolean isInputValueProvided()",
    "source_code": "\tpublic boolean isInputValueProvided() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.jdbc.core.SqlParameter#isResultsParameter()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this parameter is an implicit return parameter used during the\n\t * results processing of {@code CallableStatement.getMoreResults/getUpdateCount}.\n\t * <p>This implementation always returns {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "boolean",
    "signature": "public boolean isResultsParameter()",
    "source_code": "\tpublic boolean isResultsParameter() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.jdbc.core.SqlParameter#sqlTypesToAnonymousParameterList(types)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a list of JDBC types, as defined in {@code java.sql.Types},\n\t * to a List of SqlParameter objects as used in this package.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "types"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "List<SqlParameter>",
    "signature": "public List<SqlParameter> sqlTypesToAnonymousParameterList(int @Nullable ... types)",
    "source_code": "\tpublic static List<SqlParameter> sqlTypesToAnonymousParameterList(int @Nullable ... types) {\n\t\tif (types == null) {\n\t\t\treturn new ArrayList<>();\n\t\t}\n\t\tList<SqlParameter> result = new ArrayList<>(types.length);\n\t\tfor (int type : types) {\n\t\t\tresult.add(new SqlParameter(type));\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link SqlParameterSource} implementation that obtains parameter values\n * from bean properties of a given JavaBean object. The names of the bean\n * properties have to match the parameter names. Supports components of\n * record classes as well, with accessor methods matching parameter names.\n *\n * <p>Uses a Spring {@link BeanWrapper} for bean property access underneath.\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @since 2.0\n * @see NamedParameterJdbcTemplate\n * @see SimplePropertySqlParameterSource\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class BeanPropertySqlParameterSource",
    "source_code": "public class BeanPropertySqlParameterSource extends AbstractSqlParameterSource {\n\n\tprivate final BeanWrapper beanWrapper;\n\n\tprivate String @Nullable [] propertyNames;\n\n\n\t/**\n\t * Create a new BeanPropertySqlParameterSource for the given bean.\n\t * @param object the bean instance to wrap\n\t */\n\tpublic BeanPropertySqlParameterSource(Object object) {\n\t\tthis.beanWrapper = PropertyAccessorFactory.forBeanPropertyAccess(object);\n\t}\n\n\n\t@Override\n\tpublic boolean hasValue(String paramName) {\n\t\treturn this.beanWrapper.isReadableProperty(paramName);\n\t}\n\n\t@Override\n\tpublic @Nullable Object getValue(String paramName) throws IllegalArgumentException {\n\t\ttry {\n\t\t\treturn this.beanWrapper.getPropertyValue(paramName);\n\t\t}\n\t\tcatch (NotReadablePropertyException ex) {\n\t\t\tthrow new IllegalArgumentException(ex.getMessage());\n\t\t}\n\t}\n\n\t/**\n\t * Derives a default SQL type from the corresponding property type.\n\t * @see org.springframework.jdbc.core.StatementCreatorUtils#javaTypeToSqlParameterType\n\t */\n\t@Override\n\tpublic int getSqlType(String paramName) {\n\t\tint sqlType = super.getSqlType(paramName);\n\t\tif (sqlType != TYPE_UNKNOWN) {\n\t\t\treturn sqlType;\n\t\t}\n\t\tClass<?> propType = this.beanWrapper.getPropertyType(paramName);\n\t\treturn StatementCreatorUtils.javaTypeToSqlParameterType(propType);\n\t}\n\n\t@Override\n\tpublic String[] getParameterNames() {\n\t\treturn getReadablePropertyNames();\n\t}\n\n\t/**\n\t * Provide access to the property names of the wrapped bean.\n\t * Uses support provided in the {@link PropertyAccessor} interface.\n\t * @return an array containing all the known property names\n\t */\n\tpublic String[] getReadablePropertyNames() {\n\t\tif (this.propertyNames == null) {\n\t\t\tList<String> names = new ArrayList<>();\n\t\t\tPropertyDescriptor[] props = this.beanWrapper.getPropertyDescriptors();\n\t\t\tfor (PropertyDescriptor pd : props) {\n\t\t\t\tif (this.beanWrapper.isReadableProperty(pd.getName())) {\n\t\t\t\t\tnames.add(pd.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.propertyNames = StringUtils.toStringArray(names);\n\t\t}\n\t\treturn this.propertyNames;\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource#getParameterNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "String[]",
    "signature": "public String[] getParameterNames()",
    "source_code": "\tpublic String[] getParameterNames() {\n\t\treturn getReadablePropertyNames();\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource#getReadablePropertyNames()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide access to the property names of the wrapped bean.\n\t * Uses support provided in the {@link PropertyAccessor} interface.\n\t * @return an array containing all the known property names\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "String[]",
    "signature": "public String[] getReadablePropertyNames()",
    "source_code": "\tpublic String[] getReadablePropertyNames() {\n\t\tif (this.propertyNames == null) {\n\t\t\tList<String> names = new ArrayList<>();\n\t\t\tPropertyDescriptor[] props = this.beanWrapper.getPropertyDescriptors();\n\t\t\tfor (PropertyDescriptor pd : props) {\n\t\t\t\tif (this.beanWrapper.isReadableProperty(pd.getName())) {\n\t\t\t\t\tnames.add(pd.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.propertyNames = StringUtils.toStringArray(names);\n\t\t}\n\t\treturn this.propertyNames;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource#getSqlType(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Derives a default SQL type from the corresponding property type.\n\t * @see org.springframework.jdbc.core.StatementCreatorUtils#javaTypeToSqlParameterType\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "int",
    "signature": "public int getSqlType(String paramName)",
    "source_code": "\tpublic int getSqlType(String paramName) {\n\t\tint sqlType = super.getSqlType(paramName);\n\t\tif (sqlType != TYPE_UNKNOWN) {\n\t\t\treturn sqlType;\n\t\t}\n\t\tClass<?> propType = this.beanWrapper.getPropertyType(paramName);\n\t\treturn StatementCreatorUtils.javaTypeToSqlParameterType(propType);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource#getValue(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "Object",
    "signature": "public Object getValue(String paramName)",
    "source_code": "\tpublic @Nullable Object getValue(String paramName) throws IllegalArgumentException {\n\t\ttry {\n\t\t\treturn this.beanWrapper.getPropertyValue(paramName);\n\t\t}\n\t\tcatch (NotReadablePropertyException ex) {\n\t\t\tthrow new IllegalArgumentException(ex.getMessage());\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource#hasValue(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "boolean",
    "signature": "public boolean hasValue(String paramName)",
    "source_code": "\tpublic boolean hasValue(String paramName) {\n\t\treturn this.beanWrapper.isReadableProperty(paramName);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.DEFAULT_CACHE_LIMIT": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Default maximum number of entries for this template's SQL cache: 256. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "signature": "public int DEFAULT_CACHE_LIMIT",
    "source_code": "\tpublic static final int DEFAULT_CACHE_LIMIT = 256;",
    "type": "int"
  },
  "org.springframework.jdbc.core.namedparam.EmptySqlParameterSource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A simple empty implementation of the {@link SqlParameterSource} interface.\n *\n * @author Juergen Hoeller\n * @since 3.2.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 27
    },
    "signature": "public class EmptySqlParameterSource",
    "source_code": "public class EmptySqlParameterSource implements SqlParameterSource {\n\n\t/**\n\t * A shared instance of {@link EmptySqlParameterSource}.\n\t */\n\tpublic static final EmptySqlParameterSource INSTANCE = new EmptySqlParameterSource();\n\n\n\t@Override\n\tpublic boolean hasValue(String paramName) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic @Nullable Object getValue(String paramName) throws IllegalArgumentException {\n\t\tthrow new IllegalArgumentException(\"This SqlParameterSource is empty\");\n\t}\n\n\t@Override\n\tpublic int getSqlType(String paramName) {\n\t\treturn TYPE_UNKNOWN;\n\t}\n\n\t@Override\n\tpublic @Nullable String getTypeName(String paramName) {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic String @Nullable [] getParameterNames() {\n\t\treturn null;\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.namedparam.EmptySqlParameterSource#getSqlType(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "int",
    "signature": "public int getSqlType(String paramName)",
    "source_code": "\tpublic int getSqlType(String paramName) {\n\t\treturn TYPE_UNKNOWN;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.EmptySqlParameterSource#getTypeName(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "String",
    "signature": "public String getTypeName(String paramName)",
    "source_code": "\tpublic @Nullable String getTypeName(String paramName) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.EmptySqlParameterSource#getValue(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "return": "Object",
    "signature": "public Object getValue(String paramName)",
    "source_code": "\tpublic @Nullable Object getValue(String paramName) throws IllegalArgumentException {\n\t\tthrow new IllegalArgumentException(\"This SqlParameterSource is empty\");\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.EmptySqlParameterSource#hasValue(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "return": "boolean",
    "signature": "public boolean hasValue(String paramName)",
    "source_code": "\tpublic boolean hasValue(String paramName) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.INSTANCE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A shared instance of {@link EmptySqlParameterSource}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 32
    },
    "signature": "public EmptySqlParameterSource INSTANCE",
    "source_code": "\tpublic static final EmptySqlParameterSource INSTANCE = new EmptySqlParameterSource();",
    "type": "EmptySqlParameterSource"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcOperations": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Interface specifying a basic set of JDBC operations allowing the use\n * of named parameters rather than the traditional '?' placeholders.\n *\n * <p>This is an alternative to the classic\n * {@link org.springframework.jdbc.core.JdbcOperations} interface,\n * implemented by {@link NamedParameterJdbcTemplate}. This interface is not\n * often used directly, but provides a useful option to enhance testability,\n * as it can easily be mocked or stubbed.\n *\n * <p><b>NOTE: As of 6.1, there is a unified JDBC access facade available in\n * the form of {@link org.springframework.jdbc.core.simple.JdbcClient}.</b>\n * {@code JdbcClient} provides a fluent API style for common JDBC queries/updates\n * with flexible use of indexed or named parameters. It delegates to\n * {@code JdbcOperations}/{@code NamedParameterJdbcOperations} for actual execution.\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @since 2.0\n * @see NamedParameterJdbcTemplate\n * @see org.springframework.jdbc.core.JdbcOperations\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "signature": "public interface NamedParameterJdbcOperations",
    "source_code": "public interface NamedParameterJdbcOperations {\n\n\t/**\n\t * Expose the classic Spring JdbcTemplate to allow invocation of\n\t * classic JDBC operations.\n\t */\n\tJdbcOperations getJdbcOperations();\n\n\n\t/**\n\t * Execute a JDBC data access operation, implemented as callback action\n\t * working on a JDBC PreparedStatement. This allows for implementing arbitrary\n\t * data access operations on a single Statement, within Spring's managed\n\t * JDBC environment: that is, participating in Spring-managed transactions\n\t * and converting JDBC SQLExceptions into Spring's DataAccessException hierarchy.\n\t * <p>The callback action can return a result object, for example a\n\t * domain object or a collection of domain objects.\n\t * @param sql the SQL to execute\n\t * @param paramSource container of arguments to bind to the query\n\t * @param action callback object that specifies the action\n\t * @return a result object returned by the action, or {@code null}\n\t * @throws DataAccessException if there is any problem\n\t */\n\t<T> @Nullable T execute(String sql, SqlParameterSource paramSource, PreparedStatementCallback<T> action)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Execute a JDBC data access operation, implemented as callback action\n\t * working on a JDBC PreparedStatement. This allows for implementing arbitrary\n\t * data access operations on a single Statement, within Spring's managed\n\t * JDBC environment: that is, participating in Spring-managed transactions\n\t * and converting JDBC SQLExceptions into Spring's DataAccessException hierarchy.\n\t * <p>The callback action can return a result object, for example a\n\t * domain object or a collection of domain objects.\n\t * @param sql the SQL to execute\n\t * @param paramMap map of parameters to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type)\n\t * @param action callback object that specifies the action\n\t * @return a result object returned by the action, or {@code null}\n\t * @throws DataAccessException if there is any problem\n\t */\n\t<T> @Nullable T execute(String sql, Map<String, ?> paramMap, PreparedStatementCallback<T> action)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Execute a JDBC data access operation, implemented as callback action\n\t * working on a JDBC PreparedStatement. This allows for implementing arbitrary\n\t * data access operations on a single Statement, within Spring's managed\n\t * JDBC environment: that is, participating in Spring-managed transactions\n\t * and converting JDBC SQLExceptions into Spring's DataAccessException hierarchy.\n\t * <p>The callback action can return a result object, for example a\n\t * domain object or a collection of domain objects.\n\t * @param sql the SQL to execute\n\t * @param action callback object that specifies the action\n\t * @return a result object returned by the action, or {@code null}\n\t * @throws DataAccessException if there is any problem\n\t */\n\t<T> @Nullable T execute(String sql, PreparedStatementCallback<T> action) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list\n\t * of arguments to bind to the query, reading the ResultSet with a\n\t * ResultSetExtractor.\n\t * @param sql the SQL query to execute\n\t * @param paramSource container of arguments to bind to the query\n\t * @param rse object that will extract results\n\t * @return an arbitrary result object, as returned by the ResultSetExtractor\n\t * @throws DataAccessException if the query fails\n\t */\n\t<T> @Nullable T query(String sql, SqlParameterSource paramSource, ResultSetExtractor<T> rse)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list\n\t * of arguments to bind to the query, reading the ResultSet with a\n\t * ResultSetExtractor.\n\t * @param sql the SQL query to execute\n\t * @param paramMap map of parameters to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type)\n\t * @param rse object that will extract results\n\t * @return an arbitrary result object, as returned by the ResultSetExtractor\n\t * @throws DataAccessException if the query fails\n\t */\n\t<T> @Nullable T query(String sql, Map<String, ?> paramMap, ResultSetExtractor<T> rse)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL,\n\t * reading the ResultSet with a ResultSetExtractor.\n\t * <p>Note: In contrast to the JdbcOperations method with the same signature,\n\t * this query variant always uses a PreparedStatement. It is effectively\n\t * equivalent to a query call with an empty parameter Map.\n\t * @param sql the SQL query to execute\n\t * @param rse object that will extract results\n\t * @return an arbitrary result object, as returned by the ResultSetExtractor\n\t * @throws DataAccessException if the query fails\n\t */\n\t<T> @Nullable T query(String sql, ResultSetExtractor<T> rse) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, reading the ResultSet on a per-row basis\n\t * with a RowCallbackHandler.\n\t * @param sql the SQL query to execute\n\t * @param paramSource container of arguments to bind to the query\n\t * @param rch object that will extract results, one row at a time\n\t * @throws DataAccessException if the query fails\n\t */\n\tvoid query(String sql, SqlParameterSource paramSource, RowCallbackHandler rch)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list of\n\t * arguments to bind to the query, reading the ResultSet on a per-row basis\n\t * with a RowCallbackHandler.\n\t * @param sql the SQL query to execute\n\t * @param paramMap map of parameters to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type)\n\t * @param rch object that will extract results, one row at a time\n\t * @throws DataAccessException if the query fails\n\t */\n\tvoid query(String sql, Map<String, ?> paramMap, RowCallbackHandler rch) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL,\n\t * reading the ResultSet on a per-row basis with a RowCallbackHandler.\n\t * <p>Note: In contrast to the JdbcOperations method with the same signature,\n\t * this query variant always uses a PreparedStatement. It is effectively\n\t * equivalent to a query call with an empty parameter Map.\n\t * @param sql the SQL query to execute\n\t * @param rch object that will extract results, one row at a time\n\t * @throws DataAccessException if the query fails\n\t */\n\tvoid query(String sql, RowCallbackHandler rch) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list\n\t * of arguments to bind to the query, mapping each row to a Java object\n\t * via a RowMapper.\n\t * @param sql the SQL query to execute\n\t * @param paramSource container of arguments to bind to the query\n\t * @param rowMapper object that will map one object per row\n\t * @return the result List, containing mapped objects\n\t * @throws DataAccessException if the query fails\n\t */\n\t<T> List<T> query(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list\n\t * of arguments to bind to the query, mapping each row to a Java object\n\t * via a RowMapper.\n\t * @param sql the SQL query to execute\n\t * @param paramMap map of parameters to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type)\n\t * @param rowMapper object that will map one object per row\n\t * @return the result List, containing mapped objects\n\t * @throws DataAccessException if the query fails\n\t */\n\t<T> List<T> query(String sql, Map<String, ?> paramMap, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL,\n\t * mapping each row to a Java object via a RowMapper.\n\t * <p>Note: In contrast to the JdbcOperations method with the same signature,\n\t * this query variant always uses a PreparedStatement. It is effectively\n\t * equivalent to a query call with an empty parameter Map.\n\t * @param sql the SQL query to execute\n\t * @param rowMapper object that will map one object per row\n\t * @return the result List, containing mapped objects\n\t * @throws DataAccessException if the query fails\n\t */\n\t<T> List<T> query(String sql, RowMapper<T> rowMapper) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list\n\t * of arguments to bind to the query, mapping each row to a Java object\n\t * via a RowMapper, and turning it into an iterable and closeable Stream.\n\t * @param sql the SQL query to execute\n\t * @param paramSource container of arguments to bind to the query\n\t * @param rowMapper object that will map one object per row\n\t * @return the result Stream, containing mapped objects, needing to be\n\t * closed once fully processed (for example, through a try-with-resources clause)\n\t * @throws DataAccessException if the query fails\n\t * @since 5.3\n\t */\n\t<T> Stream<T> queryForStream(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list\n\t * of arguments to bind to the query, mapping each row to a Java object\n\t * via a RowMapper, and turning it into an iterable and closeable Stream.\n\t * @param sql the SQL query to execute\n\t * @param paramMap map of parameters to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type)\n\t * @param rowMapper object that will map one object per row\n\t * @return the result Stream, containing mapped objects, needing to be\n\t * closed once fully processed (for example, through a try-with-resources clause)\n\t * @throws DataAccessException if the query fails\n\t * @since 5.3\n\t */\n\t<T> Stream<T> queryForStream(String sql, Map<String, ?> paramMap, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list\n\t * of arguments to bind to the query, mapping a single result row to a\n\t * Java object via a RowMapper.\n\t * @param sql the SQL query to execute\n\t * @param paramSource container of arguments to bind to the query\n\t * @param rowMapper object that will map one object per row\n\t * @return the single mapped object (may be {@code null} if the given\n\t * {@link RowMapper} returned {@code} null)\n\t * @throws org.springframework.dao.IncorrectResultSizeDataAccessException\n\t * if the query does not return exactly one row\n\t * @throws DataAccessException if the query fails\n\t */\n\t<T> @Nullable T queryForObject(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a list\n\t * of arguments to bind to the query, mapping a single result row to a\n\t * Java object via a RowMapper.\n\t * @param sql the SQL query to execute\n\t * @param paramMap map of parameters to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type)\n\t * @param rowMapper object that will map one object per row\n\t * @return the single mapped object (may be {@code null} if the given\n\t * {@link RowMapper} returned {@code} null)\n\t * @throws org.springframework.dao.IncorrectResultSizeDataAccessException\n\t * if the query does not return exactly one row\n\t * @throws DataAccessException if the query fails\n\t */\n\t<T> @Nullable T queryForObject(String sql, Map<String, ?> paramMap, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a\n\t * list of arguments to bind to the query, expecting a result object.\n\t * <p>The query is expected to be a single row/single column query; the returned\n\t * result will be directly mapped to the corresponding object type.\n\t * @param sql the SQL query to execute\n\t * @param paramSource container of arguments to bind to the query\n\t * @param requiredType the type that the result object is expected to match\n\t * @return the result object of the required type, or {@code null} in case of SQL NULL\n\t * @throws org.springframework.dao.IncorrectResultSizeDataAccessException\n\t * if the query does not return exactly one row\n\t * @throws org.springframework.jdbc.IncorrectResultSetColumnCountException\n\t * if the query does not return a row containing a single column\n\t * @throws DataAccessException if the query fails\n\t * @see org.springframework.jdbc.core.JdbcTemplate#queryForObject(String, Class)\n\t * @see org.springframework.jdbc.core.SingleColumnRowMapper\n\t */\n\t<T> @Nullable T queryForObject(String sql, SqlParameterSource paramSource, Class<T> requiredType)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a\n\t * list of arguments to bind to the query, expecting a result object.\n\t * <p>The query is expected to be a single row/single column query; the returned\n\t * result will be directly mapped to the corresponding object type.\n\t * @param sql the SQL query to execute\n\t * @param paramMap map of parameters to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type)\n\t * @param requiredType the type that the result object is expected to match\n\t * @return the result object of the required type, or {@code null} in case of SQL NULL\n\t * @throws org.springframework.dao.IncorrectResultSizeDataAccessException\n\t * if the query does not return exactly one row\n\t * @throws org.springframework.jdbc.IncorrectResultSetColumnCountException\n\t * if the query does not return a row containing a single column\n\t * @throws DataAccessException if the query fails\n\t * @see org.springframework.jdbc.core.JdbcTemplate#queryForObject(String, Class)\n\t */\n\t<T> @Nullable T queryForObject(String sql, Map<String, ?> paramMap, Class<T> requiredType)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a\n\t * list of arguments to bind to the query, expecting a result Map.\n\t * <p>The query is expected to be a single row query; the result row will be\n\t * mapped to a Map (one entry for each column, using the column name as the key).\n\t * @param sql the SQL query to execute\n\t * @param paramSource container of arguments to bind to the query\n\t * @return the result Map (one entry for each column, using the column name as the key)\n\t * @throws org.springframework.dao.IncorrectResultSizeDataAccessException\n\t * if the query does not return exactly one row\n\t * @throws DataAccessException if the query fails\n\t * @see org.springframework.jdbc.core.JdbcTemplate#queryForMap(String)\n\t * @see org.springframework.jdbc.core.ColumnMapRowMapper\n\t */\n\tMap<String, Object> queryForMap(String sql, SqlParameterSource paramSource) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a\n\t * list of arguments to bind to the query, expecting a result Map.\n\t * The queryForMap() methods defined by this interface are appropriate\n\t * when you don't have a domain model. Otherwise, consider using\n\t * one of the queryForObject() methods.\n\t * <p>The query is expected to be a single row query; the result row will be\n\t * mapped to a Map (one entry for each column, using the column name as the key).\n\t * @param sql the SQL query to execute\n\t * @param paramMap map of parameters to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type)\n\t * @return the result Map (one entry for each column, using the column name as the key)\n\t * @throws org.springframework.dao.IncorrectResultSizeDataAccessException\n\t * if the query does not return exactly one row\n\t * @throws DataAccessException if the query fails\n\t * @see org.springframework.jdbc.core.JdbcTemplate#queryForMap(String)\n\t * @see org.springframework.jdbc.core.ColumnMapRowMapper\n\t */\n\tMap<String, Object> queryForMap(String sql, Map<String, ?> paramMap) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a\n\t * list of arguments to bind to the query, expecting a result list.\n\t * <p>The results will be mapped to a List (one entry for each row) of\n\t * result objects, each of them matching the specified element type.\n\t * @param sql the SQL query to execute\n\t * @param paramSource container of arguments to bind to the query\n\t * @param elementType the required type of element in the result list\n\t * (for example, {@code Integer.class})\n\t * @return a List of objects that match the specified element type\n\t * @throws DataAccessException if the query fails\n\t * @see org.springframework.jdbc.core.JdbcTemplate#queryForList(String, Class)\n\t * @see org.springframework.jdbc.core.SingleColumnRowMapper\n\t */\n\t<T> List<T> queryForList(String sql, SqlParameterSource paramSource, Class<T> elementType)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a\n\t * list of arguments to bind to the query, expecting a result list.\n\t * <p>The results will be mapped to a List (one entry for each row) of\n\t * result objects, each of them matching the specified element type.\n\t * @param sql the SQL query to execute\n\t * @param paramMap map of parameters to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type)\n\t * @param elementType the required type of element in the result list\n\t * (for example, {@code Integer.class})\n\t * @return a List of objects that match the specified element type\n\t * @throws DataAccessException if the query fails\n\t * @see org.springframework.jdbc.core.JdbcTemplate#queryForList(String, Class)\n\t * @see org.springframework.jdbc.core.SingleColumnRowMapper\n\t */\n\t<T> List<T> queryForList(String sql, Map<String, ?> paramMap, Class<T> elementType)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a\n\t * list of arguments to bind to the query, expecting a result list.\n\t * <p>The results will be mapped to a List (one entry for each row) of\n\t * Maps (one entry for each column, using the column name as the key).\n\t * Each element in the list will be of the form returned by this interface's\n\t * {@code queryForMap} methods.\n\t * @param sql the SQL query to execute\n\t * @param paramSource container of arguments to bind to the query\n\t * @return a List that contains a Map per row\n\t * @throws DataAccessException if the query fails\n\t * @see org.springframework.jdbc.core.JdbcTemplate#queryForList(String)\n\t */\n\tList<Map<String, Object>> queryForList(String sql, SqlParameterSource paramSource) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a\n\t * list of arguments to bind to the query, expecting a result list.\n\t * <p>The results will be mapped to a List (one entry for each row) of\n\t * Maps (one entry for each column, using the column name as the key).\n\t * Each element in the list will be of the form returned by this interface's\n\t * {@code queryForMap} methods.\n\t * @param sql the SQL query to execute\n\t * @param paramMap map of parameters to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type)\n\t * @return a List that contains a Map per row\n\t * @throws DataAccessException if the query fails\n\t * @see org.springframework.jdbc.core.JdbcTemplate#queryForList(String)\n\t */\n\tList<Map<String, Object>> queryForList(String sql, Map<String, ?> paramMap) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a\n\t * list of arguments to bind to the query, expecting an SqlRowSet.\n\t * <p>The results will be mapped to an SqlRowSet which holds the data in a\n\t * disconnected fashion. This wrapper will translate any SQLExceptions thrown.\n\t * <p>Note that, for the default implementation, JDBC RowSet support needs to\n\t * be available at runtime: by default, a standard JDBC {@code CachedRowSet}\n\t * is used.\n\t * @param sql the SQL query to execute\n\t * @param paramSource container of arguments to bind to the query\n\t * @return an SqlRowSet representation (possibly a wrapper around a\n\t * {@code javax.sql.rowset.CachedRowSet})\n\t * @throws DataAccessException if there is any problem executing the query\n\t * @see org.springframework.jdbc.core.JdbcTemplate#queryForRowSet(String)\n\t * @see org.springframework.jdbc.core.SqlRowSetResultSetExtractor\n\t * @see javax.sql.rowset.CachedRowSet\n\t */\n\tSqlRowSet queryForRowSet(String sql, SqlParameterSource paramSource) throws DataAccessException;\n\n\t/**\n\t * Query given SQL to create a prepared statement from SQL and a\n\t * list of arguments to bind to the query, expecting an SqlRowSet.\n\t * <p>The results will be mapped to an SqlRowSet which holds the data in a\n\t * disconnected fashion. This wrapper will translate any SQLExceptions thrown.\n\t * <p>Note that, for the default implementation, JDBC RowSet support needs to\n\t * be available at runtime: by default, a standard JDBC {@code CachedRowSet}\n\t * is used.\n\t * @param sql the SQL query to execute\n\t * @param paramMap map of parameters to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type)\n\t * @return an SqlRowSet representation (possibly a wrapper around a\n\t * {@code javax.sql.rowset.CachedRowSet})\n\t * @throws DataAccessException if there is any problem executing the query\n\t * @see org.springframework.jdbc.core.JdbcTemplate#queryForRowSet(String)\n\t * @see org.springframework.jdbc.core.SqlRowSetResultSetExtractor\n\t * @see javax.sql.rowset.CachedRowSet\n\t */\n\tSqlRowSet queryForRowSet(String sql, Map<String, ?> paramMap) throws DataAccessException;\n\n\t/**\n\t * Issue an update via a prepared statement, binding the given arguments.\n\t * @param sql the SQL containing named parameters\n\t * @param paramSource container of arguments and SQL types to bind to the query\n\t * @return the number of rows affected\n\t * @throws DataAccessException if there is any problem issuing the update\n\t */\n\tint update(String sql, SqlParameterSource paramSource) throws DataAccessException;\n\n\t/**\n\t * Issue an update via a prepared statement, binding the given arguments.\n\t * @param sql the SQL containing named parameters\n\t * @param paramMap map of parameters to bind to the query\n\t * (leaving it to the PreparedStatement to guess the corresponding SQL type)\n\t * @return the number of rows affected\n\t * @throws DataAccessException if there is any problem issuing the update\n\t */\n\tint update(String sql, Map<String, ?> paramMap) throws DataAccessException;\n\n\t/**\n\t * Issue an update via a prepared statement, binding the given arguments,\n\t * returning generated keys.\n\t * <p>This method requires support for generated keys in the JDBC driver.\n\t * @param sql the SQL containing named parameters\n\t * @param paramSource container of arguments and SQL types to bind to the query\n\t * @param generatedKeyHolder a {@link KeyHolder} that will hold the generated keys\n\t * @return the number of rows affected\n\t * @throws DataAccessException if there is any problem issuing the update\n\t * @see MapSqlParameterSource\n\t * @see org.springframework.jdbc.support.GeneratedKeyHolder\n\t * @see java.sql.DatabaseMetaData#supportsGetGeneratedKeys()\n\t */\n\tint update(String sql, SqlParameterSource paramSource, KeyHolder generatedKeyHolder)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Issue an update via a prepared statement, binding the given arguments,\n\t * returning generated keys.\n\t * <p>This method requires support for generated keys in the JDBC driver.\n\t * @param sql the SQL containing named parameters\n\t * @param paramSource container of arguments and SQL types to bind to the query\n\t * @param generatedKeyHolder a {@link KeyHolder} that will hold the generated keys\n\t * @param keyColumnNames names of the columns that will have keys generated for them\n\t * @return the number of rows affected\n\t * @throws DataAccessException if there is any problem issuing the update\n\t * @see MapSqlParameterSource\n\t * @see org.springframework.jdbc.support.GeneratedKeyHolder\n\t * @see java.sql.DatabaseMetaData#supportsGetGeneratedKeys()\n\t */\n\tint update(String sql, SqlParameterSource paramSource, KeyHolder generatedKeyHolder, String[] keyColumnNames)\n\t\t\tthrows DataAccessException;\n\n\t/**\n\t * Execute a batch using the supplied SQL statement with the batch of supplied arguments.\n\t * @param sql the SQL statement to execute\n\t * @param batchArgs the array of {@link SqlParameterSource} containing the batch of\n\t * arguments for the query\n\t * @return an array containing the numbers of rows affected by each update in the batch\n\t * (may also contain special JDBC-defined negative values for affected rows such as\n\t * {@link java.sql.Statement#SUCCESS_NO_INFO}/{@link java.sql.Statement#EXECUTE_FAILED})\n\t * @throws DataAccessException if there is any problem issuing the update\n\t */\n\tint[] batchUpdate(String sql, SqlParameterSource[] batchArgs);\n\n\t/**\n\t * Executes a batch using the supplied SQL statement with the batch of supplied arguments.\n\t * @param sql the SQL statement to execute\n\t * @param batchValues the array of Maps containing the batch of arguments for the query\n\t * @return an array containing the numbers of rows affected by each update in the batch\n\t * (may also contain special JDBC-defined negative values for affected rows such as\n\t * {@link java.sql.Statement#SUCCESS_NO_INFO}/{@link java.sql.Statement#EXECUTE_FAILED})\n\t * @throws DataAccessException if there is any problem issuing the update\n\t */\n\tint[] batchUpdate(String sql, Map<String, ?>[] batchValues);\n\n\t/**\n\t * Execute a batch using the supplied SQL statement with the batch of supplied\n\t * arguments, returning generated keys.\n\t * <p>This method requires support for generated keys in the JDBC driver.\n\t * @param sql the SQL statement to execute\n\t * @param batchArgs the array of {@link SqlParameterSource} containing the batch of\n\t * arguments for the query\n\t * @param generatedKeyHolder a {@link KeyHolder} that will hold the generated keys\n\t * @return an array containing the numbers of rows affected by each update in the batch\n\t * (may also contain special JDBC-defined negative values for affected rows such as\n\t * {@link java.sql.Statement#SUCCESS_NO_INFO}/{@link java.sql.Statement#EXECUTE_FAILED})\n\t * @throws DataAccessException if there is any problem issuing the update\n\t * @since 6.1\n\t * @see org.springframework.jdbc.support.GeneratedKeyHolder\n\t * @see java.sql.DatabaseMetaData#supportsGetGeneratedKeys()\n\t */\n\tint[] batchUpdate(String sql, SqlParameterSource[] batchArgs, KeyHolder generatedKeyHolder);\n\n\t/**\n\t * Execute a batch using the supplied SQL statement with the batch of supplied arguments,\n\t * returning generated keys.\n\t * <p>This method requires support for generated keys in the JDBC driver.\n\t * @param sql the SQL statement to execute\n\t * @param batchArgs the array of {@link SqlParameterSource} containing the batch of\n\t * arguments for the query\n\t * @param generatedKeyHolder a {@link KeyHolder} that will hold the generated keys\n\t * @param keyColumnNames names of the columns that will have keys generated for them\n\t * @return an array containing the numbers of rows affected by each update in the batch\n\t * (may also contain special JDBC-defined negative values for affected rows such as\n\t * {@link java.sql.Statement#SUCCESS_NO_INFO}/{@link java.sql.Statement#EXECUTE_FAILED})\n\t * @throws DataAccessException if there is any problem issuing the update\n\t * @since 6.1\n\t * @see org.springframework.jdbc.support.GeneratedKeyHolder\n\t * @see java.sql.DatabaseMetaData#supportsGetGeneratedKeys()\n\t */\n\tint[] batchUpdate(String sql, SqlParameterSource[] batchArgs, KeyHolder generatedKeyHolder,\n\t\t\tString[] keyColumnNames);\n\n}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Template class with a basic set of JDBC operations, allowing the use\n * of named parameters rather than traditional '?' placeholders.\n *\n * <p>This class delegates to a wrapped {@link #getJdbcOperations() JdbcTemplate}\n * once the substitution from named parameters to JDBC style '?' placeholders is\n * done at execution time. It also allows for expanding a {@link java.util.List}\n * of values to the appropriate number of placeholders.\n *\n * <p>An instance of this template class is thread-safe once configured.\n * The underlying {@link org.springframework.jdbc.core.JdbcTemplate} is\n * exposed to allow for convenient access to the traditional\n * {@link org.springframework.jdbc.core.JdbcTemplate} methods.\n *\n * <p><b>NOTE: As of 6.1, there is a unified JDBC access facade available in\n * the form of {@link org.springframework.jdbc.core.simple.JdbcClient}.</b>\n * {@code JdbcClient} provides a fluent API style for common JDBC queries/updates\n * with flexible use of indexed or named parameters. It delegates to a\n * {@code JdbcTemplate}/{@code NamedParameterJdbcTemplate} for actual execution.\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @since 2.0\n * @see NamedParameterJdbcOperations\n * @see SqlParameterSource\n * @see ResultSetExtractor\n * @see RowCallbackHandler\n * @see RowMapper\n * @see org.springframework.jdbc.core.JdbcTemplate\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "signature": "public class NamedParameterJdbcTemplate",
    "source_code": "public class NamedParameterJdbcTemplate implements NamedParameterJdbcOperations {\n\n\t/** Default maximum number of entries for this template's SQL cache: 256. */\n\tpublic static final int DEFAULT_CACHE_LIMIT = 256;\n\n\n\t/** The JdbcTemplate we are wrapping. */\n\tprivate final JdbcOperations classicJdbcTemplate;\n\n\t/** Cache of original SQL String to ParsedSql representation. */\n\tprivate volatile ConcurrentLruCache<String, ParsedSql> parsedSqlCache =\n\t\t\tnew ConcurrentLruCache<>(DEFAULT_CACHE_LIMIT, NamedParameterUtils::parseSqlStatement);\n\n\n\t/**\n\t * Create a new NamedParameterJdbcTemplate for the given {@link DataSource}.\n\t * <p>Creates a classic Spring {@link org.springframework.jdbc.core.JdbcTemplate} and wraps it.\n\t * @param dataSource the JDBC DataSource to access\n\t */\n\tpublic NamedParameterJdbcTemplate(DataSource dataSource) {\n\t\tAssert.notNull(dataSource, \"DataSource must not be null\");\n\t\tthis.classicJdbcTemplate = new JdbcTemplate(dataSource);\n\t}\n\n\t/**\n\t * Create a new NamedParameterJdbcTemplate for the given classic\n\t * Spring {@link org.springframework.jdbc.core.JdbcTemplate}.\n\t * @param classicJdbcTemplate the classic Spring JdbcTemplate to wrap\n\t */\n\tpublic NamedParameterJdbcTemplate(JdbcOperations classicJdbcTemplate) {\n\t\tAssert.notNull(classicJdbcTemplate, \"JdbcTemplate must not be null\");\n\t\tthis.classicJdbcTemplate = classicJdbcTemplate;\n\t}\n\n\n\t/**\n\t * Expose the classic Spring JdbcTemplate operations to allow invocation\n\t * of less commonly used methods.\n\t */\n\t@Override\n\tpublic JdbcOperations getJdbcOperations() {\n\t\treturn this.classicJdbcTemplate;\n\t}\n\n\t/**\n\t * Expose the classic Spring {@link JdbcTemplate} itself, if available,\n\t * in particular for passing it on to other {@code JdbcTemplate} consumers.\n\t * <p>If sufficient for the purposes at hand, {@link #getJdbcOperations()}\n\t * is recommended over this variant.\n\t * @since 5.0.3\n\t */\n\tpublic JdbcTemplate getJdbcTemplate() {\n\t\tAssert.state(this.classicJdbcTemplate instanceof JdbcTemplate, \"No JdbcTemplate available\");\n\t\treturn (JdbcTemplate) this.classicJdbcTemplate;\n\t}\n\n\t/**\n\t * Specify the maximum number of entries for this template's SQL cache.\n\t * Default is 256. 0 indicates no caching, always parsing each statement.\n\t */\n\tpublic void setCacheLimit(int cacheLimit) {\n\t\tthis.parsedSqlCache = new ConcurrentLruCache<>(cacheLimit, NamedParameterUtils::parseSqlStatement);\n\t}\n\n\t/**\n\t * Return the maximum number of entries for this template's SQL cache.\n\t */\n\tpublic int getCacheLimit() {\n\t\treturn this.parsedSqlCache.capacity();\n\t}\n\n\n\t@Override\n\tpublic <T> @Nullable T execute(String sql, SqlParameterSource paramSource, PreparedStatementCallback<T> action)\n\t\t\tthrows DataAccessException {\n\n\t\treturn getJdbcOperations().execute(getPreparedStatementCreator(sql, paramSource), action);\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T execute(String sql, Map<String, ?> paramMap, PreparedStatementCallback<T> action)\n\t\t\tthrows DataAccessException {\n\n\t\treturn execute(sql, new MapSqlParameterSource(paramMap), action);\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T execute(String sql, PreparedStatementCallback<T> action) throws DataAccessException {\n\t\treturn execute(sql, EmptySqlParameterSource.INSTANCE, action);\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T query(String sql, SqlParameterSource paramSource, ResultSetExtractor<T> rse)\n\t\t\tthrows DataAccessException {\n\n\t\treturn getJdbcOperations().query(getPreparedStatementCreator(sql, paramSource), rse);\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T query(String sql, Map<String, ?> paramMap, ResultSetExtractor<T> rse)\n\t\t\tthrows DataAccessException {\n\n\t\treturn query(sql, new MapSqlParameterSource(paramMap), rse);\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T query(String sql, ResultSetExtractor<T> rse) throws DataAccessException {\n\t\treturn query(sql, EmptySqlParameterSource.INSTANCE, rse);\n\t}\n\n\t@Override\n\tpublic void query(String sql, SqlParameterSource paramSource, RowCallbackHandler rch)\n\t\t\tthrows DataAccessException {\n\n\t\tgetJdbcOperations().query(getPreparedStatementCreator(sql, paramSource), rch);\n\t}\n\n\t@Override\n\tpublic void query(String sql, Map<String, ?> paramMap, RowCallbackHandler rch)\n\t\t\tthrows DataAccessException {\n\n\t\tquery(sql, new MapSqlParameterSource(paramMap), rch);\n\t}\n\n\t@Override\n\tpublic void query(String sql, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(sql, EmptySqlParameterSource.INSTANCE, rch);\n\t}\n\n\t@Override\n\tpublic <T> List<T> query(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException {\n\n\t\treturn getJdbcOperations().query(getPreparedStatementCreator(sql, paramSource), rowMapper);\n\t}\n\n\t@Override\n\tpublic <T> List<T> query(String sql, Map<String, ?> paramMap, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException {\n\n\t\treturn query(sql, new MapSqlParameterSource(paramMap), rowMapper);\n\t}\n\n\t@Override\n\tpublic <T> List<T> query(String sql, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn query(sql, EmptySqlParameterSource.INSTANCE, rowMapper);\n\t}\n\n\t@Override\n\tpublic <T> Stream<T> queryForStream(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException {\n\n\t\treturn getJdbcOperations().queryForStream(getPreparedStatementCreator(sql, paramSource), rowMapper);\n\t}\n\n\t@Override\n\tpublic <T> Stream<T> queryForStream(String sql, Map<String, ?> paramMap, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException {\n\n\t\treturn queryForStream(sql, new MapSqlParameterSource(paramMap), rowMapper);\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T queryForObject(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException {\n\n\t\tList<T> results = getJdbcOperations().query(getPreparedStatementCreator(sql, paramSource), rowMapper);\n\t\treturn DataAccessUtils.nullableSingleResult(results);\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T queryForObject(String sql, Map<String, ?> paramMap, RowMapper<T>rowMapper)\n\t\t\tthrows DataAccessException {\n\n\t\treturn queryForObject(sql, new MapSqlParameterSource(paramMap), rowMapper);\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T queryForObject(String sql, SqlParameterSource paramSource, Class<T> requiredType)\n\t\t\tthrows DataAccessException {\n\n\t\treturn queryForObject(sql, paramSource, new SingleColumnRowMapper<>(requiredType));\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T queryForObject(String sql, Map<String, ?> paramMap, Class<T> requiredType)\n\t\t\tthrows DataAccessException {\n\n\t\treturn queryForObject(sql, paramMap, new SingleColumnRowMapper<>(requiredType));\n\t}\n\n\t@Override\n\tpublic Map<String, Object> queryForMap(String sql, SqlParameterSource paramSource) throws DataAccessException {\n\t\tMap<String, Object> result = queryForObject(sql, paramSource, new ColumnMapRowMapper());\n\t\tAssert.state(result != null, \"No result map\");\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic Map<String, Object> queryForMap(String sql, Map<String, ?> paramMap) throws DataAccessException {\n\t\tMap<String, Object> result = queryForObject(sql, paramMap, new ColumnMapRowMapper());\n\t\tAssert.state(result != null, \"No result map\");\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic <T> List<T> queryForList(String sql, SqlParameterSource paramSource, Class<T> elementType)\n\t\t\tthrows DataAccessException {\n\n\t\treturn query(sql, paramSource, new SingleColumnRowMapper<>(elementType));\n\t}\n\n\t@Override\n\tpublic <T> List<T> queryForList(String sql, Map<String, ?> paramMap, Class<T> elementType)\n\t\t\tthrows DataAccessException {\n\n\t\treturn queryForList(sql, new MapSqlParameterSource(paramMap), elementType);\n\t}\n\n\t@Override\n\tpublic List<Map<String, Object>> queryForList(String sql, SqlParameterSource paramSource)\n\t\t\tthrows DataAccessException {\n\n\t\treturn query(sql, paramSource, new ColumnMapRowMapper());\n\t}\n\n\t@Override\n\tpublic List<Map<String, Object>> queryForList(String sql, Map<String, ?> paramMap)\n\t\t\tthrows DataAccessException {\n\n\t\treturn queryForList(sql, new MapSqlParameterSource(paramMap));\n\t}\n\n\t@Override\n\tpublic SqlRowSet queryForRowSet(String sql, SqlParameterSource paramSource) throws DataAccessException {\n\t\tSqlRowSet result = getJdbcOperations().query(\n\t\t\t\tgetPreparedStatementCreator(sql, paramSource), new SqlRowSetResultSetExtractor());\n\t\tAssert.state(result != null, \"No result\");\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic SqlRowSet queryForRowSet(String sql, Map<String, ?> paramMap) throws DataAccessException {\n\t\treturn queryForRowSet(sql, new MapSqlParameterSource(paramMap));\n\t}\n\n\t@Override\n\tpublic int update(String sql, SqlParameterSource paramSource) throws DataAccessException {\n\t\treturn getJdbcOperations().update(getPreparedStatementCreator(sql, paramSource));\n\t}\n\n\t@Override\n\tpublic int update(String sql, Map<String, ?> paramMap) throws DataAccessException {\n\t\treturn update(sql, new MapSqlParameterSource(paramMap));\n\t}\n\n\t@Override\n\tpublic int update(String sql, SqlParameterSource paramSource, KeyHolder generatedKeyHolder)\n\t\t\tthrows DataAccessException {\n\n\t\treturn update(sql, paramSource, generatedKeyHolder, null);\n\t}\n\n\t@Override\n\tpublic int update(\n\t\t\tString sql, SqlParameterSource paramSource, KeyHolder generatedKeyHolder, String @Nullable [] keyColumnNames)\n\t\t\tthrows DataAccessException {\n\n\t\tPreparedStatementCreator psc = getPreparedStatementCreator(sql, paramSource, pscf -> {\n\t\t\tif (keyColumnNames != null) {\n\t\t\t\tpscf.setGeneratedKeysColumnNames(keyColumnNames);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpscf.setReturnGeneratedKeys(true);\n\t\t\t}\n\t\t});\n\t\treturn getJdbcOperations().update(psc, generatedKeyHolder);\n\t}\n\n\t@Override\n\tpublic int[] batchUpdate(String sql, SqlParameterSource[] batchArgs) {\n\t\tif (batchArgs.length == 0) {\n\t\t\treturn new int[0];\n\t\t}\n\n\t\tParsedSql parsedSql = getParsedSql(sql);\n\t\tPreparedStatementCreatorFactory pscf = getPreparedStatementCreatorFactory(parsedSql, batchArgs[0]);\n\n\t\treturn getJdbcOperations().batchUpdate(\n\t\t\t\tpscf.getSql(),\n\t\t\t\tnew BatchPreparedStatementSetter() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n\t\t\t\t\t\t@Nullable Object[] values = NamedParameterUtils.buildValueArray(parsedSql, batchArgs[i], null);\n\t\t\t\t\t\tpscf.newPreparedStatementSetter(values).setValues(ps);\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int getBatchSize() {\n\t\t\t\t\t\treturn batchArgs.length;\n\t\t\t\t\t}\n\t\t\t\t});\n\t}\n\n\t@Override\n\tpublic int[] batchUpdate(String sql, Map<String, ?>[] batchValues) {\n\t\treturn batchUpdate(sql, SqlParameterSourceUtils.createBatch(batchValues));\n\t}\n\n\t@Override\n\tpublic int[] batchUpdate(String sql, SqlParameterSource[] batchArgs, KeyHolder generatedKeyHolder) {\n\t\treturn batchUpdate(sql, batchArgs, generatedKeyHolder, null);\n\t}\n\n\t@Override\n\tpublic int[] batchUpdate(String sql, SqlParameterSource[] batchArgs, KeyHolder generatedKeyHolder,\n\t\t\tString @Nullable [] keyColumnNames) {\n\n\t\tif (batchArgs.length == 0) {\n\t\t\treturn new int[0];\n\t\t}\n\n\t\tParsedSql parsedSql = getParsedSql(sql);\n\t\tSqlParameterSource paramSource = batchArgs[0];\n\t\tPreparedStatementCreatorFactory pscf = getPreparedStatementCreatorFactory(parsedSql, paramSource);\n\t\tif (keyColumnNames != null) {\n\t\t\tpscf.setGeneratedKeysColumnNames(keyColumnNames);\n\t\t}\n\t\telse {\n\t\t\tpscf.setReturnGeneratedKeys(true);\n\t\t}\n\t\t@Nullable Object[] params = NamedParameterUtils.buildValueArray(parsedSql, paramSource, null);\n\t\tPreparedStatementCreator psc = pscf.newPreparedStatementCreator(params);\n\t\treturn getJdbcOperations().batchUpdate(psc, new BatchPreparedStatementSetter() {\n\t\t\t@Override\n\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n\t\t\t\t@Nullable Object[] values = NamedParameterUtils.buildValueArray(parsedSql, batchArgs[i], null);\n\t\t\t\tpscf.newPreparedStatementSetter(values).setValues(ps);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int getBatchSize() {\n\t\t\t\treturn batchArgs.length;\n\t\t\t}\n\t\t}, generatedKeyHolder);\n\t}\n\n\n\t/**\n\t * Build a {@link PreparedStatementCreator} based on the given SQL and named parameters.\n\t * <p>Note: Directly called from all {@code query} variants. Delegates to the common\n\t * {@link #getPreparedStatementCreator(String, SqlParameterSource, Consumer)} method.\n\t * @param sql the SQL statement to execute\n\t * @param paramSource container of arguments to bind\n\t * @return the corresponding {@link PreparedStatementCreator}\n\t * @see #getPreparedStatementCreator(String, SqlParameterSource, Consumer)\n\t */\n\tprotected PreparedStatementCreator getPreparedStatementCreator(String sql, SqlParameterSource paramSource) {\n\t\treturn getPreparedStatementCreator(sql, paramSource, null);\n\t}\n\n\t/**\n\t * Build a {@link PreparedStatementCreator} based on the given SQL and named parameters.\n\t * <p>Note: Used for the {@code update} variant with generated key handling, and also\n\t * delegated from {@link #getPreparedStatementCreator(String, SqlParameterSource)}.\n\t * @param sql the SQL statement to execute\n\t * @param paramSource container of arguments to bind\n\t * @param customizer callback for setting further properties on the\n\t * {@link PreparedStatementCreatorFactory} in use, applied before the\n\t * actual {@code newPreparedStatementCreator} call\n\t * @return the corresponding {@link PreparedStatementCreator}\n\t * @since 5.0.5\n\t * @see #getParsedSql(String)\n\t * @see PreparedStatementCreatorFactory#PreparedStatementCreatorFactory(String, List)\n\t * @see PreparedStatementCreatorFactory#newPreparedStatementCreator(Object[])\n\t */\n\tprotected PreparedStatementCreator getPreparedStatementCreator(String sql, SqlParameterSource paramSource,\n\t\t\t@Nullable Consumer<PreparedStatementCreatorFactory> customizer) {\n\n\t\tParsedSql parsedSql = getParsedSql(sql);\n\t\tPreparedStatementCreatorFactory pscf = getPreparedStatementCreatorFactory(parsedSql, paramSource);\n\t\tif (customizer != null) {\n\t\t\tcustomizer.accept(pscf);\n\t\t}\n\t\t@Nullable Object[] params = NamedParameterUtils.buildValueArray(parsedSql, paramSource, null);\n\t\treturn pscf.newPreparedStatementCreator(params);\n\t}\n\n\t/**\n\t * Obtain a parsed representation of the given SQL statement.\n\t * <p>The default implementation uses an LRU cache with an upper limit of 256 entries.\n\t * @param sql the original SQL statement\n\t * @return a representation of the parsed SQL statement\n\t */\n\tprotected ParsedSql getParsedSql(String sql) {\n\t\tAssert.notNull(sql, \"SQL must not be null\");\n\t\treturn this.parsedSqlCache.get(sql);\n\t}\n\n\t/**\n\t * Build a {@link PreparedStatementCreatorFactory} based on the given SQL and named parameters.\n\t * @param parsedSql parsed representation of the given SQL statement\n\t * @param paramSource container of arguments to bind\n\t * @return the corresponding {@link PreparedStatementCreatorFactory}\n\t * @since 5.1.3\n\t * @see #getPreparedStatementCreator(String, SqlParameterSource, Consumer)\n\t * @see #getParsedSql(String)\n\t */\n\tprotected PreparedStatementCreatorFactory getPreparedStatementCreatorFactory(\n\t\t\tParsedSql parsedSql, SqlParameterSource paramSource) {\n\n\t\tString sqlToUse = NamedParameterUtils.substituteNamedParameters(parsedSql, paramSource);\n\t\tList<SqlParameter> declaredParameters = NamedParameterUtils.buildSqlParameterList(parsedSql, paramSource);\n\t\treturn new PreparedStatementCreatorFactory(sqlToUse, declaredParameters);\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#batchUpdate(sql,Map<String,batchValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "batchValues"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, Map<String, ?>[] batchValues)",
    "source_code": "\tpublic int[] batchUpdate(String sql, Map<String, ?>[] batchValues) {\n\t\treturn batchUpdate(sql, SqlParameterSourceUtils.createBatch(batchValues));\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#batchUpdate(sql,batchArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "batchArgs"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, SqlParameterSource[] batchArgs)",
    "source_code": "\tpublic int[] batchUpdate(String sql, SqlParameterSource[] batchArgs) {\n\t\tif (batchArgs.length == 0) {\n\t\t\treturn new int[0];\n\t\t}\n\n\t\tParsedSql parsedSql = getParsedSql(sql);\n\t\tPreparedStatementCreatorFactory pscf = getPreparedStatementCreatorFactory(parsedSql, batchArgs[0]);\n\n\t\treturn getJdbcOperations().batchUpdate(\n\t\t\t\tpscf.getSql(),\n\t\t\t\tnew BatchPreparedStatementSetter() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n\t\t\t\t\t\t@Nullable Object[] values = NamedParameterUtils.buildValueArray(parsedSql, batchArgs[i], null);\n\t\t\t\t\t\tpscf.newPreparedStatementSetter(values).setValues(ps);\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int getBatchSize() {\n\t\t\t\t\t\treturn batchArgs.length;\n\t\t\t\t\t}\n\t\t\t\t});\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#batchUpdate(sql,batchArgs,generatedKeyHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "batchArgs",
      "generatedKeyHolder"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, SqlParameterSource[] batchArgs, KeyHolder generatedKeyHolder)",
    "source_code": "\tpublic int[] batchUpdate(String sql, SqlParameterSource[] batchArgs, KeyHolder generatedKeyHolder) {\n\t\treturn batchUpdate(sql, batchArgs, generatedKeyHolder, null);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#batchUpdate(sql,batchArgs,generatedKeyHolder,keyColumnNames)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "batchArgs",
      "generatedKeyHolder",
      "keyColumnNames"
    ],
    "position": {
      "column": 1,
      "line": 394
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, SqlParameterSource[] batchArgs, KeyHolder generatedKeyHolder,\n\t\t\tString @Nullable [] keyColumnNames)",
    "source_code": "\tpublic int[] batchUpdate(String sql, SqlParameterSource[] batchArgs, KeyHolder generatedKeyHolder,"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#execute(sql,Map<String,paramMap,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "T",
    "signature": "public T execute(String sql, Map<String, ?> paramMap, PreparedStatementCallback<T> action)",
    "source_code": "\tpublic <T> @Nullable T execute(String sql, Map<String, ?> paramMap, PreparedStatementCallback<T> action)"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#execute(sql,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "T",
    "signature": "public T execute(String sql, PreparedStatementCallback<T> action)",
    "source_code": "\tpublic <T> @Nullable T execute(String sql, PreparedStatementCallback<T> action) throws DataAccessException {\n\t\treturn execute(sql, EmptySqlParameterSource.INSTANCE, action);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#execute(sql,paramSource,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "T",
    "signature": "public T execute(String sql, SqlParameterSource paramSource, PreparedStatementCallback<T> action)",
    "source_code": "\tpublic <T> @Nullable T execute(String sql, SqlParameterSource paramSource, PreparedStatementCallback<T> action)"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#getBatchSize()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 420
    },
    "return": "int",
    "signature": "public int getBatchSize()",
    "source_code": "\t\t\tpublic int getBatchSize() {\n\t\t\t\treturn batchArgs.length;\n\t\t\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#getCacheLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the maximum number of entries for this template's SQL cache.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "int",
    "signature": "public int getCacheLimit()",
    "source_code": "\tpublic int getCacheLimit() {\n\t\treturn this.parsedSqlCache.capacity();\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#getJdbcOperations()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Expose the classic Spring JdbcTemplate operations to allow invocation\n\t * of less commonly used methods.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "JdbcOperations",
    "signature": "public JdbcOperations getJdbcOperations()",
    "source_code": "\tpublic JdbcOperations getJdbcOperations() {\n\t\treturn this.classicJdbcTemplate;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#getJdbcTemplate()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Expose the classic Spring {@link JdbcTemplate} itself, if available,\n\t * in particular for passing it on to other {@code JdbcTemplate} consumers.\n\t * <p>If sufficient for the purposes at hand, {@link #getJdbcOperations()}\n\t * is recommended over this variant.\n\t * @since 5.0.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "JdbcTemplate",
    "signature": "public JdbcTemplate getJdbcTemplate()",
    "source_code": "\tpublic JdbcTemplate getJdbcTemplate() {\n\t\tAssert.state(this.classicJdbcTemplate instanceof JdbcTemplate, \"No JdbcTemplate available\");\n\t\treturn (JdbcTemplate) this.classicJdbcTemplate;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#getParsedSql(sql)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a parsed representation of the given SQL statement.\n\t * <p>The default implementation uses an LRU cache with an upper limit of 256 entries.\n\t * @param sql the original SQL statement\n\t * @return a representation of the parsed SQL statement\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sql"
    ],
    "position": {
      "column": 1,
      "line": 473
    },
    "return": "ParsedSql",
    "signature": "protected ParsedSql getParsedSql(String sql)",
    "source_code": "\tprotected ParsedSql getParsedSql(String sql) {\n\t\tAssert.notNull(sql, \"SQL must not be null\");\n\t\treturn this.parsedSqlCache.get(sql);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#getPreparedStatementCreator(sql,paramSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link PreparedStatementCreator} based on the given SQL and named parameters.\n\t * <p>Note: Directly called from all {@code query} variants. Delegates to the common\n\t * {@link #getPreparedStatementCreator(String, SqlParameterSource, Consumer)} method.\n\t * @param sql the SQL statement to execute\n\t * @param paramSource container of arguments to bind\n\t * @return the corresponding {@link PreparedStatementCreator}\n\t * @see #getPreparedStatementCreator(String, SqlParameterSource, Consumer)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "PreparedStatementCreator",
    "signature": "protected PreparedStatementCreator getPreparedStatementCreator(String sql, SqlParameterSource paramSource)",
    "source_code": "\tprotected PreparedStatementCreator getPreparedStatementCreator(String sql, SqlParameterSource paramSource) {\n\t\treturn getPreparedStatementCreator(sql, paramSource, null);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#getPreparedStatementCreator(sql,paramSource,customizer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link PreparedStatementCreator} based on the given SQL and named parameters.\n\t * <p>Note: Used for the {@code update} variant with generated key handling, and also\n\t * delegated from {@link #getPreparedStatementCreator(String, SqlParameterSource)}.\n\t * @param sql the SQL statement to execute\n\t * @param paramSource container of arguments to bind\n\t * @param customizer callback for setting further properties on the\n\t * {@link PreparedStatementCreatorFactory} in use, applied before the\n\t * actual {@code newPreparedStatementCreator} call\n\t * @return the corresponding {@link PreparedStatementCreator}\n\t * @since 5.0.5\n\t * @see #getParsedSql(String)\n\t * @see PreparedStatementCreatorFactory#PreparedStatementCreatorFactory(String, List)\n\t * @see PreparedStatementCreatorFactory#newPreparedStatementCreator(Object[])\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sql",
      "paramSource",
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 455
    },
    "return": "PreparedStatementCreator",
    "signature": "protected PreparedStatementCreator getPreparedStatementCreator(String sql, SqlParameterSource paramSource,\n\t\t\t@Nullable Consumer<PreparedStatementCreatorFactory> customizer)",
    "source_code": "\tprotected PreparedStatementCreator getPreparedStatementCreator(String sql, SqlParameterSource paramSource,"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#getPreparedStatementCreatorFactory(parsedSql,paramSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link PreparedStatementCreatorFactory} based on the given SQL and named parameters.\n\t * @param parsedSql parsed representation of the given SQL statement\n\t * @param paramSource container of arguments to bind\n\t * @return the corresponding {@link PreparedStatementCreatorFactory}\n\t * @since 5.1.3\n\t * @see #getPreparedStatementCreator(String, SqlParameterSource, Consumer)\n\t * @see #getParsedSql(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parsedSql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 487
    },
    "return": "PreparedStatementCreatorFactory",
    "signature": "protected PreparedStatementCreatorFactory getPreparedStatementCreatorFactory(ParsedSql parsedSql, SqlParameterSource paramSource)",
    "source_code": "\tprotected PreparedStatementCreatorFactory getPreparedStatementCreatorFactory("
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#query(sql,Map<String,paramMap,rch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "void",
    "signature": "public void query(String sql, Map<String, ?> paramMap, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, Map<String, ?> paramMap, RowCallbackHandler rch)"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#query(sql,Map<String,paramMap,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, Map<String, ?> paramMap, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, Map<String, ?> paramMap, RowMapper<T> rowMapper)"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#query(sql,Map<String,paramMap,rse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "T",
    "signature": "public T query(String sql, Map<String, ?> paramMap, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> @Nullable T query(String sql, Map<String, ?> paramMap, ResultSetExtractor<T> rse)"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#query(sql,paramSource,rch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "void",
    "signature": "public void query(String sql, SqlParameterSource paramSource, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, SqlParameterSource paramSource, RowCallbackHandler rch)"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#query(sql,paramSource,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#query(sql,paramSource,rse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "T",
    "signature": "public T query(String sql, SqlParameterSource paramSource, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> @Nullable T query(String sql, SqlParameterSource paramSource, ResultSetExtractor<T> rse)"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#query(sql,rch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "void",
    "signature": "public void query(String sql, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(sql, EmptySqlParameterSource.INSTANCE, rch);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#query(sql,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn query(sql, EmptySqlParameterSource.INSTANCE, rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#query(sql,rse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "T",
    "signature": "public T query(String sql, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> @Nullable T query(String sql, ResultSetExtractor<T> rse) throws DataAccessException {\n\t\treturn query(sql, EmptySqlParameterSource.INSTANCE, rse);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#queryForList(sql,Map<String,paramMap)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "Object>>",
    "signature": "public Object>> queryForList(String sql, Map<String, ?> paramMap)",
    "source_code": "\tpublic List<Map<String, Object>> queryForList(String sql, Map<String, ?> paramMap)"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#queryForList(sql,Map<String,paramMap,elementType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "List<T>",
    "signature": "public List<T> queryForList(String sql, Map<String, ?> paramMap, Class<T> elementType)",
    "source_code": "\tpublic <T> List<T> queryForList(String sql, Map<String, ?> paramMap, Class<T> elementType)"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#queryForList(sql,paramSource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "Object>>",
    "signature": "public Object>> queryForList(String sql, SqlParameterSource paramSource)",
    "source_code": "\tpublic List<Map<String, Object>> queryForList(String sql, SqlParameterSource paramSource)"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#queryForList(sql,paramSource,elementType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "List<T>",
    "signature": "public List<T> queryForList(String sql, SqlParameterSource paramSource, Class<T> elementType)",
    "source_code": "\tpublic <T> List<T> queryForList(String sql, SqlParameterSource paramSource, Class<T> elementType)"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#queryForMap(sql,Map<String,paramMap)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "Object>",
    "signature": "public Object> queryForMap(String sql, Map<String, ?> paramMap)",
    "source_code": "\tpublic Map<String, Object> queryForMap(String sql, Map<String, ?> paramMap) throws DataAccessException {\n\t\tMap<String, Object> result = queryForObject(sql, paramMap, new ColumnMapRowMapper());\n\t\tAssert.state(result != null, \"No result map\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#queryForMap(sql,paramSource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "Object>",
    "signature": "public Object> queryForMap(String sql, SqlParameterSource paramSource)",
    "source_code": "\tpublic Map<String, Object> queryForMap(String sql, SqlParameterSource paramSource) throws DataAccessException {\n\t\tMap<String, Object> result = queryForObject(sql, paramSource, new ColumnMapRowMapper());\n\t\tAssert.state(result != null, \"No result map\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#queryForObject(sql,Map<String,paramMap,RowMapper<T>rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "RowMapper<T>rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, Map<String, ?> paramMap, RowMapper<T>rowMapper)",
    "source_code": "\tpublic <T> @Nullable T queryForObject(String sql, Map<String, ?> paramMap, RowMapper<T>rowMapper)"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#queryForObject(sql,Map<String,paramMap,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, Map<String, ?> paramMap, Class<T> requiredType)",
    "source_code": "\tpublic <T> @Nullable T queryForObject(String sql, Map<String, ?> paramMap, Class<T> requiredType)"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#queryForObject(sql,paramSource,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, SqlParameterSource paramSource, Class<T> requiredType)",
    "source_code": "\tpublic <T> @Nullable T queryForObject(String sql, SqlParameterSource paramSource, Class<T> requiredType)"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#queryForObject(sql,paramSource,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> @Nullable T queryForObject(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#queryForRowSet(sql,Map<String,paramMap)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "SqlRowSet",
    "signature": "public SqlRowSet queryForRowSet(String sql, Map<String, ?> paramMap)",
    "source_code": "\tpublic SqlRowSet queryForRowSet(String sql, Map<String, ?> paramMap) throws DataAccessException {\n\t\treturn queryForRowSet(sql, new MapSqlParameterSource(paramMap));\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#queryForRowSet(sql,paramSource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "SqlRowSet",
    "signature": "public SqlRowSet queryForRowSet(String sql, SqlParameterSource paramSource)",
    "source_code": "\tpublic SqlRowSet queryForRowSet(String sql, SqlParameterSource paramSource) throws DataAccessException {\n\t\tSqlRowSet result = getJdbcOperations().query(\n\t\t\t\tgetPreparedStatementCreator(sql, paramSource), new SqlRowSetResultSetExtractor());\n\t\tAssert.state(result != null, \"No result\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#queryForStream(sql,Map<String,paramMap,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(String sql, Map<String, ?> paramMap, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(String sql, Map<String, ?> paramMap, RowMapper<T> rowMapper)"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#queryForStream(sql,paramSource,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#setCacheLimit(cacheLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the maximum number of entries for this template's SQL cache.\n\t * Default is 256. 0 indicates no caching, always parsing each statement.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheLimit"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "public void setCacheLimit(int cacheLimit)",
    "source_code": "\tpublic void setCacheLimit(int cacheLimit) {\n\t\tthis.parsedSqlCache = new ConcurrentLruCache<>(cacheLimit, NamedParameterUtils::parseSqlStatement);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#setValues(ps,i)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "i"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "void",
    "signature": "public void setValues(PreparedStatement ps, int i)",
    "source_code": "\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n\t\t\t\t@Nullable Object[] values = NamedParameterUtils.buildValueArray(parsedSql, batchArgs[i], null);\n\t\t\t\tpscf.newPreparedStatementSetter(values).setValues(ps);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#update(sql,Map<String,paramMap)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "int",
    "signature": "public int update(String sql, Map<String, ?> paramMap)",
    "source_code": "\tpublic int update(String sql, Map<String, ?> paramMap) throws DataAccessException {\n\t\treturn update(sql, new MapSqlParameterSource(paramMap));\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#update(sql,paramSource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "int",
    "signature": "public int update(String sql, SqlParameterSource paramSource)",
    "source_code": "\tpublic int update(String sql, SqlParameterSource paramSource) throws DataAccessException {\n\t\treturn getJdbcOperations().update(getPreparedStatementCreator(sql, paramSource));\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#update(sql,paramSource,generatedKeyHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "generatedKeyHolder"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "int",
    "signature": "public int update(String sql, SqlParameterSource paramSource, KeyHolder generatedKeyHolder)",
    "source_code": "\tpublic int update(String sql, SqlParameterSource paramSource, KeyHolder generatedKeyHolder)"
  },
  "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#update(sql,paramSource,generatedKeyHolder,keyColumnNames)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "generatedKeyHolder",
      "keyColumnNames"
    ],
    "position": {
      "column": 1,
      "line": 344
    },
    "return": "int",
    "signature": "public int update(String sql, SqlParameterSource paramSource, KeyHolder generatedKeyHolder, String @Nullable [] keyColumnNames)",
    "source_code": "\tpublic int update("
  },
  "org.springframework.jdbc.core.namedparam.SqlParameterSource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Interface that defines common functionality for objects that can\n * offer parameter values for named SQL parameters, serving as argument\n * for {@link NamedParameterJdbcTemplate} operations.\n *\n * <p>This interface allows for the specification of SQL type in addition\n * to parameter values. All parameter values and types are identified by\n * specifying the name of the parameter.\n *\n * <p>Intended to wrap various implementations like a Map or a JavaBean\n * with a consistent interface.\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @since 2.0\n * @see NamedParameterJdbcOperations\n * @see NamedParameterJdbcTemplate\n * @see MapSqlParameterSource\n * @see BeanPropertySqlParameterSource\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public interface SqlParameterSource",
    "source_code": "public interface SqlParameterSource {\n\n\t/**\n\t * Constant that indicates an unknown (or unspecified) SQL type.\n\t * To be returned from {@code getType} when no specific SQL type known.\n\t * @see #getSqlType\n\t * @see java.sql.Types\n\t */\n\tint TYPE_UNKNOWN = JdbcUtils.TYPE_UNKNOWN;\n\n\n\t/**\n\t * Determine whether there is a value for the specified named parameter.\n\t * @param paramName the name of the parameter\n\t * @return whether there is a value defined\n\t */\n\tboolean hasValue(String paramName);\n\n\t/**\n\t * Return the parameter value for the requested named parameter.\n\t * @param paramName the name of the parameter\n\t * @return the value of the specified parameter\n\t * @throws IllegalArgumentException if there is no value for the requested parameter\n\t */\n\t@Nullable Object getValue(String paramName) throws IllegalArgumentException;\n\n\t/**\n\t * Determine the SQL type for the specified named parameter.\n\t * @param paramName the name of the parameter\n\t * @return the SQL type of the specified parameter,\n\t * or {@code TYPE_UNKNOWN} if not known\n\t * @see #TYPE_UNKNOWN\n\t */\n\tdefault int getSqlType(String paramName) {\n\t\treturn TYPE_UNKNOWN;\n\t}\n\n\t/**\n\t * Determine the type name for the specified named parameter.\n\t * @param paramName the name of the parameter\n\t * @return the type name of the specified parameter,\n\t * or {@code null} if not known\n\t */\n\tdefault @Nullable String getTypeName(String paramName) {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Enumerate all available parameter names if possible.\n\t * <p>This is an optional operation, primarily for use with\n\t * {@link org.springframework.jdbc.core.simple.SimpleJdbcInsert}\n\t * and {@link org.springframework.jdbc.core.simple.SimpleJdbcCall}.\n\t * @return the array of parameter names, or {@code null} if not determinable\n\t * @since 5.0.3\n\t * @see SqlParameterSourceUtils#extractCaseInsensitiveParameterNames\n\t */\n\tdefault String @Nullable [] getParameterNames() {\n\t\treturn null;\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract class to provide base functionality for easy (batch) inserts\n * based on configuration options and database meta-data.\n *\n * <p>This class provides the processing arrangement for {@link SimpleJdbcInsert}.\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 2.5\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "signature": "public class AbstractJdbcInsert",
    "source_code": "public abstract class AbstractJdbcInsert {\n\n\t/** Logger available to subclasses. */\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t/** Lower-level class used to execute SQL. */\n\tprivate final JdbcTemplate jdbcTemplate;\n\n\t/** Context used to retrieve and manage database meta-data. */\n\tprivate final TableMetaDataContext tableMetaDataContext = new TableMetaDataContext();\n\n\t/** List of column names to be used in insert statement. */\n\tprivate final List<String> declaredColumns = new ArrayList<>();\n\n\t/** The names of the columns holding the generated key. */\n\tprivate String[] generatedKeyNames = new String[0];\n\n\t/**\n\t * Has this operation been compiled? Compilation means at least checking\n\t * that a DataSource or JdbcTemplate has been provided.\n\t */\n\tprivate volatile boolean compiled;\n\n\t/** The generated string used for insert statement. */\n\tprivate String insertString = \"\";\n\n\t/** The SQL type information for the insert columns. */\n\tprivate int[] insertTypes = new int[0];\n\n\n\t/**\n\t * Constructor to be used when initializing using a {@link DataSource}.\n\t * @param dataSource the {@code DataSource} to be used\n\t */\n\tprotected AbstractJdbcInsert(DataSource dataSource) {\n\t\tthis.jdbcTemplate = new JdbcTemplate(dataSource);\n\t}\n\n\t/**\n\t * Constructor to be used when initializing using a {@link JdbcTemplate}.\n\t * @param jdbcTemplate the {@code JdbcTemplate} to use\n\t */\n\tprotected AbstractJdbcInsert(JdbcTemplate jdbcTemplate) {\n\t\tAssert.notNull(jdbcTemplate, \"JdbcTemplate must not be null\");\n\t\tthis.jdbcTemplate = jdbcTemplate;\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Methods dealing with configuration properties\n\t//-------------------------------------------------------------------------\n\n\t/**\n\t * Get the configured {@link JdbcTemplate}.\n\t */\n\tpublic JdbcTemplate getJdbcTemplate() {\n\t\treturn this.jdbcTemplate;\n\t}\n\n\t/**\n\t * Set the name of the table for this insert.\n\t */\n\tpublic void setTableName(@Nullable String tableName) {\n\t\tcheckIfConfigurationModificationIsAllowed();\n\t\tthis.tableMetaDataContext.setTableName(tableName);\n\t}\n\n\t/**\n\t * Get the name of the table for this insert.\n\t */\n\tpublic @Nullable String getTableName() {\n\t\treturn this.tableMetaDataContext.getTableName();\n\t}\n\n\t/**\n\t * Set the name of the schema for this insert.\n\t */\n\tpublic void setSchemaName(@Nullable String schemaName) {\n\t\tcheckIfConfigurationModificationIsAllowed();\n\t\tthis.tableMetaDataContext.setSchemaName(schemaName);\n\t}\n\n\t/**\n\t * Get the name of the schema for this insert.\n\t */\n\tpublic @Nullable String getSchemaName() {\n\t\treturn this.tableMetaDataContext.getSchemaName();\n\t}\n\n\t/**\n\t * Set the name of the catalog for this insert.\n\t */\n\tpublic void setCatalogName(@Nullable String catalogName) {\n\t\tcheckIfConfigurationModificationIsAllowed();\n\t\tthis.tableMetaDataContext.setCatalogName(catalogName);\n\t}\n\n\t/**\n\t * Get the name of the catalog for this insert.\n\t */\n\tpublic @Nullable String getCatalogName() {\n\t\treturn this.tableMetaDataContext.getCatalogName();\n\t}\n\n\t/**\n\t * Set the names of the columns to be used.\n\t */\n\tpublic void setColumnNames(List<String> columnNames) {\n\t\tcheckIfConfigurationModificationIsAllowed();\n\t\tthis.declaredColumns.clear();\n\t\tthis.declaredColumns.addAll(columnNames);\n\t}\n\n\t/**\n\t * Get the names of the columns used.\n\t */\n\tpublic List<String> getColumnNames() {\n\t\treturn Collections.unmodifiableList(this.declaredColumns);\n\t}\n\n\t/**\n\t * Specify the name of a single generated key column.\n\t */\n\tpublic void setGeneratedKeyName(String generatedKeyName) {\n\t\tcheckIfConfigurationModificationIsAllowed();\n\t\tthis.generatedKeyNames = new String[] {generatedKeyName};\n\t}\n\n\t/**\n\t * Set the names of any generated keys.\n\t */\n\tpublic void setGeneratedKeyNames(String... generatedKeyNames) {\n\t\tcheckIfConfigurationModificationIsAllowed();\n\t\tthis.generatedKeyNames = generatedKeyNames;\n\t}\n\n\t/**\n\t * Get the names of any generated keys.\n\t */\n\tpublic String[] getGeneratedKeyNames() {\n\t\treturn this.generatedKeyNames;\n\t}\n\n\t/**\n\t * Specify whether the parameter meta-data for the call should be used.\n\t * <p>The default is {@code true}.\n\t */\n\tpublic void setAccessTableColumnMetaData(boolean accessTableColumnMetaData) {\n\t\tthis.tableMetaDataContext.setAccessTableColumnMetaData(accessTableColumnMetaData);\n\t}\n\n\t/**\n\t * Specify whether the default for including synonyms should be changed.\n\t * <p>The default is {@code false}.\n\t */\n\tpublic void setOverrideIncludeSynonymsDefault(boolean override) {\n\t\tthis.tableMetaDataContext.setOverrideIncludeSynonymsDefault(override);\n\t}\n\n\t/**\n\t * Get the insert string to be used.\n\t */\n\tpublic String getInsertString() {\n\t\treturn this.insertString;\n\t}\n\n\t/**\n\t * Get the array of {@link java.sql.Types} to be used for insert.\n\t */\n\tpublic int[] getInsertTypes() {\n\t\treturn this.insertTypes;\n\t}\n\n\t/**\n\t * Specify whether SQL identifiers should be quoted.\n\t * <p>Defaults to {@code false}. If set to {@code true}, the identifier\n\t * quote string for the underlying database will be used to quote SQL\n\t * identifiers in generated SQL statements.\n\t * @param quoteIdentifiers whether identifiers should be quoted\n\t * @since 6.1\n\t * @see java.sql.DatabaseMetaData#getIdentifierQuoteString()\n\t */\n\tpublic void setQuoteIdentifiers(boolean quoteIdentifiers) {\n\t\tthis.tableMetaDataContext.setQuoteIdentifiers(quoteIdentifiers);\n\t}\n\n\t/**\n\t * Get the {@code quoteIdentifiers} flag.\n\t * @since 6.1\n\t * @see #setQuoteIdentifiers(boolean)\n\t */\n\tpublic boolean isQuoteIdentifiers() {\n\t\treturn this.tableMetaDataContext.isQuoteIdentifiers();\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Methods handling compilation issues\n\t//-------------------------------------------------------------------------\n\n\t/**\n\t * Compile this JdbcInsert using provided parameters and meta-data plus other settings.\n\t * This finalizes the configuration for this object and subsequent attempts to compile are\n\t * ignored. This will be implicitly called the first time an un-compiled insert is executed.\n\t * @throws InvalidDataAccessApiUsageException if the object hasn't been correctly initialized,\n\t * for example if no DataSource has been provided\n\t */\n\tpublic final synchronized void compile() throws InvalidDataAccessApiUsageException {\n\t\tif (!isCompiled()) {\n\t\t\tif (getTableName() == null) {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\"Table name is required\");\n\t\t\t}\n\t\t\tif (isQuoteIdentifiers() && this.declaredColumns.isEmpty()) {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\"Explicit column names must be provided when using quoted identifiers\");\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthis.jdbcTemplate.afterPropertiesSet();\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(ex.getMessage());\n\t\t\t}\n\t\t\tcompileInternal();\n\t\t\tthis.compiled = true;\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"JdbcInsert for table [\" + getTableName() + \"] compiled\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Delegate method to perform the actual compilation.\n\t * <p>Subclasses can override this template method to perform  their own compilation.\n\t * Invoked after this base class's compilation is complete.\n\t */\n\tprotected void compileInternal() {\n\t\tDataSource dataSource = getJdbcTemplate().getDataSource();\n\t\tAssert.state(dataSource != null, \"No DataSource set\");\n\t\tthis.tableMetaDataContext.processMetaData(dataSource, getColumnNames(), getGeneratedKeyNames());\n\t\tthis.insertString = this.tableMetaDataContext.createInsertString(getGeneratedKeyNames());\n\t\tthis.insertTypes = this.tableMetaDataContext.createInsertTypes();\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Compiled insert object: insert string is [\" + this.insertString + \"]\");\n\t\t}\n\t\tonCompileInternal();\n\t}\n\n\t/**\n\t * Hook method that subclasses may override to react to compilation.\n\t * <p>This implementation is empty.\n\t */\n\tprotected void onCompileInternal() {\n\t}\n\n\t/**\n\t * Is this operation \"compiled\"?\n\t * @return whether this operation is compiled and ready to use\n\t */\n\tpublic boolean isCompiled() {\n\t\treturn this.compiled;\n\t}\n\n\t/**\n\t * Check whether this operation has been compiled already;\n\t * lazily compile it if not already compiled.\n\t * <p>Automatically called by all {@code doExecute*(...)} methods.\n\t */\n\tprotected void checkCompiled() {\n\t\tif (!isCompiled()) {\n\t\t\tlogger.debug(\"JdbcInsert not compiled before execution - invoking compile\");\n\t\t\tcompile();\n\t\t}\n\t}\n\n\t/**\n\t * Method to check whether we are allowed to make any configuration changes at this time.\n\t * <p>If the class has been compiled, then no further changes to the configuration are allowed.\n\t */\n\tprotected void checkIfConfigurationModificationIsAllowed() {\n\t\tif (isCompiled()) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"Configuration cannot be altered once the class has been compiled or used\");\n\t\t}\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Methods handling execution\n\t//-------------------------------------------------------------------------\n\n\t/**\n\t * Delegate method that executes the insert using the passed-in Map of parameters.\n\t * @param args a Map with parameter names and values to be used in insert\n\t * @return the number of rows affected\n\t */\n\tprotected int doExecute(Map<String, ?> args) {\n\t\tcheckCompiled();\n\t\tList<Object> values = matchInParameterValuesWithInsertColumns(args);\n\t\treturn executeInsertInternal(values);\n\t}\n\n\t/**\n\t * Delegate method that executes the insert using the passed-in {@link SqlParameterSource}.\n\t * @param parameterSource parameter names and values to be used in insert\n\t * @return the number of rows affected\n\t */\n\tprotected int doExecute(SqlParameterSource parameterSource) {\n\t\tcheckCompiled();\n\t\tList<Object> values = matchInParameterValuesWithInsertColumns(parameterSource);\n\t\treturn executeInsertInternal(values);\n\t}\n\n\t/**\n\t * Delegate method to execute the insert.\n\t */\n\tprivate int executeInsertInternal(List<?> values) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"The following parameters are used for insert \" + getInsertString() + \" with: \" + values);\n\t\t}\n\t\treturn getJdbcTemplate().update(getInsertString(), values.toArray(), getInsertTypes());\n\t}\n\n\t/**\n\t * Method that provides execution of the insert using the passed-in\n\t * Map of parameters and returning a generated key.\n\t * @param args a Map with parameter names and values to be used in insert\n\t * @return the key generated by the insert\n\t */\n\tprotected Number doExecuteAndReturnKey(Map<String, ?> args) {\n\t\tcheckCompiled();\n\t\tList<Object> values = matchInParameterValuesWithInsertColumns(args);\n\t\treturn executeInsertAndReturnKeyInternal(values);\n\t}\n\n\t/**\n\t * Method that provides execution of the insert using the passed-in\n\t * {@link SqlParameterSource} and returning a generated key.\n\t * @param parameterSource parameter names and values to be used in insert\n\t * @return the key generated by the insert\n\t */\n\tprotected Number doExecuteAndReturnKey(SqlParameterSource parameterSource) {\n\t\tcheckCompiled();\n\t\tList<Object> values = matchInParameterValuesWithInsertColumns(parameterSource);\n\t\treturn executeInsertAndReturnKeyInternal(values);\n\t}\n\n\t/**\n\t * Method that provides execution of the insert using the passed-in\n\t * Map of parameters and returning all generated keys.\n\t * @param args a Map with parameter names and values to be used in insert\n\t * @return the KeyHolder containing keys generated by the insert\n\t */\n\tprotected KeyHolder doExecuteAndReturnKeyHolder(Map<String, ?> args) {\n\t\tcheckCompiled();\n\t\tList<Object> values = matchInParameterValuesWithInsertColumns(args);\n\t\treturn executeInsertAndReturnKeyHolderInternal(values);\n\t}\n\n\t/**\n\t * Method that provides execution of the insert using the passed-in\n\t * {@link SqlParameterSource} and returning all generated keys.\n\t * @param parameterSource parameter names and values to be used in insert\n\t * @return the KeyHolder containing keys generated by the insert\n\t */\n\tprotected KeyHolder doExecuteAndReturnKeyHolder(SqlParameterSource parameterSource) {\n\t\tcheckCompiled();\n\t\tList<Object> values = matchInParameterValuesWithInsertColumns(parameterSource);\n\t\treturn executeInsertAndReturnKeyHolderInternal(values);\n\t}\n\n\t/**\n\t * Delegate method to execute the insert, generating a single key.\n\t */\n\tprivate Number executeInsertAndReturnKeyInternal(List<?> values) {\n\t\tKeyHolder kh = executeInsertAndReturnKeyHolderInternal(values);\n\t\tif (kh.getKey() != null) {\n\t\t\treturn kh.getKey();\n\t\t}\n\t\telse {\n\t\t\tthrow new DataIntegrityViolationException(\n\t\t\t\t\t\"Unable to retrieve the generated key for the insert: \" + getInsertString());\n\t\t}\n\t}\n\n\t/**\n\t * Delegate method to execute the insert, generating any number of keys.\n\t */\n\tprivate KeyHolder executeInsertAndReturnKeyHolderInternal(List<?> values) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"The following parameters are used for call \" + getInsertString() + \" with: \" + values);\n\t\t}\n\t\tKeyHolder keyHolder = new GeneratedKeyHolder();\n\n\t\tif (this.tableMetaDataContext.isGetGeneratedKeysSupported()) {\n\t\t\tgetJdbcTemplate().update(\n\t\t\t\t\tcon -> {\n\t\t\t\t\t\tPreparedStatement ps = prepareStatementForGeneratedKeys(con);\n\t\t\t\t\t\tsetParameterValues(ps, values, getInsertTypes());\n\t\t\t\t\t\treturn ps;\n\t\t\t\t\t},\n\t\t\t\t\tkeyHolder);\n\t\t}\n\n\t\telse {\n\t\t\tif (!this.tableMetaDataContext.isGetGeneratedKeysSimulated()) {\n\t\t\t\tthrow new InvalidDataAccessResourceUsageException(\n\t\t\t\t\t\t\"The getGeneratedKeys feature is not supported by this database\");\n\t\t\t}\n\t\t\tif (getGeneratedKeyNames().length < 1) {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\"Generated Key Name(s) not specified. \" +\n\t\t\t\t\t\t\"Using the generated keys features requires specifying the name(s) of the generated column(s)\");\n\t\t\t}\n\t\t\tif (getGeneratedKeyNames().length > 1) {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\"Current database only supports retrieving the key for a single column. There are \" +\n\t\t\t\t\t\tgetGeneratedKeyNames().length + \" columns specified: \" + Arrays.toString(getGeneratedKeyNames()));\n\t\t\t}\n\n\t\t\tAssert.state(getTableName() != null, \"No table name set\");\n\t\t\tString keyQuery = this.tableMetaDataContext.getSimpleQueryForGetGeneratedKey(\n\t\t\t\t\tgetTableName(), getGeneratedKeyNames()[0]);\n\t\t\tAssert.state(keyQuery != null, \"Query for simulating get generated keys must not be null\");\n\n\t\t\t// This is a hack to be able to get the generated key from a database that doesn't support\n\t\t\t// get generated keys feature. HSQL is one, PostgreSQL is another. Postgres uses a RETURNING\n\t\t\t// clause while HSQL uses a second query that has to be executed with the same connection.\n\n\t\t\tif (keyQuery.toUpperCase(Locale.ROOT).startsWith(\"RETURNING\")) {\n\t\t\t\tLong key = getJdbcTemplate().queryForObject(\n\t\t\t\t\t\tgetInsertString() + \" \" + keyQuery, Long.class, values.toArray());\n\t\t\t\tMap<String, Object> keys = new HashMap<>(2);\n\t\t\t\tkeys.put(getGeneratedKeyNames()[0], key);\n\t\t\t\tkeyHolder.getKeyList().add(keys);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgetJdbcTemplate().execute((ConnectionCallback<Object>) con -> {\n\t\t\t\t\t// Do the insert\n\t\t\t\t\tPreparedStatement ps = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tps = con.prepareStatement(getInsertString());\n\t\t\t\t\t\tsetParameterValues(ps, values, getInsertTypes());\n\t\t\t\t\t\tps.executeUpdate();\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tJdbcUtils.closeStatement(ps);\n\t\t\t\t\t}\n\t\t\t\t\t//Get the key\n\t\t\t\t\tStatement keyStmt = null;\n\t\t\t\t\tResultSet rs = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tkeyStmt = con.createStatement();\n\t\t\t\t\t\trs = keyStmt.executeQuery(keyQuery);\n\t\t\t\t\t\tif (rs.next()) {\n\t\t\t\t\t\t\tlong key = rs.getLong(1);\n\t\t\t\t\t\t\tMap<String, Object> keys = new HashMap<>(2);\n\t\t\t\t\t\t\tkeys.put(getGeneratedKeyNames()[0], key);\n\t\t\t\t\t\t\tkeyHolder.getKeyList().add(keys);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t\t\t\tJdbcUtils.closeStatement(keyStmt);\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn keyHolder;\n\t}\n\n\t/**\n\t * Create a PreparedStatement to be used for an insert operation with generated keys.\n\t * @param con the Connection to use\n\t * @return the PreparedStatement\n\t */\n\tprivate PreparedStatement prepareStatementForGeneratedKeys(Connection con) throws SQLException {\n\t\tif (getGeneratedKeyNames().length < 1) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\"Generated Key Name(s) not specified. \" +\n\t\t\t\t\t\"Using the generated keys features requires specifying the name(s) of the generated column(s).\");\n\t\t}\n\t\tPreparedStatement ps;\n\t\tif (this.tableMetaDataContext.isGeneratedKeysColumnNameArraySupported()) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Using generated keys support with array of column names.\");\n\t\t\t}\n\t\t\tps = con.prepareStatement(getInsertString(), getGeneratedKeyNames());\n\t\t}\n\t\telse {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Using generated keys support with Statement.RETURN_GENERATED_KEYS.\");\n\t\t\t}\n\t\t\tps = con.prepareStatement(getInsertString(), Statement.RETURN_GENERATED_KEYS);\n\t\t}\n\t\treturn ps;\n\t}\n\n\t/**\n\t * Delegate method that executes a batch insert using the passed-in Maps of parameters.\n\t * @param batch maps with parameter names and values to be used in the batch insert\n\t * @return an array of number of rows affected\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected int[] doExecuteBatch(Map<String, ?>... batch) {\n\t\tcheckCompiled();\n\t\tList<List<Object>> batchValues = new ArrayList<>(batch.length);\n\t\tfor (Map<String, ?> args : batch) {\n\t\t\tbatchValues.add(matchInParameterValuesWithInsertColumns(args));\n\t\t}\n\t\treturn executeBatchInternal(batchValues);\n\t}\n\n\t/**\n\t * Delegate method that executes a batch insert using the passed-in\n\t * {@link SqlParameterSource SqlParameterSources}.\n\t * @param batch parameter sources with names and values to be used in the batch insert\n\t * @return an array of number of rows affected\n\t */\n\tprotected int[] doExecuteBatch(SqlParameterSource... batch) {\n\t\tcheckCompiled();\n\t\tList<List<Object>> batchValues = new ArrayList<>(batch.length);\n\t\tfor (SqlParameterSource parameterSource : batch) {\n\t\t\tbatchValues.add(matchInParameterValuesWithInsertColumns(parameterSource));\n\t\t}\n\t\treturn executeBatchInternal(batchValues);\n\t}\n\n\t/**\n\t * Delegate method to execute the batch insert.\n\t */\n\tprivate int[] executeBatchInternal(final List<List<Object>> batchValues) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Executing statement \" + getInsertString() + \" with batch of size: \" + batchValues.size());\n\t\t}\n\t\treturn getJdbcTemplate().batchUpdate(getInsertString(),\n\t\t\t\tnew BatchPreparedStatementSetter() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n\t\t\t\t\t\tsetParameterValues(ps, batchValues.get(i), getInsertTypes());\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int getBatchSize() {\n\t\t\t\t\t\treturn batchValues.size();\n\t\t\t\t\t}\n\t\t\t\t});\n\t}\n\n\t/**\n\t * Internal implementation for setting parameter values.\n\t * @param preparedStatement the PreparedStatement\n\t * @param values the values to be set\n\t */\n\tprivate void setParameterValues(PreparedStatement preparedStatement, List<?> values, int @Nullable ... columnTypes)\n\t\t\tthrows SQLException {\n\n\t\tint colIndex = 0;\n\t\tfor (Object value : values) {\n\t\t\tcolIndex++;\n\t\t\tif (columnTypes == null || colIndex > columnTypes.length) {\n\t\t\t\tStatementCreatorUtils.setParameterValue(preparedStatement, colIndex, SqlTypeValue.TYPE_UNKNOWN, value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tStatementCreatorUtils.setParameterValue(preparedStatement, colIndex, columnTypes[colIndex - 1], value);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Match the provided in parameter values with registered parameters and parameters\n\t * defined via meta-data processing.\n\t * @param parameterSource the parameter values provided as a {@link SqlParameterSource}\n\t * @return a List of values\n\t */\n\tprotected List<Object> matchInParameterValuesWithInsertColumns(SqlParameterSource parameterSource) {\n\t\treturn this.tableMetaDataContext.matchInParameterValuesWithInsertColumns(parameterSource);\n\t}\n\n\t/**\n\t * Match the provided in parameter values with registered parameters and parameters\n\t * defined via meta-data processing.\n\t * @param args the parameter values provided as a Map\n\t * @return a List of values\n\t */\n\tprotected List<Object> matchInParameterValuesWithInsertColumns(Map<String, ?> args) {\n\t\treturn this.tableMetaDataContext.matchInParameterValuesWithInsertColumns(args);\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#checkCompiled()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether this operation has been compiled already;\n\t * lazily compile it if not already compiled.\n\t * <p>Automatically called by all {@code doExecute*(...)} methods.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "void",
    "signature": "protected void checkCompiled()",
    "source_code": "\tprotected void checkCompiled() {\n\t\tif (!isCompiled()) {\n\t\t\tlogger.debug(\"JdbcInsert not compiled before execution - invoking compile\");\n\t\t\tcompile();\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#checkIfConfigurationModificationIsAllowed()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Method to check whether we are allowed to make any configuration changes at this time.\n\t * <p>If the class has been compiled, then no further changes to the configuration are allowed.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 342
    },
    "return": "void",
    "signature": "protected void checkIfConfigurationModificationIsAllowed()",
    "source_code": "\tprotected void checkIfConfigurationModificationIsAllowed() {\n\t\tif (isCompiled()) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"Configuration cannot be altered once the class has been compiled or used\");\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#compile()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Compile this JdbcInsert using provided parameters and meta-data plus other settings.\n\t * This finalizes the configuration for this object and subsequent attempts to compile are\n\t * ignored. This will be implicitly called the first time an un-compiled insert is executed.\n\t * @throws InvalidDataAccessApiUsageException if the object hasn't been correctly initialized,\n\t * for example if no DataSource has been provided\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "void",
    "signature": "public void compile()",
    "source_code": "\tpublic final synchronized void compile() throws InvalidDataAccessApiUsageException {\n\t\tif (!isCompiled()) {\n\t\t\tif (getTableName() == null) {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\"Table name is required\");\n\t\t\t}\n\t\t\tif (isQuoteIdentifiers() && this.declaredColumns.isEmpty()) {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\"Explicit column names must be provided when using quoted identifiers\");\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthis.jdbcTemplate.afterPropertiesSet();\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(ex.getMessage());\n\t\t\t}\n\t\t\tcompileInternal();\n\t\t\tthis.compiled = true;\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"JdbcInsert for table [\" + getTableName() + \"] compiled\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#compileInternal()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate method to perform the actual compilation.\n\t * <p>Subclasses can override this template method to perform  their own compilation.\n\t * Invoked after this base class's compilation is complete.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "void",
    "signature": "protected void compileInternal()",
    "source_code": "\tprotected void compileInternal() {\n\t\tDataSource dataSource = getJdbcTemplate().getDataSource();\n\t\tAssert.state(dataSource != null, \"No DataSource set\");\n\t\tthis.tableMetaDataContext.processMetaData(dataSource, getColumnNames(), getGeneratedKeyNames());\n\t\tthis.insertString = this.tableMetaDataContext.createInsertString(getGeneratedKeyNames());\n\t\tthis.insertTypes = this.tableMetaDataContext.createInsertTypes();\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Compiled insert object: insert string is [\" + this.insertString + \"]\");\n\t\t}\n\t\tonCompileInternal();\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#doExecute(Map<String,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate method that executes the insert using the passed-in Map of parameters.\n\t * @param args a Map with parameter names and values to be used in insert\n\t * @return the number of rows affected\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 359
    },
    "return": "int",
    "signature": "protected int doExecute(Map<String, ?> args)",
    "source_code": "\tprotected int doExecute(Map<String, ?> args) {\n\t\tcheckCompiled();\n\t\tList<Object> values = matchInParameterValuesWithInsertColumns(args);\n\t\treturn executeInsertInternal(values);\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#doExecute(parameterSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate method that executes the insert using the passed-in {@link SqlParameterSource}.\n\t * @param parameterSource parameter names and values to be used in insert\n\t * @return the number of rows affected\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameterSource"
    ],
    "position": {
      "column": 1,
      "line": 370
    },
    "return": "int",
    "signature": "protected int doExecute(SqlParameterSource parameterSource)",
    "source_code": "\tprotected int doExecute(SqlParameterSource parameterSource) {\n\t\tcheckCompiled();\n\t\tList<Object> values = matchInParameterValuesWithInsertColumns(parameterSource);\n\t\treturn executeInsertInternal(values);\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#doExecuteAndReturnKey(Map<String,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Method that provides execution of the insert using the passed-in\n\t * Map of parameters and returning a generated key.\n\t * @param args a Map with parameter names and values to be used in insert\n\t * @return the key generated by the insert\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 392
    },
    "return": "Number",
    "signature": "protected Number doExecuteAndReturnKey(Map<String, ?> args)",
    "source_code": "\tprotected Number doExecuteAndReturnKey(Map<String, ?> args) {\n\t\tcheckCompiled();\n\t\tList<Object> values = matchInParameterValuesWithInsertColumns(args);\n\t\treturn executeInsertAndReturnKeyInternal(values);\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#doExecuteAndReturnKey(parameterSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Method that provides execution of the insert using the passed-in\n\t * {@link SqlParameterSource} and returning a generated key.\n\t * @param parameterSource parameter names and values to be used in insert\n\t * @return the key generated by the insert\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameterSource"
    ],
    "position": {
      "column": 1,
      "line": 404
    },
    "return": "Number",
    "signature": "protected Number doExecuteAndReturnKey(SqlParameterSource parameterSource)",
    "source_code": "\tprotected Number doExecuteAndReturnKey(SqlParameterSource parameterSource) {\n\t\tcheckCompiled();\n\t\tList<Object> values = matchInParameterValuesWithInsertColumns(parameterSource);\n\t\treturn executeInsertAndReturnKeyInternal(values);\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#doExecuteAndReturnKeyHolder(Map<String,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Method that provides execution of the insert using the passed-in\n\t * Map of parameters and returning all generated keys.\n\t * @param args a Map with parameter names and values to be used in insert\n\t * @return the KeyHolder containing keys generated by the insert\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 416
    },
    "return": "KeyHolder",
    "signature": "protected KeyHolder doExecuteAndReturnKeyHolder(Map<String, ?> args)",
    "source_code": "\tprotected KeyHolder doExecuteAndReturnKeyHolder(Map<String, ?> args) {\n\t\tcheckCompiled();\n\t\tList<Object> values = matchInParameterValuesWithInsertColumns(args);\n\t\treturn executeInsertAndReturnKeyHolderInternal(values);\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#doExecuteAndReturnKeyHolder(parameterSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Method that provides execution of the insert using the passed-in\n\t * {@link SqlParameterSource} and returning all generated keys.\n\t * @param parameterSource parameter names and values to be used in insert\n\t * @return the KeyHolder containing keys generated by the insert\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameterSource"
    ],
    "position": {
      "column": 1,
      "line": 428
    },
    "return": "KeyHolder",
    "signature": "protected KeyHolder doExecuteAndReturnKeyHolder(SqlParameterSource parameterSource)",
    "source_code": "\tprotected KeyHolder doExecuteAndReturnKeyHolder(SqlParameterSource parameterSource) {\n\t\tcheckCompiled();\n\t\tList<Object> values = matchInParameterValuesWithInsertColumns(parameterSource);\n\t\treturn executeInsertAndReturnKeyHolderInternal(values);\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#doExecuteBatch(Map<String,batch)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate method that executes a batch insert using the passed-in Maps of parameters.\n\t * @param batch maps with parameter names and values to be used in the batch insert\n\t * @return an array of number of rows affected\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "batch"
    ],
    "position": {
      "column": 1,
      "line": 567
    },
    "return": "int[]",
    "signature": "protected int[] doExecuteBatch(Map<String, ?>... batch)",
    "source_code": "\tprotected int[] doExecuteBatch(Map<String, ?>... batch) {\n\t\tcheckCompiled();\n\t\tList<List<Object>> batchValues = new ArrayList<>(batch.length);\n\t\tfor (Map<String, ?> args : batch) {\n\t\t\tbatchValues.add(matchInParameterValuesWithInsertColumns(args));\n\t\t}\n\t\treturn executeBatchInternal(batchValues);\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#doExecuteBatch(batch)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate method that executes a batch insert using the passed-in\n\t * {@link SqlParameterSource SqlParameterSources}.\n\t * @param batch parameter sources with names and values to be used in the batch insert\n\t * @return an array of number of rows affected\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "batch"
    ],
    "position": {
      "column": 1,
      "line": 582
    },
    "return": "int[]",
    "signature": "protected int[] doExecuteBatch(SqlParameterSource... batch)",
    "source_code": "\tprotected int[] doExecuteBatch(SqlParameterSource... batch) {\n\t\tcheckCompiled();\n\t\tList<List<Object>> batchValues = new ArrayList<>(batch.length);\n\t\tfor (SqlParameterSource parameterSource : batch) {\n\t\t\tbatchValues.add(matchInParameterValuesWithInsertColumns(parameterSource));\n\t\t}\n\t\treturn executeBatchInternal(batchValues);\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#getBatchSize()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 605
    },
    "return": "int",
    "signature": "public int getBatchSize()",
    "source_code": "\t\t\t\t\tpublic int getBatchSize() {\n\t\t\t\t\t\treturn batchValues.size();\n\t\t\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#getCatalogName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the name of the catalog for this insert.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "String",
    "signature": "public String getCatalogName()",
    "source_code": "\tpublic @Nullable String getCatalogName() {\n\t\treturn this.tableMetaDataContext.getCatalogName();\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#getColumnNames()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the names of the columns used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "List<String>",
    "signature": "public List<String> getColumnNames()",
    "source_code": "\tpublic List<String> getColumnNames() {\n\t\treturn Collections.unmodifiableList(this.declaredColumns);\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#getGeneratedKeyNames()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the names of any generated keys.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "String[]",
    "signature": "public String[] getGeneratedKeyNames()",
    "source_code": "\tpublic String[] getGeneratedKeyNames() {\n\t\treturn this.generatedKeyNames;\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#getInsertString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the insert string to be used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "String",
    "signature": "public String getInsertString()",
    "source_code": "\tpublic String getInsertString() {\n\t\treturn this.insertString;\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#getInsertTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the array of {@link java.sql.Types} to be used for insert.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "int[]",
    "signature": "public int[] getInsertTypes()",
    "source_code": "\tpublic int[] getInsertTypes() {\n\t\treturn this.insertTypes;\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#getJdbcTemplate()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the configured {@link JdbcTemplate}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "JdbcTemplate",
    "signature": "public JdbcTemplate getJdbcTemplate()",
    "source_code": "\tpublic JdbcTemplate getJdbcTemplate() {\n\t\treturn this.jdbcTemplate;\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#getSchemaName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the name of the schema for this insert.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "String",
    "signature": "public String getSchemaName()",
    "source_code": "\tpublic @Nullable String getSchemaName() {\n\t\treturn this.tableMetaDataContext.getSchemaName();\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#getTableName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the name of the table for this insert.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "String",
    "signature": "public String getTableName()",
    "source_code": "\tpublic @Nullable String getTableName() {\n\t\treturn this.tableMetaDataContext.getTableName();\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#isCompiled()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Is this operation \"compiled\"?\n\t * @return whether this operation is compiled and ready to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "boolean",
    "signature": "public boolean isCompiled()",
    "source_code": "\tpublic boolean isCompiled() {\n\t\treturn this.compiled;\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#isQuoteIdentifiers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@code quoteIdentifiers} flag.\n\t * @since 6.1\n\t * @see #setQuoteIdentifiers(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "boolean",
    "signature": "public boolean isQuoteIdentifiers()",
    "source_code": "\tpublic boolean isQuoteIdentifiers() {\n\t\treturn this.tableMetaDataContext.isQuoteIdentifiers();\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#matchInParameterValuesWithInsertColumns(Map<String,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Match the provided in parameter values with registered parameters and parameters\n\t * defined via meta-data processing.\n\t * @param args the parameter values provided as a Map\n\t * @return a List of values\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 647
    },
    "return": "List<Object>",
    "signature": "protected List<Object> matchInParameterValuesWithInsertColumns(Map<String, ?> args)",
    "source_code": "\tprotected List<Object> matchInParameterValuesWithInsertColumns(Map<String, ?> args) {\n\t\treturn this.tableMetaDataContext.matchInParameterValuesWithInsertColumns(args);\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#matchInParameterValuesWithInsertColumns(parameterSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Match the provided in parameter values with registered parameters and parameters\n\t * defined via meta-data processing.\n\t * @param parameterSource the parameter values provided as a {@link SqlParameterSource}\n\t * @return a List of values\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameterSource"
    ],
    "position": {
      "column": 1,
      "line": 637
    },
    "return": "List<Object>",
    "signature": "protected List<Object> matchInParameterValuesWithInsertColumns(SqlParameterSource parameterSource)",
    "source_code": "\tprotected List<Object> matchInParameterValuesWithInsertColumns(SqlParameterSource parameterSource) {\n\t\treturn this.tableMetaDataContext.matchInParameterValuesWithInsertColumns(parameterSource);\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#onCompileInternal()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook method that subclasses may override to react to compilation.\n\t * <p>This implementation is empty.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "void",
    "signature": "protected void onCompileInternal()",
    "source_code": "\tprotected void onCompileInternal() {\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#setAccessTableColumnMetaData(accessTableColumnMetaData)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether the parameter meta-data for the call should be used.\n\t * <p>The default is {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "accessTableColumnMetaData"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "void",
    "signature": "public void setAccessTableColumnMetaData(boolean accessTableColumnMetaData)",
    "source_code": "\tpublic void setAccessTableColumnMetaData(boolean accessTableColumnMetaData) {\n\t\tthis.tableMetaDataContext.setAccessTableColumnMetaData(accessTableColumnMetaData);\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#setCatalogName(catalogName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the catalog for this insert.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "catalogName"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "void",
    "signature": "public void setCatalogName(@Nullable String catalogName)",
    "source_code": "\tpublic void setCatalogName(@Nullable String catalogName) {\n\t\tcheckIfConfigurationModificationIsAllowed();\n\t\tthis.tableMetaDataContext.setCatalogName(catalogName);\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#setColumnNames(columnNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the names of the columns to be used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnNames"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "void",
    "signature": "public void setColumnNames(List<String> columnNames)",
    "source_code": "\tpublic void setColumnNames(List<String> columnNames) {\n\t\tcheckIfConfigurationModificationIsAllowed();\n\t\tthis.declaredColumns.clear();\n\t\tthis.declaredColumns.addAll(columnNames);\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#setGeneratedKeyName(generatedKeyName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the name of a single generated key column.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generatedKeyName"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "void",
    "signature": "public void setGeneratedKeyName(String generatedKeyName)",
    "source_code": "\tpublic void setGeneratedKeyName(String generatedKeyName) {\n\t\tcheckIfConfigurationModificationIsAllowed();\n\t\tthis.generatedKeyNames = new String[] {generatedKeyName};\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#setGeneratedKeyNames(generatedKeyNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the names of any generated keys.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generatedKeyNames"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "void",
    "signature": "public void setGeneratedKeyNames(String... generatedKeyNames)",
    "source_code": "\tpublic void setGeneratedKeyNames(String... generatedKeyNames) {\n\t\tcheckIfConfigurationModificationIsAllowed();\n\t\tthis.generatedKeyNames = generatedKeyNames;\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#setOverrideIncludeSynonymsDefault(override)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether the default for including synonyms should be changed.\n\t * <p>The default is {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "override"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "void",
    "signature": "public void setOverrideIncludeSynonymsDefault(boolean override)",
    "source_code": "\tpublic void setOverrideIncludeSynonymsDefault(boolean override) {\n\t\tthis.tableMetaDataContext.setOverrideIncludeSynonymsDefault(override);\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#setQuoteIdentifiers(quoteIdentifiers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether SQL identifiers should be quoted.\n\t * <p>Defaults to {@code false}. If set to {@code true}, the identifier\n\t * quote string for the underlying database will be used to quote SQL\n\t * identifiers in generated SQL statements.\n\t * @param quoteIdentifiers whether identifiers should be quoted\n\t * @since 6.1\n\t * @see java.sql.DatabaseMetaData#getIdentifierQuoteString()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "quoteIdentifiers"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "void",
    "signature": "public void setQuoteIdentifiers(boolean quoteIdentifiers)",
    "source_code": "\tpublic void setQuoteIdentifiers(boolean quoteIdentifiers) {\n\t\tthis.tableMetaDataContext.setQuoteIdentifiers(quoteIdentifiers);\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#setSchemaName(schemaName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the schema for this insert.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "schemaName"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "public void setSchemaName(@Nullable String schemaName)",
    "source_code": "\tpublic void setSchemaName(@Nullable String schemaName) {\n\t\tcheckIfConfigurationModificationIsAllowed();\n\t\tthis.tableMetaDataContext.setSchemaName(schemaName);\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#setTableName(tableName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the table for this insert.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "tableName"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void setTableName(@Nullable String tableName)",
    "source_code": "\tpublic void setTableName(@Nullable String tableName) {\n\t\tcheckIfConfigurationModificationIsAllowed();\n\t\tthis.tableMetaDataContext.setTableName(tableName);\n\t}"
  },
  "org.springframework.jdbc.core.simple.AbstractJdbcInsert#setValues(ps,i)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "i"
    ],
    "position": {
      "column": 1,
      "line": 601
    },
    "return": "void",
    "signature": "public void setValues(PreparedStatement ps, int i)",
    "source_code": "\t\t\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n\t\t\t\t\t\tsetParameterValues(ps, batchValues.get(i), getInsertTypes());\n\t\t\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.SimpleJdbcCall": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A SimpleJdbcCall is a multithreaded, reusable object representing a call\n * to a stored procedure or a stored function. It provides meta-data processing\n * to simplify the code needed to access basic stored procedures/functions.\n * All you need to provide is the name of the procedure/function and a Map\n * containing the parameters when you execute the call. The names of the\n * supplied parameters will be matched up with in and out parameters declared\n * when the stored procedure was created.\n *\n * <p>The meta-data processing is based on the DatabaseMetaData provided by\n * the JDBC driver. Since we rely on the JDBC driver, this \"auto-detection\"\n * can only be used for databases that are known to provide accurate meta-data.\n * These currently include Derby, MySQL, Microsoft SQL Server, Oracle, DB2,\n * Sybase and PostgreSQL. For any other databases you are required to declare\n * all parameters explicitly. You can of course declare all parameters\n * explicitly even if the database provides the necessary meta-data. In that\n * case your declared parameters will take precedence. You can also turn off\n * any meta-data processing if you want to use parameter names that do not\n * match what is declared during the stored procedure compilation.\n *\n * <p>The actual call is being handled using Spring's {@link JdbcTemplate}.\n *\n * <p>Many of the configuration methods return the current instance of the\n * SimpleJdbcCall in order to provide the ability to chain multiple ones\n * together in a \"fluent\" interface style.\n *\n * @author Thomas Risberg\n * @author Stephane Nicoll\n * @since 2.5\n * @see java.sql.DatabaseMetaData\n * @see org.springframework.jdbc.core.JdbcTemplate\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "signature": "public class SimpleJdbcCall",
    "source_code": "public class SimpleJdbcCall extends AbstractJdbcCall implements SimpleJdbcCallOperations {\n\n\t/**\n\t * Constructor that takes one parameter with the JDBC DataSource to use when\n\t * creating the underlying JdbcTemplate.\n\t * @param dataSource the {@code DataSource} to use\n\t * @see org.springframework.jdbc.core.JdbcTemplate#setDataSource\n\t */\n\tpublic SimpleJdbcCall(DataSource dataSource) {\n\t\tsuper(dataSource);\n\t}\n\n\t/**\n\t * Alternative Constructor that takes one parameter with the JdbcTemplate to be used.\n\t * @param jdbcTemplate the {@code JdbcTemplate} to use\n\t * @see org.springframework.jdbc.core.JdbcTemplate#setDataSource\n\t */\n\tpublic SimpleJdbcCall(JdbcTemplate jdbcTemplate) {\n\t\tsuper(jdbcTemplate);\n\t}\n\n\n\t@Override\n\tpublic SimpleJdbcCall withProcedureName(String procedureName) {\n\t\tsetProcedureName(procedureName);\n\t\tsetFunction(false);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic SimpleJdbcCall withFunctionName(String functionName) {\n\t\tsetProcedureName(functionName);\n\t\tsetFunction(true);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic SimpleJdbcCall withSchemaName(String schemaName) {\n\t\tsetSchemaName(schemaName);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic SimpleJdbcCall withCatalogName(String catalogName) {\n\t\tsetCatalogName(catalogName);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic SimpleJdbcCall withReturnValue() {\n\t\tsetReturnValueRequired(true);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic SimpleJdbcCall declareParameters(SqlParameter... sqlParameters) {\n\t\tfor (SqlParameter sqlParameter : sqlParameters) {\n\t\t\tif (sqlParameter != null) {\n\t\t\t\taddDeclaredParameter(sqlParameter);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic SimpleJdbcCall useInParameterNames(String... inParameterNames) {\n\t\tsetInParameterNames(new LinkedHashSet<>(Arrays.asList(inParameterNames)));\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic SimpleJdbcCall returningResultSet(String parameterName, RowMapper<?> rowMapper) {\n\t\taddDeclaredRowMapper(parameterName, rowMapper);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic SimpleJdbcCall withoutProcedureColumnMetaDataAccess() {\n\t\tsetAccessCallParameterMetaData(false);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic SimpleJdbcCall withNamedBinding() {\n\t\tsetNamedBinding(true);\n\t\treturn this;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> @Nullable T executeFunction(Class<T> returnType, Object... args) {\n\t\treturn (T) doExecute(args).get(getScalarOutParameterName());\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> @Nullable T executeFunction(Class<T> returnType, Map<String, ?> args) {\n\t\treturn (T) doExecute(args).get(getScalarOutParameterName());\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> @Nullable T executeFunction(Class<T> returnType, SqlParameterSource args) {\n\t\treturn (T) doExecute(args).get(getScalarOutParameterName());\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> @Nullable T executeObject(Class<T> returnType, Object... args) {\n\t\treturn (T) doExecute(args).get(getScalarOutParameterName());\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> @Nullable T executeObject(Class<T> returnType, Map<String, ?> args) {\n\t\treturn (T) doExecute(args).get(getScalarOutParameterName());\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> @Nullable T executeObject(Class<T> returnType, SqlParameterSource args) {\n\t\treturn (T) doExecute(args).get(getScalarOutParameterName());\n\t}\n\n\t@Override\n\tpublic Map<String, Object> execute(Object... args) {\n\t\treturn doExecute(args);\n\t}\n\n\t@Override\n\tpublic Map<String, Object> execute(Map<String, ?> args) {\n\t\treturn doExecute(args);\n\t}\n\n\t@Override\n\tpublic Map<String, Object> execute(SqlParameterSource parameterSource) {\n\t\treturn doExecute(parameterSource);\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.simple.SimpleJdbcCall#declareParameters(sqlParameters)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sqlParameters"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "SimpleJdbcCall",
    "signature": "public SimpleJdbcCall declareParameters(SqlParameter... sqlParameters)",
    "source_code": "\tpublic SimpleJdbcCall declareParameters(SqlParameter... sqlParameters) {\n\t\tfor (SqlParameter sqlParameter : sqlParameters) {\n\t\t\tif (sqlParameter != null) {\n\t\t\t\taddDeclaredParameter(sqlParameter);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.simple.SimpleJdbcCall#execute(Map<String,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "Object>",
    "signature": "public Object> execute(Map<String, ?> args)",
    "source_code": "\tpublic Map<String, Object> execute(Map<String, ?> args) {\n\t\treturn doExecute(args);\n\t}"
  },
  "org.springframework.jdbc.core.simple.SimpleJdbcCall#execute(args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "args"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "Object>",
    "signature": "public Object> execute(Object... args)",
    "source_code": "\tpublic Map<String, Object> execute(Object... args) {\n\t\treturn doExecute(args);\n\t}"
  },
  "org.springframework.jdbc.core.simple.SimpleJdbcCall#execute(parameterSource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterSource"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "Object>",
    "signature": "public Object> execute(SqlParameterSource parameterSource)",
    "source_code": "\tpublic Map<String, Object> execute(SqlParameterSource parameterSource) {\n\t\treturn doExecute(parameterSource);\n\t}"
  },
  "org.springframework.jdbc.core.simple.SimpleJdbcCall#executeFunction(returnType,Map<String,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType",
      "Map<String",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "T",
    "signature": "public T executeFunction(Class<T> returnType, Map<String, ?> args)",
    "source_code": "\tpublic <T> @Nullable T executeFunction(Class<T> returnType, Map<String, ?> args) {\n\t\treturn (T) doExecute(args).get(getScalarOutParameterName());\n\t}"
  },
  "org.springframework.jdbc.core.simple.SimpleJdbcCall#executeFunction(returnType,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "T",
    "signature": "public T executeFunction(Class<T> returnType, SqlParameterSource args)",
    "source_code": "\tpublic <T> @Nullable T executeFunction(Class<T> returnType, SqlParameterSource args) {\n\t\treturn (T) doExecute(args).get(getScalarOutParameterName());\n\t}"
  },
  "org.springframework.jdbc.core.simple.SimpleJdbcCall#executeObject(returnType,Map<String,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType",
      "Map<String",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "T",
    "signature": "public T executeObject(Class<T> returnType, Map<String, ?> args)",
    "source_code": "\tpublic <T> @Nullable T executeObject(Class<T> returnType, Map<String, ?> args) {\n\t\treturn (T) doExecute(args).get(getScalarOutParameterName());\n\t}"
  },
  "org.springframework.jdbc.core.simple.SimpleJdbcCall#executeObject(returnType,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "T",
    "signature": "public T executeObject(Class<T> returnType, SqlParameterSource args)",
    "source_code": "\tpublic <T> @Nullable T executeObject(Class<T> returnType, SqlParameterSource args) {\n\t\treturn (T) doExecute(args).get(getScalarOutParameterName());\n\t}"
  },
  "org.springframework.jdbc.core.simple.SimpleJdbcCall#returningResultSet(parameterName,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterName",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "SimpleJdbcCall",
    "signature": "public SimpleJdbcCall returningResultSet(String parameterName, RowMapper<?> rowMapper)",
    "source_code": "\tpublic SimpleJdbcCall returningResultSet(String parameterName, RowMapper<?> rowMapper) {\n\t\taddDeclaredRowMapper(parameterName, rowMapper);\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.simple.SimpleJdbcCall#useInParameterNames(inParameterNames)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inParameterNames"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "SimpleJdbcCall",
    "signature": "public SimpleJdbcCall useInParameterNames(String... inParameterNames)",
    "source_code": "\tpublic SimpleJdbcCall useInParameterNames(String... inParameterNames) {\n\t\tsetInParameterNames(new LinkedHashSet<>(Arrays.asList(inParameterNames)));\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.simple.SimpleJdbcCall#withCatalogName(catalogName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "catalogName"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "SimpleJdbcCall",
    "signature": "public SimpleJdbcCall withCatalogName(String catalogName)",
    "source_code": "\tpublic SimpleJdbcCall withCatalogName(String catalogName) {\n\t\tsetCatalogName(catalogName);\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.simple.SimpleJdbcCall#withFunctionName(functionName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "functionName"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "SimpleJdbcCall",
    "signature": "public SimpleJdbcCall withFunctionName(String functionName)",
    "source_code": "\tpublic SimpleJdbcCall withFunctionName(String functionName) {\n\t\tsetProcedureName(functionName);\n\t\tsetFunction(true);\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.simple.SimpleJdbcCall#withNamedBinding()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "SimpleJdbcCall",
    "signature": "public SimpleJdbcCall withNamedBinding()",
    "source_code": "\tpublic SimpleJdbcCall withNamedBinding() {\n\t\tsetNamedBinding(true);\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.simple.SimpleJdbcCall#withProcedureName(procedureName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "procedureName"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "SimpleJdbcCall",
    "signature": "public SimpleJdbcCall withProcedureName(String procedureName)",
    "source_code": "\tpublic SimpleJdbcCall withProcedureName(String procedureName) {\n\t\tsetProcedureName(procedureName);\n\t\tsetFunction(false);\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.simple.SimpleJdbcCall#withReturnValue()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "SimpleJdbcCall",
    "signature": "public SimpleJdbcCall withReturnValue()",
    "source_code": "\tpublic SimpleJdbcCall withReturnValue() {\n\t\tsetReturnValueRequired(true);\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.simple.SimpleJdbcCall#withSchemaName(schemaName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "schemaName"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "SimpleJdbcCall",
    "signature": "public SimpleJdbcCall withSchemaName(String schemaName)",
    "source_code": "\tpublic SimpleJdbcCall withSchemaName(String schemaName) {\n\t\tsetSchemaName(schemaName);\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.simple.SimpleJdbcCall#withoutProcedureColumnMetaDataAccess()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "SimpleJdbcCall",
    "signature": "public SimpleJdbcCall withoutProcedureColumnMetaDataAccess()",
    "source_code": "\tpublic SimpleJdbcCall withoutProcedureColumnMetaDataAccess() {\n\t\tsetAccessCallParameterMetaData(false);\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.simple.SimpleJdbcCallOperations": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Interface specifying the API for a Simple JDBC Call implemented by {@link SimpleJdbcCall}.\n * This interface is not often used directly, but provides the option to enhance testability,\n * as it can easily be mocked or stubbed.\n *\n * @author Thomas Risberg\n * @author Stephane Nicoll\n * @since 2.5\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public interface SimpleJdbcCallOperations",
    "source_code": "public interface SimpleJdbcCallOperations {\n\n\t/**\n\t * Specify the procedure name to be used - this implies that we will be calling a stored procedure.\n\t * @param procedureName the name of the stored procedure\n\t * @return the instance of this SimpleJdbcCall\n\t */\n\tSimpleJdbcCallOperations withProcedureName(String procedureName);\n\n\t/**\n\t * Specify the procedure name to be used - this implies that we will be calling a stored function.\n\t * @param functionName the name of the stored function\n\t * @return the instance of this SimpleJdbcCall\n\t */\n\tSimpleJdbcCallOperations withFunctionName(String functionName);\n\n\t/**\n\t * Optionally, specify the name of the schema that contains the stored procedure.\n\t * @param schemaName the name of the schema\n\t * @return the instance of this SimpleJdbcCall\n\t */\n\tSimpleJdbcCallOperations withSchemaName(String schemaName);\n\n\t/**\n\t * Optionally, specify the name of the catalog that contains the stored procedure.\n\t * <p>To provide consistency with the Oracle DatabaseMetaData, this is used to specify the\n\t * package name if the procedure is declared as part of a package.\n\t * @param catalogName the catalog or package name\n\t * @return the instance of this SimpleJdbcCall\n\t */\n\tSimpleJdbcCallOperations withCatalogName(String catalogName);\n\n\t/**\n\t * Indicates the procedure's return value should be included in the results returned.\n\t * @return the instance of this SimpleJdbcCall\n\t */\n\tSimpleJdbcCallOperations withReturnValue();\n\n\t/**\n\t * Specify one or more parameters if desired. These parameters will be supplemented with\n\t * any parameter information retrieved from the database meta-data.\n\t * <p>Note that only parameters declared as {@code SqlParameter} and {@code SqlInOutParameter}\n\t * will be used to provide input values. This is different from the {@code StoredProcedure}\n\t * class which - for backwards compatibility reasons - allows input values to be provided\n\t * for parameters declared as {@code SqlOutParameter}.\n\t * @param sqlParameters the parameters to use\n\t * @return the instance of this SimpleJdbcCall\n\t */\n\tSimpleJdbcCallOperations declareParameters(SqlParameter... sqlParameters);\n\n\t/** Not used yet. */\n\tSimpleJdbcCallOperations useInParameterNames(String... inParameterNames);\n\n\t/**\n\t * Used to specify when a ResultSet is returned by the stored procedure and you want it\n\t * mapped by a {@link RowMapper}. The results will be returned using the parameter name\n\t * specified. Multiple ResultSets must be declared in the correct order.\n\t * <p>If the database you are using uses ref cursors then the name specified must match\n\t * the name of the parameter declared for the procedure in the database.\n\t * @param parameterName the name of the returned results and/or the name of the ref cursor parameter\n\t * @param rowMapper the RowMapper implementation that will map the data returned for each row\n\t * */\n\tSimpleJdbcCallOperations returningResultSet(String parameterName, RowMapper<?> rowMapper);\n\n\t/**\n\t * Turn off any processing of parameter meta-data information obtained via JDBC.\n\t * @return the instance of this SimpleJdbcCall\n\t */\n\tSimpleJdbcCallOperations withoutProcedureColumnMetaDataAccess();\n\n\t/**\n\t * Indicates that parameters should be bound by name.\n\t * @return the instance of this SimpleJdbcCall\n\t * @since 4.2\n\t */\n\tSimpleJdbcCallOperations withNamedBinding();\n\n\n\t/**\n\t * Execute the stored function and return the results obtained as an Object of the\n\t * specified return type.\n\t * @param returnType the type of the value to return\n\t * @param args optional array containing the in parameter values to be used in the call.\n\t * Parameter values must be provided in the same order as the parameters are defined\n\t * for the stored procedure.\n\t */\n\t<T> @Nullable T executeFunction(Class<T> returnType, Object... args);\n\n\t/**\n\t * Execute the stored function and return the results obtained as an Object of the\n\t * specified return type.\n\t * @param returnType the type of the value to return\n\t * @param args a Map containing the parameter values to be used in the call\n\t */\n\t<T> @Nullable T executeFunction(Class<T> returnType, Map<String, ?> args);\n\n\t/**\n\t * Execute the stored function and return the results obtained as an Object of the\n\t * specified return type.\n\t * @param returnType the type of the value to return\n\t * @param args the MapSqlParameterSource containing the parameter values to be used in the call\n\t */\n\t<T> @Nullable T executeFunction(Class<T> returnType, SqlParameterSource args);\n\n\t/**\n\t * Execute the stored procedure and return the single out parameter as an Object\n\t * of the specified return type. In the case where there are multiple out parameters,\n\t * the first one is returned and additional out parameters are ignored.\n\t * @param returnType the type of the value to return\n\t * @param args optional array containing the in parameter values to be used in the call.\n\t * Parameter values must be provided in the same order as the parameters are defined for\n\t * the stored procedure.\n\t */\n\t<T> @Nullable T executeObject(Class<T> returnType, Object... args);\n\n\t/**\n\t * Execute the stored procedure and return the single out parameter as an Object\n\t * of the specified return type. In the case where there are multiple out parameters,\n\t * the first one is returned and additional out parameters are ignored.\n\t * @param returnType the type of the value to return\n\t * @param args a Map containing the parameter values to be used in the call\n\t */\n\t<T> @Nullable T executeObject(Class<T> returnType, Map<String, ?> args);\n\n\t/**\n\t * Execute the stored procedure and return the single out parameter as an Object\n\t * of the specified return type. In the case where there are multiple out parameters,\n\t * the first one is returned and additional out parameters are ignored.\n\t * @param returnType the type of the value to return\n\t * @param args the MapSqlParameterSource containing the parameter values to be used in the call\n\t */\n\t<T> @Nullable T executeObject(Class<T> returnType, SqlParameterSource args);\n\n\t/**\n\t * Execute the stored procedure and return a map of output params, keyed by name\n\t * as in parameter declarations.\n\t * @param args optional array containing the in parameter values to be used in the call.\n\t * Parameter values must be provided in the same order as the parameters are defined for\n\t * the stored procedure.\n\t * @return a Map of output params\n\t */\n\tMap<String, Object> execute(Object... args);\n\n\t/**\n\t * Execute the stored procedure and return a map of output params, keyed by name\n\t * as in parameter declarations.\n\t * @param args a Map containing the parameter values to be used in the call\n\t * @return a Map of output params\n\t */\n\tMap<String, Object> execute(Map<String, ?> args);\n\n\t/**\n\t * Execute the stored procedure and return a map of output params, keyed by name\n\t * as in parameter declarations.\n\t * @param args the SqlParameterSource containing the parameter values to be used in the call\n\t * @return a Map of output params\n\t */\n\tMap<String, Object> execute(SqlParameterSource args);\n\n}"
  },
  "org.springframework.jdbc.core.simple.logger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Logger available to subclasses. */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.jdbc.object.GenericSqlQuery": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A concrete variant of {@link SqlQuery} which can be configured\n * with a {@link RowMapper}.\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @since 3.0\n * @param <T> the result type\n * @see #setRowMapper\n * @see #setRowMapperClass\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class GenericSqlQuery",
    "source_code": "public class GenericSqlQuery<T> extends SqlQuery<T> {\n\n\tprivate @Nullable RowMapper<T> rowMapper;\n\n\t@SuppressWarnings(\"rawtypes\")\n\tprivate @Nullable Class<? extends RowMapper> rowMapperClass;\n\n\n\t/**\n\t * Set a specific {@link RowMapper} instance to use for this query.\n\t * @since 4.3.2\n\t */\n\tpublic void setRowMapper(RowMapper<T> rowMapper) {\n\t\tthis.rowMapper = rowMapper;\n\t}\n\n\t/**\n\t * Set a {@link RowMapper} class for this query, creating a fresh\n\t * {@link RowMapper} instance per execution.\n\t */\n\t@SuppressWarnings(\"rawtypes\")\n\tpublic void setRowMapperClass(Class<? extends RowMapper> rowMapperClass) {\n\t\tthis.rowMapperClass = rowMapperClass;\n\t}\n\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\tsuper.afterPropertiesSet();\n\t\tAssert.isTrue(this.rowMapper != null || this.rowMapperClass != null,\n\t\t\t\t\"'rowMapper' or 'rowMapperClass' is required\");\n\t}\n\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tprotected RowMapper<T> newRowMapper(@Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context) {\n\t\tif (this.rowMapper != null) {\n\t\t\treturn this.rowMapper;\n\t\t}\n\t\telse {\n\t\t\tAssert.state(this.rowMapperClass != null, \"No RowMapper set\");\n\t\t\treturn BeanUtils.instantiateClass(this.rowMapperClass);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jdbc.object.GenericSqlQuery#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tsuper.afterPropertiesSet();\n\t\tAssert.isTrue(this.rowMapper != null || this.rowMapperClass != null,\n\t\t\t\t\"'rowMapper' or 'rowMapperClass' is required\");\n\t}"
  },
  "org.springframework.jdbc.object.GenericSqlQuery#newRowMapper(parameters,Map<?,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameters",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "RowMapper<T>",
    "signature": "protected RowMapper<T> newRowMapper(@Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context)",
    "source_code": "\tprotected RowMapper<T> newRowMapper(@Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context) {\n\t\tif (this.rowMapper != null) {\n\t\t\treturn this.rowMapper;\n\t\t}\n\t\telse {\n\t\t\tAssert.state(this.rowMapperClass != null, \"No RowMapper set\");\n\t\t\treturn BeanUtils.instantiateClass(this.rowMapperClass);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.object.GenericSqlQuery#setRowMapper(rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a specific {@link RowMapper} instance to use for this query.\n\t * @since 4.3.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "return": "void",
    "signature": "public void setRowMapper(RowMapper<T> rowMapper)",
    "source_code": "\tpublic void setRowMapper(RowMapper<T> rowMapper) {\n\t\tthis.rowMapper = rowMapper;\n\t}"
  },
  "org.springframework.jdbc.object.GenericSqlQuery#setRowMapperClass(rowMapperClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a {@link RowMapper} class for this query, creating a fresh\n\t * {@link RowMapper} instance per execution.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rowMapperClass"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "public void setRowMapperClass(Class<? extends RowMapper> rowMapperClass)",
    "source_code": "\tpublic void setRowMapperClass(Class<? extends RowMapper> rowMapperClass) {\n\t\tthis.rowMapperClass = rowMapperClass;\n\t}"
  },
  "org.springframework.jdbc.object.MappingSqlQuery": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Reusable query in which concrete subclasses must implement the abstract\n * mapRow(ResultSet, int) method to convert each row of the JDBC ResultSet\n * into an object.\n *\n * <p>Simplifies MappingSqlQueryWithParameters API by dropping parameters and\n * context. Most subclasses won't care about parameters. If you don't use\n * contextual information, subclass this instead of MappingSqlQueryWithParameters.\n *\n * @author Rod Johnson\n * @author Thomas Risberg\n * @author Jean-Pierre Pawlak\n * @param <T> the result type\n * @see MappingSqlQueryWithParameters\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class MappingSqlQuery",
    "source_code": "public abstract class MappingSqlQuery<T> extends MappingSqlQueryWithParameters<T> {\n\n\t/**\n\t * Constructor that allows use as a JavaBean.\n\t */\n\tpublic MappingSqlQuery() {\n\t}\n\n\t/**\n\t * Convenient constructor with DataSource and SQL string.\n\t * @param ds the DataSource to use to obtain connections\n\t * @param sql the SQL to run\n\t */\n\tpublic MappingSqlQuery(DataSource ds, String sql) {\n\t\tsuper(ds, sql);\n\t}\n\n\n\t/**\n\t * This method is implemented to invoke the simpler mapRow\n\t * template method, ignoring parameters.\n\t * @see #mapRow(ResultSet, int)\n\t */\n\t@Override\n\tprotected final @Nullable T mapRow(ResultSet rs, int rowNum, @Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context)\n\t\t\tthrows SQLException {\n\n\t\treturn mapRow(rs, rowNum);\n\t}\n\n\t/**\n\t * Subclasses must implement this method to convert each row of the\n\t * ResultSet into an object of the result type.\n\t * <p>Subclasses of this class, as opposed to direct subclasses of\n\t * MappingSqlQueryWithParameters, don't need to concern themselves\n\t * with the parameters to the execute method of the query object.\n\t * @param rs the ResultSet we're working through\n\t * @param rowNum row number (from 0) we're up to\n\t * @return an object of the result type\n\t * @throws SQLException if there's an error extracting data.\n\t * Subclasses can simply not catch SQLExceptions, relying on the\n\t * framework to clean up.\n\t */\n\tprotected abstract @Nullable T mapRow(ResultSet rs, int rowNum) throws SQLException;\n\n}"
  },
  "org.springframework.jdbc.object.MappingSqlQuery#mapRow(rs,rowNum)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses must implement this method to convert each row of the\n\t * ResultSet into an object of the result type.\n\t * <p>Subclasses of this class, as opposed to direct subclasses of\n\t * MappingSqlQueryWithParameters, don't need to concern themselves\n\t * with the parameters to the execute method of the query object.\n\t * @param rs the ResultSet we're working through\n\t * @param rowNum row number (from 0) we're up to\n\t * @return an object of the result type\n\t * @throws SQLException if there's an error extracting data.\n\t * Subclasses can simply not catch SQLExceptions, relying on the\n\t * framework to clean up.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "rowNum"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "T",
    "signature": "protected T mapRow(ResultSet rs, int rowNum)",
    "source_code": "\tprotected abstract @Nullable T mapRow(ResultSet rs, int rowNum) throws SQLException;"
  },
  "org.springframework.jdbc.object.MappingSqlQuery#mapRow(rs,rowNum,parameters,Map<?,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This method is implemented to invoke the simpler mapRow\n\t * template method, ignoring parameters.\n\t * @see #mapRow(ResultSet, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "rowNum",
      "parameters",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "T",
    "signature": "protected T mapRow(ResultSet rs, int rowNum, @Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context)",
    "source_code": "\tprotected final @Nullable T mapRow(ResultSet rs, int rowNum, @Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context)"
  },
  "org.springframework.jdbc.object.MappingSqlQueryWithParameters": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Reusable RDBMS query in which concrete subclasses must implement\n * the abstract mapRow(ResultSet, int) method to map each row of\n * the JDBC ResultSet into an object.\n *\n * <p>Such manual mapping is usually preferable to \"automatic\"\n * mapping using reflection, which can become complex in non-trivial\n * cases. For example, the present class allows different objects\n * to be used for different rows (for example, if a subclass is indicated).\n * It allows computed fields to be set. And there's no need for\n * ResultSet columns to have the same names as bean properties.\n * The Pareto Principle in action: going the extra mile to automate\n * the extraction process makes the framework much more complex\n * and delivers little real benefit.\n *\n * <p>Subclasses can be constructed providing SQL, parameter types\n * and a DataSource. SQL will often vary between subclasses.\n *\n * @author Rod Johnson\n * @author Thomas Risberg\n * @author Jean-Pierre Pawlak\n * @param <T> the result type\n * @see org.springframework.jdbc.object.MappingSqlQuery\n * @see org.springframework.jdbc.object.SqlQuery\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "signature": "public class MappingSqlQueryWithParameters",
    "source_code": "public abstract class MappingSqlQueryWithParameters<T> extends SqlQuery<T> {\n\n\t/**\n\t * Constructor to allow use as a JavaBean.\n\t */\n\tpublic MappingSqlQueryWithParameters() {\n\t}\n\n\t/**\n\t * Convenient constructor with DataSource and SQL string.\n\t * @param ds the DataSource to use to get connections\n\t * @param sql the SQL to run\n\t */\n\tpublic MappingSqlQueryWithParameters(DataSource ds, String sql) {\n\t\tsuper(ds, sql);\n\t}\n\n\n\t/**\n\t * Implementation of protected abstract method. This invokes the subclass's\n\t * implementation of the mapRow() method.\n\t */\n\t@Override\n\tprotected RowMapper<T> newRowMapper(@Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context) {\n\t\treturn new RowMapperImpl(parameters, context);\n\t}\n\n\t/**\n\t * Subclasses must implement this method to convert each row\n\t * of the ResultSet into an object of the result type.\n\t * @param rs the ResultSet we're working through\n\t * @param rowNum row number (from 0) we're up to\n\t * @param parameters to the query (passed to the execute() method).\n\t * Subclasses are rarely interested in these.\n\t * It can be {@code null} if there are no parameters.\n\t * @param context passed to the execute() method.\n\t * It can be {@code null} if no contextual information is need.\n\t * @return an object of the result type\n\t * @throws SQLException if there's an error extracting data.\n\t * Subclasses can simply not catch SQLExceptions, relying on the\n\t * framework to clean up.\n\t */\n\tprotected abstract @Nullable T mapRow(ResultSet rs, int rowNum, @Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context)\n\t\t\tthrows SQLException;\n\n\n\t/**\n\t * Implementation of RowMapper that calls the enclosing\n\t * class's {@code mapRow} method for each row.\n\t */\n\tprotected class RowMapperImpl implements RowMapper<T> {\n\n\t\tprivate final @Nullable Object @Nullable [] params;\n\n\t\tprivate final @Nullable Map<?, ?> context;\n\n\t\t/**\n\t\t * Use an array results. More efficient if we know how many results to expect.\n\t\t */\n\t\tpublic RowMapperImpl(@Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context) {\n\t\t\tthis.params = parameters;\n\t\t\tthis.context = context;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable T mapRow(ResultSet rs, int rowNum) throws SQLException {\n\t\t\treturn MappingSqlQueryWithParameters.this.mapRow(rs, rowNum, this.params, this.context);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jdbc.object.MappingSqlQueryWithParameters#mapRow(rs,rowNum)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "rowNum"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "T",
    "signature": "public T mapRow(ResultSet rs, int rowNum)",
    "source_code": "\t\tpublic @Nullable T mapRow(ResultSet rs, int rowNum) throws SQLException {\n\t\t\treturn MappingSqlQueryWithParameters.this.mapRow(rs, rowNum, this.params, this.context);\n\t\t}"
  },
  "org.springframework.jdbc.object.MappingSqlQueryWithParameters#mapRow(rs,rowNum,parameters,Map<?,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses must implement this method to convert each row\n\t * of the ResultSet into an object of the result type.\n\t * @param rs the ResultSet we're working through\n\t * @param rowNum row number (from 0) we're up to\n\t * @param parameters to the query (passed to the execute() method).\n\t * Subclasses are rarely interested in these.\n\t * It can be {@code null} if there are no parameters.\n\t * @param context passed to the execute() method.\n\t * It can be {@code null} if no contextual information is need.\n\t * @return an object of the result type\n\t * @throws SQLException if there's an error extracting data.\n\t * Subclasses can simply not catch SQLExceptions, relying on the\n\t * framework to clean up.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "rowNum",
      "parameters",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "T",
    "signature": "protected T mapRow(ResultSet rs, int rowNum, @Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context)",
    "source_code": "\tprotected abstract @Nullable T mapRow(ResultSet rs, int rowNum, @Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context)"
  },
  "org.springframework.jdbc.object.MappingSqlQueryWithParameters#newRowMapper(parameters,Map<?,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Implementation of protected abstract method. This invokes the subclass's\n\t * implementation of the mapRow() method.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameters",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "RowMapper<T>",
    "signature": "protected RowMapper<T> newRowMapper(@Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context)",
    "source_code": "\tprotected RowMapper<T> newRowMapper(@Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context) {\n\t\treturn new RowMapperImpl(parameters, context);\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An \"RDBMS operation\" is a multithreaded, reusable object representing a query,\n * update, or stored procedure call. An RDBMS operation is <b>not</b> a command,\n * as a command is not reusable. However, execute methods may take commands as\n * arguments. Subclasses should be JavaBeans, allowing easy configuration.\n *\n * <p>This class and subclasses throw runtime exceptions, defined in the\n * {@code org.springframework.dao} package (and as thrown by the\n * {@code org.springframework.jdbc.core} package, which the classes\n * in this package use under the hood to perform raw JDBC operations).\n *\n * <p>Subclasses should set SQL and add parameters before invoking the\n * {@link #compile()} method. The order in which parameters are added is\n * significant. The appropriate {@code execute} or {@code update}\n * method can then be invoked.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @see SqlQuery\n * @see SqlUpdate\n * @see StoredProcedure\n * @see org.springframework.jdbc.core.JdbcTemplate\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "signature": "public class RdbmsOperation",
    "source_code": "public abstract class RdbmsOperation implements InitializingBean {\n\n\t/** Logger available to subclasses. */\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t/** Lower-level class used to execute SQL. */\n\tprivate JdbcTemplate jdbcTemplate = new JdbcTemplate();\n\n\tprivate int resultSetType = ResultSet.TYPE_FORWARD_ONLY;\n\n\tprivate boolean updatableResults = false;\n\n\tprivate boolean returnGeneratedKeys = false;\n\n\tprivate String @Nullable [] generatedKeysColumnNames;\n\n\tprivate @Nullable String sql;\n\n\tprivate final List<SqlParameter> declaredParameters = new ArrayList<>();\n\n\t/**\n\t * Has this operation been compiled? Compilation means at\n\t * least checking that a DataSource and sql have been provided,\n\t * but subclasses may also implement their own custom validation.\n\t */\n\tprivate volatile boolean compiled;\n\n\n\t/**\n\t * An alternative to the more commonly used {@link #setDataSource} when you want to\n\t * use the same {@link JdbcTemplate} in multiple {@code RdbmsOperations}. This is\n\t * appropriate if the {@code JdbcTemplate} has special configuration such as a\n\t * {@link org.springframework.jdbc.support.SQLExceptionTranslator} to be reused.\n\t */\n\tpublic void setJdbcTemplate(JdbcTemplate jdbcTemplate) {\n\t\tthis.jdbcTemplate = jdbcTemplate;\n\t}\n\n\t/**\n\t * Return the {@link JdbcTemplate} used by this operation object.\n\t */\n\tpublic JdbcTemplate getJdbcTemplate() {\n\t\treturn this.jdbcTemplate;\n\t}\n\n\t/**\n\t * Set the JDBC {@link DataSource} to obtain connections from.\n\t * @see org.springframework.jdbc.core.JdbcTemplate#setDataSource\n\t */\n\tpublic void setDataSource(DataSource dataSource) {\n\t\tthis.jdbcTemplate.setDataSource(dataSource);\n\t}\n\n\t/**\n\t * Set the fetch size for this RDBMS operation. This is important for processing\n\t * large result sets: Setting this higher than the default value will increase\n\t * processing speed at the cost of memory consumption; setting this lower can\n\t * avoid transferring row data that will never be read by the application.\n\t * <p>Default is -1, indicating to use the driver's default.\n\t * @see org.springframework.jdbc.core.JdbcTemplate#setFetchSize\n\t */\n\tpublic void setFetchSize(int fetchSize) {\n\t\tthis.jdbcTemplate.setFetchSize(fetchSize);\n\t}\n\n\t/**\n\t * Set the maximum number of rows for this RDBMS operation. This is important\n\t * for processing subsets of large result sets, in order to avoid reading and\n\t * holding the entire result set in the database or in the JDBC driver.\n\t * <p>Default is -1, indicating to use the driver's default.\n\t * @see org.springframework.jdbc.core.JdbcTemplate#setMaxRows\n\t */\n\tpublic void setMaxRows(int maxRows) {\n\t\tthis.jdbcTemplate.setMaxRows(maxRows);\n\t}\n\n\t/**\n\t * Set the query timeout for statements that this RDBMS operation executes.\n\t * <p>Default is -1, indicating to use the JDBC driver's default.\n\t * <p>Note: Any timeout specified here will be overridden by the remaining\n\t * transaction timeout when executing within a transaction that has a\n\t * timeout specified at the transaction level.\n\t */\n\tpublic void setQueryTimeout(int queryTimeout) {\n\t\tthis.jdbcTemplate.setQueryTimeout(queryTimeout);\n\t}\n\n\t/**\n\t * Set whether to use statements that return a specific type of ResultSet.\n\t * @param resultSetType the ResultSet type\n\t * @see java.sql.ResultSet#TYPE_FORWARD_ONLY\n\t * @see java.sql.ResultSet#TYPE_SCROLL_INSENSITIVE\n\t * @see java.sql.ResultSet#TYPE_SCROLL_SENSITIVE\n\t * @see java.sql.Connection#prepareStatement(String, int, int)\n\t */\n\tpublic void setResultSetType(int resultSetType) {\n\t\tthis.resultSetType = resultSetType;\n\t}\n\n\t/**\n\t * Return whether statements will return a specific type of ResultSet.\n\t */\n\tpublic int getResultSetType() {\n\t\treturn this.resultSetType;\n\t}\n\n\t/**\n\t * Set whether to use statements that are capable of returning\n\t * updatable ResultSets.\n\t * @see java.sql.Connection#prepareStatement(String, int, int)\n\t */\n\tpublic void setUpdatableResults(boolean updatableResults) {\n\t\tif (isCompiled()) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"The updatableResults flag must be set before the operation is compiled\");\n\t\t}\n\t\tthis.updatableResults = updatableResults;\n\t}\n\n\t/**\n\t * Return whether statements will return updatable ResultSets.\n\t */\n\tpublic boolean isUpdatableResults() {\n\t\treturn this.updatableResults;\n\t}\n\n\t/**\n\t * Set whether prepared statements should be capable of returning\n\t * auto-generated keys.\n\t * @see java.sql.Connection#prepareStatement(String, int)\n\t */\n\tpublic void setReturnGeneratedKeys(boolean returnGeneratedKeys) {\n\t\tif (isCompiled()) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"The returnGeneratedKeys flag must be set before the operation is compiled\");\n\t\t}\n\t\tthis.returnGeneratedKeys = returnGeneratedKeys;\n\t}\n\n\t/**\n\t * Return whether statements should be capable of returning\n\t * auto-generated keys.\n\t */\n\tpublic boolean isReturnGeneratedKeys() {\n\t\treturn this.returnGeneratedKeys;\n\t}\n\n\t/**\n\t * Set the column names of the auto-generated keys.\n\t * @see java.sql.Connection#prepareStatement(String, String[])\n\t */\n\tpublic void setGeneratedKeysColumnNames(String @Nullable ... names) {\n\t\tif (isCompiled()) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"The column names for the generated keys must be set before the operation is compiled\");\n\t\t}\n\t\tthis.generatedKeysColumnNames = names;\n\t}\n\n\t/**\n\t * Return the column names of the auto generated keys.\n\t */\n\tpublic String @Nullable [] getGeneratedKeysColumnNames() {\n\t\treturn this.generatedKeysColumnNames;\n\t}\n\n\t/**\n\t * Set the SQL executed by this operation.\n\t */\n\tpublic void setSql(@Nullable String sql) {\n\t\tthis.sql = sql;\n\t}\n\n\t/**\n\t * Subclasses can override this to supply dynamic SQL if they wish, but SQL is\n\t * normally set by calling the {@link #setSql} method or in a subclass constructor.\n\t */\n\tpublic @Nullable String getSql() {\n\t\treturn this.sql;\n\t}\n\n\t/**\n\t * Resolve the configured SQL for actual use.\n\t * @return the SQL (never {@code null})\n\t * @since 5.0\n\t */\n\tprotected String resolveSql() {\n\t\tString sql = getSql();\n\t\tAssert.state(sql != null, \"No SQL set\");\n\t\treturn sql;\n\t}\n\n\t/**\n\t * Add anonymous parameters, specifying only their SQL types\n\t * as defined in the {@code java.sql.Types} class.\n\t * <p>Parameter ordering is significant. This method is an alternative\n\t * to the {@link #declareParameter} method, which should normally be preferred.\n\t * @param types array of SQL types as defined in the\n\t * {@code java.sql.Types} class\n\t * @throws InvalidDataAccessApiUsageException if the operation is already compiled\n\t */\n\tpublic void setTypes(int @Nullable [] types) throws InvalidDataAccessApiUsageException {\n\t\tif (isCompiled()) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\"Cannot add parameters once query is compiled\");\n\t\t}\n\t\tif (types != null) {\n\t\t\tfor (int type : types) {\n\t\t\t\tdeclareParameter(new SqlParameter(type));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Declare a parameter for this operation.\n\t * <p>The order in which this method is called is significant when using\n\t * positional parameters. It is not significant when using named parameters\n\t * with named SqlParameter objects here; it remains significant when using\n\t * named parameters in combination with unnamed SqlParameter objects here.\n\t * @param param the SqlParameter to add. This will specify SQL type and (optionally)\n\t * the parameter's name. Note that you typically use the {@link SqlParameter} class\n\t * itself here, not any of its subclasses.\n\t * @throws InvalidDataAccessApiUsageException if the operation is already compiled,\n\t * and hence cannot be configured further\n\t */\n\tpublic void declareParameter(SqlParameter param) throws InvalidDataAccessApiUsageException {\n\t\tif (isCompiled()) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\"Cannot add parameters once the query is compiled\");\n\t\t}\n\t\tthis.declaredParameters.add(param);\n\t}\n\n\t/**\n\t * Add one or more declared parameters. Used for configuring this operation\n\t * when used in a bean factory.  Each parameter will specify SQL type and (optionally)\n\t * the parameter's name.\n\t * @param parameters an array containing the declared {@link SqlParameter} objects\n\t * @see #declaredParameters\n\t */\n\tpublic void setParameters(SqlParameter... parameters) {\n\t\tif (isCompiled()) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\"Cannot add parameters once the query is compiled\");\n\t\t}\n\t\tfor (int i = 0; i < parameters.length; i++) {\n\t\t\tif (parameters[i] != null) {\n\t\t\t\tthis.declaredParameters.add(parameters[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\"Cannot add parameter at index \" + i + \" from \" +\n\t\t\t\t\t\tArrays.asList(parameters) + \" since it is 'null'\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return a list of the declared {@link SqlParameter} objects.\n\t */\n\tprotected List<SqlParameter> getDeclaredParameters() {\n\t\treturn this.declaredParameters;\n\t}\n\n\n\t/**\n\t * Ensures compilation if used in a bean factory.\n\t */\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\tcompile();\n\t}\n\n\t/**\n\t * Compile this query.\n\t * Ignores subsequent attempts to compile.\n\t * @throws InvalidDataAccessApiUsageException if the object hasn't\n\t * been correctly initialized, for example if no DataSource has been provided\n\t */\n\tpublic final void compile() throws InvalidDataAccessApiUsageException {\n\t\tif (!isCompiled()) {\n\t\t\tif (getSql() == null) {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\"Property 'sql' is required\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tthis.jdbcTemplate.afterPropertiesSet();\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(ex.getMessage());\n\t\t\t}\n\n\t\t\tcompileInternal();\n\t\t\tthis.compiled = true;\n\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"RdbmsOperation with SQL [\" + getSql() + \"] compiled\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Is this operation \"compiled\"? Compilation, as in JDO,\n\t * means that the operation is fully configured, and ready to use.\n\t * The exact meaning of compilation will vary between subclasses.\n\t * @return whether this operation is compiled and ready to use\n\t */\n\tpublic boolean isCompiled() {\n\t\treturn this.compiled;\n\t}\n\n\t/**\n\t * Check whether this operation has been compiled already;\n\t * lazily compile it if not already compiled.\n\t * <p>Automatically called by {@code validateParameters}.\n\t * @see #validateParameters\n\t */\n\tprotected void checkCompiled() {\n\t\tif (!isCompiled()) {\n\t\t\tlogger.debug(\"SQL operation not compiled before execution - invoking compile\");\n\t\t\tcompile();\n\t\t}\n\t}\n\n\t/**\n\t * Validate the parameters passed to an execute method based on declared parameters.\n\t * Subclasses should invoke this method before every {@code executeQuery()}\n\t * or {@code update()} method.\n\t * @param parameters the parameters supplied (may be {@code null})\n\t * @throws InvalidDataAccessApiUsageException if the parameters are invalid\n\t */\n\tprotected void validateParameters(Object @Nullable [] parameters) throws InvalidDataAccessApiUsageException {\n\t\tcheckCompiled();\n\t\tint declaredInParameters = 0;\n\t\tfor (SqlParameter param : this.declaredParameters) {\n\t\t\tif (param.isInputValueProvided()) {\n\t\t\t\tif (!supportsLobParameters() &&\n\t\t\t\t\t\t(param.getSqlType() == Types.BLOB || param.getSqlType() == Types.CLOB)) {\n\t\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\t\"BLOB or CLOB parameters are not allowed for this kind of operation\");\n\t\t\t\t}\n\t\t\t\tdeclaredInParameters++;\n\t\t\t}\n\t\t}\n\t\tvalidateParameterCount((parameters != null ? parameters.length : 0), declaredInParameters);\n\t}\n\n\t/**\n\t * Validate the named parameters passed to an execute method based on declared parameters.\n\t * Subclasses should invoke this method before every {@code executeQuery()} or\n\t * {@code update()} method.\n\t * @param parameters parameter Map supplied (may be {@code null})\n\t * @throws InvalidDataAccessApiUsageException if the parameters are invalid\n\t */\n\tprotected void validateNamedParameters(@Nullable Map<String, ?> parameters) throws InvalidDataAccessApiUsageException {\n\t\tcheckCompiled();\n\t\tMap<String, ?> paramsToUse = (parameters != null ? parameters : Collections.<String, Object> emptyMap());\n\t\tint declaredInParameters = 0;\n\t\tfor (SqlParameter param : this.declaredParameters) {\n\t\t\tif (param.isInputValueProvided()) {\n\t\t\t\tif (!supportsLobParameters() &&\n\t\t\t\t\t\t(param.getSqlType() == Types.BLOB || param.getSqlType() == Types.CLOB)) {\n\t\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\t\"BLOB or CLOB parameters are not allowed for this kind of operation\");\n\t\t\t\t}\n\t\t\t\tif (param.getName() != null && !paramsToUse.containsKey(param.getName())) {\n\t\t\t\t\tthrow new InvalidDataAccessApiUsageException(\"The parameter named '\" + param.getName() +\n\t\t\t\t\t\t\t\"' was not among the parameters supplied: \" + paramsToUse.keySet());\n\t\t\t\t}\n\t\t\t\tdeclaredInParameters++;\n\t\t\t}\n\t\t}\n\t\tvalidateParameterCount(paramsToUse.size(), declaredInParameters);\n\t}\n\n\t/**\n\t * Validate the given parameter count against the given declared parameters.\n\t * @param suppliedParamCount the number of actual parameters given\n\t * @param declaredInParamCount the number of input parameters declared\n\t */\n\tprivate void validateParameterCount(int suppliedParamCount, int declaredInParamCount) {\n\t\tif (suppliedParamCount < declaredInParamCount) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(suppliedParamCount + \" parameters were supplied, but \" +\n\t\t\t\t\tdeclaredInParamCount + \" in parameters were declared in class [\" + getClass().getName() + \"]\");\n\t\t}\n\t\tif (suppliedParamCount > this.declaredParameters.size() && !allowsUnusedParameters()) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(suppliedParamCount + \" parameters were supplied, but \" +\n\t\t\t\t\tdeclaredInParamCount + \" parameters were declared in class [\" + getClass().getName() + \"]\");\n\t\t}\n\t}\n\n\n\t/**\n\t * Subclasses must implement this template method to perform their own compilation.\n\t * Invoked after this base class's compilation is complete.\n\t * <p>Subclasses can assume that SQL and a DataSource have been supplied.\n\t * @throws InvalidDataAccessApiUsageException if the subclass hasn't been\n\t * properly configured\n\t */\n\tprotected abstract void compileInternal() throws InvalidDataAccessApiUsageException;\n\n\t/**\n\t * Return whether BLOB/CLOB parameters are supported for this kind of operation.\n\t * <p>The default is {@code true}.\n\t */\n\tprotected boolean supportsLobParameters() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Return whether this operation accepts additional parameters that are\n\t * given but not actually used. Applies in particular to parameter Maps.\n\t * <p>The default is {@code false}.\n\t * @see StoredProcedure\n\t */\n\tprotected boolean allowsUnusedParameters() {\n\t\treturn false;\n\t}\n\n}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Ensures compilation if used in a bean factory.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tcompile();\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#allowsUnusedParameters()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this operation accepts additional parameters that are\n\t * given but not actually used. Applies in particular to parameter Maps.\n\t * <p>The default is {@code false}.\n\t * @see StoredProcedure\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 473
    },
    "return": "boolean",
    "signature": "protected boolean allowsUnusedParameters()",
    "source_code": "\tprotected boolean allowsUnusedParameters() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#checkCompiled()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether this operation has been compiled already;\n\t * lazily compile it if not already compiled.\n\t * <p>Automatically called by {@code validateParameters}.\n\t * @see #validateParameters\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "void",
    "signature": "protected void checkCompiled()",
    "source_code": "\tprotected void checkCompiled() {\n\t\tif (!isCompiled()) {\n\t\t\tlogger.debug(\"SQL operation not compiled before execution - invoking compile\");\n\t\t\tcompile();\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#compile()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Compile this query.\n\t * Ignores subsequent attempts to compile.\n\t * @throws InvalidDataAccessApiUsageException if the object hasn't\n\t * been correctly initialized, for example if no DataSource has been provided\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "void",
    "signature": "public void compile()",
    "source_code": "\tpublic final void compile() throws InvalidDataAccessApiUsageException {\n\t\tif (!isCompiled()) {\n\t\t\tif (getSql() == null) {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\"Property 'sql' is required\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tthis.jdbcTemplate.afterPropertiesSet();\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(ex.getMessage());\n\t\t\t}\n\n\t\t\tcompileInternal();\n\t\t\tthis.compiled = true;\n\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"RdbmsOperation with SQL [\" + getSql() + \"] compiled\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#compileInternal()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses must implement this template method to perform their own compilation.\n\t * Invoked after this base class's compilation is complete.\n\t * <p>Subclasses can assume that SQL and a DataSource have been supplied.\n\t * @throws InvalidDataAccessApiUsageException if the subclass hasn't been\n\t * properly configured\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 457
    },
    "return": "void",
    "signature": "protected void compileInternal()",
    "source_code": "\tprotected abstract void compileInternal() throws InvalidDataAccessApiUsageException;"
  },
  "org.springframework.jdbc.object.RdbmsOperation#declareParameter(param)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Declare a parameter for this operation.\n\t * <p>The order in which this method is called is significant when using\n\t * positional parameters. It is not significant when using named parameters\n\t * with named SqlParameter objects here; it remains significant when using\n\t * named parameters in combination with unnamed SqlParameter objects here.\n\t * @param param the SqlParameter to add. This will specify SQL type and (optionally)\n\t * the parameter's name. Note that you typically use the {@link SqlParameter} class\n\t * itself here, not any of its subclasses.\n\t * @throws InvalidDataAccessApiUsageException if the operation is already compiled,\n\t * and hence cannot be configured further\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "param"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "void",
    "signature": "public void declareParameter(SqlParameter param)",
    "source_code": "\tpublic void declareParameter(SqlParameter param) throws InvalidDataAccessApiUsageException {\n\t\tif (isCompiled()) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\"Cannot add parameters once the query is compiled\");\n\t\t}\n\t\tthis.declaredParameters.add(param);\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#getDeclaredParameters()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a list of the declared {@link SqlParameter} objects.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "List<SqlParameter>",
    "signature": "protected List<SqlParameter> getDeclaredParameters()",
    "source_code": "\tprotected List<SqlParameter> getDeclaredParameters() {\n\t\treturn this.declaredParameters;\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#getJdbcTemplate()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link JdbcTemplate} used by this operation object.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "JdbcTemplate",
    "signature": "public JdbcTemplate getJdbcTemplate()",
    "source_code": "\tpublic JdbcTemplate getJdbcTemplate() {\n\t\treturn this.jdbcTemplate;\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#getResultSetType()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether statements will return a specific type of ResultSet.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "int",
    "signature": "public int getResultSetType()",
    "source_code": "\tpublic int getResultSetType() {\n\t\treturn this.resultSetType;\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#getSql()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can override this to supply dynamic SQL if they wish, but SQL is\n\t * normally set by calling the {@link #setSql} method or in a subclass constructor.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "String",
    "signature": "public String getSql()",
    "source_code": "\tpublic @Nullable String getSql() {\n\t\treturn this.sql;\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#isCompiled()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Is this operation \"compiled\"? Compilation, as in JDO,\n\t * means that the operation is fully configured, and ready to use.\n\t * The exact meaning of compilation will vary between subclasses.\n\t * @return whether this operation is compiled and ready to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "boolean",
    "signature": "public boolean isCompiled()",
    "source_code": "\tpublic boolean isCompiled() {\n\t\treturn this.compiled;\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#isReturnGeneratedKeys()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether statements should be capable of returning\n\t * auto-generated keys.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "boolean",
    "signature": "public boolean isReturnGeneratedKeys()",
    "source_code": "\tpublic boolean isReturnGeneratedKeys() {\n\t\treturn this.returnGeneratedKeys;\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#isUpdatableResults()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether statements will return updatable ResultSets.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "boolean",
    "signature": "public boolean isUpdatableResults()",
    "source_code": "\tpublic boolean isUpdatableResults() {\n\t\treturn this.updatableResults;\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#resolveSql()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the configured SQL for actual use.\n\t * @return the SQL (never {@code null})\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "String",
    "signature": "protected String resolveSql()",
    "source_code": "\tprotected String resolveSql() {\n\t\tString sql = getSql();\n\t\tAssert.state(sql != null, \"No SQL set\");\n\t\treturn sql;\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#setDataSource(dataSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JDBC {@link DataSource} to obtain connections from.\n\t * @see org.springframework.jdbc.core.JdbcTemplate#setDataSource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void setDataSource(DataSource dataSource)",
    "source_code": "\tpublic void setDataSource(DataSource dataSource) {\n\t\tthis.jdbcTemplate.setDataSource(dataSource);\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#setFetchSize(fetchSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the fetch size for this RDBMS operation. This is important for processing\n\t * large result sets: Setting this higher than the default value will increase\n\t * processing speed at the cost of memory consumption; setting this lower can\n\t * avoid transferring row data that will never be read by the application.\n\t * <p>Default is -1, indicating to use the driver's default.\n\t * @see org.springframework.jdbc.core.JdbcTemplate#setFetchSize\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fetchSize"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "public void setFetchSize(int fetchSize)",
    "source_code": "\tpublic void setFetchSize(int fetchSize) {\n\t\tthis.jdbcTemplate.setFetchSize(fetchSize);\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#setGeneratedKeysColumnNames(names)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the column names of the auto-generated keys.\n\t * @see java.sql.Connection#prepareStatement(String, String[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "names"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "void",
    "signature": "public void setGeneratedKeysColumnNames(String @Nullable ... names)",
    "source_code": "\tpublic void setGeneratedKeysColumnNames(String @Nullable ... names) {\n\t\tif (isCompiled()) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"The column names for the generated keys must be set before the operation is compiled\");\n\t\t}\n\t\tthis.generatedKeysColumnNames = names;\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#setJdbcTemplate(jdbcTemplate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to the more commonly used {@link #setDataSource} when you want to\n\t * use the same {@link JdbcTemplate} in multiple {@code RdbmsOperations}. This is\n\t * appropriate if the {@code JdbcTemplate} has special configuration such as a\n\t * {@link org.springframework.jdbc.support.SQLExceptionTranslator} to be reused.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jdbcTemplate"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void setJdbcTemplate(JdbcTemplate jdbcTemplate)",
    "source_code": "\tpublic void setJdbcTemplate(JdbcTemplate jdbcTemplate) {\n\t\tthis.jdbcTemplate = jdbcTemplate;\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#setMaxRows(maxRows)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the maximum number of rows for this RDBMS operation. This is important\n\t * for processing subsets of large result sets, in order to avoid reading and\n\t * holding the entire result set in the database or in the JDBC driver.\n\t * <p>Default is -1, indicating to use the driver's default.\n\t * @see org.springframework.jdbc.core.JdbcTemplate#setMaxRows\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "maxRows"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void setMaxRows(int maxRows)",
    "source_code": "\tpublic void setMaxRows(int maxRows) {\n\t\tthis.jdbcTemplate.setMaxRows(maxRows);\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#setParameters(parameters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add one or more declared parameters. Used for configuring this operation\n\t * when used in a bean factory.  Each parameter will specify SQL type and (optionally)\n\t * the parameter's name.\n\t * @param parameters an array containing the declared {@link SqlParameter} objects\n\t * @see #declaredParameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "void",
    "signature": "public void setParameters(SqlParameter... parameters)",
    "source_code": "\tpublic void setParameters(SqlParameter... parameters) {\n\t\tif (isCompiled()) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\"Cannot add parameters once the query is compiled\");\n\t\t}\n\t\tfor (int i = 0; i < parameters.length; i++) {\n\t\t\tif (parameters[i] != null) {\n\t\t\t\tthis.declaredParameters.add(parameters[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\"Cannot add parameter at index \" + i + \" from \" +\n\t\t\t\t\t\tArrays.asList(parameters) + \" since it is 'null'\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#setQueryTimeout(queryTimeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the query timeout for statements that this RDBMS operation executes.\n\t * <p>Default is -1, indicating to use the JDBC driver's default.\n\t * <p>Note: Any timeout specified here will be overridden by the remaining\n\t * transaction timeout when executing within a transaction that has a\n\t * timeout specified at the transaction level.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queryTimeout"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "public void setQueryTimeout(int queryTimeout)",
    "source_code": "\tpublic void setQueryTimeout(int queryTimeout) {\n\t\tthis.jdbcTemplate.setQueryTimeout(queryTimeout);\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#setResultSetType(resultSetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to use statements that return a specific type of ResultSet.\n\t * @param resultSetType the ResultSet type\n\t * @see java.sql.ResultSet#TYPE_FORWARD_ONLY\n\t * @see java.sql.ResultSet#TYPE_SCROLL_INSENSITIVE\n\t * @see java.sql.ResultSet#TYPE_SCROLL_SENSITIVE\n\t * @see java.sql.Connection#prepareStatement(String, int, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resultSetType"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "public void setResultSetType(int resultSetType)",
    "source_code": "\tpublic void setResultSetType(int resultSetType) {\n\t\tthis.resultSetType = resultSetType;\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#setReturnGeneratedKeys(returnGeneratedKeys)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether prepared statements should be capable of returning\n\t * auto-generated keys.\n\t * @see java.sql.Connection#prepareStatement(String, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnGeneratedKeys"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "void",
    "signature": "public void setReturnGeneratedKeys(boolean returnGeneratedKeys)",
    "source_code": "\tpublic void setReturnGeneratedKeys(boolean returnGeneratedKeys) {\n\t\tif (isCompiled()) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"The returnGeneratedKeys flag must be set before the operation is compiled\");\n\t\t}\n\t\tthis.returnGeneratedKeys = returnGeneratedKeys;\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#setSql(sql)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the SQL executed by this operation.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql"
    ],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "void",
    "signature": "public void setSql(@Nullable String sql)",
    "source_code": "\tpublic void setSql(@Nullable String sql) {\n\t\tthis.sql = sql;\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#setTypes(types)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add anonymous parameters, specifying only their SQL types\n\t * as defined in the {@code java.sql.Types} class.\n\t * <p>Parameter ordering is significant. This method is an alternative\n\t * to the {@link #declareParameter} method, which should normally be preferred.\n\t * @param types array of SQL types as defined in the\n\t * {@code java.sql.Types} class\n\t * @throws InvalidDataAccessApiUsageException if the operation is already compiled\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "types"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "void",
    "signature": "public void setTypes(int @Nullable [] types)",
    "source_code": "\tpublic void setTypes(int @Nullable [] types) throws InvalidDataAccessApiUsageException {\n\t\tif (isCompiled()) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\"Cannot add parameters once query is compiled\");\n\t\t}\n\t\tif (types != null) {\n\t\t\tfor (int type : types) {\n\t\t\t\tdeclareParameter(new SqlParameter(type));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#setUpdatableResults(updatableResults)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to use statements that are capable of returning\n\t * updatable ResultSets.\n\t * @see java.sql.Connection#prepareStatement(String, int, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "updatableResults"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "public void setUpdatableResults(boolean updatableResults)",
    "source_code": "\tpublic void setUpdatableResults(boolean updatableResults) {\n\t\tif (isCompiled()) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"The updatableResults flag must be set before the operation is compiled\");\n\t\t}\n\t\tthis.updatableResults = updatableResults;\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#supportsLobParameters()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether BLOB/CLOB parameters are supported for this kind of operation.\n\t * <p>The default is {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 463
    },
    "return": "boolean",
    "signature": "protected boolean supportsLobParameters()",
    "source_code": "\tprotected boolean supportsLobParameters() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#validateNamedParameters(Map<String,parameters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the named parameters passed to an execute method based on declared parameters.\n\t * Subclasses should invoke this method before every {@code executeQuery()} or\n\t * {@code update()} method.\n\t * @param parameters parameter Map supplied (may be {@code null})\n\t * @throws InvalidDataAccessApiUsageException if the parameters are invalid\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "void",
    "signature": "protected void validateNamedParameters(@Nullable Map<String, ?> parameters)",
    "source_code": "\tprotected void validateNamedParameters(@Nullable Map<String, ?> parameters) throws InvalidDataAccessApiUsageException {\n\t\tcheckCompiled();\n\t\tMap<String, ?> paramsToUse = (parameters != null ? parameters : Collections.<String, Object> emptyMap());\n\t\tint declaredInParameters = 0;\n\t\tfor (SqlParameter param : this.declaredParameters) {\n\t\t\tif (param.isInputValueProvided()) {\n\t\t\t\tif (!supportsLobParameters() &&\n\t\t\t\t\t\t(param.getSqlType() == Types.BLOB || param.getSqlType() == Types.CLOB)) {\n\t\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\t\"BLOB or CLOB parameters are not allowed for this kind of operation\");\n\t\t\t\t}\n\t\t\t\tif (param.getName() != null && !paramsToUse.containsKey(param.getName())) {\n\t\t\t\t\tthrow new InvalidDataAccessApiUsageException(\"The parameter named '\" + param.getName() +\n\t\t\t\t\t\t\t\"' was not among the parameters supplied: \" + paramsToUse.keySet());\n\t\t\t\t}\n\t\t\t\tdeclaredInParameters++;\n\t\t\t}\n\t\t}\n\t\tvalidateParameterCount(paramsToUse.size(), declaredInParameters);\n\t}"
  },
  "org.springframework.jdbc.object.RdbmsOperation#validateParameters(parameters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the parameters passed to an execute method based on declared parameters.\n\t * Subclasses should invoke this method before every {@code executeQuery()}\n\t * or {@code update()} method.\n\t * @param parameters the parameters supplied (may be {@code null})\n\t * @throws InvalidDataAccessApiUsageException if the parameters are invalid\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "void",
    "signature": "protected void validateParameters(Object @Nullable [] parameters)",
    "source_code": "\tprotected void validateParameters(Object @Nullable [] parameters) throws InvalidDataAccessApiUsageException {\n\t\tcheckCompiled();\n\t\tint declaredInParameters = 0;\n\t\tfor (SqlParameter param : this.declaredParameters) {\n\t\t\tif (param.isInputValueProvided()) {\n\t\t\t\tif (!supportsLobParameters() &&\n\t\t\t\t\t\t(param.getSqlType() == Types.BLOB || param.getSqlType() == Types.CLOB)) {\n\t\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\t\"BLOB or CLOB parameters are not allowed for this kind of operation\");\n\t\t\t\t}\n\t\t\t\tdeclaredInParameters++;\n\t\t\t}\n\t\t}\n\t\tvalidateParameterCount((parameters != null ? parameters.length : 0), declaredInParameters);\n\t}"
  },
  "org.springframework.jdbc.object.RowMapperImpl": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Implementation of RowMapper that calls the enclosing\n\t * class's {@code mapRow} method for each row.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "signature": "protected class RowMapperImpl",
    "source_code": "\tprotected class RowMapperImpl implements RowMapper<T> {\n\n\t\tprivate final @Nullable Object @Nullable [] params;\n\n\t\tprivate final @Nullable Map<?, ?> context;\n\n\t\t/**\n\t\t * Use an array results. More efficient if we know how many results to expect.\n\t\t */\n\t\tpublic RowMapperImpl(@Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context) {\n\t\t\tthis.params = parameters;\n\t\t\tthis.context = context;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable T mapRow(ResultSet rs, int rowNum) throws SQLException {\n\t\t\treturn MappingSqlQueryWithParameters.this.mapRow(rs, rowNum, this.params, this.context);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.object.SqlOperation": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Operation object representing an SQL-based operation such as a query or update,\n * as opposed to a stored procedure.\n *\n * <p>Configures a {@link org.springframework.jdbc.core.PreparedStatementCreatorFactory}\n * based on the declared parameters.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class SqlOperation",
    "source_code": "public abstract class SqlOperation extends RdbmsOperation {\n\n\t/**\n\t * Object enabling us to create PreparedStatementCreators efficiently,\n\t * based on this class's declared parameters.\n\t */\n\tprivate @Nullable PreparedStatementCreatorFactory preparedStatementFactory;\n\n\t/** Parsed representation of the SQL statement. */\n\tprivate @Nullable ParsedSql cachedSql;\n\n\t/** Monitor for locking the cached representation of the parsed SQL statement. */\n\tprivate final Object parsedSqlMonitor = new Object();\n\n\n\t/**\n\t * Overridden method to configure the PreparedStatementCreatorFactory\n\t * based on our declared parameters.\n\t */\n\t@Override\n\tprotected final void compileInternal() {\n\t\tthis.preparedStatementFactory = new PreparedStatementCreatorFactory(resolveSql(), getDeclaredParameters());\n\t\tthis.preparedStatementFactory.setResultSetType(getResultSetType());\n\t\tthis.preparedStatementFactory.setUpdatableResults(isUpdatableResults());\n\t\tthis.preparedStatementFactory.setReturnGeneratedKeys(isReturnGeneratedKeys());\n\t\tif (getGeneratedKeysColumnNames() != null) {\n\t\t\tthis.preparedStatementFactory.setGeneratedKeysColumnNames(getGeneratedKeysColumnNames());\n\t\t}\n\n\t\tonCompileInternal();\n\t}\n\n\t/**\n\t * Hook method that subclasses may override to post-process compilation.\n\t * This implementation does nothing.\n\t * @see #compileInternal\n\t */\n\tprotected void onCompileInternal() {\n\t}\n\n\t/**\n\t * Obtain a parsed representation of this operation's SQL statement.\n\t * <p>Typically used for named parameter parsing.\n\t */\n\tprotected ParsedSql getParsedSql() {\n\t\tsynchronized (this.parsedSqlMonitor) {\n\t\t\tif (this.cachedSql == null) {\n\t\t\t\tthis.cachedSql = NamedParameterUtils.parseSqlStatement(resolveSql());\n\t\t\t}\n\t\t\treturn this.cachedSql;\n\t\t}\n\t}\n\n\n\t/**\n\t * Return a PreparedStatementSetter to perform an operation\n\t * with the given parameters.\n\t * @param params the parameter array (may be {@code null})\n\t */\n\tprotected final PreparedStatementSetter newPreparedStatementSetter(@Nullable Object @Nullable [] params) {\n\t\tAssert.state(this.preparedStatementFactory != null, \"No PreparedStatementFactory available\");\n\t\treturn this.preparedStatementFactory.newPreparedStatementSetter(params);\n\t}\n\n\t/**\n\t * Return a PreparedStatementCreator to perform an operation\n\t * with the given parameters.\n\t * @param params the parameter array (may be {@code null})\n\t */\n\tprotected final PreparedStatementCreator newPreparedStatementCreator(@Nullable Object @Nullable [] params) {\n\t\tAssert.state(this.preparedStatementFactory != null, \"No PreparedStatementFactory available\");\n\t\treturn this.preparedStatementFactory.newPreparedStatementCreator(params);\n\t}\n\n\t/**\n\t * Return a PreparedStatementCreator to perform an operation\n\t * with the given parameters.\n\t * @param sqlToUse the actual SQL statement to use (if different from\n\t * the factory's, for example because of named parameter expanding)\n\t * @param params the parameter array (may be {@code null})\n\t */\n\tprotected final PreparedStatementCreator newPreparedStatementCreator(String sqlToUse, @Nullable Object @Nullable [] params) {\n\t\tAssert.state(this.preparedStatementFactory != null, \"No PreparedStatementFactory available\");\n\t\treturn this.preparedStatementFactory.newPreparedStatementCreator(sqlToUse, params);\n\t}\n\n}"
  },
  "org.springframework.jdbc.object.SqlOperation#compileInternal()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Overridden method to configure the PreparedStatementCreatorFactory\n\t * based on our declared parameters.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "void",
    "signature": "protected void compileInternal()",
    "source_code": "\tprotected final void compileInternal() {\n\t\tthis.preparedStatementFactory = new PreparedStatementCreatorFactory(resolveSql(), getDeclaredParameters());\n\t\tthis.preparedStatementFactory.setResultSetType(getResultSetType());\n\t\tthis.preparedStatementFactory.setUpdatableResults(isUpdatableResults());\n\t\tthis.preparedStatementFactory.setReturnGeneratedKeys(isReturnGeneratedKeys());\n\t\tif (getGeneratedKeysColumnNames() != null) {\n\t\t\tthis.preparedStatementFactory.setGeneratedKeysColumnNames(getGeneratedKeysColumnNames());\n\t\t}\n\n\t\tonCompileInternal();\n\t}"
  },
  "org.springframework.jdbc.object.SqlOperation#getParsedSql()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a parsed representation of this operation's SQL statement.\n\t * <p>Typically used for named parameter parsing.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "ParsedSql",
    "signature": "protected ParsedSql getParsedSql()",
    "source_code": "\tprotected ParsedSql getParsedSql() {\n\t\tsynchronized (this.parsedSqlMonitor) {\n\t\t\tif (this.cachedSql == null) {\n\t\t\t\tthis.cachedSql = NamedParameterUtils.parseSqlStatement(resolveSql());\n\t\t\t}\n\t\t\treturn this.cachedSql;\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.object.SqlOperation#newPreparedStatementCreator(params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a PreparedStatementCreator to perform an operation\n\t * with the given parameters.\n\t * @param params the parameter array (may be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "params"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "PreparedStatementCreator",
    "signature": "protected PreparedStatementCreator newPreparedStatementCreator(@Nullable Object @Nullable [] params)",
    "source_code": "\tprotected final PreparedStatementCreator newPreparedStatementCreator(@Nullable Object @Nullable [] params) {\n\t\tAssert.state(this.preparedStatementFactory != null, \"No PreparedStatementFactory available\");\n\t\treturn this.preparedStatementFactory.newPreparedStatementCreator(params);\n\t}"
  },
  "org.springframework.jdbc.object.SqlOperation#newPreparedStatementCreator(sqlToUse,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a PreparedStatementCreator to perform an operation\n\t * with the given parameters.\n\t * @param sqlToUse the actual SQL statement to use (if different from\n\t * the factory's, for example because of named parameter expanding)\n\t * @param params the parameter array (may be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sqlToUse",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "PreparedStatementCreator",
    "signature": "protected PreparedStatementCreator newPreparedStatementCreator(String sqlToUse, @Nullable Object @Nullable [] params)",
    "source_code": "\tprotected final PreparedStatementCreator newPreparedStatementCreator(String sqlToUse, @Nullable Object @Nullable [] params) {\n\t\tAssert.state(this.preparedStatementFactory != null, \"No PreparedStatementFactory available\");\n\t\treturn this.preparedStatementFactory.newPreparedStatementCreator(sqlToUse, params);\n\t}"
  },
  "org.springframework.jdbc.object.SqlOperation#newPreparedStatementSetter(params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a PreparedStatementSetter to perform an operation\n\t * with the given parameters.\n\t * @param params the parameter array (may be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "params"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "PreparedStatementSetter",
    "signature": "protected PreparedStatementSetter newPreparedStatementSetter(@Nullable Object @Nullable [] params)",
    "source_code": "\tprotected final PreparedStatementSetter newPreparedStatementSetter(@Nullable Object @Nullable [] params) {\n\t\tAssert.state(this.preparedStatementFactory != null, \"No PreparedStatementFactory available\");\n\t\treturn this.preparedStatementFactory.newPreparedStatementSetter(params);\n\t}"
  },
  "org.springframework.jdbc.object.SqlOperation#onCompileInternal()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook method that subclasses may override to post-process compilation.\n\t * This implementation does nothing.\n\t * @see #compileInternal\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "void",
    "signature": "protected void onCompileInternal()",
    "source_code": "\tprotected void onCompileInternal() {\n\t}"
  },
  "org.springframework.jdbc.object.SqlQuery": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Reusable operation object representing an SQL query.\n *\n * <p>Subclasses must implement the {@link #newRowMapper} method to provide\n * an object that can extract the results of iterating over the\n * {@code ResultSet} created during the execution of the query.\n *\n * <p>This class provides a number of public {@code execute} methods that are\n * analogous to the different convenient JDO query execute methods. Subclasses\n * can either rely on one of these inherited methods, or can add their own\n * custom execution methods, with meaningful names and typed parameters\n * (definitely a best practice). Each custom query method will invoke one of\n * this class's untyped query methods.\n *\n * <p>Like all {@code RdbmsOperation} classes that ship with the Spring\n * Framework, {@code SqlQuery} instances are thread-safe after their\n * initialization is complete. That is, after they are constructed and configured\n * via their setter methods, they can be used safely from multiple threads.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Thomas Risberg\n * @param <T> the result type\n * @see SqlUpdate\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "signature": "public class SqlQuery",
    "source_code": "public abstract class SqlQuery<T> extends SqlOperation {\n\n\t/** The number of rows to expect; if 0, unknown. */\n\tprivate int rowsExpected = 0;\n\n\n\t/**\n\t * Constructor to allow use as a JavaBean.\n\t * <p>The {@code DataSource} and SQL must be supplied before\n\t * compilation and use.\n\t */\n\tpublic SqlQuery() {\n\t}\n\n\t/**\n\t * Convenient constructor with a {@code DataSource} and SQL string.\n\t * @param ds the {@code DataSource} to use to get connections\n\t * @param sql the SQL to execute; SQL can also be supplied at runtime\n\t * by overriding the {@link #getSql()} method.\n\t */\n\tpublic SqlQuery(DataSource ds, String sql) {\n\t\tsetDataSource(ds);\n\t\tsetSql(sql);\n\t}\n\n\n\t/**\n\t * Set the number of rows expected.\n\t * <p>This can be used to ensure efficient storage of results. The\n\t * default behavior is not to expect any specific number of rows.\n\t */\n\tpublic void setRowsExpected(int rowsExpected) {\n\t\tthis.rowsExpected = rowsExpected;\n\t}\n\n\t/**\n\t * Get the number of rows expected.\n\t */\n\tpublic int getRowsExpected() {\n\t\treturn this.rowsExpected;\n\t}\n\n\n\t/**\n\t * Central execution method. All un-named parameter execution goes through this method.\n\t * @param params parameters, similar to JDO query parameters.\n\t * Primitive parameters must be represented by their Object wrapper type.\n\t * The ordering of parameters is significant.\n\t * @param context the contextual information passed to the {@code mapRow}\n\t * callback method. The JDBC operation itself doesn't rely on this parameter,\n\t * but it can be useful for creating the objects of the result list.\n\t * @return a List of objects, one per row of the ResultSet. Normally all these\n\t * will be of the same class, although it is possible to use different types.\n\t */\n\tpublic List<T> execute(Object @Nullable [] params, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\tvalidateParameters(params);\n\t\tRowMapper<T> rowMapper = newRowMapper(params, context);\n\t\treturn getJdbcTemplate().query(newPreparedStatementCreator(params), rowMapper);\n\t}\n\n\t/**\n\t * Convenient method to execute without context.\n\t * @param params parameters for the query. Primitive parameters must\n\t * be represented by their Object wrapper type. The ordering of parameters is\n\t * significant.\n\t */\n\tpublic List<T> execute(Object... params) throws DataAccessException {\n\t\treturn execute(params, null);\n\t}\n\n\t/**\n\t * Convenient method to execute without parameters.\n\t * @param context the contextual information for object creation\n\t */\n\tpublic List<T> execute(Map<?, ?> context) throws DataAccessException {\n\t\treturn execute((Object[]) null, context);\n\t}\n\n\t/**\n\t * Convenient method to execute without parameters nor context.\n\t */\n\tpublic List<T> execute() throws DataAccessException {\n\t\treturn execute((Object[]) null, null);\n\t}\n\n\t/**\n\t * Convenient method to execute with a single int parameter and context.\n\t * @param p1 single int parameter\n\t * @param context the contextual information for object creation\n\t */\n\tpublic List<T> execute(int p1, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\treturn execute(new Object[] {p1}, context);\n\t}\n\n\t/**\n\t * Convenient method to execute with a single int parameter.\n\t * @param p1 single int parameter\n\t */\n\tpublic List<T> execute(int p1) throws DataAccessException {\n\t\treturn execute(p1, null);\n\t}\n\n\t/**\n\t * Convenient method to execute with two int parameters and context.\n\t * @param p1 first int parameter\n\t * @param p2 second int parameter\n\t * @param context the contextual information for object creation\n\t */\n\tpublic List<T> execute(int p1, int p2, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\treturn execute(new Object[] {p1, p2}, context);\n\t}\n\n\t/**\n\t * Convenient method to execute with two int parameters.\n\t * @param p1 first int parameter\n\t * @param p2 second int parameter\n\t */\n\tpublic List<T> execute(int p1, int p2) throws DataAccessException {\n\t\treturn execute(p1, p2, null);\n\t}\n\n\t/**\n\t * Convenient method to execute with a single long parameter and context.\n\t * @param p1 single long parameter\n\t * @param context the contextual information for object creation\n\t */\n\tpublic List<T> execute(long p1, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\treturn execute(new Object[] {p1}, context);\n\t}\n\n\t/**\n\t * Convenient method to execute with a single long parameter.\n\t * @param p1 single long parameter\n\t */\n\tpublic List<T> execute(long p1) throws DataAccessException {\n\t\treturn execute(p1, null);\n\t}\n\n\t/**\n\t * Convenient method to execute with a single String parameter and context.\n\t * @param p1 single String parameter\n\t * @param context the contextual information for object creation\n\t */\n\tpublic List<T> execute(String p1, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\treturn execute(new Object[] {p1}, context);\n\t}\n\n\t/**\n\t * Convenient method to execute with a single String parameter.\n\t * @param p1 single String parameter\n\t */\n\tpublic List<T> execute(String p1) throws DataAccessException {\n\t\treturn execute(p1, null);\n\t}\n\n\t/**\n\t * Central execution method. All named parameter execution goes through this method.\n\t * @param paramMap parameters associated with the name specified while declaring\n\t * the SqlParameters. Primitive parameters must be represented by their Object wrapper\n\t * type. The ordering of parameters is not significant since they are supplied in a\n\t * SqlParameterMap which is an implementation of the Map interface.\n\t * @param context the contextual information passed to the {@code mapRow}\n\t * callback method. The JDBC operation itself doesn't rely on this parameter,\n\t * but it can be useful for creating the objects of the result list.\n\t * @return a List of objects, one per row of the ResultSet. Normally all these\n\t * will be of the same class, although it is possible to use different types.\n\t */\n\tpublic List<T> executeByNamedParam(Map<String, ?> paramMap, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\tvalidateNamedParameters(paramMap);\n\t\tParsedSql parsedSql = getParsedSql();\n\t\tMapSqlParameterSource paramSource = new MapSqlParameterSource(paramMap);\n\t\tString sqlToUse = NamedParameterUtils.substituteNamedParameters(parsedSql, paramSource);\n\t\t@Nullable Object[] params = NamedParameterUtils.buildValueArray(parsedSql, paramSource, getDeclaredParameters());\n\t\tRowMapper<T> rowMapper = newRowMapper(params, context);\n\t\treturn getJdbcTemplate().query(newPreparedStatementCreator(sqlToUse, params), rowMapper);\n\t}\n\n\t/**\n\t * Convenient method to execute without context.\n\t * @param paramMap parameters associated with the name specified while declaring\n\t * the SqlParameters. Primitive parameters must be represented by their Object wrapper\n\t * type. The ordering of parameters is not significant.\n\t */\n\tpublic List<T> executeByNamedParam(Map<String, ? extends @Nullable Object> paramMap) throws DataAccessException {\n\t\treturn executeByNamedParam(paramMap, null);\n\t}\n\n\n\t/**\n\t * Generic object finder method, used by all other {@code findObject} methods.\n\t * Object finder methods are like EJB entity bean finders, in that it is\n\t * considered an error if they return more than one result.\n\t * @return the result object, or {@code null} if not found. Subclasses may\n\t * choose to treat this as an error and throw an exception.\n\t * @see org.springframework.dao.support.DataAccessUtils#singleResult\n\t */\n\tpublic @Nullable T findObject(Object @Nullable [] params, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\tList<T> results = execute(params, context);\n\t\treturn DataAccessUtils.singleResult(results);\n\t}\n\n\t/**\n\t * Convenient method to find a single object without context.\n\t */\n\tpublic @Nullable T findObject(Object... params) throws DataAccessException {\n\t\treturn findObject(params, null);\n\t}\n\n\t/**\n\t * Convenient method to find a single object given a single int parameter\n\t * and a context.\n\t */\n\tpublic @Nullable T findObject(int p1, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\treturn findObject(new Object[] {p1}, context);\n\t}\n\n\t/**\n\t * Convenient method to find a single object given a single int parameter.\n\t */\n\tpublic @Nullable T findObject(int p1) throws DataAccessException {\n\t\treturn findObject(p1, null);\n\t}\n\n\t/**\n\t * Convenient method to find a single object given two int parameters\n\t * and a context.\n\t */\n\tpublic @Nullable T findObject(int p1, int p2, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\treturn findObject(new Object[] {p1, p2}, context);\n\t}\n\n\t/**\n\t * Convenient method to find a single object given two int parameters.\n\t */\n\tpublic @Nullable T findObject(int p1, int p2) throws DataAccessException {\n\t\treturn findObject(p1, p2, null);\n\t}\n\n\t/**\n\t * Convenient method to find a single object given a single long parameter\n\t * and a context.\n\t */\n\tpublic @Nullable T findObject(long p1, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\treturn findObject(new Object[] {p1}, context);\n\t}\n\n\t/**\n\t * Convenient method to find a single object given a single long parameter.\n\t */\n\tpublic @Nullable T findObject(long p1) throws DataAccessException {\n\t\treturn findObject(p1, null);\n\t}\n\n\t/**\n\t * Convenient method to find a single object given a single String parameter\n\t * and a context.\n\t */\n\tpublic @Nullable T findObject(String p1, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\treturn findObject(new Object[] {p1}, context);\n\t}\n\n\t/**\n\t * Convenient method to find a single object given a single String parameter.\n\t */\n\tpublic @Nullable T findObject(String p1) throws DataAccessException {\n\t\treturn findObject(p1, null);\n\t}\n\n\t/**\n\t * Generic object finder method for named parameters.\n\t * @param paramMap a Map of parameter name to parameter object,\n\t * matching named parameters specified in the SQL statement.\n\t * Ordering is not significant.\n\t * @param context the contextual information passed to the {@code mapRow}\n\t * callback method. The JDBC operation itself doesn't rely on this parameter,\n\t * but it can be useful for creating the objects of the result list.\n\t * @return a List of objects, one per row of the ResultSet. Normally all these\n\t * will be of the same class, although it is possible to use different types.\n\t */\n\tpublic @Nullable T findObjectByNamedParam(Map<String, ?> paramMap, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\tList<T> results = executeByNamedParam(paramMap, context);\n\t\treturn DataAccessUtils.singleResult(results);\n\t}\n\n\t/**\n\t * Convenient method to execute without context.\n\t * @param paramMap a Map of parameter name to parameter object,\n\t * matching named parameters specified in the SQL statement.\n\t * Ordering is not significant.\n\t */\n\tpublic @Nullable T findObjectByNamedParam(Map<String, ?> paramMap) throws DataAccessException {\n\t\treturn findObjectByNamedParam(paramMap, null);\n\t}\n\n\n\t/**\n\t * Subclasses must implement this method to extract an object per row, to be\n\t * returned by the {@code execute} method as an aggregated {@link List}.\n\t * @param parameters the parameters to the {@code execute()} method,\n\t * in case subclass is interested; may be {@code null} if there\n\t * were no parameters.\n\t * @param context the contextual information passed to the {@code mapRow}\n\t * callback method. The JDBC operation itself doesn't rely on this parameter,\n\t * but it can be useful for creating the objects of the result list.\n\t * @see #execute\n\t */\n\tprotected abstract RowMapper<T> newRowMapper(@Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context);\n\n}"
  },
  "org.springframework.jdbc.object.SqlQuery#execute()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to execute without parameters nor context.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "List<T>",
    "signature": "public List<T> execute()",
    "source_code": "\tpublic List<T> execute() throws DataAccessException {\n\t\treturn execute((Object[]) null, null);\n\t}"
  },
  "org.springframework.jdbc.object.SqlQuery#execute(Map<?,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to execute without parameters.\n\t * @param context the contextual information for object creation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "List<T>",
    "signature": "public List<T> execute(Map<?, ?> context)",
    "source_code": "\tpublic List<T> execute(Map<?, ?> context) throws DataAccessException {\n\t\treturn execute((Object[]) null, context);\n\t}"
  },
  "org.springframework.jdbc.object.SqlQuery#execute(p1)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to execute with a single String parameter.\n\t * @param p1 single String parameter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "p1"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "List<T>",
    "signature": "public List<T> execute(String p1)",
    "source_code": "\tpublic List<T> execute(String p1) throws DataAccessException {\n\t\treturn execute(p1, null);\n\t}"
  },
  "org.springframework.jdbc.object.SqlQuery#execute(p1,Map<?,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to execute with a single String parameter and context.\n\t * @param p1 single String parameter\n\t * @param context the contextual information for object creation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "p1",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "List<T>",
    "signature": "public List<T> execute(String p1, @Nullable Map<?, ?> context)",
    "source_code": "\tpublic List<T> execute(String p1, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\treturn execute(new Object[] {p1}, context);\n\t}"
  },
  "org.springframework.jdbc.object.SqlQuery#execute(p1,p2)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to execute with two int parameters.\n\t * @param p1 first int parameter\n\t * @param p2 second int parameter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "p1",
      "p2"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "List<T>",
    "signature": "public List<T> execute(int p1, int p2)",
    "source_code": "\tpublic List<T> execute(int p1, int p2) throws DataAccessException {\n\t\treturn execute(p1, p2, null);\n\t}"
  },
  "org.springframework.jdbc.object.SqlQuery#execute(p1,p2,Map<?,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to execute with two int parameters and context.\n\t * @param p1 first int parameter\n\t * @param p2 second int parameter\n\t * @param context the contextual information for object creation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "p1",
      "p2",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "List<T>",
    "signature": "public List<T> execute(int p1, int p2, @Nullable Map<?, ?> context)",
    "source_code": "\tpublic List<T> execute(int p1, int p2, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\treturn execute(new Object[] {p1, p2}, context);\n\t}"
  },
  "org.springframework.jdbc.object.SqlQuery#execute(params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to execute without context.\n\t * @param params parameters for the query. Primitive parameters must\n\t * be represented by their Object wrapper type. The ordering of parameters is\n\t * significant.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "params"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "List<T>",
    "signature": "public List<T> execute(Object... params)",
    "source_code": "\tpublic List<T> execute(Object... params) throws DataAccessException {\n\t\treturn execute(params, null);\n\t}"
  },
  "org.springframework.jdbc.object.SqlQuery#execute(params,Map<?,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Central execution method. All un-named parameter execution goes through this method.\n\t * @param params parameters, similar to JDO query parameters.\n\t * Primitive parameters must be represented by their Object wrapper type.\n\t * The ordering of parameters is significant.\n\t * @param context the contextual information passed to the {@code mapRow}\n\t * callback method. The JDBC operation itself doesn't rely on this parameter,\n\t * but it can be useful for creating the objects of the result list.\n\t * @return a List of objects, one per row of the ResultSet. Normally all these\n\t * will be of the same class, although it is possible to use different types.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "params",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "List<T>",
    "signature": "public List<T> execute(Object @Nullable [] params, @Nullable Map<?, ?> context)",
    "source_code": "\tpublic List<T> execute(Object @Nullable [] params, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\tvalidateParameters(params);\n\t\tRowMapper<T> rowMapper = newRowMapper(params, context);\n\t\treturn getJdbcTemplate().query(newPreparedStatementCreator(params), rowMapper);\n\t}"
  },
  "org.springframework.jdbc.object.SqlQuery#executeByNamedParam(Map<String,paramMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to execute without context.\n\t * @param paramMap parameters associated with the name specified while declaring\n\t * the SqlParameters. Primitive parameters must be represented by their Object wrapper\n\t * type. The ordering of parameters is not significant.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "List<T>",
    "signature": "public List<T> executeByNamedParam(Map<String, ? extends @Nullable Object> paramMap)",
    "source_code": "\tpublic List<T> executeByNamedParam(Map<String, ? extends @Nullable Object> paramMap) throws DataAccessException {\n\t\treturn executeByNamedParam(paramMap, null);\n\t}"
  },
  "org.springframework.jdbc.object.SqlQuery#executeByNamedParam(Map<String,paramMap,Map<?,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Central execution method. All named parameter execution goes through this method.\n\t * @param paramMap parameters associated with the name specified while declaring\n\t * the SqlParameters. Primitive parameters must be represented by their Object wrapper\n\t * type. The ordering of parameters is not significant since they are supplied in a\n\t * SqlParameterMap which is an implementation of the Map interface.\n\t * @param context the contextual information passed to the {@code mapRow}\n\t * callback method. The JDBC operation itself doesn't rely on this parameter,\n\t * but it can be useful for creating the objects of the result list.\n\t * @return a List of objects, one per row of the ResultSet. Normally all these\n\t * will be of the same class, although it is possible to use different types.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "paramMap",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "List<T>",
    "signature": "public List<T> executeByNamedParam(Map<String, ?> paramMap, @Nullable Map<?, ?> context)",
    "source_code": "\tpublic List<T> executeByNamedParam(Map<String, ?> paramMap, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\tvalidateNamedParameters(paramMap);\n\t\tParsedSql parsedSql = getParsedSql();\n\t\tMapSqlParameterSource paramSource = new MapSqlParameterSource(paramMap);\n\t\tString sqlToUse = NamedParameterUtils.substituteNamedParameters(parsedSql, paramSource);\n\t\t@Nullable Object[] params = NamedParameterUtils.buildValueArray(parsedSql, paramSource, getDeclaredParameters());\n\t\tRowMapper<T> rowMapper = newRowMapper(params, context);\n\t\treturn getJdbcTemplate().query(newPreparedStatementCreator(sqlToUse, params), rowMapper);\n\t}"
  },
  "org.springframework.jdbc.object.SqlQuery#findObject(p1)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to find a single object given a single String parameter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "p1"
    ],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "T",
    "signature": "public T findObject(String p1)",
    "source_code": "\tpublic @Nullable T findObject(String p1) throws DataAccessException {\n\t\treturn findObject(p1, null);\n\t}"
  },
  "org.springframework.jdbc.object.SqlQuery#findObject(p1,Map<?,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to find a single object given a single String parameter\n\t * and a context.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "p1",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "T",
    "signature": "public T findObject(String p1, @Nullable Map<?, ?> context)",
    "source_code": "\tpublic @Nullable T findObject(String p1, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\treturn findObject(new Object[] {p1}, context);\n\t}"
  },
  "org.springframework.jdbc.object.SqlQuery#findObject(p1,p2)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to find a single object given two int parameters.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "p1",
      "p2"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "T",
    "signature": "public T findObject(int p1, int p2)",
    "source_code": "\tpublic @Nullable T findObject(int p1, int p2) throws DataAccessException {\n\t\treturn findObject(p1, p2, null);\n\t}"
  },
  "org.springframework.jdbc.object.SqlQuery#findObject(p1,p2,Map<?,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to find a single object given two int parameters\n\t * and a context.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "p1",
      "p2",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 285
    },
    "return": "T",
    "signature": "public T findObject(int p1, int p2, @Nullable Map<?, ?> context)",
    "source_code": "\tpublic @Nullable T findObject(int p1, int p2, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\treturn findObject(new Object[] {p1, p2}, context);\n\t}"
  },
  "org.springframework.jdbc.object.SqlQuery#findObject(params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to find a single object without context.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "params"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "T",
    "signature": "public T findObject(Object... params)",
    "source_code": "\tpublic @Nullable T findObject(Object... params) throws DataAccessException {\n\t\treturn findObject(params, null);\n\t}"
  },
  "org.springframework.jdbc.object.SqlQuery#findObject(params,Map<?,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generic object finder method, used by all other {@code findObject} methods.\n\t * Object finder methods are like EJB entity bean finders, in that it is\n\t * considered an error if they return more than one result.\n\t * @return the result object, or {@code null} if not found. Subclasses may\n\t * choose to treat this as an error and throw an exception.\n\t * @see org.springframework.dao.support.DataAccessUtils#singleResult\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "params",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "T",
    "signature": "public T findObject(Object @Nullable [] params, @Nullable Map<?, ?> context)",
    "source_code": "\tpublic @Nullable T findObject(Object @Nullable [] params, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\tList<T> results = execute(params, context);\n\t\treturn DataAccessUtils.singleResult(results);\n\t}"
  },
  "org.springframework.jdbc.object.SqlQuery#findObjectByNamedParam(Map<String,paramMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to execute without context.\n\t * @param paramMap a Map of parameter name to parameter object,\n\t * matching named parameters specified in the SQL statement.\n\t * Ordering is not significant.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "T",
    "signature": "public T findObjectByNamedParam(Map<String, ?> paramMap)",
    "source_code": "\tpublic @Nullable T findObjectByNamedParam(Map<String, ?> paramMap) throws DataAccessException {\n\t\treturn findObjectByNamedParam(paramMap, null);\n\t}"
  },
  "org.springframework.jdbc.object.SqlQuery#findObjectByNamedParam(Map<String,paramMap,Map<?,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generic object finder method for named parameters.\n\t * @param paramMap a Map of parameter name to parameter object,\n\t * matching named parameters specified in the SQL statement.\n\t * Ordering is not significant.\n\t * @param context the contextual information passed to the {@code mapRow}\n\t * callback method. The JDBC operation itself doesn't rely on this parameter,\n\t * but it can be useful for creating the objects of the result list.\n\t * @return a List of objects, one per row of the ResultSet. Normally all these\n\t * will be of the same class, although it is possible to use different types.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "paramMap",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "T",
    "signature": "public T findObjectByNamedParam(Map<String, ?> paramMap, @Nullable Map<?, ?> context)",
    "source_code": "\tpublic @Nullable T findObjectByNamedParam(Map<String, ?> paramMap, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\tList<T> results = executeByNamedParam(paramMap, context);\n\t\treturn DataAccessUtils.singleResult(results);\n\t}"
  },
  "org.springframework.jdbc.object.SqlQuery#getRowsExpected()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the number of rows expected.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "int",
    "signature": "public int getRowsExpected()",
    "source_code": "\tpublic int getRowsExpected() {\n\t\treturn this.rowsExpected;\n\t}"
  },
  "org.springframework.jdbc.object.SqlQuery#newRowMapper(parameters,Map<?,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses must implement this method to extract an object per row, to be\n\t * returned by the {@code execute} method as an aggregated {@link List}.\n\t * @param parameters the parameters to the {@code execute()} method,\n\t * in case subclass is interested; may be {@code null} if there\n\t * were no parameters.\n\t * @param context the contextual information passed to the {@code mapRow}\n\t * callback method. The JDBC operation itself doesn't rely on this parameter,\n\t * but it can be useful for creating the objects of the result list.\n\t * @see #execute\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameters",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 364
    },
    "return": "RowMapper<T>",
    "signature": "protected RowMapper<T> newRowMapper(@Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context)",
    "source_code": "\tprotected abstract RowMapper<T> newRowMapper(@Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context);"
  },
  "org.springframework.jdbc.object.SqlQuery#setRowsExpected(rowsExpected)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the number of rows expected.\n\t * <p>This can be used to ensure efficient storage of results. The\n\t * default behavior is not to expect any specific number of rows.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rowsExpected"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void setRowsExpected(int rowsExpected)",
    "source_code": "\tpublic void setRowsExpected(int rowsExpected) {\n\t\tthis.rowsExpected = rowsExpected;\n\t}"
  },
  "org.springframework.jdbc.object.UpdatableSqlQuery": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Reusable RDBMS query in which concrete subclasses must implement\n * the abstract updateRow(ResultSet, int, context) method to update each\n * row of the JDBC ResultSet and optionally map contents into an object.\n *\n * <p>Subclasses can be constructed providing SQL, parameter types\n * and a DataSource. SQL will often vary between subclasses.\n *\n * @author Thomas Risberg\n * @param <T> the result type\n * @see org.springframework.jdbc.object.SqlQuery\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public class UpdatableSqlQuery",
    "source_code": "public abstract class UpdatableSqlQuery<T> extends SqlQuery<T> {\n\n\t/**\n\t * Constructor to allow use as a JavaBean.\n\t */\n\tpublic UpdatableSqlQuery() {\n\t\tsetUpdatableResults(true);\n\t}\n\n\t/**\n\t * Convenient constructor with DataSource and SQL string.\n\t * @param ds the DataSource to use to get connections\n\t * @param sql the SQL to run\n\t */\n\tpublic UpdatableSqlQuery(DataSource ds, String sql) {\n\t\tsuper(ds, sql);\n\t\tsetUpdatableResults(true);\n\t}\n\n\n\t/**\n\t * Implementation of the superclass template method. This invokes the subclass's\n\t * implementation of the {@code updateRow()} method.\n\t */\n\t@Override\n\tprotected RowMapper<T> newRowMapper(@Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context) {\n\t\treturn new RowMapperImpl(context);\n\t}\n\n\t/**\n\t * Subclasses must implement this method to update each row of the\n\t * ResultSet and optionally create object of the result type.\n\t * @param rs the ResultSet we're working through\n\t * @param rowNum row number (from 0) we're up to\n\t * @param context passed to the {@code execute()} method.\n\t * It can be {@code null} if no contextual information is need.  If you\n\t * need to pass in data for each row, you can pass in a HashMap with\n\t * the primary key of the row being the key for the HashMap.  That way\n\t * it is easy to locate the updates for each row\n\t * @return an object of the result type\n\t * @throws SQLException if there's an error updating data.\n\t * Subclasses can simply not catch SQLExceptions, relying on the\n\t * framework to clean up.\n\t */\n\tprotected abstract T updateRow(ResultSet rs, int rowNum, @Nullable Map<?, ?> context) throws SQLException;\n\n\n\t/**\n\t * Implementation of RowMapper that calls the enclosing\n\t * class's {@code updateRow()} method for each row.\n\t */\n\tprotected class RowMapperImpl implements RowMapper<T> {\n\n\t\tprivate final @Nullable Map<?, ?> context;\n\n\t\tpublic RowMapperImpl(@Nullable Map<?, ?> context) {\n\t\t\tthis.context = context;\n\t\t}\n\n\t\t@Override\n\t\tpublic T mapRow(ResultSet rs, int rowNum) throws SQLException {\n\t\t\tT result = updateRow(rs, rowNum, this.context);\n\t\t\trs.updateRow();\n\t\t\treturn result;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jdbc.object.UpdatableSqlQuery#mapRow(rs,rowNum)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "rowNum"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "T",
    "signature": "public T mapRow(ResultSet rs, int rowNum)",
    "source_code": "\t\tpublic T mapRow(ResultSet rs, int rowNum) throws SQLException {\n\t\t\tT result = updateRow(rs, rowNum, this.context);\n\t\t\trs.updateRow();\n\t\t\treturn result;\n\t\t}"
  },
  "org.springframework.jdbc.object.UpdatableSqlQuery#newRowMapper(parameters,Map<?,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Implementation of the superclass template method. This invokes the subclass's\n\t * implementation of the {@code updateRow()} method.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameters",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "RowMapper<T>",
    "signature": "protected RowMapper<T> newRowMapper(@Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context)",
    "source_code": "\tprotected RowMapper<T> newRowMapper(@Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context) {\n\t\treturn new RowMapperImpl(context);\n\t}"
  },
  "org.springframework.jdbc.object.UpdatableSqlQuery#updateRow(rs,rowNum,Map<?,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses must implement this method to update each row of the\n\t * ResultSet and optionally create object of the result type.\n\t * @param rs the ResultSet we're working through\n\t * @param rowNum row number (from 0) we're up to\n\t * @param context passed to the {@code execute()} method.\n\t * It can be {@code null} if no contextual information is need.  If you\n\t * need to pass in data for each row, you can pass in a HashMap with\n\t * the primary key of the row being the key for the HashMap.  That way\n\t * it is easy to locate the updates for each row\n\t * @return an object of the result type\n\t * @throws SQLException if there's an error updating data.\n\t * Subclasses can simply not catch SQLExceptions, relying on the\n\t * framework to clean up.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "rowNum",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "T",
    "signature": "protected T updateRow(ResultSet rs, int rowNum, @Nullable Map<?, ?> context)",
    "source_code": "\tprotected abstract T updateRow(ResultSet rs, int rowNum, @Nullable Map<?, ?> context) throws SQLException;"
  },
  "org.springframework.jdbc.object.logger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Logger available to subclasses. */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.jdbc.support.GeneratedKeyHolder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * The standard implementation of the {@link KeyHolder} interface, to be used for\n * holding auto-generated keys (as potentially returned by JDBC insert statements).\n *\n * <p>Create an instance of this class for each insert operation, and pass it\n * to the corresponding {@link org.springframework.jdbc.core.JdbcTemplate} or\n * {@link org.springframework.jdbc.object.SqlUpdate} methods.\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @author Slawomir Dymitrow\n * @since 1.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class GeneratedKeyHolder",
    "source_code": "public class GeneratedKeyHolder implements KeyHolder {\n\n\tprivate final List<Map<String, Object>> keyList;\n\n\n\t/**\n\t * Create a new GeneratedKeyHolder with a default list.\n\t */\n\tpublic GeneratedKeyHolder() {\n\t\tthis.keyList = new ArrayList<>(1);\n\t}\n\n\t/**\n\t * Create a new GeneratedKeyHolder with a given list.\n\t * @param keyList a list to hold maps of keys\n\t */\n\tpublic GeneratedKeyHolder(List<Map<String, Object>> keyList) {\n\t\tthis.keyList = keyList;\n\t}\n\n\n\t@Override\n\tpublic @Nullable Number getKey() throws InvalidDataAccessApiUsageException, DataRetrievalFailureException {\n\t\treturn getKeyAs(Number.class);\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T getKeyAs(Class<T> keyType) throws InvalidDataAccessApiUsageException, DataRetrievalFailureException {\n\t\tif (this.keyList.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this.keyList.size() > 1 || this.keyList.get(0).size() > 1) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"The getKey method should only be used when a single key is returned. \" +\n\t\t\t\t\t\"The current key entry contains multiple keys: \" + this.keyList);\n\t\t}\n\t\tIterator<Object> keyIter = this.keyList.get(0).values().iterator();\n\t\tif (keyIter.hasNext()) {\n\t\t\tObject key = keyIter.next();\n\t\t\tif (key == null || !(keyType.isAssignableFrom(key.getClass()))) {\n\t\t\t\tthrow new DataRetrievalFailureException(\n\t\t\t\t\t\t\"The generated key type is not supported. \" +\n\t\t\t\t\t\t\"Unable to cast [\" + (key != null ? key.getClass().getName() : null) +\n\t\t\t\t\t\t\"] to [\" + keyType.getName() + \"].\");\n\t\t\t}\n\t\t\treturn keyType.cast(key);\n\t\t}\n\t\telse {\n\t\t\tthrow new DataRetrievalFailureException(\"Unable to retrieve the generated key. \" +\n\t\t\t\t\t\"Check that the table has an identity column enabled.\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic @Nullable Map<String, Object> getKeys() throws InvalidDataAccessApiUsageException {\n\t\tif (this.keyList.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this.keyList.size() > 1) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"The getKeys method should only be used when keys for a single row are returned. \" +\n\t\t\t\t\t\"The current key list contains keys for multiple rows: \" + this.keyList);\n\t\t}\n\t\treturn this.keyList.get(0);\n\t}\n\n\t@Override\n\tpublic List<Map<String, Object>> getKeyList() {\n\t\treturn this.keyList;\n\t}\n\n}"
  },
  "org.springframework.jdbc.support.GeneratedKeyHolder#getKey()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "Number",
    "signature": "public Number getKey()",
    "source_code": "\tpublic @Nullable Number getKey() throws InvalidDataAccessApiUsageException, DataRetrievalFailureException {\n\t\treturn getKeyAs(Number.class);\n\t}"
  },
  "org.springframework.jdbc.support.GeneratedKeyHolder#getKeyAs(keyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "keyType"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "T",
    "signature": "public T getKeyAs(Class<T> keyType)",
    "source_code": "\tpublic <T> @Nullable T getKeyAs(Class<T> keyType) throws InvalidDataAccessApiUsageException, DataRetrievalFailureException {\n\t\tif (this.keyList.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this.keyList.size() > 1 || this.keyList.get(0).size() > 1) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"The getKey method should only be used when a single key is returned. \" +\n\t\t\t\t\t\"The current key entry contains multiple keys: \" + this.keyList);\n\t\t}\n\t\tIterator<Object> keyIter = this.keyList.get(0).values().iterator();\n\t\tif (keyIter.hasNext()) {\n\t\t\tObject key = keyIter.next();\n\t\t\tif (key == null || !(keyType.isAssignableFrom(key.getClass()))) {\n\t\t\t\tthrow new DataRetrievalFailureException(\n\t\t\t\t\t\t\"The generated key type is not supported. \" +\n\t\t\t\t\t\t\"Unable to cast [\" + (key != null ? key.getClass().getName() : null) +\n\t\t\t\t\t\t\"] to [\" + keyType.getName() + \"].\");\n\t\t\t}\n\t\t\treturn keyType.cast(key);\n\t\t}\n\t\telse {\n\t\t\tthrow new DataRetrievalFailureException(\"Unable to retrieve the generated key. \" +\n\t\t\t\t\t\"Check that the table has an identity column enabled.\");\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.GeneratedKeyHolder#getKeyList()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Object>>",
    "signature": "public Object>> getKeyList()",
    "source_code": "\tpublic List<Map<String, Object>> getKeyList() {\n\t\treturn this.keyList;\n\t}"
  },
  "org.springframework.jdbc.support.GeneratedKeyHolder#getKeys()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "Object>",
    "signature": "public Object> getKeys()",
    "source_code": "\tpublic @Nullable Map<String, Object> getKeys() throws InvalidDataAccessApiUsageException {\n\t\tif (this.keyList.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this.keyList.size() > 1) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"The getKeys method should only be used when keys for a single row are returned. \" +\n\t\t\t\t\t\"The current key list contains keys for multiple rows: \" + this.keyList);\n\t\t}\n\t\treturn this.keyList.get(0);\n\t}"
  },
  "org.springframework.jdbc.support.KeyHolder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Interface for retrieving keys, typically used for auto-generated keys\n * as potentially returned by JDBC insert statements.\n *\n * <p>Implementations of this interface can hold any number of keys.\n * In the general case, the keys are returned as a List containing one Map\n * for each row of keys.\n *\n * <p>Most applications only use one key per row and process only one row at a\n * time in an insert statement. In these cases, just call {@link #getKey() getKey}\n * or {@link #getKeyAs(Class) getKeyAs} to retrieve the key. The value returned\n * by {@code getKey} is a {@link Number}, which is the usual type for auto-generated\n * keys. For any other auto-generated key type, use {@code getKeyAs} instead.\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @author Slawomir Dymitrow\n * @since 1.1\n * @see org.springframework.jdbc.core.JdbcTemplate\n * @see org.springframework.jdbc.object.SqlUpdate\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public interface KeyHolder",
    "source_code": "public interface KeyHolder {\n\n\t/**\n\t * Retrieve the first item from the first map, assuming that there is just\n\t * one item and just one map, and that the item is a number.\n\t * This is the typical case: a single, numeric generated key.\n\t * <p>Keys are held in a List of Maps, where each item in the list represents\n\t * the keys for each row. If there are multiple columns, then the Map will have\n\t * multiple entries as well. If this method encounters multiple entries in\n\t * either the map or the list meaning that multiple keys were returned,\n\t * then an InvalidDataAccessApiUsageException is thrown.\n\t * @return the generated key as a number\n\t * @throws InvalidDataAccessApiUsageException if multiple keys are encountered\n\t * @see #getKeyAs(Class)\n\t */\n\t@Nullable Number getKey() throws InvalidDataAccessApiUsageException;\n\n\t/**\n\t * Retrieve the first item from the first map, assuming that there is just\n\t * one item and just one map, and that the item is an instance of specified type.\n\t * This is a common case: a single generated key of the specified type.\n\t * <p>Keys are held in a List of Maps, where each item in the list represents\n\t * the keys for each row. If there are multiple columns, then the Map will have\n\t * multiple entries as well. If this method encounters multiple entries in\n\t * either the map or the list meaning that multiple keys were returned,\n\t * then an InvalidDataAccessApiUsageException is thrown.\n\t * @param keyType the type of the auto-generated key\n\t * @return the generated key as an instance of specified type\n\t * @throws InvalidDataAccessApiUsageException if multiple keys are encountered\n\t * @since 5.3\n\t * @see #getKey()\n\t */\n\t<T> @Nullable T getKeyAs(Class<T> keyType) throws InvalidDataAccessApiUsageException;\n\n\t/**\n\t * Retrieve the first map of keys.\n\t * <p>If there are multiple entries in the list (meaning that multiple rows\n\t * had keys returned), then an InvalidDataAccessApiUsageException is thrown.\n\t * @return the Map of generated keys for a single row\n\t * @throws InvalidDataAccessApiUsageException if keys for multiple rows are encountered\n\t */\n\t@Nullable Map<String, Object> getKeys() throws InvalidDataAccessApiUsageException;\n\n\t/**\n\t * Return a reference to the List that contains the keys.\n\t * <p>Can be used for extracting keys for multiple rows (an unusual case),\n\t * and also for adding new maps of keys.\n\t * @return the List for the generated keys, with each entry representing\n\t * an individual row through a Map of column names and key values\n\t */\n\tList<Map<String, Object>> getKeyList();\n\n}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * JavaBean for holding JDBC error codes for a particular database.\n * Instances of this class are normally loaded through a bean factory.\n *\n * <p>Used by Spring's {@link SQLErrorCodeSQLExceptionTranslator}.\n * The file \"sql-error-codes.xml\" in this package contains default\n * {@code SQLErrorCodes} instances for various databases.\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @see SQLErrorCodesFactory\n * @see SQLErrorCodeSQLExceptionTranslator\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class SQLErrorCodes",
    "source_code": "public class SQLErrorCodes {\n\n\tprivate String @Nullable [] databaseProductNames;\n\n\tprivate boolean useSqlStateForTranslation = false;\n\n\tprivate String[] badSqlGrammarCodes = new String[0];\n\n\tprivate String[] invalidResultSetAccessCodes = new String[0];\n\n\tprivate String[] duplicateKeyCodes = new String[0];\n\n\tprivate String[] dataIntegrityViolationCodes = new String[0];\n\n\tprivate String[] permissionDeniedCodes = new String[0];\n\n\tprivate String[] dataAccessResourceFailureCodes = new String[0];\n\n\tprivate String[] transientDataAccessResourceCodes = new String[0];\n\n\tprivate String[] cannotAcquireLockCodes = new String[0];\n\n\tprivate String[] deadlockLoserCodes = new String[0];\n\n\tprivate String[] cannotSerializeTransactionCodes = new String[0];\n\n\tprivate CustomSQLErrorCodesTranslation @Nullable [] customTranslations;\n\n\tprivate @Nullable SQLExceptionTranslator customSqlExceptionTranslator;\n\n\n\t/**\n\t * Set this property if the database name contains spaces,\n\t * in which case we can not use the bean name for lookup.\n\t */\n\tpublic void setDatabaseProductName(@Nullable String databaseProductName) {\n\t\tthis.databaseProductNames = new String[] {databaseProductName};\n\t}\n\n\tpublic @Nullable String getDatabaseProductName() {\n\t\treturn (this.databaseProductNames != null && this.databaseProductNames.length > 0 ?\n\t\t\t\tthis.databaseProductNames[0] : null);\n\t}\n\n\t/**\n\t * Set this property to specify multiple database names that contains spaces,\n\t * in which case we can not use bean names for lookup.\n\t */\n\tpublic void setDatabaseProductNames(String @Nullable ... databaseProductNames) {\n\t\tthis.databaseProductNames = databaseProductNames;\n\t}\n\n\tpublic String @Nullable [] getDatabaseProductNames() {\n\t\treturn this.databaseProductNames;\n\t}\n\n\t/**\n\t * Set this property to true for databases that do not provide an error code\n\t * but that do provide SQL State (this includes PostgreSQL).\n\t */\n\tpublic void setUseSqlStateForTranslation(boolean useStateCodeForTranslation) {\n\t\tthis.useSqlStateForTranslation = useStateCodeForTranslation;\n\t}\n\n\tpublic boolean isUseSqlStateForTranslation() {\n\t\treturn this.useSqlStateForTranslation;\n\t}\n\n\tpublic void setBadSqlGrammarCodes(String... badSqlGrammarCodes) {\n\t\tthis.badSqlGrammarCodes = StringUtils.sortStringArray(badSqlGrammarCodes);\n\t}\n\n\tpublic String[] getBadSqlGrammarCodes() {\n\t\treturn this.badSqlGrammarCodes;\n\t}\n\n\tpublic void setInvalidResultSetAccessCodes(String... invalidResultSetAccessCodes) {\n\t\tthis.invalidResultSetAccessCodes = StringUtils.sortStringArray(invalidResultSetAccessCodes);\n\t}\n\n\tpublic String[] getInvalidResultSetAccessCodes() {\n\t\treturn this.invalidResultSetAccessCodes;\n\t}\n\n\tpublic String[] getDuplicateKeyCodes() {\n\t\treturn this.duplicateKeyCodes;\n\t}\n\n\tpublic void setDuplicateKeyCodes(String... duplicateKeyCodes) {\n\t\tthis.duplicateKeyCodes = duplicateKeyCodes;\n\t}\n\n\tpublic void setDataIntegrityViolationCodes(String... dataIntegrityViolationCodes) {\n\t\tthis.dataIntegrityViolationCodes = StringUtils.sortStringArray(dataIntegrityViolationCodes);\n\t}\n\n\tpublic String[] getDataIntegrityViolationCodes() {\n\t\treturn this.dataIntegrityViolationCodes;\n\t}\n\n\tpublic void setPermissionDeniedCodes(String... permissionDeniedCodes) {\n\t\tthis.permissionDeniedCodes = StringUtils.sortStringArray(permissionDeniedCodes);\n\t}\n\n\tpublic String[] getPermissionDeniedCodes() {\n\t\treturn this.permissionDeniedCodes;\n\t}\n\n\tpublic void setDataAccessResourceFailureCodes(String... dataAccessResourceFailureCodes) {\n\t\tthis.dataAccessResourceFailureCodes = StringUtils.sortStringArray(dataAccessResourceFailureCodes);\n\t}\n\n\tpublic String[] getDataAccessResourceFailureCodes() {\n\t\treturn this.dataAccessResourceFailureCodes;\n\t}\n\n\tpublic void setTransientDataAccessResourceCodes(String... transientDataAccessResourceCodes) {\n\t\tthis.transientDataAccessResourceCodes = StringUtils.sortStringArray(transientDataAccessResourceCodes);\n\t}\n\n\tpublic String[] getTransientDataAccessResourceCodes() {\n\t\treturn this.transientDataAccessResourceCodes;\n\t}\n\n\tpublic void setCannotAcquireLockCodes(String... cannotAcquireLockCodes) {\n\t\tthis.cannotAcquireLockCodes = StringUtils.sortStringArray(cannotAcquireLockCodes);\n\t}\n\n\tpublic String[] getCannotAcquireLockCodes() {\n\t\treturn this.cannotAcquireLockCodes;\n\t}\n\n\tpublic void setDeadlockLoserCodes(String... deadlockLoserCodes) {\n\t\tthis.deadlockLoserCodes = StringUtils.sortStringArray(deadlockLoserCodes);\n\t}\n\n\tpublic String[] getDeadlockLoserCodes() {\n\t\treturn this.deadlockLoserCodes;\n\t}\n\n\tpublic void setCannotSerializeTransactionCodes(String... cannotSerializeTransactionCodes) {\n\t\tthis.cannotSerializeTransactionCodes = StringUtils.sortStringArray(cannotSerializeTransactionCodes);\n\t}\n\n\tpublic String[] getCannotSerializeTransactionCodes() {\n\t\treturn this.cannotSerializeTransactionCodes;\n\t}\n\n\tpublic void setCustomTranslations(CustomSQLErrorCodesTranslation... customTranslations) {\n\t\tthis.customTranslations = customTranslations;\n\t}\n\n\tpublic CustomSQLErrorCodesTranslation @Nullable [] getCustomTranslations() {\n\t\treturn this.customTranslations;\n\t}\n\n\tpublic void setCustomSqlExceptionTranslatorClass(@Nullable Class<? extends SQLExceptionTranslator> customTranslatorClass) {\n\t\tif (customTranslatorClass != null) {\n\t\t\ttry {\n\t\t\t\tthis.customSqlExceptionTranslator =\n\t\t\t\t\t\tReflectionUtils.accessibleConstructor(customTranslatorClass).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalStateException(\"Unable to instantiate custom translator\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.customSqlExceptionTranslator = null;\n\t\t}\n\t}\n\n\tpublic void setCustomSqlExceptionTranslator(@Nullable SQLExceptionTranslator customSqlExceptionTranslator) {\n\t\tthis.customSqlExceptionTranslator = customSqlExceptionTranslator;\n\t}\n\n\tpublic @Nullable SQLExceptionTranslator getCustomSqlExceptionTranslator() {\n\t\treturn this.customSqlExceptionTranslator;\n\t}\n\n}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#getBadSqlGrammarCodes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "String[]",
    "signature": "public String[] getBadSqlGrammarCodes()",
    "source_code": "\tpublic String[] getBadSqlGrammarCodes() {\n\t\treturn this.badSqlGrammarCodes;\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#getCannotAcquireLockCodes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "String[]",
    "signature": "public String[] getCannotAcquireLockCodes()",
    "source_code": "\tpublic String[] getCannotAcquireLockCodes() {\n\t\treturn this.cannotAcquireLockCodes;\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#getCannotSerializeTransactionCodes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "String[]",
    "signature": "public String[] getCannotSerializeTransactionCodes()",
    "source_code": "\tpublic String[] getCannotSerializeTransactionCodes() {\n\t\treturn this.cannotSerializeTransactionCodes;\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#getCustomSqlExceptionTranslator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "SQLExceptionTranslator",
    "signature": "public SQLExceptionTranslator getCustomSqlExceptionTranslator()",
    "source_code": "\tpublic @Nullable SQLExceptionTranslator getCustomSqlExceptionTranslator() {\n\t\treturn this.customSqlExceptionTranslator;\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#getDataAccessResourceFailureCodes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "String[]",
    "signature": "public String[] getDataAccessResourceFailureCodes()",
    "source_code": "\tpublic String[] getDataAccessResourceFailureCodes() {\n\t\treturn this.dataAccessResourceFailureCodes;\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#getDataIntegrityViolationCodes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "String[]",
    "signature": "public String[] getDataIntegrityViolationCodes()",
    "source_code": "\tpublic String[] getDataIntegrityViolationCodes() {\n\t\treturn this.dataIntegrityViolationCodes;\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#getDatabaseProductName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "String",
    "signature": "public String getDatabaseProductName()",
    "source_code": "\tpublic @Nullable String getDatabaseProductName() {\n\t\treturn (this.databaseProductNames != null && this.databaseProductNames.length > 0 ?\n\t\t\t\tthis.databaseProductNames[0] : null);\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#getDeadlockLoserCodes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "String[]",
    "signature": "public String[] getDeadlockLoserCodes()",
    "source_code": "\tpublic String[] getDeadlockLoserCodes() {\n\t\treturn this.deadlockLoserCodes;\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#getDuplicateKeyCodes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "String[]",
    "signature": "public String[] getDuplicateKeyCodes()",
    "source_code": "\tpublic String[] getDuplicateKeyCodes() {\n\t\treturn this.duplicateKeyCodes;\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#getInvalidResultSetAccessCodes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "String[]",
    "signature": "public String[] getInvalidResultSetAccessCodes()",
    "source_code": "\tpublic String[] getInvalidResultSetAccessCodes() {\n\t\treturn this.invalidResultSetAccessCodes;\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#getPermissionDeniedCodes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "String[]",
    "signature": "public String[] getPermissionDeniedCodes()",
    "source_code": "\tpublic String[] getPermissionDeniedCodes() {\n\t\treturn this.permissionDeniedCodes;\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#getTransientDataAccessResourceCodes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "String[]",
    "signature": "public String[] getTransientDataAccessResourceCodes()",
    "source_code": "\tpublic String[] getTransientDataAccessResourceCodes() {\n\t\treturn this.transientDataAccessResourceCodes;\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#isUseSqlStateForTranslation()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "boolean",
    "signature": "public boolean isUseSqlStateForTranslation()",
    "source_code": "\tpublic boolean isUseSqlStateForTranslation() {\n\t\treturn this.useSqlStateForTranslation;\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#setBadSqlGrammarCodes(badSqlGrammarCodes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "badSqlGrammarCodes"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void setBadSqlGrammarCodes(String... badSqlGrammarCodes)",
    "source_code": "\tpublic void setBadSqlGrammarCodes(String... badSqlGrammarCodes) {\n\t\tthis.badSqlGrammarCodes = StringUtils.sortStringArray(badSqlGrammarCodes);\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#setCannotAcquireLockCodes(cannotAcquireLockCodes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cannotAcquireLockCodes"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void setCannotAcquireLockCodes(String... cannotAcquireLockCodes)",
    "source_code": "\tpublic void setCannotAcquireLockCodes(String... cannotAcquireLockCodes) {\n\t\tthis.cannotAcquireLockCodes = StringUtils.sortStringArray(cannotAcquireLockCodes);\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#setCannotSerializeTransactionCodes(cannotSerializeTransactionCodes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cannotSerializeTransactionCodes"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "void",
    "signature": "public void setCannotSerializeTransactionCodes(String... cannotSerializeTransactionCodes)",
    "source_code": "\tpublic void setCannotSerializeTransactionCodes(String... cannotSerializeTransactionCodes) {\n\t\tthis.cannotSerializeTransactionCodes = StringUtils.sortStringArray(cannotSerializeTransactionCodes);\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#setCustomSqlExceptionTranslator(customSqlExceptionTranslator)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "customSqlExceptionTranslator"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "void",
    "signature": "public void setCustomSqlExceptionTranslator(@Nullable SQLExceptionTranslator customSqlExceptionTranslator)",
    "source_code": "\tpublic void setCustomSqlExceptionTranslator(@Nullable SQLExceptionTranslator customSqlExceptionTranslator) {\n\t\tthis.customSqlExceptionTranslator = customSqlExceptionTranslator;\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#setCustomSqlExceptionTranslatorClass(customTranslatorClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "customTranslatorClass"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "void",
    "signature": "public void setCustomSqlExceptionTranslatorClass(@Nullable Class<? extends SQLExceptionTranslator> customTranslatorClass)",
    "source_code": "\tpublic void setCustomSqlExceptionTranslatorClass(@Nullable Class<? extends SQLExceptionTranslator> customTranslatorClass) {\n\t\tif (customTranslatorClass != null) {\n\t\t\ttry {\n\t\t\t\tthis.customSqlExceptionTranslator =\n\t\t\t\t\t\tReflectionUtils.accessibleConstructor(customTranslatorClass).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalStateException(\"Unable to instantiate custom translator\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.customSqlExceptionTranslator = null;\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#setCustomTranslations(customTranslations)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "customTranslations"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "public void setCustomTranslations(CustomSQLErrorCodesTranslation... customTranslations)",
    "source_code": "\tpublic void setCustomTranslations(CustomSQLErrorCodesTranslation... customTranslations) {\n\t\tthis.customTranslations = customTranslations;\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#setDataAccessResourceFailureCodes(dataAccessResourceFailureCodes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataAccessResourceFailureCodes"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "public void setDataAccessResourceFailureCodes(String... dataAccessResourceFailureCodes)",
    "source_code": "\tpublic void setDataAccessResourceFailureCodes(String... dataAccessResourceFailureCodes) {\n\t\tthis.dataAccessResourceFailureCodes = StringUtils.sortStringArray(dataAccessResourceFailureCodes);\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#setDataIntegrityViolationCodes(dataIntegrityViolationCodes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataIntegrityViolationCodes"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "void",
    "signature": "public void setDataIntegrityViolationCodes(String... dataIntegrityViolationCodes)",
    "source_code": "\tpublic void setDataIntegrityViolationCodes(String... dataIntegrityViolationCodes) {\n\t\tthis.dataIntegrityViolationCodes = StringUtils.sortStringArray(dataIntegrityViolationCodes);\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#setDatabaseProductName(databaseProductName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set this property if the database name contains spaces,\n\t * in which case we can not use the bean name for lookup.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "databaseProductName"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "public void setDatabaseProductName(@Nullable String databaseProductName)",
    "source_code": "\tpublic void setDatabaseProductName(@Nullable String databaseProductName) {\n\t\tthis.databaseProductNames = new String[] {databaseProductName};\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#setDatabaseProductNames(databaseProductNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set this property to specify multiple database names that contains spaces,\n\t * in which case we can not use bean names for lookup.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "databaseProductNames"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "void",
    "signature": "public void setDatabaseProductNames(String @Nullable ... databaseProductNames)",
    "source_code": "\tpublic void setDatabaseProductNames(String @Nullable ... databaseProductNames) {\n\t\tthis.databaseProductNames = databaseProductNames;\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#setDeadlockLoserCodes(deadlockLoserCodes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "deadlockLoserCodes"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "void",
    "signature": "public void setDeadlockLoserCodes(String... deadlockLoserCodes)",
    "source_code": "\tpublic void setDeadlockLoserCodes(String... deadlockLoserCodes) {\n\t\tthis.deadlockLoserCodes = StringUtils.sortStringArray(deadlockLoserCodes);\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#setDuplicateKeyCodes(duplicateKeyCodes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "duplicateKeyCodes"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void setDuplicateKeyCodes(String... duplicateKeyCodes)",
    "source_code": "\tpublic void setDuplicateKeyCodes(String... duplicateKeyCodes) {\n\t\tthis.duplicateKeyCodes = duplicateKeyCodes;\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#setInvalidResultSetAccessCodes(invalidResultSetAccessCodes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invalidResultSetAccessCodes"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void setInvalidResultSetAccessCodes(String... invalidResultSetAccessCodes)",
    "source_code": "\tpublic void setInvalidResultSetAccessCodes(String... invalidResultSetAccessCodes) {\n\t\tthis.invalidResultSetAccessCodes = StringUtils.sortStringArray(invalidResultSetAccessCodes);\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#setPermissionDeniedCodes(permissionDeniedCodes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "permissionDeniedCodes"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "void",
    "signature": "public void setPermissionDeniedCodes(String... permissionDeniedCodes)",
    "source_code": "\tpublic void setPermissionDeniedCodes(String... permissionDeniedCodes) {\n\t\tthis.permissionDeniedCodes = StringUtils.sortStringArray(permissionDeniedCodes);\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#setTransientDataAccessResourceCodes(transientDataAccessResourceCodes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transientDataAccessResourceCodes"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void setTransientDataAccessResourceCodes(String... transientDataAccessResourceCodes)",
    "source_code": "\tpublic void setTransientDataAccessResourceCodes(String... transientDataAccessResourceCodes) {\n\t\tthis.transientDataAccessResourceCodes = StringUtils.sortStringArray(transientDataAccessResourceCodes);\n\t}"
  },
  "org.springframework.jdbc.support.SQLErrorCodes#setUseSqlStateForTranslation(useStateCodeForTranslation)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set this property to true for databases that do not provide an error code\n\t * but that do provide SQL State (this includes PostgreSQL).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "useStateCodeForTranslation"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "public void setUseSqlStateForTranslation(boolean useStateCodeForTranslation)",
    "source_code": "\tpublic void setUseSqlStateForTranslation(boolean useStateCodeForTranslation) {\n\t\tthis.useSqlStateForTranslation = useStateCodeForTranslation;\n\t}"
  },
  "org.springframework.jdbc.support.incrementer.AbstractIdentityColumnMaxValueIncrementer": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for {@link DataFieldMaxValueIncrementer} implementations\n * which are based on identity columns in a sequence-like table.\n *\n * @author Juergen Hoeller\n * @author Thomas Risberg\n * @since 4.1.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class AbstractIdentityColumnMaxValueIncrementer",
    "source_code": "public abstract class AbstractIdentityColumnMaxValueIncrementer extends AbstractColumnMaxValueIncrementer {\n\n\tprivate boolean deleteSpecificValues = false;\n\n\t/** The current cache of values. */\n\tprivate long @Nullable [] valueCache;\n\n\t/** The next id to serve from the value cache. */\n\tprivate int nextValueIndex = -1;\n\n\n\t/**\n\t * Default constructor for bean property style usage.\n\t * @see #setDataSource\n\t * @see #setIncrementerName\n\t * @see #setColumnName\n\t */\n\tpublic AbstractIdentityColumnMaxValueIncrementer() {\n\t}\n\n\tpublic AbstractIdentityColumnMaxValueIncrementer(DataSource dataSource, String incrementerName, String columnName) {\n\t\tsuper(dataSource, incrementerName, columnName);\n\t}\n\n\n\t/**\n\t * Specify whether to delete the entire range below the current maximum key value\n\t * ({@code false} - the default), or the specifically generated values ({@code true}).\n\t * The former mode will use a where range clause whereas the latter will use an in\n\t * clause starting with the lowest value minus 1, just preserving the maximum value.\n\t */\n\tpublic void setDeleteSpecificValues(boolean deleteSpecificValues) {\n\t\tthis.deleteSpecificValues = deleteSpecificValues;\n\t}\n\n\t/**\n\t * Return whether to delete the entire range below the current maximum key value\n\t * ({@code false} - the default), or the specifically generated values ({@code true}).\n\t */\n\tpublic boolean isDeleteSpecificValues() {\n\t\treturn this.deleteSpecificValues;\n\t}\n\n\n\t@Override\n\tprotected synchronized long getNextKey() throws DataAccessException {\n\t\tif (this.nextValueIndex < 0 || this.nextValueIndex >= getCacheSize()) {\n\t\t\t/*\n\t\t\t* Need to use straight JDBC code because we need to make sure that the insert and select\n\t\t\t* are performed on the same connection (otherwise we can't be sure that @@identity\n\t\t\t* returns the correct value)\n\t\t\t*/\n\t\t\tConnection con = DataSourceUtils.getConnection(getDataSource());\n\t\t\tStatement stmt = null;\n\t\t\ttry {\n\t\t\t\tstmt = con.createStatement();\n\t\t\t\tDataSourceUtils.applyTransactionTimeout(stmt, getDataSource());\n\t\t\t\tthis.valueCache = new long[getCacheSize()];\n\t\t\t\tthis.nextValueIndex = 0;\n\t\t\t\tfor (int i = 0; i < getCacheSize(); i++) {\n\t\t\t\t\tstmt.executeUpdate(getIncrementStatement());\n\t\t\t\t\tResultSet rs = stmt.executeQuery(getIdentityStatement());\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!rs.next()) {\n\t\t\t\t\t\t\tthrow new DataAccessResourceFailureException(\"Identity statement failed after inserting\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.valueCache[i] = rs.getLong(1);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstmt.executeUpdate(getDeleteStatement(this.valueCache));\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\tthrow new DataAccessResourceFailureException(\"Could not increment identity\", ex);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJdbcUtils.closeStatement(stmt);\n\t\t\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t\t\t}\n\t\t}\n\t\tAssert.state(this.valueCache != null, \"The cache of values can't be null\");\n\t\treturn this.valueCache[this.nextValueIndex++];\n\t}\n\n\n\t/**\n\t * Statement to use to increment the \"sequence\" value.\n\t * @return the SQL statement to use\n\t */\n\tprotected abstract String getIncrementStatement();\n\n\t/**\n\t * Statement to use to obtain the current identity value.\n\t * @return the SQL statement to use\n\t */\n\tprotected abstract String getIdentityStatement();\n\n\t/**\n\t * Statement to use to clean up \"sequence\" values.\n\t * <p>The default implementation either deletes the entire range below\n\t * the current maximum value, or the specifically generated values\n\t * (starting with the lowest minus 1, just preserving the maximum value)\n\t * - according to the {@link #isDeleteSpecificValues()} setting.\n\t * @param values the currently generated key values\n\t * (the number of values corresponds to {@link #getCacheSize()})\n\t * @return the SQL statement to use\n\t */\n\tprotected String getDeleteStatement(long[] values) {\n\t\tStringBuilder sb = new StringBuilder(64);\n\t\tsb.append(\"delete from \").append(getIncrementerName()).append(\" where \").append(getColumnName());\n\t\tif (isDeleteSpecificValues()) {\n\t\t\tsb.append(\" in (\").append(values[0] - 1);\n\t\t\tfor (int i = 0; i < values.length - 1; i++) {\n\t\t\t\tsb.append(\", \").append(values[i]);\n\t\t\t}\n\t\t\tsb.append(')');\n\t\t}\n\t\telse {\n\t\t\tlong maxValue = values[values.length - 1];\n\t\t\tsb.append(\" < \").append(maxValue);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n}"
  },
  "org.springframework.jdbc.support.incrementer.AbstractIdentityColumnMaxValueIncrementer#getDeleteStatement(values)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Statement to use to clean up \"sequence\" values.\n\t * <p>The default implementation either deletes the entire range below\n\t * the current maximum value, or the specifically generated values\n\t * (starting with the lowest minus 1, just preserving the maximum value)\n\t * - according to the {@link #isDeleteSpecificValues()} setting.\n\t * @param values the currently generated key values\n\t * (the number of values corresponds to {@link #getCacheSize()})\n\t * @return the SQL statement to use\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "values"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "String",
    "signature": "protected String getDeleteStatement(long[] values)",
    "source_code": "\tprotected String getDeleteStatement(long[] values) {\n\t\tStringBuilder sb = new StringBuilder(64);\n\t\tsb.append(\"delete from \").append(getIncrementerName()).append(\" where \").append(getColumnName());\n\t\tif (isDeleteSpecificValues()) {\n\t\t\tsb.append(\" in (\").append(values[0] - 1);\n\t\t\tfor (int i = 0; i < values.length - 1; i++) {\n\t\t\t\tsb.append(\", \").append(values[i]);\n\t\t\t}\n\t\t\tsb.append(')');\n\t\t}\n\t\telse {\n\t\t\tlong maxValue = values[values.length - 1];\n\t\t\tsb.append(\" < \").append(maxValue);\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.jdbc.support.incrementer.AbstractIdentityColumnMaxValueIncrementer#getIdentityStatement()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Statement to use to obtain the current identity value.\n\t * @return the SQL statement to use\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "String",
    "signature": "protected String getIdentityStatement()",
    "source_code": "\tprotected abstract String getIdentityStatement();"
  },
  "org.springframework.jdbc.support.incrementer.AbstractIdentityColumnMaxValueIncrementer#getIncrementStatement()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Statement to use to increment the \"sequence\" value.\n\t * @return the SQL statement to use\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "String",
    "signature": "protected String getIncrementStatement()",
    "source_code": "\tprotected abstract String getIncrementStatement();"
  },
  "org.springframework.jdbc.support.incrementer.AbstractIdentityColumnMaxValueIncrementer#getNextKey()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "long",
    "signature": "protected long getNextKey()",
    "source_code": "\tprotected synchronized long getNextKey() throws DataAccessException {\n\t\tif (this.nextValueIndex < 0 || this.nextValueIndex >= getCacheSize()) {\n\t\t\t/*\n\t\t\t* Need to use straight JDBC code because we need to make sure that the insert and select\n\t\t\t* are performed on the same connection (otherwise we can't be sure that @@identity\n\t\t\t* returns the correct value)\n\t\t\t*/\n\t\t\tConnection con = DataSourceUtils.getConnection(getDataSource());\n\t\t\tStatement stmt = null;\n\t\t\ttry {\n\t\t\t\tstmt = con.createStatement();\n\t\t\t\tDataSourceUtils.applyTransactionTimeout(stmt, getDataSource());\n\t\t\t\tthis.valueCache = new long[getCacheSize()];\n\t\t\t\tthis.nextValueIndex = 0;\n\t\t\t\tfor (int i = 0; i < getCacheSize(); i++) {\n\t\t\t\t\tstmt.executeUpdate(getIncrementStatement());\n\t\t\t\t\tResultSet rs = stmt.executeQuery(getIdentityStatement());\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!rs.next()) {\n\t\t\t\t\t\t\tthrow new DataAccessResourceFailureException(\"Identity statement failed after inserting\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.valueCache[i] = rs.getLong(1);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstmt.executeUpdate(getDeleteStatement(this.valueCache));\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\tthrow new DataAccessResourceFailureException(\"Could not increment identity\", ex);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJdbcUtils.closeStatement(stmt);\n\t\t\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t\t\t}\n\t\t}\n\t\tAssert.state(this.valueCache != null, \"The cache of values can't be null\");\n\t\treturn this.valueCache[this.nextValueIndex++];\n\t}"
  },
  "org.springframework.jdbc.support.incrementer.AbstractIdentityColumnMaxValueIncrementer#isDeleteSpecificValues()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to delete the entire range below the current maximum key value\n\t * ({@code false} - the default), or the specifically generated values ({@code true}).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "boolean",
    "signature": "public boolean isDeleteSpecificValues()",
    "source_code": "\tpublic boolean isDeleteSpecificValues() {\n\t\treturn this.deleteSpecificValues;\n\t}"
  },
  "org.springframework.jdbc.support.incrementer.AbstractIdentityColumnMaxValueIncrementer#setDeleteSpecificValues(deleteSpecificValues)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to delete the entire range below the current maximum key value\n\t * ({@code false} - the default), or the specifically generated values ({@code true}).\n\t * The former mode will use a where range clause whereas the latter will use an in\n\t * clause starting with the lowest value minus 1, just preserving the maximum value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "deleteSpecificValues"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "public void setDeleteSpecificValues(boolean deleteSpecificValues)",
    "source_code": "\tpublic void setDeleteSpecificValues(boolean deleteSpecificValues) {\n\t\tthis.deleteSpecificValues = deleteSpecificValues;\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#free()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void free()",
    "source_code": "\tpublic void free() throws SQLException {\n\t\t// no-op\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#getBinaryStream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "InputStream",
    "signature": "public InputStream getBinaryStream()",
    "source_code": "\tpublic InputStream getBinaryStream() throws SQLException {\n\t\tif (this.content != null) {\n\t\t\treturn new ByteArrayInputStream(this.content);\n\t\t}\n\t\telse {\n\t\t\treturn (this.binaryStream != null ? this.binaryStream : InputStream.nullInputStream());\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#getBinaryStream(pos,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "InputStream",
    "signature": "public InputStream getBinaryStream(long pos, long length)",
    "source_code": "\tpublic InputStream getBinaryStream(long pos, long length) throws SQLException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#getBytes(pos,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "byte[]",
    "signature": "public byte[] getBytes(long pos, int length)",
    "source_code": "\tpublic byte[] getBytes(long pos, int length) throws SQLException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#length()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "long",
    "signature": "public long length()",
    "source_code": "\tpublic long length() throws SQLException {\n\t\treturn this.contentLength;\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#position(pattern,start)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pattern",
      "start"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "long",
    "signature": "public long position(Blob pattern, long start)",
    "source_code": "\tpublic long position(Blob pattern, long start) throws SQLException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#setBinaryStream(pos)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "OutputStream",
    "signature": "public OutputStream setBinaryStream(long pos)",
    "source_code": "\tpublic OutputStream setBinaryStream(long pos) throws SQLException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#setBytes(pos,bytes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "bytes"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "int",
    "signature": "public int setBytes(long pos, byte[] bytes)",
    "source_code": "\tpublic int setBytes(long pos, byte[] bytes) throws SQLException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#setBytes(pos,bytes,offset,len)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "bytes",
      "offset",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "int",
    "signature": "public int setBytes(long pos, byte[] bytes, int offset, int len)",
    "source_code": "\tpublic int setBytes(long pos, byte[] bytes, int offset, int len) throws SQLException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#truncate(len)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "len"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void truncate(long len)",
    "source_code": "\tpublic void truncate(long len) throws SQLException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.jdbc.support.lob.AbstractLobHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for {@link LobHandler} implementations.\n *\n * <p>Implements all accessor methods for column names through a column lookup\n * and delegating to the corresponding accessor that takes a column index.\n *\n * @author Juergen Hoeller\n * @since 1.2\n * @see java.sql.ResultSet#findColumn\n * @deprecated as of 6.2, in favor of {@link org.springframework.jdbc.core.support.SqlBinaryValue}\n * and {@link org.springframework.jdbc.core.support.SqlCharacterValue}\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class AbstractLobHandler",
    "source_code": "public abstract class AbstractLobHandler implements LobHandler {\n\n\t@Override\n\tpublic byte @Nullable [] getBlobAsBytes(ResultSet rs, String columnName) throws SQLException {\n\t\treturn getBlobAsBytes(rs, rs.findColumn(columnName));\n\t}\n\n\t@Override\n\tpublic @Nullable InputStream getBlobAsBinaryStream(ResultSet rs, String columnName) throws SQLException {\n\t\treturn getBlobAsBinaryStream(rs, rs.findColumn(columnName));\n\t}\n\n\t@Override\n\tpublic @Nullable String getClobAsString(ResultSet rs, String columnName) throws SQLException {\n\t\treturn getClobAsString(rs, rs.findColumn(columnName));\n\t}\n\n\t@Override\n\tpublic @Nullable InputStream getClobAsAsciiStream(ResultSet rs, String columnName) throws SQLException {\n\t\treturn getClobAsAsciiStream(rs, rs.findColumn(columnName));\n\t}\n\n\t@Override\n\tpublic Reader getClobAsCharacterStream(ResultSet rs, String columnName) throws SQLException {\n\t\treturn getClobAsCharacterStream(rs, rs.findColumn(columnName));\n\t}\n\n}"
  },
  "org.springframework.jdbc.support.lob.AbstractLobHandler#getBlobAsBinaryStream(rs,columnName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "columnName"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "InputStream",
    "signature": "public InputStream getBlobAsBinaryStream(ResultSet rs, String columnName)",
    "source_code": "\tpublic @Nullable InputStream getBlobAsBinaryStream(ResultSet rs, String columnName) throws SQLException {\n\t\treturn getBlobAsBinaryStream(rs, rs.findColumn(columnName));\n\t}"
  },
  "org.springframework.jdbc.support.lob.AbstractLobHandler#getClobAsAsciiStream(rs,columnName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "columnName"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "InputStream",
    "signature": "public InputStream getClobAsAsciiStream(ResultSet rs, String columnName)",
    "source_code": "\tpublic @Nullable InputStream getClobAsAsciiStream(ResultSet rs, String columnName) throws SQLException {\n\t\treturn getClobAsAsciiStream(rs, rs.findColumn(columnName));\n\t}"
  },
  "org.springframework.jdbc.support.lob.AbstractLobHandler#getClobAsCharacterStream(rs,columnName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "columnName"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "Reader",
    "signature": "public Reader getClobAsCharacterStream(ResultSet rs, String columnName)",
    "source_code": "\tpublic Reader getClobAsCharacterStream(ResultSet rs, String columnName) throws SQLException {\n\t\treturn getClobAsCharacterStream(rs, rs.findColumn(columnName));\n\t}"
  },
  "org.springframework.jdbc.support.lob.AbstractLobHandler#getClobAsString(rs,columnName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "columnName"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "String",
    "signature": "public String getClobAsString(ResultSet rs, String columnName)",
    "source_code": "\tpublic @Nullable String getClobAsString(ResultSet rs, String columnName) throws SQLException {\n\t\treturn getClobAsString(rs, rs.findColumn(columnName));\n\t}"
  },
  "org.springframework.jdbc.support.lob.DefaultLobCreator": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Default LobCreator implementation as an inner class.\n\t * Can be subclassed in DefaultLobHandler extensions.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "signature": "protected class DefaultLobCreator",
    "source_code": "\tprotected class DefaultLobCreator implements LobCreator {\n\n\t\t@Override\n\t\tpublic void setBlobAsBytes(PreparedStatement ps, int paramIndex, byte @Nullable [] content)\n\t\t\t\tthrows SQLException {\n\n\t\t\tif (streamAsLob) {\n\t\t\t\tif (content != null) {\n\t\t\t\t\tps.setBlob(paramIndex, new ByteArrayInputStream(content), content.length);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setBlob(paramIndex, (Blob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (wrapAsLob) {\n\t\t\t\tif (content != null) {\n\t\t\t\t\tps.setBlob(paramIndex, new PassThroughBlob(content));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setBlob(paramIndex, (Blob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tps.setBytes(paramIndex, content);\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(content != null ? \"Set bytes for BLOB with length \" + content.length :\n\t\t\t\t\t\t\"Set BLOB to null\");\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void setBlobAsBinaryStream(\n\t\t\t\tPreparedStatement ps, int paramIndex, @Nullable InputStream binaryStream, int contentLength)\n\t\t\t\tthrows SQLException {\n\n\t\t\tif (streamAsLob) {\n\t\t\t\tif (binaryStream != null) {\n\t\t\t\t\tif (contentLength >= 0) {\n\t\t\t\t\t\tps.setBlob(paramIndex, binaryStream, contentLength);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tps.setBlob(paramIndex, binaryStream);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setBlob(paramIndex, (Blob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (wrapAsLob) {\n\t\t\t\tif (binaryStream != null) {\n\t\t\t\t\tps.setBlob(paramIndex, new PassThroughBlob(binaryStream, contentLength));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setBlob(paramIndex, (Blob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (contentLength >= 0) {\n\t\t\t\tps.setBinaryStream(paramIndex, binaryStream, contentLength);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tps.setBinaryStream(paramIndex, binaryStream);\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(binaryStream != null ? \"Set binary stream for BLOB with length \" + contentLength :\n\t\t\t\t\t\t\"Set BLOB to null\");\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void setClobAsString(PreparedStatement ps, int paramIndex, @Nullable String content)\n\t\t\t\tthrows SQLException {\n\n\t\t\tif (streamAsLob) {\n\t\t\t\tif (content != null) {\n\t\t\t\t\tps.setClob(paramIndex, new StringReader(content), content.length());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setClob(paramIndex, (Clob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (wrapAsLob) {\n\t\t\t\tif (content != null) {\n\t\t\t\t\tps.setClob(paramIndex, new PassThroughClob(content));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setClob(paramIndex, (Clob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tps.setString(paramIndex, content);\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(content != null ? \"Set string for CLOB with length \" + content.length() :\n\t\t\t\t\t\t\"Set CLOB to null\");\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void setClobAsAsciiStream(\n\t\t\t\tPreparedStatement ps, int paramIndex, @Nullable InputStream asciiStream, int contentLength)\n\t\t\t\tthrows SQLException {\n\n\t\t\tif (streamAsLob) {\n\t\t\t\tif (asciiStream != null) {\n\t\t\t\t\tReader reader = new InputStreamReader(asciiStream, StandardCharsets.US_ASCII);\n\t\t\t\t\tif (contentLength >= 0) {\n\t\t\t\t\t\tps.setClob(paramIndex, reader, contentLength);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tps.setClob(paramIndex, reader);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setClob(paramIndex, (Clob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (wrapAsLob) {\n\t\t\t\tif (asciiStream != null) {\n\t\t\t\t\tps.setClob(paramIndex, new PassThroughClob(asciiStream, contentLength));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setClob(paramIndex, (Clob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (contentLength >= 0) {\n\t\t\t\tps.setAsciiStream(paramIndex, asciiStream, contentLength);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tps.setAsciiStream(paramIndex, asciiStream);\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(asciiStream != null ? \"Set ASCII stream for CLOB with length \" + contentLength :\n\t\t\t\t\t\t\"Set CLOB to null\");\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void setClobAsCharacterStream(\n\t\t\t\tPreparedStatement ps, int paramIndex, @Nullable Reader characterStream, int contentLength)\n\t\t\t\tthrows SQLException {\n\n\t\t\tif (streamAsLob) {\n\t\t\t\tif (characterStream != null) {\n\t\t\t\t\tif (contentLength >= 0) {\n\t\t\t\t\t\tps.setClob(paramIndex, characterStream, contentLength);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tps.setClob(paramIndex, characterStream);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setClob(paramIndex, (Clob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (wrapAsLob) {\n\t\t\t\tif (characterStream != null) {\n\t\t\t\t\tps.setClob(paramIndex, new PassThroughClob(characterStream, contentLength));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setClob(paramIndex, (Clob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (contentLength >= 0) {\n\t\t\t\tps.setCharacterStream(paramIndex, characterStream, contentLength);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tps.setCharacterStream(paramIndex, characterStream);\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(characterStream != null ? \"Set character stream for CLOB with length \" + contentLength :\n\t\t\t\t\t\t\"Set CLOB to null\");\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void close() {\n\t\t\t// nothing to do when not creating temporary LOBs\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.lob.DefaultLobHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Default implementation of the {@link LobHandler} interface.\n * Invokes the direct accessor methods that {@code java.sql.ResultSet}\n * and {@code java.sql.PreparedStatement} offer.\n *\n * <p>By default, incoming streams are going to be passed to the appropriate\n * {@code setBinary/Ascii/CharacterStream} method on the JDBC driver's\n * {@link PreparedStatement}. If the specified content length is negative,\n * this handler will use the JDBC 4.0 variants of the set-stream methods\n * without a length parameter; otherwise, it will pass the specified length\n * on to the driver.\n *\n * <p>This LobHandler should work for any JDBC driver that is JDBC compliant\n * in terms of the spec's suggestions regarding simple BLOB and CLOB handling.\n * This does not apply to Oracle 9i's drivers at all; as of Oracle 10g,\n * it does work but may still come with LOB size limitations. Consider using\n * recent Oracle drivers even when working against an older database server.\n * See the {@link LobHandler} javadoc for the full set of recommendations.\n *\n * <p>Some JDBC drivers require values with a BLOB/CLOB target column to be\n * explicitly set through the JDBC {@code setBlob} / {@code setClob} API:\n * for example, PostgreSQL's driver. Switch the {@link #setWrapAsLob \"wrapAsLob\"}\n * property to \"true\" when operating against such a driver.\n *\n * <p>On JDBC 4.0, this LobHandler also supports streaming the BLOB/CLOB content\n * via the {@code setBlob} / {@code setClob} variants that take a stream\n * argument directly. Consider switching the {@link #setStreamAsLob \"streamAsLob\"}\n * property to \"true\" when operating against a fully compliant JDBC 4.0 driver.\n *\n * <p>Finally, this LobHandler also supports the creation of temporary BLOB/CLOB\n * objects. Consider switching the {@link #setCreateTemporaryLob \"createTemporaryLob\"}\n * property to \"true\" when \"streamAsLob\" happens to run into LOB size limitations.\n *\n * <p>See the {@link LobHandler} interface javadoc for a summary of recommendations.\n *\n * @author Juergen Hoeller\n * @since 04.12.2003\n * @see java.sql.ResultSet#getBytes\n * @see java.sql.ResultSet#getBinaryStream\n * @see java.sql.ResultSet#getString\n * @see java.sql.ResultSet#getAsciiStream\n * @see java.sql.ResultSet#getCharacterStream\n * @see java.sql.PreparedStatement#setBytes\n * @see java.sql.PreparedStatement#setBinaryStream\n * @see java.sql.PreparedStatement#setString\n * @see java.sql.PreparedStatement#setAsciiStream\n * @see java.sql.PreparedStatement#setCharacterStream\n * @deprecated as of 6.2, in favor of {@link org.springframework.jdbc.core.support.SqlBinaryValue}\n * and {@link org.springframework.jdbc.core.support.SqlCharacterValue}\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "signature": "public class DefaultLobHandler",
    "source_code": "public class DefaultLobHandler extends AbstractLobHandler {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate boolean wrapAsLob = false;\n\n\tprivate boolean streamAsLob = false;\n\n\tprivate boolean createTemporaryLob = false;\n\n\n\t/**\n\t * Specify whether to submit a byte array / String to the JDBC driver\n\t * wrapped in a JDBC Blob / Clob object, using the JDBC {@code setBlob} /\n\t * {@code setClob} method with a Blob / Clob argument.\n\t * <p>Default is \"false\", using the common JDBC 2.0 {@code setBinaryStream}\n\t * / {@code setCharacterStream} method for setting the content. Switch this\n\t * to \"true\" for explicit Blob / Clob wrapping against JDBC drivers that\n\t * are known to require such wrapping (for example, PostgreSQL's for access to OID\n\t * columns, whereas BYTEA columns need to be accessed the standard way).\n\t * <p>This setting affects byte array / String arguments as well as stream\n\t * arguments, unless {@link #setStreamAsLob \"streamAsLob\"} overrides this\n\t * handling to use JDBC 4.0's new explicit streaming support (if available).\n\t * @see java.sql.PreparedStatement#setBlob(int, java.sql.Blob)\n\t * @see java.sql.PreparedStatement#setClob(int, java.sql.Clob)\n\t */\n\tpublic void setWrapAsLob(boolean wrapAsLob) {\n\t\tthis.wrapAsLob = wrapAsLob;\n\t}\n\n\t/**\n\t * Specify whether to submit a binary stream / character stream to the JDBC\n\t * driver as explicit LOB content, using the JDBC 4.0 {@code setBlob} /\n\t * {@code setClob} method with a stream argument.\n\t * <p>Default is \"false\", using the common JDBC 2.0 {@code setBinaryStream}\n\t * / {@code setCharacterStream} method for setting the content.\n\t * Switch this to \"true\" for explicit JDBC 4.0 streaming, provided that your\n\t * JDBC driver actually supports those JDBC 4.0 operations (for example, Derby's).\n\t * <p>This setting affects stream arguments as well as byte array / String\n\t * arguments, requiring JDBC 4.0 support. For supporting LOB content against\n\t * JDBC 3.0, check out the {@link #setWrapAsLob \"wrapAsLob\"} setting.\n\t * @see java.sql.PreparedStatement#setBlob(int, java.io.InputStream, long)\n\t * @see java.sql.PreparedStatement#setClob(int, java.io.Reader, long)\n\t */\n\tpublic void setStreamAsLob(boolean streamAsLob) {\n\t\tthis.streamAsLob = streamAsLob;\n\t}\n\n\t/**\n\t * Specify whether to copy a byte array / String into a temporary JDBC\n\t * Blob / Clob object created through the JDBC 4.0 {@code createBlob} /\n\t * {@code createClob} methods.\n\t * <p>Default is \"false\", using the common JDBC 2.0 {@code setBinaryStream}\n\t * / {@code setCharacterStream} method for setting the content. Switch this\n\t * to \"true\" for explicit Blob / Clob creation using JDBC 4.0.\n\t * <p>This setting affects stream arguments as well as byte array / String\n\t * arguments, requiring JDBC 4.0 support. For supporting LOB content against\n\t * JDBC 3.0, check out the {@link #setWrapAsLob \"wrapAsLob\"} setting.\n\t * @see java.sql.Connection#createBlob()\n\t * @see java.sql.Connection#createClob()\n\t */\n\tpublic void setCreateTemporaryLob(boolean createTemporaryLob) {\n\t\tthis.createTemporaryLob = createTemporaryLob;\n\t}\n\n\n\t@Override\n\tpublic byte @Nullable [] getBlobAsBytes(ResultSet rs, int columnIndex) throws SQLException {\n\t\tlogger.debug(\"Returning BLOB as bytes\");\n\t\tif (this.wrapAsLob) {\n\t\t\tBlob blob = rs.getBlob(columnIndex);\n\t\t\treturn blob.getBytes(1, (int) blob.length());\n\t\t}\n\t\telse {\n\t\t\treturn rs.getBytes(columnIndex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic @Nullable InputStream getBlobAsBinaryStream(ResultSet rs, int columnIndex) throws SQLException {\n\t\tlogger.debug(\"Returning BLOB as binary stream\");\n\t\tif (this.wrapAsLob) {\n\t\t\tBlob blob = rs.getBlob(columnIndex);\n\t\t\treturn blob.getBinaryStream();\n\t\t}\n\t\telse {\n\t\t\treturn rs.getBinaryStream(columnIndex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic @Nullable String getClobAsString(ResultSet rs, int columnIndex) throws SQLException {\n\t\tlogger.debug(\"Returning CLOB as string\");\n\t\tif (this.wrapAsLob) {\n\t\t\tClob clob = rs.getClob(columnIndex);\n\t\t\treturn clob.getSubString(1, (int) clob.length());\n\t\t}\n\t\telse {\n\t\t\treturn rs.getString(columnIndex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic InputStream getClobAsAsciiStream(ResultSet rs, int columnIndex) throws SQLException {\n\t\tlogger.debug(\"Returning CLOB as ASCII stream\");\n\t\tif (this.wrapAsLob) {\n\t\t\tClob clob = rs.getClob(columnIndex);\n\t\t\treturn clob.getAsciiStream();\n\t\t}\n\t\telse {\n\t\t\treturn rs.getAsciiStream(columnIndex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic Reader getClobAsCharacterStream(ResultSet rs, int columnIndex) throws SQLException {\n\t\tlogger.debug(\"Returning CLOB as character stream\");\n\t\tif (this.wrapAsLob) {\n\t\t\tClob clob = rs.getClob(columnIndex);\n\t\t\treturn clob.getCharacterStream();\n\t\t}\n\t\telse {\n\t\t\treturn rs.getCharacterStream(columnIndex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic LobCreator getLobCreator() {\n\t\treturn (this.createTemporaryLob ? new TemporaryLobCreator() : new DefaultLobCreator());\n\t}\n\n\n\t/**\n\t * Default LobCreator implementation as an inner class.\n\t * Can be subclassed in DefaultLobHandler extensions.\n\t */\n\tprotected class DefaultLobCreator implements LobCreator {\n\n\t\t@Override\n\t\tpublic void setBlobAsBytes(PreparedStatement ps, int paramIndex, byte @Nullable [] content)\n\t\t\t\tthrows SQLException {\n\n\t\t\tif (streamAsLob) {\n\t\t\t\tif (content != null) {\n\t\t\t\t\tps.setBlob(paramIndex, new ByteArrayInputStream(content), content.length);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setBlob(paramIndex, (Blob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (wrapAsLob) {\n\t\t\t\tif (content != null) {\n\t\t\t\t\tps.setBlob(paramIndex, new PassThroughBlob(content));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setBlob(paramIndex, (Blob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tps.setBytes(paramIndex, content);\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(content != null ? \"Set bytes for BLOB with length \" + content.length :\n\t\t\t\t\t\t\"Set BLOB to null\");\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void setBlobAsBinaryStream(\n\t\t\t\tPreparedStatement ps, int paramIndex, @Nullable InputStream binaryStream, int contentLength)\n\t\t\t\tthrows SQLException {\n\n\t\t\tif (streamAsLob) {\n\t\t\t\tif (binaryStream != null) {\n\t\t\t\t\tif (contentLength >= 0) {\n\t\t\t\t\t\tps.setBlob(paramIndex, binaryStream, contentLength);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tps.setBlob(paramIndex, binaryStream);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setBlob(paramIndex, (Blob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (wrapAsLob) {\n\t\t\t\tif (binaryStream != null) {\n\t\t\t\t\tps.setBlob(paramIndex, new PassThroughBlob(binaryStream, contentLength));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setBlob(paramIndex, (Blob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (contentLength >= 0) {\n\t\t\t\tps.setBinaryStream(paramIndex, binaryStream, contentLength);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tps.setBinaryStream(paramIndex, binaryStream);\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(binaryStream != null ? \"Set binary stream for BLOB with length \" + contentLength :\n\t\t\t\t\t\t\"Set BLOB to null\");\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void setClobAsString(PreparedStatement ps, int paramIndex, @Nullable String content)\n\t\t\t\tthrows SQLException {\n\n\t\t\tif (streamAsLob) {\n\t\t\t\tif (content != null) {\n\t\t\t\t\tps.setClob(paramIndex, new StringReader(content), content.length());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setClob(paramIndex, (Clob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (wrapAsLob) {\n\t\t\t\tif (content != null) {\n\t\t\t\t\tps.setClob(paramIndex, new PassThroughClob(content));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setClob(paramIndex, (Clob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tps.setString(paramIndex, content);\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(content != null ? \"Set string for CLOB with length \" + content.length() :\n\t\t\t\t\t\t\"Set CLOB to null\");\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void setClobAsAsciiStream(\n\t\t\t\tPreparedStatement ps, int paramIndex, @Nullable InputStream asciiStream, int contentLength)\n\t\t\t\tthrows SQLException {\n\n\t\t\tif (streamAsLob) {\n\t\t\t\tif (asciiStream != null) {\n\t\t\t\t\tReader reader = new InputStreamReader(asciiStream, StandardCharsets.US_ASCII);\n\t\t\t\t\tif (contentLength >= 0) {\n\t\t\t\t\t\tps.setClob(paramIndex, reader, contentLength);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tps.setClob(paramIndex, reader);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setClob(paramIndex, (Clob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (wrapAsLob) {\n\t\t\t\tif (asciiStream != null) {\n\t\t\t\t\tps.setClob(paramIndex, new PassThroughClob(asciiStream, contentLength));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setClob(paramIndex, (Clob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (contentLength >= 0) {\n\t\t\t\tps.setAsciiStream(paramIndex, asciiStream, contentLength);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tps.setAsciiStream(paramIndex, asciiStream);\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(asciiStream != null ? \"Set ASCII stream for CLOB with length \" + contentLength :\n\t\t\t\t\t\t\"Set CLOB to null\");\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void setClobAsCharacterStream(\n\t\t\t\tPreparedStatement ps, int paramIndex, @Nullable Reader characterStream, int contentLength)\n\t\t\t\tthrows SQLException {\n\n\t\t\tif (streamAsLob) {\n\t\t\t\tif (characterStream != null) {\n\t\t\t\t\tif (contentLength >= 0) {\n\t\t\t\t\t\tps.setClob(paramIndex, characterStream, contentLength);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tps.setClob(paramIndex, characterStream);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setClob(paramIndex, (Clob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (wrapAsLob) {\n\t\t\t\tif (characterStream != null) {\n\t\t\t\t\tps.setClob(paramIndex, new PassThroughClob(characterStream, contentLength));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setClob(paramIndex, (Clob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (contentLength >= 0) {\n\t\t\t\tps.setCharacterStream(paramIndex, characterStream, contentLength);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tps.setCharacterStream(paramIndex, characterStream);\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(characterStream != null ? \"Set character stream for CLOB with length \" + contentLength :\n\t\t\t\t\t\t\"Set CLOB to null\");\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void close() {\n\t\t\t// nothing to do when not creating temporary LOBs\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jdbc.support.lob.DefaultLobHandler#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\t\tpublic void close() {\n\t\t\t// nothing to do when not creating temporary LOBs\n\t\t}"
  },
  "org.springframework.jdbc.support.lob.DefaultLobHandler#getBlobAsBinaryStream(rs,columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "InputStream",
    "signature": "public InputStream getBlobAsBinaryStream(ResultSet rs, int columnIndex)",
    "source_code": "\tpublic @Nullable InputStream getBlobAsBinaryStream(ResultSet rs, int columnIndex) throws SQLException {\n\t\tlogger.debug(\"Returning BLOB as binary stream\");\n\t\tif (this.wrapAsLob) {\n\t\t\tBlob blob = rs.getBlob(columnIndex);\n\t\t\treturn blob.getBinaryStream();\n\t\t}\n\t\telse {\n\t\t\treturn rs.getBinaryStream(columnIndex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.lob.DefaultLobHandler#getClobAsAsciiStream(rs,columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "InputStream",
    "signature": "public InputStream getClobAsAsciiStream(ResultSet rs, int columnIndex)",
    "source_code": "\tpublic InputStream getClobAsAsciiStream(ResultSet rs, int columnIndex) throws SQLException {\n\t\tlogger.debug(\"Returning CLOB as ASCII stream\");\n\t\tif (this.wrapAsLob) {\n\t\t\tClob clob = rs.getClob(columnIndex);\n\t\t\treturn clob.getAsciiStream();\n\t\t}\n\t\telse {\n\t\t\treturn rs.getAsciiStream(columnIndex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.lob.DefaultLobHandler#getClobAsCharacterStream(rs,columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "Reader",
    "signature": "public Reader getClobAsCharacterStream(ResultSet rs, int columnIndex)",
    "source_code": "\tpublic Reader getClobAsCharacterStream(ResultSet rs, int columnIndex) throws SQLException {\n\t\tlogger.debug(\"Returning CLOB as character stream\");\n\t\tif (this.wrapAsLob) {\n\t\t\tClob clob = rs.getClob(columnIndex);\n\t\t\treturn clob.getCharacterStream();\n\t\t}\n\t\telse {\n\t\t\treturn rs.getCharacterStream(columnIndex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.lob.DefaultLobHandler#getClobAsString(rs,columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "String",
    "signature": "public String getClobAsString(ResultSet rs, int columnIndex)",
    "source_code": "\tpublic @Nullable String getClobAsString(ResultSet rs, int columnIndex) throws SQLException {\n\t\tlogger.debug(\"Returning CLOB as string\");\n\t\tif (this.wrapAsLob) {\n\t\t\tClob clob = rs.getClob(columnIndex);\n\t\t\treturn clob.getSubString(1, (int) clob.length());\n\t\t}\n\t\telse {\n\t\t\treturn rs.getString(columnIndex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.lob.DefaultLobHandler#getLobCreator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "LobCreator",
    "signature": "public LobCreator getLobCreator()",
    "source_code": "\tpublic LobCreator getLobCreator() {\n\t\treturn (this.createTemporaryLob ? new TemporaryLobCreator() : new DefaultLobCreator());\n\t}"
  },
  "org.springframework.jdbc.support.lob.DefaultLobHandler#setBlobAsBinaryStream(ps,paramIndex,binaryStream,contentLength)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "binaryStream",
      "contentLength"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void setBlobAsBinaryStream(PreparedStatement ps, int paramIndex, @Nullable InputStream binaryStream, int contentLength)",
    "source_code": "\t\tpublic void setBlobAsBinaryStream("
  },
  "org.springframework.jdbc.support.lob.DefaultLobHandler#setBlobAsBytes(ps,paramIndex,content)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "content"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "void",
    "signature": "public void setBlobAsBytes(PreparedStatement ps, int paramIndex, byte @Nullable [] content)",
    "source_code": "\t\tpublic void setBlobAsBytes(PreparedStatement ps, int paramIndex, byte @Nullable [] content)"
  },
  "org.springframework.jdbc.support.lob.DefaultLobHandler#setClobAsAsciiStream(ps,paramIndex,asciiStream,contentLength)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "asciiStream",
      "contentLength"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "void",
    "signature": "public void setClobAsAsciiStream(PreparedStatement ps, int paramIndex, @Nullable InputStream asciiStream, int contentLength)",
    "source_code": "\t\tpublic void setClobAsAsciiStream("
  },
  "org.springframework.jdbc.support.lob.DefaultLobHandler#setClobAsCharacterStream(ps,paramIndex,characterStream,contentLength)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "characterStream",
      "contentLength"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "void",
    "signature": "public void setClobAsCharacterStream(PreparedStatement ps, int paramIndex, @Nullable Reader characterStream, int contentLength)",
    "source_code": "\t\tpublic void setClobAsCharacterStream("
  },
  "org.springframework.jdbc.support.lob.DefaultLobHandler#setClobAsString(ps,paramIndex,content)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "content"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "void",
    "signature": "public void setClobAsString(PreparedStatement ps, int paramIndex, @Nullable String content)",
    "source_code": "\t\tpublic void setClobAsString(PreparedStatement ps, int paramIndex, @Nullable String content)"
  },
  "org.springframework.jdbc.support.lob.DefaultLobHandler#setCreateTemporaryLob(createTemporaryLob)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to copy a byte array / String into a temporary JDBC\n\t * Blob / Clob object created through the JDBC 4.0 {@code createBlob} /\n\t * {@code createClob} methods.\n\t * <p>Default is \"false\", using the common JDBC 2.0 {@code setBinaryStream}\n\t * / {@code setCharacterStream} method for setting the content. Switch this\n\t * to \"true\" for explicit Blob / Clob creation using JDBC 4.0.\n\t * <p>This setting affects stream arguments as well as byte array / String\n\t * arguments, requiring JDBC 4.0 support. For supporting LOB content against\n\t * JDBC 3.0, check out the {@link #setWrapAsLob \"wrapAsLob\"} setting.\n\t * @see java.sql.Connection#createBlob()\n\t * @see java.sql.Connection#createClob()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "createTemporaryLob"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void setCreateTemporaryLob(boolean createTemporaryLob)",
    "source_code": "\tpublic void setCreateTemporaryLob(boolean createTemporaryLob) {\n\t\tthis.createTemporaryLob = createTemporaryLob;\n\t}"
  },
  "org.springframework.jdbc.support.lob.DefaultLobHandler#setStreamAsLob(streamAsLob)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to submit a binary stream / character stream to the JDBC\n\t * driver as explicit LOB content, using the JDBC 4.0 {@code setBlob} /\n\t * {@code setClob} method with a stream argument.\n\t * <p>Default is \"false\", using the common JDBC 2.0 {@code setBinaryStream}\n\t * / {@code setCharacterStream} method for setting the content.\n\t * Switch this to \"true\" for explicit JDBC 4.0 streaming, provided that your\n\t * JDBC driver actually supports those JDBC 4.0 operations (for example, Derby's).\n\t * <p>This setting affects stream arguments as well as byte array / String\n\t * arguments, requiring JDBC 4.0 support. For supporting LOB content against\n\t * JDBC 3.0, check out the {@link #setWrapAsLob \"wrapAsLob\"} setting.\n\t * @see java.sql.PreparedStatement#setBlob(int, java.io.InputStream, long)\n\t * @see java.sql.PreparedStatement#setClob(int, java.io.Reader, long)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "streamAsLob"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void setStreamAsLob(boolean streamAsLob)",
    "source_code": "\tpublic void setStreamAsLob(boolean streamAsLob) {\n\t\tthis.streamAsLob = streamAsLob;\n\t}"
  },
  "org.springframework.jdbc.support.lob.DefaultLobHandler#setWrapAsLob(wrapAsLob)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to submit a byte array / String to the JDBC driver\n\t * wrapped in a JDBC Blob / Clob object, using the JDBC {@code setBlob} /\n\t * {@code setClob} method with a Blob / Clob argument.\n\t * <p>Default is \"false\", using the common JDBC 2.0 {@code setBinaryStream}\n\t * / {@code setCharacterStream} method for setting the content. Switch this\n\t * to \"true\" for explicit Blob / Clob wrapping against JDBC drivers that\n\t * are known to require such wrapping (for example, PostgreSQL's for access to OID\n\t * columns, whereas BYTEA columns need to be accessed the standard way).\n\t * <p>This setting affects byte array / String arguments as well as stream\n\t * arguments, unless {@link #setStreamAsLob \"streamAsLob\"} overrides this\n\t * handling to use JDBC 4.0's new explicit streaming support (if available).\n\t * @see java.sql.PreparedStatement#setBlob(int, java.sql.Blob)\n\t * @see java.sql.PreparedStatement#setClob(int, java.sql.Clob)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "wrapAsLob"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void setWrapAsLob(boolean wrapAsLob)",
    "source_code": "\tpublic void setWrapAsLob(boolean wrapAsLob) {\n\t\tthis.wrapAsLob = wrapAsLob;\n\t}"
  },
  "org.springframework.jdbc.support.lob.LobCreator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Interface that abstracts potentially database-specific creation of large binary\n * fields and large text fields. Does not work with {@code java.sql.Blob}\n * and {@code java.sql.Clob} instances in the API, as some JDBC drivers\n * do not support these types as such.\n *\n * <p>The LOB creation part is where {@link LobHandler} implementations usually\n * differ. Possible strategies include usage of\n * {@code PreparedStatement.setBinaryStream/setCharacterStream} but also\n * {@code PreparedStatement.setBlob/setClob} with either a stream argument or\n * {@code java.sql.Blob/Clob} wrapper objects.\n *\n * <p>A LobCreator represents a session for creating BLOBs: It is <i>not</i>\n * thread-safe and needs to be instantiated for each statement execution or for\n * each transaction. Each LobCreator needs to be closed after completion.\n *\n * <p>For convenient working with a PreparedStatement and a LobCreator,\n * consider using {@link org.springframework.jdbc.core.JdbcTemplate} with an\n *{@link org.springframework.jdbc.core.support.AbstractLobCreatingPreparedStatementCallback}\n * implementation. See the latter's javadoc for details.\n *\n * @author Juergen Hoeller\n * @since 04.12.2003\n * @see #close()\n * @see LobHandler#getLobCreator()\n * @see DefaultLobHandler.DefaultLobCreator\n * @see java.sql.PreparedStatement#setBlob\n * @see java.sql.PreparedStatement#setClob\n * @see java.sql.PreparedStatement#setBytes\n * @see java.sql.PreparedStatement#setBinaryStream\n * @see java.sql.PreparedStatement#setString\n * @see java.sql.PreparedStatement#setAsciiStream\n * @see java.sql.PreparedStatement#setCharacterStream\n * @deprecated as of 6.2, in favor of {@link org.springframework.jdbc.core.support.SqlBinaryValue}\n * and {@link org.springframework.jdbc.core.support.SqlCharacterValue}\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "signature": "public interface LobCreator",
    "source_code": "public interface LobCreator extends Closeable {\n\n\t/**\n\t * Set the given content as bytes on the given statement, using the given\n\t * parameter index. Might simply invoke {@code PreparedStatement.setBytes}\n\t * or create a Blob instance for it, depending on the database and driver.\n\t * @param ps the PreparedStatement to the set the content on\n\t * @param paramIndex the parameter index to use\n\t * @param content the content as byte array, or {@code null} for SQL NULL\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.PreparedStatement#setBytes\n\t */\n\tvoid setBlobAsBytes(PreparedStatement ps, int paramIndex, byte @Nullable [] content)\n\t\t\tthrows SQLException;\n\n\t/**\n\t * Set the given content as binary stream on the given statement, using the given\n\t * parameter index. Might simply invoke {@code PreparedStatement.setBinaryStream}\n\t * or create a Blob instance for it, depending on the database and driver.\n\t * @param ps the PreparedStatement to the set the content on\n\t * @param paramIndex the parameter index to use\n\t * @param contentStream the content as binary stream, or {@code null} for SQL NULL\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.PreparedStatement#setBinaryStream\n\t */\n\tvoid setBlobAsBinaryStream(\n\t\t\tPreparedStatement ps, int paramIndex, @Nullable InputStream contentStream, int contentLength)\n\t\t\tthrows SQLException;\n\n\t/**\n\t * Set the given content as String on the given statement, using the given\n\t * parameter index. Might simply invoke {@code PreparedStatement.setString}\n\t * or create a Clob instance for it, depending on the database and driver.\n\t * @param ps the PreparedStatement to the set the content on\n\t * @param paramIndex the parameter index to use\n\t * @param content the content as String, or {@code null} for SQL NULL\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.PreparedStatement#setBytes\n\t */\n\tvoid setClobAsString(PreparedStatement ps, int paramIndex, @Nullable String content)\n\t\t\tthrows SQLException;\n\n\t/**\n\t * Set the given content as ASCII stream on the given statement, using the given\n\t * parameter index. Might simply invoke {@code PreparedStatement.setAsciiStream}\n\t * or create a Clob instance for it, depending on the database and driver.\n\t * @param ps the PreparedStatement to the set the content on\n\t * @param paramIndex the parameter index to use\n\t * @param asciiStream the content as ASCII stream, or {@code null} for SQL NULL\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.PreparedStatement#setAsciiStream\n\t */\n\tvoid setClobAsAsciiStream(\n\t\t\tPreparedStatement ps, int paramIndex, @Nullable InputStream asciiStream, int contentLength)\n\t\t\tthrows SQLException;\n\n\t/**\n\t * Set the given content as character stream on the given statement, using the given\n\t * parameter index. Might simply invoke {@code PreparedStatement.setCharacterStream}\n\t * or create a Clob instance for it, depending on the database and driver.\n\t * @param ps the PreparedStatement to the set the content on\n\t * @param paramIndex the parameter index to use\n\t * @param characterStream the content as character stream, or {@code null} for SQL NULL\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.PreparedStatement#setCharacterStream\n\t */\n\tvoid setClobAsCharacterStream(\n\t\t\tPreparedStatement ps, int paramIndex, @Nullable Reader characterStream, int contentLength)\n\t\t\tthrows SQLException;\n\n\t/**\n\t * Close this LobCreator session and free its temporarily created BLOBs and CLOBs.\n\t * Will not need to do anything if using PreparedStatement's standard methods,\n\t * but might be necessary to free database resources if using proprietary means.\n\t * <p><b>NOTE</b>: Needs to be invoked after the involved PreparedStatements have\n\t * been executed or the affected O/R mapping sessions have been flushed.\n\t * Otherwise, the database resources for the temporary BLOBs might stay allocated.\n\t */\n\t@Override\n\tvoid close();\n\n}"
  },
  "org.springframework.jdbc.support.lob.LobHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstraction for handling large binary fields and large text fields in\n * specific databases, no matter if represented as simple types or Large OBjects.\n *\n * <p>Provides accessor methods for BLOBs and CLOBs, and acts as factory for\n * LobCreator instances, to be used as sessions for creating BLOBs or CLOBs.\n * LobCreators are typically instantiated for each statement execution or for\n * each transaction; they are not thread-safe because they might track\n * allocated database resources in order to free them after execution.\n *\n * <p>Most databases/drivers should be able to work with {@link DefaultLobHandler},\n * which by default delegates to JDBC's direct accessor methods, avoiding the\n * {@code java.sql.Blob} and {@code java.sql.Clob} API completely.\n * {@link DefaultLobHandler} can also be configured to access LOBs using\n * {@code PreparedStatement.setBlob/setClob} (for example, for PostgreSQL), through\n * setting the {@link DefaultLobHandler#setWrapAsLob \"wrapAsLob\"} property.\n *\n * <p>Of course, you need to declare different field types for each database.\n * In Oracle, any binary content needs to go into a BLOB, and all character content\n * beyond 4000 bytes needs to go into a CLOB. In MySQL, there is no notion of a\n * CLOB type but rather a LONGTEXT type that behaves like a VARCHAR. For complete\n * portability, use a LobHandler for fields that might typically require LOBs on\n * some database because of the field size (take Oracle's numbers as a guideline).\n *\n * <p><b>Summarizing the recommended options (for actual LOB fields):</b>\n * <ul>\n * <li><b>JDBC 4.0 driver (including Oracle 11g driver):</b> Use {@link DefaultLobHandler},\n * potentially with {@code streamAsLob=true} if your database driver requires that\n * hint when populating a LOB field. Fall back to {@code createTemporaryLob=true}\n * if you happen to run into LOB size limitations with your (Oracle) database setup.\n * <li><b>Oracle 10g driver:</b> Use {@link DefaultLobHandler} with standard setup.\n * On Oracle 10.1, set the \"SetBigStringTryClob\" connection property; as of Oracle 10.2,\n * DefaultLobHandler should work with standard setup out of the box.\n * <li><b>PostgreSQL:</b> Configure {@link DefaultLobHandler} with {@code wrapAsLob=true},\n * and use that LobHandler to access OID columns (but not BYTEA) in your database tables.\n * <li>For all other database drivers (and for non-LOB fields that might potentially\n * turn into LOBs on some databases): Simply use a plain {@link DefaultLobHandler}.\n * </ul>\n *\n * @author Juergen Hoeller\n * @since 23.12.2003\n * @see DefaultLobHandler\n * @see java.sql.ResultSet#getBlob\n * @see java.sql.ResultSet#getClob\n * @see java.sql.ResultSet#getBytes\n * @see java.sql.ResultSet#getBinaryStream\n * @see java.sql.ResultSet#getString\n * @see java.sql.ResultSet#getAsciiStream\n * @see java.sql.ResultSet#getCharacterStream\n * @deprecated as of 6.2, in favor of {@link org.springframework.jdbc.core.support.SqlBinaryValue}\n * and {@link org.springframework.jdbc.core.support.SqlCharacterValue}\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "signature": "public interface LobHandler",
    "source_code": "public interface LobHandler {\n\n\t/**\n\t * Retrieve the given column as bytes from the given ResultSet.\n\t * Might simply invoke {@code ResultSet.getBytes} or work with\n\t * {@code ResultSet.getBlob}, depending on the database and driver.\n\t * @param rs the ResultSet to retrieve the content from\n\t * @param columnName the column name to use\n\t * @return the content as byte array, or {@code null} in case of SQL NULL\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.ResultSet#getBytes\n\t */\n\tbyte @Nullable [] getBlobAsBytes(ResultSet rs, String columnName) throws SQLException;\n\n\t/**\n\t * Retrieve the given column as bytes from the given ResultSet.\n\t * Might simply invoke {@code ResultSet.getBytes} or work with\n\t * {@code ResultSet.getBlob}, depending on the database and driver.\n\t * @param rs the ResultSet to retrieve the content from\n\t * @param columnIndex the column index to use\n\t * @return the content as byte array, or {@code null} in case of SQL NULL\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.ResultSet#getBytes\n\t */\n\tbyte @Nullable [] getBlobAsBytes(ResultSet rs, int columnIndex) throws SQLException;\n\n\t/**\n\t * Retrieve the given column as binary stream from the given ResultSet.\n\t * Might simply invoke {@code ResultSet.getBinaryStream} or work with\n\t * {@code ResultSet.getBlob}, depending on the database and driver.\n\t * @param rs the ResultSet to retrieve the content from\n\t * @param columnName the column name to use\n\t * @return the content as binary stream, or {@code null} in case of SQL NULL\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.ResultSet#getBinaryStream\n\t */\n\t@Nullable InputStream getBlobAsBinaryStream(ResultSet rs, String columnName) throws SQLException;\n\n\t/**\n\t * Retrieve the given column as binary stream from the given ResultSet.\n\t * Might simply invoke {@code ResultSet.getBinaryStream} or work with\n\t * {@code ResultSet.getBlob}, depending on the database and driver.\n\t * @param rs the ResultSet to retrieve the content from\n\t * @param columnIndex the column index to use\n\t * @return the content as binary stream, or {@code null} in case of SQL NULL\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.ResultSet#getBinaryStream\n\t */\n\t@Nullable InputStream getBlobAsBinaryStream(ResultSet rs, int columnIndex) throws SQLException;\n\n\t/**\n\t * Retrieve the given column as String from the given ResultSet.\n\t * Might simply invoke {@code ResultSet.getString} or work with\n\t * {@code ResultSet.getClob}, depending on the database and driver.\n\t * @param rs the ResultSet to retrieve the content from\n\t * @param columnName the column name to use\n\t * @return the content as String, or {@code null} in case of SQL NULL\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.ResultSet#getString\n\t */\n\t@Nullable String getClobAsString(ResultSet rs, String columnName) throws SQLException;\n\n\t/**\n\t * Retrieve the given column as String from the given ResultSet.\n\t * Might simply invoke {@code ResultSet.getString} or work with\n\t * {@code ResultSet.getClob}, depending on the database and driver.\n\t * @param rs the ResultSet to retrieve the content from\n\t * @param columnIndex the column index to use\n\t * @return the content as String, or {@code null} in case of SQL NULL\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.ResultSet#getString\n\t */\n\t@Nullable String getClobAsString(ResultSet rs, int columnIndex) throws SQLException;\n\n\t/**\n\t * Retrieve the given column as ASCII stream from the given ResultSet.\n\t * Might simply invoke {@code ResultSet.getAsciiStream} or work with\n\t * {@code ResultSet.getClob}, depending on the database and driver.\n\t * @param rs the ResultSet to retrieve the content from\n\t * @param columnName the column name to use\n\t * @return the content as ASCII stream, or {@code null} in case of SQL NULL\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.ResultSet#getAsciiStream\n\t */\n\t@Nullable InputStream getClobAsAsciiStream(ResultSet rs, String columnName) throws SQLException;\n\n\t/**\n\t * Retrieve the given column as ASCII stream from the given ResultSet.\n\t * Might simply invoke {@code ResultSet.getAsciiStream} or work with\n\t * {@code ResultSet.getClob}, depending on the database and driver.\n\t * @param rs the ResultSet to retrieve the content from\n\t * @param columnIndex the column index to use\n\t * @return the content as ASCII stream, or {@code null} in case of SQL NULL\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.ResultSet#getAsciiStream\n\t */\n\t@Nullable InputStream getClobAsAsciiStream(ResultSet rs, int columnIndex) throws SQLException;\n\n\t/**\n\t * Retrieve the given column as character stream from the given ResultSet.\n\t * Might simply invoke {@code ResultSet.getCharacterStream} or work with\n\t * {@code ResultSet.getClob}, depending on the database and driver.\n\t * @param rs the ResultSet to retrieve the content from\n\t * @param columnName the column name to use\n\t * @return the content as character stream\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.ResultSet#getCharacterStream\n\t */\n\tReader getClobAsCharacterStream(ResultSet rs, String columnName) throws SQLException;\n\n\t/**\n\t * Retrieve the given column as character stream from the given ResultSet.\n\t * Might simply invoke {@code ResultSet.getCharacterStream} or work with\n\t * {@code ResultSet.getClob}, depending on the database and driver.\n\t * @param rs the ResultSet to retrieve the content from\n\t * @param columnIndex the column index to use\n\t * @return the content as character stream\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.ResultSet#getCharacterStream\n\t */\n\tReader getClobAsCharacterStream(ResultSet rs, int columnIndex) throws SQLException;\n\n\t/**\n\t * Create a new {@link LobCreator} instance, i.e. a session for creating BLOBs\n\t * and CLOBs. Needs to be closed after the created LOBs are not needed anymore -\n\t * typically after statement execution or transaction completion.\n\t * @return the new LobCreator instance\n\t * @see LobCreator#close()\n\t */\n\tLobCreator getLobCreator();\n\n}"
  },
  "org.springframework.jdbc.support.lob.TemporaryLobCreator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link LobCreator} implementation based on temporary LOBs, using JDBC's\n * {@link java.sql.Connection#createBlob()} /\n * {@link java.sql.Connection#createClob()} mechanism.\n *\n * <p>Used by DefaultLobHandler's {@link DefaultLobHandler#setCreateTemporaryLob} mode.\n * Can also be used directly to reuse the tracking and freeing of temporary LOBs.\n *\n * @author Juergen Hoeller\n * @since 3.2.2\n * @see DefaultLobHandler#setCreateTemporaryLob\n * @see java.sql.Connection#createBlob()\n * @see java.sql.Connection#createClob()\n * @deprecated as of 6.2, in favor of {@link org.springframework.jdbc.core.support.SqlBinaryValue}\n * and {@link org.springframework.jdbc.core.support.SqlCharacterValue}\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "signature": "public class TemporaryLobCreator",
    "source_code": "public class TemporaryLobCreator implements LobCreator {\n\n\tprotected static final Log logger = LogFactory.getLog(TemporaryLobCreator.class);\n\n\tprivate final Set<Blob> temporaryBlobs = new LinkedHashSet<>(1);\n\n\tprivate final Set<Clob> temporaryClobs = new LinkedHashSet<>(1);\n\n\n\t@Override\n\tpublic void setBlobAsBytes(PreparedStatement ps, int paramIndex, byte @Nullable [] content)\n\t\t\tthrows SQLException {\n\n\t\tif (content != null) {\n\t\t\tBlob blob = ps.getConnection().createBlob();\n\t\t\tblob.setBytes(1, content);\n\t\t\tthis.temporaryBlobs.add(blob);\n\t\t\tps.setBlob(paramIndex, blob);\n\t\t}\n\t\telse {\n\t\t\tps.setBlob(paramIndex, (Blob) null);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(content != null ? \"Copied bytes into temporary BLOB with length \" + content.length :\n\t\t\t\t\t\"Set BLOB to null\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setBlobAsBinaryStream(\n\t\t\tPreparedStatement ps, int paramIndex, @Nullable InputStream binaryStream, int contentLength)\n\t\t\tthrows SQLException {\n\n\t\tif (binaryStream != null) {\n\t\t\tBlob blob = ps.getConnection().createBlob();\n\t\t\ttry {\n\t\t\t\tFileCopyUtils.copy(binaryStream, blob.setBinaryStream(1));\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new DataAccessResourceFailureException(\"Could not copy into LOB stream\", ex);\n\t\t\t}\n\t\t\tthis.temporaryBlobs.add(blob);\n\t\t\tps.setBlob(paramIndex, blob);\n\t\t}\n\t\telse {\n\t\t\tps.setBlob(paramIndex, (Blob) null);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(binaryStream != null ?\n\t\t\t\t\t\"Copied binary stream into temporary BLOB with length \" + contentLength :\n\t\t\t\t\t\"Set BLOB to null\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setClobAsString(PreparedStatement ps, int paramIndex, @Nullable String content)\n\t\t\tthrows SQLException {\n\n\t\tif (content != null) {\n\t\t\tClob clob = ps.getConnection().createClob();\n\t\t\tclob.setString(1, content);\n\t\t\tthis.temporaryClobs.add(clob);\n\t\t\tps.setClob(paramIndex, clob);\n\t\t}\n\t\telse {\n\t\t\tps.setClob(paramIndex, (Clob) null);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(content != null ? \"Copied string into temporary CLOB with length \" + content.length() :\n\t\t\t\t\t\"Set CLOB to null\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setClobAsAsciiStream(\n\t\t\tPreparedStatement ps, int paramIndex, @Nullable InputStream asciiStream, int contentLength)\n\t\t\tthrows SQLException {\n\n\t\tif (asciiStream != null) {\n\t\t\tClob clob = ps.getConnection().createClob();\n\t\t\ttry {\n\t\t\t\tFileCopyUtils.copy(asciiStream, clob.setAsciiStream(1));\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new DataAccessResourceFailureException(\"Could not copy into LOB stream\", ex);\n\t\t\t}\n\t\t\tthis.temporaryClobs.add(clob);\n\t\t\tps.setClob(paramIndex, clob);\n\t\t}\n\t\telse {\n\t\t\tps.setClob(paramIndex, (Clob) null);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(asciiStream != null ?\n\t\t\t\t\t\"Copied ASCII stream into temporary CLOB with length \" + contentLength :\n\t\t\t\t\t\"Set CLOB to null\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setClobAsCharacterStream(\n\t\t\tPreparedStatement ps, int paramIndex, @Nullable Reader characterStream, int contentLength)\n\t\t\tthrows SQLException {\n\n\t\tif (characterStream != null) {\n\t\t\tClob clob = ps.getConnection().createClob();\n\t\t\ttry {\n\t\t\t\tFileCopyUtils.copy(characterStream, clob.setCharacterStream(1));\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new DataAccessResourceFailureException(\"Could not copy into LOB stream\", ex);\n\t\t\t}\n\t\t\tthis.temporaryClobs.add(clob);\n\t\t\tps.setClob(paramIndex, clob);\n\t\t}\n\t\telse {\n\t\t\tps.setClob(paramIndex, (Clob) null);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(characterStream != null ?\n\t\t\t\t\t\"Copied character stream into temporary CLOB with length \" + contentLength :\n\t\t\t\t\t\"Set CLOB to null\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tfor (Blob blob : this.temporaryBlobs) {\n\t\t\ttry {\n\t\t\t\tblob.free();\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\tlogger.warn(\"Could not free BLOB\", ex);\n\t\t\t}\n\t\t}\n\t\tfor (Clob clob : this.temporaryClobs) {\n\t\t\ttry {\n\t\t\t\tclob.free();\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\tlogger.warn(\"Could not free CLOB\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jdbc.support.lob.TemporaryLobCreator#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\tpublic void close() {\n\t\tfor (Blob blob : this.temporaryBlobs) {\n\t\t\ttry {\n\t\t\t\tblob.free();\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\tlogger.warn(\"Could not free BLOB\", ex);\n\t\t\t}\n\t\t}\n\t\tfor (Clob clob : this.temporaryClobs) {\n\t\t\ttry {\n\t\t\t\tclob.free();\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\tlogger.warn(\"Could not free CLOB\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.lob.TemporaryLobCreator#setBlobAsBinaryStream(ps,paramIndex,binaryStream,contentLength)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "binaryStream",
      "contentLength"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void setBlobAsBinaryStream(PreparedStatement ps, int paramIndex, @Nullable InputStream binaryStream, int contentLength)",
    "source_code": "\tpublic void setBlobAsBinaryStream("
  },
  "org.springframework.jdbc.support.lob.TemporaryLobCreator#setBlobAsBytes(ps,paramIndex,content)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "content"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "void",
    "signature": "public void setBlobAsBytes(PreparedStatement ps, int paramIndex, byte @Nullable [] content)",
    "source_code": "\tpublic void setBlobAsBytes(PreparedStatement ps, int paramIndex, byte @Nullable [] content)"
  },
  "org.springframework.jdbc.support.lob.TemporaryLobCreator#setClobAsAsciiStream(ps,paramIndex,asciiStream,contentLength)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "asciiStream",
      "contentLength"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void setClobAsAsciiStream(PreparedStatement ps, int paramIndex, @Nullable InputStream asciiStream, int contentLength)",
    "source_code": "\tpublic void setClobAsAsciiStream("
  },
  "org.springframework.jdbc.support.lob.TemporaryLobCreator#setClobAsCharacterStream(ps,paramIndex,characterStream,contentLength)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "characterStream",
      "contentLength"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "public void setClobAsCharacterStream(PreparedStatement ps, int paramIndex, @Nullable Reader characterStream, int contentLength)",
    "source_code": "\tpublic void setClobAsCharacterStream("
  },
  "org.springframework.jdbc.support.lob.TemporaryLobCreator#setClobAsString(ps,paramIndex,content)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "content"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void setClobAsString(PreparedStatement ps, int paramIndex, @Nullable String content)",
    "source_code": "\tpublic void setClobAsString(PreparedStatement ps, int paramIndex, @Nullable String content)"
  },
  "org.springframework.jdbc.support.lob.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * The common implementation of Spring's {@link SqlRowSet} interface, wrapping a\n * {@link java.sql.ResultSet}, catching any {@link SQLException SQLExceptions} and\n * translating them to a corresponding Spring {@link InvalidResultSetAccessException}.\n *\n * <p>The passed-in ResultSet should already be disconnected if the SqlRowSet is supposed\n * to be usable in a disconnected fashion. This means that you will usually pass in a\n * {@code javax.sql.rowset.CachedRowSet}, which implements the ResultSet interface.\n *\n * <p>Note: Since JDBC 4.0, it has been clarified that any methods using a String to identify\n * the column should be using the column label. The column label is assigned using the ALIAS\n * keyword in the SQL query string. When the query doesn't use an ALIAS, the default label is\n * the column name. Most JDBC ResultSet implementations follow this pattern, but there are\n * exceptions such as the {@code com.sun.rowset.CachedRowSetImpl} class which only uses\n * the column name, ignoring any column labels. {@code ResultSetWrappingSqlRowSet}\n * will translate column labels to the correct column index to provide better support for\n * {@code com.sun.rowset.CachedRowSetImpl} which is the default implementation used by\n * {@link org.springframework.jdbc.core.JdbcTemplate} when working with RowSets.\n *\n * <p>Note: This class implements the {@code java.io.Serializable} marker interface\n * through the SqlRowSet interface, but is only actually serializable if the disconnected\n * ResultSet/RowSet contained in it is serializable. Most CachedRowSet implementations\n * are actually serializable, so serialization should usually work.\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @since 1.2\n * @see java.sql.ResultSet\n * @see javax.sql.rowset.CachedRowSet\n * @see org.springframework.jdbc.core.JdbcTemplate#queryForRowSet\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "signature": "public class ResultSetWrappingSqlRowSet",
    "source_code": "public class ResultSetWrappingSqlRowSet implements SqlRowSet {\n\n\t/** use serialVersionUID from Spring 1.2 for interoperability. */\n\tprivate static final long serialVersionUID = -4688694393146734764L;\n\n\t@SuppressWarnings(\"serial\")\n\tprivate final ResultSet resultSet;\n\n\t@SuppressWarnings(\"serial\")\n\tprivate final SqlRowSetMetaData rowSetMetaData;\n\n\t@SuppressWarnings(\"serial\")\n\tprivate final Map<String, Integer> columnLabelMap;\n\n\n\t/**\n\t * Create a new {@code ResultSetWrappingSqlRowSet} for the given {@link ResultSet}.\n\t * @param resultSet a disconnected ResultSet to wrap\n\t * (usually a {@code javax.sql.rowset.CachedRowSet})\n\t * @throws InvalidResultSetAccessException if extracting\n\t * the ResultSetMetaData failed\n\t * @see javax.sql.rowset.CachedRowSet\n\t * @see java.sql.ResultSet#getMetaData\n\t * @see ResultSetWrappingSqlRowSetMetaData\n\t */\n\tpublic ResultSetWrappingSqlRowSet(ResultSet resultSet) throws InvalidResultSetAccessException {\n\t\tthis.resultSet = resultSet;\n\t\ttry {\n\t\t\tthis.rowSetMetaData = new ResultSetWrappingSqlRowSetMetaData(resultSet.getMetaData());\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t\ttry {\n\t\t\tResultSetMetaData rsmd = resultSet.getMetaData();\n\t\t\tif (rsmd != null) {\n\t\t\t\tint columnCount = rsmd.getColumnCount();\n\t\t\t\tthis.columnLabelMap = CollectionUtils.newHashMap(columnCount * 2);\n\t\t\t\tfor (int i = 1; i <= columnCount; i++) {\n\t\t\t\t\tString key = rsmd.getColumnLabel(i);\n\t\t\t\t\t// Make sure to preserve first matching column for any given name,\n\t\t\t\t\t// as defined in ResultSet's type-level javadoc (lines 81 to 83).\n\t\t\t\t\tif (!this.columnLabelMap.containsKey(key)) {\n\t\t\t\t\t\tthis.columnLabelMap.put(key, i);\n\t\t\t\t\t}\n\t\t\t\t\t// Also support column names prefixed with table name\n\t\t\t\t\t// as in {table_name}.{column.name}.\n\t\t\t\t\tString table = rsmd.getTableName(i);\n\t\t\t\t\tif (StringUtils.hasLength(table)) {\n\t\t\t\t\t\tkey = table + \".\" + rsmd.getColumnName(i);\n\t\t\t\t\t\tif (!this.columnLabelMap.containsKey(key)) {\n\t\t\t\t\t\t\tthis.columnLabelMap.put(key, i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.columnLabelMap = Collections.emptyMap();\n\t\t\t}\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Return the underlying ResultSet\n\t * (usually a {@code javax.sql.rowset.CachedRowSet}).\n\t * @see javax.sql.rowset.CachedRowSet\n\t */\n\tpublic final ResultSet getResultSet() {\n\t\treturn this.resultSet;\n\t}\n\n\t/**\n\t * @see java.sql.ResultSetMetaData#getCatalogName(int)\n\t */\n\t@Override\n\tpublic final SqlRowSetMetaData getMetaData() {\n\t\treturn this.rowSetMetaData;\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#findColumn(String)\n\t */\n\t@Override\n\tpublic int findColumn(String columnLabel) throws InvalidResultSetAccessException {\n\t\tInteger columnIndex = this.columnLabelMap.get(columnLabel);\n\t\tif (columnIndex != null) {\n\t\t\treturn columnIndex;\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\treturn this.resultSet.findColumn(columnLabel);\n\t\t\t}\n\t\t\tcatch (SQLException se) {\n\t\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// RowSet methods for extracting data values\n\n\t/**\n\t * @see java.sql.ResultSet#getBigDecimal(int)\n\t */\n\t@Override\n\tpublic @Nullable BigDecimal getBigDecimal(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getBigDecimal(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getBigDecimal(String)\n\t */\n\t@Override\n\tpublic @Nullable BigDecimal getBigDecimal(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getBigDecimal(findColumn(columnLabel));\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getBoolean(int)\n\t */\n\t@Override\n\tpublic boolean getBoolean(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getBoolean(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getBoolean(String)\n\t */\n\t@Override\n\tpublic boolean getBoolean(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getBoolean(findColumn(columnLabel));\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getByte(int)\n\t */\n\t@Override\n\tpublic byte getByte(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getByte(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getByte(String)\n\t */\n\t@Override\n\tpublic byte getByte(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getByte(findColumn(columnLabel));\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getDate(int)\n\t */\n\t@Override\n\tpublic @Nullable Date getDate(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getDate(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getDate(String)\n\t */\n\t@Override\n\tpublic @Nullable Date getDate(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getDate(findColumn(columnLabel));\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getDate(int, Calendar)\n\t */\n\t@Override\n\tpublic @Nullable Date getDate(int columnIndex, Calendar cal) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getDate(columnIndex, cal);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getDate(String, Calendar)\n\t */\n\t@Override\n\tpublic @Nullable Date getDate(String columnLabel, Calendar cal) throws InvalidResultSetAccessException {\n\t\treturn getDate(findColumn(columnLabel), cal);\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getDouble(int)\n\t */\n\t@Override\n\tpublic double getDouble(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getDouble(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getDouble(String)\n\t */\n\t@Override\n\tpublic double getDouble(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getDouble(findColumn(columnLabel));\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getFloat(int)\n\t */\n\t@Override\n\tpublic float getFloat(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getFloat(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getFloat(String)\n\t */\n\t@Override\n\tpublic float getFloat(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getFloat(findColumn(columnLabel));\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getInt(int)\n\t */\n\t@Override\n\tpublic int getInt(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getInt(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getInt(String)\n\t */\n\t@Override\n\tpublic int getInt(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getInt(findColumn(columnLabel));\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getLong(int)\n\t */\n\t@Override\n\tpublic long getLong(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getLong(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getLong(String)\n\t */\n\t@Override\n\tpublic long getLong(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getLong(findColumn(columnLabel));\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getNString(int)\n\t */\n\t@Override\n\tpublic @Nullable String getNString(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getNString(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getNString(String)\n\t */\n\t@Override\n\tpublic @Nullable String getNString(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getNString(findColumn(columnLabel));\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getObject(int)\n\t */\n\t@Override\n\tpublic @Nullable Object getObject(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getObject(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getObject(String)\n\t */\n\t@Override\n\tpublic @Nullable Object getObject(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getObject(findColumn(columnLabel));\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getObject(int, Map)\n\t */\n\t@Override\n\tpublic @Nullable Object getObject(int columnIndex, Map<String, Class<?>> map) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getObject(columnIndex, map);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getObject(String, Map)\n\t */\n\t@Override\n\tpublic @Nullable Object getObject(String columnLabel, Map<String, Class<?>> map) throws InvalidResultSetAccessException {\n\t\treturn getObject(findColumn(columnLabel), map);\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getObject(int, Class)\n\t */\n\t@Override\n\tpublic <T> @Nullable T getObject(int columnIndex, Class<T> type) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getObject(columnIndex, type);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getObject(String, Class)\n\t */\n\t@Override\n\tpublic <T> @Nullable T getObject(String columnLabel, Class<T> type) throws InvalidResultSetAccessException {\n\t\treturn getObject(findColumn(columnLabel), type);\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getShort(int)\n\t */\n\t@Override\n\tpublic short getShort(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getShort(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getShort(String)\n\t */\n\t@Override\n\tpublic short getShort(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getShort(findColumn(columnLabel));\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getString(int)\n\t */\n\t@Override\n\tpublic @Nullable String getString(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getString(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getString(String)\n\t */\n\t@Override\n\tpublic @Nullable String getString(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getString(findColumn(columnLabel));\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getTime(int)\n\t */\n\t@Override\n\tpublic @Nullable Time getTime(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getTime(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getTime(String)\n\t */\n\t@Override\n\tpublic @Nullable Time getTime(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getTime(findColumn(columnLabel));\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getTime(int, Calendar)\n\t */\n\t@Override\n\tpublic @Nullable Time getTime(int columnIndex, Calendar cal) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getTime(columnIndex, cal);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getTime(String, Calendar)\n\t */\n\t@Override\n\tpublic @Nullable Time getTime(String columnLabel, Calendar cal) throws InvalidResultSetAccessException {\n\t\treturn getTime(findColumn(columnLabel), cal);\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getTimestamp(int)\n\t */\n\t@Override\n\tpublic @Nullable Timestamp getTimestamp(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getTimestamp(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getTimestamp(String)\n\t */\n\t@Override\n\tpublic @Nullable Timestamp getTimestamp(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getTimestamp(findColumn(columnLabel));\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getTimestamp(int, Calendar)\n\t */\n\t@Override\n\tpublic @Nullable Timestamp getTimestamp(int columnIndex, Calendar cal) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getTimestamp(columnIndex, cal);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getTimestamp(String, Calendar)\n\t */\n\t@Override\n\tpublic @Nullable Timestamp getTimestamp(String columnLabel, Calendar cal) throws InvalidResultSetAccessException {\n\t\treturn getTimestamp(findColumn(columnLabel), cal);\n\t}\n\n\n\t// RowSet navigation methods\n\n\t/**\n\t * @see java.sql.ResultSet#absolute(int)\n\t */\n\t@Override\n\tpublic boolean absolute(int row) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.absolute(row);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#afterLast()\n\t */\n\t@Override\n\tpublic void afterLast() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\tthis.resultSet.afterLast();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#beforeFirst()\n\t */\n\t@Override\n\tpublic void beforeFirst() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\tthis.resultSet.beforeFirst();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#first()\n\t */\n\t@Override\n\tpublic boolean first() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.first();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#getRow()\n\t */\n\t@Override\n\tpublic int getRow() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getRow();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#isAfterLast()\n\t */\n\t@Override\n\tpublic boolean isAfterLast() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.isAfterLast();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#isBeforeFirst()\n\t */\n\t@Override\n\tpublic boolean isBeforeFirst() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.isBeforeFirst();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#isFirst()\n\t */\n\t@Override\n\tpublic boolean isFirst() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.isFirst();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#isLast()\n\t */\n\t@Override\n\tpublic boolean isLast() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.isLast();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#last()\n\t */\n\t@Override\n\tpublic boolean last() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.last();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#next()\n\t */\n\t@Override\n\tpublic boolean next() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.next();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#previous()\n\t */\n\t@Override\n\tpublic boolean previous() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.previous();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#relative(int)\n\t */\n\t@Override\n\tpublic boolean relative(int rows) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.relative(rows);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t/**\n\t * @see java.sql.ResultSet#wasNull()\n\t */\n\t@Override\n\tpublic boolean wasNull() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.wasNull();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#absolute(row)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#absolute(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "row"
    ],
    "position": {
      "column": 1,
      "line": 579
    },
    "return": "boolean",
    "signature": "public boolean absolute(int row)",
    "source_code": "\tpublic boolean absolute(int row) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.absolute(row);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#afterLast()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#afterLast()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 592
    },
    "return": "void",
    "signature": "public void afterLast()",
    "source_code": "\tpublic void afterLast() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\tthis.resultSet.afterLast();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#beforeFirst()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#beforeFirst()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 605
    },
    "return": "void",
    "signature": "public void beforeFirst()",
    "source_code": "\tpublic void beforeFirst() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\tthis.resultSet.beforeFirst();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#findColumn(columnLabel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#findColumn(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "int",
    "signature": "public int findColumn(String columnLabel)",
    "source_code": "\tpublic int findColumn(String columnLabel) throws InvalidResultSetAccessException {\n\t\tInteger columnIndex = this.columnLabelMap.get(columnLabel);\n\t\tif (columnIndex != null) {\n\t\t\treturn columnIndex;\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\treturn this.resultSet.findColumn(columnLabel);\n\t\t\t}\n\t\t\tcatch (SQLException se) {\n\t\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#first()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#first()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 618
    },
    "return": "boolean",
    "signature": "public boolean first()",
    "source_code": "\tpublic boolean first() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.first();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getBigDecimal(columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getBigDecimal(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "BigDecimal",
    "signature": "public BigDecimal getBigDecimal(int columnIndex)",
    "source_code": "\tpublic @Nullable BigDecimal getBigDecimal(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getBigDecimal(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getBigDecimal(columnLabel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getBigDecimal(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "BigDecimal",
    "signature": "public BigDecimal getBigDecimal(String columnLabel)",
    "source_code": "\tpublic @Nullable BigDecimal getBigDecimal(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getBigDecimal(findColumn(columnLabel));\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getBoolean(columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getBoolean(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "boolean",
    "signature": "public boolean getBoolean(int columnIndex)",
    "source_code": "\tpublic boolean getBoolean(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getBoolean(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getBoolean(columnLabel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getBoolean(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "boolean",
    "signature": "public boolean getBoolean(String columnLabel)",
    "source_code": "\tpublic boolean getBoolean(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getBoolean(findColumn(columnLabel));\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getByte(columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getByte(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "byte",
    "signature": "public byte getByte(int columnIndex)",
    "source_code": "\tpublic byte getByte(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getByte(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getByte(columnLabel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getByte(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "byte",
    "signature": "public byte getByte(String columnLabel)",
    "source_code": "\tpublic byte getByte(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getByte(findColumn(columnLabel));\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getDate(columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getDate(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "Date",
    "signature": "public Date getDate(int columnIndex)",
    "source_code": "\tpublic @Nullable Date getDate(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getDate(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getDate(columnIndex,cal)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getDate(int, Calendar)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex",
      "cal"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "Date",
    "signature": "public Date getDate(int columnIndex, Calendar cal)",
    "source_code": "\tpublic @Nullable Date getDate(int columnIndex, Calendar cal) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getDate(columnIndex, cal);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getDate(columnLabel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getDate(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel"
    ],
    "position": {
      "column": 1,
      "line": 253
    },
    "return": "Date",
    "signature": "public Date getDate(String columnLabel)",
    "source_code": "\tpublic @Nullable Date getDate(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getDate(findColumn(columnLabel));\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getDate(columnLabel,cal)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getDate(String, Calendar)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel",
      "cal"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "Date",
    "signature": "public Date getDate(String columnLabel, Calendar cal)",
    "source_code": "\tpublic @Nullable Date getDate(String columnLabel, Calendar cal) throws InvalidResultSetAccessException {\n\t\treturn getDate(findColumn(columnLabel), cal);\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getDouble(columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getDouble(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "double",
    "signature": "public double getDouble(int columnIndex)",
    "source_code": "\tpublic double getDouble(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getDouble(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getDouble(columnLabel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getDouble(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "double",
    "signature": "public double getDouble(String columnLabel)",
    "source_code": "\tpublic double getDouble(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getDouble(findColumn(columnLabel));\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getFloat(columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getFloat(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "float",
    "signature": "public float getFloat(int columnIndex)",
    "source_code": "\tpublic float getFloat(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getFloat(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getFloat(columnLabel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getFloat(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "float",
    "signature": "public float getFloat(String columnLabel)",
    "source_code": "\tpublic float getFloat(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getFloat(findColumn(columnLabel));\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getInt(columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getInt(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "int",
    "signature": "public int getInt(int columnIndex)",
    "source_code": "\tpublic int getInt(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getInt(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getInt(columnLabel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getInt(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "int",
    "signature": "public int getInt(String columnLabel)",
    "source_code": "\tpublic int getInt(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getInt(findColumn(columnLabel));\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getLong(columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getLong(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "long",
    "signature": "public long getLong(int columnIndex)",
    "source_code": "\tpublic long getLong(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getLong(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getLong(columnLabel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getLong(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel"
    ],
    "position": {
      "column": 1,
      "line": 358
    },
    "return": "long",
    "signature": "public long getLong(String columnLabel)",
    "source_code": "\tpublic long getLong(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getLong(findColumn(columnLabel));\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getMetaData()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSetMetaData#getCatalogName(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "SqlRowSetMetaData",
    "signature": "public SqlRowSetMetaData getMetaData()",
    "source_code": "\tpublic final SqlRowSetMetaData getMetaData() {\n\t\treturn this.rowSetMetaData;\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getNString(columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getNString(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "String",
    "signature": "public String getNString(int columnIndex)",
    "source_code": "\tpublic @Nullable String getNString(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getNString(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getNString(columnLabel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getNString(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "String",
    "signature": "public String getNString(String columnLabel)",
    "source_code": "\tpublic @Nullable String getNString(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getNString(findColumn(columnLabel));\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getObject(columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getObject(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 387
    },
    "return": "Object",
    "signature": "public Object getObject(int columnIndex)",
    "source_code": "\tpublic @Nullable Object getObject(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getObject(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getObject(columnIndex,Map<String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getObject(int, Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex",
      "Map<String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "Object",
    "signature": "public Object getObject(int columnIndex, Map<String, Class<?>> map)",
    "source_code": "\tpublic @Nullable Object getObject(int columnIndex, Map<String, Class<?>> map) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getObject(columnIndex, map);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getObject(columnIndex,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getObject(int, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "T",
    "signature": "public T getObject(int columnIndex, Class<T> type)",
    "source_code": "\tpublic <T> @Nullable T getObject(int columnIndex, Class<T> type) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getObject(columnIndex, type);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getObject(columnLabel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getObject(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel"
    ],
    "position": {
      "column": 1,
      "line": 400
    },
    "return": "Object",
    "signature": "public Object getObject(String columnLabel)",
    "source_code": "\tpublic @Nullable Object getObject(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getObject(findColumn(columnLabel));\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getObject(columnLabel,Map<String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getObject(String, Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel",
      "Map<String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 421
    },
    "return": "Object",
    "signature": "public Object getObject(String columnLabel, Map<String, Class<?>> map)",
    "source_code": "\tpublic @Nullable Object getObject(String columnLabel, Map<String, Class<?>> map) throws InvalidResultSetAccessException {\n\t\treturn getObject(findColumn(columnLabel), map);\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getObject(columnLabel,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getObject(String, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 442
    },
    "return": "T",
    "signature": "public T getObject(String columnLabel, Class<T> type)",
    "source_code": "\tpublic <T> @Nullable T getObject(String columnLabel, Class<T> type) throws InvalidResultSetAccessException {\n\t\treturn getObject(findColumn(columnLabel), type);\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getResultSet()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the underlying ResultSet\n\t * (usually a {@code javax.sql.rowset.CachedRowSet}).\n\t * @see javax.sql.rowset.CachedRowSet\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "ResultSet",
    "signature": "public ResultSet getResultSet()",
    "source_code": "\tpublic final ResultSet getResultSet() {\n\t\treturn this.resultSet;\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getRow()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getRow()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 631
    },
    "return": "int",
    "signature": "public int getRow()",
    "source_code": "\tpublic int getRow() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getRow();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getShort(columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getShort(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 450
    },
    "return": "short",
    "signature": "public short getShort(int columnIndex)",
    "source_code": "\tpublic short getShort(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getShort(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getShort(columnLabel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getShort(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel"
    ],
    "position": {
      "column": 1,
      "line": 463
    },
    "return": "short",
    "signature": "public short getShort(String columnLabel)",
    "source_code": "\tpublic short getShort(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getShort(findColumn(columnLabel));\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getString(columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getString(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "String",
    "signature": "public String getString(int columnIndex)",
    "source_code": "\tpublic @Nullable String getString(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getString(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getString(columnLabel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getString(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel"
    ],
    "position": {
      "column": 1,
      "line": 484
    },
    "return": "String",
    "signature": "public String getString(String columnLabel)",
    "source_code": "\tpublic @Nullable String getString(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getString(findColumn(columnLabel));\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getTime(columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getTime(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 492
    },
    "return": "Time",
    "signature": "public Time getTime(int columnIndex)",
    "source_code": "\tpublic @Nullable Time getTime(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getTime(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getTime(columnIndex,cal)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getTime(int, Calendar)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex",
      "cal"
    ],
    "position": {
      "column": 1,
      "line": 513
    },
    "return": "Time",
    "signature": "public Time getTime(int columnIndex, Calendar cal)",
    "source_code": "\tpublic @Nullable Time getTime(int columnIndex, Calendar cal) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getTime(columnIndex, cal);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getTime(columnLabel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getTime(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel"
    ],
    "position": {
      "column": 1,
      "line": 505
    },
    "return": "Time",
    "signature": "public Time getTime(String columnLabel)",
    "source_code": "\tpublic @Nullable Time getTime(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getTime(findColumn(columnLabel));\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getTime(columnLabel,cal)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getTime(String, Calendar)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel",
      "cal"
    ],
    "position": {
      "column": 1,
      "line": 526
    },
    "return": "Time",
    "signature": "public Time getTime(String columnLabel, Calendar cal)",
    "source_code": "\tpublic @Nullable Time getTime(String columnLabel, Calendar cal) throws InvalidResultSetAccessException {\n\t\treturn getTime(findColumn(columnLabel), cal);\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getTimestamp(columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getTimestamp(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "Timestamp",
    "signature": "public Timestamp getTimestamp(int columnIndex)",
    "source_code": "\tpublic @Nullable Timestamp getTimestamp(int columnIndex) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getTimestamp(columnIndex);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getTimestamp(columnIndex,cal)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getTimestamp(int, Calendar)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex",
      "cal"
    ],
    "position": {
      "column": 1,
      "line": 555
    },
    "return": "Timestamp",
    "signature": "public Timestamp getTimestamp(int columnIndex, Calendar cal)",
    "source_code": "\tpublic @Nullable Timestamp getTimestamp(int columnIndex, Calendar cal) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getTimestamp(columnIndex, cal);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getTimestamp(columnLabel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getTimestamp(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel"
    ],
    "position": {
      "column": 1,
      "line": 547
    },
    "return": "Timestamp",
    "signature": "public Timestamp getTimestamp(String columnLabel)",
    "source_code": "\tpublic @Nullable Timestamp getTimestamp(String columnLabel) throws InvalidResultSetAccessException {\n\t\treturn getTimestamp(findColumn(columnLabel));\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getTimestamp(columnLabel,cal)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getTimestamp(String, Calendar)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel",
      "cal"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "Timestamp",
    "signature": "public Timestamp getTimestamp(String columnLabel, Calendar cal)",
    "source_code": "\tpublic @Nullable Timestamp getTimestamp(String columnLabel, Calendar cal) throws InvalidResultSetAccessException {\n\t\treturn getTimestamp(findColumn(columnLabel), cal);\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#isAfterLast()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#isAfterLast()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 644
    },
    "return": "boolean",
    "signature": "public boolean isAfterLast()",
    "source_code": "\tpublic boolean isAfterLast() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.isAfterLast();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#isBeforeFirst()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#isBeforeFirst()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 657
    },
    "return": "boolean",
    "signature": "public boolean isBeforeFirst()",
    "source_code": "\tpublic boolean isBeforeFirst() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.isBeforeFirst();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#isFirst()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#isFirst()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 670
    },
    "return": "boolean",
    "signature": "public boolean isFirst()",
    "source_code": "\tpublic boolean isFirst() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.isFirst();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#isLast()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#isLast()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 683
    },
    "return": "boolean",
    "signature": "public boolean isLast()",
    "source_code": "\tpublic boolean isLast() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.isLast();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#last()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#last()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 696
    },
    "return": "boolean",
    "signature": "public boolean last()",
    "source_code": "\tpublic boolean last() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.last();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#next()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#next()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 709
    },
    "return": "boolean",
    "signature": "public boolean next()",
    "source_code": "\tpublic boolean next() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.next();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#previous()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#previous()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 722
    },
    "return": "boolean",
    "signature": "public boolean previous()",
    "source_code": "\tpublic boolean previous() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.previous();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#relative(rows)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#relative(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rows"
    ],
    "position": {
      "column": 1,
      "line": 735
    },
    "return": "boolean",
    "signature": "public boolean relative(int rows)",
    "source_code": "\tpublic boolean relative(int rows) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.relative(rows);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#wasNull()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#wasNull()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 748
    },
    "return": "boolean",
    "signature": "public boolean wasNull()",
    "source_code": "\tpublic boolean wasNull() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.wasNull();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSetMetaData": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * The default implementation of Spring's {@link SqlRowSetMetaData} interface, wrapping a\n * {@link java.sql.ResultSetMetaData} instance, catching any {@link SQLException SQLExceptions}\n * and translating them to a corresponding Spring {@link InvalidResultSetAccessException}.\n *\n * <p>Used by {@link ResultSetWrappingSqlRowSet}.\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @since 1.2\n * @see ResultSetWrappingSqlRowSet#getMetaData()\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class ResultSetWrappingSqlRowSetMetaData",
    "source_code": "public class ResultSetWrappingSqlRowSetMetaData implements SqlRowSetMetaData {\n\n\tprivate final ResultSetMetaData resultSetMetaData;\n\n\tprivate String @Nullable [] columnNames;\n\n\n\t/**\n\t * Create a new ResultSetWrappingSqlRowSetMetaData object\n\t * for the given ResultSetMetaData instance.\n\t * @param resultSetMetaData a disconnected ResultSetMetaData instance\n\t * to wrap (usually a {@code javax.sql.RowSetMetaData} instance)\n\t * @see java.sql.ResultSet#getMetaData\n\t * @see javax.sql.RowSetMetaData\n\t * @see ResultSetWrappingSqlRowSet#getMetaData\n\t */\n\tpublic ResultSetWrappingSqlRowSetMetaData(ResultSetMetaData resultSetMetaData) {\n\t\tthis.resultSetMetaData = resultSetMetaData;\n\t}\n\n\n\t@Override\n\tpublic String getCatalogName(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getCatalogName(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getColumnClassName(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getColumnClassName(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnCount() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getColumnCount();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String[] getColumnNames() throws InvalidResultSetAccessException {\n\t\tif (this.columnNames == null) {\n\t\t\tthis.columnNames = new String[getColumnCount()];\n\t\t\tfor (int i = 0; i < getColumnCount(); i++) {\n\t\t\t\tthis.columnNames[i] = getColumnName(i + 1);\n\t\t\t}\n\t\t}\n\t\treturn this.columnNames;\n\t}\n\n\t@Override\n\tpublic int getColumnDisplaySize(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getColumnDisplaySize(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getColumnLabel(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getColumnLabel(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getColumnName(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getColumnName(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnType(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getColumnType(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getColumnTypeName(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getColumnTypeName(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getPrecision(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getPrecision(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getScale(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getScale(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getSchemaName(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getSchemaName(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getTableName(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getTableName(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isCaseSensitive(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.isCaseSensitive(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isCurrency(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.isCurrency(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isSigned(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.isSigned(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSetMetaData#getCatalogName(column)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "column"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "String",
    "signature": "public String getCatalogName(int column)",
    "source_code": "\tpublic String getCatalogName(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getCatalogName(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSetMetaData#getColumnClassName(column)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "column"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "String",
    "signature": "public String getColumnClassName(int column)",
    "source_code": "\tpublic String getColumnClassName(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getColumnClassName(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSetMetaData#getColumnCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "int",
    "signature": "public int getColumnCount()",
    "source_code": "\tpublic int getColumnCount() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getColumnCount();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSetMetaData#getColumnDisplaySize(column)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "column"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "int",
    "signature": "public int getColumnDisplaySize(int column)",
    "source_code": "\tpublic int getColumnDisplaySize(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getColumnDisplaySize(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSetMetaData#getColumnLabel(column)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "column"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "String",
    "signature": "public String getColumnLabel(int column)",
    "source_code": "\tpublic String getColumnLabel(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getColumnLabel(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSetMetaData#getColumnName(column)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "column"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "String",
    "signature": "public String getColumnName(int column)",
    "source_code": "\tpublic String getColumnName(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getColumnName(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSetMetaData#getColumnNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "String[]",
    "signature": "public String[] getColumnNames()",
    "source_code": "\tpublic String[] getColumnNames() throws InvalidResultSetAccessException {\n\t\tif (this.columnNames == null) {\n\t\t\tthis.columnNames = new String[getColumnCount()];\n\t\t\tfor (int i = 0; i < getColumnCount(); i++) {\n\t\t\t\tthis.columnNames[i] = getColumnName(i + 1);\n\t\t\t}\n\t\t}\n\t\treturn this.columnNames;\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSetMetaData#getColumnType(column)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "column"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "int",
    "signature": "public int getColumnType(int column)",
    "source_code": "\tpublic int getColumnType(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getColumnType(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSetMetaData#getColumnTypeName(column)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "column"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "String",
    "signature": "public String getColumnTypeName(int column)",
    "source_code": "\tpublic String getColumnTypeName(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getColumnTypeName(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSetMetaData#getPrecision(column)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "column"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "int",
    "signature": "public int getPrecision(int column)",
    "source_code": "\tpublic int getPrecision(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getPrecision(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSetMetaData#getScale(column)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "column"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "int",
    "signature": "public int getScale(int column)",
    "source_code": "\tpublic int getScale(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getScale(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSetMetaData#getSchemaName(column)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "column"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "String",
    "signature": "public String getSchemaName(int column)",
    "source_code": "\tpublic String getSchemaName(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getSchemaName(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSetMetaData#getTableName(column)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "column"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "String",
    "signature": "public String getTableName(int column)",
    "source_code": "\tpublic String getTableName(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.getTableName(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSetMetaData#isCaseSensitive(column)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "column"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "boolean",
    "signature": "public boolean isCaseSensitive(int column)",
    "source_code": "\tpublic boolean isCaseSensitive(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.isCaseSensitive(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSetMetaData#isCurrency(column)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "column"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "boolean",
    "signature": "public boolean isCurrency(int column)",
    "source_code": "\tpublic boolean isCurrency(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.isCurrency(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSetMetaData#isSigned(column)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "column"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "boolean",
    "signature": "public boolean isSigned(int column)",
    "source_code": "\tpublic boolean isSigned(int column) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSetMetaData.isSigned(column);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.SqlRowSet": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Mirror interface for {@link javax.sql.RowSet}, representing a disconnected variant of\n * {@link java.sql.ResultSet} data.\n *\n * <p>The main difference to the standard JDBC RowSet is that a {@link java.sql.SQLException}\n * is never thrown here. This allows an SqlRowSet to be used without having to deal with\n * checked exceptions. An SqlRowSet will throw Spring's {@link InvalidResultSetAccessException}\n * instead (when appropriate).\n *\n * <p>Note: This interface extends the {@code java.io.Serializable} marker interface.\n * Implementations, which typically hold disconnected data, are encouraged to be actually\n * serializable (as far as possible).\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @since 1.2\n * @see javax.sql.RowSet\n * @see java.sql.ResultSet\n * @see org.springframework.jdbc.InvalidResultSetAccessException\n * @see org.springframework.jdbc.core.JdbcTemplate#queryForRowSet\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public interface SqlRowSet",
    "source_code": "public interface SqlRowSet extends Serializable {\n\n\t/**\n\t * Retrieve the meta-data, i.e. number, types and properties\n\t * for the columns of this row set.\n\t * @return a corresponding SqlRowSetMetaData instance\n\t * @see java.sql.ResultSet#getMetaData()\n\t */\n\tSqlRowSetMetaData getMetaData();\n\n\t/**\n\t * Map the given column label to its column index.\n\t * @param columnLabel the name of the column\n\t * @return the column index for the given column label\n\t * @see java.sql.ResultSet#findColumn(String)\n\t */\n\tint findColumn(String columnLabel) throws InvalidResultSetAccessException;\n\n\n\t// RowSet methods for extracting data values\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a BigDecimal object.\n\t * @param columnIndex the column index\n\t * @return an BigDecimal object representing the column value\n\t * @see java.sql.ResultSet#getBigDecimal(int)\n\t */\n\t@Nullable BigDecimal getBigDecimal(int columnIndex) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a BigDecimal object.\n\t * @param columnLabel the column label\n\t * @return an BigDecimal object representing the column value\n\t * @see java.sql.ResultSet#getBigDecimal(String)\n\t */\n\t@Nullable BigDecimal getBigDecimal(String columnLabel) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a boolean.\n\t * @param columnIndex the column index\n\t * @return a boolean representing the column value\n\t * @see java.sql.ResultSet#getBoolean(int)\n\t */\n\tboolean getBoolean(int columnIndex) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a boolean.\n\t * @param columnLabel the column label\n\t * @return a boolean representing the column value\n\t * @see java.sql.ResultSet#getBoolean(String)\n\t */\n\tboolean getBoolean(String columnLabel) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a byte.\n\t * @param columnIndex the column index\n\t * @return a byte representing the column value\n\t * @see java.sql.ResultSet#getByte(int)\n\t */\n\tbyte getByte(int columnIndex) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a byte.\n\t * @param columnLabel the column label\n\t * @return a byte representing the column value\n\t * @see java.sql.ResultSet#getByte(String)\n\t */\n\tbyte getByte(String columnLabel) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a Date object.\n\t * @param columnIndex the column index\n\t * @return a Date object representing the column value\n\t * @see java.sql.ResultSet#getDate(int)\n\t */\n\t@Nullable Date getDate(int columnIndex) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a Date object.\n\t * @param columnLabel the column label\n\t * @return a Date object representing the column value\n\t * @see java.sql.ResultSet#getDate(String)\n\t */\n\t@Nullable Date getDate(String columnLabel) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a Date object.\n\t * @param columnIndex the column index\n\t * @param cal the Calendar to use in constructing the Date\n\t * @return a Date object representing the column value\n\t * @see java.sql.ResultSet#getDate(int, Calendar)\n\t */\n\t@Nullable Date getDate(int columnIndex, Calendar cal) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a Date object.\n\t * @param columnLabel the column label\n\t * @param cal the Calendar to use in constructing the Date\n\t * @return a Date object representing the column value\n\t * @see java.sql.ResultSet#getDate(String, Calendar)\n\t */\n\t@Nullable Date getDate(String columnLabel, Calendar cal) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a Double object.\n\t * @param columnIndex the column index\n\t * @return a Double object representing the column value\n\t * @see java.sql.ResultSet#getDouble(int)\n\t */\n\tdouble getDouble(int columnIndex) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a Double object.\n\t * @param columnLabel the column label\n\t * @return a Double object representing the column value\n\t * @see java.sql.ResultSet#getDouble(String)\n\t */\n\tdouble getDouble(String columnLabel) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a float.\n\t * @param columnIndex the column index\n\t * @return a float representing the column value\n\t * @see java.sql.ResultSet#getFloat(int)\n\t */\n\tfloat getFloat(int columnIndex) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a float.\n\t * @param columnLabel the column label\n\t * @return a float representing the column value\n\t * @see java.sql.ResultSet#getFloat(String)\n\t */\n\tfloat getFloat(String columnLabel) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as an int.\n\t * @param columnIndex the column index\n\t * @return an int representing the column value\n\t * @see java.sql.ResultSet#getInt(int)\n\t */\n\tint getInt(int columnIndex) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as an int.\n\t * @param columnLabel the column label\n\t * @return an int representing the column value\n\t * @see java.sql.ResultSet#getInt(String)\n\t */\n\tint getInt(String columnLabel) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a long.\n\t * @param columnIndex the column index\n\t * @return a long representing the column value\n\t * @see java.sql.ResultSet#getLong(int)\n\t */\n\tlong getLong(int columnIndex) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a long.\n\t * @param columnLabel the column label\n\t * @return a long representing the column value\n\t * @see java.sql.ResultSet#getLong(String)\n\t */\n\tlong getLong(String columnLabel) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a String\n\t * (for NCHAR, NVARCHAR, LONGNVARCHAR columns).\n\t * @param columnIndex the column index\n\t * @return a String representing the column value\n\t * @since 4.1.3\n\t * @see java.sql.ResultSet#getNString(int)\n\t */\n\t@Nullable String getNString(int columnIndex) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a String\n\t * (for NCHAR, NVARCHAR, LONGNVARCHAR columns).\n\t * @param columnLabel the column label\n\t * @return a String representing the column value\n\t * @since 4.1.3\n\t * @see java.sql.ResultSet#getNString(String)\n\t */\n\t@Nullable String getNString(String columnLabel) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as an Object.\n\t * @param columnIndex the column index\n\t * @return an Object representing the column value\n\t * @see java.sql.ResultSet#getObject(int)\n\t */\n\t@Nullable Object getObject(int columnIndex) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as an Object.\n\t * @param columnLabel the column label\n\t * @return an Object representing the column value\n\t * @see java.sql.ResultSet#getObject(String)\n\t */\n\t@Nullable Object getObject(String columnLabel) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as an Object.\n\t * @param columnIndex the column index\n\t * @param map a Map object containing the mapping from SQL types to Java types\n\t * @return an Object representing the column value\n\t * @see java.sql.ResultSet#getObject(int, Map)\n\t */\n\t@Nullable Object getObject(int columnIndex, Map<String, Class<?>> map) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as an Object.\n\t * @param columnLabel the column label\n\t * @param map a Map object containing the mapping from SQL types to Java types\n\t * @return an Object representing the column value\n\t * @see java.sql.ResultSet#getObject(String, Map)\n\t */\n\t@Nullable Object getObject(String columnLabel, Map<String, Class<?>> map) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as an Object.\n\t * @param columnIndex the column index\n\t * @param type the Java type to convert the designated column to\n\t * @return an Object representing the column value\n\t * @since 4.1.3\n\t * @see java.sql.ResultSet#getObject(int, Class)\n\t */\n\t<T> @Nullable T getObject(int columnIndex, Class<T> type) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as an Object.\n\t * @param columnLabel the column label\n\t * @param type the Java type to convert the designated column to\n\t * @return an Object representing the column value\n\t * @since 4.1.3\n\t * @see java.sql.ResultSet#getObject(String, Class)\n\t */\n\t<T> @Nullable T getObject(String columnLabel, Class<T> type) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a short.\n\t * @param columnIndex the column index\n\t * @return a short representing the column value\n\t * @see java.sql.ResultSet#getShort(int)\n\t */\n\tshort getShort(int columnIndex) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a short.\n\t * @param columnLabel the column label\n\t * @return a short representing the column value\n\t * @see java.sql.ResultSet#getShort(String)\n\t */\n\tshort getShort(String columnLabel) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a String.\n\t * @param columnIndex the column index\n\t * @return a String representing the column value\n\t * @see java.sql.ResultSet#getString(int)\n\t */\n\t@Nullable String getString(int columnIndex) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a String.\n\t * @param columnLabel the column label\n\t * @return a String representing the column value\n\t * @see java.sql.ResultSet#getString(String)\n\t */\n\t@Nullable String getString(String columnLabel) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a Time object.\n\t * @param columnIndex the column index\n\t * @return a Time object representing the column value\n\t * @see java.sql.ResultSet#getTime(int)\n\t */\n\t@Nullable Time getTime(int columnIndex) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a Time object.\n\t * @param columnLabel the column label\n\t * @return a Time object representing the column value\n\t * @see java.sql.ResultSet#getTime(String)\n\t */\n\t@Nullable Time getTime(String columnLabel) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a Time object.\n\t * @param columnIndex the column index\n\t * @param cal the Calendar to use in constructing the Date\n\t * @return a Time object representing the column value\n\t * @see java.sql.ResultSet#getTime(int, Calendar)\n\t */\n\t@Nullable Time getTime(int columnIndex, Calendar cal) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a Time object.\n\t * @param columnLabel the column label\n\t * @param cal the Calendar to use in constructing the Date\n\t * @return a Time object representing the column value\n\t * @see java.sql.ResultSet#getTime(String, Calendar)\n\t */\n\t@Nullable Time getTime(String columnLabel, Calendar cal) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a Timestamp object.\n\t * @param columnIndex the column index\n\t * @return a Timestamp object representing the column value\n\t * @see java.sql.ResultSet#getTimestamp(int)\n\t */\n\t@Nullable Timestamp getTimestamp(int columnIndex) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a Timestamp object.\n\t * @param columnLabel the column label\n\t * @return a Timestamp object representing the column value\n\t * @see java.sql.ResultSet#getTimestamp(String)\n\t */\n\t@Nullable Timestamp getTimestamp(String columnLabel) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a Timestamp object.\n\t * @param columnIndex the column index\n\t * @param cal the Calendar to use in constructing the Date\n\t * @return a Timestamp object representing the column value\n\t * @see java.sql.ResultSet#getTimestamp(int, Calendar)\n\t */\n\t@Nullable Timestamp getTimestamp(int columnIndex, Calendar cal) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the value of the indicated column in the current row as a Timestamp object.\n\t * @param columnLabel the column label\n\t * @param cal the Calendar to use in constructing the Date\n\t * @return a Timestamp object representing the column value\n\t * @see java.sql.ResultSet#getTimestamp(String, Calendar)\n\t */\n\t@Nullable Timestamp getTimestamp(String columnLabel, Calendar cal) throws InvalidResultSetAccessException;\n\n\n\t// RowSet navigation methods\n\n\t/**\n\t * Move the cursor to the given row number in the row set, just after the last row.\n\t * @param row the number of the row where the cursor should move\n\t * @return {@code true} if the cursor is on the row set, {@code false} otherwise\n\t * @see java.sql.ResultSet#absolute(int)\n\t */\n\tboolean absolute(int row) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Move the cursor to the end of this row set.\n\t * @see java.sql.ResultSet#afterLast()\n\t */\n\tvoid afterLast() throws InvalidResultSetAccessException;\n\n\t/**\n\t * Move the cursor to the front of this row set, just before the first row.\n\t * @see java.sql.ResultSet#beforeFirst()\n\t */\n\tvoid beforeFirst() throws InvalidResultSetAccessException;\n\n\t/**\n\t * Move the cursor to the first row of this row set.\n\t * @return {@code true} if the cursor is on a valid row, {@code false} otherwise\n\t * @see java.sql.ResultSet#first()\n\t */\n\tboolean first() throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve the current row number.\n\t * @return the current row number\n\t * @see java.sql.ResultSet#getRow()\n\t */\n\tint getRow() throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve whether the cursor is after the last row of this row set.\n\t * @return {@code true} if the cursor is after the last row, {@code false} otherwise\n\t * @see java.sql.ResultSet#isAfterLast()\n\t */\n\tboolean isAfterLast() throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve whether the cursor is before the first row of this row set.\n\t * @return {@code true} if the cursor is before the first row, {@code false} otherwise\n\t * @see java.sql.ResultSet#isBeforeFirst()\n\t */\n\tboolean isBeforeFirst() throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve whether the cursor is on the first row of this row set.\n\t * @return {@code true} if the cursor is after the first row, {@code false} otherwise\n\t * @see java.sql.ResultSet#isFirst()\n\t */\n\tboolean isFirst() throws InvalidResultSetAccessException;\n\n\t/**\n\t * Retrieve whether the cursor is on the last row of this row set.\n\t * @return {@code true} if the cursor is after the last row, {@code false} otherwise\n\t * @see java.sql.ResultSet#isLast()\n\t */\n\tboolean isLast() throws InvalidResultSetAccessException;\n\n\t/**\n\t * Move the cursor to the last row of this row set.\n\t * @return {@code true} if the cursor is on a valid row, {@code false} otherwise\n\t * @see java.sql.ResultSet#last()\n\t */\n\tboolean last() throws InvalidResultSetAccessException;\n\n\t/**\n\t * Move the cursor to the next row.\n\t * @return {@code true} if the new row is valid, {@code false} if there are no more rows\n\t * @see java.sql.ResultSet#next()\n\t */\n\tboolean next() throws InvalidResultSetAccessException;\n\n\t/**\n\t * Move the cursor to the previous row.\n\t * @return {@code true} if the new row is valid, {@code false} if it is off the row set\n\t * @see java.sql.ResultSet#previous()\n\t */\n\tboolean previous() throws InvalidResultSetAccessException;\n\n\t/**\n\t * Move the cursor a relative number of rows, either positive or negative.\n\t * @return {@code true} if the cursor is on a row, {@code false} otherwise\n\t * @see java.sql.ResultSet#relative(int)\n\t */\n\tboolean relative(int rows) throws InvalidResultSetAccessException;\n\n\t/**\n\t * Report whether the last column read had a value of SQL {@code NULL}.\n\t * <p>Note that you must first call one of the getter methods and then\n\t * call the {@code wasNull()} method.\n\t * @return {@code true} if the most recent column retrieved was\n\t * SQL {@code NULL}, {@code false} otherwise\n\t * @see java.sql.ResultSet#wasNull()\n\t */\n\tboolean wasNull() throws InvalidResultSetAccessException;\n\n}"
  },
  "org.springframework.jms.connection.JmsResourceHolder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Resource holder wrapping a JMS {@link Connection} and a JMS {@link Session}.\n * {@link JmsTransactionManager} binds instances of this class to the thread,\n * for a given JMS {@link ConnectionFactory}.\n *\n * <p>Note: This is an SPI class, not intended to be used by applications.\n *\n * @author Juergen Hoeller\n * @since 1.1\n * @see JmsTransactionManager\n * @see org.springframework.jms.core.JmsTemplate\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public class JmsResourceHolder",
    "source_code": "public class JmsResourceHolder extends ResourceHolderSupport {\n\n\tprivate static final Log logger = LogFactory.getLog(JmsResourceHolder.class);\n\n\tprivate @Nullable ConnectionFactory connectionFactory;\n\n\tprivate boolean frozen = false;\n\n\tprivate final Deque<Connection> connections = new ArrayDeque<>();\n\n\tprivate final Deque<Session> sessions = new ArrayDeque<>();\n\n\tprivate final Map<Connection, Deque<Session>> sessionsPerConnection = new HashMap<>();\n\n\n\t/**\n\t * Create a new JmsResourceHolder that is open for resources to be added.\n\t * @see #addConnection\n\t * @see #addSession\n\t */\n\tpublic JmsResourceHolder() {\n\t}\n\n\t/**\n\t * Create a new JmsResourceHolder that is open for resources to be added.\n\t * @param connectionFactory the JMS ConnectionFactory that this\n\t * resource holder is associated with (may be {@code null})\n\t */\n\tpublic JmsResourceHolder(@Nullable ConnectionFactory connectionFactory) {\n\t\tthis.connectionFactory = connectionFactory;\n\t}\n\n\t/**\n\t * Create a new JmsResourceHolder for the given JMS Session.\n\t * @param session the JMS Session\n\t */\n\tpublic JmsResourceHolder(Session session) {\n\t\taddSession(session);\n\t\tthis.frozen = true;\n\t}\n\n\t/**\n\t * Create a new JmsResourceHolder for the given JMS resources.\n\t * @param connection the JMS Connection\n\t * @param session the JMS Session\n\t */\n\tpublic JmsResourceHolder(Connection connection, Session session) {\n\t\taddConnection(connection);\n\t\taddSession(session, connection);\n\t\tthis.frozen = true;\n\t}\n\n\t/**\n\t * Create a new JmsResourceHolder for the given JMS resources.\n\t * @param connectionFactory the JMS ConnectionFactory that this\n\t * resource holder is associated with (may be {@code null})\n\t * @param connection the JMS Connection\n\t * @param session the JMS Session\n\t */\n\tpublic JmsResourceHolder(@Nullable ConnectionFactory connectionFactory, Connection connection, Session session) {\n\t\tthis.connectionFactory = connectionFactory;\n\t\taddConnection(connection);\n\t\taddSession(session, connection);\n\t\tthis.frozen = true;\n\t}\n\n\n\t/**\n\t * Return whether this resource holder is frozen, i.e. does not\n\t * allow for adding further Connections and Sessions to it.\n\t * @see #addConnection\n\t * @see #addSession\n\t */\n\tpublic final boolean isFrozen() {\n\t\treturn this.frozen;\n\t}\n\n\t/**\n\t * Add the given Connection to this resource holder.\n\t */\n\tpublic final void addConnection(Connection connection) {\n\t\tAssert.isTrue(!this.frozen, \"Cannot add Connection because JmsResourceHolder is frozen\");\n\t\tAssert.notNull(connection, \"Connection must not be null\");\n\t\tif (!this.connections.contains(connection)) {\n\t\t\tthis.connections.add(connection);\n\t\t}\n\t}\n\n\t/**\n\t * Add the given Session to this resource holder.\n\t */\n\tpublic final void addSession(Session session) {\n\t\taddSession(session, null);\n\t}\n\n\t/**\n\t * Add the given Session to this resource holder,\n\t * registered for a specific Connection.\n\t */\n\tpublic final void addSession(Session session, @Nullable Connection connection) {\n\t\tAssert.isTrue(!this.frozen, \"Cannot add Session because JmsResourceHolder is frozen\");\n\t\tAssert.notNull(session, \"Session must not be null\");\n\t\tif (!this.sessions.contains(session)) {\n\t\t\tthis.sessions.add(session);\n\t\t\tif (connection != null) {\n\t\t\t\tDeque<Session> sessions =\n\t\t\t\t\t\tthis.sessionsPerConnection.computeIfAbsent(connection, k -> new ArrayDeque<>());\n\t\t\t\tsessions.add(session);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether the given Session is registered\n\t * with this resource holder.\n\t */\n\tpublic boolean containsSession(Session session) {\n\t\treturn this.sessions.contains(session);\n\t}\n\n\n\t/**\n\t * Return this resource holder's default Connection,\n\t * or {@code null} if none.\n\t */\n\tpublic @Nullable Connection getConnection() {\n\t\treturn this.connections.peek();\n\t}\n\n\t/**\n\t * Return this resource holder's Connection of the given type,\n\t * or {@code null} if none.\n\t */\n\tpublic <C extends Connection> @Nullable C getConnection(Class<C> connectionType) {\n\t\treturn CollectionUtils.findValueOfType(this.connections, connectionType);\n\t}\n\n\t/**\n\t * Return an existing original Session, if any.\n\t * <p>In contrast to {@link #getSession()}, this must not lazily initialize\n\t * a new Session, not even in {@link JmsResourceHolder} subclasses.\n\t */\n\t@Nullable Session getOriginalSession() {\n\t\treturn this.sessions.peek();\n\t}\n\n\t/**\n\t * Return this resource holder's default Session,\n\t * or {@code null} if none.\n\t */\n\tpublic @Nullable Session getSession() {\n\t\treturn this.sessions.peek();\n\t}\n\n\t/**\n\t * Return this resource holder's Session of the given type,\n\t * or {@code null} if none.\n\t */\n\tpublic <S extends Session> @Nullable S getSession(Class<S> sessionType) {\n\t\treturn getSession(sessionType, null);\n\t}\n\n\t/**\n\t * Return this resource holder's Session of the given type\n\t * for the given connection, or {@code null} if none.\n\t */\n\tpublic <S extends Session> @Nullable S getSession(Class<S> sessionType, @Nullable Connection connection) {\n\t\tDeque<Session> sessions =\n\t\t\t\t(connection != null ? this.sessionsPerConnection.get(connection) : this.sessions);\n\t\treturn CollectionUtils.findValueOfType(sessions, sessionType);\n\t}\n\n\n\t/**\n\t * Commit all of this resource holder's Sessions.\n\t * @throws JMSException if thrown from a Session commit attempt\n\t * @see Session#commit()\n\t */\n\tpublic void commitAll() throws JMSException {\n\t\tfor (Session session : this.sessions) {\n\t\t\ttry {\n\t\t\t\tsession.commit();\n\t\t\t}\n\t\t\tcatch (TransactionInProgressException ex) {\n\t\t\t\t// Ignore -> can only happen in case of a JTA transaction.\n\t\t\t}\n\t\t\tcatch (jakarta.jms.IllegalStateException ex) {\n\t\t\t\tif (this.connectionFactory != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tMethod getDataSourceMethod = this.connectionFactory.getClass().getMethod(\"getDataSource\");\n\t\t\t\t\t\tObject ds = ReflectionUtils.invokeMethod(getDataSourceMethod, this.connectionFactory);\n\t\t\t\t\t\twhile (ds != null) {\n\t\t\t\t\t\t\tif (TransactionSynchronizationManager.hasResource(ds)) {\n\t\t\t\t\t\t\t\t// IllegalStateException from sharing the underlying JDBC Connection\n\t\t\t\t\t\t\t\t// which typically gets committed first, for example, with Oracle AQ --> ignore\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t// Check for decorated DataSource a la Spring's DelegatingDataSource\n\t\t\t\t\t\t\t\tMethod getTargetDataSourceMethod = ds.getClass().getMethod(\"getTargetDataSource\");\n\t\t\t\t\t\t\t\tds = ReflectionUtils.invokeMethod(getTargetDataSourceMethod, ds);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (NoSuchMethodException nsme) {\n\t\t\t\t\t\t\t\tds = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"No working getDataSource method found on ConnectionFactory: \" + ex2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// No working getDataSource method - cannot perform DataSource transaction check\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Close all of this resource holder's Sessions and clear its state.\n\t * @see Session#close()\n\t */\n\tpublic void closeAll() {\n\t\tfor (Session session : this.sessions) {\n\t\t\ttry {\n\t\t\t\tsession.close();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.debug(\"Could not close synchronized JMS Session after transaction\", ex);\n\t\t\t}\n\t\t}\n\t\tfor (Connection con : this.connections) {\n\t\t\tConnectionFactoryUtils.releaseConnection(con, this.connectionFactory, true);\n\t\t}\n\t\tthis.connections.clear();\n\t\tthis.sessions.clear();\n\t\tthis.sessionsPerConnection.clear();\n\t}\n\n}"
  },
  "org.springframework.jms.connection.JmsResourceHolder#addConnection(connection)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given Connection to this resource holder.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connection"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void addConnection(Connection connection)",
    "source_code": "\tpublic final void addConnection(Connection connection) {\n\t\tAssert.isTrue(!this.frozen, \"Cannot add Connection because JmsResourceHolder is frozen\");\n\t\tAssert.notNull(connection, \"Connection must not be null\");\n\t\tif (!this.connections.contains(connection)) {\n\t\t\tthis.connections.add(connection);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.JmsResourceHolder#addSession(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given Session to this resource holder.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void addSession(Session session)",
    "source_code": "\tpublic final void addSession(Session session) {\n\t\taddSession(session, null);\n\t}"
  },
  "org.springframework.jms.connection.JmsResourceHolder#addSession(session,connection)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given Session to this resource holder,\n\t * registered for a specific Connection.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "connection"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "void",
    "signature": "public void addSession(Session session, @Nullable Connection connection)",
    "source_code": "\tpublic final void addSession(Session session, @Nullable Connection connection) {\n\t\tAssert.isTrue(!this.frozen, \"Cannot add Session because JmsResourceHolder is frozen\");\n\t\tAssert.notNull(session, \"Session must not be null\");\n\t\tif (!this.sessions.contains(session)) {\n\t\t\tthis.sessions.add(session);\n\t\t\tif (connection != null) {\n\t\t\t\tDeque<Session> sessions =\n\t\t\t\t\t\tthis.sessionsPerConnection.computeIfAbsent(connection, k -> new ArrayDeque<>());\n\t\t\t\tsessions.add(session);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.JmsResourceHolder#closeAll()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close all of this resource holder's Sessions and clear its state.\n\t * @see Session#close()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "void",
    "signature": "public void closeAll()",
    "source_code": "\tpublic void closeAll() {\n\t\tfor (Session session : this.sessions) {\n\t\t\ttry {\n\t\t\t\tsession.close();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.debug(\"Could not close synchronized JMS Session after transaction\", ex);\n\t\t\t}\n\t\t}\n\t\tfor (Connection con : this.connections) {\n\t\t\tConnectionFactoryUtils.releaseConnection(con, this.connectionFactory, true);\n\t\t}\n\t\tthis.connections.clear();\n\t\tthis.sessions.clear();\n\t\tthis.sessionsPerConnection.clear();\n\t}"
  },
  "org.springframework.jms.connection.JmsResourceHolder#commitAll()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Commit all of this resource holder's Sessions.\n\t * @throws JMSException if thrown from a Session commit attempt\n\t * @see Session#commit()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "void",
    "signature": "public void commitAll()",
    "source_code": "\tpublic void commitAll() throws JMSException {\n\t\tfor (Session session : this.sessions) {\n\t\t\ttry {\n\t\t\t\tsession.commit();\n\t\t\t}\n\t\t\tcatch (TransactionInProgressException ex) {\n\t\t\t\t// Ignore -> can only happen in case of a JTA transaction.\n\t\t\t}\n\t\t\tcatch (jakarta.jms.IllegalStateException ex) {\n\t\t\t\tif (this.connectionFactory != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tMethod getDataSourceMethod = this.connectionFactory.getClass().getMethod(\"getDataSource\");\n\t\t\t\t\t\tObject ds = ReflectionUtils.invokeMethod(getDataSourceMethod, this.connectionFactory);\n\t\t\t\t\t\twhile (ds != null) {\n\t\t\t\t\t\t\tif (TransactionSynchronizationManager.hasResource(ds)) {\n\t\t\t\t\t\t\t\t// IllegalStateException from sharing the underlying JDBC Connection\n\t\t\t\t\t\t\t\t// which typically gets committed first, for example, with Oracle AQ --> ignore\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t// Check for decorated DataSource a la Spring's DelegatingDataSource\n\t\t\t\t\t\t\t\tMethod getTargetDataSourceMethod = ds.getClass().getMethod(\"getTargetDataSource\");\n\t\t\t\t\t\t\t\tds = ReflectionUtils.invokeMethod(getTargetDataSourceMethod, ds);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (NoSuchMethodException nsme) {\n\t\t\t\t\t\t\t\tds = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"No working getDataSource method found on ConnectionFactory: \" + ex2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// No working getDataSource method - cannot perform DataSource transaction check\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.JmsResourceHolder#containsSession(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given Session is registered\n\t * with this resource holder.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "boolean",
    "signature": "public boolean containsSession(Session session)",
    "source_code": "\tpublic boolean containsSession(Session session) {\n\t\treturn this.sessions.contains(session);\n\t}"
  },
  "org.springframework.jms.connection.JmsResourceHolder#getConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return this resource holder's default Connection,\n\t * or {@code null} if none.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "Connection",
    "signature": "public Connection getConnection()",
    "source_code": "\tpublic @Nullable Connection getConnection() {\n\t\treturn this.connections.peek();\n\t}"
  },
  "org.springframework.jms.connection.JmsResourceHolder#getConnection(connectionType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return this resource holder's Connection of the given type,\n\t * or {@code null} if none.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connectionType"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "C",
    "signature": "public C getConnection(Class<C> connectionType)",
    "source_code": "\tpublic <C extends Connection> @Nullable C getConnection(Class<C> connectionType) {\n\t\treturn CollectionUtils.findValueOfType(this.connections, connectionType);\n\t}"
  },
  "org.springframework.jms.connection.JmsResourceHolder#getSession()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return this resource holder's default Session,\n\t * or {@code null} if none.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "Session",
    "signature": "public Session getSession()",
    "source_code": "\tpublic @Nullable Session getSession() {\n\t\treturn this.sessions.peek();\n\t}"
  },
  "org.springframework.jms.connection.JmsResourceHolder#getSession(sessionType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return this resource holder's Session of the given type,\n\t * or {@code null} if none.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionType"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "S",
    "signature": "public S getSession(Class<S> sessionType)",
    "source_code": "\tpublic <S extends Session> @Nullable S getSession(Class<S> sessionType) {\n\t\treturn getSession(sessionType, null);\n\t}"
  },
  "org.springframework.jms.connection.JmsResourceHolder#getSession(sessionType,connection)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return this resource holder's Session of the given type\n\t * for the given connection, or {@code null} if none.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionType",
      "connection"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "S",
    "signature": "public S getSession(Class<S> sessionType, @Nullable Connection connection)",
    "source_code": "\tpublic <S extends Session> @Nullable S getSession(Class<S> sessionType, @Nullable Connection connection) {\n\t\tDeque<Session> sessions =\n\t\t\t\t(connection != null ? this.sessionsPerConnection.get(connection) : this.sessions);\n\t\treturn CollectionUtils.findValueOfType(sessions, sessionType);\n\t}"
  },
  "org.springframework.jms.connection.JmsResourceHolder#isFrozen()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this resource holder is frozen, i.e. does not\n\t * allow for adding further Connections and Sessions to it.\n\t * @see #addConnection\n\t * @see #addSession\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "boolean",
    "signature": "public boolean isFrozen()",
    "source_code": "\tpublic final boolean isFrozen() {\n\t\treturn this.frozen;\n\t}"
  },
  "org.springframework.jms.core.JmsMessageOperations": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A specialization of {@link MessageSendingOperations}, {@link MessageReceivingOperations}\n * and {@link MessageRequestReplyOperations} for JMS related operations that allow to specify\n * a destination name rather than the actual {@link jakarta.jms.Destination}.\n *\n * @author Stephane Nicoll\n * @since 4.1\n * @see org.springframework.jms.core.JmsTemplate\n * @see org.springframework.messaging.core.MessageSendingOperations\n * @see org.springframework.messaging.core.MessageReceivingOperations\n * @see org.springframework.messaging.core.MessageRequestReplyOperations\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public interface JmsMessageOperations",
    "source_code": "public interface JmsMessageOperations extends MessageSendingOperations<Destination>,"
  },
  "org.springframework.jms.core.JmsMessagingTemplate": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An implementation of {@link JmsMessageOperations}.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 4.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class JmsMessagingTemplate",
    "source_code": "public class JmsMessagingTemplate extends AbstractMessagingTemplate<Destination>"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tAssert.notNull(this.jmsTemplate, \"Property 'connectionFactory' or 'jmsTemplate' is required\");\n\t\tif (!this.converterSet && this.jmsTemplate.getMessageConverter() != null) {\n\t\t\t((MessagingMessageConverter) this.jmsMessageConverter)\n\t\t\t\t\t.setPayloadConverter(this.jmsTemplate.getMessageConverter());\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#convertAndSend(destinationName,payload)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, Object payload)",
    "source_code": "\tpublic void convertAndSend(String destinationName, Object payload) throws MessagingException {\n\t\tconvertAndSend(destinationName, payload, (Map<String, Object>) null);\n\t}"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#convertAndSend(destinationName,payload,Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "payload",
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, Object payload, @Nullable Map<String, Object> headers)",
    "source_code": "\tpublic void convertAndSend(String destinationName, Object payload, @Nullable Map<String, Object> headers)"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#convertAndSend(destinationName,payload,Map<String,headers,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "payload",
      "Map<String",
      "headers",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, Object payload, @Nullable Map<String, Object> headers,\n\t\t\t@Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(String destinationName, Object payload, @Nullable Map<String, Object> headers,"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#convertAndSend(destinationName,payload,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "payload",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, Object payload, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(String destinationName, Object payload, @Nullable MessagePostProcessor postProcessor)"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#convertAndSend(payload,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "void",
    "signature": "public void convertAndSend(Object payload, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(Object payload, @Nullable MessagePostProcessor postProcessor) throws MessagingException {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\tconvertAndSend(defaultDestination, payload, postProcessor);\n\t\t}\n\t\telse {\n\t\t\tconvertAndSend(getRequiredDefaultDestinationName(), payload, postProcessor);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#convertJmsException(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 419
    },
    "return": "MessagingException",
    "signature": "protected MessagingException convertJmsException(JmsException ex)",
    "source_code": "\tprotected MessagingException convertJmsException(JmsException ex) {\n\t\tif (ex instanceof org.springframework.jms.support.destination.DestinationResolutionException ||\n\t\t\t\tex instanceof InvalidDestinationException) {\n\t\t\treturn new DestinationResolutionException(ex.getMessage(), ex);\n\t\t}\n\t\tif (ex instanceof org.springframework.jms.support.converter.MessageConversionException) {\n\t\t\treturn new MessageConversionException(ex.getMessage(), ex);\n\t\t}\n\t\t// Fallback\n\t\treturn new MessagingException(ex.getMessage(), ex);\n\t}"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#convertSendAndReceive(destinationName,request,Map<String,headers,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "request",
      "Map<String",
      "headers",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(String destinationName, Object request,\n\t\t\t@Nullable Map<String, Object> headers, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(String destinationName, Object request,"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#convertSendAndReceive(destinationName,request,Map<String,headers,targetClass,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "request",
      "Map<String",
      "headers",
      "targetClass",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(String destinationName, Object request, @Nullable Map<String, Object> headers,\n\t\t\tClass<T> targetClass, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(String destinationName, Object request, @Nullable Map<String, Object> headers,"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#convertSendAndReceive(destinationName,request,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "request",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 285
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(String destinationName, Object request, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(String destinationName, Object request, Class<T> targetClass)"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#convertSendAndReceive(destinationName,request,targetClass,requestPostProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "request",
      "targetClass",
      "requestPostProcessor"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(String destinationName, Object request, Class<T> targetClass,\n\t\t\t@Nullable MessagePostProcessor requestPostProcessor)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(String destinationName, Object request, Class<T> targetClass,"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#convertSendAndReceive(request,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(Object request, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(Object request, Class<T> targetClass) {\n\t\treturn convertSendAndReceive(request, targetClass, null);\n\t}"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#convertSendAndReceive(request,targetClass,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "targetClass",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(Object request, Class<T> targetClass, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(Object request, Class<T> targetClass, @Nullable MessagePostProcessor postProcessor) {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\treturn convertSendAndReceive(defaultDestination, request, targetClass, postProcessor);\n\t\t}\n\t\telse {\n\t\t\treturn convertSendAndReceive(getRequiredDefaultDestinationName(), request, targetClass, postProcessor);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#doSend(destination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "void",
    "signature": "protected void doSend(Destination destination, Message<?> message)",
    "source_code": "\tprotected void doSend(Destination destination, Message<?> message) {\n\t\ttry {\n\t\t\tobtainJmsTemplate().send(destination, createMessageCreator(message));\n\t\t}\n\t\tcatch (JmsException ex) {\n\t\t\tthrow convertJmsException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#doSend(destinationName,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destinationName",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "void",
    "signature": "protected void doSend(String destinationName, Message<?> message)",
    "source_code": "\tprotected void doSend(String destinationName, Message<?> message) {\n\t\ttry {\n\t\t\tobtainJmsTemplate().send(destinationName, createMessageCreator(message));\n\t\t}\n\t\tcatch (JmsException ex) {\n\t\t\tthrow convertJmsException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#getConnectionFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the ConnectionFactory that the underlying {@link JmsTemplate} uses.\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "ConnectionFactory",
    "signature": "public ConnectionFactory getConnectionFactory()",
    "source_code": "\tpublic @Nullable ConnectionFactory getConnectionFactory() {\n\t\treturn (this.jmsTemplate != null ? this.jmsTemplate.getConnectionFactory() : null);\n\t}"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#getDefaultDestinationName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured default destination name.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "String",
    "signature": "public String getDefaultDestinationName()",
    "source_code": "\tpublic @Nullable String getDefaultDestinationName() {\n\t\treturn this.defaultDestinationName;\n\t}"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#getJmsMessageConverter()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link MessageConverter} to use to convert a {@link Message}\n\t * from the messaging to and from a {@link jakarta.jms.Message}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "MessageConverter",
    "signature": "public MessageConverter getJmsMessageConverter()",
    "source_code": "\tpublic MessageConverter getJmsMessageConverter() {\n\t\treturn this.jmsMessageConverter;\n\t}"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#getJmsTemplate()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link JmsTemplate}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "JmsTemplate",
    "signature": "public JmsTemplate getJmsTemplate()",
    "source_code": "\tpublic @Nullable JmsTemplate getJmsTemplate() {\n\t\treturn this.jmsTemplate;\n\t}"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#getRequiredDefaultDestinationName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "String",
    "signature": "protected String getRequiredDefaultDestinationName()",
    "source_code": "\tprotected String getRequiredDefaultDestinationName() {\n\t\tString name = getDefaultDestinationName();\n\t\tif (name == null) {\n\t\t\tthrow new IllegalStateException(\"No 'defaultDestination' or 'defaultDestinationName' specified. \" +\n\t\t\t\t\t\"Check configuration of JmsMessagingTemplate.\");\n\t\t}\n\t\treturn name;\n\t}"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#receiveAndConvert(destinationName,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "T",
    "signature": "public T receiveAndConvert(String destinationName, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T receiveAndConvert(String destinationName, Class<T> targetClass) throws MessagingException {\n\t\tMessage<?> message = doReceive(destinationName);\n\t\tif (message != null) {\n\t\t\treturn doConvert(message, targetClass);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#receiveAndConvert(targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "T",
    "signature": "public T receiveAndConvert(Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T receiveAndConvert(Class<T> targetClass) {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\treturn receiveAndConvert(defaultDestination, targetClass);\n\t\t}\n\t\telse {\n\t\t\treturn receiveAndConvert(getRequiredDefaultDestinationName(), targetClass);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#send(destinationName,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "public void send(String destinationName, Message<?> message)",
    "source_code": "\tpublic void send(String destinationName, Message<?> message) throws MessagingException {\n\t\tdoSend(destinationName, message);\n\t}"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#send(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "void",
    "signature": "public void send(Message<?> message)",
    "source_code": "\tpublic void send(Message<?> message) {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\tsend(defaultDestination, message);\n\t\t}\n\t\telse {\n\t\t\tsend(getRequiredDefaultDestinationName(), message);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#setConnectionFactory(connectionFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the ConnectionFactory to use for the underlying {@link JmsTemplate}.\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connectionFactory"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void setConnectionFactory(ConnectionFactory connectionFactory)",
    "source_code": "\tpublic void setConnectionFactory(ConnectionFactory connectionFactory) {\n\t\tif (this.jmsTemplate != null) {\n\t\t\tthis.jmsTemplate.setConnectionFactory(connectionFactory);\n\t\t}\n\t\telse {\n\t\t\tthis.jmsTemplate = new JmsTemplate(connectionFactory);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#setDefaultDestinationName(defaultDestinationName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the default destination name to use in send methods that don't have\n\t * a destination argument. If a default destination is not configured, send methods\n\t * without a destination argument will raise an exception if invoked.\n\t * @see #setDefaultDestination(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultDestinationName"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "public void setDefaultDestinationName(@Nullable String defaultDestinationName)",
    "source_code": "\tpublic void setDefaultDestinationName(@Nullable String defaultDestinationName) {\n\t\tthis.defaultDestinationName = defaultDestinationName;\n\t}"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#setJmsMessageConverter(jmsMessageConverter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link MessageConverter} to use to convert a {@link Message} from\n\t * the messaging to and from a {@link jakarta.jms.Message}. By default, a\n\t * {@link MessagingMessageConverter} is defined using a {@link SimpleMessageConverter}\n\t * to convert the payload of the message.\n\t * <p>Consider configuring a {@link MessagingMessageConverter} with a different\n\t * {@link MessagingMessageConverter#setPayloadConverter(MessageConverter) payload converter}\n\t * for more advanced scenarios.\n\t * @see org.springframework.jms.support.converter.MessagingMessageConverter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jmsMessageConverter"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void setJmsMessageConverter(MessageConverter jmsMessageConverter)",
    "source_code": "\tpublic void setJmsMessageConverter(MessageConverter jmsMessageConverter) {\n\t\tAssert.notNull(jmsMessageConverter, \"MessageConverter must not be null\");\n\t\tthis.jmsMessageConverter = jmsMessageConverter;\n\t\tthis.converterSet = true;\n\t}"
  },
  "org.springframework.jms.core.JmsMessagingTemplate#setJmsTemplate(jmsTemplate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link JmsTemplate} to use.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jmsTemplate"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void setJmsTemplate(@Nullable JmsTemplate jmsTemplate)",
    "source_code": "\tpublic void setJmsTemplate(@Nullable JmsTemplate jmsTemplate) {\n\t\tthis.jmsTemplate = jmsTemplate;\n\t}"
  },
  "org.springframework.jms.core.JmsOperations": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Specifies a basic set of JMS operations.\n *\n * <p>Implemented by {@link JmsTemplate}. Not often used but a useful option\n * to enhance testability, as it can easily be mocked or stubbed.\n *\n * <p>Provides {@code JmsTemplate's} {@code send(..)} and\n * {@code receive(..)} methods that mirror various JMS API methods.\n * See the JMS specification and javadocs for details on those methods.\n *\n * <p>Provides also basic request reply operation using a temporary\n * queue to collect the reply.\n *\n * @author Mark Pollack\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @since 1.1\n * @see JmsTemplate\n * @see jakarta.jms.Destination\n * @see jakarta.jms.Session\n * @see jakarta.jms.MessageProducer\n * @see jakarta.jms.MessageConsumer\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public interface JmsOperations",
    "source_code": "public interface JmsOperations {\n\n\t/**\n\t * Execute the action specified by the given action object within a JMS Session.\n\t * @param action callback object that exposes the session\n\t * @return the result object from working with the session\n\t * @throws JmsException if there is any problem\n\t */\n\t<T> @Nullable T execute(SessionCallback<T> action) throws JmsException;\n\n\t/**\n\t * Send messages to the default JMS destination (or one specified\n\t * for each send operation). The callback gives access to the JMS Session\n\t * and MessageProducer in order to perform complex send operations.\n\t * @param action callback object that exposes the session/producer pair\n\t * @return the result object from working with the session\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t<T> @Nullable T execute(ProducerCallback<T> action) throws JmsException;\n\n\t/**\n\t * Send messages to a JMS destination. The callback gives access to the JMS Session\n\t * and MessageProducer in order to perform complex send operations.\n\t * @param destination the destination to send messages to\n\t * @param action callback object that exposes the session/producer pair\n\t * @return the result object from working with the session\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t<T> @Nullable T execute(Destination destination, ProducerCallback<T> action) throws JmsException;\n\n\t/**\n\t * Send messages to a JMS destination. The callback gives access to the JMS Session\n\t * and MessageProducer in order to perform complex send operations.\n\t * @param destinationName the name of the destination to send messages to\n\t * (to be resolved to an actual destination by a DestinationResolver)\n\t * @param action callback object that exposes the session/producer pair\n\t * @return the result object from working with the session\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t<T> @Nullable T execute(String destinationName, ProducerCallback<T> action) throws JmsException;\n\n\n\t//---------------------------------------------------------------------------------------\n\t// Convenience methods for sending messages\n\t//---------------------------------------------------------------------------------------\n\n\t/**\n\t * Send a message to the default destination.\n\t * <p>This will only work with a default destination specified!\n\t * @param messageCreator callback to create a message\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\tvoid send(MessageCreator messageCreator) throws JmsException;\n\n\t/**\n\t * Send a message to the specified destination.\n\t * The MessageCreator callback creates the message given a Session.\n\t * @param destination the destination to send this message to\n\t * @param messageCreator callback to create a message\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\tvoid send(Destination destination, MessageCreator messageCreator) throws JmsException;\n\n\t/**\n\t * Send a message to the specified destination.\n\t * The MessageCreator callback creates the message given a Session.\n\t * @param destinationName the name of the destination to send this message to\n\t * (to be resolved to an actual destination by a DestinationResolver)\n\t * @param messageCreator callback to create a message\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\tvoid send(String destinationName, MessageCreator messageCreator) throws JmsException;\n\n\n\t//---------------------------------------------------------------------------------------\n\t// Convenience methods for sending auto-converted messages\n\t//---------------------------------------------------------------------------------------\n\n\t/**\n\t * Send the given object to the default destination, converting the object\n\t * to a JMS message with a configured MessageConverter.\n\t * <p>This will only work with a default destination specified!\n\t * @param message the object to convert to a message\n\t * @throws JmsException converted checked JMSException to unchecked\n\t */\n\tvoid convertAndSend(Object message) throws JmsException;\n\n\t/**\n\t * Send the given object to the specified destination, converting the object\n\t * to a JMS message with a configured MessageConverter.\n\t * @param destination the destination to send this message to\n\t * @param message the object to convert to a message\n\t * @throws JmsException converted checked JMSException to unchecked\n\t */\n\tvoid convertAndSend(Destination destination, Object message) throws JmsException;\n\n\t/**\n\t * Send the given object to the specified destination, converting the object\n\t * to a JMS message with a configured MessageConverter.\n\t * @param destinationName the name of the destination to send this message to\n\t * (to be resolved to an actual destination by a DestinationResolver)\n\t * @param message the object to convert to a message\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\tvoid convertAndSend(String destinationName, Object message) throws JmsException;\n\n\t/**\n\t * Send the given object to the default destination, converting the object\n\t * to a JMS message with a configured MessageConverter. The MessagePostProcessor\n\t * callback allows for modification of the message after conversion.\n\t * <p>This will only work with a default destination specified!\n\t * @param message the object to convert to a message\n\t * @param postProcessor the callback to modify the message\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\tvoid convertAndSend(Object message, MessagePostProcessor postProcessor)\n\t\tthrows JmsException;\n\n\t/**\n\t * Send the given object to the specified destination, converting the object\n\t * to a JMS message with a configured MessageConverter. The MessagePostProcessor\n\t * callback allows for modification of the message after conversion.\n\t * @param destination the destination to send this message to\n\t * @param message the object to convert to a message\n\t * @param postProcessor the callback to modify the message\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\tvoid convertAndSend(Destination destination, Object message, MessagePostProcessor postProcessor)\n\t\tthrows JmsException;\n\n\t/**\n\t * Send the given object to the specified destination, converting the object\n\t * to a JMS message with a configured MessageConverter. The MessagePostProcessor\n\t * callback allows for modification of the message after conversion.\n\t * @param destinationName the name of the destination to send this message to\n\t * (to be resolved to an actual destination by a DestinationResolver)\n\t * @param message the object to convert to a message.\n\t * @param postProcessor the callback to modify the message\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\tvoid convertAndSend(String destinationName, Object message, MessagePostProcessor postProcessor)\n\t\tthrows JmsException;\n\n\n\t//---------------------------------------------------------------------------------------\n\t// Convenience methods for receiving messages\n\t//---------------------------------------------------------------------------------------\n\n\t/**\n\t * Receive a message synchronously from the default destination, but only\n\t * wait up to a specified time for delivery.\n\t * <p>This method should be used carefully, since it will block the thread\n\t * until the message becomes available or until the timeout value is exceeded.\n\t * <p>This will only work with a default destination specified!\n\t * @return the message received by the consumer, or {@code null} if the timeout expires\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t@Nullable Message receive() throws JmsException;\n\n\t/**\n\t * Receive a message synchronously from the specified destination, but only\n\t * wait up to a specified time for delivery.\n\t * <p>This method should be used carefully, since it will block the thread\n\t * until the message becomes available or until the timeout value is exceeded.\n\t * @param destination the destination to receive a message from\n\t * @return the message received by the consumer, or {@code null} if the timeout expires\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t@Nullable Message receive(Destination destination) throws JmsException;\n\n\t/**\n\t * Receive a message synchronously from the specified destination, but only\n\t * wait up to a specified time for delivery.\n\t * <p>This method should be used carefully, since it will block the thread\n\t * until the message becomes available or until the timeout value is exceeded.\n\t * @param destinationName the name of the destination to send this message to\n\t * (to be resolved to an actual destination by a DestinationResolver)\n\t * @return the message received by the consumer, or {@code null} if the timeout expires\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t@Nullable Message receive(String destinationName) throws JmsException;\n\n\t/**\n\t * Receive a message synchronously from the default destination, but only\n\t * wait up to a specified time for delivery.\n\t * <p>This method should be used carefully, since it will block the thread\n\t * until the message becomes available or until the timeout value is exceeded.\n\t * <p>This will only work with a default destination specified!\n\t * @param messageSelector the JMS message selector expression (or {@code null} if none).\n\t * See the JMS specification for a detailed definition of selector expressions.\n\t * @return the message received by the consumer, or {@code null} if the timeout expires\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t@Nullable Message receiveSelected(String messageSelector) throws JmsException;\n\n\t/**\n\t * Receive a message synchronously from the specified destination, but only\n\t * wait up to a specified time for delivery.\n\t * <p>This method should be used carefully, since it will block the thread\n\t * until the message becomes available or until the timeout value is exceeded.\n\t * @param destination the destination to receive a message from\n\t * @param messageSelector the JMS message selector expression (or {@code null} if none).\n\t * See the JMS specification for a detailed definition of selector expressions.\n\t * @return the message received by the consumer, or {@code null} if the timeout expires\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t@Nullable Message receiveSelected(Destination destination, String messageSelector) throws JmsException;\n\n\t/**\n\t * Receive a message synchronously from the specified destination, but only\n\t * wait up to a specified time for delivery.\n\t * <p>This method should be used carefully, since it will block the thread\n\t * until the message becomes available or until the timeout value is exceeded.\n\t * @param destinationName the name of the destination to send this message to\n\t * (to be resolved to an actual destination by a DestinationResolver)\n\t * @param messageSelector the JMS message selector expression (or {@code null} if none).\n\t * See the JMS specification for a detailed definition of selector expressions.\n\t * @return the message received by the consumer, or {@code null} if the timeout expires\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t@Nullable Message receiveSelected(String destinationName, String messageSelector) throws JmsException;\n\n\n\t//---------------------------------------------------------------------------------------\n\t// Convenience methods for receiving auto-converted messages\n\t//---------------------------------------------------------------------------------------\n\n\t/**\n\t * Receive a message synchronously from the default destination, but only\n\t * wait up to a specified time for delivery. Convert the message into an\n\t * object with a configured MessageConverter.\n\t * <p>This method should be used carefully, since it will block the thread\n\t * until the message becomes available or until the timeout value is exceeded.\n\t * <p>This will only work with a default destination specified!\n\t * @return the message produced for the consumer, or {@code null} if the timeout expires\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t@Nullable Object receiveAndConvert() throws JmsException;\n\n\t/**\n\t * Receive a message synchronously from the specified destination, but only\n\t * wait up to a specified time for delivery. Convert the message into an\n\t * object with a configured MessageConverter.\n\t * <p>This method should be used carefully, since it will block the thread\n\t * until the message becomes available or until the timeout value is exceeded.\n\t * @param destination the destination to receive a message from\n\t * @return the message produced for the consumer, or {@code null} if the timeout expires\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t@Nullable Object receiveAndConvert(Destination destination) throws JmsException;\n\n\t/**\n\t * Receive a message synchronously from the specified destination, but only\n\t * wait up to a specified time for delivery. Convert the message into an\n\t * object with a configured MessageConverter.\n\t * <p>This method should be used carefully, since it will block the thread\n\t * until the message becomes available or until the timeout value is exceeded.\n\t * @param destinationName the name of the destination to send this message to\n\t * (to be resolved to an actual destination by a DestinationResolver)\n\t * @return the message produced for the consumer, or {@code null} if the timeout expires\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t@Nullable Object receiveAndConvert(String destinationName) throws JmsException;\n\n\t/**\n\t * Receive a message synchronously from the default destination, but only\n\t * wait up to a specified time for delivery. Convert the message into an\n\t * object with a configured MessageConverter.\n\t * <p>This method should be used carefully, since it will block the thread\n\t * until the message becomes available or until the timeout value is exceeded.\n\t * <p>This will only work with a default destination specified!\n\t * @param messageSelector the JMS message selector expression (or {@code null} if none).\n\t * See the JMS specification for a detailed definition of selector expressions.\n\t * @return the message produced for the consumer, or {@code null} if the timeout expires\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t@Nullable Object receiveSelectedAndConvert(String messageSelector) throws JmsException;\n\n\t/**\n\t * Receive a message synchronously from the specified destination, but only\n\t * wait up to a specified time for delivery. Convert the message into an\n\t * object with a configured MessageConverter.\n\t * <p>This method should be used carefully, since it will block the thread\n\t * until the message becomes available or until the timeout value is exceeded.\n\t * @param destination the destination to receive a message from\n\t * @param messageSelector the JMS message selector expression (or {@code null} if none).\n\t * See the JMS specification for a detailed definition of selector expressions.\n\t * @return the message produced for the consumer, or {@code null} if the timeout expires\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t@Nullable Object receiveSelectedAndConvert(Destination destination, String messageSelector) throws JmsException;\n\n\t/**\n\t * Receive a message synchronously from the specified destination, but only\n\t * wait up to a specified time for delivery. Convert the message into an\n\t * object with a configured MessageConverter.\n\t * <p>This method should be used carefully, since it will block the thread\n\t * until the message becomes available or until the timeout value is exceeded.\n\t * @param destinationName the name of the destination to send this message to\n\t * (to be resolved to an actual destination by a DestinationResolver)\n\t * @param messageSelector the JMS message selector expression (or {@code null} if none).\n\t * See the JMS specification for a detailed definition of selector expressions.\n\t * @return the message produced for the consumer, or {@code null} if the timeout expires\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t@Nullable Object receiveSelectedAndConvert(String destinationName, String messageSelector) throws JmsException;\n\n\n\t//---------------------------------------------------------------------------------------\n\t// Convenience methods for sending messages to and receiving the reply from a destination\n\t//---------------------------------------------------------------------------------------\n\n\t/**\n\t * Send a request message and receive the reply from a default destination. The\n\t * {@link MessageCreator} callback creates the message given a Session. A temporary\n\t * queue is created as part of this operation and is set in the {@code JMSReplyTO}\n\t * header of the message.\n\t * <p>This will only work with a default destination specified!\n\t * @param messageCreator callback to create a request message\n\t * @return the reply, possibly {@code null} if the message could not be received,\n\t * for example due to a timeout\n\t * @throws JmsException checked JMSException converted to unchecked\n\t * @since 4.1\n\t */\n\t@Nullable Message sendAndReceive(MessageCreator messageCreator) throws JmsException;\n\n\t/**\n\t * Send a message and receive the reply from the specified destination. The\n\t * {@link MessageCreator} callback creates the message given a Session. A temporary\n\t * queue is created as part of this operation and is set in the {@code JMSReplyTO}\n\t * header of the message.\n\t * @param destination the destination to send this message to\n\t * @param messageCreator callback to create a message\n\t * @return the reply, possibly {@code null} if the message could not be received,\n\t * for example due to a timeout\n\t * @throws JmsException checked JMSException converted to unchecked\n\t * @since 4.1\n\t */\n\t@Nullable Message sendAndReceive(Destination destination, MessageCreator messageCreator) throws JmsException;\n\n\t/**\n\t * Send a message and receive the reply from the specified destination. The\n\t * {@link MessageCreator} callback creates the message given a Session. A temporary\n\t * queue is created as part of this operation and is set in the {@code JMSReplyTO}\n\t * header of the message.\n\t * @param destinationName the name of the destination to send this message to\n\t * (to be resolved to an actual destination by a DestinationResolver)\n\t * @param messageCreator callback to create a message\n\t * @return the reply, possibly {@code null} if the message could not be received,\n\t * for example due to a timeout\n\t * @throws JmsException checked JMSException converted to unchecked\n\t * @since 4.1\n\t */\n\t@Nullable Message sendAndReceive(String destinationName, MessageCreator messageCreator) throws JmsException;\n\n\n\t//---------------------------------------------------------------------------------------\n\t// Convenience methods for browsing messages\n\t//---------------------------------------------------------------------------------------\n\n\t/**\n\t * Browse messages in the default JMS queue. The callback gives access to the JMS\n\t * Session and QueueBrowser in order to browse the queue and react to the contents.\n\t * @param action callback object that exposes the session/browser pair\n\t * @return the result object from working with the session\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t<T> @Nullable T browse(BrowserCallback<T> action) throws JmsException;\n\n\t/**\n\t * Browse messages in a JMS queue. The callback gives access to the JMS Session\n\t * and QueueBrowser in order to browse the queue and react to the contents.\n\t * @param queue the queue to browse\n\t * @param action callback object that exposes the session/browser pair\n\t * @return the result object from working with the session\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t<T> @Nullable T browse(Queue queue, BrowserCallback<T> action) throws JmsException;\n\n\t/**\n\t * Browse messages in a JMS queue. The callback gives access to the JMS Session\n\t * and QueueBrowser in order to browse the queue and react to the contents.\n\t * @param queueName the name of the queue to browse\n\t * (to be resolved to an actual destination by a DestinationResolver)\n\t * @param action callback object that exposes the session/browser pair\n\t * @return the result object from working with the session\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t<T> @Nullable T browse(String queueName, BrowserCallback<T> action) throws JmsException;\n\n\t/**\n\t * Browse selected messages in a JMS queue. The callback gives access to the JMS\n\t * Session and QueueBrowser in order to browse the queue and react to the contents.\n\t * @param messageSelector the JMS message selector expression (or {@code null} if none).\n\t * See the JMS specification for a detailed definition of selector expressions.\n\t * @param action callback object that exposes the session/browser pair\n\t * @return the result object from working with the session\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t<T> @Nullable T browseSelected(String messageSelector, BrowserCallback<T> action) throws JmsException;\n\n\t/**\n\t * Browse selected messages in a JMS queue. The callback gives access to the JMS\n\t * Session and QueueBrowser in order to browse the queue and react to the contents.\n\t * @param queue the queue to browse\n\t * @param messageSelector the JMS message selector expression (or {@code null} if none).\n\t * See the JMS specification for a detailed definition of selector expressions.\n\t * @param action callback object that exposes the session/browser pair\n\t * @return the result object from working with the session\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t<T> @Nullable T browseSelected(Queue queue, String messageSelector, BrowserCallback<T> action) throws JmsException;\n\n\t/**\n\t * Browse selected messages in a JMS queue. The callback gives access to the JMS\n\t * Session and QueueBrowser in order to browse the queue and react to the contents.\n\t * @param queueName the name of the queue to browse\n\t * (to be resolved to an actual destination by a DestinationResolver)\n\t * @param messageSelector the JMS message selector expression (or {@code null} if none).\n\t * See the JMS specification for a detailed definition of selector expressions.\n\t * @param action callback object that exposes the session/browser pair\n\t * @return the result object from working with the session\n\t * @throws JmsException checked JMSException converted to unchecked\n\t */\n\t<T> @Nullable T browseSelected(String queueName, String messageSelector, BrowserCallback<T> action) throws JmsException;\n\n}"
  },
  "org.springframework.jmx.access.NotificationListenerRegistrar": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Registrar object that associates a specific {@link javax.management.NotificationListener}\n * with one or more MBeans in an {@link javax.management.MBeanServer}\n * (typically via a {@link javax.management.MBeanServerConnection}).\n *\n * @author Juergen Hoeller\n * @since 2.5.2\n * @see #setServer\n * @see #setMappedObjectNames\n * @see #setNotificationListener\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class NotificationListenerRegistrar",
    "source_code": "public class NotificationListenerRegistrar extends NotificationListenerHolder"
  },
  "org.springframework.jmx.access.NotificationListenerRegistrar#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tif (getNotificationListener() == null) {\n\t\t\tthrow new IllegalArgumentException(\"Property 'notificationListener' is required\");\n\t\t}\n\t\tif (CollectionUtils.isEmpty(this.mappedObjectNames)) {\n\t\t\tthrow new IllegalArgumentException(\"Property 'mappedObjectName' is required\");\n\t\t}\n\t\tprepare();\n\t}"
  },
  "org.springframework.jmx.access.NotificationListenerRegistrar#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Unregisters the specified {@code NotificationListener}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t\ttry {\n\t\t\tif (this.server != null && this.actualObjectNames != null) {\n\t\t\t\tfor (ObjectName actualObjectName : this.actualObjectNames) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.server.removeNotificationListener(\n\t\t\t\t\t\t\t\tactualObjectName, getNotificationListener(), getNotificationFilter(), getHandback());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Unable to unregister NotificationListener\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tthis.connector.close();\n\t\t}\n\t}"
  },
  "org.springframework.jmx.access.NotificationListenerRegistrar#prepare()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Registers the specified {@code NotificationListener}.\n\t * <p>Ensures that an {@code MBeanServerConnection} is configured and attempts\n\t * to detect a local connection if one is not supplied.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void prepare()",
    "source_code": "\tpublic void prepare() {\n\t\tif (this.server == null) {\n\t\t\tthis.server = this.connector.connect(this.serviceUrl, this.environment, this.agentId);\n\t\t}\n\t\ttry {\n\t\t\tthis.actualObjectNames = getResolvedObjectNames();\n\t\t\tif (this.actualObjectNames != null) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Registering NotificationListener for MBeans \" + Arrays.toString(this.actualObjectNames));\n\t\t\t\t}\n\t\t\t\tfor (ObjectName actualObjectName : this.actualObjectNames) {\n\t\t\t\t\tthis.server.addNotificationListener(\n\t\t\t\t\t\t\tactualObjectName, getNotificationListener(), getNotificationFilter(), getHandback());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new MBeanServerNotFoundException(\n\t\t\t\t\t\"Could not connect to remote MBeanServer at URL [\" + this.serviceUrl + \"]\", ex);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new JmxException(\"Unable to register NotificationListener\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.access.NotificationListenerRegistrar#setAgentId(agentId)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the agent id of the {@code MBeanServer} to locate.\n\t * <p>Default is none. If specified, this will result in an\n\t * attempt being made to locate the attendant MBeanServer, unless\n\t * the {@link #setServiceUrl \"serviceUrl\"} property has been set.\n\t * @see javax.management.MBeanServerFactory#findMBeanServer(String)\n\t * <p>Specifying the empty String indicates the platform MBeanServer.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "agentId"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void setAgentId(String agentId)",
    "source_code": "\tpublic void setAgentId(String agentId) {\n\t\tthis.agentId = agentId;\n\t}"
  },
  "org.springframework.jmx.access.NotificationListenerRegistrar#setEnvironment(Map<String,environment)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the environment for the JMX connector.\n\t * @see javax.management.remote.JMXConnectorFactory#connect(javax.management.remote.JMXServiceURL, java.util.Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "environment"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "void",
    "signature": "public void setEnvironment(@Nullable Map<String, ?> environment)",
    "source_code": "\tpublic void setEnvironment(@Nullable Map<String, ?> environment) {\n\t\tthis.environment = environment;\n\t}"
  },
  "org.springframework.jmx.access.NotificationListenerRegistrar#setServer(server)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@code MBeanServerConnection} used to connect to the\n\t * MBean which all invocations are routed to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "server"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "public void setServer(MBeanServerConnection server)",
    "source_code": "\tpublic void setServer(MBeanServerConnection server) {\n\t\tthis.server = server;\n\t}"
  },
  "org.springframework.jmx.access.NotificationListenerRegistrar#setServiceUrl(url)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the service URL of the remote {@code MBeanServer}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void setServiceUrl(String url)",
    "source_code": "\tpublic void setServiceUrl(String url) throws MalformedURLException {\n\t\tthis.serviceUrl = new JMXServiceURL(url);\n\t}"
  },
  "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Subclass of {@code AbstractReflectiveMBeanInfoAssembler} that allows for\n * the management interface of a bean to be defined using arbitrary interfaces.\n * Any methods or properties that are defined in those interfaces are exposed\n * as MBean operations and attributes.\n *\n * <p>By default, this class votes on the inclusion of each operation or attribute\n * based on the interfaces implemented by the bean class. However, you can supply an\n * array of interfaces via the {@code managedInterfaces} property that will be\n * used instead. If you have multiple beans and you wish each bean to use a different\n * set of interfaces, then you can map bean keys (that is the name used to pass the\n * bean to the {@code MBeanExporter}) to a list of interface names using the\n * {@code interfaceMappings} property.\n *\n * <p>If you specify values for both {@code interfaceMappings} and\n * {@code managedInterfaces}, Spring will attempt to find interfaces in the\n * mappings first. If no interfaces for the bean are found, it will use the\n * interfaces defined by {@code managedInterfaces}.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @since 1.2\n * @see #setManagedInterfaces\n * @see #setInterfaceMappings\n * @see MethodNameBasedMBeanInfoAssembler\n * @see SimpleReflectiveMBeanInfoAssembler\n * @see org.springframework.jmx.export.MBeanExporter\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "signature": "public class InterfaceBasedMBeanInfoAssembler",
    "source_code": "public class InterfaceBasedMBeanInfoAssembler extends AbstractConfigurableMBeanInfoAssembler"
  },
  "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tif (this.interfaceMappings != null) {\n\t\t\tthis.resolvedInterfaceMappings = resolveInterfaceMappings(this.interfaceMappings);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler#includeOperation(method,beanKey)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check to see if the {@code Method} is declared in\n\t * one of the configured interfaces and that it is public.\n\t * @param method the operation {@code Method}.\n\t * @param beanKey the key associated with the MBean in the\n\t * {@code beans} {@code Map}.\n\t * @return {@code true} if the {@code Method} is declared in one of the\n\t * configured interfaces, otherwise {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "boolean",
    "signature": "protected boolean includeOperation(Method method, String beanKey)",
    "source_code": "\tprotected boolean includeOperation(Method method, String beanKey) {\n\t\treturn isPublicInInterface(method, beanKey);\n\t}"
  },
  "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler#includeReadAttribute(method,beanKey)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check to see if the {@code Method} is declared in\n\t * one of the configured interfaces and that it is public.\n\t * @param method the accessor {@code Method}.\n\t * @param beanKey the key associated with the MBean in the\n\t * {@code beans} {@code Map}.\n\t * @return {@code true} if the {@code Method} is declared in one of the\n\t * configured interfaces, otherwise {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "boolean",
    "signature": "protected boolean includeReadAttribute(Method method, String beanKey)",
    "source_code": "\tprotected boolean includeReadAttribute(Method method, String beanKey) {\n\t\treturn isPublicInInterface(method, beanKey);\n\t}"
  },
  "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler#includeWriteAttribute(method,beanKey)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check to see if the {@code Method} is declared in\n\t * one of the configured interfaces and that it is public.\n\t * @param method the mutator {@code Method}.\n\t * @param beanKey the key associated with the MBean in the\n\t * {@code beans} {@code Map}.\n\t * @return {@code true} if the {@code Method} is declared in one of the\n\t * configured interfaces, otherwise {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "boolean",
    "signature": "protected boolean includeWriteAttribute(Method method, String beanKey)",
    "source_code": "\tprotected boolean includeWriteAttribute(Method method, String beanKey) {\n\t\treturn isPublicInInterface(method, beanKey);\n\t}"
  },
  "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler#setBeanClassLoader(beanClassLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClassLoader"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void setBeanClassLoader(@Nullable ClassLoader beanClassLoader)",
    "source_code": "\tpublic void setBeanClassLoader(@Nullable ClassLoader beanClassLoader) {\n\t\tthis.beanClassLoader = beanClassLoader;\n\t}"
  },
  "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler#setInterfaceMappings(mappings)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the mappings of bean keys to a comma-separated list of interface names.\n\t * <p>The property key should match the bean key and the property value should match\n\t * the list of interface names. When searching for interfaces for a bean, Spring\n\t * will check these mappings first.\n\t * @param mappings the mappings of bean keys to interface names\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappings"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void setInterfaceMappings(@Nullable Properties mappings)",
    "source_code": "\tpublic void setInterfaceMappings(@Nullable Properties mappings) {\n\t\tthis.interfaceMappings = mappings;\n\t}"
  },
  "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler#setManagedInterfaces(managedInterfaces)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the array of interfaces to use for creating the management info.\n\t * These interfaces will be used for a bean if no entry corresponding to\n\t * that bean is found in the {@code interfaceMappings} property.\n\t * @param managedInterfaces an array of classes indicating the interfaces to use.\n\t * Each entry <strong>MUST</strong> be an interface.\n\t * @see #setInterfaceMappings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "managedInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void setManagedInterfaces(Class<?> @Nullable ... managedInterfaces)",
    "source_code": "\tpublic void setManagedInterfaces(Class<?> @Nullable ... managedInterfaces) {\n\t\tif (managedInterfaces != null) {\n\t\t\tfor (Class<?> ifc : managedInterfaces) {\n\t\t\t\tif (!ifc.isInterface()) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\"Management interface [\" + ifc.getName() + \"] is not an interface\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.managedInterfaces = managedInterfaces;\n\t}"
  },
  "org.springframework.jmx.export.metadata.ManagedNotification": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Metadata that indicates a JMX notification emitted by a bean.\n *\n * @author Rob Harrop\n * @since 2.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 29
    },
    "signature": "public class ManagedNotification",
    "source_code": "public class ManagedNotification {\n\n\tprivate String @Nullable [] notificationTypes;\n\n\tprivate @Nullable String name;\n\n\tprivate @Nullable String description;\n\n\n\t/**\n\t * Set a single notification type, or a list of notification types\n\t * as comma-delimited String.\n\t */\n\tpublic void setNotificationType(String notificationType) {\n\t\tthis.notificationTypes = StringUtils.commaDelimitedListToStringArray(notificationType);\n\t}\n\n\t/**\n\t * Set a list of notification types.\n\t */\n\tpublic void setNotificationTypes(String @Nullable ... notificationTypes) {\n\t\tthis.notificationTypes = notificationTypes;\n\t}\n\n\t/**\n\t * Return the list of notification types.\n\t */\n\tpublic String @Nullable [] getNotificationTypes() {\n\t\treturn this.notificationTypes;\n\t}\n\n\t/**\n\t * Set the name of this notification.\n\t */\n\tpublic void setName(@Nullable String name) {\n\t\tthis.name = name;\n\t}\n\n\t/**\n\t * Return the name of this notification.\n\t */\n\tpublic @Nullable String getName() {\n\t\treturn this.name;\n\t}\n\n\t/**\n\t * Set a description for this notification.\n\t */\n\tpublic void setDescription(@Nullable String description) {\n\t\tthis.description = description;\n\t}\n\n\t/**\n\t * Return a description for this notification.\n\t */\n\tpublic @Nullable String getDescription() {\n\t\treturn this.description;\n\t}\n\n}"
  },
  "org.springframework.jmx.export.metadata.ManagedNotification#getDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a description for this notification.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "String",
    "signature": "public String getDescription()",
    "source_code": "\tpublic @Nullable String getDescription() {\n\t\treturn this.description;\n\t}"
  },
  "org.springframework.jmx.export.metadata.ManagedNotification#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of this notification.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "\tpublic @Nullable String getName() {\n\t\treturn this.name;\n\t}"
  },
  "org.springframework.jmx.export.metadata.ManagedNotification#setDescription(description)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a description for this notification.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "description"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void setDescription(@Nullable String description)",
    "source_code": "\tpublic void setDescription(@Nullable String description) {\n\t\tthis.description = description;\n\t}"
  },
  "org.springframework.jmx.export.metadata.ManagedNotification#setName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of this notification.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "void",
    "signature": "public void setName(@Nullable String name)",
    "source_code": "\tpublic void setName(@Nullable String name) {\n\t\tthis.name = name;\n\t}"
  },
  "org.springframework.jmx.export.metadata.ManagedNotification#setNotificationType(notificationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a single notification type, or a list of notification types\n\t * as comma-delimited String.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "notificationType"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "return": "void",
    "signature": "public void setNotificationType(String notificationType)",
    "source_code": "\tpublic void setNotificationType(String notificationType) {\n\t\tthis.notificationTypes = StringUtils.commaDelimitedListToStringArray(notificationType);\n\t}"
  },
  "org.springframework.jmx.export.metadata.ManagedNotification#setNotificationTypes(notificationTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a list of notification types.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "notificationTypes"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "void",
    "signature": "public void setNotificationTypes(String @Nullable ... notificationTypes)",
    "source_code": "\tpublic void setNotificationTypes(String @Nullable ... notificationTypes) {\n\t\tthis.notificationTypes = notificationTypes;\n\t}"
  },
  "org.springframework.jmx.export.naming.KeyNamingStrategy": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code ObjectNamingStrategy} implementation that builds\n * {@code ObjectName} instances from the key used in the\n * \"beans\" map passed to {@code MBeanExporter}.\n *\n * <p>Can also check object name mappings, given as {@code Properties}\n * or as {@code mappingLocations} of properties files. The key used\n * to look up is the key used in {@code MBeanExporter}'s \"beans\" map.\n * If no mapping is found for a given key, the key itself is used to\n * build an {@code ObjectName}.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @since 1.2\n * @see #setMappings\n * @see #setMappingLocation\n * @see #setMappingLocations\n * @see org.springframework.jmx.export.MBeanExporter#setBeans\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public class KeyNamingStrategy",
    "source_code": "public class KeyNamingStrategy implements ObjectNamingStrategy, InitializingBean {\n\n\t/**\n\t * {@code Log} instance for this class.\n\t */\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t/**\n\t * Stores the mappings of bean key to {@code ObjectName}.\n\t */\n\tprivate @Nullable Properties mappings;\n\n\t/**\n\t * Stores the {@code Resource}s containing properties that should be loaded\n\t * into the final merged set of {@code Properties} used for {@code ObjectName}\n\t * resolution.\n\t */\n\tprivate Resource @Nullable [] mappingLocations;\n\n\t/**\n\t * Stores the result of merging the {@code mappings} {@code Properties}\n\t * with the properties stored in the resources defined by {@code mappingLocations}.\n\t */\n\tprivate @Nullable Properties mergedMappings;\n\n\n\t/**\n\t * Set local properties, containing object name mappings, for example, via\n\t * the \"props\" tag in XML bean definitions. These can be considered\n\t * defaults, to be overridden by properties loaded from files.\n\t */\n\tpublic void setMappings(Properties mappings) {\n\t\tthis.mappings = mappings;\n\t}\n\n\t/**\n\t * Set a location of a properties file to be loaded,\n\t * containing object name mappings.\n\t */\n\tpublic void setMappingLocation(Resource location) {\n\t\tthis.mappingLocations = new Resource[] {location};\n\t}\n\n\t/**\n\t * Set location of properties files to be loaded,\n\t * containing object name mappings.\n\t */\n\tpublic void setMappingLocations(Resource... mappingLocations) {\n\t\tthis.mappingLocations = mappingLocations;\n\t}\n\n\n\t/**\n\t * Merges the {@code Properties} configured in the {@code mappings} and\n\t * {@code mappingLocations} into the final {@code Properties} instance\n\t * used for {@code ObjectName} resolution.\n\t */\n\t@Override\n\tpublic void afterPropertiesSet() throws IOException {\n\t\tthis.mergedMappings = new Properties();\n\t\tCollectionUtils.mergePropertiesIntoMap(this.mappings, this.mergedMappings);\n\n\t\tif (this.mappingLocations != null) {\n\t\t\tfor (Resource location : this.mappingLocations) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Loading JMX object name mappings file from \" + location);\n\t\t\t\t}\n\t\t\t\tPropertiesLoaderUtils.fillProperties(this.mergedMappings, location);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Attempts to retrieve the {@code ObjectName} via the given key, trying to\n\t * find a mapped value in the mappings first.\n\t */\n\t@Override\n\tpublic ObjectName getObjectName(Object managedBean, @Nullable String beanKey) throws MalformedObjectNameException {\n\t\tAssert.notNull(beanKey, \"KeyNamingStrategy requires bean key\");\n\t\tString objectName = null;\n\t\tif (this.mergedMappings != null) {\n\t\t\tobjectName = this.mergedMappings.getProperty(beanKey);\n\t\t}\n\t\tif (objectName == null) {\n\t\t\tobjectName = beanKey;\n\t\t}\n\t\treturn ObjectNameManager.getInstance(objectName);\n\t}\n\n}"
  },
  "org.springframework.jmx.export.naming.KeyNamingStrategy#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Merges the {@code Properties} configured in the {@code mappings} and\n\t * {@code mappingLocations} into the final {@code Properties} instance\n\t * used for {@code ObjectName} resolution.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() throws IOException {\n\t\tthis.mergedMappings = new Properties();\n\t\tCollectionUtils.mergePropertiesIntoMap(this.mappings, this.mergedMappings);\n\n\t\tif (this.mappingLocations != null) {\n\t\t\tfor (Resource location : this.mappingLocations) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Loading JMX object name mappings file from \" + location);\n\t\t\t\t}\n\t\t\t\tPropertiesLoaderUtils.fillProperties(this.mergedMappings, location);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.naming.KeyNamingStrategy#getObjectName(managedBean,beanKey)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempts to retrieve the {@code ObjectName} via the given key, trying to\n\t * find a mapped value in the mappings first.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "managedBean",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "ObjectName",
    "signature": "public ObjectName getObjectName(Object managedBean, @Nullable String beanKey)",
    "source_code": "\tpublic ObjectName getObjectName(Object managedBean, @Nullable String beanKey) throws MalformedObjectNameException {\n\t\tAssert.notNull(beanKey, \"KeyNamingStrategy requires bean key\");\n\t\tString objectName = null;\n\t\tif (this.mergedMappings != null) {\n\t\t\tobjectName = this.mergedMappings.getProperty(beanKey);\n\t\t}\n\t\tif (objectName == null) {\n\t\t\tobjectName = beanKey;\n\t\t}\n\t\treturn ObjectNameManager.getInstance(objectName);\n\t}"
  },
  "org.springframework.jmx.export.naming.KeyNamingStrategy#setMappingLocation(location)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a location of a properties file to be loaded,\n\t * containing object name mappings.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void setMappingLocation(Resource location)",
    "source_code": "\tpublic void setMappingLocation(Resource location) {\n\t\tthis.mappingLocations = new Resource[] {location};\n\t}"
  },
  "org.springframework.jmx.export.naming.KeyNamingStrategy#setMappingLocations(mappingLocations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set location of properties files to be loaded,\n\t * containing object name mappings.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappingLocations"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void setMappingLocations(Resource... mappingLocations)",
    "source_code": "\tpublic void setMappingLocations(Resource... mappingLocations) {\n\t\tthis.mappingLocations = mappingLocations;\n\t}"
  },
  "org.springframework.jmx.export.naming.KeyNamingStrategy#setMappings(mappings)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set local properties, containing object name mappings, for example, via\n\t * the \"props\" tag in XML bean definitions. These can be considered\n\t * defaults, to be overridden by properties loaded from files.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappings"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void setMappings(Properties mappings)",
    "source_code": "\tpublic void setMappings(Properties mappings) {\n\t\tthis.mappings = mappings;\n\t}"
  },
  "org.springframework.jmx.export.naming.logger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@code Log} instance for this class.\n\t */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.jmx.support.IDENTITY_OBJECT_NAME_KEY": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The key used when extending an existing {@link ObjectName} with the\n\t * identity hash code of its corresponding managed resource.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "signature": "public String IDENTITY_OBJECT_NAME_KEY",
    "source_code": "\tpublic static final String IDENTITY_OBJECT_NAME_KEY = \"identity\";",
    "type": "String"
  },
  "org.springframework.jmx.support.JmxUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Collection of generic utility methods to support Spring JMX.\n * Includes a convenient method to locate an MBeanServer.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @since 1.2\n * @see #locateMBeanServer\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public class JmxUtils",
    "source_code": "public abstract class JmxUtils {\n\n\t/**\n\t * The key used when extending an existing {@link ObjectName} with the\n\t * identity hash code of its corresponding managed resource.\n\t */\n\tpublic static final String IDENTITY_OBJECT_NAME_KEY = \"identity\";\n\n\t/**\n\t * Suffix used to identify an MBean interface.\n\t */\n\tprivate static final String MBEAN_SUFFIX = \"MBean\";\n\n\n\tprivate static final Log logger = LogFactory.getLog(JmxUtils.class);\n\n\n\t/**\n\t * Attempt to find a locally running {@code MBeanServer}. Fails if no\n\t * {@code MBeanServer} can be found. Logs a warning if more than one\n\t * {@code MBeanServer} found, returning the first one from the list.\n\t * @return the {@code MBeanServer} if found\n\t * @throws MBeanServerNotFoundException if no {@code MBeanServer} could be found\n\t * @see javax.management.MBeanServerFactory#findMBeanServer\n\t */\n\tpublic static MBeanServer locateMBeanServer() throws MBeanServerNotFoundException {\n\t\treturn locateMBeanServer(null);\n\t}\n\n\t/**\n\t * Attempt to find a locally running {@code MBeanServer}. Fails if no\n\t * {@code MBeanServer} can be found. Logs a warning if more than one\n\t * {@code MBeanServer} found, returning the first one from the list.\n\t * @param agentId the agent identifier of the MBeanServer to retrieve.\n\t * If this parameter is {@code null}, all registered MBeanServers are considered.\n\t * If the empty String is given, the platform MBeanServer will be returned.\n\t * @return the {@code MBeanServer} if found\n\t * @throws MBeanServerNotFoundException if no {@code MBeanServer} could be found\n\t * @see javax.management.MBeanServerFactory#findMBeanServer(String)\n\t */\n\tpublic static MBeanServer locateMBeanServer(@Nullable String agentId) throws MBeanServerNotFoundException {\n\t\tMBeanServer server = null;\n\n\t\t// null means any registered server, but \"\" specifically means the platform server\n\t\tif (!\"\".equals(agentId)) {\n\t\t\tList<MBeanServer> servers = MBeanServerFactory.findMBeanServer(agentId);\n\t\t\tif (!CollectionUtils.isEmpty(servers)) {\n\t\t\t\t// Check to see if an MBeanServer is registered.\n\t\t\t\tif (servers.size() > 1 && logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"Found more than one MBeanServer instance\" +\n\t\t\t\t\t\t\t(agentId != null ? \" with agent id [\" + agentId + \"]\" : \"\") +\n\t\t\t\t\t\t\t\". Returning first from list.\");\n\t\t\t\t}\n\t\t\t\tserver = servers.get(0);\n\t\t\t}\n\t\t}\n\n\t\tif (server == null && !StringUtils.hasLength(agentId)) {\n\t\t\t// Attempt to load the PlatformMBeanServer.\n\t\t\ttry {\n\t\t\t\tserver = ManagementFactory.getPlatformMBeanServer();\n\t\t\t}\n\t\t\tcatch (SecurityException ex) {\n\t\t\t\tthrow new MBeanServerNotFoundException(\"No specific MBeanServer found, \" +\n\t\t\t\t\t\t\"and not allowed to obtain the Java platform MBeanServer\", ex);\n\t\t\t}\n\t\t}\n\n\t\tif (server == null) {\n\t\t\tthrow new MBeanServerNotFoundException(\n\t\t\t\t\t\"Unable to locate an MBeanServer instance\" +\n\t\t\t\t\t(agentId != null ? \" with agent id [\" + agentId + \"]\" : \"\"));\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Found MBeanServer: \" + server);\n\t\t}\n\t\treturn server;\n\t}\n\n\t/**\n\t * Convert an array of {@code MBeanParameterInfo} into an array of\n\t * {@code Class} instances corresponding to the parameters.\n\t * @param paramInfo the JMX parameter info\n\t * @return the parameter types as classes\n\t * @throws ClassNotFoundException if a parameter type could not be resolved\n\t */\n\tpublic static Class<?> @Nullable [] parameterInfoToTypes(MBeanParameterInfo @Nullable [] paramInfo)\n\t\t\tthrows ClassNotFoundException {\n\n\t\treturn parameterInfoToTypes(paramInfo, ClassUtils.getDefaultClassLoader());\n\t}\n\n\t/**\n\t * Convert an array of {@code MBeanParameterInfo} into an array of\n\t * {@code Class} instances corresponding to the parameters.\n\t * @param paramInfo the JMX parameter info\n\t * @param classLoader the ClassLoader to use for loading parameter types\n\t * @return the parameter types as classes\n\t * @throws ClassNotFoundException if a parameter type could not be resolved\n\t */\n\tpublic static Class<?> @Nullable [] parameterInfoToTypes(\n\t\t\tMBeanParameterInfo @Nullable [] paramInfo, @Nullable ClassLoader classLoader)\n\t\t\tthrows ClassNotFoundException {\n\n\t\tClass<?>[] types = null;\n\t\tif (paramInfo != null && paramInfo.length > 0) {\n\t\t\ttypes = new Class<?>[paramInfo.length];\n\t\t\tfor (int x = 0; x < paramInfo.length; x++) {\n\t\t\t\ttypes[x] = ClassUtils.forName(paramInfo[x].getType(), classLoader);\n\t\t\t}\n\t\t}\n\t\treturn types;\n\t}\n\n\t/**\n\t * Create a {@code String[]} representing the argument signature of a\n\t * method. Each element in the array is the fully qualified class name\n\t * of the corresponding argument in the method's signature.\n\t * @param method the method to build an argument signature for\n\t * @return the signature as array of argument types\n\t */\n\tpublic static String[] getMethodSignature(Method method) {\n\t\tClass<?>[] types = method.getParameterTypes();\n\t\tString[] signature = new String[types.length];\n\t\tfor (int x = 0; x < types.length; x++) {\n\t\t\tsignature[x] = types[x].getName();\n\t\t}\n\t\treturn signature;\n\t}\n\n\t/**\n\t * Return the JMX attribute name to use for the given JavaBeans property.\n\t * <p>When using strict casing, a JavaBean property with a getter method\n\t * such as {@code getFoo()} translates to an attribute called\n\t * {@code Foo}. With strict casing disabled, {@code getFoo()}\n\t * would translate to just {@code foo}.\n\t * @param property the JavaBeans property descriptor\n\t * @param useStrictCasing whether to use strict casing\n\t * @return the JMX attribute name to use\n\t */\n\tpublic static String getAttributeName(PropertyDescriptor property, boolean useStrictCasing) {\n\t\tif (useStrictCasing) {\n\t\t\treturn StringUtils.capitalize(property.getName());\n\t\t}\n\t\telse {\n\t\t\treturn property.getName();\n\t\t}\n\t}\n\n\t/**\n\t * Append an additional key/value pair to an existing {@link ObjectName} with the key being\n\t * the static value {@code identity} and the value being the identity hash code of the\n\t * managed resource being exposed on the supplied {@link ObjectName}. This can be used to\n\t * provide a unique {@link ObjectName} for each distinct instance of a particular bean or\n\t * class. Useful when generating {@link ObjectName ObjectNames} at runtime for a set of\n\t * managed resources based on the template value supplied by a\n\t * {@link org.springframework.jmx.export.naming.ObjectNamingStrategy}.\n\t * @param objectName the original JMX ObjectName\n\t * @param managedResource the MBean instance\n\t * @return an ObjectName with the MBean identity added\n\t * @throws MalformedObjectNameException in case of an invalid object name specification\n\t * @see org.springframework.util.ObjectUtils#getIdentityHexString(Object)\n\t */\n\tpublic static ObjectName appendIdentityToObjectName(ObjectName objectName, Object managedResource)\n\t\t\tthrows MalformedObjectNameException {\n\n\t\tHashtable<String, String> keyProperties = objectName.getKeyPropertyList();\n\t\tkeyProperties.put(IDENTITY_OBJECT_NAME_KEY, ObjectUtils.getIdentityHexString(managedResource));\n\t\treturn ObjectNameManager.getInstance(objectName.getDomain(), keyProperties);\n\t}\n\n\t/**\n\t * Return the class or interface to expose for the given bean.\n\t * This is the class that will be searched for attributes and operations\n\t * (for example, checked for annotations).\n\t * <p>This implementation returns the superclass for a CGLIB proxy and\n\t * the class of the given bean else (for a JDK proxy or a plain bean class).\n\t * @param managedBean the bean instance (might be an AOP proxy)\n\t * @return the bean class to expose\n\t * @see org.springframework.util.ClassUtils#getUserClass(Object)\n\t */\n\tpublic static Class<?> getClassToExpose(Object managedBean) {\n\t\treturn ClassUtils.getUserClass(managedBean);\n\t}\n\n\t/**\n\t * Return the class or interface to expose for the given bean class.\n\t * This is the class that will be searched for attributes and operations\n\t * (for example, checked for annotations).\n\t * <p>This implementation returns the superclass for a CGLIB proxy and\n\t * the class of the given bean else (for a JDK proxy or a plain bean class).\n\t * @param clazz the bean class (might be an AOP proxy class)\n\t * @return the bean class to expose\n\t * @see org.springframework.util.ClassUtils#getUserClass(Class)\n\t */\n\tpublic static Class<?> getClassToExpose(Class<?> clazz) {\n\t\treturn ClassUtils.getUserClass(clazz);\n\t}\n\n\t/**\n\t * Determine whether the given bean class qualifies as an MBean as-is.\n\t * <p>This implementation checks for {@link javax.management.DynamicMBean}\n\t * classes as well as classes with corresponding \"*MBean\" interface\n\t * (Standard MBeans) or corresponding \"*MXBean\" interface (Java MXBeans).\n\t * @param clazz the bean class to analyze\n\t * @return whether the class qualifies as an MBean\n\t * @see org.springframework.jmx.export.MBeanExporter#isMBean(Class)\n\t */\n\tpublic static boolean isMBean(@Nullable Class<?> clazz) {\n\t\treturn (clazz != null &&\n\t\t\t\t(DynamicMBean.class.isAssignableFrom(clazz) ||\n\t\t\t\t\t\t(getMBeanInterface(clazz) != null || getMXBeanInterface(clazz) != null)));\n\t}\n\n\t/**\n\t * Return the Standard MBean interface for the given class, if any\n\t * (that is, an interface whose name matches the class name of the\n\t * given class but with suffix \"MBean\").\n\t * @param clazz the class to check\n\t * @return the Standard MBean interface for the given class\n\t */\n\tpublic static @Nullable Class<?> getMBeanInterface(@Nullable Class<?> clazz) {\n\t\tif (clazz == null || clazz.getSuperclass() == null) {\n\t\t\treturn null;\n\t\t}\n\t\tString mbeanInterfaceName = clazz.getName() + MBEAN_SUFFIX;\n\t\tClass<?>[] implementedInterfaces = clazz.getInterfaces();\n\t\tfor (Class<?> iface : implementedInterfaces) {\n\t\t\tif (iface.getName().equals(mbeanInterfaceName)) {\n\t\t\t\treturn iface;\n\t\t\t}\n\t\t}\n\t\treturn getMBeanInterface(clazz.getSuperclass());\n\t}\n\n\t/**\n\t * Return the Java MXBean interface for the given class, if any\n\t * (that is, an interface whose name ends with \"MXBean\" and/or\n\t * carries an appropriate MXBean annotation).\n\t * @param clazz the class to check\n\t * @return whether there is an MXBean interface for the given class\n\t */\n\tpublic static @Nullable Class<?> getMXBeanInterface(@Nullable Class<?> clazz) {\n\t\tif (clazz == null || clazz.getSuperclass() == null) {\n\t\t\treturn null;\n\t\t}\n\t\tClass<?>[] implementedInterfaces = clazz.getInterfaces();\n\t\tfor (Class<?> iface : implementedInterfaces) {\n\t\t\tif (JMX.isMXBeanInterface(iface)) {\n\t\t\t\treturn iface;\n\t\t\t}\n\t\t}\n\t\treturn getMXBeanInterface(clazz.getSuperclass());\n\t}\n\n}"
  },
  "org.springframework.jmx.support.JmxUtils#appendIdentityToObjectName(objectName,managedResource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Append an additional key/value pair to an existing {@link ObjectName} with the key being\n\t * the static value {@code identity} and the value being the identity hash code of the\n\t * managed resource being exposed on the supplied {@link ObjectName}. This can be used to\n\t * provide a unique {@link ObjectName} for each distinct instance of a particular bean or\n\t * class. Useful when generating {@link ObjectName ObjectNames} at runtime for a set of\n\t * managed resources based on the template value supplied by a\n\t * {@link org.springframework.jmx.export.naming.ObjectNamingStrategy}.\n\t * @param objectName the original JMX ObjectName\n\t * @param managedResource the MBean instance\n\t * @return an ObjectName with the MBean identity added\n\t * @throws MalformedObjectNameException in case of an invalid object name specification\n\t * @see org.springframework.util.ObjectUtils#getIdentityHexString(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "objectName",
      "managedResource"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "ObjectName",
    "signature": "public ObjectName appendIdentityToObjectName(ObjectName objectName, Object managedResource)",
    "source_code": "\tpublic static ObjectName appendIdentityToObjectName(ObjectName objectName, Object managedResource)"
  },
  "org.springframework.jmx.support.JmxUtils#getAttributeName(property,useStrictCasing)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JMX attribute name to use for the given JavaBeans property.\n\t * <p>When using strict casing, a JavaBean property with a getter method\n\t * such as {@code getFoo()} translates to an attribute called\n\t * {@code Foo}. With strict casing disabled, {@code getFoo()}\n\t * would translate to just {@code foo}.\n\t * @param property the JavaBeans property descriptor\n\t * @param useStrictCasing whether to use strict casing\n\t * @return the JMX attribute name to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "property",
      "useStrictCasing"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "String",
    "signature": "public String getAttributeName(PropertyDescriptor property, boolean useStrictCasing)",
    "source_code": "\tpublic static String getAttributeName(PropertyDescriptor property, boolean useStrictCasing) {\n\t\tif (useStrictCasing) {\n\t\t\treturn StringUtils.capitalize(property.getName());\n\t\t}\n\t\telse {\n\t\t\treturn property.getName();\n\t\t}\n\t}"
  },
  "org.springframework.jmx.support.JmxUtils#getMethodSignature(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@code String[]} representing the argument signature of a\n\t * method. Each element in the array is the fully qualified class name\n\t * of the corresponding argument in the method's signature.\n\t * @param method the method to build an argument signature for\n\t * @return the signature as array of argument types\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "String[]",
    "signature": "public String[] getMethodSignature(Method method)",
    "source_code": "\tpublic static String[] getMethodSignature(Method method) {\n\t\tClass<?>[] types = method.getParameterTypes();\n\t\tString[] signature = new String[types.length];\n\t\tfor (int x = 0; x < types.length; x++) {\n\t\t\tsignature[x] = types[x].getName();\n\t\t}\n\t\treturn signature;\n\t}"
  },
  "org.springframework.jmx.support.JmxUtils#isMBean(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given bean class qualifies as an MBean as-is.\n\t * <p>This implementation checks for {@link javax.management.DynamicMBean}\n\t * classes as well as classes with corresponding \"*MBean\" interface\n\t * (Standard MBeans) or corresponding \"*MXBean\" interface (Java MXBeans).\n\t * @param clazz the bean class to analyze\n\t * @return whether the class qualifies as an MBean\n\t * @see org.springframework.jmx.export.MBeanExporter#isMBean(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "boolean",
    "signature": "public boolean isMBean(@Nullable Class<?> clazz)",
    "source_code": "\tpublic static boolean isMBean(@Nullable Class<?> clazz) {\n\t\treturn (clazz != null &&\n\t\t\t\t(DynamicMBean.class.isAssignableFrom(clazz) ||\n\t\t\t\t\t\t(getMBeanInterface(clazz) != null || getMXBeanInterface(clazz) != null)));\n\t}"
  },
  "org.springframework.jmx.support.JmxUtils#locateMBeanServer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to find a locally running {@code MBeanServer}. Fails if no\n\t * {@code MBeanServer} can be found. Logs a warning if more than one\n\t * {@code MBeanServer} found, returning the first one from the list.\n\t * @return the {@code MBeanServer} if found\n\t * @throws MBeanServerNotFoundException if no {@code MBeanServer} could be found\n\t * @see javax.management.MBeanServerFactory#findMBeanServer\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "MBeanServer",
    "signature": "public MBeanServer locateMBeanServer()",
    "source_code": "\tpublic static MBeanServer locateMBeanServer() throws MBeanServerNotFoundException {\n\t\treturn locateMBeanServer(null);\n\t}"
  },
  "org.springframework.jmx.support.JmxUtils#locateMBeanServer(agentId)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to find a locally running {@code MBeanServer}. Fails if no\n\t * {@code MBeanServer} can be found. Logs a warning if more than one\n\t * {@code MBeanServer} found, returning the first one from the list.\n\t * @param agentId the agent identifier of the MBeanServer to retrieve.\n\t * If this parameter is {@code null}, all registered MBeanServers are considered.\n\t * If the empty String is given, the platform MBeanServer will be returned.\n\t * @return the {@code MBeanServer} if found\n\t * @throws MBeanServerNotFoundException if no {@code MBeanServer} could be found\n\t * @see javax.management.MBeanServerFactory#findMBeanServer(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "agentId"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "MBeanServer",
    "signature": "public MBeanServer locateMBeanServer(@Nullable String agentId)",
    "source_code": "\tpublic static MBeanServer locateMBeanServer(@Nullable String agentId) throws MBeanServerNotFoundException {\n\t\tMBeanServer server = null;\n\n\t\t// null means any registered server, but \"\" specifically means the platform server\n\t\tif (!\"\".equals(agentId)) {\n\t\t\tList<MBeanServer> servers = MBeanServerFactory.findMBeanServer(agentId);\n\t\t\tif (!CollectionUtils.isEmpty(servers)) {\n\t\t\t\t// Check to see if an MBeanServer is registered.\n\t\t\t\tif (servers.size() > 1 && logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"Found more than one MBeanServer instance\" +\n\t\t\t\t\t\t\t(agentId != null ? \" with agent id [\" + agentId + \"]\" : \"\") +\n\t\t\t\t\t\t\t\". Returning first from list.\");\n\t\t\t\t}\n\t\t\t\tserver = servers.get(0);\n\t\t\t}\n\t\t}\n\n\t\tif (server == null && !StringUtils.hasLength(agentId)) {\n\t\t\t// Attempt to load the PlatformMBeanServer.\n\t\t\ttry {\n\t\t\t\tserver = ManagementFactory.getPlatformMBeanServer();\n\t\t\t}\n\t\t\tcatch (SecurityException ex) {\n\t\t\t\tthrow new MBeanServerNotFoundException(\"No specific MBeanServer found, \" +\n\t\t\t\t\t\t\"and not allowed to obtain the Java platform MBeanServer\", ex);\n\t\t\t}\n\t\t}\n\n\t\tif (server == null) {\n\t\t\tthrow new MBeanServerNotFoundException(\n\t\t\t\t\t\"Unable to locate an MBeanServer instance\" +\n\t\t\t\t\t(agentId != null ? \" with agent id [\" + agentId + \"]\" : \"\"));\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Found MBeanServer: \" + server);\n\t\t}\n\t\treturn server;\n\t}"
  },
  "org.springframework.jmx.support.NotificationListenerHolder#getResolvedObjectNames()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the list of {@link javax.management.ObjectName} String representations for\n\t * which the encapsulated {@link #getNotificationFilter() NotificationFilter} will\n\t * be registered as a listener for {@link javax.management.Notification Notifications}.\n\t * @throws MalformedObjectNameException if an {@code ObjectName} is malformed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "ObjectName[]",
    "signature": "public ObjectName[] getResolvedObjectNames()",
    "source_code": "\tpublic ObjectName[] getResolvedObjectNames() throws MalformedObjectNameException {\n\t\tif (this.mappedObjectNames == null) {\n\t\t\treturn null;\n\t\t}\n\t\tObjectName[] resolved = new ObjectName[this.mappedObjectNames.size()];\n\t\tint i = 0;\n\t\tfor (Object objectName : this.mappedObjectNames) {\n\t\t\tresolved[i] = ObjectNameManager.getInstance(objectName);\n\t\t\ti++;\n\t\t}\n\t\treturn resolved;\n\t}"
  },
  "org.springframework.jndi.JndiTemplate": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Helper class that simplifies JNDI operations. It provides methods to lookup and\n * bind objects, and allows implementations of the {@link JndiCallback} interface\n * to perform any operation they like with a JNDI naming context provided.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @see JndiCallback\n * @see #execute\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public class JndiTemplate",
    "source_code": "public class JndiTemplate {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate @Nullable Properties environment;\n\n\n\t/**\n\t * Create a new JndiTemplate instance.\n\t */\n\tpublic JndiTemplate() {\n\t}\n\n\t/**\n\t * Create a new JndiTemplate instance, using the given environment.\n\t */\n\tpublic JndiTemplate(@Nullable Properties environment) {\n\t\tthis.environment = environment;\n\t}\n\n\n\t/**\n\t * Set the environment for the JNDI InitialContext.\n\t */\n\tpublic void setEnvironment(@Nullable Properties environment) {\n\t\tthis.environment = environment;\n\t}\n\n\t/**\n\t * Return the environment for the JNDI InitialContext, if any.\n\t */\n\tpublic @Nullable Properties getEnvironment() {\n\t\treturn this.environment;\n\t}\n\n\n\t/**\n\t * Execute the given JNDI context callback implementation.\n\t * @param contextCallback the JndiCallback implementation to use\n\t * @return a result object returned by the callback, or {@code null}\n\t * @throws NamingException thrown by the callback implementation\n\t * @see #createInitialContext\n\t */\n\tpublic <T> @Nullable T execute(JndiCallback<T> contextCallback) throws NamingException {\n\t\tContext ctx = getContext();\n\t\ttry {\n\t\t\treturn contextCallback.doInContext(ctx);\n\t\t}\n\t\tfinally {\n\t\t\treleaseContext(ctx);\n\t\t}\n\t}\n\n\t/**\n\t * Obtain a JNDI context corresponding to this template's configuration.\n\t * Called by {@link #execute}; may also be called directly.\n\t * <p>The default implementation delegates to {@link #createInitialContext()}.\n\t * @return the JNDI context (never {@code null})\n\t * @throws NamingException if context retrieval failed\n\t * @see #releaseContext\n\t */\n\tpublic Context getContext() throws NamingException {\n\t\treturn createInitialContext();\n\t}\n\n\t/**\n\t * Release a JNDI context as obtained from {@link #getContext()}.\n\t * @param ctx the JNDI context to release (may be {@code null})\n\t * @see #getContext\n\t */\n\tpublic void releaseContext(@Nullable Context ctx) {\n\t\tif (ctx != null) {\n\t\t\ttry {\n\t\t\t\tctx.close();\n\t\t\t}\n\t\t\tcatch (NamingException ex) {\n\t\t\t\tlogger.debug(\"Could not close JNDI InitialContext\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Create a new JNDI initial context. Invoked by {@link #getContext}.\n\t * <p>The default implementation use this template's environment settings.\n\t * Can be subclassed for custom contexts, for example, for testing.\n\t * @return the initial Context instance\n\t * @throws NamingException in case of initialization errors\n\t */\n\tprotected Context createInitialContext() throws NamingException {\n\t\tHashtable<?, ?> icEnv = null;\n\t\tProperties env = getEnvironment();\n\t\tif (env != null) {\n\t\t\ticEnv = new Hashtable<>(env.size());\n\t\t\tCollectionUtils.mergePropertiesIntoMap(env, icEnv);\n\t\t}\n\t\treturn new InitialContext(icEnv);\n\t}\n\n\n\t/**\n\t * Look up the object with the given name in the current JNDI context.\n\t * @param name the JNDI name of the object\n\t * @return object found (cannot be {@code null}; if a not so well-behaved\n\t * JNDI implementations returns null, a NamingException gets thrown)\n\t * @throws NamingException if there is no object with the given\n\t * name bound to JNDI\n\t */\n\tpublic Object lookup(final String name) throws NamingException {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Looking up JNDI object with name [\" + name + \"]\");\n\t\t}\n\t\tObject result = execute(ctx -> ctx.lookup(name));\n\t\tif (result == null) {\n\t\t\tthrow new NameNotFoundException(\n\t\t\t\t\t\"JNDI object with [\" + name + \"] not found: JNDI implementation returned null\");\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Look up the object with the given name in the current JNDI context.\n\t * @param name the JNDI name of the object\n\t * @param requiredType type the JNDI object must match. Can be an interface or\n\t * superclass of the actual class, or {@code null} for any match. For example,\n\t * if the value is {@code Object.class}, this method will succeed whatever\n\t * the class of the returned instance.\n\t * @return object found (cannot be {@code null}; if a not so well-behaved\n\t * JNDI implementations returns null, a NamingException gets thrown)\n\t * @throws NamingException if there is no object with the given\n\t * name bound to JNDI\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T lookup(String name, @Nullable Class<T> requiredType) throws NamingException {\n\t\tObject jndiObject = lookup(name);\n\t\tif (requiredType != null && !requiredType.isInstance(jndiObject)) {\n\t\t\tthrow new TypeMismatchNamingException(name, requiredType, jndiObject.getClass());\n\t\t}\n\t\treturn (T) jndiObject;\n\t}\n\n\t/**\n\t * Bind the given object to the current JNDI context, using the given name.\n\t * @param name the JNDI name of the object\n\t * @param object the object to bind\n\t * @throws NamingException thrown by JNDI, mostly name already bound\n\t */\n\tpublic void bind(final String name, final Object object) throws NamingException {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Binding JNDI object with name [\" + name + \"]\");\n\t\t}\n\t\texecute(ctx -> {\n\t\t\tctx.bind(name, object);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t/**\n\t * Rebind the given object to the current JNDI context, using the given name.\n\t * Overwrites any existing binding.\n\t * @param name the JNDI name of the object\n\t * @param object the object to rebind\n\t * @throws NamingException thrown by JNDI\n\t */\n\tpublic void rebind(final String name, final Object object) throws NamingException {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Rebinding JNDI object with name [\" + name + \"]\");\n\t\t}\n\t\texecute(ctx -> {\n\t\t\tctx.rebind(name, object);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t/**\n\t * Remove the binding for the given name from the current JNDI context.\n\t * @param name the JNDI name of the object\n\t * @throws NamingException thrown by JNDI, mostly name not found\n\t */\n\tpublic void unbind(final String name) throws NamingException {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Unbinding JNDI object with name [\" + name + \"]\");\n\t\t}\n\t\texecute(ctx -> {\n\t\t\tctx.unbind(name);\n\t\t\treturn null;\n\t\t});\n\t}\n\n}"
  },
  "org.springframework.jndi.JndiTemplate#bind(name,object)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Bind the given object to the current JNDI context, using the given name.\n\t * @param name the JNDI name of the object\n\t * @param object the object to bind\n\t * @throws NamingException thrown by JNDI, mostly name already bound\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "object"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "void",
    "signature": "public void bind(final String name, final Object object)",
    "source_code": "\tpublic void bind(final String name, final Object object) throws NamingException {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Binding JNDI object with name [\" + name + \"]\");\n\t\t}\n\t\texecute(ctx -> {\n\t\t\tctx.bind(name, object);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.jndi.JndiTemplate#createInitialContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new JNDI initial context. Invoked by {@link #getContext}.\n\t * <p>The default implementation use this template's environment settings.\n\t * Can be subclassed for custom contexts, for example, for testing.\n\t * @return the initial Context instance\n\t * @throws NamingException in case of initialization errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "Context",
    "signature": "protected Context createInitialContext()",
    "source_code": "\tprotected Context createInitialContext() throws NamingException {\n\t\tHashtable<?, ?> icEnv = null;\n\t\tProperties env = getEnvironment();\n\t\tif (env != null) {\n\t\t\ticEnv = new Hashtable<>(env.size());\n\t\t\tCollectionUtils.mergePropertiesIntoMap(env, icEnv);\n\t\t}\n\t\treturn new InitialContext(icEnv);\n\t}"
  },
  "org.springframework.jndi.JndiTemplate#execute(contextCallback)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the given JNDI context callback implementation.\n\t * @param contextCallback the JndiCallback implementation to use\n\t * @return a result object returned by the callback, or {@code null}\n\t * @throws NamingException thrown by the callback implementation\n\t * @see #createInitialContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contextCallback"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "T",
    "signature": "public T execute(JndiCallback<T> contextCallback)",
    "source_code": "\tpublic <T> @Nullable T execute(JndiCallback<T> contextCallback) throws NamingException {\n\t\tContext ctx = getContext();\n\t\ttry {\n\t\t\treturn contextCallback.doInContext(ctx);\n\t\t}\n\t\tfinally {\n\t\t\treleaseContext(ctx);\n\t\t}\n\t}"
  },
  "org.springframework.jndi.JndiTemplate#getContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JNDI context corresponding to this template's configuration.\n\t * Called by {@link #execute}; may also be called directly.\n\t * <p>The default implementation delegates to {@link #createInitialContext()}.\n\t * @return the JNDI context (never {@code null})\n\t * @throws NamingException if context retrieval failed\n\t * @see #releaseContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "Context",
    "signature": "public Context getContext()",
    "source_code": "\tpublic Context getContext() throws NamingException {\n\t\treturn createInitialContext();\n\t}"
  },
  "org.springframework.jndi.JndiTemplate#getEnvironment()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the environment for the JNDI InitialContext, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "Properties",
    "signature": "public Properties getEnvironment()",
    "source_code": "\tpublic @Nullable Properties getEnvironment() {\n\t\treturn this.environment;\n\t}"
  },
  "org.springframework.jndi.JndiTemplate#lookup(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look up the object with the given name in the current JNDI context.\n\t * @param name the JNDI name of the object\n\t * @return object found (cannot be {@code null}; if a not so well-behaved\n\t * JNDI implementations returns null, a NamingException gets thrown)\n\t * @throws NamingException if there is no object with the given\n\t * name bound to JNDI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "Object",
    "signature": "public Object lookup(final String name)",
    "source_code": "\tpublic Object lookup(final String name) throws NamingException {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Looking up JNDI object with name [\" + name + \"]\");\n\t\t}\n\t\tObject result = execute(ctx -> ctx.lookup(name));\n\t\tif (result == null) {\n\t\t\tthrow new NameNotFoundException(\n\t\t\t\t\t\"JNDI object with [\" + name + \"] not found: JNDI implementation returned null\");\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.jndi.JndiTemplate#lookup(name,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look up the object with the given name in the current JNDI context.\n\t * @param name the JNDI name of the object\n\t * @param requiredType type the JNDI object must match. Can be an interface or\n\t * superclass of the actual class, or {@code null} for any match. For example,\n\t * if the value is {@code Object.class}, this method will succeed whatever\n\t * the class of the returned instance.\n\t * @return object found (cannot be {@code null}; if a not so well-behaved\n\t * JNDI implementations returns null, a NamingException gets thrown)\n\t * @throws NamingException if there is no object with the given\n\t * name bound to JNDI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "T",
    "signature": "public T lookup(String name, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic <T> T lookup(String name, @Nullable Class<T> requiredType) throws NamingException {\n\t\tObject jndiObject = lookup(name);\n\t\tif (requiredType != null && !requiredType.isInstance(jndiObject)) {\n\t\t\tthrow new TypeMismatchNamingException(name, requiredType, jndiObject.getClass());\n\t\t}\n\t\treturn (T) jndiObject;\n\t}"
  },
  "org.springframework.jndi.JndiTemplate#rebind(name,object)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Rebind the given object to the current JNDI context, using the given name.\n\t * Overwrites any existing binding.\n\t * @param name the JNDI name of the object\n\t * @param object the object to rebind\n\t * @throws NamingException thrown by JNDI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "object"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "void",
    "signature": "public void rebind(final String name, final Object object)",
    "source_code": "\tpublic void rebind(final String name, final Object object) throws NamingException {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Rebinding JNDI object with name [\" + name + \"]\");\n\t\t}\n\t\texecute(ctx -> {\n\t\t\tctx.rebind(name, object);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.jndi.JndiTemplate#releaseContext(ctx)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Release a JNDI context as obtained from {@link #getContext()}.\n\t * @param ctx the JNDI context to release (may be {@code null})\n\t * @see #getContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ctx"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void releaseContext(@Nullable Context ctx)",
    "source_code": "\tpublic void releaseContext(@Nullable Context ctx) {\n\t\tif (ctx != null) {\n\t\t\ttry {\n\t\t\t\tctx.close();\n\t\t\t}\n\t\t\tcatch (NamingException ex) {\n\t\t\t\tlogger.debug(\"Could not close JNDI InitialContext\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jndi.JndiTemplate#setEnvironment(environment)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the environment for the JNDI InitialContext.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "public void setEnvironment(@Nullable Properties environment)",
    "source_code": "\tpublic void setEnvironment(@Nullable Properties environment) {\n\t\tthis.environment = environment;\n\t}"
  },
  "org.springframework.jndi.JndiTemplate#unbind(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Remove the binding for the given name from the current JNDI context.\n\t * @param name the JNDI name of the object\n\t * @throws NamingException thrown by JNDI, mostly name not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void unbind(final String name)",
    "source_code": "\tpublic void unbind(final String name) throws NamingException {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Unbinding JNDI object with name [\" + name + \"]\");\n\t\t}\n\t\texecute(ctx -> {\n\t\t\tctx.unbind(name);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.jndi.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.jndi.support.SimpleJndiBeanFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Simple JNDI-based implementation of Spring's\n * {@link org.springframework.beans.factory.BeanFactory} interface.\n * Does not support enumerating bean definitions, hence doesn't implement\n * the {@link org.springframework.beans.factory.ListableBeanFactory} interface.\n *\n * <p>This factory resolves given bean names as JNDI names within the\n * Jakarta EE application's \"java:comp/env/\" namespace. It caches the resolved\n * types for all obtained objects, and optionally also caches shareable\n * objects (if they are explicitly marked as\n * {@link #addShareableResource shareable resource}).\n *\n * <p>The main intent of this factory is usage in combination with Spring's\n * {@link org.springframework.context.annotation.CommonAnnotationBeanPostProcessor},\n * configured as \"resourceFactory\" for resolving {@code @Resource}\n * annotations as JNDI objects without intermediate bean definitions.\n * It may be used for similar lookup scenarios as well, of course,\n * in particular if BeanFactory-style type checking is required.\n *\n * @author Juergen Hoeller\n * @since 2.5\n * @see org.springframework.beans.factory.support.DefaultListableBeanFactory\n * @see org.springframework.context.annotation.CommonAnnotationBeanPostProcessor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "signature": "public class SimpleJndiBeanFactory",
    "source_code": "public class SimpleJndiBeanFactory extends JndiLocatorSupport implements BeanFactory {\n\n\t/** JNDI names of resources that are known to be shareable, i.e. can be cached */\n\tprivate final Set<String> shareableResources = new HashSet<>();\n\n\t/** Cache of shareable singleton objects: bean name to bean instance. */\n\tprivate final Map<String, Object> singletonObjects = new HashMap<>();\n\n\t/** Cache of the types of nonshareable resources: bean name to bean type. */\n\tprivate final Map<String, Class<?>> resourceTypes = new HashMap<>();\n\n\n\tpublic SimpleJndiBeanFactory() {\n\t\tsetResourceRef(true);\n\t}\n\n\n\t/**\n\t * Add the name of a shareable JNDI resource,\n\t * which this factory is allowed to cache once obtained.\n\t * @param shareableResource the JNDI name\n\t * (typically within the \"java:comp/env/\" namespace)\n\t */\n\tpublic void addShareableResource(String shareableResource) {\n\t\tthis.shareableResources.add(shareableResource);\n\t}\n\n\t/**\n\t * Set a list of names of shareable JNDI resources,\n\t * which this factory is allowed to cache once obtained.\n\t * @param shareableResources the JNDI names\n\t * (typically within the \"java:comp/env/\" namespace)\n\t */\n\tpublic void setShareableResources(String... shareableResources) {\n\t\tCollections.addAll(this.shareableResources, shareableResources);\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of BeanFactory interface\n\t//---------------------------------------------------------------------\n\n\n\t@Override\n\tpublic Object getBean(String name) throws BeansException {\n\t\treturn getBean(name, Object.class);\n\t}\n\n\t@Override\n\tpublic <T> T getBean(String name, Class<T> requiredType) throws BeansException {\n\t\ttry {\n\t\t\tif (isSingleton(name)) {\n\t\t\t\treturn doGetSingleton(name, requiredType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn lookup(name, requiredType);\n\t\t\t}\n\t\t}\n\t\tcatch (NameNotFoundException ex) {\n\t\t\tthrow new NoSuchBeanDefinitionException(name, \"not found in JNDI environment\");\n\t\t}\n\t\tcatch (TypeMismatchNamingException ex) {\n\t\t\tthrow new BeanNotOfRequiredTypeException(name, ex.getRequiredType(), ex.getActualType());\n\t\t}\n\t\tcatch (NamingException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(\"JNDI environment\", name, \"JNDI lookup failed\", ex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic Object getBean(String name, @Nullable Object @Nullable ... args) throws BeansException {\n\t\tif (args != null) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"SimpleJndiBeanFactory does not support explicit bean creation arguments\");\n\t\t}\n\t\treturn getBean(name);\n\t}\n\n\t@Override\n\tpublic <T> T getBean(Class<T> requiredType) throws BeansException {\n\t\treturn getBean(requiredType.getSimpleName(), requiredType);\n\t}\n\n\t@Override\n\tpublic <T> T getBean(Class<T> requiredType, @Nullable Object @Nullable ... args) throws BeansException {\n\t\tif (args != null) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"SimpleJndiBeanFactory does not support explicit bean creation arguments\");\n\t\t}\n\t\treturn getBean(requiredType);\n\t}\n\n\t@Override\n\tpublic <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType) {\n\t\treturn new ObjectProvider<>() {\n\t\t\t@Override\n\t\t\tpublic T getObject() throws BeansException {\n\t\t\t\treturn getBean(requiredType);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic T getObject(@Nullable Object... args) throws BeansException {\n\t\t\t\treturn getBean(requiredType, args);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic @Nullable T getIfAvailable() throws BeansException {\n\t\t\t\ttry {\n\t\t\t\t\treturn getBean(requiredType);\n\t\t\t\t}\n\t\t\t\tcatch (NoUniqueBeanDefinitionException ex) {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic @Nullable T getIfUnique() throws BeansException {\n\t\t\t\ttry {\n\t\t\t\t\treturn getBean(requiredType);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t@Override\n\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"SimpleJndiBeanFactory does not support resolution by ResolvableType\");\n\t}\n\n\t@Override\n\tpublic boolean containsBean(String name) {\n\t\tif (this.singletonObjects.containsKey(name) || this.resourceTypes.containsKey(name)) {\n\t\t\treturn true;\n\t\t}\n\t\ttry {\n\t\t\tdoGetType(name);\n\t\t\treturn true;\n\t\t}\n\t\tcatch (NamingException ex) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isSingleton(String name) throws NoSuchBeanDefinitionException {\n\t\treturn this.shareableResources.contains(name);\n\t}\n\n\t@Override\n\tpublic boolean isPrototype(String name) throws NoSuchBeanDefinitionException {\n\t\treturn !this.shareableResources.contains(name);\n\t}\n\n\t@Override\n\tpublic boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException {\n\t\tClass<?> type = getType(name);\n\t\treturn (type != null && typeToMatch.isAssignableFrom(type));\n\t}\n\n\t@Override\n\tpublic boolean isTypeMatch(String name, @Nullable Class<?> typeToMatch) throws NoSuchBeanDefinitionException {\n\t\tClass<?> type = getType(name);\n\t\treturn (typeToMatch == null || (type != null && typeToMatch.isAssignableFrom(type)));\n\t}\n\n\t@Override\n\tpublic @Nullable Class<?> getType(String name) throws NoSuchBeanDefinitionException {\n\t\treturn getType(name, true);\n\t}\n\n\t@Override\n\tpublic @Nullable Class<?> getType(String name, boolean allowFactoryBeanInit) throws NoSuchBeanDefinitionException {\n\t\ttry {\n\t\t\treturn doGetType(name);\n\t\t}\n\t\tcatch (NameNotFoundException ex) {\n\t\t\tthrow new NoSuchBeanDefinitionException(name, \"not found in JNDI environment\");\n\t\t}\n\t\tcatch (NamingException ex) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\tpublic String[] getAliases(String name) {\n\t\treturn new String[0];\n\t}\n\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate <T> T doGetSingleton(String name, @Nullable Class<T> requiredType) throws NamingException {\n\t\tsynchronized (this.singletonObjects) {\n\t\t\tObject singleton = this.singletonObjects.get(name);\n\t\t\tif (singleton != null) {\n\t\t\t\tif (requiredType != null && !requiredType.isInstance(singleton)) {\n\t\t\t\t\tthrow new TypeMismatchNamingException(convertJndiName(name), requiredType, singleton.getClass());\n\t\t\t\t}\n\t\t\t\treturn (T) singleton;\n\t\t\t}\n\t\t\tT jndiObject = lookup(name, requiredType);\n\t\t\tthis.singletonObjects.put(name, jndiObject);\n\t\t\treturn jndiObject;\n\t\t}\n\t}\n\n\tprivate Class<?> doGetType(String name) throws NamingException {\n\t\tif (isSingleton(name)) {\n\t\t\treturn doGetSingleton(name, null).getClass();\n\t\t}\n\t\telse {\n\t\t\tsynchronized (this.resourceTypes) {\n\t\t\t\tClass<?> type = this.resourceTypes.get(name);\n\t\t\t\tif (type == null) {\n\t\t\t\t\ttype = lookup(name, null).getClass();\n\t\t\t\t\tthis.resourceTypes.put(name, type);\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jndi.support.SimpleJndiBeanFactory#addShareableResource(shareableResource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the name of a shareable JNDI resource,\n\t * which this factory is allowed to cache once obtained.\n\t * @param shareableResource the JNDI name\n\t * (typically within the \"java:comp/env/\" namespace)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "shareableResource"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void addShareableResource(String shareableResource)",
    "source_code": "\tpublic void addShareableResource(String shareableResource) {\n\t\tthis.shareableResources.add(shareableResource);\n\t}"
  },
  "org.springframework.jndi.support.SimpleJndiBeanFactory#containsBean(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "boolean",
    "signature": "public boolean containsBean(String name)",
    "source_code": "\tpublic boolean containsBean(String name) {\n\t\tif (this.singletonObjects.containsKey(name) || this.resourceTypes.containsKey(name)) {\n\t\t\treturn true;\n\t\t}\n\t\ttry {\n\t\t\tdoGetType(name);\n\t\t\treturn true;\n\t\t}\n\t\tcatch (NamingException ex) {\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.jndi.support.SimpleJndiBeanFactory#getAliases(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 253
    },
    "return": "String[]",
    "signature": "public String[] getAliases(String name)",
    "source_code": "\tpublic String[] getAliases(String name) {\n\t\treturn new String[0];\n\t}"
  },
  "org.springframework.jndi.support.SimpleJndiBeanFactory#getBean(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Object",
    "signature": "public Object getBean(String name)",
    "source_code": "\tpublic Object getBean(String name) throws BeansException {\n\t\treturn getBean(name, Object.class);\n\t}"
  },
  "org.springframework.jndi.support.SimpleJndiBeanFactory#getBean(name,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "Object",
    "signature": "public Object getBean(String name, @Nullable Object @Nullable ... args)",
    "source_code": "\tpublic Object getBean(String name, @Nullable Object @Nullable ... args) throws BeansException {\n\t\tif (args != null) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"SimpleJndiBeanFactory does not support explicit bean creation arguments\");\n\t\t}\n\t\treturn getBean(name);\n\t}"
  },
  "org.springframework.jndi.support.SimpleJndiBeanFactory#getBean(name,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "T",
    "signature": "public T getBean(String name, Class<T> requiredType)",
    "source_code": "\tpublic <T> T getBean(String name, Class<T> requiredType) throws BeansException {\n\t\ttry {\n\t\t\tif (isSingleton(name)) {\n\t\t\t\treturn doGetSingleton(name, requiredType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn lookup(name, requiredType);\n\t\t\t}\n\t\t}\n\t\tcatch (NameNotFoundException ex) {\n\t\t\tthrow new NoSuchBeanDefinitionException(name, \"not found in JNDI environment\");\n\t\t}\n\t\tcatch (TypeMismatchNamingException ex) {\n\t\t\tthrow new BeanNotOfRequiredTypeException(name, ex.getRequiredType(), ex.getActualType());\n\t\t}\n\t\tcatch (NamingException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(\"JNDI environment\", name, \"JNDI lookup failed\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jndi.support.SimpleJndiBeanFactory#getBean(requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "T",
    "signature": "public T getBean(Class<T> requiredType)",
    "source_code": "\tpublic <T> T getBean(Class<T> requiredType) throws BeansException {\n\t\treturn getBean(requiredType.getSimpleName(), requiredType);\n\t}"
  },
  "org.springframework.jndi.support.SimpleJndiBeanFactory#getBean(requiredType,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "T",
    "signature": "public T getBean(Class<T> requiredType, @Nullable Object @Nullable ... args)",
    "source_code": "\tpublic <T> T getBean(Class<T> requiredType, @Nullable Object @Nullable ... args) throws BeansException {\n\t\tif (args != null) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"SimpleJndiBeanFactory does not support explicit bean creation arguments\");\n\t\t}\n\t\treturn getBean(requiredType);\n\t}"
  },
  "org.springframework.jndi.support.SimpleJndiBeanFactory#getBeanProvider(requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "ObjectProvider<T>",
    "signature": "public ObjectProvider<T> getBeanProvider(ResolvableType requiredType)",
    "source_code": "\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"SimpleJndiBeanFactory does not support resolution by ResolvableType\");\n\t}"
  },
  "org.springframework.jndi.support.SimpleJndiBeanFactory#getIfAvailable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "T",
    "signature": "public T getIfAvailable()",
    "source_code": "\t\t\tpublic @Nullable T getIfAvailable() throws BeansException {\n\t\t\t\ttry {\n\t\t\t\t\treturn getBean(requiredType);\n\t\t\t\t}\n\t\t\t\tcatch (NoUniqueBeanDefinitionException ex) {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.jndi.support.SimpleJndiBeanFactory#getIfUnique()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "T",
    "signature": "public T getIfUnique()",
    "source_code": "\t\t\tpublic @Nullable T getIfUnique() throws BeansException {\n\t\t\t\ttry {\n\t\t\t\t\treturn getBean(requiredType);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.jndi.support.SimpleJndiBeanFactory#getObject()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "T",
    "signature": "public T getObject()",
    "source_code": "\t\t\tpublic T getObject() throws BeansException {\n\t\t\t\treturn getBean(requiredType);\n\t\t\t}"
  },
  "org.springframework.jndi.support.SimpleJndiBeanFactory#getObject(args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "args"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "T",
    "signature": "public T getObject(@Nullable Object... args)",
    "source_code": "\t\t\tpublic T getObject(@Nullable Object... args) throws BeansException {\n\t\t\t\treturn getBean(requiredType, args);\n\t\t\t}"
  },
  "org.springframework.jndi.support.SimpleJndiBeanFactory#isPrototype(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "boolean",
    "signature": "public boolean isPrototype(String name)",
    "source_code": "\tpublic boolean isPrototype(String name) throws NoSuchBeanDefinitionException {\n\t\treturn !this.shareableResources.contains(name);\n\t}"
  },
  "org.springframework.jndi.support.SimpleJndiBeanFactory#isSingleton(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "boolean",
    "signature": "public boolean isSingleton(String name)",
    "source_code": "\tpublic boolean isSingleton(String name) throws NoSuchBeanDefinitionException {\n\t\treturn this.shareableResources.contains(name);\n\t}"
  },
  "org.springframework.jndi.support.SimpleJndiBeanFactory#isTypeMatch(name,typeToMatch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "typeToMatch"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "boolean",
    "signature": "public boolean isTypeMatch(String name, @Nullable Class<?> typeToMatch)",
    "source_code": "\tpublic boolean isTypeMatch(String name, @Nullable Class<?> typeToMatch) throws NoSuchBeanDefinitionException {\n\t\tClass<?> type = getType(name);\n\t\treturn (typeToMatch == null || (type != null && typeToMatch.isAssignableFrom(type)));\n\t}"
  },
  "org.springframework.jndi.support.SimpleJndiBeanFactory#setShareableResources(shareableResources)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a list of names of shareable JNDI resources,\n\t * which this factory is allowed to cache once obtained.\n\t * @param shareableResources the JNDI names\n\t * (typically within the \"java:comp/env/\" namespace)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "shareableResources"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void setShareableResources(String... shareableResources)",
    "source_code": "\tpublic void setShareableResources(String... shareableResources) {\n\t\tCollections.addAll(this.shareableResources, shareableResources);\n\t}"
  },
  "org.springframework.mail.MailSendException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Exception thrown when a mail sending error is encountered.\n * Can register failed messages with their exceptions.\n *\n * @author Dmitriy Kopylenko\n * @author Juergen Hoeller\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public class MailSendException",
    "source_code": "public class MailSendException extends MailException {\n\n\tprivate final transient Map<Object, Exception> failedMessages;\n\n\tprivate final Exception @Nullable [] messageExceptions;\n\n\n\t/**\n\t * Constructor for MailSendException.\n\t * @param msg the detail message\n\t */\n\tpublic MailSendException(String msg) {\n\t\tthis(msg, null);\n\t}\n\n\t/**\n\t * Constructor for MailSendException.\n\t * @param msg the detail message\n\t * @param cause the root cause from the mail API in use\n\t */\n\tpublic MailSendException(String msg, @Nullable Throwable cause) {\n\t\tsuper(msg, cause);\n\t\tthis.failedMessages = new LinkedHashMap<>();\n\t\tthis.messageExceptions = null;\n\t}\n\n\t/**\n\t * Constructor for registration of failed messages, with the\n\t * messages that failed as keys, and the thrown exceptions as values.\n\t * <p>The messages should be the same that were originally passed\n\t * to the invoked send method.\n\t * @param msg the detail message\n\t * @param cause the root cause from the mail API in use\n\t * @param failedMessages a Map of failed messages as keys and thrown\n\t * exceptions as values\n\t */\n\tpublic MailSendException(@Nullable String msg, @Nullable Throwable cause, Map<Object, Exception> failedMessages) {\n\t\tsuper(msg, cause);\n\t\tthis.failedMessages = new LinkedHashMap<>(failedMessages);\n\t\tthis.messageExceptions = failedMessages.values().toArray(new Exception[0]);\n\t}\n\n\t/**\n\t * Constructor for registration of failed messages, with the\n\t * messages that failed as keys, and the thrown exceptions as values.\n\t * <p>The messages should be the same that were originally passed\n\t * to the invoked send method.\n\t * @param failedMessages a Map of failed messages as keys and thrown\n\t * exceptions as values\n\t */\n\tpublic MailSendException(Map<Object, Exception> failedMessages) {\n\t\tthis(null, null, failedMessages);\n\t}\n\n\n\t/**\n\t * Return a Map with the failed messages as keys, and the thrown exceptions\n\t * as values.\n\t * <p>Note that a general mail server connection failure will not result\n\t * in failed messages being returned here: A message will only be\n\t * contained here if actually sending it was attempted but failed.\n\t * <p>The messages will be the same that were originally passed to the\n\t * invoked send method, that is, SimpleMailMessages in case of using\n\t * the generic MailSender interface.\n\t * <p>In case of sending MimeMessage instances via JavaMailSender,\n\t * the messages will be of type MimeMessage.\n\t * <p><b>NOTE:</b> This Map will not be available after serialization.\n\t * Use {@link #getMessageExceptions()} in such a scenario, which will\n\t * be available after serialization as well.\n\t * @return the Map of failed messages as keys and thrown exceptions as values\n\t * @see SimpleMailMessage\n\t * @see jakarta.mail.internet.MimeMessage\n\t */\n\tpublic final Map<Object, Exception> getFailedMessages() {\n\t\treturn this.failedMessages;\n\t}\n\n\t/**\n\t * Return an array with thrown message exceptions.\n\t * <p>Note that a general mail server connection failure will not result\n\t * in failed messages being returned here: A message will only be\n\t * contained here if actually sending it was attempted but failed.\n\t * @return the array of thrown message exceptions,\n\t * or an empty array if no failed messages\n\t */\n\tpublic final Exception[] getMessageExceptions() {\n\t\treturn (this.messageExceptions != null ? this.messageExceptions : new Exception[0]);\n\t}\n\n\n\t@Override\n\tpublic @Nullable String getMessage() {\n\t\tif (ObjectUtils.isEmpty(this.messageExceptions)) {\n\t\t\treturn super.getMessage();\n\t\t}\n\t\telse {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tString baseMessage = super.getMessage();\n\t\t\tif (baseMessage != null) {\n\t\t\t\tsb.append(baseMessage).append(\". \");\n\t\t\t}\n\t\t\tsb.append(\"Failed messages: \");\n\t\t\tfor (int i = 0; i < this.messageExceptions.length; i++) {\n\t\t\t\tException subEx = this.messageExceptions[i];\n\t\t\t\tsb.append(subEx.toString());\n\t\t\t\tif (i < this.messageExceptions.length - 1) {\n\t\t\t\t\tsb.append(\"; \");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tif (ObjectUtils.isEmpty(this.messageExceptions)) {\n\t\t\treturn super.toString();\n\t\t}\n\t\telse {\n\t\t\tStringBuilder sb = new StringBuilder(super.toString());\n\t\t\tsb.append(\"; message exceptions (\").append(this.messageExceptions.length).append(\") are:\");\n\t\t\tfor (int i = 0; i < this.messageExceptions.length; i++) {\n\t\t\t\tException subEx = this.messageExceptions[i];\n\t\t\t\tsb.append('\\n').append(\"Failed message \").append(i + 1).append(\": \");\n\t\t\t\tsb.append(subEx);\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void printStackTrace(PrintStream ps) {\n\t\tif (ObjectUtils.isEmpty(this.messageExceptions)) {\n\t\t\tsuper.printStackTrace(ps);\n\t\t}\n\t\telse {\n\t\t\tps.println(super.toString() + \"; message exception details (\" +\n\t\t\t\t\tthis.messageExceptions.length + \") are:\");\n\t\t\tfor (int i = 0; i < this.messageExceptions.length; i++) {\n\t\t\t\tException subEx = this.messageExceptions[i];\n\t\t\t\tps.println(\"Failed message \" + (i + 1) + \":\");\n\t\t\t\tsubEx.printStackTrace(ps);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void printStackTrace(PrintWriter pw) {\n\t\tif (ObjectUtils.isEmpty(this.messageExceptions)) {\n\t\t\tsuper.printStackTrace(pw);\n\t\t}\n\t\telse {\n\t\t\tpw.println(super.toString() + \"; message exception details (\" +\n\t\t\t\t\tthis.messageExceptions.length + \") are:\");\n\t\t\tfor (int i = 0; i < this.messageExceptions.length; i++) {\n\t\t\t\tException subEx = this.messageExceptions[i];\n\t\t\t\tpw.println(\"Failed message \" + (i + 1) + \":\");\n\t\t\t\tsubEx.printStackTrace(pw);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.mail.MailSendException#getFailedMessages()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a Map with the failed messages as keys, and the thrown exceptions\n\t * as values.\n\t * <p>Note that a general mail server connection failure will not result\n\t * in failed messages being returned here: A message will only be\n\t * contained here if actually sending it was attempted but failed.\n\t * <p>The messages will be the same that were originally passed to the\n\t * invoked send method, that is, SimpleMailMessages in case of using\n\t * the generic MailSender interface.\n\t * <p>In case of sending MimeMessage instances via JavaMailSender,\n\t * the messages will be of type MimeMessage.\n\t * <p><b>NOTE:</b> This Map will not be available after serialization.\n\t * Use {@link #getMessageExceptions()} in such a scenario, which will\n\t * be available after serialization as well.\n\t * @return the Map of failed messages as keys and thrown exceptions as values\n\t * @see SimpleMailMessage\n\t * @see jakarta.mail.internet.MimeMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Exception>",
    "signature": "public Exception> getFailedMessages()",
    "source_code": "\tpublic final Map<Object, Exception> getFailedMessages() {\n\t\treturn this.failedMessages;\n\t}"
  },
  "org.springframework.mail.MailSendException#getMessage()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "String",
    "signature": "public String getMessage()",
    "source_code": "\tpublic @Nullable String getMessage() {\n\t\tif (ObjectUtils.isEmpty(this.messageExceptions)) {\n\t\t\treturn super.getMessage();\n\t\t}\n\t\telse {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tString baseMessage = super.getMessage();\n\t\t\tif (baseMessage != null) {\n\t\t\t\tsb.append(baseMessage).append(\". \");\n\t\t\t}\n\t\t\tsb.append(\"Failed messages: \");\n\t\t\tfor (int i = 0; i < this.messageExceptions.length; i++) {\n\t\t\t\tException subEx = this.messageExceptions[i];\n\t\t\t\tsb.append(subEx.toString());\n\t\t\t\tif (i < this.messageExceptions.length - 1) {\n\t\t\t\t\tsb.append(\"; \");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t}"
  },
  "org.springframework.mail.MailSendException#getMessageExceptions()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an array with thrown message exceptions.\n\t * <p>Note that a general mail server connection failure will not result\n\t * in failed messages being returned here: A message will only be\n\t * contained here if actually sending it was attempted but failed.\n\t * @return the array of thrown message exceptions,\n\t * or an empty array if no failed messages\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "Exception[]",
    "signature": "public Exception[] getMessageExceptions()",
    "source_code": "\tpublic final Exception[] getMessageExceptions() {\n\t\treturn (this.messageExceptions != null ? this.messageExceptions : new Exception[0]);\n\t}"
  },
  "org.springframework.mail.MailSendException#printStackTrace(ps)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "public void printStackTrace(PrintStream ps)",
    "source_code": "\tpublic void printStackTrace(PrintStream ps) {\n\t\tif (ObjectUtils.isEmpty(this.messageExceptions)) {\n\t\t\tsuper.printStackTrace(ps);\n\t\t}\n\t\telse {\n\t\t\tps.println(super.toString() + \"; message exception details (\" +\n\t\t\t\t\tthis.messageExceptions.length + \") are:\");\n\t\t\tfor (int i = 0; i < this.messageExceptions.length; i++) {\n\t\t\t\tException subEx = this.messageExceptions[i];\n\t\t\t\tps.println(\"Failed message \" + (i + 1) + \":\");\n\t\t\t\tsubEx.printStackTrace(ps);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.mail.MailSendException#printStackTrace(pw)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pw"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void printStackTrace(PrintWriter pw)",
    "source_code": "\tpublic void printStackTrace(PrintWriter pw) {\n\t\tif (ObjectUtils.isEmpty(this.messageExceptions)) {\n\t\t\tsuper.printStackTrace(pw);\n\t\t}\n\t\telse {\n\t\t\tpw.println(super.toString() + \"; message exception details (\" +\n\t\t\t\t\tthis.messageExceptions.length + \") are:\");\n\t\t\tfor (int i = 0; i < this.messageExceptions.length; i++) {\n\t\t\t\tException subEx = this.messageExceptions[i];\n\t\t\t\tpw.println(\"Failed message \" + (i + 1) + \":\");\n\t\t\t\tsubEx.printStackTrace(pw);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.mail.MailSendException#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\tif (ObjectUtils.isEmpty(this.messageExceptions)) {\n\t\t\treturn super.toString();\n\t\t}\n\t\telse {\n\t\t\tStringBuilder sb = new StringBuilder(super.toString());\n\t\t\tsb.append(\"; message exceptions (\").append(this.messageExceptions.length).append(\") are:\");\n\t\t\tfor (int i = 0; i < this.messageExceptions.length; i++) {\n\t\t\t\tException subEx = this.messageExceptions[i];\n\t\t\t\tsb.append('\\n').append(\"Failed message \").append(i + 1).append(\": \");\n\t\t\t\tsb.append(subEx);\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t}"
  },
  "org.springframework.mail.SimpleMailMessage#getBcc()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "String[]",
    "signature": "public String[] getBcc()",
    "source_code": "\tpublic String[] getBcc() {\n\t\treturn this.bcc;\n\t}"
  },
  "org.springframework.mail.SimpleMailMessage#getCc()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "String[]",
    "signature": "public String[] getCc()",
    "source_code": "\tpublic String[] getCc() {\n\t\treturn this.cc;\n\t}"
  },
  "org.springframework.mail.SimpleMailMessage#getTo()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "String[]",
    "signature": "public String[] getTo()",
    "source_code": "\tpublic String[] getTo() {\n\t\treturn this.to;\n\t}"
  },
  "org.springframework.mail.javamail.ConfigurableMimeFileTypeMap": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Spring-configurable {@code FileTypeMap} implementation that will read\n * MIME type to file extension mappings from a standard JavaMail MIME type\n * mapping file, using a standard {@code MimetypesFileTypeMap} underneath.\n *\n * <p>The mapping file should be in the following format, as specified by the\n * Java Activation Framework:\n *\n * <pre class=\"code\">\n * # map text/html to .htm and .html files\n * text/html  html htm HTML HTM</pre>\n *\n * Lines starting with {@code #} are treated as comments and are ignored. All\n * other lines are treated as mappings. Each mapping line should contain the MIME\n * type as the first entry and then each file extension to map to that MIME type\n * as subsequent entries. Each entry is separated by spaces or tabs.\n *\n * <p>By default, the mappings in the {@code mime.types} file located in the\n * same package as this class are used, which cover many common file extensions\n * (in contrast to the out-of-the-box mappings in {@code activation.jar}).\n * This can be overridden using the {@code mappingLocation} property.\n *\n * <p>Additional mappings can be added via the {@code mappings} bean property,\n * as lines that follow the {@code mime.types} file format.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @since 1.2\n * @see #setMappingLocation\n * @see #setMappings\n * @see jakarta.activation.MimetypesFileTypeMap\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "signature": "public class ConfigurableMimeFileTypeMap",
    "source_code": "public class ConfigurableMimeFileTypeMap extends FileTypeMap implements InitializingBean {\n\n\t/**\n\t * The {@code Resource} to load the mapping file from.\n\t */\n\tprivate Resource mappingLocation = new ClassPathResource(\"mime.types\", getClass());\n\n\t/**\n\t * Used to configure additional mappings.\n\t */\n\tprivate String @Nullable [] mappings;\n\n\t/**\n\t * The delegate FileTypeMap, compiled from the mappings in the mapping file\n\t * and the entries in the {@code mappings} property.\n\t */\n\tprivate @Nullable FileTypeMap fileTypeMap;\n\n\n\t/**\n\t * Specify the {@code Resource} from which mappings are loaded.\n\t * <p>Needs to follow the {@code mime.types} file format, as specified\n\t * by the Java Activation Framework, containing lines such as:<br>\n\t * {@code text/html  html htm HTML HTM}\n\t */\n\tpublic void setMappingLocation(Resource mappingLocation) {\n\t\tthis.mappingLocation = mappingLocation;\n\t}\n\n\t/**\n\t * Specify additional MIME type mappings as lines that follow the\n\t * {@code mime.types} file format, as specified by the\n\t * Java Activation Framework. For example:<br>\n\t * {@code text/html  html htm HTML HTM}\n\t */\n\tpublic void setMappings(String... mappings) {\n\t\tthis.mappings = mappings;\n\t}\n\n\n\t/**\n\t * Creates the final merged mapping set.\n\t */\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\tgetFileTypeMap();\n\t}\n\n\t/**\n\t * Return the delegate FileTypeMap, compiled from the mappings in the mapping file\n\t * and the entries in the {@code mappings} property.\n\t * @see #setMappingLocation\n\t * @see #setMappings\n\t * @see #createFileTypeMap\n\t */\n\tprotected final FileTypeMap getFileTypeMap() {\n\t\tif (this.fileTypeMap == null) {\n\t\t\ttry {\n\t\t\t\tthis.fileTypeMap = createFileTypeMap(this.mappingLocation, this.mappings);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Could not load specified MIME type mapping file: \" + this.mappingLocation, ex);\n\t\t\t}\n\t\t}\n\t\treturn this.fileTypeMap;\n\t}\n\n\t/**\n\t * Compile a {@link FileTypeMap} from the mappings in the given mapping file\n\t * and the given mapping entries.\n\t * <p>The default implementation creates an Activation Framework {@link MimetypesFileTypeMap},\n\t * passing in an InputStream from the mapping resource (if any) and registering\n\t * the mapping lines programmatically.\n\t * @param mappingLocation a {@code mime.types} mapping resource (can be {@code null})\n\t * @param mappings an array of MIME type mapping lines (can be {@code null})\n\t * @return the compiled FileTypeMap\n\t * @throws IOException if resource access failed\n\t * @see jakarta.activation.MimetypesFileTypeMap#MimetypesFileTypeMap(java.io.InputStream)\n\t * @see jakarta.activation.MimetypesFileTypeMap#addMimeTypes(String)\n\t */\n\tprotected FileTypeMap createFileTypeMap(@Nullable Resource mappingLocation, String @Nullable [] mappings) throws IOException {\n\t\tMimetypesFileTypeMap fileTypeMap = null;\n\t\tif (mappingLocation != null) {\n\t\t\ttry (InputStream is = mappingLocation.getInputStream()) {\n\t\t\t\tfileTypeMap = new MimetypesFileTypeMap(is);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfileTypeMap = new MimetypesFileTypeMap();\n\t\t}\n\t\tif (mappings != null) {\n\t\t\tfor (String mapping : mappings) {\n\t\t\t\tfileTypeMap.addMimeTypes(mapping);\n\t\t\t}\n\t\t}\n\t\treturn fileTypeMap;\n\t}\n\n\n\t/**\n\t * Delegates to the underlying FileTypeMap.\n\t * @see #getFileTypeMap()\n\t */\n\t@Override\n\tpublic String getContentType(File file) {\n\t\treturn getFileTypeMap().getContentType(file);\n\t}\n\n\t/**\n\t * Delegates to the underlying FileTypeMap.\n\t * @see #getFileTypeMap()\n\t */\n\t@Override\n\tpublic String getContentType(String fileName) {\n\t\treturn getFileTypeMap().getContentType(fileName);\n\t}\n\n}"
  },
  "org.springframework.mail.javamail.ConfigurableMimeFileTypeMap#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Creates the final merged mapping set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tgetFileTypeMap();\n\t}"
  },
  "org.springframework.mail.javamail.ConfigurableMimeFileTypeMap#createFileTypeMap(mappingLocation,mappings)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Compile a {@link FileTypeMap} from the mappings in the given mapping file\n\t * and the given mapping entries.\n\t * <p>The default implementation creates an Activation Framework {@link MimetypesFileTypeMap},\n\t * passing in an InputStream from the mapping resource (if any) and registering\n\t * the mapping lines programmatically.\n\t * @param mappingLocation a {@code mime.types} mapping resource (can be {@code null})\n\t * @param mappings an array of MIME type mapping lines (can be {@code null})\n\t * @return the compiled FileTypeMap\n\t * @throws IOException if resource access failed\n\t * @see jakarta.activation.MimetypesFileTypeMap#MimetypesFileTypeMap(java.io.InputStream)\n\t * @see jakarta.activation.MimetypesFileTypeMap#addMimeTypes(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mappingLocation",
      "mappings"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "FileTypeMap",
    "signature": "protected FileTypeMap createFileTypeMap(@Nullable Resource mappingLocation, String @Nullable [] mappings)",
    "source_code": "\tprotected FileTypeMap createFileTypeMap(@Nullable Resource mappingLocation, String @Nullable [] mappings) throws IOException {\n\t\tMimetypesFileTypeMap fileTypeMap = null;\n\t\tif (mappingLocation != null) {\n\t\t\ttry (InputStream is = mappingLocation.getInputStream()) {\n\t\t\t\tfileTypeMap = new MimetypesFileTypeMap(is);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfileTypeMap = new MimetypesFileTypeMap();\n\t\t}\n\t\tif (mappings != null) {\n\t\t\tfor (String mapping : mappings) {\n\t\t\t\tfileTypeMap.addMimeTypes(mapping);\n\t\t\t}\n\t\t}\n\t\treturn fileTypeMap;\n\t}"
  },
  "org.springframework.mail.javamail.ConfigurableMimeFileTypeMap#getContentType(file)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to the underlying FileTypeMap.\n\t * @see #getFileTypeMap()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "file"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "String",
    "signature": "public String getContentType(File file)",
    "source_code": "\tpublic String getContentType(File file) {\n\t\treturn getFileTypeMap().getContentType(file);\n\t}"
  },
  "org.springframework.mail.javamail.ConfigurableMimeFileTypeMap#getContentType(fileName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to the underlying FileTypeMap.\n\t * @see #getFileTypeMap()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fileName"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "String",
    "signature": "public String getContentType(String fileName)",
    "source_code": "\tpublic String getContentType(String fileName) {\n\t\treturn getFileTypeMap().getContentType(fileName);\n\t}"
  },
  "org.springframework.mail.javamail.ConfigurableMimeFileTypeMap#getFileTypeMap()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the delegate FileTypeMap, compiled from the mappings in the mapping file\n\t * and the entries in the {@code mappings} property.\n\t * @see #setMappingLocation\n\t * @see #setMappings\n\t * @see #createFileTypeMap\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "FileTypeMap",
    "signature": "protected FileTypeMap getFileTypeMap()",
    "source_code": "\tprotected final FileTypeMap getFileTypeMap() {\n\t\tif (this.fileTypeMap == null) {\n\t\t\ttry {\n\t\t\t\tthis.fileTypeMap = createFileTypeMap(this.mappingLocation, this.mappings);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Could not load specified MIME type mapping file: \" + this.mappingLocation, ex);\n\t\t\t}\n\t\t}\n\t\treturn this.fileTypeMap;\n\t}"
  },
  "org.springframework.mail.javamail.ConfigurableMimeFileTypeMap#setMappingLocation(mappingLocation)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the {@code Resource} from which mappings are loaded.\n\t * <p>Needs to follow the {@code mime.types} file format, as specified\n\t * by the Java Activation Framework, containing lines such as:<br>\n\t * {@code text/html  html htm HTML HTM}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappingLocation"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void setMappingLocation(Resource mappingLocation)",
    "source_code": "\tpublic void setMappingLocation(Resource mappingLocation) {\n\t\tthis.mappingLocation = mappingLocation;\n\t}"
  },
  "org.springframework.mail.javamail.ConfigurableMimeFileTypeMap#setMappings(mappings)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify additional MIME type mappings as lines that follow the\n\t * {@code mime.types} file format, as specified by the\n\t * Java Activation Framework. For example:<br>\n\t * {@code text/html  html htm HTML HTM}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappings"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void setMappings(String... mappings)",
    "source_code": "\tpublic void setMappings(String... mappings) {\n\t\tthis.mappings = mappings;\n\t}"
  },
  "org.springframework.mail.javamail.DEFAULT_PORT": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** The default port: -1. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "signature": "public int DEFAULT_PORT",
    "source_code": "\tpublic static final int DEFAULT_PORT = -1;",
    "type": "int"
  },
  "org.springframework.mail.javamail.DEFAULT_PROTOCOL": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** The default protocol: 'smtp'. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "signature": "public String DEFAULT_PROTOCOL",
    "source_code": "\tpublic static final String DEFAULT_PROTOCOL = \"smtp\";",
    "type": "String"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Production implementation of the {@link JavaMailSender} interface,\n * supporting both JavaMail {@link MimeMessage MimeMessages} and Spring\n * {@link SimpleMailMessage SimpleMailMessages}. Can also be used as a\n * plain {@link org.springframework.mail.MailSender} implementation.\n *\n * <p>Allows for defining all settings locally as bean properties.\n * Alternatively, a pre-configured JavaMail {@link jakarta.mail.Session} can be\n * specified, possibly pulled from an application server's JNDI environment.\n *\n * <p>Non-default properties in this object will always override the settings\n * in the JavaMail {@code Session}. Note that if overriding all values locally,\n * there is no added value in setting a pre-configured {@code Session}.\n *\n * @author Dmitriy Kopylenko\n * @author Juergen Hoeller\n * @since 10.09.2003\n * @see jakarta.mail.internet.MimeMessage\n * @see jakarta.mail.Session\n * @see #setSession\n * @see #setJavaMailProperties\n * @see #setHost\n * @see #setPort\n * @see #setUsername\n * @see #setPassword\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "signature": "public class JavaMailSenderImpl",
    "source_code": "public class JavaMailSenderImpl implements JavaMailSender {\n\n\t/** The default protocol: 'smtp'. */\n\tpublic static final String DEFAULT_PROTOCOL = \"smtp\";\n\n\t/** The default port: -1. */\n\tpublic static final int DEFAULT_PORT = -1;\n\n\tprivate static final String HEADER_MESSAGE_ID = \"Message-ID\";\n\n\n\tprivate Properties javaMailProperties = new Properties();\n\n\tprivate @Nullable Session session;\n\n\tprivate @Nullable String protocol;\n\n\tprivate @Nullable String host;\n\n\tprivate int port = DEFAULT_PORT;\n\n\tprivate @Nullable String username;\n\n\tprivate @Nullable String password;\n\n\tprivate @Nullable String defaultEncoding;\n\n\tprivate @Nullable FileTypeMap defaultFileTypeMap;\n\n\n\t/**\n\t * Create a new instance of the {@code JavaMailSenderImpl} class.\n\t * <p>Initializes the {@link #setDefaultFileTypeMap \"defaultFileTypeMap\"}\n\t * property with a default {@link ConfigurableMimeFileTypeMap}.\n\t */\n\tpublic JavaMailSenderImpl() {\n\t\tConfigurableMimeFileTypeMap fileTypeMap = new ConfigurableMimeFileTypeMap();\n\t\tfileTypeMap.afterPropertiesSet();\n\t\tthis.defaultFileTypeMap = fileTypeMap;\n\t}\n\n\n\t/**\n\t * Set JavaMail properties for the {@code Session}.\n\t * <p>A new {@code Session} will be created with those properties.\n\t * Use either this method or {@link #setSession}, but not both.\n\t * <p>Non-default properties in this instance will override given\n\t * JavaMail properties.\n\t */\n\tpublic void setJavaMailProperties(Properties javaMailProperties) {\n\t\tthis.javaMailProperties = javaMailProperties;\n\t\tsynchronized (this) {\n\t\t\tthis.session = null;\n\t\t}\n\t}\n\n\t/**\n\t * Allow {@code Map} access to the JavaMail properties of this sender,\n\t * with the option to add or override specific entries.\n\t * <p>Useful for specifying entries directly, for example via\n\t * {@code javaMailProperties[mail.smtp.auth]}.\n\t */\n\tpublic Properties getJavaMailProperties() {\n\t\treturn this.javaMailProperties;\n\t}\n\n\t/**\n\t * Set the JavaMail {@code Session}, possibly pulled from JNDI.\n\t * <p>Default is a new {@code Session} without defaults, that is\n\t * completely configured via this instance's properties.\n\t * <p>If using a pre-configured {@code Session}, non-default properties\n\t * in this instance will override the settings in the {@code Session}.\n\t * @see #setJavaMailProperties\n\t */\n\tpublic synchronized void setSession(Session session) {\n\t\tAssert.notNull(session, \"Session must not be null\");\n\t\tthis.session = session;\n\t}\n\n\t/**\n\t * Return the JavaMail {@code Session},\n\t * lazily initializing it if it hasn't been specified explicitly.\n\t */\n\tpublic synchronized Session getSession() {\n\t\tif (this.session == null) {\n\t\t\tthis.session = Session.getInstance(this.javaMailProperties);\n\t\t}\n\t\treturn this.session;\n\t}\n\n\t/**\n\t * Set the mail protocol. Default is \"smtp\".\n\t */\n\tpublic void setProtocol(@Nullable String protocol) {\n\t\tthis.protocol = protocol;\n\t}\n\n\t/**\n\t * Return the mail protocol.\n\t */\n\tpublic @Nullable String getProtocol() {\n\t\treturn this.protocol;\n\t}\n\n\t/**\n\t * Set the mail server host, typically an SMTP host.\n\t * <p>Default is the default host of the underlying JavaMail Session.\n\t */\n\tpublic void setHost(@Nullable String host) {\n\t\tthis.host = host;\n\t}\n\n\t/**\n\t * Return the mail server host.\n\t */\n\tpublic @Nullable String getHost() {\n\t\treturn this.host;\n\t}\n\n\t/**\n\t * Set the mail server port.\n\t * <p>Default is {@link #DEFAULT_PORT}, letting JavaMail use the default\n\t * SMTP port (25).\n\t */\n\tpublic void setPort(int port) {\n\t\tthis.port = port;\n\t}\n\n\t/**\n\t * Return the mail server port.\n\t */\n\tpublic int getPort() {\n\t\treturn this.port;\n\t}\n\n\t/**\n\t * Set the username for the account at the mail host, if any.\n\t * <p>Note that the underlying JavaMail {@code Session} has to be\n\t * configured with the property {@code \"mail.smtp.auth\"} set to\n\t * {@code true}, else the specified username will not be sent to the\n\t * mail server by the JavaMail runtime. If you are not explicitly passing\n\t * in a {@code Session} to use, simply specify this setting via\n\t * {@link #setJavaMailProperties}.\n\t * @see #setSession\n\t * @see #setPassword\n\t */\n\tpublic void setUsername(@Nullable String username) {\n\t\tthis.username = username;\n\t}\n\n\t/**\n\t * Return the username for the account at the mail host.\n\t */\n\tpublic @Nullable String getUsername() {\n\t\treturn this.username;\n\t}\n\n\t/**\n\t * Set the password for the account at the mail host, if any.\n\t * <p>Note that the underlying JavaMail {@code Session} has to be\n\t * configured with the property {@code \"mail.smtp.auth\"} set to\n\t * {@code true}, else the specified password will not be sent to the\n\t * mail server by the JavaMail runtime. If you are not explicitly passing\n\t * in a {@code Session} to use, simply specify this setting via\n\t * {@link #setJavaMailProperties}.\n\t * @see #setSession\n\t * @see #setUsername\n\t */\n\tpublic void setPassword(@Nullable String password) {\n\t\tthis.password = password;\n\t}\n\n\t/**\n\t * Return the password for the account at the mail host.\n\t */\n\tpublic @Nullable String getPassword() {\n\t\treturn this.password;\n\t}\n\n\t/**\n\t * Set the default encoding to use for {@link MimeMessage MimeMessages}\n\t * created by this instance.\n\t * <p>Such an encoding will be auto-detected by {@link MimeMessageHelper}.\n\t */\n\tpublic void setDefaultEncoding(@Nullable String defaultEncoding) {\n\t\tthis.defaultEncoding = defaultEncoding;\n\t}\n\n\t/**\n\t * Return the default encoding for {@link MimeMessage MimeMessages},\n\t * or {@code null} if none.\n\t */\n\tpublic @Nullable String getDefaultEncoding() {\n\t\treturn this.defaultEncoding;\n\t}\n\n\t/**\n\t * Set the default Java Activation {@link FileTypeMap} to use for\n\t * {@link MimeMessage MimeMessages} created by this instance.\n\t * <p>A {@code FileTypeMap} specified here will be autodetected by\n\t * {@link MimeMessageHelper}, avoiding the need to specify the\n\t * {@code FileTypeMap} for each {@code MimeMessageHelper} instance.\n\t * <p>For example, you can specify a custom instance of Spring's\n\t * {@link ConfigurableMimeFileTypeMap} here. If not explicitly specified,\n\t * a default {@code ConfigurableMimeFileTypeMap} will be used, containing\n\t * an extended set of MIME type mappings (as defined by the\n\t * {@code mime.types} file contained in the Spring jar).\n\t * @see MimeMessageHelper#setFileTypeMap\n\t */\n\tpublic void setDefaultFileTypeMap(@Nullable FileTypeMap defaultFileTypeMap) {\n\t\tthis.defaultFileTypeMap = defaultFileTypeMap;\n\t}\n\n\t/**\n\t * Return the default Java Activation {@link FileTypeMap} for\n\t * {@link MimeMessage MimeMessages}, or {@code null} if none.\n\t */\n\tpublic @Nullable FileTypeMap getDefaultFileTypeMap() {\n\t\treturn this.defaultFileTypeMap;\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of MailSender\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic void send(SimpleMailMessage... simpleMessages) throws MailException {\n\t\tList<MimeMessage> mimeMessages = new ArrayList<>(simpleMessages.length);\n\t\tfor (SimpleMailMessage simpleMessage : simpleMessages) {\n\t\t\tMimeMailMessage message = new MimeMailMessage(createMimeMessage());\n\t\t\tsimpleMessage.copyTo(message);\n\t\t\tmimeMessages.add(message.getMimeMessage());\n\t\t}\n\t\tdoSend(mimeMessages.toArray(new MimeMessage[0]), simpleMessages);\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of JavaMailSender\n\t//---------------------------------------------------------------------\n\n\t/**\n\t * This implementation creates a SmartMimeMessage, holding the specified\n\t * default encoding and default FileTypeMap. This special defaults-carrying\n\t * message will be autodetected by {@link MimeMessageHelper}, which will use\n\t * the carried encoding and FileTypeMap unless explicitly overridden.\n\t * @see #setDefaultEncoding\n\t * @see #setDefaultFileTypeMap\n\t */\n\t@Override\n\tpublic MimeMessage createMimeMessage() {\n\t\treturn new SmartMimeMessage(getSession(), getDefaultEncoding(), getDefaultFileTypeMap());\n\t}\n\n\t@Override\n\tpublic MimeMessage createMimeMessage(InputStream contentStream) throws MailException {\n\t\ttry {\n\t\t\treturn new MimeMessage(getSession(), contentStream);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new MailParseException(\"Could not parse raw MIME content\", ex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void send(MimeMessage... mimeMessages) throws MailException {\n\t\tdoSend(mimeMessages, null);\n\t}\n\n\t/**\n\t * Validate that this instance can connect to the server that it is configured\n\t * for. Throws a {@link MessagingException} if the connection attempt failed.\n\t */\n\tpublic void testConnection() throws MessagingException {\n\t\tTransport transport = null;\n\t\ttry {\n\t\t\ttransport = connectTransport();\n\t\t}\n\t\tfinally {\n\t\t\tif (transport != null) {\n\t\t\t\ttransport.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Actually send the given array of MimeMessages via JavaMail.\n\t * @param mimeMessages the MimeMessage objects to send\n\t * @param originalMessages corresponding original message objects\n\t * that the MimeMessages have been created from (with same array\n\t * length and indices as the \"mimeMessages\" array), if any\n\t * @throws org.springframework.mail.MailAuthenticationException\n\t * in case of authentication failure\n\t * @throws org.springframework.mail.MailSendException\n\t * in case of failure when sending a message\n\t */\n\tprotected void doSend(MimeMessage[] mimeMessages, Object @Nullable [] originalMessages) throws MailException {\n\t\tMap<Object, Exception> failedMessages = new LinkedHashMap<>();\n\t\tTransport transport = null;\n\n\t\ttry {\n\t\t\tfor (int i = 0; i < mimeMessages.length; i++) {\n\n\t\t\t\t// Check transport connection first...\n\t\t\t\tif (transport == null || !transport.isConnected()) {\n\t\t\t\t\tif (transport != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttransport.close();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t// Ignore - we're reconnecting anyway\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransport = null;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttransport = connectTransport();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (AuthenticationFailedException ex) {\n\t\t\t\t\t\tthrow new MailAuthenticationException(ex);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t// Effectively, all remaining messages failed...\n\t\t\t\t\t\tfor (int j = i; j < mimeMessages.length; j++) {\n\t\t\t\t\t\t\tObject original = (originalMessages != null ? originalMessages[j] : mimeMessages[j]);\n\t\t\t\t\t\t\tfailedMessages.put(original, ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new MailSendException(\"Mail server connection failed\", ex, failedMessages);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Send message via current transport...\n\t\t\t\tMimeMessage mimeMessage = mimeMessages[i];\n\t\t\t\ttry {\n\t\t\t\t\tif (mimeMessage.getSentDate() == null) {\n\t\t\t\t\t\tmimeMessage.setSentDate(new Date());\n\t\t\t\t\t}\n\t\t\t\t\tString messageId = mimeMessage.getMessageID();\n\t\t\t\t\tmimeMessage.saveChanges();\n\t\t\t\t\tif (messageId != null) {\n\t\t\t\t\t\t// Preserve explicitly specified message id...\n\t\t\t\t\t\tmimeMessage.setHeader(HEADER_MESSAGE_ID, messageId);\n\t\t\t\t\t}\n\t\t\t\t\tAddress[] addresses = mimeMessage.getAllRecipients();\n\t\t\t\t\ttransport.sendMessage(mimeMessage, (addresses != null ? addresses : new Address[0]));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tObject original = (originalMessages != null ? originalMessages[i] : mimeMessage);\n\t\t\t\t\tfailedMessages.put(original, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif (transport != null) {\n\t\t\t\t\ttransport.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (!failedMessages.isEmpty()) {\n\t\t\t\t\tthrow new MailSendException(\"Failed to close server connection after message failures\", ex,\n\t\t\t\t\t\t\tfailedMessages);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MailSendException(\"Failed to close server connection after message sending\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!failedMessages.isEmpty()) {\n\t\t\tthrow new MailSendException(failedMessages);\n\t\t}\n\t}\n\n\t/**\n\t * Obtain and connect a Transport from the underlying JavaMail Session,\n\t * passing in the specified host, port, username, and password.\n\t * @return the connected Transport object\n\t * @throws MessagingException if the connect attempt failed\n\t * @since 4.1.2\n\t * @see #getTransport\n\t * @see #getHost()\n\t * @see #getPort()\n\t * @see #getUsername()\n\t * @see #getPassword()\n\t */\n\tprotected Transport connectTransport() throws MessagingException {\n\t\tString username = getUsername();\n\t\tString password = getPassword();\n\t\tif (\"\".equals(username)) {  // probably from a placeholder\n\t\t\tusername = null;\n\t\t\tif (\"\".equals(password)) {  // in conjunction with \"\" username, this means no password to use\n\t\t\t\tpassword = null;\n\t\t\t}\n\t\t}\n\n\t\tTransport transport = getTransport(getSession());\n\t\ttransport.connect(getHost(), getPort(), username, password);\n\t\treturn transport;\n\t}\n\n\t/**\n\t * Obtain a Transport object from the given JavaMail Session,\n\t * using the configured protocol.\n\t * <p>Can be overridden in subclasses, for example, to return a mock Transport object.\n\t * @see jakarta.mail.Session#getTransport(String)\n\t * @see #getSession()\n\t * @see #getProtocol()\n\t */\n\tprotected Transport getTransport(Session session) throws NoSuchProviderException {\n\t\tString protocol = getProtocol();\n\t\tif (protocol == null) {\n\t\t\tprotocol = session.getProperty(\"mail.transport.protocol\");\n\t\t\tif (protocol == null) {\n\t\t\t\tprotocol = DEFAULT_PROTOCOL;\n\t\t\t}\n\t\t}\n\t\treturn session.getTransport(protocol);\n\t}\n\n}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#connectTransport()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain and connect a Transport from the underlying JavaMail Session,\n\t * passing in the specified host, port, username, and password.\n\t * @return the connected Transport object\n\t * @throws MessagingException if the connect attempt failed\n\t * @since 4.1.2\n\t * @see #getTransport\n\t * @see #getHost()\n\t * @see #getPort()\n\t * @see #getUsername()\n\t * @see #getPassword()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 456
    },
    "return": "Transport",
    "signature": "protected Transport connectTransport()",
    "source_code": "\tprotected Transport connectTransport() throws MessagingException {\n\t\tString username = getUsername();\n\t\tString password = getPassword();\n\t\tif (\"\".equals(username)) {  // probably from a placeholder\n\t\t\tusername = null;\n\t\t\tif (\"\".equals(password)) {  // in conjunction with \"\" username, this means no password to use\n\t\t\t\tpassword = null;\n\t\t\t}\n\t\t}\n\n\t\tTransport transport = getTransport(getSession());\n\t\ttransport.connect(getHost(), getPort(), username, password);\n\t\treturn transport;\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#createMimeMessage()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation creates a SmartMimeMessage, holding the specified\n\t * default encoding and default FileTypeMap. This special defaults-carrying\n\t * message will be autodetected by {@link MimeMessageHelper}, which will use\n\t * the carried encoding and FileTypeMap unless explicitly overridden.\n\t * @see #setDefaultEncoding\n\t * @see #setDefaultFileTypeMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "MimeMessage",
    "signature": "public MimeMessage createMimeMessage()",
    "source_code": "\tpublic MimeMessage createMimeMessage() {\n\t\treturn new SmartMimeMessage(getSession(), getDefaultEncoding(), getDefaultFileTypeMap());\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#createMimeMessage(contentStream)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentStream"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "MimeMessage",
    "signature": "public MimeMessage createMimeMessage(InputStream contentStream)",
    "source_code": "\tpublic MimeMessage createMimeMessage(InputStream contentStream) throws MailException {\n\t\ttry {\n\t\t\treturn new MimeMessage(getSession(), contentStream);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new MailParseException(\"Could not parse raw MIME content\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#doSend(mimeMessages,originalMessages)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually send the given array of MimeMessages via JavaMail.\n\t * @param mimeMessages the MimeMessage objects to send\n\t * @param originalMessages corresponding original message objects\n\t * that the MimeMessages have been created from (with same array\n\t * length and indices as the \"mimeMessages\" array), if any\n\t * @throws org.springframework.mail.MailAuthenticationException\n\t * in case of authentication failure\n\t * @throws org.springframework.mail.MailSendException\n\t * in case of failure when sending a message\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mimeMessages",
      "originalMessages"
    ],
    "position": {
      "column": 1,
      "line": 367
    },
    "return": "void",
    "signature": "protected void doSend(MimeMessage[] mimeMessages, Object @Nullable [] originalMessages)",
    "source_code": "\tprotected void doSend(MimeMessage[] mimeMessages, Object @Nullable [] originalMessages) throws MailException {\n\t\tMap<Object, Exception> failedMessages = new LinkedHashMap<>();\n\t\tTransport transport = null;\n\n\t\ttry {\n\t\t\tfor (int i = 0; i < mimeMessages.length; i++) {\n\n\t\t\t\t// Check transport connection first...\n\t\t\t\tif (transport == null || !transport.isConnected()) {\n\t\t\t\t\tif (transport != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttransport.close();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t// Ignore - we're reconnecting anyway\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransport = null;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttransport = connectTransport();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (AuthenticationFailedException ex) {\n\t\t\t\t\t\tthrow new MailAuthenticationException(ex);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t// Effectively, all remaining messages failed...\n\t\t\t\t\t\tfor (int j = i; j < mimeMessages.length; j++) {\n\t\t\t\t\t\t\tObject original = (originalMessages != null ? originalMessages[j] : mimeMessages[j]);\n\t\t\t\t\t\t\tfailedMessages.put(original, ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new MailSendException(\"Mail server connection failed\", ex, failedMessages);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Send message via current transport...\n\t\t\t\tMimeMessage mimeMessage = mimeMessages[i];\n\t\t\t\ttry {\n\t\t\t\t\tif (mimeMessage.getSentDate() == null) {\n\t\t\t\t\t\tmimeMessage.setSentDate(new Date());\n\t\t\t\t\t}\n\t\t\t\t\tString messageId = mimeMessage.getMessageID();\n\t\t\t\t\tmimeMessage.saveChanges();\n\t\t\t\t\tif (messageId != null) {\n\t\t\t\t\t\t// Preserve explicitly specified message id...\n\t\t\t\t\t\tmimeMessage.setHeader(HEADER_MESSAGE_ID, messageId);\n\t\t\t\t\t}\n\t\t\t\t\tAddress[] addresses = mimeMessage.getAllRecipients();\n\t\t\t\t\ttransport.sendMessage(mimeMessage, (addresses != null ? addresses : new Address[0]));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tObject original = (originalMessages != null ? originalMessages[i] : mimeMessage);\n\t\t\t\t\tfailedMessages.put(original, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif (transport != null) {\n\t\t\t\t\ttransport.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (!failedMessages.isEmpty()) {\n\t\t\t\t\tthrow new MailSendException(\"Failed to close server connection after message failures\", ex,\n\t\t\t\t\t\t\tfailedMessages);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MailSendException(\"Failed to close server connection after message sending\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!failedMessages.isEmpty()) {\n\t\t\tthrow new MailSendException(failedMessages);\n\t\t}\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#getDefaultEncoding()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the default encoding for {@link MimeMessage MimeMessages},\n\t * or {@code null} if none.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "String",
    "signature": "public String getDefaultEncoding()",
    "source_code": "\tpublic @Nullable String getDefaultEncoding() {\n\t\treturn this.defaultEncoding;\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#getDefaultFileTypeMap()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the default Java Activation {@link FileTypeMap} for\n\t * {@link MimeMessage MimeMessages}, or {@code null} if none.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "FileTypeMap",
    "signature": "public FileTypeMap getDefaultFileTypeMap()",
    "source_code": "\tpublic @Nullable FileTypeMap getDefaultFileTypeMap() {\n\t\treturn this.defaultFileTypeMap;\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#getHost()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the mail server host.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "String",
    "signature": "public String getHost()",
    "source_code": "\tpublic @Nullable String getHost() {\n\t\treturn this.host;\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#getJavaMailProperties()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Allow {@code Map} access to the JavaMail properties of this sender,\n\t * with the option to add or override specific entries.\n\t * <p>Useful for specifying entries directly, for example via\n\t * {@code javaMailProperties[mail.smtp.auth]}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "Properties",
    "signature": "public Properties getJavaMailProperties()",
    "source_code": "\tpublic Properties getJavaMailProperties() {\n\t\treturn this.javaMailProperties;\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#getPassword()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the password for the account at the mail host.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "String",
    "signature": "public String getPassword()",
    "source_code": "\tpublic @Nullable String getPassword() {\n\t\treturn this.password;\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#getPort()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the mail server port.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "int",
    "signature": "public int getPort()",
    "source_code": "\tpublic int getPort() {\n\t\treturn this.port;\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#getProtocol()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the mail protocol.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "String",
    "signature": "public String getProtocol()",
    "source_code": "\tpublic @Nullable String getProtocol() {\n\t\treturn this.protocol;\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#getSession()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JavaMail {@code Session},\n\t * lazily initializing it if it hasn't been specified explicitly.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Session",
    "signature": "public Session getSession()",
    "source_code": "\tpublic synchronized Session getSession() {\n\t\tif (this.session == null) {\n\t\t\tthis.session = Session.getInstance(this.javaMailProperties);\n\t\t}\n\t\treturn this.session;\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#getTransport(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a Transport object from the given JavaMail Session,\n\t * using the configured protocol.\n\t * <p>Can be overridden in subclasses, for example, to return a mock Transport object.\n\t * @see jakarta.mail.Session#getTransport(String)\n\t * @see #getSession()\n\t * @see #getProtocol()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 479
    },
    "return": "Transport",
    "signature": "protected Transport getTransport(Session session)",
    "source_code": "\tprotected Transport getTransport(Session session) throws NoSuchProviderException {\n\t\tString protocol = getProtocol();\n\t\tif (protocol == null) {\n\t\t\tprotocol = session.getProperty(\"mail.transport.protocol\");\n\t\t\tif (protocol == null) {\n\t\t\t\tprotocol = DEFAULT_PROTOCOL;\n\t\t\t}\n\t\t}\n\t\treturn session.getTransport(protocol);\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#getUsername()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the username for the account at the mail host.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "String",
    "signature": "public String getUsername()",
    "source_code": "\tpublic @Nullable String getUsername() {\n\t\treturn this.username;\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#send(mimeMessages)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mimeMessages"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "void",
    "signature": "public void send(MimeMessage... mimeMessages)",
    "source_code": "\tpublic void send(MimeMessage... mimeMessages) throws MailException {\n\t\tdoSend(mimeMessages, null);\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#send(simpleMessages)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "simpleMessages"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "void",
    "signature": "public void send(SimpleMailMessage... simpleMessages)",
    "source_code": "\tpublic void send(SimpleMailMessage... simpleMessages) throws MailException {\n\t\tList<MimeMessage> mimeMessages = new ArrayList<>(simpleMessages.length);\n\t\tfor (SimpleMailMessage simpleMessage : simpleMessages) {\n\t\t\tMimeMailMessage message = new MimeMailMessage(createMimeMessage());\n\t\t\tsimpleMessage.copyTo(message);\n\t\t\tmimeMessages.add(message.getMimeMessage());\n\t\t}\n\t\tdoSend(mimeMessages.toArray(new MimeMessage[0]), simpleMessages);\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#setDefaultEncoding(defaultEncoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the default encoding to use for {@link MimeMessage MimeMessages}\n\t * created by this instance.\n\t * <p>Such an encoding will be auto-detected by {@link MimeMessageHelper}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultEncoding"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void setDefaultEncoding(@Nullable String defaultEncoding)",
    "source_code": "\tpublic void setDefaultEncoding(@Nullable String defaultEncoding) {\n\t\tthis.defaultEncoding = defaultEncoding;\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#setDefaultFileTypeMap(defaultFileTypeMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the default Java Activation {@link FileTypeMap} to use for\n\t * {@link MimeMessage MimeMessages} created by this instance.\n\t * <p>A {@code FileTypeMap} specified here will be autodetected by\n\t * {@link MimeMessageHelper}, avoiding the need to specify the\n\t * {@code FileTypeMap} for each {@code MimeMessageHelper} instance.\n\t * <p>For example, you can specify a custom instance of Spring's\n\t * {@link ConfigurableMimeFileTypeMap} here. If not explicitly specified,\n\t * a default {@code ConfigurableMimeFileTypeMap} will be used, containing\n\t * an extended set of MIME type mappings (as defined by the\n\t * {@code mime.types} file contained in the Spring jar).\n\t * @see MimeMessageHelper#setFileTypeMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultFileTypeMap"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "void",
    "signature": "public void setDefaultFileTypeMap(@Nullable FileTypeMap defaultFileTypeMap)",
    "source_code": "\tpublic void setDefaultFileTypeMap(@Nullable FileTypeMap defaultFileTypeMap) {\n\t\tthis.defaultFileTypeMap = defaultFileTypeMap;\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#setHost(host)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the mail server host, typically an SMTP host.\n\t * <p>Default is the default host of the underlying JavaMail Session.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "host"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "void",
    "signature": "public void setHost(@Nullable String host)",
    "source_code": "\tpublic void setHost(@Nullable String host) {\n\t\tthis.host = host;\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#setJavaMailProperties(javaMailProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set JavaMail properties for the {@code Session}.\n\t * <p>A new {@code Session} will be created with those properties.\n\t * Use either this method or {@link #setSession}, but not both.\n\t * <p>Non-default properties in this instance will override given\n\t * JavaMail properties.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "javaMailProperties"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void setJavaMailProperties(Properties javaMailProperties)",
    "source_code": "\tpublic void setJavaMailProperties(Properties javaMailProperties) {\n\t\tthis.javaMailProperties = javaMailProperties;\n\t\tsynchronized (this) {\n\t\t\tthis.session = null;\n\t\t}\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#setPassword(password)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the password for the account at the mail host, if any.\n\t * <p>Note that the underlying JavaMail {@code Session} has to be\n\t * configured with the property {@code \"mail.smtp.auth\"} set to\n\t * {@code true}, else the specified password will not be sent to the\n\t * mail server by the JavaMail runtime. If you are not explicitly passing\n\t * in a {@code Session} to use, simply specify this setting via\n\t * {@link #setJavaMailProperties}.\n\t * @see #setSession\n\t * @see #setUsername\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "password"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "void",
    "signature": "public void setPassword(@Nullable String password)",
    "source_code": "\tpublic void setPassword(@Nullable String password) {\n\t\tthis.password = password;\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#setPort(port)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the mail server port.\n\t * <p>Default is {@link #DEFAULT_PORT}, letting JavaMail use the default\n\t * SMTP port (25).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "port"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "void",
    "signature": "public void setPort(int port)",
    "source_code": "\tpublic void setPort(int port) {\n\t\tthis.port = port;\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#setProtocol(protocol)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the mail protocol. Default is \"smtp\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "protocol"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "public void setProtocol(@Nullable String protocol)",
    "source_code": "\tpublic void setProtocol(@Nullable String protocol) {\n\t\tthis.protocol = protocol;\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#setSession(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JavaMail {@code Session}, possibly pulled from JNDI.\n\t * <p>Default is a new {@code Session} without defaults, that is\n\t * completely configured via this instance's properties.\n\t * <p>If using a pre-configured {@code Session}, non-default properties\n\t * in this instance will override the settings in the {@code Session}.\n\t * @see #setJavaMailProperties\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "void",
    "signature": "public void setSession(Session session)",
    "source_code": "\tpublic synchronized void setSession(Session session) {\n\t\tAssert.notNull(session, \"Session must not be null\");\n\t\tthis.session = session;\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#setUsername(username)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the username for the account at the mail host, if any.\n\t * <p>Note that the underlying JavaMail {@code Session} has to be\n\t * configured with the property {@code \"mail.smtp.auth\"} set to\n\t * {@code true}, else the specified username will not be sent to the\n\t * mail server by the JavaMail runtime. If you are not explicitly passing\n\t * in a {@code Session} to use, simply specify this setting via\n\t * {@link #setJavaMailProperties}.\n\t * @see #setSession\n\t * @see #setPassword\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "void",
    "signature": "public void setUsername(@Nullable String username)",
    "source_code": "\tpublic void setUsername(@Nullable String username) {\n\t\tthis.username = username;\n\t}"
  },
  "org.springframework.mail.javamail.JavaMailSenderImpl#testConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate that this instance can connect to the server that it is configured\n\t * for. Throws a {@link MessagingException} if the connection attempt failed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 344
    },
    "return": "void",
    "signature": "public void testConnection()",
    "source_code": "\tpublic void testConnection() throws MessagingException {\n\t\tTransport transport = null;\n\t\ttry {\n\t\t\ttransport = connectTransport();\n\t\t}\n\t\tfinally {\n\t\t\tif (transport != null) {\n\t\t\t\ttransport.close();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.converter.ProtobufJsonFormatMessageConverter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Subclass of {@link ProtobufMessageConverter} for use with the official\n * {@code \"com.google.protobuf:protobuf-java-util\"} library for JSON support.\n *\n * <p>Most importantly, this class allows for custom JSON parser and printer\n * configurations through the {@link JsonFormat} utility. If no special parser\n * or printer configuration is given, default variants will be used instead.\n *\n * <p>Requires Protobuf 3.x and {@code \"com.google.protobuf:protobuf-java-util\"} 3.x,\n * with 3.3 or higher recommended.\n *\n * @author Rossen Stoyanchev\n * @since 5.2.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class ProtobufJsonFormatMessageConverter",
    "source_code": "public class ProtobufJsonFormatMessageConverter extends ProtobufMessageConverter {\n\n\t/**\n\t * Constructor with default instances of {@link com.google.protobuf.util.JsonFormat.Parser\n\t * JsonFormat.Parser}, {@link com.google.protobuf.util.JsonFormat.Printer\n\t * JsonFormat.Printer}, and {@link ExtensionRegistry}.\n\t */\n\tpublic ProtobufJsonFormatMessageConverter(@Nullable ExtensionRegistry extensionRegistry) {\n\t\tthis(null, null);\n\t}\n\n\t/**\n\t * Constructor with given instances of {@link com.google.protobuf.util.JsonFormat.Parser\n\t * JsonFormat.Parser}, {@link com.google.protobuf.util.JsonFormat.Printer\n\t * JsonFormat.Printer}, and a default instance of {@link ExtensionRegistry}.\n\t */\n\tpublic ProtobufJsonFormatMessageConverter(\n\t\t\tJsonFormat.@Nullable Parser parser, JsonFormat.@Nullable Printer printer) {\n\n\t\tthis(parser, printer, null);\n\t}\n\n\t/**\n\t * Constructor with given instances of {@link com.google.protobuf.util.JsonFormat.Parser\n\t * JsonFormat.Parser}, {@link com.google.protobuf.util.JsonFormat.Printer\n\t * JsonFormat.Printer}, and {@link ExtensionRegistry}.\n\t */\n\tpublic ProtobufJsonFormatMessageConverter(JsonFormat.@Nullable Parser parser,\n\t\t\tJsonFormat.@Nullable Printer printer, @Nullable ExtensionRegistry extensionRegistry) {\n\n\t\tsuper(new ProtobufJavaUtilSupport(parser, printer), extensionRegistry);\n\t}\n\n}"
  },
  "org.springframework.messaging.core.AbstractDestinationResolvingMessagingTemplate": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An extension of {@link AbstractMessagingTemplate} that adds operations for sending\n * messages to a resolvable destination name. Supports destination resolving as defined by\n * the following interfaces:\n * <ul>\n * <li>{@link DestinationResolvingMessageSendingOperations}</li>\n * <li>{@link DestinationResolvingMessageReceivingOperations}</li>\n * <li>{@link DestinationResolvingMessageRequestReplyOperations}</li>\n * </ul>\n *\n * @author Mark Fisher\n * @author Rossen Stoyanchev\n * @since 4.0\n * @param <D> the destination type\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public class AbstractDestinationResolvingMessagingTemplate",
    "source_code": "public abstract class AbstractDestinationResolvingMessagingTemplate<D> extends AbstractMessagingTemplate<D>"
  },
  "org.springframework.messaging.core.AbstractDestinationResolvingMessagingTemplate#convertAndSend(destinationName,payload)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, T payload)",
    "source_code": "\tpublic <T> void convertAndSend(String destinationName, T payload) {\n\t\tconvertAndSend(destinationName, payload, null, null);\n\t}"
  },
  "org.springframework.messaging.core.AbstractDestinationResolvingMessagingTemplate#convertAndSend(destinationName,payload,Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "payload",
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, T payload, @Nullable Map<String, Object> headers)",
    "source_code": "\tpublic <T> void convertAndSend(String destinationName, T payload, @Nullable Map<String, Object> headers) {\n\t\tconvertAndSend(destinationName, payload, headers, null);\n\t}"
  },
  "org.springframework.messaging.core.AbstractDestinationResolvingMessagingTemplate#convertAndSend(destinationName,payload,Map<String,headers,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "payload",
      "Map<String",
      "headers",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, T payload,\n\t\t\t@Nullable Map<String, Object> headers, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic <T> void convertAndSend(String destinationName, T payload,"
  },
  "org.springframework.messaging.core.AbstractDestinationResolvingMessagingTemplate#convertAndSend(destinationName,payload,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "payload",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, T payload, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic <T> void convertAndSend(String destinationName, T payload, @Nullable MessagePostProcessor postProcessor) {\n\t\tconvertAndSend(destinationName, payload, null, postProcessor);\n\t}"
  },
  "org.springframework.messaging.core.AbstractDestinationResolvingMessagingTemplate#convertSendAndReceive(destinationName,request,Map<String,headers,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "request",
      "Map<String",
      "headers",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(String destinationName, Object request,\n\t\t\t@Nullable Map<String, Object> headers, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(String destinationName, Object request,"
  },
  "org.springframework.messaging.core.AbstractDestinationResolvingMessagingTemplate#convertSendAndReceive(destinationName,request,Map<String,headers,targetClass,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "request",
      "Map<String",
      "headers",
      "targetClass",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(String destinationName, Object request,\n\t\t\t@Nullable Map<String, Object> headers, Class<T> targetClass,\n\t\t\t@Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(String destinationName, Object request,"
  },
  "org.springframework.messaging.core.AbstractDestinationResolvingMessagingTemplate#convertSendAndReceive(destinationName,request,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "request",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(String destinationName, Object request, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(String destinationName, Object request, Class<T> targetClass) {\n\t\tD destination = resolveDestination(destinationName);\n\t\treturn super.convertSendAndReceive(destination, request, targetClass);\n\t}"
  },
  "org.springframework.messaging.core.AbstractDestinationResolvingMessagingTemplate#convertSendAndReceive(destinationName,request,targetClass,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "request",
      "targetClass",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(String destinationName, Object request, Class<T> targetClass,\n\t\t\t@Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(String destinationName, Object request, Class<T> targetClass,"
  },
  "org.springframework.messaging.core.AbstractDestinationResolvingMessagingTemplate#getDestinationResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured destination resolver.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "DestinationResolver<D>",
    "signature": "public DestinationResolver<D> getDestinationResolver()",
    "source_code": "\tpublic @Nullable DestinationResolver<D> getDestinationResolver() {\n\t\treturn this.destinationResolver;\n\t}"
  },
  "org.springframework.messaging.core.AbstractDestinationResolvingMessagingTemplate#receiveAndConvert(destinationName,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "T",
    "signature": "public T receiveAndConvert(String destinationName, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T receiveAndConvert(String destinationName, Class<T> targetClass) {\n\t\tD destination = resolveDestination(destinationName);\n\t\treturn super.receiveAndConvert(destination, targetClass);\n\t}"
  },
  "org.springframework.messaging.core.AbstractDestinationResolvingMessagingTemplate#resolveDestination(destinationName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destinationName"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "D",
    "signature": "protected D resolveDestination(String destinationName)",
    "source_code": "\tprotected final D resolveDestination(String destinationName) {\n\n\t\tAssert.state(this.destinationResolver != null, \"DestinationResolver is required to resolve destination names\");\n\t\treturn this.destinationResolver.resolveDestination(destinationName);\n\t}"
  },
  "org.springframework.messaging.core.AbstractDestinationResolvingMessagingTemplate#send(destinationName,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void send(String destinationName, Message<?> message)",
    "source_code": "\tpublic void send(String destinationName, Message<?> message) {\n\t\tD destination = resolveDestination(destinationName);\n\t\tdoSend(destination, message);\n\t}"
  },
  "org.springframework.messaging.core.AbstractDestinationResolvingMessagingTemplate#setDestinationResolver(destinationResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link DestinationResolver} to use to resolve String destination\n\t * names into actual destinations of type {@code <D>}.\n\t * <p>This field does not have a default setting. If not configured, methods that\n\t * require resolving a destination name will raise an {@link IllegalArgumentException}.\n\t * @param destinationResolver the destination resolver to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationResolver"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "void",
    "signature": "public void setDestinationResolver(@Nullable DestinationResolver<D> destinationResolver)",
    "source_code": "\tpublic void setDestinationResolver(@Nullable DestinationResolver<D> destinationResolver) {\n\t\tthis.destinationResolver = destinationResolver;\n\t}"
  },
  "org.springframework.messaging.core.AbstractMessageReceivingTemplate": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An extension of {@link AbstractMessageSendingTemplate} that adds support for\n * receive style operations as defined by {@link MessageReceivingOperations}.\n *\n * @author Mark Fisher\n * @author Rossen Stoyanchev\n * @author Stephane Nicoll\n * @since 4.1\n * @param <D> the destination type\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class AbstractMessageReceivingTemplate",
    "source_code": "public abstract class AbstractMessageReceivingTemplate<D> extends AbstractMessageSendingTemplate<D>"
  },
  "org.springframework.messaging.core.AbstractMessageReceivingTemplate#doConvert(message,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert from the given message to the given target class.\n\t * @param message the message to convert\n\t * @param targetClass the target class to convert the payload to\n\t * @return the converted payload of the reply message (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "T",
    "signature": "protected T doConvert(Message<?> message, Class<T> targetClass)",
    "source_code": "\tprotected <T> @Nullable T doConvert(Message<?> message, Class<T> targetClass) {\n\t\tMessageConverter messageConverter = getMessageConverter();\n\t\tT value = (T) messageConverter.fromMessage(message, targetClass);\n\t\tif (value == null) {\n\t\t\tthrow new MessageConversionException(message, \"Unable to convert payload [\" + message.getPayload() +\n\t\t\t\t\t\"] to type [\" + targetClass + \"] using converter [\" + messageConverter + \"]\");\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.messaging.core.AbstractMessageReceivingTemplate#receiveAndConvert(destination,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "T",
    "signature": "public T receiveAndConvert(D destination, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T receiveAndConvert(D destination, Class<T> targetClass) {\n\t\tMessage<?> message = doReceive(destination);\n\t\tif (message != null) {\n\t\t\treturn doConvert(message, targetClass);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.messaging.core.AbstractMessageReceivingTemplate#receiveAndConvert(targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "T",
    "signature": "public T receiveAndConvert(Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T receiveAndConvert(Class<T> targetClass) {\n\t\treturn receiveAndConvert(getRequiredDefaultDestination(), targetClass);\n\t}"
  },
  "org.springframework.messaging.core.AbstractMessagingTemplate": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An extension of {@link AbstractMessageReceivingTemplate} that adds support for\n * request-reply style operations as defined by {@link MessageRequestReplyOperations}.\n *\n * @author Mark Fisher\n * @author Rossen Stoyanchev\n * @author Stephane Nicoll\n * @since 4.0\n * @param <D> the destination type\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class AbstractMessagingTemplate",
    "source_code": "public abstract class AbstractMessagingTemplate<D> extends AbstractMessageReceivingTemplate<D>"
  },
  "org.springframework.messaging.core.AbstractMessagingTemplate#convertSendAndReceive(destination,request,Map<String,headers,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "request",
      "Map<String",
      "headers",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(D destination, Object request, @Nullable Map<String, Object> headers, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive("
  },
  "org.springframework.messaging.core.AbstractMessagingTemplate#convertSendAndReceive(destination,request,Map<String,headers,targetClass,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "request",
      "Map<String",
      "headers",
      "targetClass",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(D destination, Object request, @Nullable Map<String, Object> headers,\n\t\t\tClass<T> targetClass, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(D destination, Object request, @Nullable Map<String, Object> headers,"
  },
  "org.springframework.messaging.core.AbstractMessagingTemplate#convertSendAndReceive(destination,request,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "request",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(D destination, Object request, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(D destination, Object request, Class<T> targetClass) {\n\t\treturn convertSendAndReceive(destination, request, null, targetClass);\n\t}"
  },
  "org.springframework.messaging.core.AbstractMessagingTemplate#convertSendAndReceive(destination,request,targetClass,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "request",
      "targetClass",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(D destination, Object request, Class<T> targetClass,\n\t\t\t@Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(D destination, Object request, Class<T> targetClass,"
  },
  "org.springframework.messaging.core.AbstractMessagingTemplate#convertSendAndReceive(request,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(Object request, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(Object request, Class<T> targetClass) {\n\t\treturn convertSendAndReceive(getRequiredDefaultDestination(), request, targetClass);\n\t}"
  },
  "org.springframework.messaging.core.AbstractMessagingTemplate#convertSendAndReceive(request,targetClass,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "targetClass",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(Object request, Class<T> targetClass, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive("
  },
  "org.springframework.messaging.core.DestinationResolvingMessageReceivingOperations": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Extends {@link MessageReceivingOperations} and adds operations for receiving messages\n * from a destination specified as a (resolvable) String name.\n *\n * @author Mark Fisher\n * @author Rossen Stoyanchev\n * @since 4.0\n * @param <D> the type of destination to receive messages from\n * @see DestinationResolver\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 34
    },
    "signature": "public interface DestinationResolvingMessageReceivingOperations",
    "source_code": "public interface DestinationResolvingMessageReceivingOperations<D> extends MessageReceivingOperations<D> {\n\n\t/**\n\t * Resolve the given destination name and receive a message from it.\n\t * @param destinationName the destination name to resolve\n\t */\n\t@Nullable Message<?> receive(String destinationName) throws MessagingException;\n\n\t/**\n\t * Resolve the given destination name, receive a message from it,\n\t * convert the payload to the specified target type.\n\t * @param destinationName the destination name to resolve\n\t * @param targetClass the target class for the converted payload\n\t */\n\t<T> @Nullable T receiveAndConvert(String destinationName, Class<T> targetClass) throws MessagingException;\n\n}"
  },
  "org.springframework.messaging.core.DestinationResolvingMessageRequestReplyOperations": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Extends {@link MessageRequestReplyOperations} and adds operations for sending and\n * receiving messages to and from a destination specified as a (resolvable) String name.\n *\n * @author Mark Fisher\n * @author Rossen Stoyanchev\n * @since 4.0\n * @param <D> the destination type\n * @see DestinationResolver\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public interface DestinationResolvingMessageRequestReplyOperations",
    "source_code": "public interface DestinationResolvingMessageRequestReplyOperations<D> extends MessageRequestReplyOperations<D> {\n\n\t/**\n\t * Resolve the given destination name to a destination and send the given message,\n\t * receive a reply and return it.\n\t * @param destinationName the name of the target destination\n\t * @param requestMessage the message to send\n\t * @return the received message, possibly {@code null} if the message could not\n\t * be received, for example due to a timeout\n\t */\n\t@Nullable Message<?> sendAndReceive(String destinationName, Message<?> requestMessage) throws MessagingException;\n\n\t/**\n\t * Resolve the given destination name, convert the payload request Object\n\t * to serialized form, possibly using a\n\t * {@link org.springframework.messaging.converter.MessageConverter},\n\t * wrap it as a message and send it to the resolved destination, receive a reply\n\t * and convert its body to the specified target class.\n\t * @param destinationName the name of the target destination\n\t * @param request the payload for the request message to send\n\t * @param targetClass the target class to convert the payload of the reply to\n\t * @return the converted payload of the reply message, possibly {@code null} if\n\t * the message could not be received, for example due to a timeout\n\t */\n\t<T> @Nullable T convertSendAndReceive(String destinationName, Object request, Class<T> targetClass)\n\t\t\tthrows MessagingException;\n\n\t/**\n\t * Resolve the given destination name, convert the payload request Object\n\t * to serialized form, possibly using a\n\t * {@link org.springframework.messaging.converter.MessageConverter},\n\t * wrap it as a message with the given headers and send it to the resolved destination,\n\t * receive a reply and convert its body to the specified target class.\n\t * @param destinationName the name of the target destination\n\t * @param request the payload for the request message to send\n\t * @param headers the headers for the request message to send\n\t * @param targetClass the target class to convert the payload of the reply to\n\t * @return the converted payload of the reply message, possibly {@code null} if\n\t * the message could not be received, for example due to a timeout\n\t */\n\t<T> @Nullable T convertSendAndReceive(String destinationName, Object request,\n\t\t\t@Nullable Map<String, Object> headers, Class<T> targetClass) throws MessagingException;\n\n\t/**\n\t * Resolve the given destination name, convert the payload request Object\n\t * to serialized form, possibly using a\n\t * {@link org.springframework.messaging.converter.MessageConverter},\n\t * wrap it as a message, apply the given post process, and send the resulting\n\t * message to the resolved destination, then receive a reply and convert its\n\t * body to the specified target class.\n\t * @param destinationName the name of the target destination\n\t * @param request the payload for the request message to send\n\t * @param targetClass the target class to convert the payload of the reply to\n\t * @param requestPostProcessor post process for the request message\n\t * @return the converted payload of the reply message, possibly {@code null} if\n\t * the message could not be received, for example due to a timeout\n\t */\n\t<T> @Nullable T convertSendAndReceive(String destinationName, Object request, Class<T> targetClass,\n\t\t\t@Nullable MessagePostProcessor requestPostProcessor) throws MessagingException;\n\n\t/**\n\t * Resolve the given destination name, convert the payload request Object\n\t * to serialized form, possibly using a\n\t * {@link org.springframework.messaging.converter.MessageConverter},\n\t * wrap it as a message with the given headers, apply the given post process,\n\t * and send the resulting message to the resolved destination, then receive\n\t * a reply and convert its body to the specified target class.\n\t * @param destinationName the name of the target destination\n\t * @param request the payload for the request message to send\n\t * @param headers the headers for the request message to send\n\t * @param targetClass the target class to convert the payload of the reply to\n\t * @param requestPostProcessor post process for the request message\n\t * @return the converted payload of the reply message, possibly {@code null} if\n\t * the message could not be received, for example due to a timeout\n\t */\n\t<T> @Nullable T convertSendAndReceive(String destinationName, Object request, @Nullable Map<String, Object> headers,\n\t\t\tClass<T> targetClass, @Nullable MessagePostProcessor requestPostProcessor) throws MessagingException;\n\n}"
  },
  "org.springframework.messaging.core.MessageReceivingOperations": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Operations for receiving messages from a destination.\n *\n * @author Mark Fisher\n * @author Rossen Stoyanchev\n * @since 4.0\n * @param <D> the type of destination\n * @see GenericMessagingTemplate\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 33
    },
    "signature": "public interface MessageReceivingOperations",
    "source_code": "public interface MessageReceivingOperations<D> {\n\n\t/**\n\t * Receive a message from a default destination.\n\t * @return the received message, possibly {@code null} if the message could not\n\t * be received, for example due to a timeout\n\t */\n\t@Nullable Message<?> receive() throws MessagingException;\n\n\t/**\n\t * Receive a message from the given destination.\n\t * @param destination the target destination\n\t * @return the received message, possibly {@code null} if the message could not\n\t * be received, for example due to a timeout\n\t */\n\t@Nullable Message<?> receive(D destination) throws MessagingException;\n\n\t/**\n\t * Receive a message from a default destination and convert its payload to the\n\t * specified target class.\n\t * @param targetClass the target class to convert the payload to\n\t * @return the converted payload of the reply message, possibly {@code null} if\n\t * the message could not be received, for example due to a timeout\n\t */\n\t<T> @Nullable T receiveAndConvert(Class<T> targetClass) throws MessagingException;\n\n\t/**\n\t * Receive a message from the given destination and convert its payload to the\n\t * specified target class.\n\t * @param destination the target destination\n\t * @param targetClass the target class to convert the payload to\n\t * @return the converted payload of the reply message, possibly {@code null} if\n\t * the message could not be received, for example due to a timeout\n\t */\n\t<T> @Nullable T receiveAndConvert(D destination, Class<T> targetClass) throws MessagingException;\n\n}"
  },
  "org.springframework.messaging.core.MessageRequestReplyOperations": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Operations for sending messages to and receiving the reply from a destination.\n *\n * @author Mark Fisher\n * @author Rossen Stoyanchev\n * @since 4.0\n * @param <D> the type of destination\n * @see GenericMessagingTemplate\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public interface MessageRequestReplyOperations",
    "source_code": "public interface MessageRequestReplyOperations<D> {\n\n\t/**\n\t * Send a request message and receive the reply from a default destination.\n\t * @param requestMessage the message to send\n\t * @return the reply, possibly {@code null} if the message could not be received,\n\t * for example due to a timeout\n\t */\n\t@Nullable Message<?> sendAndReceive(Message<?> requestMessage) throws MessagingException;\n\n\t/**\n\t * Send a request message and receive the reply from the given destination.\n\t * @param destination the target destination\n\t * @param requestMessage the message to send\n\t * @return the reply, possibly {@code null} if the message could not be received,\n\t * for example due to a timeout\n\t */\n\t@Nullable Message<?> sendAndReceive(D destination, Message<?> requestMessage) throws MessagingException;\n\n\t/**\n\t * Convert the given request Object to serialized form, possibly using a\n\t * {@link org.springframework.messaging.converter.MessageConverter}, send\n\t * it as a {@link Message} to a default destination, receive the reply and convert\n\t * its body of the specified target class.\n\t * @param request payload for the request message to send\n\t * @param targetClass the target type to convert the payload of the reply to\n\t * @return the payload of the reply message, possibly {@code null} if the message\n\t * could not be received, for example due to a timeout\n\t */\n\t<T> @Nullable T convertSendAndReceive(Object request, Class<T> targetClass) throws MessagingException;\n\n\t/**\n\t * Convert the given request Object to serialized form, possibly using a\n\t * {@link org.springframework.messaging.converter.MessageConverter}, send\n\t * it as a {@link Message} to the given destination, receive the reply and convert\n\t * its body of the specified target class.\n\t * @param destination the target destination\n\t * @param request payload for the request message to send\n\t * @param targetClass the target type to convert the payload of the reply to\n\t * @return the payload of the reply message, possibly {@code null} if the message\n\t * could not be received, for example due to a timeout\n\t */\n\t<T> @Nullable T convertSendAndReceive(D destination, Object request, Class<T> targetClass) throws MessagingException;\n\n\t/**\n\t * Convert the given request Object to serialized form, possibly using a\n\t * {@link org.springframework.messaging.converter.MessageConverter}, send\n\t * it as a {@link Message} with the given headers, to the specified destination,\n\t * receive the reply and convert its body of the specified target class.\n\t * @param destination the target destination\n\t * @param request payload for the request message to send\n\t * @param headers the headers for the request message to send\n\t * @param targetClass the target type to convert the payload of the reply to\n\t * @return the payload of the reply message, possibly {@code null} if the message\n\t * could not be received, for example due to a timeout\n\t */\n\t<T> @Nullable T convertSendAndReceive(\n\t\t\tD destination, Object request, @Nullable Map<String, Object> headers, Class<T> targetClass)\n\t\t\tthrows MessagingException;\n\n\t/**\n\t * Convert the given request Object to serialized form, possibly using a\n\t * {@link org.springframework.messaging.converter.MessageConverter},\n\t * apply the given post processor and send the resulting {@link Message} to a\n\t * default destination, receive the reply and convert its body of the given\n\t * target class.\n\t * @param request payload for the request message to send\n\t * @param targetClass the target type to convert the payload of the reply to\n\t * @param requestPostProcessor post process to apply to the request message\n\t * @return the payload of the reply message, possibly {@code null} if the message\n\t * could not be received, for example due to a timeout\n\t */\n\t<T> @Nullable T convertSendAndReceive(\n\t\t\tObject request, Class<T> targetClass, @Nullable MessagePostProcessor requestPostProcessor)\n\t\t\tthrows MessagingException;\n\n\t/**\n\t * Convert the given request Object to serialized form, possibly using a\n\t * {@link org.springframework.messaging.converter.MessageConverter},\n\t * apply the given post processor and send the resulting {@link Message} to the\n\t * given destination, receive the reply and convert its body of the given\n\t * target class.\n\t * @param destination the target destination\n\t * @param request payload for the request message to send\n\t * @param targetClass the target type to convert the payload of the reply to\n\t * @param requestPostProcessor post process to apply to the request message\n\t * @return the payload of the reply message, possibly {@code null} if the message\n\t * could not be received, for example due to a timeout\n\t */\n\t<T> @Nullable T convertSendAndReceive(D destination, Object request, Class<T> targetClass,\n\t\t\tMessagePostProcessor requestPostProcessor) throws MessagingException;\n\n\t/**\n\t * Convert the given request Object to serialized form, possibly using a\n\t * {@link org.springframework.messaging.converter.MessageConverter},\n\t * wrap it as a message with the given headers, apply the given post processor\n\t * and send the resulting {@link Message} to the specified destination, receive\n\t * the reply and convert its body of the given target class.\n\t * @param destination the target destination\n\t * @param request payload for the request message to send\n\t * @param targetClass the target type to convert the payload of the reply to\n\t * @param requestPostProcessor post process to apply to the request message\n\t * @return the payload of the reply message, possibly {@code null} if the message\n\t * could not be received, for example due to a timeout\n\t */\n\t<T> @Nullable T convertSendAndReceive(\n\t\t\tD destination, Object request, @Nullable Map<String, Object> headers, Class<T> targetClass,\n\t\t\t@Nullable MessagePostProcessor requestPostProcessor) throws MessagingException;\n\n}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractEncoderMethodReturnValueHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Base class for a return value handler that encodes return values to\n * {@code Flux<DataBuffer>} through the configured {@link Encoder}s.\n *\n * <p>Subclasses must implement the abstract method\n * {@link #handleEncodedContent} to handle the resulting encoded content.\n *\n * <p>This handler should be ordered last since its {@link #supportsReturnType}\n * returns {@code true} for any method parameter type.\n *\n * @author Rossen Stoyanchev\n * @since 5.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public class AbstractEncoderMethodReturnValueHandler",
    "source_code": "public abstract class AbstractEncoderMethodReturnValueHandler implements HandlerMethodReturnValueHandler {\n\n\tprivate static final ResolvableType VOID_RESOLVABLE_TYPE = ResolvableType.forClass(Void.class);\n\n\tprivate static final ResolvableType OBJECT_RESOLVABLE_TYPE = ResolvableType.forClass(Object.class);\n\n\tprivate static final String COROUTINES_FLOW_CLASS_NAME = \"kotlinx.coroutines.flow.Flow\";\n\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate final List<Encoder<?>> encoders;\n\n\tprivate final ReactiveAdapterRegistry adapterRegistry;\n\n\n\tprotected AbstractEncoderMethodReturnValueHandler(List<Encoder<?>> encoders, ReactiveAdapterRegistry registry) {\n\t\tAssert.notEmpty(encoders, \"At least one Encoder is required\");\n\t\tAssert.notNull(registry, \"ReactiveAdapterRegistry is required\");\n\t\tthis.encoders = Collections.unmodifiableList(encoders);\n\t\tthis.adapterRegistry = registry;\n\t}\n\n\n\t/**\n\t * The configured encoders.\n\t */\n\tpublic List<Encoder<?>> getEncoders() {\n\t\treturn this.encoders;\n\t}\n\n\t/**\n\t * The configured adapter registry.\n\t */\n\tpublic ReactiveAdapterRegistry getAdapterRegistry() {\n\t\treturn this.adapterRegistry;\n\t}\n\n\n\t@Override\n\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\t// We could check canEncode but we're probably last in order anyway\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic Mono<Void> handleReturnValue(\n\t\t\t@Nullable Object returnValue, MethodParameter returnType, Message<?> message) {\n\n\t\tif (returnValue == null) {\n\t\t\treturn handleNoContent(returnType, message);\n\t\t}\n\n\t\tDataBufferFactory bufferFactory = (DataBufferFactory) message.getHeaders()\n\t\t\t\t.getOrDefault(HandlerMethodReturnValueHandler.DATA_BUFFER_FACTORY_HEADER,\n\t\t\t\t\t\tDefaultDataBufferFactory.sharedInstance);\n\n\t\tMimeType mimeType = (MimeType) message.getHeaders().get(MessageHeaders.CONTENT_TYPE);\n\t\tFlux<DataBuffer> encodedContent = encodeContent(\n\t\t\t\treturnValue, returnType, bufferFactory, mimeType, Collections.emptyMap());\n\n\t\treturn new ChannelSendOperator<>(encodedContent, publisher ->\n\t\t\t\thandleEncodedContent(Flux.from(publisher), returnType, message));\n\t}\n\n\tprivate Flux<DataBuffer> encodeContent(\n\t\t\t@Nullable Object content, MethodParameter returnType, DataBufferFactory bufferFactory,\n\t\t\t@Nullable MimeType mimeType, Map<String, Object> hints) {\n\n\t\tResolvableType returnValueType = ResolvableType.forMethodParameter(returnType);\n\t\tReactiveAdapter adapter = getAdapterRegistry().getAdapter(returnValueType.resolve(), content);\n\n\t\tPublisher<?> publisher;\n\t\tResolvableType elementType;\n\t\tif (adapter != null) {\n\t\t\tpublisher = adapter.toPublisher(content);\n\t\t\tMethod method = returnType.getMethod();\n\t\t\tboolean isUnwrapped = (method != null && KotlinDetector.isSuspendingFunction(method) &&\n\t\t\t\t\t!COROUTINES_FLOW_CLASS_NAME.equals(returnValueType.toClass().getName()));\n\t\t\tResolvableType genericType = (isUnwrapped ? returnValueType : returnValueType.getGeneric());\n\t\t\telementType = getElementType(adapter, genericType);\n\t\t}\n\t\telse {\n\t\t\tpublisher = Mono.justOrEmpty(content);\n\t\t\telementType = (returnValueType.toClass() == Object.class && content != null ?\n\t\t\t\t\tResolvableType.forInstance(content) : returnValueType);\n\t\t}\n\n\t\tif (ClassUtils.isVoidType(elementType.resolve())) {\n\t\t\treturn Flux.from(publisher).cast(DataBuffer.class);\n\t\t}\n\n\t\tEncoder<?> encoder = getEncoder(elementType, mimeType);\n\t\treturn Flux.from(publisher).map(value ->\n\t\t\t\tencodeValue(value, elementType, encoder, bufferFactory, mimeType, hints));\n\t}\n\n\tprivate ResolvableType getElementType(ReactiveAdapter adapter, ResolvableType type) {\n\t\tif (adapter.isNoValue()) {\n\t\t\treturn VOID_RESOLVABLE_TYPE;\n\t\t}\n\t\telse if (type != ResolvableType.NONE) {\n\t\t\treturn type;\n\t\t}\n\t\telse {\n\t\t\treturn OBJECT_RESOLVABLE_TYPE;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate <T> @Nullable Encoder<T> getEncoder(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\tfor (Encoder<?> encoder : getEncoders()) {\n\t\t\tif (encoder.canEncode(elementType, mimeType)) {\n\t\t\t\treturn (Encoder<T>) encoder;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate <T> DataBuffer encodeValue(\n\t\t\tObject element, ResolvableType elementType, @Nullable Encoder<T> encoder,\n\t\t\tDataBufferFactory bufferFactory, @Nullable MimeType mimeType,\n\t\t\t@Nullable Map<String, Object> hints) {\n\n\t\tif (encoder == null) {\n\t\t\tencoder = getEncoder(ResolvableType.forInstance(element), mimeType);\n\t\t\tif (encoder == null) {\n\t\t\t\tthrow new MessagingException(\n\t\t\t\t\t\t\"No encoder for \" + elementType + \", current value type is \" + element.getClass());\n\t\t\t}\n\t\t}\n\t\treturn encoder.encodeValue((T) element, bufferFactory, elementType, mimeType, hints);\n\t}\n\n\t/**\n\t * Subclasses implement this method to handle encoded values in some way\n\t * such as creating and sending messages.\n\t * @param encodedContent the encoded content; each {@code DataBuffer}\n\t * represents the fully-aggregated, encoded content for one value\n\t * (i.e. payload) returned from the HandlerMethod.\n\t * @param returnType return type of the handler method that produced the data\n\t * @param message the input message handled by the handler method\n\t * @return completion {@code Mono<Void>} for the handling\n\t */\n\tprotected abstract Mono<Void> handleEncodedContent(\n\t\t\tFlux<DataBuffer> encodedContent, MethodParameter returnType, Message<?> message);\n\n\t/**\n\t * Invoked for a {@code null} return value, which could mean a void method\n\t * or method returning an async type parameterized by void.\n\t * @param returnType return type of the handler method that produced the data\n\t * @param message the input message handled by the handler method\n\t * @return completion {@code Mono<Void>} for the handling\n\t */\n\tprotected abstract Mono<Void> handleNoContent(MethodParameter returnType, Message<?> message);\n\n}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractEncoderMethodReturnValueHandler#getAdapterRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The configured adapter registry.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "ReactiveAdapterRegistry",
    "signature": "public ReactiveAdapterRegistry getAdapterRegistry()",
    "source_code": "\tpublic ReactiveAdapterRegistry getAdapterRegistry() {\n\t\treturn this.adapterRegistry;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractEncoderMethodReturnValueHandler#handleEncodedContent(encodedContent,returnType,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses implement this method to handle encoded values in some way\n\t * such as creating and sending messages.\n\t * @param encodedContent the encoded content; each {@code DataBuffer}\n\t * represents the fully-aggregated, encoded content for one value\n\t * (i.e. payload) returned from the HandlerMethod.\n\t * @param returnType return type of the handler method that produced the data\n\t * @param message the input message handled by the handler method\n\t * @return completion {@code Mono<Void>} for the handling\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "encodedContent",
      "returnType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> handleEncodedContent(Flux<DataBuffer> encodedContent, MethodParameter returnType, Message<?> message)",
    "source_code": "\tprotected abstract Mono<Void> handleEncodedContent("
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractEncoderMethodReturnValueHandler#handleNoContent(returnType,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked for a {@code null} return value, which could mean a void method\n\t * or method returning an async type parameterized by void.\n\t * @param returnType return type of the handler method that produced the data\n\t * @param message the input message handled by the handler method\n\t * @return completion {@code Mono<Void>} for the handling\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "returnType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> handleNoContent(MethodParameter returnType, Message<?> message)",
    "source_code": "\tprotected abstract Mono<Void> handleNoContent(MethodParameter returnType, Message<?> message);"
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractEncoderMethodReturnValueHandler#handleReturnValue(returnValue,returnType,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)",
    "source_code": "\tpublic Mono<Void> handleReturnValue("
  },
  "org.springframework.messaging.handler.invocation.reactive.AbstractEncoderMethodReturnValueHandler#supportsReturnType(returnType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "boolean",
    "signature": "public boolean supportsReturnType(MethodParameter returnType)",
    "source_code": "\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\t// We could check canEncode but we're probably last in order anyway\n\t\treturn true;\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#connect(transport)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transport"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "Mono<RSocketRequester>",
    "signature": "public Mono<RSocketRequester> connect(ClientTransport transport)",
    "source_code": "\tpublic Mono<RSocketRequester> connect(ClientTransport transport) {\n\t\tRSocketStrategies rsocketStrategies = getRSocketStrategies();\n\t\tMimeType metaMimeType = getMetadataMimeType();\n\t\tMimeType dataMimeType = getDataMimeType(rsocketStrategies);\n\n\t\tRSocketConnector connector = initConnector(\n\t\t\t\tthis.rsocketConnectorConfigurers, metaMimeType, dataMimeType, rsocketStrategies);\n\n\t\treturn connector.connect(transport).map(rsocket ->\n\t\t\t\tnew DefaultRSocketRequester(null, rsocket, dataMimeType, metaMimeType, rsocketStrategies));\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#connectTcp(host,port)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "host",
      "port"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "Mono<RSocketRequester>",
    "signature": "public Mono<RSocketRequester> connectTcp(String host, int port)",
    "source_code": "\tpublic Mono<RSocketRequester> connectTcp(String host, int port) {\n\t\treturn connect(TcpClientTransport.create(host, port));\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#connectWebSocket(uri)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "Mono<RSocketRequester>",
    "signature": "public Mono<RSocketRequester> connectWebSocket(URI uri)",
    "source_code": "\tpublic Mono<RSocketRequester> connectWebSocket(URI uri) {\n\t\treturn connect(WebsocketClientTransport.create(uri));\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#getMetadataMimeType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "MimeType",
    "signature": "public MimeType getMetadataMimeType()",
    "source_code": "\tpublic MimeType getMetadataMimeType() {\n\t\treturn this.metadataMimeType != null ? this.metadataMimeType :\n\t\t\t\tMimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_COMPOSITE_METADATA.getString());\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#tcp(host,port)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "host",
      "port"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "RSocketRequester",
    "signature": "public RSocketRequester tcp(String host, int port)",
    "source_code": "\tpublic RSocketRequester tcp(String host, int port) {\n\t\treturn transport(TcpClientTransport.create(host, port));\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#transport(transport)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transport"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "RSocketRequester",
    "signature": "public RSocketRequester transport(ClientTransport transport)",
    "source_code": "\tpublic RSocketRequester transport(ClientTransport transport) {\n\t\tRSocketStrategies strategies = getRSocketStrategies();\n\t\tMimeType metaMimeType = getMetadataMimeType();\n\t\tMimeType dataMimeType = getDataMimeType(strategies);\n\n\t\tRSocketConnector connector = initConnector(\n\t\t\t\tthis.rsocketConnectorConfigurers, metaMimeType, dataMimeType, strategies);\n\n\t\tRSocketClient client = RSocketClient.from(connector.connect(transport));\n\t\treturn new DefaultRSocketRequester(client, null, dataMimeType, metaMimeType, strategies);\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#transports(targetPublisher,loadbalanceStrategy)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetPublisher",
      "loadbalanceStrategy"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "RSocketRequester",
    "signature": "public RSocketRequester transports(Publisher<List<LoadbalanceTarget>> targetPublisher, LoadbalanceStrategy loadbalanceStrategy)",
    "source_code": "\tpublic RSocketRequester transports("
  },
  "org.springframework.messaging.rsocket.<unknown>#websocket(uri)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "RSocketRequester",
    "signature": "public RSocketRequester websocket(URI uri)",
    "source_code": "\tpublic RSocketRequester websocket(URI uri) {\n\t\treturn transport(WebsocketClientTransport.create(uri));\n\t}"
  },
  "org.springframework.messaging.simp.CONNECT_MESSAGE_HEADER": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "signature": "public String CONNECT_MESSAGE_HEADER",
    "source_code": "\tpublic static final String CONNECT_MESSAGE_HEADER = \"simpConnectMessage\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.DESTINATION_HEADER": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "signature": "public String DESTINATION_HEADER",
    "source_code": "\tpublic static final String DESTINATION_HEADER = \"simpDestination\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.DISCONNECT_MESSAGE_HEADER": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "signature": "public String DISCONNECT_MESSAGE_HEADER",
    "source_code": "\tpublic static final String DISCONNECT_MESSAGE_HEADER = \"simpDisconnectMessage\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.HEART_BEAT_HEADER": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "signature": "public String HEART_BEAT_HEADER",
    "source_code": "\tpublic static final String HEART_BEAT_HEADER = \"simpHeartbeat\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.IGNORE_ERROR": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A header that indicates to the broker that the sender will ignore errors.\n\t * The header is simply checked for presence or absence.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "signature": "public String IGNORE_ERROR",
    "source_code": "\tpublic static final String IGNORE_ERROR = \"simpIgnoreError\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.MESSAGE_TYPE_HEADER": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "signature": "public String MESSAGE_TYPE_HEADER",
    "source_code": "\tpublic static final String MESSAGE_TYPE_HEADER = \"simpMessageType\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.ORIGINAL_DESTINATION": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A header for internal use with \"user\" destinations where we need to\n\t * restore the destination prior to sending messages to clients.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "signature": "public String ORIGINAL_DESTINATION",
    "source_code": "\tpublic static final String ORIGINAL_DESTINATION = \"simpOrigDestination\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.SESSION_ATTRIBUTES": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "signature": "public String SESSION_ATTRIBUTES",
    "source_code": "\tpublic static final String SESSION_ATTRIBUTES = \"simpSessionAttributes\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.SESSION_ID_HEADER": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "signature": "public String SESSION_ID_HEADER",
    "source_code": "\tpublic static final String SESSION_ID_HEADER = \"simpSessionId\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.SUBSCRIPTION_ID_HEADER": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "signature": "public String SUBSCRIPTION_ID_HEADER",
    "source_code": "\tpublic static final String SUBSCRIPTION_ID_HEADER = \"simpSubscriptionId\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A base class for working with message headers in simple messaging protocols that\n * support basic messaging patterns. Provides uniform access to specific values common\n * across protocols such as a destination, message type (for example, publish, subscribe, etc),\n * session ID, and others.\n *\n * <p>Use one of the static factory methods in this class, then call getters and setters,\n * and at the end if necessary call {@link #toMap()} to obtain the updated headers.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public class SimpMessageHeaderAccessor",
    "source_code": "public class SimpMessageHeaderAccessor extends NativeMessageHeaderAccessor {\n\n\tprivate static final IdTimestampMessageHeaderInitializer headerInitializer;\n\n\tstatic {\n\t\theaderInitializer = new IdTimestampMessageHeaderInitializer();\n\t\theaderInitializer.setDisableIdGeneration();\n\t\theaderInitializer.setEnableTimestamp(false);\n\t}\n\n\t// SiMP header names\n\n\tpublic static final String DESTINATION_HEADER = \"simpDestination\";\n\n\tpublic static final String MESSAGE_TYPE_HEADER = \"simpMessageType\";\n\n\tpublic static final String SESSION_ID_HEADER = \"simpSessionId\";\n\n\tpublic static final String SESSION_ATTRIBUTES = \"simpSessionAttributes\";\n\n\tpublic static final String SUBSCRIPTION_ID_HEADER = \"simpSubscriptionId\";\n\n\tpublic static final String USER_HEADER = \"simpUser\";\n\n\tpublic static final String CONNECT_MESSAGE_HEADER = \"simpConnectMessage\";\n\n\tpublic static final String DISCONNECT_MESSAGE_HEADER = \"simpDisconnectMessage\";\n\n\tpublic static final String HEART_BEAT_HEADER = \"simpHeartbeat\";\n\n\n\t/**\n\t * A header for internal use with \"user\" destinations where we need to\n\t * restore the destination prior to sending messages to clients.\n\t */\n\tpublic static final String ORIGINAL_DESTINATION = \"simpOrigDestination\";\n\n\t/**\n\t * A header that indicates to the broker that the sender will ignore errors.\n\t * The header is simply checked for presence or absence.\n\t */\n\tpublic static final String IGNORE_ERROR = \"simpIgnoreError\";\n\n\n\tprivate @Nullable Consumer<Principal> userCallback;\n\n\n\t/**\n\t * A constructor for creating new message headers.\n\t * <p>This constructor is protected. See factory methods in this class\n\t * and subclasses.\n\t */\n\tprotected SimpMessageHeaderAccessor(SimpMessageType messageType,\n\t\t\t@Nullable Map<String, List<String>> externalSourceHeaders) {\n\n\t\tsuper(externalSourceHeaders);\n\t\tAssert.notNull(messageType, \"MessageType must not be null\");\n\t\tsetHeader(MESSAGE_TYPE_HEADER, messageType);\n\t\theaderInitializer.initHeaders(this);\n\t}\n\n\t/**\n\t * A constructor for accessing and modifying existing message headers.\n\t * <p>This constructor is protected. See factory methods in this class\n\t * and subclasses.\n\t */\n\tprotected SimpMessageHeaderAccessor(Message<?> message) {\n\t\tsuper(message);\n\t\theaderInitializer.initHeaders(this);\n\t}\n\n\n\t@Override\n\tprotected MessageHeaderAccessor createAccessor(Message<?> message) {\n\t\treturn wrap(message);\n\t}\n\n\tpublic void setMessageTypeIfNotSet(SimpMessageType messageType) {\n\t\tif (getMessageType() == null) {\n\t\t\tsetHeader(MESSAGE_TYPE_HEADER, messageType);\n\t\t}\n\t}\n\n\tpublic @Nullable SimpMessageType getMessageType() {\n\t\treturn (SimpMessageType) getHeader(MESSAGE_TYPE_HEADER);\n\t}\n\n\tpublic void setDestination(@Nullable String destination) {\n\t\tsetHeader(DESTINATION_HEADER, destination);\n\t}\n\n\tpublic @Nullable String getDestination() {\n\t\treturn (String) getHeader(DESTINATION_HEADER);\n\t}\n\n\tpublic void setSubscriptionId(@Nullable String subscriptionId) {\n\t\tsetHeader(SUBSCRIPTION_ID_HEADER, subscriptionId);\n\t}\n\n\tpublic @Nullable String getSubscriptionId() {\n\t\treturn (String) getHeader(SUBSCRIPTION_ID_HEADER);\n\t}\n\n\tpublic void setSessionId(@Nullable String sessionId) {\n\t\tsetHeader(SESSION_ID_HEADER, sessionId);\n\t}\n\n\t/**\n\t * Return the id of the current session.\n\t */\n\tpublic @Nullable String getSessionId() {\n\t\treturn (String) getHeader(SESSION_ID_HEADER);\n\t}\n\n\t/**\n\t * A static alternative for access to the session attributes header.\n\t */\n\tpublic void setSessionAttributes(@Nullable Map<String, Object> attributes) {\n\t\tsetHeader(SESSION_ATTRIBUTES, attributes);\n\t}\n\n\t/**\n\t * Return the attributes associated with the current session.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic @Nullable Map<String, Object> getSessionAttributes() {\n\t\treturn (Map<String, Object>) getHeader(SESSION_ATTRIBUTES);\n\t}\n\n\tpublic void setUser(@Nullable Principal principal) {\n\t\tsetHeader(USER_HEADER, principal);\n\t\tif (this.userCallback != null) {\n\t\t\tthis.userCallback.accept(principal);\n\t\t}\n\t}\n\n\t/**\n\t * Return the user associated with the current session.\n\t */\n\tpublic @Nullable Principal getUser() {\n\t\treturn (Principal) getHeader(USER_HEADER);\n\t}\n\n\t/**\n\t * Provide a callback to be invoked if and when {@link #setUser(Principal)}\n\t * is called. This is used internally on the inbound channel to detect\n\t * token-based authentications through an interceptor.\n\t * @param callback the callback to invoke\n\t * @since 5.1.9\n\t */\n\tpublic void setUserChangeCallback(Consumer<Principal> callback) {\n\t\tAssert.notNull(callback, \"'callback' is required\");\n\t\tthis.userCallback = this.userCallback != null ? this.userCallback.andThen(callback) : callback;\n\t}\n\n\t@Override\n\tpublic String getShortLogMessage(Object payload) {\n\t\tif (getMessageType() == null) {\n\t\t\treturn super.getDetailedLogMessage(payload);\n\t\t}\n\t\tStringBuilder sb = getBaseLogMessage();\n\t\tif (!CollectionUtils.isEmpty(getSessionAttributes())) {\n\t\t\tsb.append(\" attributes[\").append(getSessionAttributes().size()).append(']');\n\t\t}\n\t\tsb.append(getShortPayloadLogMessage(payload));\n\t\treturn sb.toString();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic String getDetailedLogMessage(@Nullable Object payload) {\n\t\tif (getMessageType() == null) {\n\t\t\treturn super.getDetailedLogMessage(payload);\n\t\t}\n\t\tStringBuilder sb = getBaseLogMessage();\n\t\tif (!CollectionUtils.isEmpty(getSessionAttributes())) {\n\t\t\tsb.append(\" attributes=\").append(getSessionAttributes());\n\t\t}\n\t\tif (!CollectionUtils.isEmpty((Map<String, List<String>>) getHeader(NATIVE_HEADERS))) {\n\t\t\tsb.append(\" nativeHeaders=\").append(getHeader(NATIVE_HEADERS));\n\t\t}\n\t\tsb.append(getDetailedPayloadLogMessage(payload));\n\t\treturn sb.toString();\n\t}\n\n\tprivate StringBuilder getBaseLogMessage() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tSimpMessageType messageType = getMessageType();\n\t\tsb.append(messageType != null ? messageType.name() : SimpMessageType.OTHER);\n\t\tString destination = getDestination();\n\t\tif (destination != null) {\n\t\t\tsb.append(\" destination=\").append(destination);\n\t\t}\n\t\tString subscriptionId = getSubscriptionId();\n\t\tif (subscriptionId != null) {\n\t\t\tsb.append(\" subscriptionId=\").append(subscriptionId);\n\t\t}\n\t\tsb.append(\" session=\").append(getSessionId());\n\t\tPrincipal user = getUser();\n\t\tif (user != null) {\n\t\t\tsb.append(\" user=\").append(user.getName());\n\t\t}\n\t\treturn sb;\n\t}\n\n\n\t// Static factory methods and accessors\n\n\t/**\n\t * Create an instance with\n\t * {@link org.springframework.messaging.simp.SimpMessageType} {@code MESSAGE}.\n\t */\n\tpublic static SimpMessageHeaderAccessor create() {\n\t\treturn new SimpMessageHeaderAccessor(SimpMessageType.MESSAGE, null);\n\t}\n\n\t/**\n\t * Create an instance with the given\n\t * {@link org.springframework.messaging.simp.SimpMessageType}.\n\t */\n\tpublic static SimpMessageHeaderAccessor create(SimpMessageType messageType) {\n\t\treturn new SimpMessageHeaderAccessor(messageType, null);\n\t}\n\n\t/**\n\t * Create an instance by copying the headers of a Message.\n\t */\n\tpublic static SimpMessageHeaderAccessor wrap(Message<?> message) {\n\t\treturn new SimpMessageHeaderAccessor(message);\n\t}\n\n\tpublic static @Nullable SimpMessageType getMessageType(Map<String, Object> headers) {\n\t\treturn (SimpMessageType) headers.get(MESSAGE_TYPE_HEADER);\n\t}\n\n\tpublic static @Nullable String getDestination(Map<String, Object> headers) {\n\t\treturn (String) headers.get(DESTINATION_HEADER);\n\t}\n\n\tpublic static @Nullable String getSubscriptionId(Map<String, Object> headers) {\n\t\treturn (String) headers.get(SUBSCRIPTION_ID_HEADER);\n\t}\n\n\tpublic static @Nullable String getSessionId(Map<String, Object> headers) {\n\t\treturn (String) headers.get(SESSION_ID_HEADER);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static @Nullable Map<String, Object> getSessionAttributes(Map<String, Object> headers) {\n\t\treturn (Map<String, Object>) headers.get(SESSION_ATTRIBUTES);\n\t}\n\n\tpublic static @Nullable Principal getUser(Map<String, Object> headers) {\n\t\treturn (Principal) headers.get(USER_HEADER);\n\t}\n\n\tpublic static long @Nullable [] getHeartbeat(Map<String, Object> headers) {\n\t\treturn (long[]) headers.get(HEART_BEAT_HEADER);\n\t}\n\n}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#create()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance with\n\t * {@link org.springframework.messaging.simp.SimpMessageType} {@code MESSAGE}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "SimpMessageHeaderAccessor",
    "signature": "public SimpMessageHeaderAccessor create()",
    "source_code": "\tpublic static SimpMessageHeaderAccessor create() {\n\t\treturn new SimpMessageHeaderAccessor(SimpMessageType.MESSAGE, null);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#create(messageType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance with the given\n\t * {@link org.springframework.messaging.simp.SimpMessageType}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageType"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "SimpMessageHeaderAccessor",
    "signature": "public SimpMessageHeaderAccessor create(SimpMessageType messageType)",
    "source_code": "\tpublic static SimpMessageHeaderAccessor create(SimpMessageType messageType) {\n\t\treturn new SimpMessageHeaderAccessor(messageType, null);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#createAccessor(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "MessageHeaderAccessor",
    "signature": "protected MessageHeaderAccessor createAccessor(Message<?> message)",
    "source_code": "\tprotected MessageHeaderAccessor createAccessor(Message<?> message) {\n\t\treturn wrap(message);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#getDestination()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "String",
    "signature": "public String getDestination()",
    "source_code": "\tpublic @Nullable String getDestination() {\n\t\treturn (String) getHeader(DESTINATION_HEADER);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#getDestination(Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "String",
    "signature": "public String getDestination(Map<String, Object> headers)",
    "source_code": "\tpublic static @Nullable String getDestination(Map<String, Object> headers) {\n\t\treturn (String) headers.get(DESTINATION_HEADER);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#getDetailedLogMessage(payload)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "String",
    "signature": "public String getDetailedLogMessage(@Nullable Object payload)",
    "source_code": "\tpublic String getDetailedLogMessage(@Nullable Object payload) {\n\t\tif (getMessageType() == null) {\n\t\t\treturn super.getDetailedLogMessage(payload);\n\t\t}\n\t\tStringBuilder sb = getBaseLogMessage();\n\t\tif (!CollectionUtils.isEmpty(getSessionAttributes())) {\n\t\t\tsb.append(\" attributes=\").append(getSessionAttributes());\n\t\t}\n\t\tif (!CollectionUtils.isEmpty((Map<String, List<String>>) getHeader(NATIVE_HEADERS))) {\n\t\t\tsb.append(\" nativeHeaders=\").append(getHeader(NATIVE_HEADERS));\n\t\t}\n\t\tsb.append(getDetailedPayloadLogMessage(payload));\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#getMessageType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "SimpMessageType",
    "signature": "public SimpMessageType getMessageType()",
    "source_code": "\tpublic @Nullable SimpMessageType getMessageType() {\n\t\treturn (SimpMessageType) getHeader(MESSAGE_TYPE_HEADER);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#getMessageType(Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "SimpMessageType",
    "signature": "public SimpMessageType getMessageType(Map<String, Object> headers)",
    "source_code": "\tpublic static @Nullable SimpMessageType getMessageType(Map<String, Object> headers) {\n\t\treturn (SimpMessageType) headers.get(MESSAGE_TYPE_HEADER);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#getSessionAttributes()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the attributes associated with the current session.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "Object>",
    "signature": "public Object> getSessionAttributes()",
    "source_code": "\tpublic @Nullable Map<String, Object> getSessionAttributes() {\n\t\treturn (Map<String, Object>) getHeader(SESSION_ATTRIBUTES);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#getSessionAttributes(Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "Object>",
    "signature": "public Object> getSessionAttributes(Map<String, Object> headers)",
    "source_code": "\tpublic static @Nullable Map<String, Object> getSessionAttributes(Map<String, Object> headers) {\n\t\treturn (Map<String, Object>) headers.get(SESSION_ATTRIBUTES);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#getSessionId()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the id of the current session.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "String",
    "signature": "public String getSessionId()",
    "source_code": "\tpublic @Nullable String getSessionId() {\n\t\treturn (String) getHeader(SESSION_ID_HEADER);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#getSessionId(Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "String",
    "signature": "public String getSessionId(Map<String, Object> headers)",
    "source_code": "\tpublic static @Nullable String getSessionId(Map<String, Object> headers) {\n\t\treturn (String) headers.get(SESSION_ID_HEADER);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#getShortLogMessage(payload)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "String",
    "signature": "public String getShortLogMessage(Object payload)",
    "source_code": "\tpublic String getShortLogMessage(Object payload) {\n\t\tif (getMessageType() == null) {\n\t\t\treturn super.getDetailedLogMessage(payload);\n\t\t}\n\t\tStringBuilder sb = getBaseLogMessage();\n\t\tif (!CollectionUtils.isEmpty(getSessionAttributes())) {\n\t\t\tsb.append(\" attributes[\").append(getSessionAttributes().size()).append(']');\n\t\t}\n\t\tsb.append(getShortPayloadLogMessage(payload));\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#getSubscriptionId()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "String",
    "signature": "public String getSubscriptionId()",
    "source_code": "\tpublic @Nullable String getSubscriptionId() {\n\t\treturn (String) getHeader(SUBSCRIPTION_ID_HEADER);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#getSubscriptionId(Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "String",
    "signature": "public String getSubscriptionId(Map<String, Object> headers)",
    "source_code": "\tpublic static @Nullable String getSubscriptionId(Map<String, Object> headers) {\n\t\treturn (String) headers.get(SUBSCRIPTION_ID_HEADER);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#getUser()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the user associated with the current session.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "Principal",
    "signature": "public Principal getUser()",
    "source_code": "\tpublic @Nullable Principal getUser() {\n\t\treturn (Principal) getHeader(USER_HEADER);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#getUser(Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "Principal",
    "signature": "public Principal getUser(Map<String, Object> headers)",
    "source_code": "\tpublic static @Nullable Principal getUser(Map<String, Object> headers) {\n\t\treturn (Principal) headers.get(USER_HEADER);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#setDestination(destination)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void setDestination(@Nullable String destination)",
    "source_code": "\tpublic void setDestination(@Nullable String destination) {\n\t\tsetHeader(DESTINATION_HEADER, destination);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#setMessageTypeIfNotSet(messageType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageType"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void setMessageTypeIfNotSet(SimpMessageType messageType)",
    "source_code": "\tpublic void setMessageTypeIfNotSet(SimpMessageType messageType) {\n\t\tif (getMessageType() == null) {\n\t\t\tsetHeader(MESSAGE_TYPE_HEADER, messageType);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#setSessionAttributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A static alternative for access to the session attributes header.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void setSessionAttributes(@Nullable Map<String, Object> attributes)",
    "source_code": "\tpublic void setSessionAttributes(@Nullable Map<String, Object> attributes) {\n\t\tsetHeader(SESSION_ATTRIBUTES, attributes);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#setSessionId(sessionId)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void setSessionId(@Nullable String sessionId)",
    "source_code": "\tpublic void setSessionId(@Nullable String sessionId) {\n\t\tsetHeader(SESSION_ID_HEADER, sessionId);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#setSubscriptionId(subscriptionId)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subscriptionId"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "public void setSubscriptionId(@Nullable String subscriptionId)",
    "source_code": "\tpublic void setSubscriptionId(@Nullable String subscriptionId) {\n\t\tsetHeader(SUBSCRIPTION_ID_HEADER, subscriptionId);\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#setUser(principal)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "principal"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "void",
    "signature": "public void setUser(@Nullable Principal principal)",
    "source_code": "\tpublic void setUser(@Nullable Principal principal) {\n\t\tsetHeader(USER_HEADER, principal);\n\t\tif (this.userCallback != null) {\n\t\t\tthis.userCallback.accept(principal);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#setUserChangeCallback(callback)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a callback to be invoked if and when {@link #setUser(Principal)}\n\t * is called. This is used internally on the inbound channel to detect\n\t * token-based authentications through an interceptor.\n\t * @param callback the callback to invoke\n\t * @since 5.1.9\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "void",
    "signature": "public void setUserChangeCallback(Consumer<Principal> callback)",
    "source_code": "\tpublic void setUserChangeCallback(Consumer<Principal> callback) {\n\t\tAssert.notNull(callback, \"'callback' is required\");\n\t\tthis.userCallback = this.userCallback != null ? this.userCallback.andThen(callback) : callback;\n\t}"
  },
  "org.springframework.messaging.simp.SimpMessageHeaderAccessor#wrap(message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance by copying the headers of a Message.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "SimpMessageHeaderAccessor",
    "signature": "public SimpMessageHeaderAccessor wrap(Message<?> message)",
    "source_code": "\tpublic static SimpMessageHeaderAccessor wrap(Message<?> message) {\n\t\treturn new SimpMessageHeaderAccessor(message);\n\t}"
  },
  "org.springframework.messaging.simp.USER_HEADER": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "signature": "public String USER_HEADER",
    "source_code": "\tpublic static final String USER_HEADER = \"simpUser\";",
    "type": "String"
  },
  "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#getHeartbeatValue()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * The configured value for the heart-beat settings.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "long[]",
    "signature": "public long[] getHeartbeatValue()",
    "source_code": "\tpublic long[] getHeartbeatValue() {\n\t\treturn this.heartbeatValue;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractBrokerRegistration": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Base class for message broker registration classes.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class AbstractBrokerRegistration",
    "source_code": "public abstract class AbstractBrokerRegistration {\n\n\tprivate final SubscribableChannel clientInboundChannel;\n\n\tprivate final MessageChannel clientOutboundChannel;\n\n\tprivate final List<String> destinationPrefixes;\n\n\n\t/**\n\t * Create a new broker registration.\n\t * @param clientInboundChannel the inbound channel\n\t * @param clientOutboundChannel the outbound channel\n\t * @param destinationPrefixes the destination prefixes\n\t */\n\tpublic AbstractBrokerRegistration(SubscribableChannel clientInboundChannel,\n\t\t\tMessageChannel clientOutboundChannel, String @Nullable [] destinationPrefixes) {\n\n\t\tAssert.notNull(clientInboundChannel, \"'clientInboundChannel' must not be null\");\n\t\tAssert.notNull(clientOutboundChannel, \"'clientOutboundChannel' must not be null\");\n\n\t\tthis.clientInboundChannel = clientInboundChannel;\n\t\tthis.clientOutboundChannel = clientOutboundChannel;\n\n\t\tthis.destinationPrefixes = (destinationPrefixes != null ?\n\t\t\t\tArrays.asList(destinationPrefixes) : Collections.emptyList());\n\t}\n\n\n\tprotected SubscribableChannel getClientInboundChannel() {\n\t\treturn this.clientInboundChannel;\n\t}\n\n\tprotected MessageChannel getClientOutboundChannel() {\n\t\treturn this.clientOutboundChannel;\n\t}\n\n\tprotected Collection<String> getDestinationPrefixes() {\n\t\treturn this.destinationPrefixes;\n\t}\n\n\n\tprotected abstract AbstractBrokerMessageHandler getMessageHandler(SubscribableChannel brokerChannel);\n\n}"
  },
  "org.springframework.messaging.simp.config.AbstractBrokerRegistration#getClientInboundChannel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "SubscribableChannel",
    "signature": "protected SubscribableChannel getClientInboundChannel()",
    "source_code": "\tprotected SubscribableChannel getClientInboundChannel() {\n\t\treturn this.clientInboundChannel;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractBrokerRegistration#getClientOutboundChannel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "MessageChannel",
    "signature": "protected MessageChannel getClientOutboundChannel()",
    "source_code": "\tprotected MessageChannel getClientOutboundChannel() {\n\t\treturn this.clientOutboundChannel;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractBrokerRegistration#getDestinationPrefixes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "Collection<String>",
    "signature": "protected Collection<String> getDestinationPrefixes()",
    "source_code": "\tprotected Collection<String> getDestinationPrefixes() {\n\t\treturn this.destinationPrefixes;\n\t}"
  },
  "org.springframework.messaging.simp.config.AbstractBrokerRegistration#getMessageHandler(brokerChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "brokerChannel"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "AbstractBrokerMessageHandler",
    "signature": "protected AbstractBrokerMessageHandler getMessageHandler(SubscribableChannel brokerChannel)",
    "source_code": "\tprotected abstract AbstractBrokerMessageHandler getMessageHandler(SubscribableChannel brokerChannel);"
  },
  "org.springframework.messaging.simp.config.MessageBrokerRegistry": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A registry for configuring message broker options.\n *\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class MessageBrokerRegistry",
    "source_code": "public class MessageBrokerRegistry {\n\n\tprivate final SubscribableChannel clientInboundChannel;\n\n\tprivate final MessageChannel clientOutboundChannel;\n\n\tprivate @Nullable SimpleBrokerRegistration simpleBrokerRegistration;\n\n\tprivate @Nullable StompBrokerRelayRegistration brokerRelayRegistration;\n\n\tprivate final ChannelRegistration brokerChannelRegistration = new ChannelRegistration();\n\n\tprivate String @Nullable [] applicationDestinationPrefixes;\n\n\tprivate @Nullable String userDestinationPrefix;\n\n\tprivate @Nullable Integer userRegistryOrder;\n\n\tprivate @Nullable PathMatcher pathMatcher;\n\n\tprivate @Nullable Integer cacheLimit;\n\n\tprivate boolean preservePublishOrder;\n\n\n\tpublic MessageBrokerRegistry(SubscribableChannel clientInboundChannel, MessageChannel clientOutboundChannel) {\n\t\tAssert.notNull(clientInboundChannel, \"Inbound channel must not be null\");\n\t\tAssert.notNull(clientOutboundChannel, \"Outbound channel must not be null\");\n\t\tthis.clientInboundChannel = clientInboundChannel;\n\t\tthis.clientOutboundChannel = clientOutboundChannel;\n\t}\n\n\n\t/**\n\t * Enable a simple message broker and configure one or more prefixes to filter\n\t * destinations targeting the broker (for example, destinations prefixed with \"/topic\").\n\t */\n\tpublic SimpleBrokerRegistration enableSimpleBroker(String... destinationPrefixes) {\n\t\tthis.simpleBrokerRegistration = new SimpleBrokerRegistration(\n\t\t\t\tthis.clientInboundChannel, this.clientOutboundChannel, destinationPrefixes);\n\t\treturn this.simpleBrokerRegistration;\n\t}\n\n\t/**\n\t * Enable a STOMP broker relay and configure the destination prefixes supported by the\n\t * message broker. Check the STOMP documentation of the message broker for supported\n\t * destinations.\n\t */\n\tpublic StompBrokerRelayRegistration enableStompBrokerRelay(String... destinationPrefixes) {\n\t\tthis.brokerRelayRegistration = new StompBrokerRelayRegistration(\n\t\t\t\tthis.clientInboundChannel, this.clientOutboundChannel, destinationPrefixes);\n\t\treturn this.brokerRelayRegistration;\n\t}\n\n\t/**\n\t * Customize the channel used to send messages from the application to the message\n\t * broker. By default, messages from the application to the message broker are sent\n\t * synchronously, which means application code sending a message will find out\n\t * if the message cannot be sent through an exception. However, this can be changed\n\t * if the broker channel is configured here with task executor properties.\n\t */\n\tpublic ChannelRegistration configureBrokerChannel() {\n\t\treturn this.brokerChannelRegistration;\n\t}\n\n\tprotected ChannelRegistration getBrokerChannelRegistration() {\n\t\treturn this.brokerChannelRegistration;\n\t}\n\n\tprotected @Nullable String getUserDestinationBroadcast() {\n\t\treturn (this.brokerRelayRegistration != null ?\n\t\t\t\tthis.brokerRelayRegistration.getUserDestinationBroadcast() : null);\n\t}\n\n\tprotected @Nullable String getUserRegistryBroadcast() {\n\t\treturn (this.brokerRelayRegistration != null ?\n\t\t\t\tthis.brokerRelayRegistration.getUserRegistryBroadcast() : null);\n\t}\n\n\t/**\n\t * Configure one or more prefixes to filter destinations targeting application\n\t * annotated methods. For example destinations prefixed with \"/app\" may be\n\t * processed by annotated methods while other destinations may target the\n\t * message broker (for example, \"/topic\", \"/queue\").\n\t * <p>When messages are processed, the matching prefix is removed from the destination\n\t * in order to form the lookup path. This means annotations should not contain the\n\t * destination prefix.\n\t * <p>Prefixes that do not have a trailing slash will have one automatically appended.\n\t */\n\tpublic MessageBrokerRegistry setApplicationDestinationPrefixes(String... prefixes) {\n\t\tthis.applicationDestinationPrefixes = prefixes;\n\t\treturn this;\n\t}\n\n\tprotected @Nullable Collection<String> getApplicationDestinationPrefixes() {\n\t\treturn (this.applicationDestinationPrefixes != null ?\n\t\t\t\tArrays.asList(this.applicationDestinationPrefixes) : null);\n\t}\n\n\t/**\n\t * Configure the prefix used to identify user destinations. User destinations\n\t * provide the ability for a user to subscribe to queue names unique to their\n\t * session as well as for others to send messages to those unique,\n\t * user-specific queues.\n\t * <p>For example when a user attempts to subscribe to \"/user/queue/position-updates\",\n\t * the destination may be translated to \"/queue/position-updates-useri9oqdfzo\" yielding a\n\t * unique queue name that does not collide with any other user attempting to do the same.\n\t * Subsequently when messages are sent to \"/user/{username}/queue/position-updates\",\n\t * the destination is translated to \"/queue/position-updates-useri9oqdfzo\".\n\t * <p>The default prefix used to identify such destinations is \"/user/\".\n\t */\n\tpublic MessageBrokerRegistry setUserDestinationPrefix(String destinationPrefix) {\n\t\tthis.userDestinationPrefix = destinationPrefix;\n\t\treturn this;\n\t}\n\n\tprotected @Nullable String getUserDestinationPrefix() {\n\t\treturn this.userDestinationPrefix;\n\t}\n\n\t/**\n\t * Set the order for the\n\t * {@link org.springframework.messaging.simp.user.SimpUserRegistry\n\t * SimpUserRegistry} to use as a {@link SmartApplicationListener}.\n\t * @param order the order value\n\t * @since 5.0.8\n\t */\n\tpublic void setUserRegistryOrder(int order) {\n\t\tthis.userRegistryOrder = order;\n\t}\n\n\tprotected @Nullable Integer getUserRegistryOrder() {\n\t\treturn this.userRegistryOrder;\n\t}\n\n\t/**\n\t * Configure the PathMatcher to use to match the destinations of incoming\n\t * messages to {@code @MessageMapping} and {@code @SubscribeMapping} methods.\n\t * <p>By default {@link org.springframework.util.AntPathMatcher} is configured.\n\t * However applications may provide an {@code AntPathMatcher} instance\n\t * customized to use \".\" (commonly used in messaging) instead of \"/\" as path\n\t * separator or provide a completely different PathMatcher implementation.\n\t * <p>Note that the configured PathMatcher is only used for matching the\n\t * portion of the destination after the configured prefix. For example given\n\t * application destination prefix \"/app\" and destination \"/app/price.stock.**\",\n\t * the message might be mapped to a controller with \"price\" and \"stock.**\"\n\t * as its type and method-level mappings respectively.\n\t * <p>When the simple broker is enabled, the PathMatcher configured here is\n\t * also used to match message destinations when brokering messages.\n\t * @since 4.1\n\t * @see org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry#setPathMatcher\n\t */\n\tpublic MessageBrokerRegistry setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t\treturn this;\n\t}\n\n\tprotected @Nullable PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}\n\n\t/**\n\t * Configure the cache limit to apply for registrations with the broker.\n\t * <p>This is currently only applied for the destination cache in the\n\t * subscription registry. The default cache limit there is 1024.\n\t * @since 4.3.2\n\t * @see org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry#setCacheLimit\n\t */\n\tpublic MessageBrokerRegistry setCacheLimit(int cacheLimit) {\n\t\tthis.cacheLimit = cacheLimit;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Whether the client must receive messages in the order of publication.\n\t * <p>By default messages sent to the {@code \"clientOutboundChannel\"} may\n\t * not be processed in the same order because the channel is backed by a\n\t * ThreadPoolExecutor that in turn does not guarantee processing in order.\n\t * <p>When this flag is set to {@code true} messages within the same session\n\t * will be sent to the {@code \"clientOutboundChannel\"} one at a time in\n\t * order to preserve the order of publication.\n\t * @since 5.1\n\t */\n\tpublic MessageBrokerRegistry setPreservePublishOrder(boolean preservePublishOrder) {\n\t\tthis.preservePublishOrder = preservePublishOrder;\n\t\treturn this;\n\t}\n\n\tprotected @Nullable SimpleBrokerMessageHandler getSimpleBroker(SubscribableChannel brokerChannel) {\n\t\tif (this.simpleBrokerRegistration == null && this.brokerRelayRegistration == null) {\n\t\t\tenableSimpleBroker();\n\t\t}\n\t\tif (this.simpleBrokerRegistration != null) {\n\t\t\tSimpleBrokerMessageHandler handler = this.simpleBrokerRegistration.getMessageHandler(brokerChannel);\n\t\t\thandler.setPathMatcher(this.pathMatcher);\n\t\t\thandler.setCacheLimit(this.cacheLimit);\n\t\t\thandler.setPreservePublishOrder(this.preservePublishOrder);\n\t\t\treturn handler;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected @Nullable StompBrokerRelayMessageHandler getStompBrokerRelay(SubscribableChannel brokerChannel) {\n\t\tif (this.brokerRelayRegistration != null) {\n\t\t\tStompBrokerRelayMessageHandler relay = this.brokerRelayRegistration.getMessageHandler(brokerChannel);\n\t\t\trelay.setPreservePublishOrder(this.preservePublishOrder);\n\t\t\treturn relay;\n\t\t}\n\t\treturn null;\n\t}\n\n}"
  },
  "org.springframework.messaging.simp.config.MessageBrokerRegistry#configureBrokerChannel()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the channel used to send messages from the application to the message\n\t * broker. By default, messages from the application to the message broker are sent\n\t * synchronously, which means application code sending a message will find out\n\t * if the message cannot be sent through an exception. However, this can be changed\n\t * if the broker channel is configured here with task executor properties.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "ChannelRegistration",
    "signature": "public ChannelRegistration configureBrokerChannel()",
    "source_code": "\tpublic ChannelRegistration configureBrokerChannel() {\n\t\treturn this.brokerChannelRegistration;\n\t}"
  },
  "org.springframework.messaging.simp.config.MessageBrokerRegistry#enableSimpleBroker(destinationPrefixes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Enable a simple message broker and configure one or more prefixes to filter\n\t * destinations targeting the broker (for example, destinations prefixed with \"/topic\").\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationPrefixes"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "SimpleBrokerRegistration",
    "signature": "public SimpleBrokerRegistration enableSimpleBroker(String... destinationPrefixes)",
    "source_code": "\tpublic SimpleBrokerRegistration enableSimpleBroker(String... destinationPrefixes) {\n\t\tthis.simpleBrokerRegistration = new SimpleBrokerRegistration(\n\t\t\t\tthis.clientInboundChannel, this.clientOutboundChannel, destinationPrefixes);\n\t\treturn this.simpleBrokerRegistration;\n\t}"
  },
  "org.springframework.messaging.simp.config.MessageBrokerRegistry#enableStompBrokerRelay(destinationPrefixes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Enable a STOMP broker relay and configure the destination prefixes supported by the\n\t * message broker. Check the STOMP documentation of the message broker for supported\n\t * destinations.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationPrefixes"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "StompBrokerRelayRegistration",
    "signature": "public StompBrokerRelayRegistration enableStompBrokerRelay(String... destinationPrefixes)",
    "source_code": "\tpublic StompBrokerRelayRegistration enableStompBrokerRelay(String... destinationPrefixes) {\n\t\tthis.brokerRelayRegistration = new StompBrokerRelayRegistration(\n\t\t\t\tthis.clientInboundChannel, this.clientOutboundChannel, destinationPrefixes);\n\t\treturn this.brokerRelayRegistration;\n\t}"
  },
  "org.springframework.messaging.simp.config.MessageBrokerRegistry#getApplicationDestinationPrefixes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "Collection<String>",
    "signature": "protected Collection<String> getApplicationDestinationPrefixes()",
    "source_code": "\tprotected @Nullable Collection<String> getApplicationDestinationPrefixes() {\n\t\treturn (this.applicationDestinationPrefixes != null ?\n\t\t\t\tArrays.asList(this.applicationDestinationPrefixes) : null);\n\t}"
  },
  "org.springframework.messaging.simp.config.MessageBrokerRegistry#getBrokerChannelRegistration()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "ChannelRegistration",
    "signature": "protected ChannelRegistration getBrokerChannelRegistration()",
    "source_code": "\tprotected ChannelRegistration getBrokerChannelRegistration() {\n\t\treturn this.brokerChannelRegistration;\n\t}"
  },
  "org.springframework.messaging.simp.config.MessageBrokerRegistry#getPathMatcher()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "PathMatcher",
    "signature": "protected PathMatcher getPathMatcher()",
    "source_code": "\tprotected @Nullable PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}"
  },
  "org.springframework.messaging.simp.config.MessageBrokerRegistry#getSimpleBroker(brokerChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "brokerChannel"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "SimpleBrokerMessageHandler",
    "signature": "protected SimpleBrokerMessageHandler getSimpleBroker(SubscribableChannel brokerChannel)",
    "source_code": "\tprotected @Nullable SimpleBrokerMessageHandler getSimpleBroker(SubscribableChannel brokerChannel) {\n\t\tif (this.simpleBrokerRegistration == null && this.brokerRelayRegistration == null) {\n\t\t\tenableSimpleBroker();\n\t\t}\n\t\tif (this.simpleBrokerRegistration != null) {\n\t\t\tSimpleBrokerMessageHandler handler = this.simpleBrokerRegistration.getMessageHandler(brokerChannel);\n\t\t\thandler.setPathMatcher(this.pathMatcher);\n\t\t\thandler.setCacheLimit(this.cacheLimit);\n\t\t\thandler.setPreservePublishOrder(this.preservePublishOrder);\n\t\t\treturn handler;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.simp.config.MessageBrokerRegistry#getStompBrokerRelay(brokerChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "brokerChannel"
    ],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "StompBrokerRelayMessageHandler",
    "signature": "protected StompBrokerRelayMessageHandler getStompBrokerRelay(SubscribableChannel brokerChannel)",
    "source_code": "\tprotected @Nullable StompBrokerRelayMessageHandler getStompBrokerRelay(SubscribableChannel brokerChannel) {\n\t\tif (this.brokerRelayRegistration != null) {\n\t\t\tStompBrokerRelayMessageHandler relay = this.brokerRelayRegistration.getMessageHandler(brokerChannel);\n\t\t\trelay.setPreservePublishOrder(this.preservePublishOrder);\n\t\t\treturn relay;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.simp.config.MessageBrokerRegistry#getUserDestinationBroadcast()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "String",
    "signature": "protected String getUserDestinationBroadcast()",
    "source_code": "\tprotected @Nullable String getUserDestinationBroadcast() {\n\t\treturn (this.brokerRelayRegistration != null ?\n\t\t\t\tthis.brokerRelayRegistration.getUserDestinationBroadcast() : null);\n\t}"
  },
  "org.springframework.messaging.simp.config.MessageBrokerRegistry#getUserDestinationPrefix()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "String",
    "signature": "protected String getUserDestinationPrefix()",
    "source_code": "\tprotected @Nullable String getUserDestinationPrefix() {\n\t\treturn this.userDestinationPrefix;\n\t}"
  },
  "org.springframework.messaging.simp.config.MessageBrokerRegistry#getUserRegistryBroadcast()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "String",
    "signature": "protected String getUserRegistryBroadcast()",
    "source_code": "\tprotected @Nullable String getUserRegistryBroadcast() {\n\t\treturn (this.brokerRelayRegistration != null ?\n\t\t\t\tthis.brokerRelayRegistration.getUserRegistryBroadcast() : null);\n\t}"
  },
  "org.springframework.messaging.simp.config.MessageBrokerRegistry#getUserRegistryOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "Integer",
    "signature": "protected Integer getUserRegistryOrder()",
    "source_code": "\tprotected @Nullable Integer getUserRegistryOrder() {\n\t\treturn this.userRegistryOrder;\n\t}"
  },
  "org.springframework.messaging.simp.config.MessageBrokerRegistry#setApplicationDestinationPrefixes(prefixes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure one or more prefixes to filter destinations targeting application\n\t * annotated methods. For example destinations prefixed with \"/app\" may be\n\t * processed by annotated methods while other destinations may target the\n\t * message broker (for example, \"/topic\", \"/queue\").\n\t * <p>When messages are processed, the matching prefix is removed from the destination\n\t * in order to form the lookup path. This means annotations should not contain the\n\t * destination prefix.\n\t * <p>Prefixes that do not have a trailing slash will have one automatically appended.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "prefixes"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "MessageBrokerRegistry",
    "signature": "public MessageBrokerRegistry setApplicationDestinationPrefixes(String... prefixes)",
    "source_code": "\tpublic MessageBrokerRegistry setApplicationDestinationPrefixes(String... prefixes) {\n\t\tthis.applicationDestinationPrefixes = prefixes;\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.simp.config.MessageBrokerRegistry#setCacheLimit(cacheLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the cache limit to apply for registrations with the broker.\n\t * <p>This is currently only applied for the destination cache in the\n\t * subscription registry. The default cache limit there is 1024.\n\t * @since 4.3.2\n\t * @see org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry#setCacheLimit\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheLimit"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "MessageBrokerRegistry",
    "signature": "public MessageBrokerRegistry setCacheLimit(int cacheLimit)",
    "source_code": "\tpublic MessageBrokerRegistry setCacheLimit(int cacheLimit) {\n\t\tthis.cacheLimit = cacheLimit;\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.simp.config.MessageBrokerRegistry#setPathMatcher(pathMatcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the PathMatcher to use to match the destinations of incoming\n\t * messages to {@code @MessageMapping} and {@code @SubscribeMapping} methods.\n\t * <p>By default {@link org.springframework.util.AntPathMatcher} is configured.\n\t * However applications may provide an {@code AntPathMatcher} instance\n\t * customized to use \".\" (commonly used in messaging) instead of \"/\" as path\n\t * separator or provide a completely different PathMatcher implementation.\n\t * <p>Note that the configured PathMatcher is only used for matching the\n\t * portion of the destination after the configured prefix. For example given\n\t * application destination prefix \"/app\" and destination \"/app/price.stock.**\",\n\t * the message might be mapped to a controller with \"price\" and \"stock.**\"\n\t * as its type and method-level mappings respectively.\n\t * <p>When the simple broker is enabled, the PathMatcher configured here is\n\t * also used to match message destinations when brokering messages.\n\t * @since 4.1\n\t * @see org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry#setPathMatcher\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathMatcher"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "MessageBrokerRegistry",
    "signature": "public MessageBrokerRegistry setPathMatcher(PathMatcher pathMatcher)",
    "source_code": "\tpublic MessageBrokerRegistry setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.simp.config.MessageBrokerRegistry#setPreservePublishOrder(preservePublishOrder)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the client must receive messages in the order of publication.\n\t * <p>By default messages sent to the {@code \"clientOutboundChannel\"} may\n\t * not be processed in the same order because the channel is backed by a\n\t * ThreadPoolExecutor that in turn does not guarantee processing in order.\n\t * <p>When this flag is set to {@code true} messages within the same session\n\t * will be sent to the {@code \"clientOutboundChannel\"} one at a time in\n\t * order to preserve the order of publication.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "preservePublishOrder"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "MessageBrokerRegistry",
    "signature": "public MessageBrokerRegistry setPreservePublishOrder(boolean preservePublishOrder)",
    "source_code": "\tpublic MessageBrokerRegistry setPreservePublishOrder(boolean preservePublishOrder) {\n\t\tthis.preservePublishOrder = preservePublishOrder;\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.simp.config.MessageBrokerRegistry#setUserDestinationPrefix(destinationPrefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the prefix used to identify user destinations. User destinations\n\t * provide the ability for a user to subscribe to queue names unique to their\n\t * session as well as for others to send messages to those unique,\n\t * user-specific queues.\n\t * <p>For example when a user attempts to subscribe to \"/user/queue/position-updates\",\n\t * the destination may be translated to \"/queue/position-updates-useri9oqdfzo\" yielding a\n\t * unique queue name that does not collide with any other user attempting to do the same.\n\t * Subsequently when messages are sent to \"/user/{username}/queue/position-updates\",\n\t * the destination is translated to \"/queue/position-updates-useri9oqdfzo\".\n\t * <p>The default prefix used to identify such destinations is \"/user/\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationPrefix"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "MessageBrokerRegistry",
    "signature": "public MessageBrokerRegistry setUserDestinationPrefix(String destinationPrefix)",
    "source_code": "\tpublic MessageBrokerRegistry setUserDestinationPrefix(String destinationPrefix) {\n\t\tthis.userDestinationPrefix = destinationPrefix;\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.simp.config.MessageBrokerRegistry#setUserRegistryOrder(order)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the order for the\n\t * {@link org.springframework.messaging.simp.user.SimpUserRegistry\n\t * SimpUserRegistry} to use as a {@link SmartApplicationListener}.\n\t * @param order the order value\n\t * @since 5.0.8\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "order"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "void",
    "signature": "public void setUserRegistryOrder(int order)",
    "source_code": "\tpublic void setUserRegistryOrder(int order) {\n\t\tthis.userRegistryOrder = order;\n\t}"
  },
  "org.springframework.messaging.simp.config.SimpleBrokerRegistration": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Registration class for configuring a {@link SimpleBrokerMessageHandler}.\n *\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 33
    },
    "signature": "public class SimpleBrokerRegistration",
    "source_code": "public class SimpleBrokerRegistration extends AbstractBrokerRegistration {\n\n\tprivate @Nullable TaskScheduler taskScheduler;\n\n\tprivate long @Nullable [] heartbeat;\n\n\tprivate @Nullable String selectorHeaderName;\n\n\n\t/**\n\t * Create a new {@code SimpleBrokerRegistration}.\n\t * @param clientInboundChannel the inbound channel\n\t * @param clientOutboundChannel the outbound channel\n\t * @param destinationPrefixes the destination prefixes\n\t */\n\tpublic SimpleBrokerRegistration(SubscribableChannel clientInboundChannel,\n\t\t\tMessageChannel clientOutboundChannel, String[] destinationPrefixes) {\n\n\t\tsuper(clientInboundChannel, clientOutboundChannel, destinationPrefixes);\n\t}\n\n\n\t/**\n\t * Configure the {@link org.springframework.scheduling.TaskScheduler} to\n\t * use for providing heartbeat support. Setting this property also sets the\n\t * {@link #setHeartbeatValue heartbeatValue} to \"10000, 10000\".\n\t * <p>By default this is not set.\n\t * @since 4.2\n\t */\n\tpublic SimpleBrokerRegistration setTaskScheduler(TaskScheduler taskScheduler) {\n\t\tthis.taskScheduler = taskScheduler;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configure the value for the heartbeat settings. The first number\n\t * represents how often the server will write or send a heartbeat.\n\t * The second is how often the client should write. 0 means no heartbeats.\n\t * <p>By default this is set to \"0, 0\" unless the {@link #setTaskScheduler\n\t * taskScheduler} in which case the default becomes \"10000,10000\"\n\t * (in milliseconds).\n\t * @since 4.2\n\t */\n\tpublic SimpleBrokerRegistration setHeartbeatValue(long[] heartbeat) {\n\t\tthis.heartbeat = heartbeat;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configure the name of a header that a subscription message can have for\n\t * the purpose of filtering messages matched to the subscription.\n\t * <p>The header value is expected to be a Spring Expression Language (SpEL)\n\t * boolean expression to be applied to the headers of messages matched to the\n\t * subscription.\n\t * <p>For example:\n\t * <pre style=\"code\">\n\t * headers.foo == 'bar'\n\t * </pre>\n\t * <p>By default the selector header name is set to {@code null} which disables\n\t * this feature. You can set it to {@code \"selector\"} or a different name to\n\t * enable support for a selector header.\n\t * @param selectorHeaderName the name to use for a selector header, or {@code null}\n\t * or blank to disable selector header support\n\t * @since 4.3.17\n\t */\n\tpublic void setSelectorHeaderName(@Nullable String selectorHeaderName) {\n\t\tthis.selectorHeaderName = selectorHeaderName;\n\t}\n\n\n\t@Override\n\tprotected SimpleBrokerMessageHandler getMessageHandler(SubscribableChannel brokerChannel) {\n\t\tSimpleBrokerMessageHandler handler = new SimpleBrokerMessageHandler(getClientInboundChannel(),\n\t\t\t\tgetClientOutboundChannel(), brokerChannel, getDestinationPrefixes());\n\t\tif (this.taskScheduler != null) {\n\t\t\thandler.setTaskScheduler(this.taskScheduler);\n\t\t}\n\t\tif (this.heartbeat != null) {\n\t\t\thandler.setHeartbeatValue(this.heartbeat);\n\t\t}\n\t\thandler.setSelectorHeaderName(this.selectorHeaderName);\n\t\treturn handler;\n\t}\n\n}"
  },
  "org.springframework.messaging.simp.config.SimpleBrokerRegistration#getMessageHandler(brokerChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "brokerChannel"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "SimpleBrokerMessageHandler",
    "signature": "protected SimpleBrokerMessageHandler getMessageHandler(SubscribableChannel brokerChannel)",
    "source_code": "\tprotected SimpleBrokerMessageHandler getMessageHandler(SubscribableChannel brokerChannel) {\n\t\tSimpleBrokerMessageHandler handler = new SimpleBrokerMessageHandler(getClientInboundChannel(),\n\t\t\t\tgetClientOutboundChannel(), brokerChannel, getDestinationPrefixes());\n\t\tif (this.taskScheduler != null) {\n\t\t\thandler.setTaskScheduler(this.taskScheduler);\n\t\t}\n\t\tif (this.heartbeat != null) {\n\t\t\thandler.setHeartbeatValue(this.heartbeat);\n\t\t}\n\t\thandler.setSelectorHeaderName(this.selectorHeaderName);\n\t\treturn handler;\n\t}"
  },
  "org.springframework.messaging.simp.config.SimpleBrokerRegistration#setHeartbeatValue(heartbeat)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the value for the heartbeat settings. The first number\n\t * represents how often the server will write or send a heartbeat.\n\t * The second is how often the client should write. 0 means no heartbeats.\n\t * <p>By default this is set to \"0, 0\" unless the {@link #setTaskScheduler\n\t * taskScheduler} in which case the default becomes \"10000,10000\"\n\t * (in milliseconds).\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "heartbeat"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "SimpleBrokerRegistration",
    "signature": "public SimpleBrokerRegistration setHeartbeatValue(long[] heartbeat)",
    "source_code": "\tpublic SimpleBrokerRegistration setHeartbeatValue(long[] heartbeat) {\n\t\tthis.heartbeat = heartbeat;\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.simp.config.SimpleBrokerRegistration#setSelectorHeaderName(selectorHeaderName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the name of a header that a subscription message can have for\n\t * the purpose of filtering messages matched to the subscription.\n\t * <p>The header value is expected to be a Spring Expression Language (SpEL)\n\t * boolean expression to be applied to the headers of messages matched to the\n\t * subscription.\n\t * <p>For example:\n\t * <pre style=\"code\">\n\t * headers.foo == 'bar'\n\t * </pre>\n\t * <p>By default the selector header name is set to {@code null} which disables\n\t * this feature. You can set it to {@code \"selector\"} or a different name to\n\t * enable support for a selector header.\n\t * @param selectorHeaderName the name to use for a selector header, or {@code null}\n\t * or blank to disable selector header support\n\t * @since 4.3.17\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "selectorHeaderName"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void setSelectorHeaderName(@Nullable String selectorHeaderName)",
    "source_code": "\tpublic void setSelectorHeaderName(@Nullable String selectorHeaderName) {\n\t\tthis.selectorHeaderName = selectorHeaderName;\n\t}"
  },
  "org.springframework.messaging.simp.config.SimpleBrokerRegistration#setTaskScheduler(taskScheduler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link org.springframework.scheduling.TaskScheduler} to\n\t * use for providing heartbeat support. Setting this property also sets the\n\t * {@link #setHeartbeatValue heartbeatValue} to \"10000, 10000\".\n\t * <p>By default this is not set.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "taskScheduler"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "SimpleBrokerRegistration",
    "signature": "public SimpleBrokerRegistration setTaskScheduler(TaskScheduler taskScheduler)",
    "source_code": "\tpublic SimpleBrokerRegistration setTaskScheduler(TaskScheduler taskScheduler) {\n\t\tthis.taskScheduler = taskScheduler;\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompDecoder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Decodes one or more STOMP frames contained in a {@link ByteBuffer}.\n *\n * <p>An attempt is made to read all complete STOMP frames from the buffer, which\n * could be zero, one, or more. If there is any left-over content, i.e. an incomplete\n * STOMP frame, at the end the buffer is reset to point to the beginning of the\n * partial content. The caller is then responsible for dealing with that\n * incomplete content by buffering until there is more input available.\n *\n * @author Andy Wilkinson\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class StompDecoder",
    "source_code": "public class StompDecoder {\n\n\tstatic final byte[] HEARTBEAT_PAYLOAD = new byte[] {'\\n'};\n\n\tprivate static final Log logger = SimpLogging.forLogName(StompDecoder.class);\n\n\tprivate @Nullable MessageHeaderInitializer headerInitializer;\n\n\n\t/**\n\t * Configure a {@link MessageHeaderInitializer} to apply to the headers of\n\t * {@link Message Messages} from decoded STOMP frames.\n\t */\n\tpublic void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {\n\t\tthis.headerInitializer = headerInitializer;\n\t}\n\n\t/**\n\t * Return the configured {@code MessageHeaderInitializer}, if any.\n\t */\n\tpublic @Nullable MessageHeaderInitializer getHeaderInitializer() {\n\t\treturn this.headerInitializer;\n\t}\n\n\n\t/**\n\t * Decodes one or more STOMP frames from the given {@code ByteBuffer} into a\n\t * list of {@link Message Messages}. If the input buffer contains partial STOMP frame\n\t * content, or additional content with a partial STOMP frame, the buffer is\n\t * reset, and an empty list is returned.\n\t * @param byteBuffer the buffer to decode the STOMP frame from\n\t * @return the decoded messages, or an empty list if none\n\t * @throws StompConversionException in case of decoding issues\n\t */\n\tpublic List<Message<byte[]>> decode(ByteBuffer byteBuffer) {\n\t\treturn decode(byteBuffer, null);\n\t}\n\n\t/**\n\t * Decodes one or more STOMP frames from the given {@code buffer} and returns\n\t * a list of {@link Message Messages}.\n\t * <p>If the given ByteBuffer contains only partial STOMP frame content and no\n\t * complete STOMP frames, an empty list is returned, and the buffer is reset\n\t * to where it was.\n\t * <p>If the buffer contains one or more STOMP frames, those are returned, and\n\t * the buffer is reset to point to the beginning of the unused partial content.\n\t * <p>The {@code partialMessageHeaders} map is used to store successfully parsed\n\t * headers in case of partial content. The caller can then check if a\n\t * \"content-length\" header was read, which helps to determine how much more\n\t * content is needed before the next attempt to decode.\n\t * @param byteBuffer the buffer to decode the STOMP frame from\n\t * @param partialMessageHeaders an empty output map that will store the last\n\t * successfully parsed partial message headers in case of partial message content\n\t * in cases where the partial buffer ended with a partial STOMP frame\n\t * @return the decoded messages, or an empty list if none\n\t * @throws StompConversionException in case of decoding issues\n\t */\n\tpublic List<Message<byte[]>> decode(ByteBuffer byteBuffer,\n\t\t\t@Nullable MultiValueMap<String, String> partialMessageHeaders) {\n\n\t\tList<Message<byte[]>> messages = new ArrayList<>();\n\t\twhile (byteBuffer.hasRemaining()) {\n\t\t\tMessage<byte[]> message = decodeMessage(byteBuffer, partialMessageHeaders);\n\t\t\tif (message != null) {\n\t\t\t\tmessages.add(message);\n\t\t\t\tskipEol(byteBuffer);\n\t\t\t\tif (!byteBuffer.hasRemaining()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn messages;\n\t}\n\n\t/**\n\t * Decode a single STOMP frame from the given {@code byteBuffer} into a {@link Message}.\n\t */\n\t@SuppressWarnings(\"NullAway\") // Dataflow analysis limitation\n\tprivate @Nullable Message<byte[]> decodeMessage(ByteBuffer byteBuffer, @Nullable MultiValueMap<String, String> headers) {\n\t\tMessage<byte[]> decodedMessage = null;\n\t\tskipEol(byteBuffer);\n\t\tbyteBuffer.mark();\n\n\t\tString command = readCommand(byteBuffer);\n\t\tif (command.length() > 0) {\n\t\t\tStompHeaderAccessor headerAccessor = null;\n\t\t\tbyte[] payload = null;\n\t\t\tif (byteBuffer.remaining() > 0) {\n\t\t\t\tStompCommand stompCommand = StompCommand.valueOf(command);\n\t\t\t\theaderAccessor = StompHeaderAccessor.create(stompCommand);\n\t\t\t\tinitHeaders(headerAccessor);\n\t\t\t\treadHeaders(byteBuffer, headerAccessor, stompCommand);\n\t\t\t\tpayload = readPayload(byteBuffer, headerAccessor);\n\t\t\t}\n\t\t\tif (payload != null) {\n\t\t\t\tif (payload.length > 0) {\n\t\t\t\t\tStompCommand stompCommand = headerAccessor.getCommand();\n\t\t\t\t\tif (stompCommand != null && !stompCommand.isBodyAllowed()) {\n\t\t\t\t\t\tthrow new StompConversionException(stompCommand +\n\t\t\t\t\t\t\t\t\" shouldn't have a payload: length=\" + payload.length + \", headers=\" + headers);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\theaderAccessor.updateSimpMessageHeadersFromStompHeaders();\n\t\t\t\theaderAccessor.setLeaveMutable(true);\n\t\t\t\tdecodedMessage = MessageBuilder.createMessage(payload, headerAccessor.getMessageHeaders());\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Decoded \" + headerAccessor.getDetailedLogMessage(payload));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.trace(\"Incomplete frame, resetting input buffer...\");\n\t\t\t\tif (headers != null && headerAccessor != null) {\n\t\t\t\t\tString name = NativeMessageHeaderAccessor.NATIVE_HEADERS;\n\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\tMultiValueMap<String, String> map = (MultiValueMap<String, String>) headerAccessor.getHeader(name);\n\t\t\t\t\tif (map != null) {\n\t\t\t\t\t\theaders.putAll(map);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbyteBuffer.reset();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tStompHeaderAccessor headerAccessor = StompHeaderAccessor.createForHeartbeat();\n\t\t\tinitHeaders(headerAccessor);\n\t\t\theaderAccessor.setLeaveMutable(true);\n\t\t\tdecodedMessage = MessageBuilder.createMessage(HEARTBEAT_PAYLOAD, headerAccessor.getMessageHeaders());\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Decoded \" + headerAccessor.getDetailedLogMessage(null));\n\t\t\t}\n\t\t}\n\n\t\treturn decodedMessage;\n\t}\n\n\tprivate void initHeaders(StompHeaderAccessor headerAccessor) {\n\t\tMessageHeaderInitializer initializer = getHeaderInitializer();\n\t\tif (initializer != null) {\n\t\t\tinitializer.initHeaders(headerAccessor);\n\t\t}\n\t}\n\n\t/**\n\t * Skip one ore more EOL characters at the start of the given ByteBuffer.\n\t * STOMP, section 2.1 says: \"The NULL octet can be optionally followed by\n\t * multiple EOLs.\"\n\t */\n\tprotected void skipEol(ByteBuffer byteBuffer) {\n\t\twhile (true) {\n\t\t\tif (!tryConsumeEndOfLine(byteBuffer)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String readCommand(ByteBuffer byteBuffer) {\n\t\tByteArrayOutputStream command = new ByteArrayOutputStream(256);\n\t\twhile (byteBuffer.remaining() > 0 && !tryConsumeEndOfLine(byteBuffer)) {\n\t\t\tcommand.write(byteBuffer.get());\n\t\t}\n\t\treturn StreamUtils.copyToString(command, StandardCharsets.UTF_8);\n\t}\n\n\tprivate void readHeaders(ByteBuffer byteBuffer, StompHeaderAccessor headerAccessor, StompCommand command) {\n\n\t\tboolean shouldUnescape = (command != StompCommand.CONNECT &&\n\t\t\t\tcommand != StompCommand.CONNECTED &&\n\t\t\t\tcommand != StompCommand.STOMP);\n\n\t\twhile (true) {\n\t\t\tByteArrayOutputStream headerStream = new ByteArrayOutputStream(256);\n\t\t\tboolean headerComplete = false;\n\t\t\twhile (byteBuffer.hasRemaining()) {\n\t\t\t\tif (tryConsumeEndOfLine(byteBuffer)) {\n\t\t\t\t\theaderComplete = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\theaderStream.write(byteBuffer.get());\n\t\t\t}\n\t\t\tif (headerStream.size() > 0 && headerComplete) {\n\t\t\t\tString header = StreamUtils.copyToString(headerStream, StandardCharsets.UTF_8);\n\t\t\t\tint colonIndex = header.indexOf(':');\n\t\t\t\tif (colonIndex <= 0) {\n\t\t\t\t\tif (byteBuffer.remaining() > 0) {\n\t\t\t\t\t\tthrow new StompConversionException(\"Illegal header: '\" + header +\n\t\t\t\t\t\t\t\t\"'. A header must be of the form <name>:[<value>].\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString headerName = shouldUnescape ? unescape(header.substring(0, colonIndex)) : header.substring(0, colonIndex);\n\t\t\t\t\tString headerValue = shouldUnescape ? unescape(header.substring(colonIndex + 1)) : header.substring(colonIndex + 1);\n\t\t\t\t\ttry {\n\t\t\t\t\t\theaderAccessor.addNativeHeader(headerName, headerValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvalidMimeTypeException ex) {\n\t\t\t\t\t\tif (byteBuffer.remaining() > 0) {\n\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * See STOMP Spec 1.2:\n\t * <a href=\"https://stomp.github.io/stomp-specification-1.2.html#Value_Encoding\">\"Value Encoding\"</a>.\n\t */\n\tprivate String unescape(String inString) {\n\t\tint index = inString.indexOf('\\\\');\n\t\tif (index == -1) {\n\t\t\treturn inString;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder(inString.length());\n\t\tint pos = 0;  // position in the old string\n\n\t\twhile (index >= 0) {\n\t\t\tsb.append(inString, pos, index);\n\t\t\tif (index + 1 >= inString.length()) {\n\t\t\t\tthrow new StompConversionException(\"Illegal escape sequence at index \" + index + \": \" + inString);\n\t\t\t}\n\t\t\tchar c = inString.charAt(index + 1);\n\t\t\tif (c == 'r') {\n\t\t\t\tsb.append('\\r');\n\t\t\t}\n\t\t\telse if (c == 'n') {\n\t\t\t\tsb.append('\\n');\n\t\t\t}\n\t\t\telse if (c == 'c') {\n\t\t\t\tsb.append(':');\n\t\t\t}\n\t\t\telse if (c == '\\\\') {\n\t\t\t\tsb.append('\\\\');\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// should never happen\n\t\t\t\tthrow new StompConversionException(\"Illegal escape sequence at index \" + index + \": \" + inString);\n\t\t\t}\n\t\t\tpos = index + 2;\n\t\t\tindex = inString.indexOf('\\\\', pos);\n\t\t}\n\n\t\tsb.append(inString.substring(pos));\n\t\treturn sb.toString();\n\t}\n\n\tprivate byte @Nullable [] readPayload(ByteBuffer byteBuffer, StompHeaderAccessor headerAccessor) {\n\t\tInteger contentLength;\n\t\ttry {\n\t\t\tcontentLength = headerAccessor.getContentLength();\n\t\t}\n\t\tcatch (NumberFormatException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Ignoring invalid content-length: '\" + headerAccessor);\n\t\t\t}\n\t\t\tcontentLength = null;\n\t\t}\n\n\t\tif (contentLength != null && contentLength >= 0) {\n\t\t\tif (byteBuffer.remaining() > contentLength) {\n\t\t\t\tbyte[] payload = new byte[contentLength];\n\t\t\t\tbyteBuffer.get(payload);\n\t\t\t\tif (byteBuffer.get() != 0) {\n\t\t\t\t\tthrow new StompConversionException(\"Frame must be terminated with a null octet\");\n\t\t\t\t}\n\t\t\t\treturn payload;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tByteArrayOutputStream payload = new ByteArrayOutputStream(256);\n\t\t\twhile (byteBuffer.remaining() > 0) {\n\t\t\t\tbyte b = byteBuffer.get();\n\t\t\t\tif (b == 0) {\n\t\t\t\t\treturn payload.toByteArray();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpayload.write(b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Try to read an EOL incrementing the buffer position if successful.\n\t * @return whether an EOL was consumed\n\t */\n\tprivate boolean tryConsumeEndOfLine(ByteBuffer byteBuffer) {\n\t\tif (byteBuffer.remaining() > 0) {\n\t\t\tbyte b = byteBuffer.get();\n\t\t\tif (b == '\\n') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (b == '\\r') {\n\t\t\t\tif (byteBuffer.remaining() > 0 && byteBuffer.get() == '\\n') {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new StompConversionException(\"'\\\\r' must be followed by '\\\\n'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbyteBuffer.position(byteBuffer.position() - 1);\n\t\t}\n\t\treturn false;\n\t}\n\n}"
  },
  "org.springframework.messaging.simp.stomp.StompDecoder#decode(byteBuffer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Decodes one or more STOMP frames from the given {@code ByteBuffer} into a\n\t * list of {@link Message Messages}. If the input buffer contains partial STOMP frame\n\t * content, or additional content with a partial STOMP frame, the buffer is\n\t * reset, and an empty list is returned.\n\t * @param byteBuffer the buffer to decode the STOMP frame from\n\t * @return the decoded messages, or an empty list if none\n\t * @throws StompConversionException in case of decoding issues\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "byteBuffer"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "List<Message<byte[]>>",
    "signature": "public List<Message<byte[]>> decode(ByteBuffer byteBuffer)",
    "source_code": "\tpublic List<Message<byte[]>> decode(ByteBuffer byteBuffer) {\n\t\treturn decode(byteBuffer, null);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompDecoder#decode(byteBuffer,MultiValueMap<String,partialMessageHeaders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Decodes one or more STOMP frames from the given {@code buffer} and returns\n\t * a list of {@link Message Messages}.\n\t * <p>If the given ByteBuffer contains only partial STOMP frame content and no\n\t * complete STOMP frames, an empty list is returned, and the buffer is reset\n\t * to where it was.\n\t * <p>If the buffer contains one or more STOMP frames, those are returned, and\n\t * the buffer is reset to point to the beginning of the unused partial content.\n\t * <p>The {@code partialMessageHeaders} map is used to store successfully parsed\n\t * headers in case of partial content. The caller can then check if a\n\t * \"content-length\" header was read, which helps to determine how much more\n\t * content is needed before the next attempt to decode.\n\t * @param byteBuffer the buffer to decode the STOMP frame from\n\t * @param partialMessageHeaders an empty output map that will store the last\n\t * successfully parsed partial message headers in case of partial message content\n\t * in cases where the partial buffer ended with a partial STOMP frame\n\t * @return the decoded messages, or an empty list if none\n\t * @throws StompConversionException in case of decoding issues\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "byteBuffer",
      "MultiValueMap<String",
      "partialMessageHeaders"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "List<Message<byte[]>>",
    "signature": "public List<Message<byte[]>> decode(ByteBuffer byteBuffer,\n\t\t\t@Nullable MultiValueMap<String, String> partialMessageHeaders)",
    "source_code": "\tpublic List<Message<byte[]>> decode(ByteBuffer byteBuffer,"
  },
  "org.springframework.messaging.simp.stomp.StompDecoder#getHeaderInitializer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@code MessageHeaderInitializer}, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "MessageHeaderInitializer",
    "signature": "public MessageHeaderInitializer getHeaderInitializer()",
    "source_code": "\tpublic @Nullable MessageHeaderInitializer getHeaderInitializer() {\n\t\treturn this.headerInitializer;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompDecoder#setHeaderInitializer(headerInitializer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link MessageHeaderInitializer} to apply to the headers of\n\t * {@link Message Messages} from decoded STOMP frames.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerInitializer"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "void",
    "signature": "public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer)",
    "source_code": "\tpublic void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {\n\t\tthis.headerInitializer = headerInitializer;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompDecoder#skipEol(byteBuffer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Skip one ore more EOL characters at the start of the given ByteBuffer.\n\t * STOMP, section 2.1 says: \"The NULL octet can be optionally followed by\n\t * multiple EOLs.\"\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "byteBuffer"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "void",
    "signature": "protected void skipEol(ByteBuffer byteBuffer)",
    "source_code": "\tprotected void skipEol(ByteBuffer byteBuffer) {\n\t\twhile (true) {\n\t\t\tif (!tryConsumeEndOfLine(byteBuffer)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#getAcceptVersion()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the accept-version header.\n\t * @since 5.0.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "String[]",
    "signature": "public String[] getAcceptVersion()",
    "source_code": "\tpublic String[] getAcceptVersion() {\n\t\tString value = getFirst(ACCEPT_VERSION);\n\t\treturn value != null ? StringUtils.commaDelimitedListToStringArray(value) : null;\n\t}"
  },
  "org.springframework.messaging.simp.stomp.StompHeaders#getHeartbeat()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the heartbeat header.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "long[]",
    "signature": "public long[] getHeartbeat()",
    "source_code": "\tpublic long[] getHeartbeat() {\n\t\tString rawValue = getFirst(HEARTBEAT);\n\t\tint pos = (rawValue != null ? rawValue.indexOf(',') : -1);\n\t\tif (pos == -1) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new long[] {Long.parseLong(rawValue, 0, pos, 10),\n\t\t\t\tLong.parseLong(rawValue, pos + 1, rawValue.length(), 10)};\n\t}"
  },
  "org.springframework.messaging.support.AbstractHeaderMapper": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A base {@link HeaderMapper} implementation.\n *\n * @author Stephane Nicoll\n * @since 4.1\n * @param <T> type of the instance to and from which headers will be mapped\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class AbstractHeaderMapper",
    "source_code": "public abstract class AbstractHeaderMapper<T> implements HeaderMapper<T> {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate String inboundPrefix = \"\";\n\n\tprivate String outboundPrefix = \"\";\n\n\n\t/**\n\t * Specify a prefix to be appended to the message header name for any\n\t * user-defined property that is being mapped into the MessageHeaders.\n\t * The default is an empty String (no prefix).\n\t */\n\tpublic void setInboundPrefix(@Nullable String inboundPrefix) {\n\t\tthis.inboundPrefix = (inboundPrefix != null ? inboundPrefix : \"\");\n\t}\n\n\t/**\n\t * Specify a prefix to be appended to the protocol property name for any\n\t * user-defined message header that is being mapped into the protocol-specific\n\t * Message. The default is an empty String (no prefix).\n\t */\n\tpublic void setOutboundPrefix(@Nullable String outboundPrefix) {\n\t\tthis.outboundPrefix = (outboundPrefix != null ? outboundPrefix : \"\");\n\t}\n\n\n\t/**\n\t * Generate the name to use to set the header defined by the specified\n\t * {@code headerName} to the protocol specific message.\n\t * @see #setOutboundPrefix\n\t */\n\tprotected String fromHeaderName(String headerName) {\n\t\tString propertyName = headerName;\n\t\tif (StringUtils.hasText(this.outboundPrefix) && !propertyName.startsWith(this.outboundPrefix)) {\n\t\t\tpropertyName = this.outboundPrefix + headerName;\n\t\t}\n\t\treturn propertyName;\n\t}\n\n\t/**\n\t * Generate the name to use to set the header defined by the specified\n\t * {@code propertyName} to the {@link MessageHeaders} instance.\n\t * @see #setInboundPrefix(String)\n\t */\n\tprotected String toHeaderName(String propertyName) {\n\t\tString headerName = propertyName;\n\t\tif (StringUtils.hasText(this.inboundPrefix) && !headerName.startsWith(this.inboundPrefix)) {\n\t\t\theaderName = this.inboundPrefix + propertyName;\n\t\t}\n\t\treturn headerName;\n\t}\n\n\t/**\n\t * Return the header value, or {@code null} if it does not exist\n\t * or does not match the requested {@code type}.\n\t */\n\tprotected <V> @Nullable V getHeaderIfAvailable(Map<String, Object> headers, String name, Class<V> type) {\n\t\tObject value = headers.get(name);\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!type.isAssignableFrom(value.getClass())) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Skipping header '\" + name + \"': expected type [\" + type + \"], but got [\" +\n\t\t\t\t\t\tvalue.getClass() + \"]\");\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn type.cast(value);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.messaging.support.AbstractHeaderMapper#fromHeaderName(headerName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate the name to use to set the header defined by the specified\n\t * {@code headerName} to the protocol specific message.\n\t * @see #setOutboundPrefix\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headerName"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "String",
    "signature": "protected String fromHeaderName(String headerName)",
    "source_code": "\tprotected String fromHeaderName(String headerName) {\n\t\tString propertyName = headerName;\n\t\tif (StringUtils.hasText(this.outboundPrefix) && !propertyName.startsWith(this.outboundPrefix)) {\n\t\t\tpropertyName = this.outboundPrefix + headerName;\n\t\t}\n\t\treturn propertyName;\n\t}"
  },
  "org.springframework.messaging.support.AbstractHeaderMapper#getHeaderIfAvailable(Map<String,headers,name,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the header value, or {@code null} if it does not exist\n\t * or does not match the requested {@code type}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "headers",
      "name",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "V",
    "signature": "protected V getHeaderIfAvailable(Map<String, Object> headers, String name, Class<V> type)",
    "source_code": "\tprotected <V> @Nullable V getHeaderIfAvailable(Map<String, Object> headers, String name, Class<V> type) {\n\t\tObject value = headers.get(name);\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!type.isAssignableFrom(value.getClass())) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Skipping header '\" + name + \"': expected type [\" + type + \"], but got [\" +\n\t\t\t\t\t\tvalue.getClass() + \"]\");\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn type.cast(value);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.AbstractHeaderMapper#setInboundPrefix(inboundPrefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a prefix to be appended to the message header name for any\n\t * user-defined property that is being mapped into the MessageHeaders.\n\t * The default is an empty String (no prefix).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inboundPrefix"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "void",
    "signature": "public void setInboundPrefix(@Nullable String inboundPrefix)",
    "source_code": "\tpublic void setInboundPrefix(@Nullable String inboundPrefix) {\n\t\tthis.inboundPrefix = (inboundPrefix != null ? inboundPrefix : \"\");\n\t}"
  },
  "org.springframework.messaging.support.AbstractHeaderMapper#setOutboundPrefix(outboundPrefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a prefix to be appended to the protocol property name for any\n\t * user-defined message header that is being mapped into the protocol-specific\n\t * Message. The default is an empty String (no prefix).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outboundPrefix"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "void",
    "signature": "public void setOutboundPrefix(@Nullable String outboundPrefix)",
    "source_code": "\tpublic void setOutboundPrefix(@Nullable String outboundPrefix) {\n\t\tthis.outboundPrefix = (outboundPrefix != null ? outboundPrefix : \"\");\n\t}"
  },
  "org.springframework.messaging.support.AbstractHeaderMapper#toHeaderName(propertyName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate the name to use to set the header defined by the specified\n\t * {@code propertyName} to the {@link MessageHeaders} instance.\n\t * @see #setInboundPrefix(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "String",
    "signature": "protected String toHeaderName(String propertyName)",
    "source_code": "\tprotected String toHeaderName(String propertyName) {\n\t\tString headerName = propertyName;\n\t\tif (StringUtils.hasText(this.inboundPrefix) && !headerName.startsWith(this.inboundPrefix)) {\n\t\t\theaderName = this.inboundPrefix + propertyName;\n\t\t}\n\t\treturn headerName;\n\t}"
  },
  "org.springframework.mock.web.MockHttpServletRequest#getContentAsByteArray()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the content of the request body as a byte array.\n\t * @return the content as a byte array (potentially {@code null})\n\t * @since 5.0\n\t * @see #setContent(byte[])\n\t * @see #getContentAsString()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 446
    },
    "return": "byte[]",
    "signature": "public byte[] getContentAsByteArray()",
    "source_code": "\tpublic byte[] getContentAsByteArray() {\n\t\treturn this.content;\n\t}"
  },
  "org.springframework.mock.web.MockHttpServletRequest#getCookies()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1047
    },
    "return": "Cookie[]",
    "signature": "public Cookie[] getCookies()",
    "source_code": "\tpublic Cookie[] getCookies() {\n\t\treturn this.cookies;\n\t}"
  },
  "org.springframework.mock.web.MockHttpServletRequest#getParameterValues(name)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 645
    },
    "return": "String[]",
    "signature": "public String[] getParameterValues(String name)",
    "source_code": "\tpublic String[] getParameterValues(String name) {\n\t\tAssert.notNull(name, \"Parameter name must not be null\");\n\t\treturn this.parameters.get(name);\n\t}"
  },
  "org.springframework.mock.web.MockHttpSession#getAccessor()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "Accessor",
    "signature": "public Accessor getAccessor()",
    "source_code": "\tpublic Accessor getAccessor() {\n\t\treturn sessionConsumer -> sessionConsumer.accept(MockHttpSession.this);\n\t}"
  },
  "org.springframework.mock.web.MockMultipartFile": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Mock implementation of the {@link org.springframework.web.multipart.MultipartFile}\n * interface.\n *\n * <p>Useful in conjunction with a {@link MockMultipartHttpServletRequest}\n * for testing application controllers that access multipart uploads.\n *\n * @author Juergen Hoeller\n * @author Eric Crampton\n * @since 2.0\n * @see MockMultipartHttpServletRequest\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class MockMultipartFile",
    "source_code": "public class MockMultipartFile implements MultipartFile {\n\n\tprivate final String name;\n\n\tprivate final String originalFilename;\n\n\tprivate final @Nullable String contentType;\n\n\tprivate final byte[] content;\n\n\n\t/**\n\t * Create a new MockMultipartFile with the given content.\n\t * @param name the name of the file\n\t * @param content the content of the file\n\t */\n\tpublic MockMultipartFile(String name, byte @Nullable [] content) {\n\t\tthis(name, \"\", null, content);\n\t}\n\n\t/**\n\t * Create a new MockMultipartFile with the given content.\n\t * @param name the name of the file\n\t * @param contentStream the content of the file as stream\n\t * @throws IOException if reading from the stream failed\n\t */\n\tpublic MockMultipartFile(String name, InputStream contentStream) throws IOException {\n\t\tthis(name, \"\", null, FileCopyUtils.copyToByteArray(contentStream));\n\t}\n\n\t/**\n\t * Create a new MockMultipartFile with the given content.\n\t * @param name the name of the file\n\t * @param originalFilename the original filename (as on the client's machine)\n\t * @param contentType the content type (if known)\n\t * @param content the content of the file\n\t */\n\tpublic MockMultipartFile(\n\t\t\tString name, @Nullable String originalFilename, @Nullable String contentType, byte @Nullable [] content) {\n\n\t\tAssert.hasLength(name, \"Name must not be empty\");\n\t\tthis.name = name;\n\t\tthis.originalFilename = (originalFilename != null ? originalFilename : \"\");\n\t\tthis.contentType = contentType;\n\t\tthis.content = (content != null ? content : new byte[0]);\n\t}\n\n\t/**\n\t * Create a new MockMultipartFile with the given content.\n\t * @param name the name of the file\n\t * @param originalFilename the original filename (as on the client's machine)\n\t * @param contentType the content type (if known)\n\t * @param contentStream the content of the file as stream\n\t * @throws IOException if reading from the stream failed\n\t */\n\tpublic MockMultipartFile(\n\t\t\tString name, @Nullable String originalFilename, @Nullable String contentType, InputStream contentStream)\n\t\t\tthrows IOException {\n\n\t\tthis(name, originalFilename, contentType, FileCopyUtils.copyToByteArray(contentStream));\n\t}\n\n\n\t@Override\n\tpublic String getName() {\n\t\treturn this.name;\n\t}\n\n\t@Override\n\tpublic String getOriginalFilename() {\n\t\treturn this.originalFilename;\n\t}\n\n\t@Override\n\tpublic @Nullable String getContentType() {\n\t\treturn this.contentType;\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn (this.content.length == 0);\n\t}\n\n\t@Override\n\tpublic long getSize() {\n\t\treturn this.content.length;\n\t}\n\n\t@Override\n\tpublic byte[] getBytes() throws IOException {\n\t\treturn this.content;\n\t}\n\n\t@Override\n\tpublic InputStream getInputStream() throws IOException {\n\t\treturn new ByteArrayInputStream(this.content);\n\t}\n\n\t@Override\n\tpublic void transferTo(File dest) throws IOException, IllegalStateException {\n\t\tFileCopyUtils.copy(this.content, dest);\n\t}\n\n}"
  },
  "org.springframework.mock.web.MockMultipartFile#getBytes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "byte[]",
    "signature": "public byte[] getBytes()",
    "source_code": "\tpublic byte[] getBytes() throws IOException {\n\t\treturn this.content;\n\t}"
  },
  "org.springframework.mock.web.MockMultipartFile#getContentType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "String",
    "signature": "public String getContentType()",
    "source_code": "\tpublic @Nullable String getContentType() {\n\t\treturn this.contentType;\n\t}"
  },
  "org.springframework.mock.web.MockMultipartFile#getInputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "InputStream",
    "signature": "public InputStream getInputStream()",
    "source_code": "\tpublic InputStream getInputStream() throws IOException {\n\t\treturn new ByteArrayInputStream(this.content);\n\t}"
  },
  "org.springframework.mock.web.MockMultipartFile#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "\tpublic String getName() {\n\t\treturn this.name;\n\t}"
  },
  "org.springframework.mock.web.MockMultipartFile#getOriginalFilename()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "String",
    "signature": "public String getOriginalFilename()",
    "source_code": "\tpublic String getOriginalFilename() {\n\t\treturn this.originalFilename;\n\t}"
  },
  "org.springframework.mock.web.MockMultipartFile#getSize()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "long",
    "signature": "public long getSize()",
    "source_code": "\tpublic long getSize() {\n\t\treturn this.content.length;\n\t}"
  },
  "org.springframework.mock.web.MockMultipartFile#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn (this.content.length == 0);\n\t}"
  },
  "org.springframework.mock.web.MockMultipartFile#transferTo(dest)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dest"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "public void transferTo(File dest)",
    "source_code": "\tpublic void transferTo(File dest) throws IOException, IllegalStateException {\n\t\tFileCopyUtils.copy(this.content, dest);\n\t}"
  },
  "org.springframework.mock.web.MockPart": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Mock implementation of {@code jakarta.servlet.http.Part}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.3.12\n * @see MockHttpServletRequest#addPart\n * @see MockMultipartFile\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public class MockPart",
    "source_code": "public class MockPart implements Part {\n\n\tprivate final String name;\n\n\tprivate final @Nullable String filename;\n\n\tprivate final byte[] content;\n\n\tprivate final HttpHeaders headers = new HttpHeaders();\n\n\n\t/**\n\t * Constructor for a part with a name and content only.\n\t * @see #getHeaders()\n\t */\n\tpublic MockPart(String name, byte @Nullable [] content) {\n\t\tthis(name, null, content);\n\t}\n\n\t/**\n\t * Constructor for a part with a name, filename, and content.\n\t * @see #getHeaders()\n\t */\n\tpublic MockPart(String name, @Nullable String filename, byte @Nullable [] content) {\n\t\tthis(name, filename, content, null);\n\t}\n\n\t/**\n\t * Constructor for a part with a name, filename, content, and content type.\n\t * @since 6.1.2\n\t * @see #getHeaders()\n\t */\n\tpublic MockPart(String name, @Nullable String filename, byte @Nullable [] content, @Nullable MediaType contentType) {\n\t\tAssert.hasLength(name, \"'name' must not be empty\");\n\t\tthis.name = name;\n\t\tthis.filename = filename;\n\t\tthis.content = (content != null ? content : new byte[0]);\n\t\tthis.headers.setContentDispositionFormData(name, filename);\n\t\tthis.headers.setContentType(contentType);\n\t}\n\n\n\t@Override\n\tpublic String getName() {\n\t\treturn this.name;\n\t}\n\n\t@Override\n\tpublic @Nullable String getSubmittedFileName() {\n\t\treturn this.filename;\n\t}\n\n\t@Override\n\tpublic @Nullable String getContentType() {\n\t\tMediaType contentType = this.headers.getContentType();\n\t\treturn (contentType != null ? contentType.toString() : null);\n\t}\n\n\t@Override\n\tpublic long getSize() {\n\t\treturn this.content.length;\n\t}\n\n\t@Override\n\tpublic InputStream getInputStream() throws IOException {\n\t\treturn new ByteArrayInputStream(this.content);\n\t}\n\n\t@Override\n\tpublic void write(String fileName) throws IOException {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic void delete() throws IOException {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic @Nullable String getHeader(String name) {\n\t\treturn this.headers.getFirst(name);\n\t}\n\n\t@Override\n\tpublic Collection<String> getHeaders(String name) {\n\t\tCollection<String> headerValues = this.headers.get(name);\n\t\treturn (headerValues != null ? headerValues : Collections.emptyList());\n\t}\n\n\t@Override\n\tpublic Collection<String> getHeaderNames() {\n\t\treturn this.headers.headerNames();\n\t}\n\n\t/**\n\t * Return the {@link HttpHeaders} backing header related accessor methods,\n\t * allowing for populating selected header entries.\n\t */\n\tpublic final HttpHeaders getHeaders() {\n\t\treturn this.headers;\n\t}\n\n}"
  },
  "org.springframework.mock.web.MockPart#delete()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void delete()",
    "source_code": "\tpublic void delete() throws IOException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.mock.web.MockPart#getContentType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "String",
    "signature": "public String getContentType()",
    "source_code": "\tpublic @Nullable String getContentType() {\n\t\tMediaType contentType = this.headers.getContentType();\n\t\treturn (contentType != null ? contentType.toString() : null);\n\t}"
  },
  "org.springframework.mock.web.MockPart#getHeader(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "String",
    "signature": "public String getHeader(String name)",
    "source_code": "\tpublic @Nullable String getHeader(String name) {\n\t\treturn this.headers.getFirst(name);\n\t}"
  },
  "org.springframework.mock.web.MockPart#getHeaderNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "Collection<String>",
    "signature": "public Collection<String> getHeaderNames()",
    "source_code": "\tpublic Collection<String> getHeaderNames() {\n\t\treturn this.headers.headerNames();\n\t}"
  },
  "org.springframework.mock.web.MockPart#getHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link HttpHeaders} backing header related accessor methods,\n\t * allowing for populating selected header entries.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHeaders()",
    "source_code": "\tpublic final HttpHeaders getHeaders() {\n\t\treturn this.headers;\n\t}"
  },
  "org.springframework.mock.web.MockPart#getHeaders(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "Collection<String>",
    "signature": "public Collection<String> getHeaders(String name)",
    "source_code": "\tpublic Collection<String> getHeaders(String name) {\n\t\tCollection<String> headerValues = this.headers.get(name);\n\t\treturn (headerValues != null ? headerValues : Collections.emptyList());\n\t}"
  },
  "org.springframework.mock.web.MockPart#getInputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "InputStream",
    "signature": "public InputStream getInputStream()",
    "source_code": "\tpublic InputStream getInputStream() throws IOException {\n\t\treturn new ByteArrayInputStream(this.content);\n\t}"
  },
  "org.springframework.mock.web.MockPart#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "\tpublic String getName() {\n\t\treturn this.name;\n\t}"
  },
  "org.springframework.mock.web.MockPart#getSize()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "long",
    "signature": "public long getSize()",
    "source_code": "\tpublic long getSize() {\n\t\treturn this.content.length;\n\t}"
  },
  "org.springframework.mock.web.MockPart#getSubmittedFileName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "String",
    "signature": "public String getSubmittedFileName()",
    "source_code": "\tpublic @Nullable String getSubmittedFileName() {\n\t\treturn this.filename;\n\t}"
  },
  "org.springframework.mock.web.MockPart#write(fileName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fileName"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void write(String fileName)",
    "source_code": "\tpublic void write(String fileName) throws IOException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Helper class that simplifies Hibernate data access code. Automatically\n * converts HibernateExceptions into DataAccessExceptions, following the\n * {@code org.springframework.dao} exception hierarchy.\n *\n * <p>The central method is {@code execute}, supporting Hibernate access code\n * implementing the {@link HibernateCallback} interface. It provides Hibernate Session\n * handling such that neither the HibernateCallback implementation nor the calling\n * code needs to explicitly care about retrieving/closing Hibernate Sessions,\n * or handling Session lifecycle exceptions. For typical single step actions,\n * there are various convenience methods (find, load, saveOrUpdate, delete).\n *\n * <p>Can be used within a service implementation via direct instantiation\n * with a SessionFactory reference, or get prepared in an application context\n * and given to services as bean reference. Note: The SessionFactory should\n * always be configured as bean in the application context, in the first case\n * given to the service directly, in the second case to the prepared template.\n *\n * <p><b>NOTE: Hibernate access code can also be coded against the native Hibernate\n * {@link Session}. Hence, for newly started projects, consider adopting the standard\n * Hibernate style of coding against {@link SessionFactory#getCurrentSession()}.\n * Alternatively, use {@link #execute(HibernateCallback)} with Java 8 lambda code blocks\n * against the callback-provided {@code Session} which results in elegant code as well,\n * decoupled from the Hibernate Session lifecycle. The remaining operations on this\n * HibernateTemplate are deprecated in the meantime and primarily exist as a migration\n * helper for older Hibernate 3.x/4.x data access code in existing applications.</b>\n *\n * @author Juergen Hoeller\n * @since 4.2\n * @see #setSessionFactory\n * @see HibernateCallback\n * @see Session\n * @see LocalSessionFactoryBean\n * @see HibernateTransactionManager\n * @see org.springframework.orm.hibernate5.support.OpenSessionInViewFilter\n * @see org.springframework.orm.hibernate5.support.OpenSessionInViewInterceptor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "signature": "public class HibernateTemplate",
    "source_code": "public class HibernateTemplate implements HibernateOperations, InitializingBean {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t@Nullable\n\tprivate SessionFactory sessionFactory;\n\n\t@Nullable\n\tprivate String[] filterNames;\n\n\tprivate boolean exposeNativeSession = false;\n\n\tprivate boolean checkWriteOperations = true;\n\n\tprivate boolean cacheQueries = false;\n\n\t@Nullable\n\tprivate String queryCacheRegion;\n\n\tprivate int fetchSize = 0;\n\n\tprivate int maxResults = 0;\n\n\n\t/**\n\t * Create a new HibernateTemplate instance.\n\t */\n\tpublic HibernateTemplate() {\n\t}\n\n\t/**\n\t * Create a new HibernateTemplate instance.\n\t * @param sessionFactory the SessionFactory to create Sessions with\n\t */\n\tpublic HibernateTemplate(SessionFactory sessionFactory) {\n\t\tsetSessionFactory(sessionFactory);\n\t\tafterPropertiesSet();\n\t}\n\n\n\t/**\n\t * Set the Hibernate SessionFactory that should be used to create\n\t * Hibernate Sessions.\n\t */\n\tpublic void setSessionFactory(@Nullable SessionFactory sessionFactory) {\n\t\tthis.sessionFactory = sessionFactory;\n\t}\n\n\t/**\n\t * Return the Hibernate SessionFactory that should be used to create\n\t * Hibernate Sessions.\n\t */\n\t@Nullable\n\tpublic SessionFactory getSessionFactory() {\n\t\treturn this.sessionFactory;\n\t}\n\n\t/**\n\t * Obtain the SessionFactory for actual use.\n\t * @return the SessionFactory (never {@code null})\n\t * @throws IllegalStateException in case of no SessionFactory set\n\t * @since 5.0\n\t */\n\tprotected final SessionFactory obtainSessionFactory() {\n\t\tSessionFactory sessionFactory = getSessionFactory();\n\t\tAssert.state(sessionFactory != null, \"No SessionFactory set\");\n\t\treturn sessionFactory;\n\t}\n\n\t/**\n\t * Set one or more names of Hibernate filters to be activated for all\n\t * Sessions that this accessor works with.\n\t * <p>Each of those filters will be enabled at the beginning of each\n\t * operation and correspondingly disabled at the end of the operation.\n\t * This will work for newly opened Sessions as well as for existing\n\t * Sessions (for example, within a transaction).\n\t * @see #enableFilters(Session)\n\t * @see Session#enableFilter(String)\n\t */\n\tpublic void setFilterNames(@Nullable String... filterNames) {\n\t\tthis.filterNames = filterNames;\n\t}\n\n\t/**\n\t * Return the names of Hibernate filters to be activated, if any.\n\t */\n\t@Nullable\n\tpublic String[] getFilterNames() {\n\t\treturn this.filterNames;\n\t}\n\n\t/**\n\t * Set whether to expose the native Hibernate Session to\n\t * HibernateCallback code.\n\t * <p>Default is \"false\": a Session proxy will be returned, suppressing\n\t * {@code close} calls and automatically applying query cache\n\t * settings and transaction timeouts.\n\t * @see HibernateCallback\n\t * @see Session\n\t * @see #setCacheQueries\n\t * @see #setQueryCacheRegion\n\t * @see #prepareQuery\n\t * @see #prepareCriteria\n\t */\n\tpublic void setExposeNativeSession(boolean exposeNativeSession) {\n\t\tthis.exposeNativeSession = exposeNativeSession;\n\t}\n\n\t/**\n\t * Return whether to expose the native Hibernate Session to\n\t * HibernateCallback code, or rather a Session proxy.\n\t */\n\tpublic boolean isExposeNativeSession() {\n\t\treturn this.exposeNativeSession;\n\t}\n\n\t/**\n\t * Set whether to check that the Hibernate Session is not in read-only mode\n\t * in case of write operations (save/update/delete).\n\t * <p>Default is \"true\", for fail-fast behavior when attempting write operations\n\t * within a read-only transaction. Turn this off to allow save/update/delete\n\t * on a Session with flush mode MANUAL.\n\t * @see #checkWriteOperationAllowed\n\t * @see org.springframework.transaction.TransactionDefinition#isReadOnly\n\t */\n\tpublic void setCheckWriteOperations(boolean checkWriteOperations) {\n\t\tthis.checkWriteOperations = checkWriteOperations;\n\t}\n\n\t/**\n\t * Return whether to check that the Hibernate Session is not in read-only\n\t * mode in case of write operations (save/update/delete).\n\t */\n\tpublic boolean isCheckWriteOperations() {\n\t\treturn this.checkWriteOperations;\n\t}\n\n\t/**\n\t * Set whether to cache all queries executed by this template.\n\t * <p>If this is \"true\", all Query and Criteria objects created by\n\t * this template will be marked as cacheable (including all\n\t * queries through find methods).\n\t * <p>To specify the query region to be used for queries cached\n\t * by this template, set the \"queryCacheRegion\" property.\n\t * @see #setQueryCacheRegion\n\t * @see Query#setCacheable\n\t * @see Criteria#setCacheable\n\t */\n\tpublic void setCacheQueries(boolean cacheQueries) {\n\t\tthis.cacheQueries = cacheQueries;\n\t}\n\n\t/**\n\t * Return whether to cache all queries executed by this template.\n\t */\n\tpublic boolean isCacheQueries() {\n\t\treturn this.cacheQueries;\n\t}\n\n\t/**\n\t * Set the name of the cache region for queries executed by this template.\n\t * <p>If this is specified, it will be applied to all Query and Criteria objects\n\t * created by this template (including all queries through find methods).\n\t * <p>The cache region will not take effect unless queries created by this\n\t * template are configured to be cached via the \"cacheQueries\" property.\n\t * @see #setCacheQueries\n\t * @see Query#setCacheRegion\n\t * @see Criteria#setCacheRegion\n\t */\n\tpublic void setQueryCacheRegion(@Nullable String queryCacheRegion) {\n\t\tthis.queryCacheRegion = queryCacheRegion;\n\t}\n\n\t/**\n\t * Return the name of the cache region for queries executed by this template.\n\t */\n\t@Nullable\n\tpublic String getQueryCacheRegion() {\n\t\treturn this.queryCacheRegion;\n\t}\n\n\t/**\n\t * Set the fetch size for this HibernateTemplate. This is important for processing\n\t * large result sets: Setting this higher than the default value will increase\n\t * processing speed at the cost of memory consumption; setting this lower can\n\t * avoid transferring row data that will never be read by the application.\n\t * <p>Default is 0, indicating to use the JDBC driver's default.\n\t */\n\tpublic void setFetchSize(int fetchSize) {\n\t\tthis.fetchSize = fetchSize;\n\t}\n\n\t/**\n\t * Return the fetch size specified for this HibernateTemplate.\n\t */\n\tpublic int getFetchSize() {\n\t\treturn this.fetchSize;\n\t}\n\n\t/**\n\t * Set the maximum number of rows for this HibernateTemplate. This is important\n\t * for processing subsets of large result sets, avoiding to read and hold\n\t * the entire result set in the database or in the JDBC driver if we're\n\t * never interested in the entire result in the first place (for example,\n\t * when performing searches that might return a large number of matches).\n\t * <p>Default is 0, indicating to use the JDBC driver's default.\n\t */\n\tpublic void setMaxResults(int maxResults) {\n\t\tthis.maxResults = maxResults;\n\t}\n\n\t/**\n\t * Return the maximum number of rows specified for this HibernateTemplate.\n\t */\n\tpublic int getMaxResults() {\n\t\treturn this.maxResults;\n\t}\n\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\tif (getSessionFactory() == null) {\n\t\t\tthrow new IllegalArgumentException(\"Property 'sessionFactory' is required\");\n\t\t}\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic <T> T execute(HibernateCallback<T> action) throws DataAccessException {\n\t\treturn doExecute(action, false);\n\t}\n\n\t/**\n\t * Execute the action specified by the given action object within a\n\t * native {@link Session}.\n\t * <p>This execute variant overrides the template-wide\n\t * {@link #isExposeNativeSession() \"exposeNativeSession\"} setting.\n\t * @param action callback object that specifies the Hibernate action\n\t * @return a result object returned by the action, or {@code null}\n\t * @throws DataAccessException in case of Hibernate errors\n\t */\n\t@Nullable\n\tpublic <T> T executeWithNativeSession(HibernateCallback<T> action) {\n\t\treturn doExecute(action, true);\n\t}\n\n\t/**\n\t * Execute the action specified by the given action object within a Session.\n\t * @param action callback object that specifies the Hibernate action\n\t * @param enforceNativeSession whether to enforce exposure of the native\n\t * Hibernate Session to callback code\n\t * @return a result object returned by the action, or {@code null}\n\t * @throws DataAccessException in case of Hibernate errors\n\t */\n\t@Nullable\n\tprotected <T> T doExecute(HibernateCallback<T> action, boolean enforceNativeSession) throws DataAccessException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\n\t\tSession session = null;\n\t\tboolean isNew = false;\n\t\ttry {\n\t\t\tsession = obtainSessionFactory().getCurrentSession();\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tlogger.debug(\"Could not retrieve pre-bound Hibernate session\", ex);\n\t\t}\n\t\tif (session == null) {\n\t\t\tsession = obtainSessionFactory().openSession();\n\t\t\tsession.setHibernateFlushMode(FlushMode.MANUAL);\n\t\t\tisNew = true;\n\t\t}\n\n\t\ttry {\n\t\t\tenableFilters(session);\n\t\t\tSession sessionToExpose =\n\t\t\t\t\t(enforceNativeSession || isExposeNativeSession() ? session : createSessionProxy(session));\n\t\t\treturn action.doInHibernate(sessionToExpose);\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(ex);\n\t\t}\n\t\tcatch (PersistenceException ex) {\n\t\t\tif (ex.getCause() instanceof HibernateException hibernateEx) {\n\t\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(hibernateEx);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\t// Callback code threw application exception...\n\t\t\tthrow ex;\n\t\t}\n\t\tfinally {\n\t\t\tif (isNew) {\n\t\t\t\tSessionFactoryUtils.closeSession(session);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdisableFilters(session);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Create a close-suppressing proxy for the given Hibernate Session.\n\t * The proxy also prepares returned Query and Criteria objects.\n\t * @param session the Hibernate Session to create a proxy for\n\t * @return the Session proxy\n\t * @see Session#close()\n\t * @see #prepareQuery\n\t * @see #prepareCriteria\n\t */\n\tprotected Session createSessionProxy(Session session) {\n\t\treturn (Session) Proxy.newProxyInstance(\n\t\t\t\tsession.getClass().getClassLoader(), new Class<?>[] {Session.class},\n\t\t\t\tnew CloseSuppressingInvocationHandler(session));\n\t}\n\n\t/**\n\t * Enable the specified filters on the given Session.\n\t * @param session the current Hibernate Session\n\t * @see #setFilterNames\n\t * @see Session#enableFilter(String)\n\t */\n\tprotected void enableFilters(Session session) {\n\t\tString[] filterNames = getFilterNames();\n\t\tif (filterNames != null) {\n\t\t\tfor (String filterName : filterNames) {\n\t\t\t\tsession.enableFilter(filterName);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Disable the specified filters on the given Session.\n\t * @param session the current Hibernate Session\n\t * @see #setFilterNames\n\t * @see Session#disableFilter(String)\n\t */\n\tprotected void disableFilters(Session session) {\n\t\tString[] filterNames = getFilterNames();\n\t\tif (filterNames != null) {\n\t\t\tfor (String filterName : filterNames) {\n\t\t\t\tsession.disableFilter(filterName);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Convenience methods for loading individual objects\n\t//-------------------------------------------------------------------------\n\n\t@Override\n\t@Nullable\n\tpublic <T> T get(Class<T> entityClass, Serializable id) throws DataAccessException {\n\t\treturn get(entityClass, id, null);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic <T> T get(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.get(entityClass, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.get(entityClass, id);\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object get(String entityName, Serializable id) throws DataAccessException {\n\t\treturn get(entityName, id, null);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object get(String entityName, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.get(entityName, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.get(entityName, id);\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic <T> T load(Class<T> entityClass, Serializable id) throws DataAccessException {\n\t\treturn load(entityClass, id, null);\n\t}\n\n\t@Override\n\tpublic <T> T load(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.load(entityClass, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.load(entityClass, id);\n\t\t\t}\n\t\t}));\n\t}\n\n\t@Override\n\tpublic Object load(String entityName, Serializable id) throws DataAccessException {\n\t\treturn load(entityName, id, null);\n\t}\n\n\t@Override\n\tpublic Object load(String entityName, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.load(entityName, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.load(entityName, id);\n\t\t\t}\n\t\t}));\n\t}\n\n\t@Override\n\t@SuppressWarnings({\"unchecked\", \"deprecation\"})\n\tpublic <T> List<T> loadAll(Class<T> entityClass) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<T>>) session -> {\n\t\t\tCriteria criteria = session.createCriteria(entityClass);\n\t\t\tcriteria.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY);\n\t\t\tprepareCriteria(criteria);\n\t\t\treturn criteria.list();\n\t\t}));\n\t}\n\n\t@Override\n\tpublic void load(Object entity, Serializable id) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.load(entity, id);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void refresh(Object entity) throws DataAccessException {\n\t\trefresh(entity, null);\n\t}\n\n\t@Override\n\tpublic void refresh(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.refresh(entity, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsession.refresh(entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic boolean contains(Object entity) throws DataAccessException {\n\t\tBoolean result = executeWithNativeSession(session -> session.contains(entity));\n\t\tAssert.state(result != null, \"No contains result\");\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic void evict(Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.evict(entity);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void initialize(Object proxy) throws DataAccessException {\n\t\ttry {\n\t\t\tHibernate.initialize(proxy);\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(ex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic Filter enableFilter(String filterName) throws IllegalStateException {\n\t\tSession session = obtainSessionFactory().getCurrentSession();\n\t\tFilter filter = session.getEnabledFilter(filterName);\n\t\tif (filter == null) {\n\t\t\tfilter = session.enableFilter(filterName);\n\t\t}\n\t\treturn filter;\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Convenience methods for storing individual objects\n\t//-------------------------------------------------------------------------\n\n\t@Override\n\tpublic void lock(Object entity, LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void lock(String entityName, Object entity, LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic Serializable save(Object entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn session.save(entity);\n\t\t}));\n\t}\n\n\t@Override\n\tpublic Serializable save(String entityName, Object entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn session.save(entityName, entity);\n\t\t}));\n\t}\n\n\t@Override\n\tpublic void update(Object entity) throws DataAccessException {\n\t\tupdate(entity, null);\n\t}\n\n\t@Override\n\tpublic void update(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.update(entity);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void update(String entityName, Object entity) throws DataAccessException {\n\t\tupdate(entityName, entity, null);\n\t}\n\n\t@Override\n\tpublic void update(String entityName, Object entity, @Nullable LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.update(entityName, entity);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entityName, entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void saveOrUpdate(Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.saveOrUpdate(entity);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void saveOrUpdate(String entityName, Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.saveOrUpdate(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void replicate(Object entity, ReplicationMode replicationMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.replicate(entity, replicationMode);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void replicate(String entityName, Object entity, ReplicationMode replicationMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.replicate(entityName, entity, replicationMode);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void persist(Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.persist(entity);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void persist(String entityName, Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.persist(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T merge(T entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn (T) session.merge(entity);\n\t\t}));\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T merge(String entityName, T entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn (T) session.merge(entityName, entity);\n\t\t}));\n\t}\n\n\t@Override\n\tpublic void delete(Object entity) throws DataAccessException {\n\t\tdelete(entity, null);\n\t}\n\n\t@Override\n\tpublic void delete(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\t}\n\t\t\tsession.delete(entity);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void delete(String entityName, Object entity) throws DataAccessException {\n\t\tdelete(entityName, entity, null);\n\t}\n\n\t@Override\n\tpublic void delete(String entityName, Object entity, @Nullable LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entityName, entity);\n\t\t\t}\n\t\t\tsession.delete(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void deleteAll(Collection<?> entities) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tfor (Object entity : entities) {\n\t\t\t\tsession.delete(entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void flush() throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.flush();\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t@Override\n\tpublic void clear() throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.clear();\n\t\t\treturn null;\n\t\t});\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Convenience finder methods for detached criteria\n\t//-------------------------------------------------------------------------\n\n\t@Override\n\tpublic List<?> findByCriteria(DetachedCriteria criteria) throws DataAccessException {\n\t\treturn findByCriteria(criteria, -1, -1);\n\t}\n\n\t@Override\n\tpublic List<?> findByCriteria(DetachedCriteria criteria, int firstResult, int maxResults)\n\t\t\tthrows DataAccessException {\n\n\t\tAssert.notNull(criteria, \"DetachedCriteria must not be null\");\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {\n\t\t\tCriteria executableCriteria = criteria.getExecutableCriteria(session);\n\t\t\tprepareCriteria(executableCriteria);\n\t\t\tif (firstResult >= 0) {\n\t\t\t\texecutableCriteria.setFirstResult(firstResult);\n\t\t\t}\n\t\t\tif (maxResults > 0) {\n\t\t\t\texecutableCriteria.setMaxResults(maxResults);\n\t\t\t}\n\t\t\treturn executableCriteria.list();\n\t\t}));\n\t}\n\n\t@Override\n\tpublic <T> List<T> findByExample(T exampleEntity) throws DataAccessException {\n\t\treturn findByExample(null, exampleEntity, -1, -1);\n\t}\n\n\t@Override\n\tpublic <T> List<T> findByExample(String entityName, T exampleEntity) throws DataAccessException {\n\t\treturn findByExample(entityName, exampleEntity, -1, -1);\n\t}\n\n\t@Override\n\tpublic <T> List<T> findByExample(T exampleEntity, int firstResult, int maxResults) throws DataAccessException {\n\t\treturn findByExample(null, exampleEntity, firstResult, maxResults);\n\t}\n\n\t@Override\n\t@SuppressWarnings({\"unchecked\", \"deprecation\"})\n\tpublic <T> List<T> findByExample(@Nullable String entityName, T exampleEntity, int firstResult, int maxResults)\n\t\t\tthrows DataAccessException {\n\n\t\tAssert.notNull(exampleEntity, \"Example entity must not be null\");\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<T>>) session -> {\n\t\t\tCriteria executableCriteria = (entityName != null ?\n\t\t\t\t\tsession.createCriteria(entityName) : session.createCriteria(exampleEntity.getClass()));\n\t\t\texecutableCriteria.add(Example.create(exampleEntity));\n\t\t\tprepareCriteria(executableCriteria);\n\t\t\tif (firstResult >= 0) {\n\t\t\t\texecutableCriteria.setFirstResult(firstResult);\n\t\t\t}\n\t\t\tif (maxResults > 0) {\n\t\t\t\texecutableCriteria.setMaxResults(maxResults);\n\t\t\t}\n\t\t\treturn executableCriteria.list();\n\t\t}));\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Convenience finder methods for HQL strings\n\t//-------------------------------------------------------------------------\n\n\t@Deprecated\n\t@Override\n\tpublic List<?> find(String queryString, @Nullable Object... values) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {\n\t\t\tQuery<?> queryObject = session.createQuery(queryString);\n\t\t\tprepareQuery(queryObject);\n\t\t\tif (values != null) {\n\t\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\t\tqueryObject.setParameter(i, values[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queryObject.list();\n\t\t}));\n\t}\n\n\t@Deprecated\n\t@Override\n\tpublic List<?> findByNamedParam(String queryString, String paramName, Object value)\n\t\t\tthrows DataAccessException {\n\n\t\treturn findByNamedParam(queryString, new String[] {paramName}, new Object[] {value});\n\t}\n\n\t@Deprecated\n\t@Override\n\tpublic List<?> findByNamedParam(String queryString, String[] paramNames, Object[] values)\n\t\t\tthrows DataAccessException {\n\n\t\tif (paramNames.length != values.length) {\n\t\t\tthrow new IllegalArgumentException(\"Length of paramNames array must match length of values array\");\n\t\t}\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {\n\t\t\tQuery<?> queryObject = session.createQuery(queryString);\n\t\t\tprepareQuery(queryObject);\n\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\tapplyNamedParameterToQuery(queryObject, paramNames[i], values[i]);\n\t\t\t}\n\t\t\treturn queryObject.list();\n\t\t}));\n\t}\n\n\t@Deprecated\n\t@Override\n\tpublic List<?> findByValueBean(String queryString, Object valueBean) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {\n\t\t\tQuery<?> queryObject = session.createQuery(queryString);\n\t\t\tprepareQuery(queryObject);\n\t\t\tqueryObject.setProperties(valueBean);\n\t\t\treturn queryObject.list();\n\t\t}));\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Convenience finder methods for named queries\n\t//-------------------------------------------------------------------------\n\n\t@Deprecated\n\t@Override\n\tpublic List<?> findByNamedQuery(String queryName, @Nullable Object... values) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {\n\t\t\tQuery<?> queryObject = session.getNamedQuery(queryName);\n\t\t\tprepareQuery(queryObject);\n\t\t\tif (values != null) {\n\t\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\t\tqueryObject.setParameter(i, values[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queryObject.list();\n\t\t}));\n\t}\n\n\t@Deprecated\n\t@Override\n\tpublic List<?> findByNamedQueryAndNamedParam(String queryName, String paramName, Object value)\n\t\t\tthrows DataAccessException {\n\n\t\treturn findByNamedQueryAndNamedParam(queryName, new String[] {paramName}, new Object[] {value});\n\t}\n\n\t@Deprecated\n\t@Override\n\t@SuppressWarnings(\"NullAway\")\n\tpublic List<?> findByNamedQueryAndNamedParam(\n\t\t\tString queryName, @Nullable String[] paramNames, @Nullable Object[] values)\n\t\t\tthrows DataAccessException {\n\n\t\tif (values != null && (paramNames == null || paramNames.length != values.length)) {\n\t\t\tthrow new IllegalArgumentException(\"Length of paramNames array must match length of values array\");\n\t\t}\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {\n\t\t\tQuery<?> queryObject = session.getNamedQuery(queryName);\n\t\t\tprepareQuery(queryObject);\n\t\t\tif (values != null) {\n\t\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\t\tapplyNamedParameterToQuery(queryObject, paramNames[i], values[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queryObject.list();\n\t\t}));\n\t}\n\n\t@Deprecated\n\t@Override\n\tpublic List<?> findByNamedQueryAndValueBean(String queryName, Object valueBean) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {\n\t\t\tQuery<?> queryObject = session.getNamedQuery(queryName);\n\t\t\tprepareQuery(queryObject);\n\t\t\tqueryObject.setProperties(valueBean);\n\t\t\treturn queryObject.list();\n\t\t}));\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Convenience query methods for iteration and bulk updates/deletes\n\t//-------------------------------------------------------------------------\n\n\t@SuppressWarnings(\"deprecation\")\n\t@Deprecated\n\t@Override\n\tpublic Iterator<?> iterate(String queryString, @Nullable Object... values) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<Iterator<?>>) session -> {\n\t\t\tQuery<?> queryObject = session.createQuery(queryString);\n\t\t\tprepareQuery(queryObject);\n\t\t\tif (values != null) {\n\t\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\t\tqueryObject.setParameter(i, values[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queryObject.iterate();\n\t\t}));\n\t}\n\n\t@Deprecated\n\t@Override\n\tpublic void closeIterator(Iterator<?> it) throws DataAccessException {\n\t\ttry {\n\t\t\tHibernate.close(it);\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(ex);\n\t\t}\n\t}\n\n\t@Deprecated\n\t@Override\n\tpublic int bulkUpdate(String queryString, @Nullable Object... values) throws DataAccessException {\n\t\tInteger result = executeWithNativeSession(session -> {\n\t\t\tQuery<?> queryObject = session.createQuery(queryString);\n\t\t\tprepareQuery(queryObject);\n\t\t\tif (values != null) {\n\t\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\t\tqueryObject.setParameter(i, values[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queryObject.executeUpdate();\n\t\t});\n\t\tAssert.state(result != null, \"No update count\");\n\t\treturn result;\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Helper methods used by the operations above\n\t//-------------------------------------------------------------------------\n\n\t/**\n\t * Check whether write operations are allowed on the given Session.\n\t * <p>Default implementation throws an InvalidDataAccessApiUsageException in\n\t * case of {@code FlushMode.MANUAL}. Can be overridden in subclasses.\n\t * @param session current Hibernate Session\n\t * @throws InvalidDataAccessApiUsageException if write operations are not allowed\n\t * @see #setCheckWriteOperations\n\t * @see Session#getFlushMode()\n\t * @see FlushMode#MANUAL\n\t */\n\tprotected void checkWriteOperationAllowed(Session session) throws InvalidDataAccessApiUsageException {\n\t\tif (isCheckWriteOperations() && session.getHibernateFlushMode().lessThan(FlushMode.COMMIT)) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"Write operations are not allowed in read-only mode (FlushMode.MANUAL): \"+\n\t\t\t\t\t\"Turn your Session into FlushMode.COMMIT/AUTO or remove 'readOnly' marker from transaction definition.\");\n\t\t}\n\t}\n\n\t/**\n\t * Prepare the given Criteria object, applying cache settings and/or\n\t * a transaction timeout.\n\t * @param criteria the Criteria object to prepare\n\t * @see #setCacheQueries\n\t * @see #setQueryCacheRegion\n\t */\n\tprotected void prepareCriteria(Criteria criteria) {\n\t\tif (isCacheQueries()) {\n\t\t\tcriteria.setCacheable(true);\n\t\t\tif (getQueryCacheRegion() != null) {\n\t\t\t\tcriteria.setCacheRegion(getQueryCacheRegion());\n\t\t\t}\n\t\t}\n\t\tif (getFetchSize() > 0) {\n\t\t\tcriteria.setFetchSize(getFetchSize());\n\t\t}\n\t\tif (getMaxResults() > 0) {\n\t\t\tcriteria.setMaxResults(getMaxResults());\n\t\t}\n\n\t\tResourceHolderSupport sessionHolder =\n\t\t\t\t(ResourceHolderSupport) TransactionSynchronizationManager.getResource(obtainSessionFactory());\n\t\tif (sessionHolder != null && sessionHolder.hasTimeout()) {\n\t\t\tcriteria.setTimeout(sessionHolder.getTimeToLiveInSeconds());\n\t\t}\n\t}\n\n\t/**\n\t * Prepare the given Query object, applying cache settings and/or\n\t * a transaction timeout.\n\t * @param queryObject the Query object to prepare\n\t * @see #setCacheQueries\n\t * @see #setQueryCacheRegion\n\t */\n\tprotected void prepareQuery(Query<?> queryObject) {\n\t\tif (isCacheQueries()) {\n\t\t\tqueryObject.setCacheable(true);\n\t\t\tif (getQueryCacheRegion() != null) {\n\t\t\t\tqueryObject.setCacheRegion(getQueryCacheRegion());\n\t\t\t}\n\t\t}\n\t\tif (getFetchSize() > 0) {\n\t\t\tqueryObject.setFetchSize(getFetchSize());\n\t\t}\n\t\tif (getMaxResults() > 0) {\n\t\t\tqueryObject.setMaxResults(getMaxResults());\n\t\t}\n\n\t\tResourceHolderSupport sessionHolder =\n\t\t\t\t(ResourceHolderSupport) TransactionSynchronizationManager.getResource(obtainSessionFactory());\n\t\tif (sessionHolder != null && sessionHolder.hasTimeout()) {\n\t\t\tqueryObject.setTimeout(sessionHolder.getTimeToLiveInSeconds());\n\t\t}\n\t}\n\n\t/**\n\t * Apply the given name parameter to the given Query object.\n\t * @param queryObject the Query object\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @throws HibernateException if thrown by the Query object\n\t */\n\tprotected void applyNamedParameterToQuery(Query<?> queryObject, String paramName, Object value)\n\t\t\tthrows HibernateException {\n\n\t\tif (value instanceof Collection<?> collection) {\n\t\t\tqueryObject.setParameterList(paramName, collection);\n\t\t}\n\t\telse if (value instanceof Object[] array) {\n\t\t\tqueryObject.setParameterList(paramName, array);\n\t\t}\n\t\telse {\n\t\t\tqueryObject.setParameter(paramName, value);\n\t\t}\n\t}\n\n\tprivate static <T> T nonNull(@Nullable T result) {\n\t\tAssert.state(result != null, \"No result\");\n\t\treturn result;\n\t}\n\n\n\t/**\n\t * Invocation handler that suppresses close calls on Hibernate Sessions.\n\t * Also prepares returned Query and Criteria objects.\n\t * @see Session#close\n\t */\n\tprivate class CloseSuppressingInvocationHandler implements InvocationHandler {\n\n\t\tprivate final Session target;\n\n\t\tpublic CloseSuppressingInvocationHandler(Session target) {\n\t\t\tthis.target = target;\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on Session interface coming in...\n\n\t\t\treturn switch (method.getName()) {\n\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\tcase \"equals\" -> (proxy == args[0]);\n\t\t\t\t// Use hashCode of Session proxy.\n\t\t\t\tcase \"hashCode\" -> System.identityHashCode(proxy);\n\t\t\t\t// Handle close method: suppress, not valid.\n\t\t\t\tcase \"close\" -> null;\n\t\t\t\tdefault -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Invoke method on target Session.\n\t\t\t\t\t\tObject retVal = method.invoke(this.target, args);\n\n\t\t\t\t\t\t// If return value is a Query or Criteria, apply transaction timeout.\n\t\t\t\t\t\t// Applies to createQuery, getNamedQuery, createCriteria.\n\t\t\t\t\t\tif (retVal instanceof Criteria criteria) {\n\t\t\t\t\t\t\tprepareCriteria(criteria);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (retVal instanceof Query<?> query) {\n\t\t\t\t\t\t\tprepareQuery(query);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tyield retVal;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#afterPropertiesSet()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tif (getSessionFactory() == null) {\n\t\t\tthrow new IllegalArgumentException(\"Property 'sessionFactory' is required\");\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#applyNamedParameterToQuery(queryObject,paramName,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given name parameter to the given Query object.\n\t * @param queryObject the Query object\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @throws HibernateException if thrown by the Query object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "queryObject",
      "paramName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1116
    },
    "return": "void",
    "signature": "protected void applyNamedParameterToQuery(Query<?> queryObject, String paramName, Object value)",
    "source_code": "\tprotected void applyNamedParameterToQuery(Query<?> queryObject, String paramName, Object value)"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#bulkUpdate(queryString,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queryString",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1015
    },
    "return": "int",
    "signature": "public int bulkUpdate(String queryString, @Nullable Object... values)",
    "source_code": "\tpublic int bulkUpdate(String queryString, @Nullable Object... values) throws DataAccessException {\n\t\tInteger result = executeWithNativeSession(session -> {\n\t\t\tQuery<?> queryObject = session.createQuery(queryString);\n\t\t\tprepareQuery(queryObject);\n\t\t\tif (values != null) {\n\t\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\t\tqueryObject.setParameter(i, values[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queryObject.executeUpdate();\n\t\t});\n\t\tAssert.state(result != null, \"No update count\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#checkWriteOperationAllowed(session)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether write operations are allowed on the given Session.\n\t * <p>Default implementation throws an InvalidDataAccessApiUsageException in\n\t * case of {@code FlushMode.MANUAL}. Can be overridden in subclasses.\n\t * @param session current Hibernate Session\n\t * @throws InvalidDataAccessApiUsageException if write operations are not allowed\n\t * @see #setCheckWriteOperations\n\t * @see Session#getFlushMode()\n\t * @see FlushMode#MANUAL\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 1045
    },
    "return": "void",
    "signature": "protected void checkWriteOperationAllowed(Session session)",
    "source_code": "\tprotected void checkWriteOperationAllowed(Session session) throws InvalidDataAccessApiUsageException {\n\t\tif (isCheckWriteOperations() && session.getHibernateFlushMode().lessThan(FlushMode.COMMIT)) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"Write operations are not allowed in read-only mode (FlushMode.MANUAL): \"+\n\t\t\t\t\t\"Turn your Session into FlushMode.COMMIT/AUTO or remove 'readOnly' marker from transaction definition.\");\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#clear()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 792
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.clear();\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#closeIterator(it)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "it"
    ],
    "position": {
      "column": 1,
      "line": 1004
    },
    "return": "void",
    "signature": "public void closeIterator(Iterator<?> it)",
    "source_code": "\tpublic void closeIterator(Iterator<?> it) throws DataAccessException {\n\t\ttry {\n\t\t\tHibernate.close(it);\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#contains(entity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 553
    },
    "return": "boolean",
    "signature": "public boolean contains(Object entity)",
    "source_code": "\tpublic boolean contains(Object entity) throws DataAccessException {\n\t\tBoolean result = executeWithNativeSession(session -> session.contains(entity));\n\t\tAssert.state(result != null, \"No contains result\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#createSessionProxy(session)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a close-suppressing proxy for the given Hibernate Session.\n\t * The proxy also prepares returned Query and Criteria objects.\n\t * @param session the Hibernate Session to create a proxy for\n\t * @return the Session proxy\n\t * @see Session#close()\n\t * @see #prepareQuery\n\t * @see #prepareCriteria\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 400
    },
    "return": "Session",
    "signature": "protected Session createSessionProxy(Session session)",
    "source_code": "\tprotected Session createSessionProxy(Session session) {\n\t\treturn (Session) Proxy.newProxyInstance(\n\t\t\t\tsession.getClass().getClassLoader(), new Class<?>[] {Session.class},\n\t\t\t\tnew CloseSuppressingInvocationHandler(session));\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#delete(entity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 737
    },
    "return": "void",
    "signature": "public void delete(Object entity)",
    "source_code": "\tpublic void delete(Object entity) throws DataAccessException {\n\t\tdelete(entity, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#delete(entity,lockMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 742
    },
    "return": "void",
    "signature": "public void delete(Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void delete(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\t}\n\t\t\tsession.delete(entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#delete(entityName,entity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 754
    },
    "return": "void",
    "signature": "public void delete(String entityName, Object entity)",
    "source_code": "\tpublic void delete(String entityName, Object entity) throws DataAccessException {\n\t\tdelete(entityName, entity, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#delete(entityName,entity,lockMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 759
    },
    "return": "void",
    "signature": "public void delete(String entityName, Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void delete(String entityName, Object entity, @Nullable LockMode lockMode)"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#deleteAll(entities)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entities"
    ],
    "position": {
      "column": 1,
      "line": 773
    },
    "return": "void",
    "signature": "public void deleteAll(Collection<?> entities)",
    "source_code": "\tpublic void deleteAll(Collection<?> entities) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tfor (Object entity : entities) {\n\t\t\t\tsession.delete(entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#disableFilters(session)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Disable the specified filters on the given Session.\n\t * @param session the current Hibernate Session\n\t * @see #setFilterNames\n\t * @see Session#disableFilter(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 427
    },
    "return": "void",
    "signature": "protected void disableFilters(Session session)",
    "source_code": "\tprotected void disableFilters(Session session) {\n\t\tString[] filterNames = getFilterNames();\n\t\tif (filterNames != null) {\n\t\t\tfor (String filterName : filterNames) {\n\t\t\t\tsession.disableFilter(filterName);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#doExecute(action,enforceNativeSession)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the action specified by the given action object within a Session.\n\t * @param action callback object that specifies the Hibernate action\n\t * @param enforceNativeSession whether to enforce exposure of the native\n\t * Hibernate Session to callback code\n\t * @return a result object returned by the action, or {@code null}\n\t * @throws DataAccessException in case of Hibernate errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "action",
      "enforceNativeSession"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "T",
    "signature": "protected T doExecute(HibernateCallback<T> action, boolean enforceNativeSession)",
    "source_code": "\tprotected <T> T doExecute(HibernateCallback<T> action, boolean enforceNativeSession) throws DataAccessException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\n\t\tSession session = null;\n\t\tboolean isNew = false;\n\t\ttry {\n\t\t\tsession = obtainSessionFactory().getCurrentSession();\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tlogger.debug(\"Could not retrieve pre-bound Hibernate session\", ex);\n\t\t}\n\t\tif (session == null) {\n\t\t\tsession = obtainSessionFactory().openSession();\n\t\t\tsession.setHibernateFlushMode(FlushMode.MANUAL);\n\t\t\tisNew = true;\n\t\t}\n\n\t\ttry {\n\t\t\tenableFilters(session);\n\t\t\tSession sessionToExpose =\n\t\t\t\t\t(enforceNativeSession || isExposeNativeSession() ? session : createSessionProxy(session));\n\t\t\treturn action.doInHibernate(sessionToExpose);\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(ex);\n\t\t}\n\t\tcatch (PersistenceException ex) {\n\t\t\tif (ex.getCause() instanceof HibernateException hibernateEx) {\n\t\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(hibernateEx);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\t// Callback code threw application exception...\n\t\t\tthrow ex;\n\t\t}\n\t\tfinally {\n\t\t\tif (isNew) {\n\t\t\t\tSessionFactoryUtils.closeSession(session);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdisableFilters(session);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#enableFilter(filterName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filterName"
    ],
    "position": {
      "column": 1,
      "line": 578
    },
    "return": "Filter",
    "signature": "public Filter enableFilter(String filterName)",
    "source_code": "\tpublic Filter enableFilter(String filterName) throws IllegalStateException {\n\t\tSession session = obtainSessionFactory().getCurrentSession();\n\t\tFilter filter = session.getEnabledFilter(filterName);\n\t\tif (filter == null) {\n\t\t\tfilter = session.enableFilter(filterName);\n\t\t}\n\t\treturn filter;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#enableFilters(session)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Enable the specified filters on the given Session.\n\t * @param session the current Hibernate Session\n\t * @see #setFilterNames\n\t * @see Session#enableFilter(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "void",
    "signature": "protected void enableFilters(Session session)",
    "source_code": "\tprotected void enableFilters(Session session) {\n\t\tString[] filterNames = getFilterNames();\n\t\tif (filterNames != null) {\n\t\t\tfor (String filterName : filterNames) {\n\t\t\t\tsession.enableFilter(filterName);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#evict(entity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 560
    },
    "return": "void",
    "signature": "public void evict(Object entity)",
    "source_code": "\tpublic void evict(Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.evict(entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#execute(action)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "action"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "T",
    "signature": "public T execute(HibernateCallback<T> action)",
    "source_code": "\tpublic <T> T execute(HibernateCallback<T> action) throws DataAccessException {\n\t\treturn doExecute(action, false);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#executeWithNativeSession(action)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the action specified by the given action object within a\n\t * native {@link Session}.\n\t * <p>This execute variant overrides the template-wide\n\t * {@link #isExposeNativeSession() \"exposeNativeSession\"} setting.\n\t * @param action callback object that specifies the Hibernate action\n\t * @return a result object returned by the action, or {@code null}\n\t * @throws DataAccessException in case of Hibernate errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "action"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "T",
    "signature": "public T executeWithNativeSession(HibernateCallback<T> action)",
    "source_code": "\tpublic <T> T executeWithNativeSession(HibernateCallback<T> action) {\n\t\treturn doExecute(action, true);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#findByExample(entityName,exampleEntity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "exampleEntity"
    ],
    "position": {
      "column": 1,
      "line": 833
    },
    "return": "List<T>",
    "signature": "public List<T> findByExample(String entityName, T exampleEntity)",
    "source_code": "\tpublic <T> List<T> findByExample(String entityName, T exampleEntity) throws DataAccessException {\n\t\treturn findByExample(entityName, exampleEntity, -1, -1);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#findByExample(entityName,exampleEntity,firstResult,maxResults)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "exampleEntity",
      "firstResult",
      "maxResults"
    ],
    "position": {
      "column": 1,
      "line": 844
    },
    "return": "List<T>",
    "signature": "public List<T> findByExample(@Nullable String entityName, T exampleEntity, int firstResult, int maxResults)",
    "source_code": "\tpublic <T> List<T> findByExample(@Nullable String entityName, T exampleEntity, int firstResult, int maxResults)"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#findByExample(exampleEntity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exampleEntity"
    ],
    "position": {
      "column": 1,
      "line": 828
    },
    "return": "List<T>",
    "signature": "public List<T> findByExample(T exampleEntity)",
    "source_code": "\tpublic <T> List<T> findByExample(T exampleEntity) throws DataAccessException {\n\t\treturn findByExample(null, exampleEntity, -1, -1);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#findByExample(exampleEntity,firstResult,maxResults)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exampleEntity",
      "firstResult",
      "maxResults"
    ],
    "position": {
      "column": 1,
      "line": 838
    },
    "return": "List<T>",
    "signature": "public List<T> findByExample(T exampleEntity, int firstResult, int maxResults)",
    "source_code": "\tpublic <T> List<T> findByExample(T exampleEntity, int firstResult, int maxResults) throws DataAccessException {\n\t\treturn findByExample(null, exampleEntity, firstResult, maxResults);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#flush()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 784
    },
    "return": "void",
    "signature": "public void flush()",
    "source_code": "\tpublic void flush() throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.flush();\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#get(entityClass,id)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "T",
    "signature": "public T get(Class<T> entityClass, Serializable id)",
    "source_code": "\tpublic <T> T get(Class<T> entityClass, Serializable id) throws DataAccessException {\n\t\treturn get(entityClass, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#get(entityClass,id,lockMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 449
    },
    "return": "T",
    "signature": "public T get(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic <T> T get(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.get(entityClass, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.get(entityClass, id);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#get(entityName,id)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 462
    },
    "return": "Object",
    "signature": "public Object get(String entityName, Serializable id)",
    "source_code": "\tpublic Object get(String entityName, Serializable id) throws DataAccessException {\n\t\treturn get(entityName, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#get(entityName,id,lockMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 468
    },
    "return": "Object",
    "signature": "public Object get(String entityName, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic Object get(String entityName, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.get(entityName, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.get(entityName, id);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#getFetchSize()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the fetch size specified for this HibernateTemplate.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 285
    },
    "return": "int",
    "signature": "public int getFetchSize()",
    "source_code": "\tpublic int getFetchSize() {\n\t\treturn this.fetchSize;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#getFilterNames()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the names of Hibernate filters to be activated, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "String[]",
    "signature": "public String[] getFilterNames()",
    "source_code": "\tpublic String[] getFilterNames() {\n\t\treturn this.filterNames;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#getMaxResults()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the maximum number of rows specified for this HibernateTemplate.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "int",
    "signature": "public int getMaxResults()",
    "source_code": "\tpublic int getMaxResults() {\n\t\treturn this.maxResults;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#getQueryCacheRegion()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the cache region for queries executed by this template.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "String",
    "signature": "public String getQueryCacheRegion()",
    "source_code": "\tpublic String getQueryCacheRegion() {\n\t\treturn this.queryCacheRegion;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#getSessionFactory()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Hibernate SessionFactory that should be used to create\n\t * Hibernate Sessions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "SessionFactory",
    "signature": "public SessionFactory getSessionFactory()",
    "source_code": "\tpublic SessionFactory getSessionFactory() {\n\t\treturn this.sessionFactory;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#initialize(proxy)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "void",
    "signature": "public void initialize(Object proxy)",
    "source_code": "\tpublic void initialize(Object proxy) throws DataAccessException {\n\t\ttry {\n\t\t\tHibernate.initialize(proxy);\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#invoke(proxy,method,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1151
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on Session interface coming in...\n\n\t\t\treturn switch (method.getName()) {\n\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\tcase \"equals\" -> (proxy == args[0]);\n\t\t\t\t// Use hashCode of Session proxy.\n\t\t\t\tcase \"hashCode\" -> System.identityHashCode(proxy);\n\t\t\t\t// Handle close method: suppress, not valid.\n\t\t\t\tcase \"close\" -> null;\n\t\t\t\tdefault -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Invoke method on target Session.\n\t\t\t\t\t\tObject retVal = method.invoke(this.target, args);\n\n\t\t\t\t\t\t// If return value is a Query or Criteria, apply transaction timeout.\n\t\t\t\t\t\t// Applies to createQuery, getNamedQuery, createCriteria.\n\t\t\t\t\t\tif (retVal instanceof Criteria criteria) {\n\t\t\t\t\t\t\tprepareCriteria(criteria);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (retVal instanceof Query<?> query) {\n\t\t\t\t\t\t\tprepareQuery(query);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tyield retVal;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#isCacheQueries()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to cache all queries executed by this template.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "boolean",
    "signature": "public boolean isCacheQueries()",
    "source_code": "\tpublic boolean isCacheQueries() {\n\t\treturn this.cacheQueries;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#isCheckWriteOperations()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to check that the Hibernate Session is not in read-only\n\t * mode in case of write operations (save/update/delete).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "boolean",
    "signature": "public boolean isCheckWriteOperations()",
    "source_code": "\tpublic boolean isCheckWriteOperations() {\n\t\treturn this.checkWriteOperations;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#isExposeNativeSession()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to expose the native Hibernate Session to\n\t * HibernateCallback code, or rather a Session proxy.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "boolean",
    "signature": "public boolean isExposeNativeSession()",
    "source_code": "\tpublic boolean isExposeNativeSession() {\n\t\treturn this.exposeNativeSession;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#load(entity,id)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "void",
    "signature": "public void load(Object entity, Serializable id)",
    "source_code": "\tpublic void load(Object entity, Serializable id) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.load(entity, id);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#load(entityClass,id)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 480
    },
    "return": "T",
    "signature": "public T load(Class<T> entityClass, Serializable id)",
    "source_code": "\tpublic <T> T load(Class<T> entityClass, Serializable id) throws DataAccessException {\n\t\treturn load(entityClass, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#load(entityClass,id,lockMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 485
    },
    "return": "T",
    "signature": "public T load(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic <T> T load(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode)"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#load(entityName,id)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 499
    },
    "return": "Object",
    "signature": "public Object load(String entityName, Serializable id)",
    "source_code": "\tpublic Object load(String entityName, Serializable id) throws DataAccessException {\n\t\treturn load(entityName, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#load(entityName,id,lockMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "Object",
    "signature": "public Object load(String entityName, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic Object load(String entityName, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.load(entityName, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.load(entityName, id);\n\t\t\t}\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#loadAll(entityClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass"
    ],
    "position": {
      "column": 1,
      "line": 517
    },
    "return": "List<T>",
    "signature": "public List<T> loadAll(Class<T> entityClass)",
    "source_code": "\tpublic <T> List<T> loadAll(Class<T> entityClass) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<T>>) session -> {\n\t\t\tCriteria criteria = session.createCriteria(entityClass);\n\t\t\tcriteria.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY);\n\t\t\tprepareCriteria(criteria);\n\t\t\treturn criteria.list();\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#lock(entity,lockMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 593
    },
    "return": "void",
    "signature": "public void lock(Object entity, LockMode lockMode)",
    "source_code": "\tpublic void lock(Object entity, LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#lock(entityName,entity,lockMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 601
    },
    "return": "void",
    "signature": "public void lock(String entityName, Object entity, LockMode lockMode)",
    "source_code": "\tpublic void lock(String entityName, Object entity, LockMode lockMode)"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#merge(entity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 720
    },
    "return": "T",
    "signature": "public T merge(T entity)",
    "source_code": "\tpublic <T> T merge(T entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn (T) session.merge(entity);\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#merge(entityName,entity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 729
    },
    "return": "T",
    "signature": "public T merge(String entityName, T entity)",
    "source_code": "\tpublic <T> T merge(String entityName, T entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn (T) session.merge(entityName, entity);\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#obtainSessionFactory()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the SessionFactory for actual use.\n\t * @return the SessionFactory (never {@code null})\n\t * @throws IllegalStateException in case of no SessionFactory set\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "SessionFactory",
    "signature": "protected SessionFactory obtainSessionFactory()",
    "source_code": "\tprotected final SessionFactory obtainSessionFactory() {\n\t\tSessionFactory sessionFactory = getSessionFactory();\n\t\tAssert.state(sessionFactory != null, \"No SessionFactory set\");\n\t\treturn sessionFactory;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#persist(entity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 701
    },
    "return": "void",
    "signature": "public void persist(Object entity)",
    "source_code": "\tpublic void persist(Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.persist(entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#persist(entityName,entity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 710
    },
    "return": "void",
    "signature": "public void persist(String entityName, Object entity)",
    "source_code": "\tpublic void persist(String entityName, Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.persist(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#prepareCriteria(criteria)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the given Criteria object, applying cache settings and/or\n\t * a transaction timeout.\n\t * @param criteria the Criteria object to prepare\n\t * @see #setCacheQueries\n\t * @see #setQueryCacheRegion\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "criteria"
    ],
    "position": {
      "column": 1,
      "line": 1060
    },
    "return": "void",
    "signature": "protected void prepareCriteria(Criteria criteria)",
    "source_code": "\tprotected void prepareCriteria(Criteria criteria) {\n\t\tif (isCacheQueries()) {\n\t\t\tcriteria.setCacheable(true);\n\t\t\tif (getQueryCacheRegion() != null) {\n\t\t\t\tcriteria.setCacheRegion(getQueryCacheRegion());\n\t\t\t}\n\t\t}\n\t\tif (getFetchSize() > 0) {\n\t\t\tcriteria.setFetchSize(getFetchSize());\n\t\t}\n\t\tif (getMaxResults() > 0) {\n\t\t\tcriteria.setMaxResults(getMaxResults());\n\t\t}\n\n\t\tResourceHolderSupport sessionHolder =\n\t\t\t\t(ResourceHolderSupport) TransactionSynchronizationManager.getResource(obtainSessionFactory());\n\t\tif (sessionHolder != null && sessionHolder.hasTimeout()) {\n\t\t\tcriteria.setTimeout(sessionHolder.getTimeToLiveInSeconds());\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#prepareQuery(queryObject)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the given Query object, applying cache settings and/or\n\t * a transaction timeout.\n\t * @param queryObject the Query object to prepare\n\t * @see #setCacheQueries\n\t * @see #setQueryCacheRegion\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "queryObject"
    ],
    "position": {
      "column": 1,
      "line": 1088
    },
    "return": "void",
    "signature": "protected void prepareQuery(Query<?> queryObject)",
    "source_code": "\tprotected void prepareQuery(Query<?> queryObject) {\n\t\tif (isCacheQueries()) {\n\t\t\tqueryObject.setCacheable(true);\n\t\t\tif (getQueryCacheRegion() != null) {\n\t\t\t\tqueryObject.setCacheRegion(getQueryCacheRegion());\n\t\t\t}\n\t\t}\n\t\tif (getFetchSize() > 0) {\n\t\t\tqueryObject.setFetchSize(getFetchSize());\n\t\t}\n\t\tif (getMaxResults() > 0) {\n\t\t\tqueryObject.setMaxResults(getMaxResults());\n\t\t}\n\n\t\tResourceHolderSupport sessionHolder =\n\t\t\t\t(ResourceHolderSupport) TransactionSynchronizationManager.getResource(obtainSessionFactory());\n\t\tif (sessionHolder != null && sessionHolder.hasTimeout()) {\n\t\t\tqueryObject.setTimeout(sessionHolder.getTimeToLiveInSeconds());\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#refresh(entity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 535
    },
    "return": "void",
    "signature": "public void refresh(Object entity)",
    "source_code": "\tpublic void refresh(Object entity) throws DataAccessException {\n\t\trefresh(entity, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#refresh(entity,lockMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 540
    },
    "return": "void",
    "signature": "public void refresh(Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void refresh(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.refresh(entity, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsession.refresh(entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#replicate(entity,replicationMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "replicationMode"
    ],
    "position": {
      "column": 1,
      "line": 681
    },
    "return": "void",
    "signature": "public void replicate(Object entity, ReplicationMode replicationMode)",
    "source_code": "\tpublic void replicate(Object entity, ReplicationMode replicationMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.replicate(entity, replicationMode);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#replicate(entityName,entity,replicationMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "replicationMode"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "void",
    "signature": "public void replicate(String entityName, Object entity, ReplicationMode replicationMode)",
    "source_code": "\tpublic void replicate(String entityName, Object entity, ReplicationMode replicationMode)"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#save(entity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 611
    },
    "return": "Serializable",
    "signature": "public Serializable save(Object entity)",
    "source_code": "\tpublic Serializable save(Object entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn session.save(entity);\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#save(entityName,entity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 619
    },
    "return": "Serializable",
    "signature": "public Serializable save(String entityName, Object entity)",
    "source_code": "\tpublic Serializable save(String entityName, Object entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn session.save(entityName, entity);\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#saveOrUpdate(entity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 663
    },
    "return": "void",
    "signature": "public void saveOrUpdate(Object entity)",
    "source_code": "\tpublic void saveOrUpdate(Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.saveOrUpdate(entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#saveOrUpdate(entityName,entity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 672
    },
    "return": "void",
    "signature": "public void saveOrUpdate(String entityName, Object entity)",
    "source_code": "\tpublic void saveOrUpdate(String entityName, Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.saveOrUpdate(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#setCacheQueries(cacheQueries)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to cache all queries executed by this template.\n\t * <p>If this is \"true\", all Query and Criteria objects created by\n\t * this template will be marked as cacheable (including all\n\t * queries through find methods).\n\t * <p>To specify the query region to be used for queries cached\n\t * by this template, set the \"queryCacheRegion\" property.\n\t * @see #setQueryCacheRegion\n\t * @see Query#setCacheable\n\t * @see Criteria#setCacheable\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheQueries"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "void",
    "signature": "public void setCacheQueries(boolean cacheQueries)",
    "source_code": "\tpublic void setCacheQueries(boolean cacheQueries) {\n\t\tthis.cacheQueries = cacheQueries;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#setCheckWriteOperations(checkWriteOperations)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to check that the Hibernate Session is not in read-only mode\n\t * in case of write operations (save/update/delete).\n\t * <p>Default is \"true\", for fail-fast behavior when attempting write operations\n\t * within a read-only transaction. Turn this off to allow save/update/delete\n\t * on a Session with flush mode MANUAL.\n\t * @see #checkWriteOperationAllowed\n\t * @see org.springframework.transaction.TransactionDefinition#isReadOnly\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "checkWriteOperations"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "public void setCheckWriteOperations(boolean checkWriteOperations)",
    "source_code": "\tpublic void setCheckWriteOperations(boolean checkWriteOperations) {\n\t\tthis.checkWriteOperations = checkWriteOperations;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#setExposeNativeSession(exposeNativeSession)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to expose the native Hibernate Session to\n\t * HibernateCallback code.\n\t * <p>Default is \"false\": a Session proxy will be returned, suppressing\n\t * {@code close} calls and automatically applying query cache\n\t * settings and transaction timeouts.\n\t * @see HibernateCallback\n\t * @see Session\n\t * @see #setCacheQueries\n\t * @see #setQueryCacheRegion\n\t * @see #prepareQuery\n\t * @see #prepareCriteria\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exposeNativeSession"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "void",
    "signature": "public void setExposeNativeSession(boolean exposeNativeSession)",
    "source_code": "\tpublic void setExposeNativeSession(boolean exposeNativeSession) {\n\t\tthis.exposeNativeSession = exposeNativeSession;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#setFetchSize(fetchSize)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the fetch size for this HibernateTemplate. This is important for processing\n\t * large result sets: Setting this higher than the default value will increase\n\t * processing speed at the cost of memory consumption; setting this lower can\n\t * avoid transferring row data that will never be read by the application.\n\t * <p>Default is 0, indicating to use the JDBC driver's default.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fetchSize"
    ],
    "position": {
      "column": 1,
      "line": 278
    },
    "return": "void",
    "signature": "public void setFetchSize(int fetchSize)",
    "source_code": "\tpublic void setFetchSize(int fetchSize) {\n\t\tthis.fetchSize = fetchSize;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#setFilterNames(filterNames)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set one or more names of Hibernate filters to be activated for all\n\t * Sessions that this accessor works with.\n\t * <p>Each of those filters will be enabled at the beginning of each\n\t * operation and correspondingly disabled at the end of the operation.\n\t * This will work for newly opened Sessions as well as for existing\n\t * Sessions (for example, within a transaction).\n\t * @see #enableFilters(Session)\n\t * @see Session#enableFilter(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filterNames"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "void",
    "signature": "public void setFilterNames(@Nullable String... filterNames)",
    "source_code": "\tpublic void setFilterNames(@Nullable String... filterNames) {\n\t\tthis.filterNames = filterNames;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#setMaxResults(maxResults)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the maximum number of rows for this HibernateTemplate. This is important\n\t * for processing subsets of large result sets, avoiding to read and hold\n\t * the entire result set in the database or in the JDBC driver if we're\n\t * never interested in the entire result in the first place (for example,\n\t * when performing searches that might return a large number of matches).\n\t * <p>Default is 0, indicating to use the JDBC driver's default.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "maxResults"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "void",
    "signature": "public void setMaxResults(int maxResults)",
    "source_code": "\tpublic void setMaxResults(int maxResults) {\n\t\tthis.maxResults = maxResults;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#setQueryCacheRegion(queryCacheRegion)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the cache region for queries executed by this template.\n\t * <p>If this is specified, it will be applied to all Query and Criteria objects\n\t * created by this template (including all queries through find methods).\n\t * <p>The cache region will not take effect unless queries created by this\n\t * template are configured to be cached via the \"cacheQueries\" property.\n\t * @see #setCacheQueries\n\t * @see Query#setCacheRegion\n\t * @see Criteria#setCacheRegion\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queryCacheRegion"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "void",
    "signature": "public void setQueryCacheRegion(@Nullable String queryCacheRegion)",
    "source_code": "\tpublic void setQueryCacheRegion(@Nullable String queryCacheRegion) {\n\t\tthis.queryCacheRegion = queryCacheRegion;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#setSessionFactory(sessionFactory)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Hibernate SessionFactory that should be used to create\n\t * Hibernate Sessions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionFactory"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void setSessionFactory(@Nullable SessionFactory sessionFactory)",
    "source_code": "\tpublic void setSessionFactory(@Nullable SessionFactory sessionFactory) {\n\t\tthis.sessionFactory = sessionFactory;\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#update(entity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 627
    },
    "return": "void",
    "signature": "public void update(Object entity)",
    "source_code": "\tpublic void update(Object entity) throws DataAccessException {\n\t\tupdate(entity, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#update(entity,lockMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "void",
    "signature": "public void update(Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void update(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.update(entity);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#update(entityName,entity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 644
    },
    "return": "void",
    "signature": "public void update(String entityName, Object entity)",
    "source_code": "\tpublic void update(String entityName, Object entity) throws DataAccessException {\n\t\tupdate(entityName, entity, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.HibernateTemplate#update(entityName,entity,lockMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 649
    },
    "return": "void",
    "signature": "public void update(String entityName, Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void update(String entityName, Object entity, @Nullable LockMode lockMode)"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBuilder#addAnnotatedClasses(annotatedClasses)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given annotated classes in a batch.\n\t * @see #addAnnotatedClass\n\t * @see #scanPackages\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedClasses"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "LocalSessionFactoryBuilder",
    "signature": "public LocalSessionFactoryBuilder addAnnotatedClasses(Class<?>... annotatedClasses)",
    "source_code": "\tpublic LocalSessionFactoryBuilder addAnnotatedClasses(Class<?>... annotatedClasses) {\n\t\tfor (Class<?> annotatedClass : annotatedClasses) {\n\t\t\taddAnnotatedClass(annotatedClass);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.orm.hibernate5.LocalSessionFactoryBuilder#setCurrentTenantIdentifierResolver(currentTenantIdentifierResolver)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Overridden to reliably pass a {@link CurrentTenantIdentifierResolver} to the SessionFactory.\n\t * @since 4.3.2\n\t * @see AvailableSettings#MULTI_TENANT_IDENTIFIER_RESOLVER\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "currentTenantIdentifierResolver"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "LocalSessionFactoryBuilder",
    "signature": "public LocalSessionFactoryBuilder setCurrentTenantIdentifierResolver(CurrentTenantIdentifierResolver<Object> currentTenantIdentifierResolver)",
    "source_code": "\tpublic LocalSessionFactoryBuilder setCurrentTenantIdentifierResolver(CurrentTenantIdentifierResolver<Object> currentTenantIdentifierResolver) {\n\t\tgetProperties().put(AvailableSettings.MULTI_TENANT_IDENTIFIER_RESOLVER, currentTenantIdentifierResolver);\n\t\tsuper.setCurrentTenantIdentifierResolver(currentTenantIdentifierResolver);\n\t\treturn this;\n\t}"
  },
  "org.springframework.orm.hibernate5.logger": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.orm.jpa.persistenceunit.<unknown>#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"Standard ClassFileTransformer wrapping JPA transformer: \" + this.classTransformer;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DEFAULT_PERSISTENCE_XML_LOCATION": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Default location of the {@code persistence.xml} file:\n\t * \"classpath*:META-INF/persistence.xml\".\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "signature": "public String DEFAULT_PERSISTENCE_XML_LOCATION",
    "source_code": "\tpublic static final String DEFAULT_PERSISTENCE_XML_LOCATION = \"classpath*:META-INF/\" + PERSISTENCE_XML_FILENAME;",
    "type": "String"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Default implementation of the {@link PersistenceUnitManager} interface.\n * Used as internal default by\n * {@link org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean}.\n *\n * <p>Supports standard JPA scanning for {@code persistence.xml} files,\n * with configurable file locations, JDBC DataSource lookup and load-time weaving.\n *\n * <p>Builds a persistence unit based on the state of a {@link PersistenceManagedTypes},\n * typically built using a {@link PersistenceManagedTypesScanner}.</p>\n *\n * <p>The default XML file location is {@code classpath*:META-INF/persistence.xml},\n * scanning for all matching files in the classpath (as defined in the JPA specification).\n * DataSource names are by default interpreted as JNDI names, and no load time weaving\n * is available (which requires weaving to be turned off in the persistence provider).\n *\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @since 2.0\n * @see #setPersistenceXmlLocations\n * @see #setDataSourceLookup\n * @see #setLoadTimeWeaver\n * @see org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#setPersistenceUnitManager\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public class DefaultPersistenceUnitManager",
    "source_code": "public class DefaultPersistenceUnitManager"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 422
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tif (this.loadTimeWeaver == null && InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) {\n\t\t\tthis.loadTimeWeaver = new InstrumentationLoadTimeWeaver(this.resourcePatternResolver.getClassLoader());\n\t\t}\n\t\tpreparePersistenceUnitInfos();\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#getDataSourceLookup()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JDBC DataSourceLookup that provides DataSources for the\n\t * persistence provider, resolving data source names in {@code persistence.xml}\n\t * against Spring-managed DataSource instances.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "DataSourceLookup",
    "signature": "public DataSourceLookup getDataSourceLookup()",
    "source_code": "\tpublic @Nullable DataSourceLookup getDataSourceLookup() {\n\t\treturn this.dataSourceLookup;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#getDefaultDataSource()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JDBC DataSource that the JPA persistence provider is supposed to use\n\t * for accessing the database if none has been specified in {@code persistence.xml}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "DataSource",
    "signature": "public DataSource getDefaultDataSource()",
    "source_code": "\tpublic @Nullable DataSource getDefaultDataSource() {\n\t\treturn this.defaultDataSource;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#getDefaultJtaDataSource()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JTA-aware DataSource that the JPA persistence provider is supposed to use\n\t * for accessing the database if none has been specified in {@code persistence.xml}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "DataSource",
    "signature": "public DataSource getDefaultJtaDataSource()",
    "source_code": "\tpublic @Nullable DataSource getDefaultJtaDataSource() {\n\t\treturn this.defaultJtaDataSource;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#getLoadTimeWeaver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Spring LoadTimeWeaver to use for class instrumentation according\n\t * to the JPA class transformer contract.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "LoadTimeWeaver",
    "signature": "public LoadTimeWeaver getLoadTimeWeaver()",
    "source_code": "\tpublic @Nullable LoadTimeWeaver getLoadTimeWeaver() {\n\t\treturn this.loadTimeWeaver;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#getPersistenceUnitInfo(persistenceUnitName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the specified PersistenceUnitInfo from this manager's cache\n\t * of processed persistence units, keeping it in the cache (i.e. not\n\t * 'obtaining' it for use but rather just accessing it for post-processing).\n\t * <p>This can be used in {@link #postProcessPersistenceUnitInfo} implementations,\n\t * detecting existing persistence units of the same name and potentially merging them.\n\t * @param persistenceUnitName the name of the desired persistence unit\n\t * @return the PersistenceUnitInfo in mutable form, or {@code null} if not available\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "persistenceUnitName"
    ],
    "position": {
      "column": 1,
      "line": 631
    },
    "return": "MutablePersistenceUnitInfo",
    "signature": "protected MutablePersistenceUnitInfo getPersistenceUnitInfo(String persistenceUnitName)",
    "source_code": "\tprotected final @Nullable MutablePersistenceUnitInfo getPersistenceUnitInfo(String persistenceUnitName) {\n\t\tPersistenceUnitInfo pui = this.persistenceUnitInfos.get(persistenceUnitName);\n\t\treturn (MutablePersistenceUnitInfo) pui;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#isPersistenceUnitOverrideAllowed()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether an override of a same-named persistence unit is allowed.\n\t * <p>Default is {@code false}. May be overridden to return {@code true},\n\t * for example if {@link #postProcessPersistenceUnitInfo} is able to handle that case.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 659
    },
    "return": "boolean",
    "signature": "protected boolean isPersistenceUnitOverrideAllowed()",
    "source_code": "\tprotected boolean isPersistenceUnitOverrideAllowed() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#obtainDefaultPersistenceUnitInfo()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 665
    },
    "return": "PersistenceUnitInfo",
    "signature": "public PersistenceUnitInfo obtainDefaultPersistenceUnitInfo()",
    "source_code": "\tpublic PersistenceUnitInfo obtainDefaultPersistenceUnitInfo() {\n\t\tif (this.persistenceUnitInfoNames.isEmpty()) {\n\t\t\tthrow new IllegalStateException(\"No persistence units parsed from \" +\n\t\t\t\t\tObjectUtils.nullSafeToString(this.persistenceXmlLocations));\n\t\t}\n\t\tif (this.persistenceUnitInfos.isEmpty()) {\n\t\t\tthrow new IllegalStateException(\"All persistence units from \" +\n\t\t\t\t\tObjectUtils.nullSafeToString(this.persistenceXmlLocations) + \" already obtained\");\n\t\t}\n\t\tif (this.persistenceUnitInfos.size() > 1 && this.defaultPersistenceUnitName != null) {\n\t\t\treturn obtainPersistenceUnitInfo(this.defaultPersistenceUnitName);\n\t\t}\n\t\tPersistenceUnitInfo pui = this.persistenceUnitInfos.values().iterator().next();\n\t\tthis.persistenceUnitInfos.clear();\n\t\treturn pui;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#obtainPersistenceUnitInfo(persistenceUnitName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "persistenceUnitName"
    ],
    "position": {
      "column": 1,
      "line": 683
    },
    "return": "PersistenceUnitInfo",
    "signature": "public PersistenceUnitInfo obtainPersistenceUnitInfo(String persistenceUnitName)",
    "source_code": "\tpublic PersistenceUnitInfo obtainPersistenceUnitInfo(String persistenceUnitName) {\n\t\tPersistenceUnitInfo pui = this.persistenceUnitInfos.remove(persistenceUnitName);\n\t\tif (pui == null) {\n\t\t\tif (!this.persistenceUnitInfoNames.contains(persistenceUnitName)) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"No persistence unit with name '\" + persistenceUnitName + \"' found\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Persistence unit with name '\" + persistenceUnitName + \"' already obtained\");\n\t\t\t}\n\t\t}\n\t\treturn pui;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#postProcessPersistenceUnitInfo(pui)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook method allowing subclasses to customize each PersistenceUnitInfo.\n\t * <p>The default implementation delegates to all registered PersistenceUnitPostProcessors.\n\t * It is usually preferable to register further entity classes, jar files etc there\n\t * rather than in a subclass of this manager, to be able to reuse the post-processors.\n\t * @param pui the chosen PersistenceUnitInfo, as read from {@code persistence.xml}.\n\t * Passed in as MutablePersistenceUnitInfo.\n\t * @see #setPersistenceUnitPostProcessors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "pui"
    ],
    "position": {
      "column": 1,
      "line": 645
    },
    "return": "void",
    "signature": "protected void postProcessPersistenceUnitInfo(MutablePersistenceUnitInfo pui)",
    "source_code": "\tprotected void postProcessPersistenceUnitInfo(MutablePersistenceUnitInfo pui) {\n\t\tPersistenceUnitPostProcessor[] postProcessors = getPersistenceUnitPostProcessors();\n\t\tif (postProcessors != null) {\n\t\t\tfor (PersistenceUnitPostProcessor postProcessor : postProcessors) {\n\t\t\t\tpostProcessor.postProcessPersistenceUnitInfo(pui);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#preparePersistenceUnitInfos()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the PersistenceUnitInfos according to the configuration\n\t * of this manager: scanning for {@code persistence.xml} files,\n\t * parsing all matching files, configuring and post-processing them.\n\t * <p>PersistenceUnitInfos cannot be obtained before this preparation\n\t * method has been invoked.\n\t * @see #obtainDefaultPersistenceUnitInfo()\n\t * @see #obtainPersistenceUnitInfo(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 439
    },
    "return": "void",
    "signature": "public void preparePersistenceUnitInfos()",
    "source_code": "\tpublic void preparePersistenceUnitInfos() {\n\t\tthis.persistenceUnitInfoNames.clear();\n\t\tthis.persistenceUnitInfos.clear();\n\n\t\tList<SpringPersistenceUnitInfo> puis = readPersistenceUnitInfos();\n\t\tfor (SpringPersistenceUnitInfo pui : puis) {\n\t\t\t// Determine default persistence unit root URL\n\t\t\tif (pui.getPersistenceUnitRootUrl() == null) {\n\t\t\t\tpui.setPersistenceUnitRootUrl(determineDefaultPersistenceUnitRootUrl());\n\t\t\t}\n\n\t\t\t// Override DataSource and shared cache mode\n\t\t\tif (pui.getJtaDataSource() == null && this.defaultJtaDataSource != null) {\n\t\t\t\tpui.setJtaDataSource(this.defaultJtaDataSource);\n\t\t\t}\n\t\t\tif (pui.getNonJtaDataSource() == null && this.defaultDataSource != null) {\n\t\t\t\tpui.setNonJtaDataSource(this.defaultDataSource);\n\t\t\t}\n\t\t\tif (this.sharedCacheMode != null) {\n\t\t\t\tpui.setSharedCacheMode(this.sharedCacheMode);\n\t\t\t}\n\t\t\t// Setting validationMode != ValidationMode.AUTO will ignore bean validation\n\t\t\t// during schema generation, see https://hibernate.atlassian.net/browse/HHH-12287\n\t\t\tif (this.validationMode != null) {\n\t\t\t\tpui.setValidationMode(this.validationMode);\n\t\t\t}\n\n\t\t\t// Initialize persistence unit ClassLoader\n\t\t\tif (this.loadTimeWeaver != null) {\n\t\t\t\tpui.init(this.loadTimeWeaver);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpui.init(this.resourcePatternResolver.getClassLoader());\n\t\t\t}\n\n\t\t\tpostProcessPersistenceUnitInfo(pui);\n\n\t\t\tString name = pui.getPersistenceUnitName();\n\t\t\tif (!this.persistenceUnitInfoNames.add(name) && !isPersistenceUnitOverrideAllowed()) {\n\t\t\t\tStringBuilder msg = new StringBuilder();\n\t\t\t\tmsg.append(\"Conflicting persistence unit definitions for name '\").append(name).append(\"': \");\n\t\t\t\tmsg.append(pui.getPersistenceUnitRootUrl()).append(\", \");\n\t\t\t\tmsg.append(this.persistenceUnitInfos.get(name).getPersistenceUnitRootUrl());\n\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t}\n\t\t\tthis.persistenceUnitInfos.put(name, pui);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#setDataSourceLookup(dataSourceLookup)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the JDBC DataSourceLookup that provides DataSources for the\n\t * persistence provider, resolving data source names in {@code persistence.xml}\n\t * against Spring-managed DataSource instances.\n\t * <p>Default is JndiDataSourceLookup, which resolves DataSource names as\n\t * JNDI names (as defined by standard JPA). Specify a BeanFactoryDataSourceLookup\n\t * instance if you want DataSource names to be resolved against Spring bean names.\n\t * <p>Alternatively, consider passing in a map from names to DataSource instances\n\t * via the \"dataSources\" property. If the {@code persistence.xml} file\n\t * does not define DataSource names at all, specify a default DataSource\n\t * via the \"defaultDataSource\" property.\n\t * @see org.springframework.jdbc.datasource.lookup.JndiDataSourceLookup\n\t * @see org.springframework.jdbc.datasource.lookup.BeanFactoryDataSourceLookup\n\t * @see #setDataSources\n\t * @see #setDefaultDataSource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataSourceLookup"
    ],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "void",
    "signature": "public void setDataSourceLookup(@Nullable DataSourceLookup dataSourceLookup)",
    "source_code": "\tpublic void setDataSourceLookup(@Nullable DataSourceLookup dataSourceLookup) {\n\t\tthis.dataSourceLookup = (dataSourceLookup != null ? dataSourceLookup : new JndiDataSourceLookup());\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#setDataSources(Map<String,dataSources)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the JDBC DataSources that the JPA persistence provider is supposed\n\t * to use for accessing the database, resolving data source names in\n\t * {@code persistence.xml} against Spring-managed DataSources.\n\t * <p>The specified Map needs to define data source names for specific DataSource\n\t * objects, matching the data source names used in {@code persistence.xml}.\n\t * If not specified, data source names will be resolved as JNDI names instead\n\t * (as defined by standard JPA).\n\t * @see org.springframework.jdbc.datasource.lookup.MapDataSourceLookup\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "dataSources"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "void",
    "signature": "public void setDataSources(Map<String, DataSource> dataSources)",
    "source_code": "\tpublic void setDataSources(Map<String, DataSource> dataSources) {\n\t\tthis.dataSourceLookup = new MapDataSourceLookup(dataSources);\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#setDefaultDataSource(defaultDataSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the JDBC DataSource that the JPA persistence provider is supposed to use\n\t * for accessing the database if none has been specified in {@code persistence.xml}.\n\t * This variant indicates no special transaction setup, i.e. typical resource-local.\n\t * <p>In JPA speak, a DataSource passed in here will be uses as \"nonJtaDataSource\"\n\t * on the PersistenceUnitInfo passed to the PersistenceProvider, provided that\n\t * none has been registered before.\n\t * @see jakarta.persistence.spi.PersistenceUnitInfo#getNonJtaDataSource()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultDataSource"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "void",
    "signature": "public void setDefaultDataSource(@Nullable DataSource defaultDataSource)",
    "source_code": "\tpublic void setDefaultDataSource(@Nullable DataSource defaultDataSource) {\n\t\tthis.defaultDataSource = defaultDataSource;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#setDefaultJtaDataSource(defaultJtaDataSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the JDBC DataSource that the JPA persistence provider is supposed to use\n\t * for accessing the database if none has been specified in {@code persistence.xml}.\n\t * This variant indicates that JTA is supposed to be used as transaction type.\n\t * <p>In JPA speak, a DataSource passed in here will be uses as \"jtaDataSource\"\n\t * on the PersistenceUnitInfo passed to the PersistenceProvider, provided that\n\t * none has been registered before.\n\t * @see jakarta.persistence.spi.PersistenceUnitInfo#getJtaDataSource()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultJtaDataSource"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "void",
    "signature": "public void setDefaultJtaDataSource(@Nullable DataSource defaultJtaDataSource)",
    "source_code": "\tpublic void setDefaultJtaDataSource(@Nullable DataSource defaultJtaDataSource) {\n\t\tthis.defaultJtaDataSource = defaultJtaDataSource;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#setDefaultPersistenceUnitName(defaultPersistenceUnitName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the name of the default persistence unit, if any. Default is \"default\".\n\t * <p>Primarily applied to a scanned persistence unit without {@code persistence.xml}.\n\t * Also applicable to selecting a default unit from several persistence units available.\n\t * @see #setPackagesToScan\n\t * @see #obtainDefaultPersistenceUnitInfo\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultPersistenceUnitName"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "void",
    "signature": "public void setDefaultPersistenceUnitName(String defaultPersistenceUnitName)",
    "source_code": "\tpublic void setDefaultPersistenceUnitName(String defaultPersistenceUnitName) {\n\t\tthis.defaultPersistenceUnitName = defaultPersistenceUnitName;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#setDefaultPersistenceUnitRootLocation(defaultPersistenceUnitRootLocation)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the default persistence unit root location, to be applied\n\t * if no unit-specific persistence unit root could be determined.\n\t * <p>Default is \"classpath:\", that is, the root of the current classpath\n\t * (nearest root directory). To be overridden if unit-specific resolution\n\t * does not work and the classpath root is not appropriate either.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultPersistenceUnitRootLocation"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "public void setDefaultPersistenceUnitRootLocation(String defaultPersistenceUnitRootLocation)",
    "source_code": "\tpublic void setDefaultPersistenceUnitRootLocation(String defaultPersistenceUnitRootLocation) {\n\t\tthis.defaultPersistenceUnitRootLocation = defaultPersistenceUnitRootLocation;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#setLoadTimeWeaver(loadTimeWeaver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the Spring LoadTimeWeaver to use for class instrumentation according\n\t * to the JPA class transformer contract.\n\t * <p>It is not required to specify a LoadTimeWeaver: Most providers will be able\n\t * to provide a subset of their functionality without class instrumentation as well,\n\t * or operate with their own VM agent specified on JVM startup. Furthermore,\n\t * DefaultPersistenceUnitManager falls back to an InstrumentationLoadTimeWeaver\n\t * if Spring's agent-based instrumentation is available at runtime.\n\t * <p>In terms of Spring-provided weaving options, the most important ones are\n\t * InstrumentationLoadTimeWeaver, which requires a Spring-specific (but very general)\n\t * VM agent specified on JVM startup, and ReflectiveLoadTimeWeaver, which interacts\n\t * with an underlying ClassLoader based on specific extended methods being available\n\t * on it (for example, interacting with Spring's TomcatInstrumentableClassLoader).\n\t * Consider using the {@code context:load-time-weaver} XML tag for creating\n\t * such a shared LoadTimeWeaver (autodetecting the environment by default).\n\t * @see org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver\n\t * @see org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "loadTimeWeaver"
    ],
    "position": {
      "column": 1,
      "line": 403
    },
    "return": "void",
    "signature": "public void setLoadTimeWeaver(@Nullable LoadTimeWeaver loadTimeWeaver)",
    "source_code": "\tpublic void setLoadTimeWeaver(@Nullable LoadTimeWeaver loadTimeWeaver) {\n\t\tthis.loadTimeWeaver = loadTimeWeaver;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#setManagedClassNameFilter(managedClassNameFilter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link ManagedClassNameFilter} to apply on entity classes discovered\n\t * using {@linkplain #setPackagesToScan(String...) classpath scanning}.\n\t * @param managedClassNameFilter a predicate to filter entity classes\n\t * @since 6.1.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "managedClassNameFilter"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "void",
    "signature": "public void setManagedClassNameFilter(ManagedClassNameFilter managedClassNameFilter)",
    "source_code": "\tpublic void setManagedClassNameFilter(ManagedClassNameFilter managedClassNameFilter) {\n\t\tthis.managedClassNameFilter = managedClassNameFilter;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#setManagedTypes(managedTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link PersistenceManagedTypes} to use to build the list of managed types\n\t * as an alternative to entity scanning.\n\t * @param managedTypes the managed types\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "managedTypes"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "void",
    "signature": "public void setManagedTypes(PersistenceManagedTypes managedTypes)",
    "source_code": "\tpublic void setManagedTypes(PersistenceManagedTypes managedTypes) {\n\t\tthis.managedTypes = managedTypes;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#setMappingResources(mappingResources)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify one or more mapping resources (equivalent to {@code <mapping-file>}\n\t * entries in {@code persistence.xml}) for the default persistence unit.\n\t * Can be used on its own or in combination with entity scanning in the classpath,\n\t * in both cases avoiding {@code persistence.xml}.\n\t * <p>Note that mapping resources must be relative to the classpath root,\n\t * for example, \"META-INF/mappings.xml\" or \"com/mycompany/repository/mappings.xml\",\n\t * so that they can be loaded through {@code ClassLoader.getResource}.\n\t * <p>If no explicit mapping resources have been specified next to\n\t * {@link #setPackagesToScan packages to scan}, this manager looks for a default\n\t * {@code META-INF/orm.xml} file in the classpath, registering it as a mapping\n\t * resource for the default unit if the mapping file is not co-located with a\n\t * {@code persistence.xml} file (in which case we assume it is only meant to be\n\t * used with the persistence units defined there, like in standard JPA).\n\t * <p>Note that specifying an empty array/list here suppresses the default\n\t * {@code META-INF/orm.xml} check. On the other hand, explicitly specifying\n\t * {@code META-INF/orm.xml} here will register that file even if it happens\n\t * to be co-located with a {@code persistence.xml} file.\n\t * @see #setDefaultPersistenceUnitName\n\t * @see #setPackagesToScan\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappingResources"
    ],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "void",
    "signature": "public void setMappingResources(String... mappingResources)",
    "source_code": "\tpublic void setMappingResources(String... mappingResources) {\n\t\tthis.mappingResources = mappingResources;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#setPackagesToScan(packagesToScan)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to use Spring-based scanning for entity classes in the classpath\n\t * instead of using JPA's standard scanning of jar files with {@code persistence.xml}\n\t * markers in them. In case of Spring-based scanning, no {@code persistence.xml}\n\t * is necessary; all you need to do is to specify base packages to search here.\n\t * <p>Default is none. Specify packages to search for autodetection of your entity\n\t * classes in the classpath. This is analogous to Spring's component-scan feature\n\t * ({@link org.springframework.context.annotation.ClassPathBeanDefinitionScanner}).\n\t * <p>Consider setting a {@link PersistenceManagedTypes} instead that allows the\n\t * scanning logic to be optimized by AOT processing.\n\t * <p>Such package scanning defines a \"default persistence unit\" in Spring, which\n\t * may live next to regularly defined units originating from {@code persistence.xml}.\n\t * Its name is determined by {@link #setDefaultPersistenceUnitName}: by default,\n\t * it's simply \"default\".\n\t * <p><b>Note: There may be limitations in comparison to regular JPA scanning.</b>\n\t * In particular, JPA providers may pick up annotated packages for provider-specific\n\t * annotations only when driven by {@code persistence.xml}. As of 4.1, Spring's\n\t * scan can detect annotated packages as well if supported by the given\n\t * {@link org.springframework.orm.jpa.JpaVendorAdapter} (for example, for Hibernate).\n\t * <p>If no explicit {@link #setMappingResources mapping resources} have been\n\t * specified in addition to these packages, this manager looks for a default\n\t * {@code META-INF/orm.xml} file in the classpath, registering it as a mapping\n\t * resource for the default unit if the mapping file is not co-located with a\n\t * {@code persistence.xml} file (in which case we assume it is only meant to be\n\t * used with the persistence units defined there, like in standard JPA).\n\t * @see #setManagedClassNameFilter(ManagedClassNameFilter)\n\t * @see #setManagedTypes(PersistenceManagedTypes)\n\t * @see #setDefaultPersistenceUnitName\n\t * @see #setMappingResources\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "packagesToScan"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "void",
    "signature": "public void setPackagesToScan(String... packagesToScan)",
    "source_code": "\tpublic void setPackagesToScan(String... packagesToScan) {\n\t\tthis.packagesToScan = packagesToScan;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#setPersistenceUnitPostProcessors(postProcessors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the PersistenceUnitPostProcessors to be applied to each\n\t * PersistenceUnitInfo that has been parsed by this manager.\n\t * <p>Such post-processors can, for example, register further entity classes and\n\t * jar files, in addition to the metadata read from {@code persistence.xml}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "postProcessors"
    ],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "void",
    "signature": "public void setPersistenceUnitPostProcessors(PersistenceUnitPostProcessor @Nullable ... postProcessors)",
    "source_code": "\tpublic void setPersistenceUnitPostProcessors(PersistenceUnitPostProcessor @Nullable ... postProcessors) {\n\t\tthis.persistenceUnitPostProcessors = postProcessors;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#setPersistenceXmlLocation(persistenceXmlLocation)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the location of the {@code persistence.xml} files to load.\n\t * These can be specified as Spring resource locations and/or location patterns.\n\t * <p>Default is \"classpath*:META-INF/persistence.xml\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "persistenceXmlLocation"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "public void setPersistenceXmlLocation(String persistenceXmlLocation)",
    "source_code": "\tpublic void setPersistenceXmlLocation(String persistenceXmlLocation) {\n\t\tthis.persistenceXmlLocations = new String[] {persistenceXmlLocation};\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#setPersistenceXmlLocations(persistenceXmlLocations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify multiple locations of {@code persistence.xml} files to load.\n\t * These can be specified as Spring resource locations and/or location patterns.\n\t * <p>Default is \"classpath*:META-INF/persistence.xml\".\n\t * @param persistenceXmlLocations an array of Spring resource Strings\n\t * identifying the location of the {@code persistence.xml} files to read\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "persistenceXmlLocations"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "void",
    "signature": "public void setPersistenceXmlLocations(String... persistenceXmlLocations)",
    "source_code": "\tpublic void setPersistenceXmlLocations(String... persistenceXmlLocations) {\n\t\tthis.persistenceXmlLocations = persistenceXmlLocations;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#setResourceLoader(resourceLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLoader"
    ],
    "position": {
      "column": 1,
      "line": 416
    },
    "return": "void",
    "signature": "public void setResourceLoader(ResourceLoader resourceLoader)",
    "source_code": "\tpublic void setResourceLoader(ResourceLoader resourceLoader) {\n\t\tthis.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader);\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#setSharedCacheMode(sharedCacheMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the JPA 2.0 shared cache mode for all of this manager's persistence\n\t * units, overriding any value in {@code persistence.xml} if set.\n\t * @since 4.0\n\t * @see jakarta.persistence.spi.PersistenceUnitInfo#getSharedCacheMode()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sharedCacheMode"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "public void setSharedCacheMode(SharedCacheMode sharedCacheMode)",
    "source_code": "\tpublic void setSharedCacheMode(SharedCacheMode sharedCacheMode) {\n\t\tthis.sharedCacheMode = sharedCacheMode;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#setValidationMode(validationMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the JPA 2.0 validation mode for all of this manager's persistence\n\t * units, overriding any value in {@code persistence.xml} if set.\n\t * @since 4.0\n\t * @see jakarta.persistence.spi.PersistenceUnitInfo#getValidationMode()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "validationMode"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "void",
    "signature": "public void setValidationMode(ValidationMode validationMode)",
    "source_code": "\tpublic void setValidationMode(ValidationMode validationMode) {\n\t\tthis.validationMode = validationMode;\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.ORIGINAL_DEFAULT_PERSISTENCE_UNIT_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Default persistence unit name.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "signature": "public String ORIGINAL_DEFAULT_PERSISTENCE_UNIT_NAME",
    "source_code": "\tpublic static final String ORIGINAL_DEFAULT_PERSISTENCE_UNIT_NAME = \"default\";",
    "type": "String"
  },
  "org.springframework.orm.jpa.persistenceunit.ORIGINAL_DEFAULT_PERSISTENCE_UNIT_ROOT_LOCATION": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Default location for the persistence unit root URL:\n\t * \"classpath:\", indicating the root of the classpath.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "signature": "public String ORIGINAL_DEFAULT_PERSISTENCE_UNIT_ROOT_LOCATION",
    "source_code": "\tpublic static final String ORIGINAL_DEFAULT_PERSISTENCE_UNIT_ROOT_LOCATION = \"classpath:\";",
    "type": "String"
  },
  "org.springframework.orm.jpa.persistenceunit.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter#determineDatabaseDialectName(database)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the Hibernate database dialect class name for the given target database.\n\t * <p>The default implementation covers the common community dialect for Derby.\n\t * @param database the target database\n\t * @return the Hibernate database dialect class name, or {@code null} if none found\n\t * @since 7.0\n\t * @see #determineDatabaseDialectClass\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "database"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "String",
    "signature": "protected String determineDatabaseDialectName(Database database)",
    "source_code": "\tprotected @Nullable String determineDatabaseDialectName(Database database) {\n\t\treturn switch (database) {\n\t\t\tcase DERBY -> \"org.hibernate.community.dialect.DerbyDialect\";\n\t\t\tdefault -> null;\n\t\t};\n\t}"
  },
  "org.springframework.oxm.jaxb.Jaxb2Marshaller#getPackagesToScan()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the packages to search for JAXB2 annotations.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "String[]",
    "signature": "public String[] getPackagesToScan()",
    "source_code": "\tpublic String[] getPackagesToScan() {\n\t\treturn this.packagesToScan;\n\t}"
  },
  "org.springframework.scheduling.annotation.AbstractAsyncConfiguration": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base {@code Configuration} class providing common structure for enabling\n * Spring's asynchronous method execution capability.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @since 3.1\n * @see EnableAsync\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public class AbstractAsyncConfiguration",
    "source_code": "public abstract class AbstractAsyncConfiguration implements ImportAware {\n\n\tprotected @Nullable AnnotationAttributes enableAsync;\n\n\tprotected @Nullable Supplier<? extends @Nullable Executor> executor;\n\n\tprotected @Nullable Supplier<? extends @Nullable AsyncUncaughtExceptionHandler> exceptionHandler;\n\n\n\t@Override\n\tpublic void setImportMetadata(AnnotationMetadata importMetadata) {\n\t\tthis.enableAsync = AnnotationAttributes.fromMap(\n\t\t\t\timportMetadata.getAnnotationAttributes(EnableAsync.class.getName()));\n\t\tif (this.enableAsync == null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"@EnableAsync is not present on importing class \" + importMetadata.getClassName());\n\t\t}\n\t}\n\n\t/**\n\t * Collect any {@link AsyncConfigurer} beans through autowiring.\n\t */\n\t@Autowired\n\t@SuppressWarnings(\"NullAway\") // https://github.com/uber/NullAway/issues/1126\n\tvoid setConfigurers(ObjectProvider<AsyncConfigurer> configurers) {\n\t\tSingletonSupplier<AsyncConfigurer> configurer = SingletonSupplier.ofNullable(() -> {\n\t\t\tList<AsyncConfigurer> candidates = configurers.stream().toList();\n\t\t\tif (CollectionUtils.isEmpty(candidates)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (candidates.size() > 1) {\n\t\t\t\tthrow new IllegalStateException(\"Only one AsyncConfigurer may exist\");\n\t\t\t}\n\t\t\treturn candidates.get(0);\n\t\t});\n\t\tthis.executor = adapt(configurer, AsyncConfigurer::getAsyncExecutor);\n\t\tthis.exceptionHandler = adapt(configurer, AsyncConfigurer::getAsyncUncaughtExceptionHandler);\n\t}\n\n\tprivate <T> Supplier<@Nullable T> adapt(SingletonSupplier<AsyncConfigurer> supplier, Function<AsyncConfigurer, @Nullable T> provider) {\n\t\treturn () -> {\n\t\t\tAsyncConfigurer configurer = supplier.get();\n\t\t\treturn (configurer != null ? provider.apply(configurer) : null);\n\t\t};\n\t}\n\n}"
  },
  "org.springframework.scheduling.annotation.AbstractAsyncConfiguration#setImportMetadata(importMetadata)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "importMetadata"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "void",
    "signature": "public void setImportMetadata(AnnotationMetadata importMetadata)",
    "source_code": "\tpublic void setImportMetadata(AnnotationMetadata importMetadata) {\n\t\tthis.enableAsync = AnnotationAttributes.fromMap(\n\t\t\t\timportMetadata.getAnnotationAttributes(EnableAsync.class.getName()));\n\t\tif (this.enableAsync == null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"@EnableAsync is not present on importing class \" + importMetadata.getClassName());\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Bean post-processor that automatically applies asynchronous invocation\n * behavior to any bean that carries the {@link Async} annotation at class or\n * method-level by adding a corresponding {@link AsyncAnnotationAdvisor} to the\n * exposed proxy (either an existing AOP proxy or a newly generated proxy that\n * implements all the target's interfaces).\n *\n * <p>The {@link TaskExecutor} responsible for the asynchronous execution may\n * be provided as well as the annotation type that indicates a method should be\n * invoked asynchronously. If no annotation type is specified, this post-\n * processor will detect both Spring's {@link Async @Async} annotation as well\n * as the EJB 3.1 {@code jakarta.ejb.Asynchronous} annotation.\n *\n * <p>For methods having a {@code void} return type, any exception thrown\n * during the asynchronous method invocation cannot be accessed by the\n * caller. An {@link AsyncUncaughtExceptionHandler} can be specified to handle\n * these cases.\n *\n * <p>Note: The underlying async advisor applies before existing advisors by default,\n * in order to switch to async execution as early as possible in the invocation chain.\n *\n * @author Mark Fisher\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @since 3.0\n * @see Async\n * @see AsyncAnnotationAdvisor\n * @see #setBeforeExistingAdvisors\n * @see ScheduledAnnotationBeanPostProcessor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "signature": "public class AsyncAnnotationBeanPostProcessor",
    "source_code": "public class AsyncAnnotationBeanPostProcessor extends AbstractBeanFactoryAwareAdvisingPostProcessor {\n\n\t/**\n\t * The default name of the {@link TaskExecutor} bean to pick up: \"taskExecutor\".\n\t * <p>Note that the initial lookup happens by type; this is just the fallback\n\t * in case of multiple executor beans found in the context.\n\t * @since 4.2\n\t * @see AnnotationAsyncExecutionInterceptor#DEFAULT_TASK_EXECUTOR_BEAN_NAME\n\t */\n\tpublic static final String DEFAULT_TASK_EXECUTOR_BEAN_NAME =\n\t\t\tAnnotationAsyncExecutionInterceptor.DEFAULT_TASK_EXECUTOR_BEAN_NAME;\n\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate @Nullable Supplier<? extends @Nullable Executor> executor;\n\n\tprivate @Nullable Supplier<? extends @Nullable AsyncUncaughtExceptionHandler> exceptionHandler;\n\n\tprivate @Nullable Class<? extends Annotation> asyncAnnotationType;\n\n\n\n\tpublic AsyncAnnotationBeanPostProcessor() {\n\t\tsetBeforeExistingAdvisors(true);\n\t}\n\n\n\t/**\n\t * Configure this post-processor with the given executor and exception handler suppliers,\n\t * applying the corresponding default if a supplier is not resolvable.\n\t * @since 5.1\n\t */\n\tpublic void configure(@Nullable Supplier<? extends @Nullable Executor> executor,\n\t\t\t@Nullable Supplier<? extends @Nullable AsyncUncaughtExceptionHandler> exceptionHandler) {\n\n\t\tthis.executor = executor;\n\t\tthis.exceptionHandler = exceptionHandler;\n\t}\n\n\t/**\n\t * Set the {@link Executor} to use when invoking methods asynchronously.\n\t * <p>If not specified, default executor resolution will apply: searching for a\n\t * unique {@link TaskExecutor} bean in the context, or for an {@link Executor}\n\t * bean named \"taskExecutor\" otherwise. If neither of the two is resolvable,\n\t * a local default executor will be created within the interceptor.\n\t * @see AnnotationAsyncExecutionInterceptor#getDefaultExecutor(BeanFactory)\n\t * @see #DEFAULT_TASK_EXECUTOR_BEAN_NAME\n\t */\n\tpublic void setExecutor(Executor executor) {\n\t\tthis.executor = SingletonSupplier.of(executor);\n\t}\n\n\t/**\n\t * Set the {@link AsyncUncaughtExceptionHandler} to use to handle uncaught\n\t * exceptions thrown by asynchronous method executions.\n\t * @since 4.1\n\t */\n\tpublic void setExceptionHandler(AsyncUncaughtExceptionHandler exceptionHandler) {\n\t\tthis.exceptionHandler = SingletonSupplier.of(exceptionHandler);\n\t}\n\n\t/**\n\t * Set the 'async' annotation type to be detected at either class or method\n\t * level. By default, both the {@link Async} annotation and the EJB 3.1\n\t * {@code jakarta.ejb.Asynchronous} annotation will be detected.\n\t * <p>This setter property exists so that developers can provide their own\n\t * (non-Spring-specific) annotation type to indicate that a method (or all\n\t * methods of a given class) should be invoked asynchronously.\n\t * @param asyncAnnotationType the desired annotation type\n\t */\n\tpublic void setAsyncAnnotationType(Class<? extends Annotation> asyncAnnotationType) {\n\t\tAssert.notNull(asyncAnnotationType, \"'asyncAnnotationType' must not be null\");\n\t\tthis.asyncAnnotationType = asyncAnnotationType;\n\t}\n\n\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tsuper.setBeanFactory(beanFactory);\n\n\t\tAsyncAnnotationAdvisor advisor = new AsyncAnnotationAdvisor(this.executor, this.exceptionHandler);\n\t\tif (this.asyncAnnotationType != null) {\n\t\t\tadvisor.setAsyncAnnotationType(this.asyncAnnotationType);\n\t\t}\n\t\tadvisor.setBeanFactory(beanFactory);\n\t\tthis.advisor = advisor;\n\t}\n\n}"
  },
  "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessor#configure(executor,exceptionHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure this post-processor with the given executor and exception handler suppliers,\n\t * applying the corresponding default if a supplier is not resolvable.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executor",
      "exceptionHandler"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void configure(@Nullable Supplier<? extends @Nullable Executor> executor,\n\t\t\t@Nullable Supplier<? extends @Nullable AsyncUncaughtExceptionHandler> exceptionHandler)",
    "source_code": "\tpublic void configure(@Nullable Supplier<? extends @Nullable Executor> executor,"
  },
  "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessor#setAsyncAnnotationType(asyncAnnotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the 'async' annotation type to be detected at either class or method\n\t * level. By default, both the {@link Async} annotation and the EJB 3.1\n\t * {@code jakarta.ejb.Asynchronous} annotation will be detected.\n\t * <p>This setter property exists so that developers can provide their own\n\t * (non-Spring-specific) annotation type to indicate that a method (or all\n\t * methods of a given class) should be invoked asynchronously.\n\t * @param asyncAnnotationType the desired annotation type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "asyncAnnotationType"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "public void setAsyncAnnotationType(Class<? extends Annotation> asyncAnnotationType)",
    "source_code": "\tpublic void setAsyncAnnotationType(Class<? extends Annotation> asyncAnnotationType) {\n\t\tAssert.notNull(asyncAnnotationType, \"'asyncAnnotationType' must not be null\");\n\t\tthis.asyncAnnotationType = asyncAnnotationType;\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessor#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tsuper.setBeanFactory(beanFactory);\n\n\t\tAsyncAnnotationAdvisor advisor = new AsyncAnnotationAdvisor(this.executor, this.exceptionHandler);\n\t\tif (this.asyncAnnotationType != null) {\n\t\t\tadvisor.setAsyncAnnotationType(this.asyncAnnotationType);\n\t\t}\n\t\tadvisor.setBeanFactory(beanFactory);\n\t\tthis.advisor = advisor;\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessor#setExceptionHandler(exceptionHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link AsyncUncaughtExceptionHandler} to use to handle uncaught\n\t * exceptions thrown by asynchronous method executions.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exceptionHandler"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "public void setExceptionHandler(AsyncUncaughtExceptionHandler exceptionHandler)",
    "source_code": "\tpublic void setExceptionHandler(AsyncUncaughtExceptionHandler exceptionHandler) {\n\t\tthis.exceptionHandler = SingletonSupplier.of(exceptionHandler);\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessor#setExecutor(executor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link Executor} to use when invoking methods asynchronously.\n\t * <p>If not specified, default executor resolution will apply: searching for a\n\t * unique {@link TaskExecutor} bean in the context, or for an {@link Executor}\n\t * bean named \"taskExecutor\" otherwise. If neither of the two is resolvable,\n\t * a local default executor will be created within the interceptor.\n\t * @see AnnotationAsyncExecutionInterceptor#getDefaultExecutor(BeanFactory)\n\t * @see #DEFAULT_TASK_EXECUTOR_BEAN_NAME\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executor"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "void",
    "signature": "public void setExecutor(Executor executor)",
    "source_code": "\tpublic void setExecutor(Executor executor) {\n\t\tthis.executor = SingletonSupplier.of(executor);\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncResult#addCallback(callback)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void addCallback(ListenableFutureCallback<? super V> callback)",
    "source_code": "\tpublic void addCallback(ListenableFutureCallback<? super V> callback) {\n\t\taddCallback(callback, callback);\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncResult#addCallback(successCallback,failureCallback)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "successCallback",
      "failureCallback"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "void",
    "signature": "public void addCallback(SuccessCallback<? super V> successCallback, FailureCallback failureCallback)",
    "source_code": "\tpublic void addCallback(SuccessCallback<? super V> successCallback, FailureCallback failureCallback) {\n\t\ttry {\n\t\t\tif (this.executionException != null) {\n\t\t\t\tfailureCallback.onFailure(exposedException(this.executionException));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsuccessCallback.onSuccess(this.value);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// Ignore\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncResult#completable()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "CompletableFuture<V>",
    "signature": "public CompletableFuture<V> completable()",
    "source_code": "\tpublic CompletableFuture<V> completable() {\n\t\tif (this.executionException != null) {\n\t\t\tCompletableFuture<V> completable = new CompletableFuture<>();\n\t\t\tcompletable.completeExceptionally(exposedException(this.executionException));\n\t\t\treturn completable;\n\t\t}\n\t\telse {\n\t\t\treturn CompletableFuture.completedFuture(this.value);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncResult#forExecutionException(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new async result which exposes the given exception as an\n\t * {@link ExecutionException} from {@link Future#get()}.\n\t * @param ex the exception to expose (either an pre-built {@link ExecutionException}\n\t * or a cause to be wrapped in an {@link ExecutionException})\n\t * @since 4.2\n\t * @see ExecutionException\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "Future<V>",
    "signature": "public Future<V> forExecutionException(Throwable ex)",
    "source_code": "\tpublic static <V> Future<V> forExecutionException(Throwable ex) {\n\t\treturn new AsyncResult<>(null, ex);\n\t}"
  },
  "org.springframework.scheduling.annotation.AsyncResult#forValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new async result which exposes the given value from {@link Future#get()}.\n\t * @param value the value to expose\n\t * @since 4.2\n\t * @see Future#get()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "Future<V>",
    "signature": "public Future<V> forValue(V value)",
    "source_code": "\tpublic static <V> Future<V> forValue(V value) {\n\t\treturn new AsyncResult<>(value, null);\n\t}"
  },
  "org.springframework.scheduling.annotation.DEFAULT_TASK_EXECUTOR_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The default name of the {@link TaskExecutor} bean to pick up: \"taskExecutor\".\n\t * <p>Note that the initial lookup happens by type; this is just the fallback\n\t * in case of multiple executor beans found in the context.\n\t * @since 4.2\n\t * @see AnnotationAsyncExecutionInterceptor#DEFAULT_TASK_EXECUTOR_BEAN_NAME\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "signature": "public String DEFAULT_TASK_EXECUTOR_BEAN_NAME",
    "source_code": "\tpublic static final String DEFAULT_TASK_EXECUTOR_BEAN_NAME =",
    "type": "String"
  },
  "org.springframework.scheduling.annotation.enableAsync": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "protected AnnotationAttributes enableAsync",
    "source_code": "\tprotected @Nullable AnnotationAttributes enableAsync;",
    "type": "AnnotationAttributes"
  },
  "org.springframework.scheduling.concurrent.ConcurrentTaskExecutor#submitListenable(task)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "ListenableFuture<T>",
    "signature": "public ListenableFuture<T> submitListenable(Callable<T> task)",
    "source_code": "\t\tpublic <T> ListenableFuture<T> submitListenable(Callable<T> task) {\n\t\t\treturn super.submitListenable(ManagedTaskBuilder.buildManagedTask(task, task.toString()));\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.ForkJoinPoolFactoryBean": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A Spring {@link FactoryBean} that builds and exposes a preconfigured {@link ForkJoinPool}.\n *\n * @author Juergen Hoeller\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 34
    },
    "signature": "public class ForkJoinPoolFactoryBean",
    "source_code": "public class ForkJoinPoolFactoryBean implements FactoryBean<ForkJoinPool>, InitializingBean, DisposableBean {\n\n\tprivate boolean commonPool = false;\n\n\tprivate int parallelism = Runtime.getRuntime().availableProcessors();\n\n\tprivate ForkJoinPool.ForkJoinWorkerThreadFactory threadFactory = ForkJoinPool.defaultForkJoinWorkerThreadFactory;\n\n\tprivate Thread.@Nullable UncaughtExceptionHandler uncaughtExceptionHandler;\n\n\tprivate boolean asyncMode = false;\n\n\tprivate int awaitTerminationSeconds = 0;\n\n\tprivate @Nullable ForkJoinPool forkJoinPool;\n\n\n\t/**\n\t * Set whether to expose JDK 8's 'common' {@link ForkJoinPool}.\n\t * <p>Default is \"false\", creating a local {@link ForkJoinPool} instance based on the\n\t * {@link #setParallelism \"parallelism\"}, {@link #setThreadFactory \"threadFactory\"},\n\t * {@link #setUncaughtExceptionHandler \"uncaughtExceptionHandler\"} and\n\t * {@link #setAsyncMode \"asyncMode\"} properties on this FactoryBean.\n\t * <p><b>NOTE:</b> Setting this flag to \"true\" effectively ignores all other\n\t * properties on this FactoryBean, reusing the shared common JDK {@link ForkJoinPool}\n\t * instead. This is a fine choice on JDK 8 but does remove the application's ability\n\t * to customize ForkJoinPool behavior, in particular the use of custom threads.\n\t * @since 3.2\n\t * @see java.util.concurrent.ForkJoinPool#commonPool()\n\t */\n\tpublic void setCommonPool(boolean commonPool) {\n\t\tthis.commonPool = commonPool;\n\t}\n\n\t/**\n\t * Specify the parallelism level. Default is {@link Runtime#availableProcessors()}.\n\t */\n\tpublic void setParallelism(int parallelism) {\n\t\tthis.parallelism = parallelism;\n\t}\n\n\t/**\n\t * Set the factory for creating new ForkJoinWorkerThreads.\n\t * Default is {@link ForkJoinPool#defaultForkJoinWorkerThreadFactory}.\n\t */\n\tpublic void setThreadFactory(ForkJoinPool.ForkJoinWorkerThreadFactory threadFactory) {\n\t\tthis.threadFactory = threadFactory;\n\t}\n\n\t/**\n\t * Set the handler for internal worker threads that terminate due to unrecoverable errors\n\t * encountered while executing tasks. Default is none.\n\t */\n\tpublic void setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler uncaughtExceptionHandler) {\n\t\tthis.uncaughtExceptionHandler = uncaughtExceptionHandler;\n\t}\n\n\t/**\n\t * Specify whether to establish a local first-in-first-out scheduling mode for forked tasks\n\t * that are never joined. This mode (asyncMode = {@code true}) may be more appropriate\n\t * than the default locally stack-based mode in applications in which worker threads only\n\t * process event-style asynchronous tasks. Default is {@code false}.\n\t */\n\tpublic void setAsyncMode(boolean asyncMode) {\n\t\tthis.asyncMode = asyncMode;\n\t}\n\n\t/**\n\t * Set the maximum number of seconds that this ForkJoinPool is supposed to block\n\t * on shutdown in order to wait for remaining tasks to complete their execution\n\t * before the rest of the container continues to shut down. This is particularly\n\t * useful if your remaining tasks are likely to need access to other resources\n\t * that are also managed by the container.\n\t * <p>By default, this ForkJoinPool won't wait for the termination of tasks at all.\n\t * It will continue to fully execute all ongoing tasks as well as all remaining\n\t * tasks in the queue, in parallel to the rest of the container shutting down.\n\t * In contrast, if you specify an await-termination period using this property,\n\t * this executor will wait for the given time (max) for the termination of tasks.\n\t * <p>Note that this feature works for the {@link #setCommonPool \"commonPool\"}\n\t * mode as well. The underlying ForkJoinPool won't actually terminate in that\n\t * case but will wait for all tasks to terminate.\n\t * @see java.util.concurrent.ForkJoinPool#shutdown()\n\t * @see java.util.concurrent.ForkJoinPool#awaitTermination\n\t */\n\tpublic void setAwaitTerminationSeconds(int awaitTerminationSeconds) {\n\t\tthis.awaitTerminationSeconds = awaitTerminationSeconds;\n\t}\n\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\tthis.forkJoinPool = (this.commonPool ? ForkJoinPool.commonPool() :\n\t\t\t\tnew ForkJoinPool(this.parallelism, this.threadFactory, this.uncaughtExceptionHandler, this.asyncMode));\n\t}\n\n\n\t@Override\n\tpublic @Nullable ForkJoinPool getObject() {\n\t\treturn this.forkJoinPool;\n\t}\n\n\t@Override\n\tpublic Class<?> getObjectType() {\n\t\treturn ForkJoinPool.class;\n\t}\n\n\t@Override\n\tpublic boolean isSingleton() {\n\t\treturn true;\n\t}\n\n\n\t@Override\n\tpublic void destroy() {\n\t\tif (this.forkJoinPool != null) {\n\t\t\t// Ignored for the common pool.\n\t\t\tthis.forkJoinPool.shutdown();\n\n\t\t\t// Wait for all tasks to terminate - works for the common pool as well.\n\t\t\tif (this.awaitTerminationSeconds > 0) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.forkJoinPool.awaitTermination(this.awaitTerminationSeconds, TimeUnit.SECONDS);\n\t\t\t\t}\n\t\t\t\tcatch (InterruptedException ex) {\n\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.scheduling.concurrent.ForkJoinPoolFactoryBean#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tthis.forkJoinPool = (this.commonPool ? ForkJoinPool.commonPool() :\n\t\t\t\tnew ForkJoinPool(this.parallelism, this.threadFactory, this.uncaughtExceptionHandler, this.asyncMode));\n\t}"
  },
  "org.springframework.scheduling.concurrent.ForkJoinPoolFactoryBean#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t\tif (this.forkJoinPool != null) {\n\t\t\t// Ignored for the common pool.\n\t\t\tthis.forkJoinPool.shutdown();\n\n\t\t\t// Wait for all tasks to terminate - works for the common pool as well.\n\t\t\tif (this.awaitTerminationSeconds > 0) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.forkJoinPool.awaitTermination(this.awaitTerminationSeconds, TimeUnit.SECONDS);\n\t\t\t\t}\n\t\t\t\tcatch (InterruptedException ex) {\n\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ForkJoinPoolFactoryBean#getObject()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "ForkJoinPool",
    "signature": "public ForkJoinPool getObject()",
    "source_code": "\tpublic @Nullable ForkJoinPool getObject() {\n\t\treturn this.forkJoinPool;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ForkJoinPoolFactoryBean#isSingleton()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "boolean",
    "signature": "public boolean isSingleton()",
    "source_code": "\tpublic boolean isSingleton() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ForkJoinPoolFactoryBean#setAsyncMode(asyncMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to establish a local first-in-first-out scheduling mode for forked tasks\n\t * that are never joined. This mode (asyncMode = {@code true}) may be more appropriate\n\t * than the default locally stack-based mode in applications in which worker threads only\n\t * process event-style asynchronous tasks. Default is {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "asyncMode"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "public void setAsyncMode(boolean asyncMode)",
    "source_code": "\tpublic void setAsyncMode(boolean asyncMode) {\n\t\tthis.asyncMode = asyncMode;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ForkJoinPoolFactoryBean#setAwaitTerminationSeconds(awaitTerminationSeconds)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the maximum number of seconds that this ForkJoinPool is supposed to block\n\t * on shutdown in order to wait for remaining tasks to complete their execution\n\t * before the rest of the container continues to shut down. This is particularly\n\t * useful if your remaining tasks are likely to need access to other resources\n\t * that are also managed by the container.\n\t * <p>By default, this ForkJoinPool won't wait for the termination of tasks at all.\n\t * It will continue to fully execute all ongoing tasks as well as all remaining\n\t * tasks in the queue, in parallel to the rest of the container shutting down.\n\t * In contrast, if you specify an await-termination period using this property,\n\t * this executor will wait for the given time (max) for the termination of tasks.\n\t * <p>Note that this feature works for the {@link #setCommonPool \"commonPool\"}\n\t * mode as well. The underlying ForkJoinPool won't actually terminate in that\n\t * case but will wait for all tasks to terminate.\n\t * @see java.util.concurrent.ForkJoinPool#shutdown()\n\t * @see java.util.concurrent.ForkJoinPool#awaitTermination\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "awaitTerminationSeconds"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "void",
    "signature": "public void setAwaitTerminationSeconds(int awaitTerminationSeconds)",
    "source_code": "\tpublic void setAwaitTerminationSeconds(int awaitTerminationSeconds) {\n\t\tthis.awaitTerminationSeconds = awaitTerminationSeconds;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ForkJoinPoolFactoryBean#setCommonPool(commonPool)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to expose JDK 8's 'common' {@link ForkJoinPool}.\n\t * <p>Default is \"false\", creating a local {@link ForkJoinPool} instance based on the\n\t * {@link #setParallelism \"parallelism\"}, {@link #setThreadFactory \"threadFactory\"},\n\t * {@link #setUncaughtExceptionHandler \"uncaughtExceptionHandler\"} and\n\t * {@link #setAsyncMode \"asyncMode\"} properties on this FactoryBean.\n\t * <p><b>NOTE:</b> Setting this flag to \"true\" effectively ignores all other\n\t * properties on this FactoryBean, reusing the shared common JDK {@link ForkJoinPool}\n\t * instead. This is a fine choice on JDK 8 but does remove the application's ability\n\t * to customize ForkJoinPool behavior, in particular the use of custom threads.\n\t * @since 3.2\n\t * @see java.util.concurrent.ForkJoinPool#commonPool()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "commonPool"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void setCommonPool(boolean commonPool)",
    "source_code": "\tpublic void setCommonPool(boolean commonPool) {\n\t\tthis.commonPool = commonPool;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ForkJoinPoolFactoryBean#setParallelism(parallelism)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the parallelism level. Default is {@link Runtime#availableProcessors()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parallelism"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "public void setParallelism(int parallelism)",
    "source_code": "\tpublic void setParallelism(int parallelism) {\n\t\tthis.parallelism = parallelism;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ForkJoinPoolFactoryBean#setThreadFactory(threadFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the factory for creating new ForkJoinWorkerThreads.\n\t * Default is {@link ForkJoinPool#defaultForkJoinWorkerThreadFactory}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "threadFactory"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void setThreadFactory(ForkJoinPool.ForkJoinWorkerThreadFactory threadFactory)",
    "source_code": "\tpublic void setThreadFactory(ForkJoinPool.ForkJoinWorkerThreadFactory threadFactory) {\n\t\tthis.threadFactory = threadFactory;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ForkJoinPoolFactoryBean#setUncaughtExceptionHandler(uncaughtExceptionHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the handler for internal worker threads that terminate due to unrecoverable errors\n\t * encountered while executing tasks. Default is none.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uncaughtExceptionHandler"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler uncaughtExceptionHandler)",
    "source_code": "\tpublic void setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler uncaughtExceptionHandler) {\n\t\tthis.uncaughtExceptionHandler = uncaughtExceptionHandler;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#submitListenable(task)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 431
    },
    "return": "ListenableFuture<T>",
    "signature": "public ListenableFuture<T> submitListenable(Callable<T> task)",
    "source_code": "\tpublic <T> ListenableFuture<T> submitListenable(Callable<T> task) {\n\t\tExecutorService executor = getThreadPoolExecutor();\n\t\ttry {\n\t\t\tListenableFutureTask<T> future = new ListenableFutureTask<>(task);\n\t\t\texecutor.execute(future);\n\t\t\treturn future;\n\t\t}\n\t\tcatch (RejectedExecutionException ex) {\n\t\t\tthrow new TaskRejectedException(executor, task, ex);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#cancelRemainingTask(task)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 394
    },
    "return": "void",
    "signature": "protected void cancelRemainingTask(Runnable task)",
    "source_code": "\tprotected void cancelRemainingTask(Runnable task) {\n\t\tsuper.cancelRemainingTask(task);\n\t\t// Cancel associated user-level ListenableFuture handle as well\n\t\tListenableFuture<?> listenableFuture = this.listenableFutureMap.get(task);\n\t\tif (listenableFuture != null) {\n\t\t\tlistenableFuture.cancel(true);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#submitListenable(task)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 374
    },
    "return": "ListenableFuture<T>",
    "signature": "public ListenableFuture<T> submitListenable(Callable<T> task)",
    "source_code": "\tpublic <T> ListenableFuture<T> submitListenable(Callable<T> task) {\n\t\tExecutorService executor = getScheduledExecutor();\n\t\ttry {\n\t\t\tListenableFutureTask<T> listenableFuture = new ListenableFutureTask<>(task);\n\t\t\texecuteAndTrack(executor, listenableFuture);\n\t\t\treturn listenableFuture;\n\t\t}\n\t\tcatch (RejectedExecutionException ex) {\n\t\t\tthrow new TaskRejectedException(executor, task, ex);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.quartz.SpringBeanJobFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Subclass of {@link AdaptableJobFactory} that also supports Spring-style\n * dependency injection on bean properties. This is essentially the direct\n * equivalent of Spring's {@link QuartzJobBean} in the shape of a Quartz\n * {@link org.quartz.spi.JobFactory}.\n *\n * <p>Applies scheduler context, job data map and trigger data map entries\n * as bean property values. If no matching bean property is found, the entry\n * is by default simply ignored. This is analogous to QuartzJobBean's behavior.\n *\n * <p>Compatible with Quartz 2.1.4 and higher, as of Spring 4.1.\n *\n * @author Juergen Hoeller\n * @since 2.0\n * @see SchedulerFactoryBean#setJobFactory\n * @see QuartzJobBean\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class SpringBeanJobFactory",
    "source_code": "public class SpringBeanJobFactory extends AdaptableJobFactory"
  },
  "org.springframework.scheduling.quartz.SpringBeanJobFactory#createJobInstance(bundle)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the job instance, populating it with property values taken\n\t * from the scheduler context, job data map and trigger data map.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bundle"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "Object",
    "signature": "protected Object createJobInstance(TriggerFiredBundle bundle)",
    "source_code": "\tprotected Object createJobInstance(TriggerFiredBundle bundle) throws Exception {\n\t\tObject job = (this.applicationContext != null ?\n\t\t\t\tthis.applicationContext.getAutowireCapableBeanFactory().createBean(bundle.getJobDetail().getJobClass()) :\n\t\t\t\tsuper.createJobInstance(bundle));\n\n\t\tif (isEligibleForPropertyPopulation(job)) {\n\t\t\tBeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(job);\n\t\t\tMutablePropertyValues pvs = new MutablePropertyValues();\n\t\t\tif (this.schedulerContext != null) {\n\t\t\t\tpvs.addPropertyValues(this.schedulerContext);\n\t\t\t}\n\t\t\tpvs.addPropertyValues(bundle.getJobDetail().getJobDataMap());\n\t\t\tpvs.addPropertyValues(bundle.getTrigger().getJobDataMap());\n\t\t\tif (this.ignoredUnknownProperties != null) {\n\t\t\t\tfor (String propName : this.ignoredUnknownProperties) {\n\t\t\t\t\tif (pvs.contains(propName) && !bw.isWritableProperty(propName)) {\n\t\t\t\t\t\tpvs.removePropertyValue(propName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbw.setPropertyValues(pvs);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbw.setPropertyValues(pvs, true);\n\t\t\t}\n\t\t}\n\n\t\treturn job;\n\t}"
  },
  "org.springframework.scheduling.quartz.SpringBeanJobFactory#isEligibleForPropertyPopulation(jobObject)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the given job object is eligible for having\n\t * its bean properties populated.\n\t * <p>The default implementation ignores {@link QuartzJobBean} instances,\n\t * which will inject bean properties themselves.\n\t * @param jobObject the job object to introspect\n\t * @see QuartzJobBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jobObject"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "boolean",
    "signature": "protected boolean isEligibleForPropertyPopulation(Object jobObject)",
    "source_code": "\tprotected boolean isEligibleForPropertyPopulation(Object jobObject) {\n\t\treturn (!(jobObject instanceof QuartzJobBean));\n\t}"
  },
  "org.springframework.scheduling.quartz.SpringBeanJobFactory#setApplicationContext(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void setApplicationContext(ApplicationContext applicationContext)",
    "source_code": "\tpublic void setApplicationContext(ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t}"
  },
  "org.springframework.scheduling.quartz.SpringBeanJobFactory#setIgnoredUnknownProperties(ignoredUnknownProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the unknown properties (not found in the bean) that should be ignored.\n\t * <p>Default is {@code null}, indicating that all unknown properties\n\t * should be ignored. Specify an empty array to throw an exception in case\n\t * of any unknown properties, or a list of property names that should be\n\t * ignored if there is no corresponding property found on the particular\n\t * job class (all other unknown properties will still trigger an exception).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ignoredUnknownProperties"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void setIgnoredUnknownProperties(String... ignoredUnknownProperties)",
    "source_code": "\tpublic void setIgnoredUnknownProperties(String... ignoredUnknownProperties) {\n\t\tthis.ignoredUnknownProperties = ignoredUnknownProperties;\n\t}"
  },
  "org.springframework.scheduling.quartz.SpringBeanJobFactory#setSchedulerContext(schedulerContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "schedulerContext"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void setSchedulerContext(SchedulerContext schedulerContext)",
    "source_code": "\tpublic void setSchedulerContext(SchedulerContext schedulerContext) {\n\t\tthis.schedulerContext = schedulerContext;\n\t}"
  },
  "org.springframework.scheduling.support.<unknown>#parseDaysOfMonth(value)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given value into a days of months {@code QuartzCronField},\n\t * the fourth entry of a cron expression.\n\t * <p>Expects a \"L\" or \"W\" in the given value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "QuartzCronField",
    "signature": "public QuartzCronField parseDaysOfMonth(String value)",
    "source_code": "\tpublic static QuartzCronField parseDaysOfMonth(String value) {\n\t\tint idx = value.lastIndexOf('L');\n\t\tif (idx != -1) {\n\t\t\tTemporalAdjuster adjuster;\n\t\t\tif (idx != 0) {\n\t\t\t\tthrow new IllegalArgumentException(\"Unrecognized characters before 'L' in '\" + value + \"'\");\n\t\t\t}\n\t\t\telse if (value.length() == 2 && value.charAt(1) == 'W') {  // \"LW\"\n\t\t\t\tadjuster = lastWeekdayOfMonth();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (value.length() == 1) {  // \"L\"\n\t\t\t\t\tadjuster = lastDayOfMonth();\n\t\t\t\t}\n\t\t\t\telse {  // \"L-[0-9]+\"\n\t\t\t\t\tint offset = Integer.parseInt(value, idx + 1, value.length(), 10);\n\t\t\t\t\tif (offset >= 0) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Offset '\" + offset + \" should be < 0 '\" + value + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tadjuster = lastDayWithOffset(offset);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new QuartzCronField(Type.DAY_OF_MONTH, adjuster, value);\n\t\t}\n\t\tidx = value.lastIndexOf('W');\n\t\tif (idx != -1) {\n\t\t\tif (idx == 0) {\n\t\t\t\tthrow new IllegalArgumentException(\"No day-of-month before 'W' in '\" + value + \"'\");\n\t\t\t}\n\t\t\telse if (idx != value.length() - 1) {\n\t\t\t\tthrow new IllegalArgumentException(\"Unrecognized characters after 'W' in '\" + value + \"'\");\n\t\t\t}\n\t\t\telse {  // \"[0-9]+W\"\n\t\t\t\tint dayOfMonth = Integer.parseInt(value, 0, idx, 10);\n\t\t\t\tdayOfMonth = Type.DAY_OF_MONTH.checkValidValue(dayOfMonth);\n\t\t\t\tTemporalAdjuster adjuster = weekdayNearestTo(dayOfMonth);\n\t\t\t\treturn new QuartzCronField(Type.DAY_OF_MONTH, adjuster, value);\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"No 'L' or 'W' found in '\" + value + \"'\");\n\t}"
  },
  "org.springframework.scheduling.support.<unknown>#parseDaysOfWeek(value)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given value into a days of week {@code QuartzCronField},\n\t * the sixth entry of a cron expression.\n\t * <p>Expects a \"L\" or \"#\" in the given value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "QuartzCronField",
    "signature": "public QuartzCronField parseDaysOfWeek(String value)",
    "source_code": "\tpublic static QuartzCronField parseDaysOfWeek(String value) {\n\t\tint idx = value.lastIndexOf('L');\n\t\tif (idx != -1) {\n\t\t\tif (idx != value.length() - 1) {\n\t\t\t\tthrow new IllegalArgumentException(\"Unrecognized characters after 'L' in '\" + value + \"'\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tTemporalAdjuster adjuster;\n\t\t\t\tif (idx == 0) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"No day-of-week before 'L' in '\" + value + \"'\");\n\t\t\t\t}\n\t\t\t\telse {  // \"[0-7]L\"\n\t\t\t\t\tDayOfWeek dayOfWeek = parseDayOfWeek(value.substring(0, idx));\n\t\t\t\t\tadjuster = lastInMonth(dayOfWeek);\n\t\t\t\t}\n\t\t\t\treturn new QuartzCronField(Type.DAY_OF_WEEK, Type.DAY_OF_MONTH, adjuster, value);\n\t\t\t}\n\t\t}\n\t\tidx = value.lastIndexOf('#');\n\t\tif (idx != -1) {\n\t\t\tif (idx == 0) {\n\t\t\t\tthrow new IllegalArgumentException(\"No day-of-week before '#' in '\" + value + \"'\");\n\t\t\t}\n\t\t\telse if (idx == value.length() - 1) {\n\t\t\t\tthrow new IllegalArgumentException(\"No ordinal after '#' in '\" + value + \"'\");\n\t\t\t}\n\t\t\t// \"[0-7]#[0-9]+\"\n\t\t\tDayOfWeek dayOfWeek = parseDayOfWeek(value.substring(0, idx));\n\t\t\tint ordinal = Integer.parseInt(value, idx + 1, value.length(), 10);\n\t\t\tif (ordinal <= 0) {\n\t\t\t\tthrow new IllegalArgumentException(\"Ordinal '\" + ordinal + \"' in '\" + value +\n\t\t\t\t\t\t\"' must be positive number \");\n\t\t\t}\n\t\t\tTemporalAdjuster adjuster = dayOfWeekInMonth(ordinal, dayOfWeek);\n\t\t\treturn new QuartzCronField(Type.DAY_OF_WEEK, Type.DAY_OF_MONTH, adjuster, value);\n\t\t}\n\t\tthrow new IllegalArgumentException(\"No 'L' or '#' found in '\" + value + \"'\");\n\t}"
  },
  "org.springframework.scheduling.support.Type": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Represents the type of cron field, i.e. seconds, minutes, hours,\n\t * day-of-month, month, day-of-week.\n\t */",
    "kind": "enum",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "signature": "protected enum Type",
    "source_code": "\tprotected enum Type {\n\n\t\tNANO(ChronoField.NANO_OF_SECOND, ChronoUnit.SECONDS),\n\t\tSECOND(ChronoField.SECOND_OF_MINUTE, ChronoUnit.MINUTES, ChronoField.NANO_OF_SECOND),\n\t\tMINUTE(ChronoField.MINUTE_OF_HOUR, ChronoUnit.HOURS, ChronoField.SECOND_OF_MINUTE, ChronoField.NANO_OF_SECOND),\n\t\tHOUR(ChronoField.HOUR_OF_DAY, ChronoUnit.DAYS, ChronoField.MINUTE_OF_HOUR, ChronoField.SECOND_OF_MINUTE, ChronoField.NANO_OF_SECOND),\n\t\tDAY_OF_MONTH(ChronoField.DAY_OF_MONTH, ChronoUnit.MONTHS, ChronoField.HOUR_OF_DAY, ChronoField.MINUTE_OF_HOUR, ChronoField.SECOND_OF_MINUTE, ChronoField.NANO_OF_SECOND),\n\t\tMONTH(ChronoField.MONTH_OF_YEAR, ChronoUnit.YEARS, ChronoField.DAY_OF_MONTH, ChronoField.HOUR_OF_DAY, ChronoField.MINUTE_OF_HOUR, ChronoField.SECOND_OF_MINUTE, ChronoField.NANO_OF_SECOND),\n\t\tDAY_OF_WEEK(ChronoField.DAY_OF_WEEK, ChronoUnit.WEEKS, ChronoField.HOUR_OF_DAY, ChronoField.MINUTE_OF_HOUR, ChronoField.SECOND_OF_MINUTE, ChronoField.NANO_OF_SECOND);\n\n\t\tprivate final ChronoField field;\n\n\t\tprivate final ChronoUnit higherOrder;\n\n\t\tprivate final ChronoField[] lowerOrders;\n\n\t\tType(ChronoField field, ChronoUnit higherOrder, ChronoField... lowerOrders) {\n\t\t\tthis.field = field;\n\t\t\tthis.higherOrder = higherOrder;\n\t\t\tthis.lowerOrders = lowerOrders;\n\t\t}\n\n\t\t/**\n\t\t * Return the value of this type for the given temporal.\n\t\t * @return the value of this type\n\t\t */\n\t\tpublic int get(Temporal date) {\n\t\t\treturn date.get(this.field);\n\t\t}\n\n\t\t/**\n\t\t * Return the general range of this type. For instance, this method\n\t\t * will return 0-31 for {@link #MONTH}.\n\t\t * @return the range of this field\n\t\t */\n\t\tpublic ValueRange range() {\n\t\t\treturn this.field.range();\n\t\t}\n\n\t\t/**\n\t\t * Check whether the given value is valid, i.e. whether it falls in\n\t\t * {@linkplain #range() range}.\n\t\t * @param value the value to check\n\t\t * @return the value that was passed in\n\t\t * @throws IllegalArgumentException if the given value is invalid\n\t\t */\n\t\tpublic int checkValidValue(int value) {\n\t\t\tif (this == DAY_OF_WEEK && value == 0) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\treturn this.field.checkValidIntValue(value);\n\t\t\t\t}\n\t\t\t\tcatch (DateTimeException ex) {\n\t\t\t\t\tthrow new IllegalArgumentException(ex.getMessage(), ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Elapse the given temporal for the difference between the current\n\t\t * value of this field and the goal value. Typically, the returned\n\t\t * temporal will have the given goal as the current value for this type,\n\t\t * but this is not the case for {@link #DAY_OF_MONTH}.\n\t\t * @param temporal the temporal to elapse\n\t\t * @param goal the goal value\n\t\t * @param <T> the type of temporal\n\t\t * @return the elapsed temporal, typically with {@code goal} as value\n\t\t * for this type.\n\t\t */\n\t\tpublic <T extends Temporal & Comparable<? super T>> T elapseUntil(T temporal, int goal) {\n\t\t\tint current = get(temporal);\n\t\t\tValueRange range = temporal.range(this.field);\n\t\t\tif (current < goal) {\n\t\t\t\tif (range.isValidIntValue(goal)) {\n\t\t\t\t\treturn cast(temporal.with(this.field, goal));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// goal is invalid, eg. 29th Feb, so roll forward\n\t\t\t\t\tlong amount = range.getMaximum() - current + 1;\n\t\t\t\t\treturn this.field.getBaseUnit().addTo(temporal, amount);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong amount = goal + range.getMaximum() - current + 1 - range.getMinimum();\n\t\t\t\treturn this.field.getBaseUnit().addTo(temporal, amount);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Roll forward the give temporal until it reaches the next higher\n\t\t * order field. Calling this method is equivalent to calling\n\t\t * {@link #elapseUntil(Temporal, int)} with goal set to the\n\t\t * minimum value of this field's range.\n\t\t * @param temporal the temporal to roll forward\n\t\t * @param <T> the type of temporal\n\t\t * @return the rolled forward temporal\n\t\t */\n\t\tpublic <T extends Temporal & Comparable<? super T>> T rollForward(T temporal) {\n\t\t\tT result = this.higherOrder.addTo(temporal, 1);\n\t\t\tValueRange range = result.range(this.field);\n\t\t\treturn this.field.adjustInto(result, range.getMinimum());\n\t\t}\n\n\t\t/**\n\t\t * Reset this and all lower order fields of the given temporal to their\n\t\t * minimum value. For instance for {@link #MINUTE}, this method\n\t\t * resets nanos, seconds, <strong>and</strong> minutes to 0.\n\t\t * @param temporal the temporal to reset\n\t\t * @param <T> the type of temporal\n\t\t * @return the reset temporal\n\t\t */\n\t\tpublic <T extends Temporal> T reset(T temporal) {\n\t\t\tfor (ChronoField lowerOrder : this.lowerOrders) {\n\t\t\t\tif (temporal.isSupported(lowerOrder)) {\n\t\t\t\t\ttemporal = lowerOrder.adjustInto(temporal, temporal.range(lowerOrder).getMinimum());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn temporal;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.field.toString();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.support.Type#checkValidValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Check whether the given value is valid, i.e. whether it falls in\n\t\t * {@linkplain #range() range}.\n\t\t * @param value the value to check\n\t\t * @return the value that was passed in\n\t\t * @throws IllegalArgumentException if the given value is invalid\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "int",
    "signature": "public int checkValidValue(int value)",
    "source_code": "\t\tpublic int checkValidValue(int value) {\n\t\t\tif (this == DAY_OF_WEEK && value == 0) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\treturn this.field.checkValidIntValue(value);\n\t\t\t\t}\n\t\t\t\tcatch (DateTimeException ex) {\n\t\t\t\t\tthrow new IllegalArgumentException(ex.getMessage(), ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.scheduling.support.Type#get(date)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return the value of this type for the given temporal.\n\t\t * @return the value of this type\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "date"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "int",
    "signature": "public int get(Temporal date)",
    "source_code": "\t\tpublic int get(Temporal date) {\n\t\t\treturn date.get(this.field);\n\t\t}"
  },
  "org.springframework.scheduling.support.Type#parseDaysOfMonth(value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given value into a days of months {@code CronField}, the fourth entry of a cron expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "CronField",
    "signature": "public CronField parseDaysOfMonth(String value)",
    "source_code": "\tpublic static CronField parseDaysOfMonth(String value) {\n\t\tif (!QuartzCronField.isQuartzDaysOfMonthField(value)) {\n\t\t\treturn BitsCronField.parseDaysOfMonth(value);\n\t\t}\n\t\telse {\n\t\t\treturn parseList(value, Type.DAY_OF_MONTH, (field, type) -> {\n\t\t\t\tif (QuartzCronField.isQuartzDaysOfMonthField(field)) {\n\t\t\t\t\treturn QuartzCronField.parseDaysOfMonth(field);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn BitsCronField.parseDaysOfMonth(field);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.support.Type#parseDaysOfWeek(value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given value into a days of week {@code CronField}, the sixth entry of a cron expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "CronField",
    "signature": "public CronField parseDaysOfWeek(String value)",
    "source_code": "\tpublic static CronField parseDaysOfWeek(String value) {\n\t\tvalue = replaceOrdinals(value, DAYS);\n\t\tif (!QuartzCronField.isQuartzDaysOfWeekField(value)) {\n\t\t\treturn BitsCronField.parseDaysOfWeek(value);\n\t\t}\n\t\telse {\n\t\t\treturn parseList(value, Type.DAY_OF_WEEK, (field, type) -> {\n\t\t\t\tif (QuartzCronField.isQuartzDaysOfWeekField(field)) {\n\t\t\t\t\treturn QuartzCronField.parseDaysOfWeek(field);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn BitsCronField.parseDaysOfWeek(field);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.support.Type#parseHours(value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given value into an hours {@code CronField}, the third entry of a cron expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "CronField",
    "signature": "public CronField parseHours(String value)",
    "source_code": "\tpublic static CronField parseHours(String value) {\n\t\treturn BitsCronField.parseHours(value);\n\t}"
  },
  "org.springframework.scheduling.support.Type#parseMinutes(value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given value into a minutes {@code CronField}, the second entry of a cron expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "CronField",
    "signature": "public CronField parseMinutes(String value)",
    "source_code": "\tpublic static CronField parseMinutes(String value) {\n\t\treturn BitsCronField.parseMinutes(value);\n\t}"
  },
  "org.springframework.scheduling.support.Type#parseMonth(value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given value into a month {@code CronField}, the fifth entry of a cron expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "CronField",
    "signature": "public CronField parseMonth(String value)",
    "source_code": "\tpublic static CronField parseMonth(String value) {\n\t\tvalue = replaceOrdinals(value, MONTHS);\n\t\treturn BitsCronField.parseMonth(value);\n\t}"
  },
  "org.springframework.scheduling.support.Type#parseSeconds(value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given value into a seconds {@code CronField}, the first entry of a cron expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "CronField",
    "signature": "public CronField parseSeconds(String value)",
    "source_code": "\tpublic static CronField parseSeconds(String value) {\n\t\treturn BitsCronField.parseSeconds(value);\n\t}"
  },
  "org.springframework.scheduling.support.Type#range()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return the general range of this type. For instance, this method\n\t\t * will return 0-31 for {@link #MONTH}.\n\t\t * @return the range of this field\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "ValueRange",
    "signature": "public ValueRange range()",
    "source_code": "\t\tpublic ValueRange range() {\n\t\t\treturn this.field.range();\n\t\t}"
  },
  "org.springframework.scheduling.support.Type#reset(temporal)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Reset this and all lower order fields of the given temporal to their\n\t\t * minimum value. For instance for {@link #MINUTE}, this method\n\t\t * resets nanos, seconds, <strong>and</strong> minutes to 0.\n\t\t * @param temporal the temporal to reset\n\t\t * @param <T> the type of temporal\n\t\t * @return the reset temporal\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "temporal"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "T",
    "signature": "public T reset(T temporal)",
    "source_code": "\t\tpublic <T extends Temporal> T reset(T temporal) {\n\t\t\tfor (ChronoField lowerOrder : this.lowerOrders) {\n\t\t\t\tif (temporal.isSupported(lowerOrder)) {\n\t\t\t\t\ttemporal = lowerOrder.adjustInto(temporal, temporal.range(lowerOrder).getMinimum());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn temporal;\n\t\t}"
  },
  "org.springframework.scheduling.support.Type#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn this.field.toString();\n\t\t}"
  },
  "org.springframework.scheduling.support.Type#type()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "Type",
    "signature": "protected Type type()",
    "source_code": "\tprotected Type type() {\n\t\treturn this.type;\n\t}"
  },
  "org.springframework.scheduling.support.Type#zeroNanos()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code CronField} enabled for 0 nanoseconds.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "CronField",
    "signature": "public CronField zeroNanos()",
    "source_code": "\tpublic static CronField zeroNanos() {\n\t\treturn BitsCronField.ZERO_NANOS;\n\t}"
  },
  "org.springframework.scripting.ScriptFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Script definition interface, encapsulating the configuration\n * of a specific script as well as a factory method for\n * creating the actual scripted Java {@code Object}.\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @since 2.0\n * @see #getScriptSourceLocator\n * @see #getScriptedObject\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 34
    },
    "signature": "public interface ScriptFactory",
    "source_code": "public interface ScriptFactory {\n\n\t/**\n\t * Return a locator that points to the source of the script.\n\t * Interpreted by the post-processor that actually creates the script.\n\t * <p>Typical supported locators are Spring resource locations\n\t * (such as \"file:C:/myScript.bsh\" or \"classpath:myPackage/myScript.bsh\")\n\t * and inline scripts (\"inline:myScriptText...\").\n\t * @return the script source locator\n\t * @see org.springframework.scripting.support.ScriptFactoryPostProcessor#convertToScriptSource\n\t * @see org.springframework.core.io.ResourceLoader\n\t */\n\tString getScriptSourceLocator();\n\n\t/**\n\t * Return the business interfaces that the script is supposed to implement.\n\t * <p>Can return {@code null} if the script itself determines\n\t * its Java interfaces (such as in the case of Groovy).\n\t * @return the interfaces for the script\n\t */\n\tClass<?> @Nullable [] getScriptInterfaces();\n\n\t/**\n\t * Return whether the script requires a config interface to be\n\t * generated for it. This is typically the case for scripts that\n\t * do not determine Java signatures themselves, with no appropriate\n\t * config interface specified in {@code getScriptInterfaces()}.\n\t * @return whether the script requires a generated config interface\n\t * @see #getScriptInterfaces()\n\t */\n\tboolean requiresConfigInterface();\n\n\t/**\n\t * Factory method for creating the scripted Java object.\n\t * <p>Implementations are encouraged to cache script metadata such as\n\t * a generated script class. Note that this method may be invoked\n\t * concurrently and must be implemented in a thread-safe fashion.\n\t * @param scriptSource the actual ScriptSource to retrieve\n\t * the script source text from (never {@code null})\n\t * @param actualInterfaces the actual interfaces to expose,\n\t * including script interfaces as well as a generated config interface\n\t * (if applicable; may be {@code null})\n\t * @return the scripted Java object\n\t * @throws IOException if script retrieval failed\n\t * @throws ScriptCompilationException if script compilation failed\n\t */\n\t@Nullable Object getScriptedObject(ScriptSource scriptSource, Class<?> @Nullable ... actualInterfaces)\n\t\t\tthrows IOException, ScriptCompilationException;\n\n\t/**\n\t * Determine the type of the scripted Java object.\n\t * <p>Implementations are encouraged to cache script metadata such as\n\t * a generated script class. Note that this method may be invoked\n\t * concurrently and must be implemented in a thread-safe fashion.\n\t * @param scriptSource the actual ScriptSource to retrieve\n\t * the script source text from (never {@code null})\n\t * @return the type of the scripted Java object, or {@code null}\n\t * if none could be determined\n\t * @throws IOException if script retrieval failed\n\t * @throws ScriptCompilationException if script compilation failed\n\t * @since 2.0.3\n\t */\n\t@Nullable Class<?> getScriptedObjectType(ScriptSource scriptSource)\n\t\t\tthrows IOException, ScriptCompilationException;\n\n\t/**\n\t * Determine whether a refresh is required (for example, through\n\t * ScriptSource's {@code isModified()} method).\n\t * @param scriptSource the actual ScriptSource to retrieve\n\t * the script source text from (never {@code null})\n\t * @return whether a fresh {@link #getScriptedObject} call is required\n\t * @since 2.5.2\n\t * @see ScriptSource#isModified()\n\t */\n\tboolean requiresScriptedObjectRefresh(ScriptSource scriptSource);\n\n}"
  },
  "org.springframework.test.context.AnnotationDescriptor": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Descriptor for an {@link Annotation}, including the {@linkplain\n\t * #getDeclaringClass() class} on which the annotation is <em>declared</em>\n\t * as well as the {@linkplain #getAnnotation() merged annotation} instance.\n\t * <p>If the annotation is used as a meta-annotation, the <em>root declaring\n\t * class</em> is not directly annotated with the annotation but rather\n\t * indirectly via a composed annotation.\n\t * <p>Given the following example, if we are searching for the {@code @Transactional}\n\t * annotation <em>on</em> the {@code TransactionalTests} class, then the\n\t * properties of the {@code AnnotationDescriptor} would be as follows.\n\t * <ul>\n\t * <li>rootDeclaringClass: {@code TransactionalTests} class object</li>\n\t * <li>declaringClass: {@code TransactionalTests} class object</li>\n\t * <li>annotation: instance of the {@code Transactional} annotation</li>\n\t * </ul>\n\t * <p><pre style=\"code\">\n\t * &#064;Transactional\n\t * &#064;ContextConfiguration({\"/test-datasource.xml\", \"/repository-config.xml\"})\n\t * public class TransactionalTests { }\n\t * </pre>\n\t * <p>Given the following example, if we are searching for the {@code @Transactional}\n\t * annotation <em>on</em> the {@code UserRepositoryTests} class, then the\n\t * properties of the {@code AnnotationDescriptor} would be as follows.\n\t * <ul>\n\t * <li>rootDeclaringClass: {@code UserRepositoryTests} class object</li>\n\t * <li>declaringClass: {@code RepositoryTests} class object</li>\n\t * <li>annotation: instance of the {@code Transactional} annotation</li>\n\t * </ul>\n\t * <p><pre style=\"code\">\n\t * &#064;Transactional\n\t * &#064;ContextConfiguration({\"/test-datasource.xml\", \"/repository-config.xml\"})\n\t * &#064;Retention(RetentionPolicy.RUNTIME)\n\t * public &#064;interface RepositoryTests { }\n\t *\n\t * &#064;RepositoryTests\n\t * public class UserRepositoryTests { }\n\t * </pre>\n\t *\n\t * @param <T> the annotation type\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 495
    },
    "signature": "public class AnnotationDescriptor",
    "source_code": "\tpublic static class AnnotationDescriptor<T extends Annotation> {\n\n\t\tprivate final Class<?> rootDeclaringClass;\n\n\t\tprivate final Class<?> declaringClass;\n\n\t\tprivate final T annotation;\n\n\t\tAnnotationDescriptor(Class<?> rootDeclaringClass, T annotation) {\n\t\t\tthis(rootDeclaringClass, rootDeclaringClass, annotation);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tAnnotationDescriptor(Class<?> rootDeclaringClass, Class<?> declaringClass, T annotation) {\n\t\t\tAssert.notNull(rootDeclaringClass, \"'rootDeclaringClass' must not be null\");\n\t\t\tAssert.notNull(declaringClass, \"'declaringClass' must not be null\");\n\t\t\tAssert.notNull(annotation, \"Annotation must not be null\");\n\t\t\tthis.rootDeclaringClass = rootDeclaringClass;\n\t\t\tthis.declaringClass = declaringClass;\n\t\t\tT mergedAnnotation = (T) AnnotatedElementUtils.findMergedAnnotation(\n\t\t\t\t\trootDeclaringClass, annotation.annotationType());\n\t\t\tAssert.state(mergedAnnotation != null,\n\t\t\t\t\t() -> \"Failed to find merged annotation for \" + annotation);\n\t\t\tthis.annotation = mergedAnnotation;\n\t\t}\n\n\t\tpublic Class<?> getRootDeclaringClass() {\n\t\t\treturn this.rootDeclaringClass;\n\t\t}\n\n\t\tpublic Class<?> getDeclaringClass() {\n\t\t\treturn this.declaringClass;\n\t\t}\n\n\t\t/**\n\t\t * Get the merged annotation for this descriptor.\n\t\t */\n\t\tpublic T getAnnotation() {\n\t\t\treturn this.annotation;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tClass<T> getAnnotationType() {\n\t\t\treturn (Class<T>) this.annotation.annotationType();\n\t\t}\n\n\t\t/**\n\t\t * Find the next {@link AnnotationDescriptor} for the specified annotation\n\t\t * type in the hierarchy above the {@linkplain #getRootDeclaringClass()\n\t\t * root declaring class} of this descriptor.\n\t\t * <p>If a corresponding annotation is found in the superclass hierarchy\n\t\t * of the root declaring class, that will be returned. Otherwise, an\n\t\t * attempt will be made to find a corresponding annotation in the\n\t\t * {@linkplain Class#getEnclosingClass() enclosing class} hierarchy of\n\t\t * the root declaring class if {@linkplain #searchEnclosingClass appropriate}.\n\t\t * @return the next corresponding annotation descriptor if the annotation\n\t\t * was found; otherwise {@code null}\n\t\t */\n\t\tpublic @Nullable AnnotationDescriptor<T> next() {\n\t\t\t// Declared on a superclass?\n\t\t\tAnnotationDescriptor<T> descriptor =\n\t\t\t\t\tfindAnnotationDescriptor(getRootDeclaringClass().getSuperclass(), getAnnotationType());\n\t\t\t// Declared on an enclosing class of an inner class?\n\t\t\tif (descriptor == null && searchEnclosingClass(getRootDeclaringClass())) {\n\t\t\t\tdescriptor = findAnnotationDescriptor(getRootDeclaringClass().getEnclosingClass(), getAnnotationType());\n\t\t\t}\n\t\t\treturn descriptor;\n\t\t}\n\n\t\t/**\n\t\t * Find <strong>all</strong> annotations of the specified annotation type\n\t\t * that are present or meta-present on the {@linkplain #getRootDeclaringClass()\n\t\t * root declaring class} of this descriptor or on any interfaces that the\n\t\t * root declaring class implements.\n\t\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t\t * or an empty set if none were found\n\t\t */\n\t\tpublic Set<T> findAllLocalMergedAnnotations() {\n\t\t\tSearchStrategy searchStrategy = SearchStrategy.TYPE_HIERARCHY;\n\t\t\treturn MergedAnnotations.from(getRootDeclaringClass(), searchStrategy, RepeatableContainers.none())\n\t\t\t\t\t.stream(getAnnotationType())\n\t\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t\t}\n\n\t\t/**\n\t\t * Provide a textual representation of this {@code AnnotationDescriptor}.\n\t\t */\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn new ToStringCreator(this, new DefaultToStringStyler(new SimpleValueStyler()))\n\t\t\t\t\t.append(\"rootDeclaringClass\", this.rootDeclaringClass)\n\t\t\t\t\t.append(\"declaringClass\", this.declaringClass)\n\t\t\t\t\t.append(\"annotation\", this.annotation)\n\t\t\t\t\t.toString();\n\t\t}\n\t}"
  },
  "org.springframework.test.context.TestContextAnnotationUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code TestContextAnnotationUtils} is a collection of utility methods that\n * complements the standard support already available in {@link AnnotationUtils}\n * and {@link AnnotatedElementUtils}, while transparently honoring\n * {@link NestedTestConfiguration @NestedTestConfiguration} semantics.\n *\n * <p>Mainly for internal use within the <em>Spring TestContext Framework</em>\n * but also supported for third-party integrations with the TestContext framework.\n *\n * <p>Whereas {@code AnnotationUtils} and {@code AnnotatedElementUtils} provide\n * utilities for <em>getting</em> or <em>finding</em> annotations,\n * {@code TestContextAnnotationUtils} goes a step further by providing support\n * for determining the <em>root class</em> on which an annotation is declared,\n * either directly or indirectly via a <em>composed annotation</em>. This\n * additional information is encapsulated in an {@link AnnotationDescriptor}.\n *\n * <p>The additional information provided by an {@code AnnotationDescriptor} is\n * required by the <em>Spring TestContext Framework</em> in order to be able to\n * support class inheritance and enclosing class hierarchy traversals for\n * annotations such as {@link ContextConfiguration @ContextConfiguration},\n * {@link TestExecutionListeners @TestExecutionListeners}, and\n * {@link ActiveProfiles @ActiveProfiles} which offer support for merging and\n * overriding various <em>inherited</em> annotation attributes &mdash; for\n * example, {@link ContextConfiguration#inheritLocations}.\n *\n * @author Sam Brannen\n * @since 5.3, though originally since 4.0 as {@code org.springframework.test.util.MetaAnnotationUtils}\n * @see AnnotationUtils\n * @see AnnotatedElementUtils\n * @see AnnotationDescriptor\n * @see NestedTestConfiguration\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "signature": "public class TestContextAnnotationUtils",
    "source_code": "public abstract class TestContextAnnotationUtils {\n\n\tprivate static final ConcurrentLruCache<Class<?>, EnclosingConfiguration> cachedEnclosingConfigurationModes =\n\t\t\tnew ConcurrentLruCache<>(32, TestContextAnnotationUtils::lookUpEnclosingConfiguration);\n\n\tprivate static volatile @Nullable EnclosingConfiguration defaultEnclosingConfigurationMode;\n\n\n\t/**\n\t * Determine if an annotation of the specified {@code annotationType} is\n\t * present or meta-present on the supplied {@link Class} according to the\n\t * search algorithm used in {@link #findMergedAnnotation(Class, Class)}.\n\t * <p>If this method returns {@code true}, then {@code findMergedAnnotation(...)}\n\t * will return a non-null value.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * @return {@code true} if a matching annotation is present\n\t * @since 5.3.3\n\t * @see #findMergedAnnotation(Class, Class)\n\t */\n\tpublic static boolean hasAnnotation(Class<?> clazz, Class<? extends Annotation> annotationType) {\n\t\treturn MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.withEnclosingClasses(TestContextAnnotationUtils::searchEnclosingClass)\n\t\t\t\t.from(clazz)\n\t\t\t\t.isPresent(annotationType);\n\t}\n\n\t/**\n\t * Find the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied class, merge that\n\t * annotation's attributes with <em>matching</em> attributes from annotations\n\t * in lower levels of the annotation hierarchy, and synthesize the result back\n\t * into an annotation of the specified {@code annotationType}.\n\t * <p>In the context of this method, the term \"above\" means within the\n\t * {@linkplain Class#getSuperclass() superclass} hierarchy or within the\n\t * {@linkplain Class#getEnclosingClass() enclosing class} hierarchy of the\n\t * supplied class. The enclosing class hierarchy will only be searched\n\t * according to {@link NestedTestConfiguration @NestedTestConfiguration}\n\t * semantics.\n\t * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\n\t * are fully supported, both within a single annotation and within annotation\n\t * hierarchies.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @see AnnotatedElementUtils#findMergedAnnotation(java.lang.reflect.AnnotatedElement, Class)\n\t * @see #findAnnotationDescriptor(Class, Class)\n\t * @see #searchEnclosingClass(Class)\n\t */\n\tpublic static <T extends Annotation> @Nullable T findMergedAnnotation(Class<?> clazz, Class<T> annotationType) {\n\t\treturn findMergedAnnotation(clazz, annotationType, TestContextAnnotationUtils::searchEnclosingClass);\n\t}\n\n\tprivate static <T extends Annotation> @Nullable T findMergedAnnotation(Class<?> clazz, Class<T> annotationType,\n\t\t\tPredicate<Class<?>> searchEnclosingClass) {\n\n\t\treturn MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.withEnclosingClasses(searchEnclosingClass)\n\t\t\t\t.from(clazz)\n\t\t\t\t.get(annotationType)\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}\n\n\t/**\n\t * Get all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied class; and for\n\t * each annotation found, merge that annotation's attributes with <em>matching</em>\n\t * attributes from annotations in lower levels of the annotation hierarchy and\n\t * synthesize the results back into an annotation of the specified {@code annotationType}.\n\t * <p>This method will find {@link java.lang.annotation.Inherited @Inherited}\n\t * annotations declared on superclasses if the supplied class does not have\n\t * any local declarations of the repeatable annotation. If no inherited\n\t * annotations are found, this method will search within the\n\t * {@linkplain Class#getEnclosingClass() enclosing class} hierarchy of the\n\t * supplied class. The enclosing class hierarchy will only be searched\n\t * according to {@link NestedTestConfiguration @NestedTestConfiguration}\n\t * semantics.\n\t * <p>The container type that holds the repeatable annotations will be looked up\n\t * via {@link java.lang.annotation.Repeatable}.\n\t * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\n\t * are fully supported, both within a single annotation and within annotation\n\t * hierarchies.\n\t * @param clazz the class on which to search for annotations (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged repeatable annotations found, or an empty set\n\t * if none were found\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(java.lang.reflect.AnnotatedElement, Class)\n\t * @see #searchEnclosingClass(Class)\n\t */\n\tpublic static <T extends Annotation> Set<T> getMergedRepeatableAnnotations(\n\t\t\tClass<?> clazz, Class<T> annotationType) {\n\n\t\t// Present (via @Inherited semantics), directly present, or meta-present?\n\t\tSet<T> mergedAnnotations = MergedAnnotations.from(clazz, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\n\t\tif (!mergedAnnotations.isEmpty()) {\n\t\t\treturn mergedAnnotations;\n\t\t}\n\n\t\t// Declared on an enclosing class of an inner class?\n\t\tif (searchEnclosingClass(clazz)) {\n\t\t\t// Then mimic @Inherited semantics within the enclosing class hierarchy.\n\t\t\treturn getMergedRepeatableAnnotations(clazz.getEnclosingClass(), annotationType);\n\t\t}\n\n\t\treturn Collections.emptySet();\n\t}\n\n\t/**\n\t * Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}\n\t * on the supplied {@link Class}, traversing its annotations, interfaces,\n\t * superclasses, and enclosing classes if no annotation can be found on the\n\t * given class itself.\n\t * <p>This method explicitly handles class-level annotations which are not\n\t * declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as\n\t * well as meta-annotations</em>.\n\t * <p>The algorithm operates as follows:\n\t * <ol>\n\t * <li>Search for the annotation on the given class and return a corresponding\n\t * {@code AnnotationDescriptor} if found.\n\t * <li>Recursively search through all annotations that the given class declares.</li>\n\t * <li>Recursively search through all interfaces implemented by the given class.</li>\n\t * <li>Recursively search through the superclass hierarchy of the given class.</li>\n\t * <li>Recursively search through the enclosing class hierarchy of the given class\n\t * if appropriate according to {@link NestedTestConfiguration @NestedTestConfiguration}\n\t * semantics.</li>\n\t * </ol>\n\t * <p>In this context, the term <em>recursively</em> means that the search\n\t * process continues by returning to step #1 with the current annotation,\n\t * interface, superclass, or enclosing class as the class to look for\n\t * annotations on.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * @return the corresponding annotation descriptor if the annotation was found;\n\t * otherwise {@code null}\n\t * @see #findAnnotationDescriptorForTypes(Class, Class...)\n\t */\n\tpublic static <T extends Annotation> @Nullable AnnotationDescriptor<T> findAnnotationDescriptor(\n\t\t\tClass<?> clazz, Class<T> annotationType) {\n\n\t\tAssert.notNull(annotationType, \"Annotation type must not be null\");\n\t\treturn findAnnotationDescriptor(clazz, annotationType, TestContextAnnotationUtils::searchEnclosingClass,\n\t\t\tnew HashSet<>());\n\t}\n\n\t/**\n\t * Perform the search algorithm for {@link #findAnnotationDescriptor(Class, Class)},\n\t * avoiding endless recursion by tracking which annotations have already been\n\t * <em>visited</em>.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * @param searchEnclosingClass a predicate which evaluates to {@code true}\n\t * if a search should be performed on the enclosing class\n\t * @param visited the set of annotations that have already been visited\n\t * @return the corresponding annotation descriptor if the annotation was found;\n\t * otherwise {@code null}\n\t */\n\tprivate static <T extends Annotation> @Nullable AnnotationDescriptor<T> findAnnotationDescriptor(\n\t\t\t@Nullable Class<?> clazz, Class<T> annotationType, Predicate<Class<?>> searchEnclosingClass,\n\t\t\tSet<Annotation> visited) {\n\n\t\tif (clazz == null || Object.class == clazz) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Declared locally?\n\t\tif (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {\n\t\t\treturn new AnnotationDescriptor<>(clazz, clazz.getAnnotation(annotationType));\n\t\t}\n\n\t\tAnnotationDescriptor<T> descriptor;\n\n\t\t// Declared on a composed annotation (i.e., as a meta-annotation)?\n\t\tfor (Annotation composedAnn : clazz.getDeclaredAnnotations()) {\n\t\t\tClass<? extends Annotation> composedType = composedAnn.annotationType();\n\t\t\tif (!AnnotationUtils.isInJavaLangAnnotationPackage(composedType.getName()) && visited.add(composedAnn)) {\n\t\t\t\tdescriptor = findAnnotationDescriptor(composedType, annotationType, searchEnclosingClass, visited);\n\t\t\t\tif (descriptor != null) {\n\t\t\t\t\treturn new AnnotationDescriptor<>(clazz, descriptor.getDeclaringClass(), descriptor.getAnnotation());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Declared on an interface?\n\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\t\t\tdescriptor = findAnnotationDescriptor(ifc, annotationType, searchEnclosingClass, visited);\n\t\t\tif (descriptor != null) {\n\t\t\t\treturn new AnnotationDescriptor<>(clazz, descriptor.getDeclaringClass(), descriptor.getAnnotation());\n\t\t\t}\n\t\t}\n\n\t\t// Declared on a superclass?\n\t\tdescriptor = findAnnotationDescriptor(clazz.getSuperclass(), annotationType, searchEnclosingClass, visited);\n\t\tif (descriptor != null) {\n\t\t\treturn descriptor;\n\t\t}\n\n\t\t// Declared on an enclosing class of an inner class?\n\t\tif (searchEnclosingClass.test(clazz)) {\n\t\t\tdescriptor = findAnnotationDescriptor(clazz.getEnclosingClass(), annotationType, searchEnclosingClass, visited);\n\t\t\tif (descriptor != null) {\n\t\t\t\treturn descriptor;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}\n\t * in the inheritance hierarchy of the specified {@code clazz} (including\n\t * the specified {@code clazz} itself) which declares at least one of the\n\t * specified {@code annotationTypes}.\n\t * <p>This method traverses the annotations, interfaces, superclasses, and\n\t * enclosing classes of the specified {@code clazz} if no annotation can be\n\t * found on the given class itself.\n\t * <p>This method explicitly handles class-level annotations which are not\n\t * declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as\n\t * well as meta-annotations</em>.\n\t * <p>The algorithm operates as follows:\n\t * <ol>\n\t * <li>Search for a local declaration of one of the annotation types on the\n\t * given class and return a corresponding {@code UntypedAnnotationDescriptor}\n\t * if found.\n\t * <li>Recursively search through all annotations that the given class declares.</li>\n\t * <li>Recursively search through all interfaces implemented by the given class.</li>\n\t * <li>Recursively search through the superclass hierarchy of the given class.</li>\n\t * <li>Recursively search through the enclosing class hierarchy of the given class\n\t * if appropriate according to {@link NestedTestConfiguration @NestedTestConfiguration}\n\t * semantics.</li>\n\t * </ol>\n\t * <p>In this context, the term <em>recursively</em> means that the search\n\t * process continues by returning to step #1 with the current annotation,\n\t * interface, superclass, or enclosing class as the class to look for\n\t * annotations on.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationTypes the types of annotations to look for\n\t * @return the corresponding annotation descriptor if one of the annotations\n\t * was found; otherwise {@code null}\n\t * @see #findAnnotationDescriptor(Class, Class)\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static @Nullable UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(\n\t\t\tClass<?> clazz, Class<? extends Annotation>... annotationTypes) {\n\n\t\tassertNonEmptyAnnotationTypeArray(annotationTypes, \"The list of annotation types must not be empty\");\n\t\treturn findAnnotationDescriptorForTypes(clazz, annotationTypes, new HashSet<>());\n\t}\n\n\t/**\n\t * Perform the search algorithm for {@link #findAnnotationDescriptorForTypes(Class, Class...)},\n\t * avoiding endless recursion by tracking which annotations have already been\n\t * <em>visited</em>.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationTypes the types of annotations to look for\n\t * @param visited the set of annotations that have already been visited\n\t * @return the corresponding annotation descriptor if one of the annotations\n\t * was found; otherwise {@code null}\n\t */\n\tprivate static @Nullable UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(@Nullable Class<?> clazz,\n\t\t\tClass<? extends Annotation>[] annotationTypes, Set<Annotation> visited) {\n\n\t\tif (clazz == null || Object.class == clazz) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Declared locally?\n\t\tfor (Class<? extends Annotation> annotationType : annotationTypes) {\n\t\t\tif (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {\n\t\t\t\treturn new UntypedAnnotationDescriptor(clazz, clazz.getAnnotation(annotationType), annotationTypes);\n\t\t\t}\n\t\t}\n\n\t\t// Declared on a composed annotation (i.e., as a meta-annotation)?\n\t\tfor (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {\n\t\t\tif (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {\n\t\t\t\tUntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(\n\t\t\t\t\t\tcomposedAnnotation.annotationType(), annotationTypes, visited);\n\t\t\t\tif (descriptor != null) {\n\t\t\t\t\treturn new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(),\n\t\t\t\t\t\t\tdescriptor.getAnnotation(), annotationTypes);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Declared on an interface?\n\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\t\t\tUntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(ifc, annotationTypes, visited);\n\t\t\tif (descriptor != null) {\n\t\t\t\treturn new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(),\n\t\t\t\t\t\tdescriptor.getAnnotation(), annotationTypes);\n\t\t\t}\n\t\t}\n\n\t\t// Declared on a superclass?\n\t\tUntypedAnnotationDescriptor descriptor =\n\t\t\t\tfindAnnotationDescriptorForTypes(clazz.getSuperclass(), annotationTypes, visited);\n\t\tif (descriptor != null) {\n\t\t\treturn descriptor;\n\t\t}\n\n\t\t// Declared on an enclosing class of an inner class?\n\t\tif (searchEnclosingClass(clazz)) {\n\t\t\tdescriptor = findAnnotationDescriptorForTypes(clazz.getEnclosingClass(), annotationTypes, visited);\n\t\t\tif (descriptor != null) {\n\t\t\t\treturn descriptor;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Determine if annotations on the enclosing class of the supplied class\n\t * should be searched by annotation search algorithms within the <em>Spring\n\t * TestContext Framework</em>.\n\t * @param clazz the class whose enclosing class should potentially be searched\n\t * @return {@code true} if the supplied class is an inner class whose enclosing\n\t * class should be searched\n\t * @see ClassUtils#isInnerClass(Class)\n\t * @see NestedTestConfiguration @NestedTestConfiguration\n\t */\n\tpublic static boolean searchEnclosingClass(Class<?> clazz) {\n\t\treturn (ClassUtils.isInnerClass(clazz) &&\n\t\t\t\tgetEnclosingConfiguration(clazz) == EnclosingConfiguration.INHERIT);\n\t}\n\n\tstatic void clearCaches() {\n\t\tcachedEnclosingConfigurationModes.clear();\n\t\tdefaultEnclosingConfigurationMode = null;\n\t}\n\n\t/**\n\t * Get the {@link EnclosingConfiguration} mode for the supplied class.\n\t * @param clazz the class for which the enclosing configuration mode should\n\t * be resolved\n\t * @return the resolved enclosing configuration mode\n\t */\n\tprivate static EnclosingConfiguration getEnclosingConfiguration(Class<?> clazz) {\n\t\treturn cachedEnclosingConfigurationModes.get(clazz);\n\t}\n\n\tprivate static EnclosingConfiguration lookUpEnclosingConfiguration(Class<?> clazz) {\n\t\t// @NestedTestConfiguration should not be discovered on an enclosing class\n\t\t// for a nested interface (which is always static), so our predicate simply\n\t\t// ensures that the candidate class is an inner class.\n\t\tPredicate<Class<?>> searchEnclosingClass = ClassUtils::isInnerClass;\n\t\tNestedTestConfiguration nestedTestConfiguration =\n\t\t\t\tfindMergedAnnotation(clazz, NestedTestConfiguration.class, searchEnclosingClass);\n\t\treturn (nestedTestConfiguration != null ? nestedTestConfiguration.value() : getDefaultEnclosingConfigurationMode());\n\t}\n\n\tprivate static EnclosingConfiguration getDefaultEnclosingConfigurationMode() {\n\t\tEnclosingConfiguration defaultConfigurationMode = defaultEnclosingConfigurationMode;\n\t\tif (defaultConfigurationMode == null) {\n\t\t\tString value = SpringProperties.getProperty(NestedTestConfiguration.ENCLOSING_CONFIGURATION_PROPERTY_NAME);\n\t\t\tEnclosingConfiguration enclosingConfigurationMode = EnclosingConfiguration.from(value);\n\t\t\tdefaultConfigurationMode =\n\t\t\t\t\t(enclosingConfigurationMode != null ? enclosingConfigurationMode : EnclosingConfiguration.INHERIT);\n\t\t\tdefaultEnclosingConfigurationMode = defaultConfigurationMode;\n\t\t}\n\t\treturn defaultConfigurationMode;\n\t}\n\n\tprivate static void assertNonEmptyAnnotationTypeArray(Class<?>[] annotationTypes, String message) {\n\t\tif (ObjectUtils.isEmpty(annotationTypes)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t\tfor (Class<?> clazz : annotationTypes) {\n\t\t\tif (!Annotation.class.isAssignableFrom(clazz)) {\n\t\t\t\tthrow new IllegalArgumentException(\"Array elements must be of type Annotation\");\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Descriptor for an {@link Annotation}, including the {@linkplain\n\t * #getDeclaringClass() class} on which the annotation is <em>declared</em>\n\t * as well as the {@linkplain #getAnnotation() merged annotation} instance.\n\t * <p>If the annotation is used as a meta-annotation, the <em>root declaring\n\t * class</em> is not directly annotated with the annotation but rather\n\t * indirectly via a composed annotation.\n\t * <p>Given the following example, if we are searching for the {@code @Transactional}\n\t * annotation <em>on</em> the {@code TransactionalTests} class, then the\n\t * properties of the {@code AnnotationDescriptor} would be as follows.\n\t * <ul>\n\t * <li>rootDeclaringClass: {@code TransactionalTests} class object</li>\n\t * <li>declaringClass: {@code TransactionalTests} class object</li>\n\t * <li>annotation: instance of the {@code Transactional} annotation</li>\n\t * </ul>\n\t * <p><pre style=\"code\">\n\t * &#064;Transactional\n\t * &#064;ContextConfiguration({\"/test-datasource.xml\", \"/repository-config.xml\"})\n\t * public class TransactionalTests { }\n\t * </pre>\n\t * <p>Given the following example, if we are searching for the {@code @Transactional}\n\t * annotation <em>on</em> the {@code UserRepositoryTests} class, then the\n\t * properties of the {@code AnnotationDescriptor} would be as follows.\n\t * <ul>\n\t * <li>rootDeclaringClass: {@code UserRepositoryTests} class object</li>\n\t * <li>declaringClass: {@code RepositoryTests} class object</li>\n\t * <li>annotation: instance of the {@code Transactional} annotation</li>\n\t * </ul>\n\t * <p><pre style=\"code\">\n\t * &#064;Transactional\n\t * &#064;ContextConfiguration({\"/test-datasource.xml\", \"/repository-config.xml\"})\n\t * &#064;Retention(RetentionPolicy.RUNTIME)\n\t * public &#064;interface RepositoryTests { }\n\t *\n\t * &#064;RepositoryTests\n\t * public class UserRepositoryTests { }\n\t * </pre>\n\t *\n\t * @param <T> the annotation type\n\t */\n\tpublic static class AnnotationDescriptor<T extends Annotation> {\n\n\t\tprivate final Class<?> rootDeclaringClass;\n\n\t\tprivate final Class<?> declaringClass;\n\n\t\tprivate final T annotation;\n\n\t\tAnnotationDescriptor(Class<?> rootDeclaringClass, T annotation) {\n\t\t\tthis(rootDeclaringClass, rootDeclaringClass, annotation);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tAnnotationDescriptor(Class<?> rootDeclaringClass, Class<?> declaringClass, T annotation) {\n\t\t\tAssert.notNull(rootDeclaringClass, \"'rootDeclaringClass' must not be null\");\n\t\t\tAssert.notNull(declaringClass, \"'declaringClass' must not be null\");\n\t\t\tAssert.notNull(annotation, \"Annotation must not be null\");\n\t\t\tthis.rootDeclaringClass = rootDeclaringClass;\n\t\t\tthis.declaringClass = declaringClass;\n\t\t\tT mergedAnnotation = (T) AnnotatedElementUtils.findMergedAnnotation(\n\t\t\t\t\trootDeclaringClass, annotation.annotationType());\n\t\t\tAssert.state(mergedAnnotation != null,\n\t\t\t\t\t() -> \"Failed to find merged annotation for \" + annotation);\n\t\t\tthis.annotation = mergedAnnotation;\n\t\t}\n\n\t\tpublic Class<?> getRootDeclaringClass() {\n\t\t\treturn this.rootDeclaringClass;\n\t\t}\n\n\t\tpublic Class<?> getDeclaringClass() {\n\t\t\treturn this.declaringClass;\n\t\t}\n\n\t\t/**\n\t\t * Get the merged annotation for this descriptor.\n\t\t */\n\t\tpublic T getAnnotation() {\n\t\t\treturn this.annotation;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tClass<T> getAnnotationType() {\n\t\t\treturn (Class<T>) this.annotation.annotationType();\n\t\t}\n\n\t\t/**\n\t\t * Find the next {@link AnnotationDescriptor} for the specified annotation\n\t\t * type in the hierarchy above the {@linkplain #getRootDeclaringClass()\n\t\t * root declaring class} of this descriptor.\n\t\t * <p>If a corresponding annotation is found in the superclass hierarchy\n\t\t * of the root declaring class, that will be returned. Otherwise, an\n\t\t * attempt will be made to find a corresponding annotation in the\n\t\t * {@linkplain Class#getEnclosingClass() enclosing class} hierarchy of\n\t\t * the root declaring class if {@linkplain #searchEnclosingClass appropriate}.\n\t\t * @return the next corresponding annotation descriptor if the annotation\n\t\t * was found; otherwise {@code null}\n\t\t */\n\t\tpublic @Nullable AnnotationDescriptor<T> next() {\n\t\t\t// Declared on a superclass?\n\t\t\tAnnotationDescriptor<T> descriptor =\n\t\t\t\t\tfindAnnotationDescriptor(getRootDeclaringClass().getSuperclass(), getAnnotationType());\n\t\t\t// Declared on an enclosing class of an inner class?\n\t\t\tif (descriptor == null && searchEnclosingClass(getRootDeclaringClass())) {\n\t\t\t\tdescriptor = findAnnotationDescriptor(getRootDeclaringClass().getEnclosingClass(), getAnnotationType());\n\t\t\t}\n\t\t\treturn descriptor;\n\t\t}\n\n\t\t/**\n\t\t * Find <strong>all</strong> annotations of the specified annotation type\n\t\t * that are present or meta-present on the {@linkplain #getRootDeclaringClass()\n\t\t * root declaring class} of this descriptor or on any interfaces that the\n\t\t * root declaring class implements.\n\t\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t\t * or an empty set if none were found\n\t\t */\n\t\tpublic Set<T> findAllLocalMergedAnnotations() {\n\t\t\tSearchStrategy searchStrategy = SearchStrategy.TYPE_HIERARCHY;\n\t\t\treturn MergedAnnotations.from(getRootDeclaringClass(), searchStrategy, RepeatableContainers.none())\n\t\t\t\t\t.stream(getAnnotationType())\n\t\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t\t}\n\n\t\t/**\n\t\t * Provide a textual representation of this {@code AnnotationDescriptor}.\n\t\t */\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn new ToStringCreator(this, new DefaultToStringStyler(new SimpleValueStyler()))\n\t\t\t\t\t.append(\"rootDeclaringClass\", this.rootDeclaringClass)\n\t\t\t\t\t.append(\"declaringClass\", this.declaringClass)\n\t\t\t\t\t.append(\"annotation\", this.annotation)\n\t\t\t\t\t.toString();\n\t\t}\n\t}\n\n\n\t/**\n\t * <em>Untyped</em> extension of {@link AnnotationDescriptor} that is used\n\t * to describe the declaration of one of several candidate annotation types\n\t * where the actual annotation type cannot be predetermined.\n\t */\n\tpublic static class UntypedAnnotationDescriptor extends AnnotationDescriptor<Annotation> {\n\n\t\tprivate final Class<? extends Annotation>[] annotationTypes;\n\n\t\tUntypedAnnotationDescriptor(Class<?> rootDeclaringClass, Annotation annotation,\n\t\t\t\tClass<? extends Annotation>[] annotationTypes) {\n\n\t\t\tthis(rootDeclaringClass, rootDeclaringClass, annotation, annotationTypes);\n\t\t}\n\n\t\tUntypedAnnotationDescriptor(Class<?> rootDeclaringClass, Class<?> declaringClass,\n\t\t\t\tAnnotation annotation, Class<? extends Annotation>[] annotationTypes) {\n\n\t\t\tsuper(rootDeclaringClass, declaringClass, annotation);\n\t\t\tthis.annotationTypes = annotationTypes;\n\t\t}\n\n\t\t/**\n\t\t * Find the next {@link UntypedAnnotationDescriptor} for the specified\n\t\t * annotation types in the hierarchy above the\n\t\t * {@linkplain #getRootDeclaringClass() root declaring class} of this\n\t\t * descriptor.\n\t\t * <p>If one of the corresponding annotations is found in the superclass\n\t\t * hierarchy of the root declaring class, that will be returned. Otherwise,\n\t\t * an attempt will be made to find a corresponding annotation in the\n\t\t * {@linkplain Class#getEnclosingClass() enclosing class} hierarchy of\n\t\t * the root declaring class if {@linkplain #searchEnclosingClass appropriate}.\n\t\t * @return the next corresponding annotation descriptor if one of the\n\t\t * annotations was found; otherwise {@code null}\n\t\t * @see AnnotationDescriptor#next()\n\t\t */\n\t\t@Override\n\t\tpublic @Nullable UntypedAnnotationDescriptor next() {\n\t\t\t// Declared on a superclass?\n\t\t\tUntypedAnnotationDescriptor descriptor =\n\t\t\t\t\tfindAnnotationDescriptorForTypes(getRootDeclaringClass().getSuperclass(), this.annotationTypes);\n\t\t\t// Declared on an enclosing class of an inner class?\n\t\t\tif (descriptor == null && searchEnclosingClass(getRootDeclaringClass())) {\n\t\t\t\tdescriptor = findAnnotationDescriptorForTypes(getRootDeclaringClass().getEnclosingClass(), this.annotationTypes);\n\t\t\t}\n\t\t\treturn descriptor;\n\t\t}\n\n\t\t/**\n\t\t * Throws an {@link UnsupportedOperationException} since the type of annotation\n\t\t * represented by an {@code UntypedAnnotationDescriptor} is unknown.\n\t\t */\n\t\t@Override\n\t\tpublic Set<Annotation> findAllLocalMergedAnnotations() {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"findAllLocalMergedAnnotations() is unsupported in UntypedAnnotationDescriptor\");\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.test.context.TestContextAnnotationUtils#findAllLocalMergedAnnotations()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Throws an {@link UnsupportedOperationException} since the type of annotation\n\t\t * represented by an {@code UntypedAnnotationDescriptor} is unknown.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 647
    },
    "return": "Set<Annotation>",
    "signature": "public Set<Annotation> findAllLocalMergedAnnotations()",
    "source_code": "\t\tpublic Set<Annotation> findAllLocalMergedAnnotations() {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"findAllLocalMergedAnnotations() is unsupported in UntypedAnnotationDescriptor\");\n\t\t}"
  },
  "org.springframework.test.context.TestContextAnnotationUtils#findAnnotationDescriptor(clazz,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}\n\t * on the supplied {@link Class}, traversing its annotations, interfaces,\n\t * superclasses, and enclosing classes if no annotation can be found on the\n\t * given class itself.\n\t * <p>This method explicitly handles class-level annotations which are not\n\t * declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as\n\t * well as meta-annotations</em>.\n\t * <p>The algorithm operates as follows:\n\t * <ol>\n\t * <li>Search for the annotation on the given class and return a corresponding\n\t * {@code AnnotationDescriptor} if found.\n\t * <li>Recursively search through all annotations that the given class declares.</li>\n\t * <li>Recursively search through all interfaces implemented by the given class.</li>\n\t * <li>Recursively search through the superclass hierarchy of the given class.</li>\n\t * <li>Recursively search through the enclosing class hierarchy of the given class\n\t * if appropriate according to {@link NestedTestConfiguration @NestedTestConfiguration}\n\t * semantics.</li>\n\t * </ol>\n\t * <p>In this context, the term <em>recursively</em> means that the search\n\t * process continues by returning to step #1 with the current annotation,\n\t * interface, superclass, or enclosing class as the class to look for\n\t * annotations on.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * @return the corresponding annotation descriptor if the annotation was found;\n\t * otherwise {@code null}\n\t * @see #findAnnotationDescriptorForTypes(Class, Class...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "AnnotationDescriptor<T>",
    "signature": "public AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz, Class<T> annotationType)",
    "source_code": "\tpublic static <T extends Annotation> @Nullable AnnotationDescriptor<T> findAnnotationDescriptor("
  },
  "org.springframework.test.context.TestContextAnnotationUtils#findAnnotationDescriptorForTypes(clazz,annotationTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}\n\t * in the inheritance hierarchy of the specified {@code clazz} (including\n\t * the specified {@code clazz} itself) which declares at least one of the\n\t * specified {@code annotationTypes}.\n\t * <p>This method traverses the annotations, interfaces, superclasses, and\n\t * enclosing classes of the specified {@code clazz} if no annotation can be\n\t * found on the given class itself.\n\t * <p>This method explicitly handles class-level annotations which are not\n\t * declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as\n\t * well as meta-annotations</em>.\n\t * <p>The algorithm operates as follows:\n\t * <ol>\n\t * <li>Search for a local declaration of one of the annotation types on the\n\t * given class and return a corresponding {@code UntypedAnnotationDescriptor}\n\t * if found.\n\t * <li>Recursively search through all annotations that the given class declares.</li>\n\t * <li>Recursively search through all interfaces implemented by the given class.</li>\n\t * <li>Recursively search through the superclass hierarchy of the given class.</li>\n\t * <li>Recursively search through the enclosing class hierarchy of the given class\n\t * if appropriate according to {@link NestedTestConfiguration @NestedTestConfiguration}\n\t * semantics.</li>\n\t * </ol>\n\t * <p>In this context, the term <em>recursively</em> means that the search\n\t * process continues by returning to step #1 with the current annotation,\n\t * interface, superclass, or enclosing class as the class to look for\n\t * annotations on.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationTypes the types of annotations to look for\n\t * @return the corresponding annotation descriptor if one of the annotations\n\t * was found; otherwise {@code null}\n\t * @see #findAnnotationDescriptor(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationTypes"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "UntypedAnnotationDescriptor",
    "signature": "public UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz, Class<? extends Annotation>... annotationTypes)",
    "source_code": "\tpublic static @Nullable UntypedAnnotationDescriptor findAnnotationDescriptorForTypes("
  },
  "org.springframework.test.context.TestContextAnnotationUtils#findMergedAnnotation(clazz,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied class, merge that\n\t * annotation's attributes with <em>matching</em> attributes from annotations\n\t * in lower levels of the annotation hierarchy, and synthesize the result back\n\t * into an annotation of the specified {@code annotationType}.\n\t * <p>In the context of this method, the term \"above\" means within the\n\t * {@linkplain Class#getSuperclass() superclass} hierarchy or within the\n\t * {@linkplain Class#getEnclosingClass() enclosing class} hierarchy of the\n\t * supplied class. The enclosing class hierarchy will only be searched\n\t * according to {@link NestedTestConfiguration @NestedTestConfiguration}\n\t * semantics.\n\t * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\n\t * are fully supported, both within a single annotation and within annotation\n\t * hierarchies.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @see AnnotatedElementUtils#findMergedAnnotation(java.lang.reflect.AnnotatedElement, Class)\n\t * @see #findAnnotationDescriptor(Class, Class)\n\t * @see #searchEnclosingClass(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "T",
    "signature": "public T findMergedAnnotation(Class<?> clazz, Class<T> annotationType)",
    "source_code": "\tpublic static <T extends Annotation> @Nullable T findMergedAnnotation(Class<?> clazz, Class<T> annotationType) {\n\t\treturn findMergedAnnotation(clazz, annotationType, TestContextAnnotationUtils::searchEnclosingClass);\n\t}"
  },
  "org.springframework.test.context.TestContextAnnotationUtils#getAnnotation()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Get the merged annotation for this descriptor.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 532
    },
    "return": "T",
    "signature": "public T getAnnotation()",
    "source_code": "\t\tpublic T getAnnotation() {\n\t\t\treturn this.annotation;\n\t\t}"
  },
  "org.springframework.test.context.TestContextAnnotationUtils#getMergedRepeatableAnnotations(clazz,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied class; and for\n\t * each annotation found, merge that annotation's attributes with <em>matching</em>\n\t * attributes from annotations in lower levels of the annotation hierarchy and\n\t * synthesize the results back into an annotation of the specified {@code annotationType}.\n\t * <p>This method will find {@link java.lang.annotation.Inherited @Inherited}\n\t * annotations declared on superclasses if the supplied class does not have\n\t * any local declarations of the repeatable annotation. If no inherited\n\t * annotations are found, this method will search within the\n\t * {@linkplain Class#getEnclosingClass() enclosing class} hierarchy of the\n\t * supplied class. The enclosing class hierarchy will only be searched\n\t * according to {@link NestedTestConfiguration @NestedTestConfiguration}\n\t * semantics.\n\t * <p>The container type that holds the repeatable annotations will be looked up\n\t * via {@link java.lang.annotation.Repeatable}.\n\t * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\n\t * are fully supported, both within a single annotation and within annotation\n\t * hierarchies.\n\t * @param clazz the class on which to search for annotations (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged repeatable annotations found, or an empty set\n\t * if none were found\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(java.lang.reflect.AnnotatedElement, Class)\n\t * @see #searchEnclosingClass(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "Set<T>",
    "signature": "public Set<T> getMergedRepeatableAnnotations(Class<?> clazz, Class<T> annotationType)",
    "source_code": "\tpublic static <T extends Annotation> Set<T> getMergedRepeatableAnnotations("
  },
  "org.springframework.test.context.TestContextAnnotationUtils#hasAnnotation(clazz,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if an annotation of the specified {@code annotationType} is\n\t * present or meta-present on the supplied {@link Class} according to the\n\t * search algorithm used in {@link #findMergedAnnotation(Class, Class)}.\n\t * <p>If this method returns {@code true}, then {@code findMergedAnnotation(...)}\n\t * will return a non-null value.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * @return {@code true} if a matching annotation is present\n\t * @since 5.3.3\n\t * @see #findMergedAnnotation(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "boolean",
    "signature": "public boolean hasAnnotation(Class<?> clazz, Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic static boolean hasAnnotation(Class<?> clazz, Class<? extends Annotation> annotationType) {\n\t\treturn MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.withEnclosingClasses(TestContextAnnotationUtils::searchEnclosingClass)\n\t\t\t\t.from(clazz)\n\t\t\t\t.isPresent(annotationType);\n\t}"
  },
  "org.springframework.test.context.TestContextAnnotationUtils#next()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Find the next {@link UntypedAnnotationDescriptor} for the specified\n\t\t * annotation types in the hierarchy above the\n\t\t * {@linkplain #getRootDeclaringClass() root declaring class} of this\n\t\t * descriptor.\n\t\t * <p>If one of the corresponding annotations is found in the superclass\n\t\t * hierarchy of the root declaring class, that will be returned. Otherwise,\n\t\t * an attempt will be made to find a corresponding annotation in the\n\t\t * {@linkplain Class#getEnclosingClass() enclosing class} hierarchy of\n\t\t * the root declaring class if {@linkplain #searchEnclosingClass appropriate}.\n\t\t * @return the next corresponding annotation descriptor if one of the\n\t\t * annotations was found; otherwise {@code null}\n\t\t * @see AnnotationDescriptor#next()\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 631
    },
    "return": "UntypedAnnotationDescriptor",
    "signature": "public UntypedAnnotationDescriptor next()",
    "source_code": "\t\tpublic @Nullable UntypedAnnotationDescriptor next() {\n\t\t\t// Declared on a superclass?\n\t\t\tUntypedAnnotationDescriptor descriptor =\n\t\t\t\t\tfindAnnotationDescriptorForTypes(getRootDeclaringClass().getSuperclass(), this.annotationTypes);\n\t\t\t// Declared on an enclosing class of an inner class?\n\t\t\tif (descriptor == null && searchEnclosingClass(getRootDeclaringClass())) {\n\t\t\t\tdescriptor = findAnnotationDescriptorForTypes(getRootDeclaringClass().getEnclosingClass(), this.annotationTypes);\n\t\t\t}\n\t\t\treturn descriptor;\n\t\t}"
  },
  "org.springframework.test.context.TestContextAnnotationUtils#searchEnclosingClass(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if annotations on the enclosing class of the supplied class\n\t * should be searched by annotation search algorithms within the <em>Spring\n\t * TestContext Framework</em>.\n\t * @param clazz the class whose enclosing class should potentially be searched\n\t * @return {@code true} if the supplied class is an inner class whose enclosing\n\t * class should be searched\n\t * @see ClassUtils#isInnerClass(Class)\n\t * @see NestedTestConfiguration @NestedTestConfiguration\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "boolean",
    "signature": "public boolean searchEnclosingClass(Class<?> clazz)",
    "source_code": "\tpublic static boolean searchEnclosingClass(Class<?> clazz) {\n\t\treturn (ClassUtils.isInnerClass(clazz) &&\n\t\t\t\tgetEnclosingConfiguration(clazz) == EnclosingConfiguration.INHERIT);\n\t}"
  },
  "org.springframework.test.context.TestContextAnnotationUtils#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Provide a textual representation of this {@code AnnotationDescriptor}.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 584
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn new ToStringCreator(this, new DefaultToStringStyler(new SimpleValueStyler()))\n\t\t\t\t\t.append(\"rootDeclaringClass\", this.rootDeclaringClass)\n\t\t\t\t\t.append(\"declaringClass\", this.declaringClass)\n\t\t\t\t\t.append(\"annotation\", this.annotation)\n\t\t\t\t\t.toString();\n\t\t}"
  },
  "org.springframework.test.context.UntypedAnnotationDescriptor": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * <em>Untyped</em> extension of {@link AnnotationDescriptor} that is used\n\t * to describe the declaration of one of several candidate annotation types\n\t * where the actual annotation type cannot be predetermined.\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 599
    },
    "signature": "public class UntypedAnnotationDescriptor",
    "source_code": "\tpublic static class UntypedAnnotationDescriptor extends AnnotationDescriptor<Annotation> {\n\n\t\tprivate final Class<? extends Annotation>[] annotationTypes;\n\n\t\tUntypedAnnotationDescriptor(Class<?> rootDeclaringClass, Annotation annotation,\n\t\t\t\tClass<? extends Annotation>[] annotationTypes) {\n\n\t\t\tthis(rootDeclaringClass, rootDeclaringClass, annotation, annotationTypes);\n\t\t}\n\n\t\tUntypedAnnotationDescriptor(Class<?> rootDeclaringClass, Class<?> declaringClass,\n\t\t\t\tAnnotation annotation, Class<? extends Annotation>[] annotationTypes) {\n\n\t\t\tsuper(rootDeclaringClass, declaringClass, annotation);\n\t\t\tthis.annotationTypes = annotationTypes;\n\t\t}\n\n\t\t/**\n\t\t * Find the next {@link UntypedAnnotationDescriptor} for the specified\n\t\t * annotation types in the hierarchy above the\n\t\t * {@linkplain #getRootDeclaringClass() root declaring class} of this\n\t\t * descriptor.\n\t\t * <p>If one of the corresponding annotations is found in the superclass\n\t\t * hierarchy of the root declaring class, that will be returned. Otherwise,\n\t\t * an attempt will be made to find a corresponding annotation in the\n\t\t * {@linkplain Class#getEnclosingClass() enclosing class} hierarchy of\n\t\t * the root declaring class if {@linkplain #searchEnclosingClass appropriate}.\n\t\t * @return the next corresponding annotation descriptor if one of the\n\t\t * annotations was found; otherwise {@code null}\n\t\t * @see AnnotationDescriptor#next()\n\t\t */\n\t\t@Override\n\t\tpublic @Nullable UntypedAnnotationDescriptor next() {\n\t\t\t// Declared on a superclass?\n\t\t\tUntypedAnnotationDescriptor descriptor =\n\t\t\t\t\tfindAnnotationDescriptorForTypes(getRootDeclaringClass().getSuperclass(), this.annotationTypes);\n\t\t\t// Declared on an enclosing class of an inner class?\n\t\t\tif (descriptor == null && searchEnclosingClass(getRootDeclaringClass())) {\n\t\t\t\tdescriptor = findAnnotationDescriptorForTypes(getRootDeclaringClass().getEnclosingClass(), this.annotationTypes);\n\t\t\t}\n\t\t\treturn descriptor;\n\t\t}\n\n\t\t/**\n\t\t * Throws an {@link UnsupportedOperationException} since the type of annotation\n\t\t * represented by an {@code UntypedAnnotationDescriptor} is unknown.\n\t\t */\n\t\t@Override\n\t\tpublic Set<Annotation> findAllLocalMergedAnnotations() {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"findAllLocalMergedAnnotations() is unsupported in UntypedAnnotationDescriptor\");\n\t\t}\n\t}"
  },
  "org.springframework.test.util.ReflectionTestUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code ReflectionTestUtils} is a collection of reflection-based utility\n * methods for use in unit and integration testing scenarios.\n *\n * <p>There are often times when it would be beneficial to be able to set a\n * non-{@code public} field, invoke a non-{@code public} setter method, or\n * invoke a non-{@code public} <em>configuration</em> or <em>lifecycle</em>\n * callback method when testing code involving, for example:\n *\n * <ul>\n * <li>ORM frameworks such as JPA and Hibernate which condone the usage of\n * {@code private} or {@code protected} field access as opposed to\n * {@code public} setter methods for properties in a domain entity.</li>\n * <li>Spring's support for annotations such as\n * {@link org.springframework.beans.factory.annotation.Autowired @Autowired},\n * {@link jakarta.inject.Inject @Inject}, and\n * {@link jakarta.annotation.Resource @Resource} which provides dependency\n * injection for {@code private} or {@code protected} fields, setter methods,\n * and configuration methods.</li>\n * <li>Use of annotations such as {@link jakarta.annotation.PostConstruct @PostConstruct}\n * and {@link jakarta.annotation.PreDestroy @PreDestroy} for lifecycle callback\n * methods.</li>\n * </ul>\n *\n * <p>In addition, several methods in this class provide support for {@code static}\n * fields and {@code static} methods &mdash; for example,\n * {@link #setField(Class, String, Object)}, {@link #getField(Class, String)},\n * {@link #invokeMethod(Class, String, Object...)},\n * {@link #invokeMethod(Object, Class, String, Object...)}, etc.\n *\n * @author Sam Brannen\n * @author Juergen Hoeller\n * @since 2.5\n * @see ReflectionUtils\n * @see AopTestUtils\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "signature": "public class ReflectionTestUtils",
    "source_code": "public abstract class ReflectionTestUtils {\n\n\tprivate static final String SETTER_PREFIX = \"set\";\n\n\tprivate static final String GETTER_PREFIX = \"get\";\n\n\tprivate static final Log logger = LogFactory.getLog(ReflectionTestUtils.class);\n\n\tprivate static final boolean springAopPresent = ClassUtils.isPresent(\n\t\t\t\"org.springframework.aop.framework.Advised\", ReflectionTestUtils.class.getClassLoader());\n\n\n\t/**\n\t * Set the {@linkplain Field field} with the given {@code name} on the\n\t * provided {@code targetObject} to the supplied {@code value}.\n\t * <p>This method delegates to {@link #setField(Object, String, Object, Class)},\n\t * supplying {@code null} for the {@code type} argument.\n\t * @param targetObject the target object on which to set the field; never {@code null}\n\t * @param name the name of the field to set; never {@code null}\n\t * @param value the value to set\n\t */\n\tpublic static void setField(Object targetObject, String name, @Nullable Object value) {\n\t\tsetField(targetObject, name, value, null);\n\t}\n\n\t/**\n\t * Set the {@linkplain Field field} with the given {@code name}/{@code type}\n\t * on the provided {@code targetObject} to the supplied {@code value}.\n\t * <p>This method delegates to {@link #setField(Object, Class, String, Object, Class)},\n\t * supplying {@code null} for the {@code targetClass} argument.\n\t * @param targetObject the target object on which to set the field; never {@code null}\n\t * @param name the name of the field to set; may be {@code null} if\n\t * {@code type} is specified\n\t * @param value the value to set\n\t * @param type the type of the field to set; may be {@code null} if\n\t * {@code name} is specified\n\t */\n\tpublic static void setField(Object targetObject, @Nullable String name, @Nullable Object value, @Nullable Class<?> type) {\n\t\tsetField(targetObject, null, name, value, type);\n\t}\n\n\t/**\n\t * Set the static {@linkplain Field field} with the given {@code name} on\n\t * the provided {@code targetClass} to the supplied {@code value}.\n\t * <p>This method delegates to {@link #setField(Object, Class, String, Object, Class)},\n\t * supplying {@code null} for the {@code targetObject} and {@code type} arguments.\n\t * <p>This method does not support setting {@code static final} fields.\n\t * @param targetClass the target class on which to set the static field;\n\t * never {@code null}\n\t * @param name the name of the field to set; never {@code null}\n\t * @param value the value to set\n\t * @since 4.2\n\t */\n\tpublic static void setField(Class<?> targetClass, String name, @Nullable Object value) {\n\t\tsetField(null, targetClass, name, value, null);\n\t}\n\n\t/**\n\t * Set the static {@linkplain Field field} with the given\n\t * {@code name}/{@code type} on the provided {@code targetClass} to\n\t * the supplied {@code value}.\n\t * <p>This method delegates to {@link #setField(Object, Class, String, Object, Class)},\n\t * supplying {@code null} for the {@code targetObject} argument.\n\t * <p>This method does not support setting {@code static final} fields.\n\t * @param targetClass the target class on which to set the static field;\n\t * never {@code null}\n\t * @param name the name of the field to set; may be {@code null} if\n\t * {@code type} is specified\n\t * @param value the value to set\n\t * @param type the type of the field to set; may be {@code null} if\n\t * {@code name} is specified\n\t * @since 4.2\n\t */\n\tpublic static void setField(\n\t\t\tClass<?> targetClass, @Nullable String name, @Nullable Object value, @Nullable Class<?> type) {\n\n\t\tsetField(null, targetClass, name, value, type);\n\t}\n\n\t/**\n\t * Set the {@linkplain Field field} with the given {@code name}/{@code type}\n\t * on the provided {@code targetObject}/{@code targetClass} to the supplied\n\t * {@code value}.\n\t * <p>If the supplied {@code targetObject} is a <em>proxy</em>, it will\n\t * be {@linkplain AopTestUtils#getUltimateTargetObject unwrapped} allowing\n\t * the field to be set on the ultimate target of the proxy.\n\t * <p>This method traverses the class hierarchy in search of the desired\n\t * field. In addition, an attempt will be made to make non-{@code public}\n\t * fields <em>accessible</em>, thus allowing one to set {@code protected},\n\t * {@code private}, and <em>package-private</em> fields.\n\t * <p>This method does not support setting {@code static final} fields.\n\t * @param targetObject the target object on which to set the field; may be\n\t * {@code null} if the field is static\n\t * @param targetClass the target class on which to set the field; may\n\t * be {@code null} if the field is an instance field\n\t * @param name the name of the field to set; may be {@code null} if\n\t * {@code type} is specified\n\t * @param value the value to set\n\t * @param type the type of the field to set; may be {@code null} if\n\t * {@code name} is specified\n\t * @since 4.2\n\t * @see ReflectionUtils#findField(Class, String, Class)\n\t * @see ReflectionUtils#makeAccessible(Field)\n\t * @see ReflectionUtils#setField(Field, Object, Object)\n\t * @see AopTestUtils#getUltimateTargetObject(Object)\n\t */\n\t@SuppressWarnings(\"NullAway\") // Dataflow analysis limitation\n\tpublic static void setField(@Nullable Object targetObject, @Nullable Class<?> targetClass,\n\t\t\t@Nullable String name, @Nullable Object value, @Nullable Class<?> type) {\n\n\t\tAssert.isTrue(targetObject != null || targetClass != null,\n\t\t\t\t\"Either targetObject or targetClass for the field must be specified\");\n\n\t\tif (targetObject != null && springAopPresent) {\n\t\t\ttargetObject = AopTestUtils.getUltimateTargetObject(targetObject);\n\t\t}\n\t\tif (targetClass == null) {\n\t\t\ttargetClass = targetObject.getClass();\n\t\t}\n\n\t\tField field = ReflectionUtils.findField(targetClass, name, type);\n\t\tif (field == null) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"Could not find field '%s' of type [%s] on %s or target class [%s]\", name, type,\n\t\t\t\t\tsafeToString(targetObject), targetClass));\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\n\t\t\t\t\t\"Setting field '%s' of type [%s] on %s or target class [%s] to value [%s]\", name, type,\n\t\t\t\t\tsafeToString(targetObject), targetClass, value));\n\t\t}\n\t\tReflectionUtils.makeAccessible(field);\n\t\tReflectionUtils.setField(field, targetObject, value);\n\t}\n\n\t/**\n\t * Get the value of the {@linkplain Field field} with the given {@code name}\n\t * from the provided {@code targetObject}.\n\t * <p>This method delegates to {@link #getField(Object, Class, String)},\n\t * supplying {@code null} for the {@code targetClass} argument.\n\t * @param targetObject the target object from which to get the field;\n\t * never {@code null}\n\t * @param name the name of the field to get; never {@code null}\n\t * @return the field's current value\n\t * @see #getField(Class, String)\n\t */\n\tpublic static @Nullable Object getField(Object targetObject, String name) {\n\t\treturn getField(targetObject, null, name);\n\t}\n\n\t/**\n\t * Get the value of the static {@linkplain Field field} with the given\n\t * {@code name} from the provided {@code targetClass}.\n\t * <p>This method delegates to {@link #getField(Object, Class, String)},\n\t * supplying {@code null} for the {@code targetObject} argument.\n\t * @param targetClass the target class from which to get the static field;\n\t * never {@code null}\n\t * @param name the name of the field to get; never {@code null}\n\t * @return the field's current value\n\t * @since 4.2\n\t * @see #getField(Object, String)\n\t */\n\tpublic static @Nullable Object getField(Class<?> targetClass, String name) {\n\t\treturn getField(null, targetClass, name);\n\t}\n\n\t/**\n\t * Get the value of the {@linkplain Field field} with the given {@code name}\n\t * from the provided {@code targetObject}/{@code targetClass}.\n\t * <p>If the supplied {@code targetObject} is a <em>proxy</em>, it will\n\t * be {@linkplain AopTestUtils#getUltimateTargetObject unwrapped} allowing\n\t * the field to be retrieved from the ultimate target of the proxy.\n\t * <p>This method traverses the class hierarchy in search of the desired\n\t * field. In addition, an attempt will be made to make non-{@code public}\n\t * fields <em>accessible</em>, thus allowing one to get {@code protected},\n\t * {@code private}, and <em>package-private</em> fields.\n\t * @param targetObject the target object from which to get the field; may be\n\t * {@code null} if the field is static\n\t * @param targetClass the target class from which to get the field; may\n\t * be {@code null} if the field is an instance field\n\t * @param name the name of the field to get; never {@code null}\n\t * @return the field's current value\n\t * @since 4.2\n\t * @see #getField(Object, String)\n\t * @see #getField(Class, String)\n\t * @see ReflectionUtils#findField(Class, String, Class)\n\t * @see ReflectionUtils#makeAccessible(Field)\n\t * @see ReflectionUtils#getField(Field, Object)\n\t * @see AopTestUtils#getUltimateTargetObject(Object)\n\t */\n\t@SuppressWarnings(\"NullAway\") // Dataflow analysis limitation\n\tpublic static @Nullable Object getField(@Nullable Object targetObject, @Nullable Class<?> targetClass, String name) {\n\t\tAssert.isTrue(targetObject != null || targetClass != null,\n\t\t\t\"Either targetObject or targetClass for the field must be specified\");\n\n\t\tif (targetObject != null && springAopPresent) {\n\t\t\ttargetObject = AopTestUtils.getUltimateTargetObject(targetObject);\n\t\t}\n\t\tif (targetClass == null) {\n\t\t\ttargetClass = targetObject.getClass();\n\t\t}\n\n\t\tField field = ReflectionUtils.findField(targetClass, name);\n\t\tif (field == null) {\n\t\t\tthrow new IllegalArgumentException(String.format(\"Could not find field '%s' on %s or target class [%s]\",\n\t\t\t\t\tname, safeToString(targetObject), targetClass));\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Getting field '%s' from %s or target class [%s]\", name,\n\t\t\t\t\tsafeToString(targetObject), targetClass));\n\t\t}\n\t\tReflectionUtils.makeAccessible(field);\n\t\treturn ReflectionUtils.getField(field, targetObject);\n\t}\n\n\t/**\n\t * Invoke the setter method with the given {@code name} on the supplied\n\t * target object with the supplied {@code value}.\n\t * <p>This method delegates to\n\t * {@link #invokeSetterMethod(Object, String, Object, Class)}, supplying\n\t * {@code null} for the parameter type.\n\t * @param target the target object on which to invoke the specified setter\n\t * method\n\t * @param name the name of the setter method to invoke or the corresponding\n\t * property name\n\t * @param value the value to provide to the setter method\n\t */\n\tpublic static void invokeSetterMethod(Object target, String name, Object value) {\n\t\tinvokeSetterMethod(target, name, value, null);\n\t}\n\n\t/**\n\t * Invoke the setter method with the given {@code name} on the supplied\n\t * target object with the supplied {@code value}.\n\t * <p>This method traverses the class hierarchy in search of the desired\n\t * method. In addition, an attempt will be made to make non-{@code public}\n\t * methods <em>accessible</em>, thus allowing one to invoke {@code protected},\n\t * {@code private}, and <em>package-private</em> setter methods.\n\t * <p>This method also supports JavaBean-style <em>property</em> names. For\n\t * example, if you wish to set the {@code name} property on the target object,\n\t * you may pass either {@code \"name\"} or {@code \"setName\"} as the method name.\n\t * <p>As of Spring Framework 6.2, if the supplied target object is a CGLIB\n\t * proxy which does not intercept the setter method, the proxy will be\n\t * {@linkplain AopTestUtils#getUltimateTargetObject unwrapped} allowing the\n\t * setter method to be invoked directly on the ultimate target of the proxy.\n\t * @param target the target object on which to invoke the specified setter\n\t * method\n\t * @param name the name of the setter method to invoke or the corresponding\n\t * property name\n\t * @param value the value to provide to the setter method\n\t * @param type the formal parameter type declared by the setter method\n\t * (may be {@code null} to indicate any type)\n\t * @see ReflectionUtils#findMethod(Class, String, Class[])\n\t * @see ReflectionUtils#makeAccessible(Method)\n\t * @see ReflectionUtils#invokeMethod(Method, Object, Object[])\n\t * @see AopTestUtils#getUltimateTargetObject(Object)\n\t */\n\tpublic static void invokeSetterMethod(Object target, String name, @Nullable Object value, @Nullable Class<?> type) {\n\t\tAssert.notNull(target, \"Target object must not be null\");\n\t\tAssert.hasText(name, \"Method name must not be empty\");\n\t\tClass<?>[] paramTypes = (type != null ? new Class<?>[] {type} : null);\n\n\t\tString setterMethodName = name;\n\t\tif (!name.startsWith(SETTER_PREFIX)) {\n\t\t\tsetterMethodName = SETTER_PREFIX + StringUtils.capitalize(name);\n\t\t}\n\n\t\tMethod method = ReflectionUtils.findMethod(target.getClass(), setterMethodName, paramTypes);\n\t\tif (method == null && !setterMethodName.equals(name)) {\n\t\t\tsetterMethodName = name;\n\t\t\tmethod = ReflectionUtils.findMethod(target.getClass(), setterMethodName, paramTypes);\n\t\t}\n\t\tif (method == null) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"Could not find setter method '%s' on %s with parameter type [%s]\", setterMethodName,\n\t\t\t\t\tsafeToString(target), type));\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Invoking setter method '%s' on %s with value [%s]\", setterMethodName,\n\t\t\t\t\tsafeToString(target), value));\n\t\t}\n\n\t\tif (springAopPresent) {\n\t\t\t// If the target is a CGLIB proxy which does not intercept the method, invoke the\n\t\t\t// method on the ultimate target.\n\t\t\tif (isCglibProxyThatDoesNotInterceptMethod(target, method)) {\n\t\t\t\ttarget = AopTestUtils.getUltimateTargetObject(target);\n\t\t\t}\n\t\t}\n\n\t\tReflectionUtils.makeAccessible(method);\n\t\tReflectionUtils.invokeMethod(method, target, value);\n\t}\n\n\t/**\n\t * Invoke the getter method with the given {@code name} on the supplied\n\t * target object with the supplied {@code value}.\n\t * <p>This method traverses the class hierarchy in search of the desired\n\t * method. In addition, an attempt will be made to make non-{@code public}\n\t * methods <em>accessible</em>, thus allowing one to invoke {@code protected},\n\t * {@code private}, and <em>package-private</em> getter methods.\n\t * <p>This method also supports JavaBean-style <em>property</em> names. For\n\t * example, if you wish to get the {@code name} property on the target object,\n\t * you may pass either {@code \"name\"} or {@code \"getName\"} as the method name.\n\t * <p>As of Spring Framework 6.2, if the supplied target object is a CGLIB\n\t * proxy which does not intercept the getter method, the proxy will be\n\t * {@linkplain AopTestUtils#getUltimateTargetObject unwrapped} allowing the\n\t * getter method to be invoked directly on the ultimate target of the proxy.\n\t * @param target the target object on which to invoke the specified getter\n\t * method\n\t * @param name the name of the getter method to invoke or the corresponding\n\t * property name\n\t * @return the value returned from the invocation\n\t * @see ReflectionUtils#findMethod(Class, String, Class[])\n\t * @see ReflectionUtils#makeAccessible(Method)\n\t * @see ReflectionUtils#invokeMethod(Method, Object, Object[])\n\t * @see AopTestUtils#getUltimateTargetObject(Object)\n\t */\n\tpublic static @Nullable Object invokeGetterMethod(Object target, String name) {\n\t\tAssert.notNull(target, \"Target object must not be null\");\n\t\tAssert.hasText(name, \"Method name must not be empty\");\n\n\t\tString getterMethodName = name;\n\t\tif (!name.startsWith(GETTER_PREFIX)) {\n\t\t\tgetterMethodName = GETTER_PREFIX + StringUtils.capitalize(name);\n\t\t}\n\t\tMethod method = ReflectionUtils.findMethod(target.getClass(), getterMethodName);\n\t\tif (method == null && !getterMethodName.equals(name)) {\n\t\t\tgetterMethodName = name;\n\t\t\tmethod = ReflectionUtils.findMethod(target.getClass(), getterMethodName);\n\t\t}\n\t\tif (method == null) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"Could not find getter method '%s' on %s\", getterMethodName, safeToString(target)));\n\t\t}\n\n\t\tif (springAopPresent) {\n\t\t\t// If the target is a CGLIB proxy which does not intercept the method, invoke the\n\t\t\t// method on the ultimate target.\n\t\t\tif (isCglibProxyThatDoesNotInterceptMethod(target, method)) {\n\t\t\t\ttarget = AopTestUtils.getUltimateTargetObject(target);\n\t\t\t}\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Invoking getter method '%s' on %s\", getterMethodName, safeToString(target)));\n\t\t}\n\t\tReflectionUtils.makeAccessible(method);\n\t\treturn ReflectionUtils.invokeMethod(method, target);\n\t}\n\n\t/**\n\t * Invoke the method with the given {@code name} on the supplied target\n\t * object with the supplied arguments.\n\t * <p>This method delegates to {@link #invokeMethod(Object, Class, String, Object...)},\n\t * supplying {@code null} for the {@code targetClass} argument.\n\t * @param target the target object on which to invoke the specified method\n\t * @param name the name of the method to invoke\n\t * @param args the arguments to provide to the method\n\t * @return the invocation result, if any\n\t * @see #invokeMethod(Class, String, Object...)\n\t * @see #invokeMethod(Object, Class, String, Object...)\n\t */\n\tpublic static <T> @Nullable T invokeMethod(Object target, String name, Object... args) {\n\t\tAssert.notNull(target, \"Target object must not be null\");\n\t\treturn invokeMethod(target, null, name, args);\n\t}\n\n\t/**\n\t * Invoke the static method with the given {@code name} on the supplied target\n\t * class with the supplied arguments.\n\t * <p>This method delegates to {@link #invokeMethod(Object, Class, String, Object...)},\n\t * supplying {@code null} for the {@code targetObject} argument.\n\t * @param targetClass the target class on which to invoke the specified method\n\t * @param name the name of the method to invoke\n\t * @param args the arguments to provide to the method\n\t * @return the invocation result, if any\n\t * @since 5.2\n\t * @see #invokeMethod(Object, String, Object...)\n\t * @see #invokeMethod(Object, Class, String, Object...)\n\t */\n\tpublic static <T> @Nullable T invokeMethod(Class<?> targetClass, String name, Object... args) {\n\t\tAssert.notNull(targetClass, \"Target class must not be null\");\n\t\treturn invokeMethod(null, targetClass, name, args);\n\t}\n\n\t/**\n\t * Invoke the method with the given {@code name} on the provided\n\t * {@code targetObject}/{@code targetClass} with the supplied arguments.\n\t * <p>This method traverses the class hierarchy in search of the desired\n\t * method. In addition, an attempt will be made to make non-{@code public}\n\t * methods <em>accessible</em>, thus allowing one to invoke {@code protected},\n\t * {@code private}, and <em>package-private</em> methods.\n\t * <p>As of Spring Framework 6.2, if the supplied target object is a CGLIB\n\t * proxy which does not intercept the method, the proxy will be\n\t * {@linkplain AopTestUtils#getUltimateTargetObject unwrapped} allowing the\n\t * method to be invoked directly on the ultimate target of the proxy.\n\t * @param targetObject the target object on which to invoke the method; may\n\t * be {@code null} if the method is static\n\t * @param targetClass the target class on which to invoke the method; may\n\t * be {@code null} if the method is an instance method\n\t * @param name the name of the method to invoke\n\t * @param args the arguments to provide to the method\n\t * @return the invocation result, if any\n\t * @since 5.2\n\t * @see #invokeMethod(Object, String, Object...)\n\t * @see #invokeMethod(Class, String, Object...)\n\t * @see MethodInvoker\n\t * @see ReflectionUtils#makeAccessible(Method)\n\t * @see ReflectionUtils#handleReflectionException(Exception)\n\t * @see AopTestUtils#getUltimateTargetObject(Object)\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T> @Nullable T invokeMethod(@Nullable Object targetObject, @Nullable Class<?> targetClass, String name,\n\t\t\tObject... args) {\n\n\t\tAssert.isTrue(targetObject != null || targetClass != null,\n\t\t\t\t\"Either 'targetObject' or 'targetClass' for the method must be specified\");\n\t\tAssert.hasText(name, \"Method name must not be empty\");\n\n\t\ttry {\n\t\t\tMethodInvoker methodInvoker = new MethodInvoker();\n\t\t\tmethodInvoker.setTargetObject(targetObject);\n\t\t\tif (targetClass != null) {\n\t\t\t\tmethodInvoker.setTargetClass(targetClass);\n\t\t\t}\n\t\t\tmethodInvoker.setTargetMethod(name);\n\t\t\tmethodInvoker.setArguments(args);\n\t\t\tmethodInvoker.prepare();\n\n\t\t\tif (targetObject != null && springAopPresent) {\n\t\t\t\t// If the target is a CGLIB proxy which does not intercept the method, invoke the\n\t\t\t\t// method on the ultimate target.\n\t\t\t\tif (isCglibProxyThatDoesNotInterceptMethod(targetObject, methodInvoker.getPreparedMethod())) {\n\t\t\t\t\ttargetObject = AopTestUtils.getUltimateTargetObject(targetObject);\n\t\t\t\t\tmethodInvoker.setTargetObject(targetObject);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(String.format(\"Invoking method '%s' on %s or %s with arguments %s\", name,\n\t\t\t\t\t\tsafeToString(targetObject), safeToString(targetClass), ObjectUtils.nullSafeToString(args)));\n\t\t\t}\n\n\t\t\treturn (T) methodInvoker.invoke();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tReflectionUtils.handleReflectionException(ex);\n\t\t\tthrow new IllegalStateException(\"Should never get here\");\n\t\t}\n\t}\n\n\tprivate static String safeToString(@Nullable Object target) {\n\t\ttry {\n\t\t\treturn String.format(\"target object [%s]\", target);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\treturn String.format(\"target of type [%s] whose toString() method threw [%s]\",\n\t\t\t\t\t(target != null ? target.getClass().getName() : \"unknown\"), ex);\n\t\t}\n\t}\n\n\tprivate static String safeToString(@Nullable Class<?> clazz) {\n\t\treturn String.format(\"target class [%s]\", (clazz != null ? clazz.getName() : null));\n\t}\n\n\t/**\n\t * Determine if the supplied target object is a CBLIB proxy that does not intercept the\n\t * supplied method.\n\t * @since 6.2\n\t */\n\tprivate static boolean isCglibProxyThatDoesNotInterceptMethod(Object target, Method method) {\n\t\treturn (AopUtils.isCglibProxy(target) && !method.getDeclaringClass().equals(target.getClass()));\n\t}\n\n}"
  },
  "org.springframework.test.util.ReflectionTestUtils#getField(targetClass,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the static {@linkplain Field field} with the given\n\t * {@code name} from the provided {@code targetClass}.\n\t * <p>This method delegates to {@link #getField(Object, Class, String)},\n\t * supplying {@code null} for the {@code targetObject} argument.\n\t * @param targetClass the target class from which to get the static field;\n\t * never {@code null}\n\t * @param name the name of the field to get; never {@code null}\n\t * @return the field's current value\n\t * @since 4.2\n\t * @see #getField(Object, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetClass",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "Object",
    "signature": "public Object getField(Class<?> targetClass, String name)",
    "source_code": "\tpublic static @Nullable Object getField(Class<?> targetClass, String name) {\n\t\treturn getField(null, targetClass, name);\n\t}"
  },
  "org.springframework.test.util.ReflectionTestUtils#getField(targetObject,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the {@linkplain Field field} with the given {@code name}\n\t * from the provided {@code targetObject}.\n\t * <p>This method delegates to {@link #getField(Object, Class, String)},\n\t * supplying {@code null} for the {@code targetClass} argument.\n\t * @param targetObject the target object from which to get the field;\n\t * never {@code null}\n\t * @param name the name of the field to get; never {@code null}\n\t * @return the field's current value\n\t * @see #getField(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetObject",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "Object",
    "signature": "public Object getField(Object targetObject, String name)",
    "source_code": "\tpublic static @Nullable Object getField(Object targetObject, String name) {\n\t\treturn getField(targetObject, null, name);\n\t}"
  },
  "org.springframework.test.util.ReflectionTestUtils#getField(targetObject,targetClass,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the {@linkplain Field field} with the given {@code name}\n\t * from the provided {@code targetObject}/{@code targetClass}.\n\t * <p>If the supplied {@code targetObject} is a <em>proxy</em>, it will\n\t * be {@linkplain AopTestUtils#getUltimateTargetObject unwrapped} allowing\n\t * the field to be retrieved from the ultimate target of the proxy.\n\t * <p>This method traverses the class hierarchy in search of the desired\n\t * field. In addition, an attempt will be made to make non-{@code public}\n\t * fields <em>accessible</em>, thus allowing one to get {@code protected},\n\t * {@code private}, and <em>package-private</em> fields.\n\t * @param targetObject the target object from which to get the field; may be\n\t * {@code null} if the field is static\n\t * @param targetClass the target class from which to get the field; may\n\t * be {@code null} if the field is an instance field\n\t * @param name the name of the field to get; never {@code null}\n\t * @return the field's current value\n\t * @since 4.2\n\t * @see #getField(Object, String)\n\t * @see #getField(Class, String)\n\t * @see ReflectionUtils#findField(Class, String, Class)\n\t * @see ReflectionUtils#makeAccessible(Field)\n\t * @see ReflectionUtils#getField(Field, Object)\n\t * @see AopTestUtils#getUltimateTargetObject(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetObject",
      "targetClass",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "Object",
    "signature": "public Object getField(@Nullable Object targetObject, @Nullable Class<?> targetClass, String name)",
    "source_code": "\tpublic static @Nullable Object getField(@Nullable Object targetObject, @Nullable Class<?> targetClass, String name) {\n\t\tAssert.isTrue(targetObject != null || targetClass != null,\n\t\t\t\"Either targetObject or targetClass for the field must be specified\");\n\n\t\tif (targetObject != null && springAopPresent) {\n\t\t\ttargetObject = AopTestUtils.getUltimateTargetObject(targetObject);\n\t\t}\n\t\tif (targetClass == null) {\n\t\t\ttargetClass = targetObject.getClass();\n\t\t}\n\n\t\tField field = ReflectionUtils.findField(targetClass, name);\n\t\tif (field == null) {\n\t\t\tthrow new IllegalArgumentException(String.format(\"Could not find field '%s' on %s or target class [%s]\",\n\t\t\t\t\tname, safeToString(targetObject), targetClass));\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Getting field '%s' from %s or target class [%s]\", name,\n\t\t\t\t\tsafeToString(targetObject), targetClass));\n\t\t}\n\t\tReflectionUtils.makeAccessible(field);\n\t\treturn ReflectionUtils.getField(field, targetObject);\n\t}"
  },
  "org.springframework.test.util.ReflectionTestUtils#invokeGetterMethod(target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the getter method with the given {@code name} on the supplied\n\t * target object with the supplied {@code value}.\n\t * <p>This method traverses the class hierarchy in search of the desired\n\t * method. In addition, an attempt will be made to make non-{@code public}\n\t * methods <em>accessible</em>, thus allowing one to invoke {@code protected},\n\t * {@code private}, and <em>package-private</em> getter methods.\n\t * <p>This method also supports JavaBean-style <em>property</em> names. For\n\t * example, if you wish to get the {@code name} property on the target object,\n\t * you may pass either {@code \"name\"} or {@code \"getName\"} as the method name.\n\t * <p>As of Spring Framework 6.2, if the supplied target object is a CGLIB\n\t * proxy which does not intercept the getter method, the proxy will be\n\t * {@linkplain AopTestUtils#getUltimateTargetObject unwrapped} allowing the\n\t * getter method to be invoked directly on the ultimate target of the proxy.\n\t * @param target the target object on which to invoke the specified getter\n\t * method\n\t * @param name the name of the getter method to invoke or the corresponding\n\t * property name\n\t * @return the value returned from the invocation\n\t * @see ReflectionUtils#findMethod(Class, String, Class[])\n\t * @see ReflectionUtils#makeAccessible(Method)\n\t * @see ReflectionUtils#invokeMethod(Method, Object, Object[])\n\t * @see AopTestUtils#getUltimateTargetObject(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "Object",
    "signature": "public Object invokeGetterMethod(Object target, String name)",
    "source_code": "\tpublic static @Nullable Object invokeGetterMethod(Object target, String name) {\n\t\tAssert.notNull(target, \"Target object must not be null\");\n\t\tAssert.hasText(name, \"Method name must not be empty\");\n\n\t\tString getterMethodName = name;\n\t\tif (!name.startsWith(GETTER_PREFIX)) {\n\t\t\tgetterMethodName = GETTER_PREFIX + StringUtils.capitalize(name);\n\t\t}\n\t\tMethod method = ReflectionUtils.findMethod(target.getClass(), getterMethodName);\n\t\tif (method == null && !getterMethodName.equals(name)) {\n\t\t\tgetterMethodName = name;\n\t\t\tmethod = ReflectionUtils.findMethod(target.getClass(), getterMethodName);\n\t\t}\n\t\tif (method == null) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"Could not find getter method '%s' on %s\", getterMethodName, safeToString(target)));\n\t\t}\n\n\t\tif (springAopPresent) {\n\t\t\t// If the target is a CGLIB proxy which does not intercept the method, invoke the\n\t\t\t// method on the ultimate target.\n\t\t\tif (isCglibProxyThatDoesNotInterceptMethod(target, method)) {\n\t\t\t\ttarget = AopTestUtils.getUltimateTargetObject(target);\n\t\t\t}\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Invoking getter method '%s' on %s\", getterMethodName, safeToString(target)));\n\t\t}\n\t\tReflectionUtils.makeAccessible(method);\n\t\treturn ReflectionUtils.invokeMethod(method, target);\n\t}"
  },
  "org.springframework.test.util.ReflectionTestUtils#invokeMethod(target,name,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method with the given {@code name} on the supplied target\n\t * object with the supplied arguments.\n\t * <p>This method delegates to {@link #invokeMethod(Object, Class, String, Object...)},\n\t * supplying {@code null} for the {@code targetClass} argument.\n\t * @param target the target object on which to invoke the specified method\n\t * @param name the name of the method to invoke\n\t * @param args the arguments to provide to the method\n\t * @return the invocation result, if any\n\t * @see #invokeMethod(Class, String, Object...)\n\t * @see #invokeMethod(Object, Class, String, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "T",
    "signature": "public T invokeMethod(Object target, String name, Object... args)",
    "source_code": "\tpublic static <T> @Nullable T invokeMethod(Object target, String name, Object... args) {\n\t\tAssert.notNull(target, \"Target object must not be null\");\n\t\treturn invokeMethod(target, null, name, args);\n\t}"
  },
  "org.springframework.test.util.ReflectionTestUtils#invokeMethod(targetClass,name,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the static method with the given {@code name} on the supplied target\n\t * class with the supplied arguments.\n\t * <p>This method delegates to {@link #invokeMethod(Object, Class, String, Object...)},\n\t * supplying {@code null} for the {@code targetObject} argument.\n\t * @param targetClass the target class on which to invoke the specified method\n\t * @param name the name of the method to invoke\n\t * @param args the arguments to provide to the method\n\t * @return the invocation result, if any\n\t * @since 5.2\n\t * @see #invokeMethod(Object, String, Object...)\n\t * @see #invokeMethod(Object, Class, String, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetClass",
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "T",
    "signature": "public T invokeMethod(Class<?> targetClass, String name, Object... args)",
    "source_code": "\tpublic static <T> @Nullable T invokeMethod(Class<?> targetClass, String name, Object... args) {\n\t\tAssert.notNull(targetClass, \"Target class must not be null\");\n\t\treturn invokeMethod(null, targetClass, name, args);\n\t}"
  },
  "org.springframework.test.util.ReflectionTestUtils#invokeMethod(targetObject,targetClass,name,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method with the given {@code name} on the provided\n\t * {@code targetObject}/{@code targetClass} with the supplied arguments.\n\t * <p>This method traverses the class hierarchy in search of the desired\n\t * method. In addition, an attempt will be made to make non-{@code public}\n\t * methods <em>accessible</em>, thus allowing one to invoke {@code protected},\n\t * {@code private}, and <em>package-private</em> methods.\n\t * <p>As of Spring Framework 6.2, if the supplied target object is a CGLIB\n\t * proxy which does not intercept the method, the proxy will be\n\t * {@linkplain AopTestUtils#getUltimateTargetObject unwrapped} allowing the\n\t * method to be invoked directly on the ultimate target of the proxy.\n\t * @param targetObject the target object on which to invoke the method; may\n\t * be {@code null} if the method is static\n\t * @param targetClass the target class on which to invoke the method; may\n\t * be {@code null} if the method is an instance method\n\t * @param name the name of the method to invoke\n\t * @param args the arguments to provide to the method\n\t * @return the invocation result, if any\n\t * @since 5.2\n\t * @see #invokeMethod(Object, String, Object...)\n\t * @see #invokeMethod(Class, String, Object...)\n\t * @see MethodInvoker\n\t * @see ReflectionUtils#makeAccessible(Method)\n\t * @see ReflectionUtils#handleReflectionException(Exception)\n\t * @see AopTestUtils#getUltimateTargetObject(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetObject",
      "targetClass",
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "T",
    "signature": "public T invokeMethod(@Nullable Object targetObject, @Nullable Class<?> targetClass, String name,\n\t\t\tObject... args)",
    "source_code": "\tpublic static <T> @Nullable T invokeMethod(@Nullable Object targetObject, @Nullable Class<?> targetClass, String name,"
  },
  "org.springframework.test.util.ReflectionTestUtils#invokeSetterMethod(target,name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the setter method with the given {@code name} on the supplied\n\t * target object with the supplied {@code value}.\n\t * <p>This method delegates to\n\t * {@link #invokeSetterMethod(Object, String, Object, Class)}, supplying\n\t * {@code null} for the parameter type.\n\t * @param target the target object on which to invoke the specified setter\n\t * method\n\t * @param name the name of the setter method to invoke or the corresponding\n\t * property name\n\t * @param value the value to provide to the setter method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "void",
    "signature": "public void invokeSetterMethod(Object target, String name, Object value)",
    "source_code": "\tpublic static void invokeSetterMethod(Object target, String name, Object value) {\n\t\tinvokeSetterMethod(target, name, value, null);\n\t}"
  },
  "org.springframework.test.util.ReflectionTestUtils#invokeSetterMethod(target,name,value,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the setter method with the given {@code name} on the supplied\n\t * target object with the supplied {@code value}.\n\t * <p>This method traverses the class hierarchy in search of the desired\n\t * method. In addition, an attempt will be made to make non-{@code public}\n\t * methods <em>accessible</em>, thus allowing one to invoke {@code protected},\n\t * {@code private}, and <em>package-private</em> setter methods.\n\t * <p>This method also supports JavaBean-style <em>property</em> names. For\n\t * example, if you wish to set the {@code name} property on the target object,\n\t * you may pass either {@code \"name\"} or {@code \"setName\"} as the method name.\n\t * <p>As of Spring Framework 6.2, if the supplied target object is a CGLIB\n\t * proxy which does not intercept the setter method, the proxy will be\n\t * {@linkplain AopTestUtils#getUltimateTargetObject unwrapped} allowing the\n\t * setter method to be invoked directly on the ultimate target of the proxy.\n\t * @param target the target object on which to invoke the specified setter\n\t * method\n\t * @param name the name of the setter method to invoke or the corresponding\n\t * property name\n\t * @param value the value to provide to the setter method\n\t * @param type the formal parameter type declared by the setter method\n\t * (may be {@code null} to indicate any type)\n\t * @see ReflectionUtils#findMethod(Class, String, Class[])\n\t * @see ReflectionUtils#makeAccessible(Method)\n\t * @see ReflectionUtils#invokeMethod(Method, Object, Object[])\n\t * @see AopTestUtils#getUltimateTargetObject(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "name",
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 329
    },
    "return": "void",
    "signature": "public void invokeSetterMethod(Object target, String name, @Nullable Object value, @Nullable Class<?> type)",
    "source_code": "\tpublic static void invokeSetterMethod(Object target, String name, @Nullable Object value, @Nullable Class<?> type) {\n\t\tAssert.notNull(target, \"Target object must not be null\");\n\t\tAssert.hasText(name, \"Method name must not be empty\");\n\t\tClass<?>[] paramTypes = (type != null ? new Class<?>[] {type} : null);\n\n\t\tString setterMethodName = name;\n\t\tif (!name.startsWith(SETTER_PREFIX)) {\n\t\t\tsetterMethodName = SETTER_PREFIX + StringUtils.capitalize(name);\n\t\t}\n\n\t\tMethod method = ReflectionUtils.findMethod(target.getClass(), setterMethodName, paramTypes);\n\t\tif (method == null && !setterMethodName.equals(name)) {\n\t\t\tsetterMethodName = name;\n\t\t\tmethod = ReflectionUtils.findMethod(target.getClass(), setterMethodName, paramTypes);\n\t\t}\n\t\tif (method == null) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"Could not find setter method '%s' on %s with parameter type [%s]\", setterMethodName,\n\t\t\t\t\tsafeToString(target), type));\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Invoking setter method '%s' on %s with value [%s]\", setterMethodName,\n\t\t\t\t\tsafeToString(target), value));\n\t\t}\n\n\t\tif (springAopPresent) {\n\t\t\t// If the target is a CGLIB proxy which does not intercept the method, invoke the\n\t\t\t// method on the ultimate target.\n\t\t\tif (isCglibProxyThatDoesNotInterceptMethod(target, method)) {\n\t\t\t\ttarget = AopTestUtils.getUltimateTargetObject(target);\n\t\t\t}\n\t\t}\n\n\t\tReflectionUtils.makeAccessible(method);\n\t\tReflectionUtils.invokeMethod(method, target, value);\n\t}"
  },
  "org.springframework.test.util.ReflectionTestUtils#setField(targetClass,name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the static {@linkplain Field field} with the given {@code name} on\n\t * the provided {@code targetClass} to the supplied {@code value}.\n\t * <p>This method delegates to {@link #setField(Object, Class, String, Object, Class)},\n\t * supplying {@code null} for the {@code targetObject} and {@code type} arguments.\n\t * <p>This method does not support setting {@code static final} fields.\n\t * @param targetClass the target class on which to set the static field;\n\t * never {@code null}\n\t * @param name the name of the field to set; never {@code null}\n\t * @param value the value to set\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetClass",
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "public void setField(Class<?> targetClass, String name, @Nullable Object value)",
    "source_code": "\tpublic static void setField(Class<?> targetClass, String name, @Nullable Object value) {\n\t\tsetField(null, targetClass, name, value, null);\n\t}"
  },
  "org.springframework.test.util.ReflectionTestUtils#setField(targetClass,name,value,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the static {@linkplain Field field} with the given\n\t * {@code name}/{@code type} on the provided {@code targetClass} to\n\t * the supplied {@code value}.\n\t * <p>This method delegates to {@link #setField(Object, Class, String, Object, Class)},\n\t * supplying {@code null} for the {@code targetObject} argument.\n\t * <p>This method does not support setting {@code static final} fields.\n\t * @param targetClass the target class on which to set the static field;\n\t * never {@code null}\n\t * @param name the name of the field to set; may be {@code null} if\n\t * {@code type} is specified\n\t * @param value the value to set\n\t * @param type the type of the field to set; may be {@code null} if\n\t * {@code name} is specified\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetClass",
      "name",
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void setField(Class<?> targetClass, @Nullable String name, @Nullable Object value, @Nullable Class<?> type)",
    "source_code": "\tpublic static void setField("
  },
  "org.springframework.test.util.ReflectionTestUtils#setField(targetObject,name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@linkplain Field field} with the given {@code name} on the\n\t * provided {@code targetObject} to the supplied {@code value}.\n\t * <p>This method delegates to {@link #setField(Object, String, Object, Class)},\n\t * supplying {@code null} for the {@code type} argument.\n\t * @param targetObject the target object on which to set the field; never {@code null}\n\t * @param name the name of the field to set; never {@code null}\n\t * @param value the value to set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetObject",
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void setField(Object targetObject, String name, @Nullable Object value)",
    "source_code": "\tpublic static void setField(Object targetObject, String name, @Nullable Object value) {\n\t\tsetField(targetObject, name, value, null);\n\t}"
  },
  "org.springframework.test.util.ReflectionTestUtils#setField(targetObject,name,value,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@linkplain Field field} with the given {@code name}/{@code type}\n\t * on the provided {@code targetObject} to the supplied {@code value}.\n\t * <p>This method delegates to {@link #setField(Object, Class, String, Object, Class)},\n\t * supplying {@code null} for the {@code targetClass} argument.\n\t * @param targetObject the target object on which to set the field; never {@code null}\n\t * @param name the name of the field to set; may be {@code null} if\n\t * {@code type} is specified\n\t * @param value the value to set\n\t * @param type the type of the field to set; may be {@code null} if\n\t * {@code name} is specified\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetObject",
      "name",
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void setField(Object targetObject, @Nullable String name, @Nullable Object value, @Nullable Class<?> type)",
    "source_code": "\tpublic static void setField(Object targetObject, @Nullable String name, @Nullable Object value, @Nullable Class<?> type) {\n\t\tsetField(targetObject, null, name, value, type);\n\t}"
  },
  "org.springframework.test.util.ReflectionTestUtils#setField(targetObject,targetClass,name,value,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@linkplain Field field} with the given {@code name}/{@code type}\n\t * on the provided {@code targetObject}/{@code targetClass} to the supplied\n\t * {@code value}.\n\t * <p>If the supplied {@code targetObject} is a <em>proxy</em>, it will\n\t * be {@linkplain AopTestUtils#getUltimateTargetObject unwrapped} allowing\n\t * the field to be set on the ultimate target of the proxy.\n\t * <p>This method traverses the class hierarchy in search of the desired\n\t * field. In addition, an attempt will be made to make non-{@code public}\n\t * fields <em>accessible</em>, thus allowing one to set {@code protected},\n\t * {@code private}, and <em>package-private</em> fields.\n\t * <p>This method does not support setting {@code static final} fields.\n\t * @param targetObject the target object on which to set the field; may be\n\t * {@code null} if the field is static\n\t * @param targetClass the target class on which to set the field; may\n\t * be {@code null} if the field is an instance field\n\t * @param name the name of the field to set; may be {@code null} if\n\t * {@code type} is specified\n\t * @param value the value to set\n\t * @param type the type of the field to set; may be {@code null} if\n\t * {@code name} is specified\n\t * @since 4.2\n\t * @see ReflectionUtils#findField(Class, String, Class)\n\t * @see ReflectionUtils#makeAccessible(Field)\n\t * @see ReflectionUtils#setField(Field, Object, Object)\n\t * @see AopTestUtils#getUltimateTargetObject(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetObject",
      "targetClass",
      "name",
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "void",
    "signature": "public void setField(@Nullable Object targetObject, @Nullable Class<?> targetClass,\n\t\t\t@Nullable String name, @Nullable Object value, @Nullable Class<?> type)",
    "source_code": "\tpublic static void setField(@Nullable Object targetObject, @Nullable Class<?> targetClass,"
  },
  "org.springframework.test.util.XpathExpectationsHelper": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A helper class for applying assertions via XPath expressions.\n *\n * @author Rossen Stoyanchev\n * @since 3.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class XpathExpectationsHelper",
    "source_code": "public class XpathExpectationsHelper {\n\n\tprivate final String expression;\n\n\tprivate final XPathExpression xpathExpression;\n\n\tprivate final boolean hasNamespaces;\n\n\n\t/**\n\t * XpathExpectationsHelper constructor.\n\t * @param expression the XPath expression\n\t * @param namespaces the XML namespaces referenced in the XPath expression, or {@code null}\n\t * @param args arguments to parameterize the XPath expression with using the\n\t * formatting specifiers defined in {@link String#format(String, Object...)}\n\t * @throws XPathExpressionException if expression compilation failed\n\t */\n\tpublic XpathExpectationsHelper(String expression, @Nullable Map<String, String> namespaces, Object... args)\n\t\t\tthrows XPathExpressionException {\n\n\t\tthis.expression = String.format(expression, args);\n\t\tthis.xpathExpression = compileXpathExpression(this.expression, namespaces);\n\t\tthis.hasNamespaces = !CollectionUtils.isEmpty(namespaces);\n\t}\n\n\tprivate static XPathExpression compileXpathExpression(String expression,\n\t\t\t@Nullable Map<String, String> namespaces) throws XPathExpressionException {\n\n\t\tSimpleNamespaceContext namespaceContext = new SimpleNamespaceContext();\n\t\tnamespaceContext.setBindings(namespaces != null ? namespaces : Collections.emptyMap());\n\t\tXPath xpath = XPathFactory.newInstance().newXPath();\n\t\txpath.setNamespaceContext(namespaceContext);\n\t\treturn xpath.compile(expression);\n\t}\n\n\n\t/**\n\t * Return the compiled XPath expression.\n\t */\n\tprotected XPathExpression getXpathExpression() {\n\t\treturn this.xpathExpression;\n\t}\n\n\n\t/**\n\t * Parse the content, evaluate the XPath expression as a {@link Node},\n\t * and assert it with the given {@code Matcher<Node>}.\n\t */\n\tpublic void assertNode(byte[] content, @Nullable String encoding, Matcher<? super Node> matcher)\n\t\t\tthrows Exception {\n\n\t\tNode node = evaluateXpath(content, encoding, Node.class);\n\t\tMatcherAssert.assertThat(\"XPath \" + this.expression, node, matcher);\n\t}\n\n\t/**\n\t * Parse the content, evaluate the XPath expression as a {@link NodeList},\n\t * and assert it with the given {@code Matcher<NodeList>}.\n\t * @since 5.2.2\n\t */\n\tpublic void assertNodeList(byte[] content, @Nullable String encoding, Matcher<? super NodeList> matcher)\n\t\t\tthrows Exception {\n\n\t\tDocument document = parseXmlByteArray(content, encoding);\n\t\tNodeList nodeList = evaluateXpath(document, XPathConstants.NODESET, NodeList.class);\n\t\tMatcherAssert.assertThat(\"XPath \" + getXpathExpression(), nodeList, matcher);\n\t}\n\n\t/**\n\t * Apply the XPath expression and assert the resulting content exists.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */\n\tpublic void exists(byte[] content, @Nullable String encoding) throws Exception {\n\t\tNode node = evaluateXpath(content, encoding, Node.class);\n\t\tAssertionErrors.assertNotNull(\"XPath \" + this.expression + \" does not exist\", node);\n\t}\n\n\t/**\n\t * Apply the XPath expression and assert the resulting content does not exist.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */\n\tpublic void doesNotExist(byte[] content, @Nullable String encoding) throws Exception {\n\t\tNode node = evaluateXpath(content, encoding, Node.class);\n\t\tAssertionErrors.assertNull(\"XPath \" + this.expression + \" exists\", node);\n\t}\n\n\t/**\n\t * Apply the XPath expression and assert the resulting content with the\n\t * given Hamcrest matcher.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */\n\tpublic void assertNodeCount(byte[] content, @Nullable String encoding, Matcher<? super Integer> matcher)\n\t\t\tthrows Exception {\n\n\t\tNodeList nodeList = evaluateXpath(content, encoding, NodeList.class);\n\t\tString reason = \"nodeCount for XPath \" + this.expression;\n\t\tMatcherAssert.assertThat(reason, nodeList != null ? nodeList.getLength() : 0, matcher);\n\t}\n\n\t/**\n\t * Apply the XPath expression and assert the resulting content as an integer.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */\n\tpublic void assertNodeCount(byte[] content, @Nullable String encoding, int expectedCount) throws Exception {\n\t\tNodeList nodeList = evaluateXpath(content, encoding, NodeList.class);\n\t\tAssertionErrors.assertEquals(\"nodeCount for XPath \" + this.expression, expectedCount,\n\t\t\t\t(nodeList != null ? nodeList.getLength() : 0));\n\t}\n\n\t/**\n\t * Apply the XPath expression and assert the resulting content with the\n\t * given Hamcrest matcher.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */\n\tpublic void assertString(byte[] content, @Nullable String encoding, Matcher<? super String> matcher)\n\t\t\tthrows Exception {\n\n\t\tString actual = evaluateXpath(content, encoding, String.class);\n\t\tMatcherAssert.assertThat(\"XPath \" + this.expression, actual, matcher);\n\t}\n\n\t/**\n\t * Apply the XPath expression and assert the resulting content as a String.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */\n\tpublic void assertString(byte[] content, @Nullable String encoding, String expectedValue) throws Exception {\n\t\tString actual = evaluateXpath(content, encoding, String.class);\n\t\tAssertionErrors.assertEquals(\"XPath \" + this.expression, expectedValue, actual);\n\t}\n\n\t/**\n\t * Apply the XPath expression and assert the resulting content with the\n\t * given Hamcrest matcher.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */\n\tpublic void assertNumber(byte[] content, @Nullable String encoding, Matcher<? super Double> matcher) throws Exception {\n\t\tDouble actual = evaluateXpath(content, encoding, Double.class);\n\t\tMatcherAssert.assertThat(\"XPath \" + this.expression, actual, matcher);\n\t}\n\n\t/**\n\t * Apply the XPath expression and assert the resulting content as a Double.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */\n\tpublic void assertNumber(byte[] content, @Nullable String encoding, Double expectedValue) throws Exception {\n\t\tDouble actual = evaluateXpath(content, encoding, Double.class);\n\t\tAssertionErrors.assertEquals(\"XPath \" + this.expression, expectedValue, actual);\n\t}\n\n\t/**\n\t * Apply the XPath expression and assert the resulting content as a Boolean.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */\n\tpublic void assertBoolean(byte[] content, @Nullable String encoding, boolean expectedValue) throws Exception {\n\t\tString actual = evaluateXpath(content, encoding, String.class);\n\t\tAssertionErrors.assertEquals(\"XPath \" + this.expression, expectedValue, Boolean.parseBoolean(actual));\n\t}\n\n\t/**\n\t * Evaluate the XPath and return the resulting value.\n\t * @param content the content to evaluate against\n\t * @param encoding the encoding to use (optionally)\n\t * @param targetClass the target class, one of Number, String, Boolean,\n\t * org.w3c.Node, or NodeList\n\t * @throws Exception if content parsing or expression evaluation fails\n\t * @since 5.1\n\t */\n\tpublic <T> @Nullable T evaluateXpath(byte[] content, @Nullable String encoding, Class<T> targetClass) throws Exception {\n\t\tDocument document = parseXmlByteArray(content, encoding);\n\t\treturn evaluateXpath(document, toQName(targetClass), targetClass);\n\t}\n\n\t/**\n\t * Parse the given XML content to a {@link Document}.\n\t * @param xml the content to parse\n\t * @param encoding optional content encoding, if provided as metadata (for example, in HTTP headers)\n\t * @return the parsed document\n\t */\n\tprotected Document parseXmlByteArray(byte[] xml, @Nullable String encoding) throws Exception {\n\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t\tfactory.setNamespaceAware(this.hasNamespaces);\n\t\tDocumentBuilder documentBuilder = factory.newDocumentBuilder();\n\t\tInputSource inputSource = new InputSource(new ByteArrayInputStream(xml));\n\t\tif (StringUtils.hasText(encoding)) {\n\t\t\tinputSource.setEncoding(encoding);\n\t\t}\n\t\treturn documentBuilder.parse(inputSource);\n\t}\n\n\t/**\n\t * Apply the XPath expression to given document.\n\t * @throws XPathExpressionException if expression evaluation failed\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected <T> @Nullable T evaluateXpath(Document document, QName evaluationType, Class<T> expectedClass)\n\t\t\tthrows XPathExpressionException {\n\n\t\treturn (T) getXpathExpression().evaluate(document, evaluationType);\n\t}\n\n\tprivate <T> QName toQName(Class<T> expectedClass) {\n\t\tQName evaluationType;\n\t\tif (Number.class.isAssignableFrom(expectedClass)) {\n\t\t\tevaluationType = XPathConstants.NUMBER;\n\t\t}\n\t\telse if (CharSequence.class.isAssignableFrom(expectedClass)) {\n\t\t\tevaluationType = XPathConstants.STRING;\n\t\t}\n\t\telse if (Boolean.class.isAssignableFrom(expectedClass)) {\n\t\t\tevaluationType = XPathConstants.BOOLEAN;\n\t\t}\n\t\telse if (Node.class.isAssignableFrom(expectedClass)) {\n\t\t\tevaluationType = XPathConstants.NODE;\n\t\t}\n\t\telse if (NodeList.class.isAssignableFrom(expectedClass)) {\n\t\t\tevaluationType = XPathConstants.NODESET;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Unexpected target class \" + expectedClass + \". \" +\n\t\t\t\t\t\"Supported: numbers, strings, boolean, and org.w3c.Node and NodeList\");\n\t\t}\n\t\treturn evaluationType;\n\t}\n\n}"
  },
  "org.springframework.test.util.XpathExpectationsHelper#assertBoolean(content,encoding,expectedValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content as a Boolean.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "expectedValue"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void assertBoolean(byte[] content, @Nullable String encoding, boolean expectedValue)",
    "source_code": "\tpublic void assertBoolean(byte[] content, @Nullable String encoding, boolean expectedValue) throws Exception {\n\t\tString actual = evaluateXpath(content, encoding, String.class);\n\t\tAssertionErrors.assertEquals(\"XPath \" + this.expression, expectedValue, Boolean.parseBoolean(actual));\n\t}"
  },
  "org.springframework.test.util.XpathExpectationsHelper#assertNode(content,encoding,matcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the content, evaluate the XPath expression as a {@link Node},\n\t * and assert it with the given {@code Matcher<Node>}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void assertNode(byte[] content, @Nullable String encoding, Matcher<? super Node> matcher)",
    "source_code": "\tpublic void assertNode(byte[] content, @Nullable String encoding, Matcher<? super Node> matcher)"
  },
  "org.springframework.test.util.XpathExpectationsHelper#assertNodeCount(content,encoding,expectedCount)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content as an integer.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "expectedCount"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void assertNodeCount(byte[] content, @Nullable String encoding, int expectedCount)",
    "source_code": "\tpublic void assertNodeCount(byte[] content, @Nullable String encoding, int expectedCount) throws Exception {\n\t\tNodeList nodeList = evaluateXpath(content, encoding, NodeList.class);\n\t\tAssertionErrors.assertEquals(\"nodeCount for XPath \" + this.expression, expectedCount,\n\t\t\t\t(nodeList != null ? nodeList.getLength() : 0));\n\t}"
  },
  "org.springframework.test.util.XpathExpectationsHelper#assertNodeCount(content,encoding,matcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content with the\n\t * given Hamcrest matcher.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "public void assertNodeCount(byte[] content, @Nullable String encoding, Matcher<? super Integer> matcher)",
    "source_code": "\tpublic void assertNodeCount(byte[] content, @Nullable String encoding, Matcher<? super Integer> matcher)"
  },
  "org.springframework.test.util.XpathExpectationsHelper#assertNodeList(content,encoding,matcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the content, evaluate the XPath expression as a {@link NodeList},\n\t * and assert it with the given {@code Matcher<NodeList>}.\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void assertNodeList(byte[] content, @Nullable String encoding, Matcher<? super NodeList> matcher)",
    "source_code": "\tpublic void assertNodeList(byte[] content, @Nullable String encoding, Matcher<? super NodeList> matcher)"
  },
  "org.springframework.test.util.XpathExpectationsHelper#assertNumber(content,encoding,expectedValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content as a Double.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "expectedValue"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "void",
    "signature": "public void assertNumber(byte[] content, @Nullable String encoding, Double expectedValue)",
    "source_code": "\tpublic void assertNumber(byte[] content, @Nullable String encoding, Double expectedValue) throws Exception {\n\t\tDouble actual = evaluateXpath(content, encoding, Double.class);\n\t\tAssertionErrors.assertEquals(\"XPath \" + this.expression, expectedValue, actual);\n\t}"
  },
  "org.springframework.test.util.XpathExpectationsHelper#assertNumber(content,encoding,matcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content with the\n\t * given Hamcrest matcher.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "public void assertNumber(byte[] content, @Nullable String encoding, Matcher<? super Double> matcher)",
    "source_code": "\tpublic void assertNumber(byte[] content, @Nullable String encoding, Matcher<? super Double> matcher) throws Exception {\n\t\tDouble actual = evaluateXpath(content, encoding, Double.class);\n\t\tMatcherAssert.assertThat(\"XPath \" + this.expression, actual, matcher);\n\t}"
  },
  "org.springframework.test.util.XpathExpectationsHelper#assertString(content,encoding,expectedValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content as a String.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "expectedValue"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "void",
    "signature": "public void assertString(byte[] content, @Nullable String encoding, String expectedValue)",
    "source_code": "\tpublic void assertString(byte[] content, @Nullable String encoding, String expectedValue) throws Exception {\n\t\tString actual = evaluateXpath(content, encoding, String.class);\n\t\tAssertionErrors.assertEquals(\"XPath \" + this.expression, expectedValue, actual);\n\t}"
  },
  "org.springframework.test.util.XpathExpectationsHelper#assertString(content,encoding,matcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content with the\n\t * given Hamcrest matcher.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void assertString(byte[] content, @Nullable String encoding, Matcher<? super String> matcher)",
    "source_code": "\tpublic void assertString(byte[] content, @Nullable String encoding, Matcher<? super String> matcher)"
  },
  "org.springframework.test.util.XpathExpectationsHelper#doesNotExist(content,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content does not exist.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void doesNotExist(byte[] content, @Nullable String encoding)",
    "source_code": "\tpublic void doesNotExist(byte[] content, @Nullable String encoding) throws Exception {\n\t\tNode node = evaluateXpath(content, encoding, Node.class);\n\t\tAssertionErrors.assertNull(\"XPath \" + this.expression + \" exists\", node);\n\t}"
  },
  "org.springframework.test.util.XpathExpectationsHelper#evaluateXpath(content,encoding,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Evaluate the XPath and return the resulting value.\n\t * @param content the content to evaluate against\n\t * @param encoding the encoding to use (optionally)\n\t * @param targetClass the target class, one of Number, String, Boolean,\n\t * org.w3c.Node, or NodeList\n\t * @throws Exception if content parsing or expression evaluation fails\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "T",
    "signature": "public T evaluateXpath(byte[] content, @Nullable String encoding, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T evaluateXpath(byte[] content, @Nullable String encoding, Class<T> targetClass) throws Exception {\n\t\tDocument document = parseXmlByteArray(content, encoding);\n\t\treturn evaluateXpath(document, toQName(targetClass), targetClass);\n\t}"
  },
  "org.springframework.test.util.XpathExpectationsHelper#evaluateXpath(document,evaluationType,expectedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression to given document.\n\t * @throws XPathExpressionException if expression evaluation failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "document",
      "evaluationType",
      "expectedClass"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "T",
    "signature": "protected T evaluateXpath(Document document, QName evaluationType, Class<T> expectedClass)",
    "source_code": "\tprotected <T> @Nullable T evaluateXpath(Document document, QName evaluationType, Class<T> expectedClass)"
  },
  "org.springframework.test.util.XpathExpectationsHelper#exists(content,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content exists.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void exists(byte[] content, @Nullable String encoding)",
    "source_code": "\tpublic void exists(byte[] content, @Nullable String encoding) throws Exception {\n\t\tNode node = evaluateXpath(content, encoding, Node.class);\n\t\tAssertionErrors.assertNotNull(\"XPath \" + this.expression + \" does not exist\", node);\n\t}"
  },
  "org.springframework.test.util.XpathExpectationsHelper#getXpathExpression()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the compiled XPath expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "XPathExpression",
    "signature": "protected XPathExpression getXpathExpression()",
    "source_code": "\tprotected XPathExpression getXpathExpression() {\n\t\treturn this.xpathExpression;\n\t}"
  },
  "org.springframework.test.util.XpathExpectationsHelper#parseXmlByteArray(xml,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given XML content to a {@link Document}.\n\t * @param xml the content to parse\n\t * @param encoding optional content encoding, if provided as metadata (for example, in HTTP headers)\n\t * @return the parsed document\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "xml",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "Document",
    "signature": "protected Document parseXmlByteArray(byte[] xml, @Nullable String encoding)",
    "source_code": "\tprotected Document parseXmlByteArray(byte[] xml, @Nullable String encoding) throws Exception {\n\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t\tfactory.setNamespaceAware(this.hasNamespaces);\n\t\tDocumentBuilder documentBuilder = factory.newDocumentBuilder();\n\t\tInputSource inputSource = new InputSource(new ByteArrayInputStream(xml));\n\t\tif (StringUtils.hasText(encoding)) {\n\t\t\tinputSource.setEncoding(encoding);\n\t\t}\n\t\treturn documentBuilder.parse(inputSource);\n\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#accept(acceptableMediaTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptableMediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec accept(MediaType... acceptableMediaTypes)",
    "source_code": "\t\tpublic RequestBodySpec accept(MediaType... acceptableMediaTypes) {\n\t\t\tgetHeaders().setAccept(Arrays.asList(acceptableMediaTypes));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#acceptCharset(acceptableCharsets)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptableCharsets"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec acceptCharset(Charset... acceptableCharsets)",
    "source_code": "\t\tpublic RequestBodySpec acceptCharset(Charset... acceptableCharsets) {\n\t\t\tgetHeaders().setAcceptCharset(Arrays.asList(acceptableCharsets));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#attribute(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attribute(String name, Object value)",
    "source_code": "\t\tpublic RequestBodySpec attribute(String name, Object value) {\n\t\t\tthis.attributes.put(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#attributes(Consumer<Map<String,attributesConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<Map<String",
      "attributesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer)",
    "source_code": "\t\tpublic RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer) {\n\t\t\tattributesConsumer.accept(this.attributes);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#consumeWith(consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 717
    },
    "return": "BodyContentSpec",
    "signature": "public BodyContentSpec consumeWith(Consumer<EntityExchangeResult<byte[]>> consumer)",
    "source_code": "\t\tpublic BodyContentSpec consumeWith(Consumer<EntityExchangeResult<byte[]>> consumer) {\n\t\t\tthis.result.assertWithDiagnostics(() -> consumer.accept(this.result));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#contains(elements)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elements"
    ],
    "position": {
      "column": 1,
      "line": 609
    },
    "return": "ListBodySpec<E>",
    "signature": "public ListBodySpec<E> contains(@Nullable E... elements)",
    "source_code": "\t\tpublic ListBodySpec<E> contains(@Nullable E... elements) {\n\t\t\tList<E> expected = Arrays.asList(elements);\n\t\t\tList<@Nullable E> actual = getResult().getResponseBody();\n\t\t\tString message = \"Response body does not contain \" + expected;\n\t\t\tgetResult().assertWithDiagnostics(() ->\n\t\t\t\t\tAssertionErrors.assertTrue(message, (actual != null && actual.containsAll(expected))));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#contentLength(contentLength)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentLength"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec contentLength(long contentLength)",
    "source_code": "\t\tpublic RequestBodySpec contentLength(long contentLength) {\n\t\t\tgetHeaders().setContentLength(contentLength);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#contentType(contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 278
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec contentType(MediaType contentType)",
    "source_code": "\t\tpublic RequestBodySpec contentType(MediaType contentType) {\n\t\t\tgetHeaders().setContentType(contentType);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#cookie(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec cookie(String name, String value)",
    "source_code": "\t\tpublic RequestBodySpec cookie(String name, String value) {\n\t\t\tgetCookies().add(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#cookies(Consumer<MultiValueMap<String,cookiesConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<MultiValueMap<String",
      "cookiesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer)",
    "source_code": "\t\tpublic RequestBodySpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer) {\n\t\t\tcookiesConsumer.accept(getCookies());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#doesNotContain(elements)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elements"
    ],
    "position": {
      "column": 1,
      "line": 620
    },
    "return": "ListBodySpec<E>",
    "signature": "public ListBodySpec<E> doesNotContain(@Nullable E... elements)",
    "source_code": "\t\tpublic ListBodySpec<E> doesNotContain(@Nullable E... elements) {\n\t\t\tList<E> expected = Arrays.asList(elements);\n\t\t\tList<@Nullable E> actual = getResult().getResponseBody();\n\t\t\tString message = \"Response body should not have contained \" + expected;\n\t\t\tgetResult().assertWithDiagnostics(() ->\n\t\t\t\t\tAssertionErrors.assertTrue(message, (actual == null || !actual.containsAll(expected))));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#exchange()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 351
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec exchange()",
    "source_code": "\t\tpublic ResponseSpec exchange() {\n\t\t\tClientRequest request = (this.inserter != null ?\n\t\t\t\t\tinitRequestBuilder().body(this.inserter).build() :\n\t\t\t\t\tinitRequestBuilder().build());\n\n\t\t\tClientResponse response = DefaultWebTestClient.this.exchangeFunction.exchange(request).block(getResponseTimeout());\n\t\t\tAssert.state(response != null, \"No ClientResponse\");\n\n\t\t\tExchangeResult result = DefaultWebTestClient.this.wiretapConnector.getExchangeResult(\n\t\t\t\t\tthis.requestId, this.uriTemplate, getResponseTimeout());\n\n\t\t\treturn new DefaultResponseSpec(result, response,\n\t\t\t\t\tDefaultWebTestClient.this.jsonEncoderDecoder,\n\t\t\t\t\tDefaultWebTestClient.this.entityResultConsumer, getResponseTimeout());\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#expectAll(consumers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumers"
    ],
    "position": {
      "column": 1,
      "line": 508
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec expectAll(ResponseSpecConsumer... consumers)",
    "source_code": "\t\tpublic ResponseSpec expectAll(ResponseSpecConsumer... consumers) {\n\t\t\tExceptionCollector exceptionCollector = new ExceptionCollector();\n\t\t\tfor (ResponseSpecConsumer consumer : consumers) {\n\t\t\t\texceptionCollector.execute(() -> consumer.accept(this));\n\t\t\t}\n\t\t\ttry {\n\t\t\t\texceptionCollector.assertEmpty();\n\t\t\t}\n\t\t\tcatch (RuntimeException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\t// In theory, a ResponseSpecConsumer should never throw an Exception\n\t\t\t\t// that is not a RuntimeException, but since ExceptionCollector may\n\t\t\t\t// throw a checked Exception, we handle this to appease the compiler\n\t\t\t\t// and in case someone uses a \"sneaky throws\" technique.\n\t\t\t\tthrow new AssertionError(ex.getMessage(), ex);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#expectBody()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 468
    },
    "return": "BodyContentSpec",
    "signature": "public BodyContentSpec expectBody()",
    "source_code": "\t\tpublic BodyContentSpec expectBody() {\n\t\t\tByteArrayResource resource = this.response.bodyToMono(ByteArrayResource.class).block(this.timeout);\n\t\t\tbyte[] body = (resource != null ? resource.getByteArray() : null);\n\t\t\tEntityExchangeResult<byte[]> entityResult = initEntityExchangeResult(body);\n\t\t\treturn new DefaultBodyContentSpec(entityResult, this.jsonEncoderDecoder);\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#expectBodyList(elementType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 456
    },
    "return": "ListBodySpec<E>",
    "signature": "public ListBodySpec<E> expectBodyList(ParameterizedTypeReference<E> elementType)",
    "source_code": "\t\tpublic <E> ListBodySpec<E> expectBodyList(ParameterizedTypeReference<E> elementType) {\n\t\t\tFlux<E> flux = this.response.bodyToFlux(elementType);\n\t\t\treturn getListBodySpec(flux);\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#expectCookie()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "CookieAssertions",
    "signature": "public CookieAssertions expectCookie()",
    "source_code": "\t\tpublic CookieAssertions expectCookie() {\n\t\t\treturn new CookieAssertions(this.exchangeResult, this);\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#expectHeader()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 427
    },
    "return": "HeaderAssertions",
    "signature": "public HeaderAssertions expectHeader()",
    "source_code": "\t\tpublic HeaderAssertions expectHeader() {\n\t\t\treturn new HeaderAssertions(this.exchangeResult, this);\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#expectStatus()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 422
    },
    "return": "StatusAssertions",
    "signature": "public StatusAssertions expectStatus()",
    "source_code": "\t\tpublic StatusAssertions expectStatus() {\n\t\t\treturn new StatusAssertions(this.exchangeResult, this);\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#getResult()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 539
    },
    "return": "EntityExchangeResult<B>",
    "signature": "protected EntityExchangeResult<B> getResult()",
    "source_code": "\t\tprotected EntityExchangeResult<B> getResult() {\n\t\t\treturn this.result;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#hasSize(size)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "size"
    ],
    "position": {
      "column": 1,
      "line": 599
    },
    "return": "ListBodySpec<E>",
    "signature": "public ListBodySpec<E> hasSize(int size)",
    "source_code": "\t\tpublic ListBodySpec<E> hasSize(int size) {\n\t\t\tList<@Nullable E> actual = getResult().getResponseBody();\n\t\t\tString message = \"Response body does not contain \" + size + \" elements\";\n\t\t\tgetResult().assertWithDiagnostics(() ->\n\t\t\t\t\tAssertionErrors.assertEquals(message, size, (actual != null ? actual.size() : 0)));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#header(headerName,headerValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic RequestBodySpec header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tgetHeaders().add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#headers(headersConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headersConsumer"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec headers(Consumer<HttpHeaders> headersConsumer)",
    "source_code": "\t\tpublic RequestBodySpec headers(Consumer<HttpHeaders> headersConsumer) {\n\t\t\theadersConsumer.accept(getHeaders());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#ifModifiedSince(ifModifiedSince)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ifModifiedSince"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec ifModifiedSince(ZonedDateTime ifModifiedSince)",
    "source_code": "\t\tpublic RequestBodySpec ifModifiedSince(ZonedDateTime ifModifiedSince) {\n\t\t\tgetHeaders().setIfModifiedSince(ifModifiedSince);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#ifNoneMatch(ifNoneMatches)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ifNoneMatches"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec ifNoneMatch(String... ifNoneMatches)",
    "source_code": "\t\tpublic RequestBodySpec ifNoneMatch(String... ifNoneMatches) {\n\t\t\tgetHeaders().setIfNoneMatch(Arrays.asList(ifNoneMatches));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 651
    },
    "return": "EntityExchangeResult<Void>",
    "signature": "public EntityExchangeResult<Void> isEmpty()",
    "source_code": "\t\tpublic EntityExchangeResult<Void> isEmpty() {\n\t\t\tthis.result.assertWithDiagnostics(() ->\n\t\t\t\t\tAssertionErrors.assertTrue(\"Expected empty body\", this.isEmpty));\n\t\t\treturn new EntityExchangeResult<>(this.result, null);\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#isEqualTo(expected)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expected"
    ],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "T",
    "signature": "public T isEqualTo(@Nullable B expected)",
    "source_code": "\t\tpublic <T extends S> T isEqualTo(@Nullable B expected) {\n\t\t\tthis.result.assertWithDiagnostics(() ->\n\t\t\t\t\tAssertionErrors.assertEquals(\"Response body\", expected, this.result.getResponseBody()));\n\t\t\treturn self();\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#json(expectedJson,comparator)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedJson",
      "comparator"
    ],
    "position": {
      "column": 1,
      "line": 670
    },
    "return": "BodyContentSpec",
    "signature": "public BodyContentSpec json(String expectedJson, JsonComparator comparator)",
    "source_code": "\t\tpublic BodyContentSpec json(String expectedJson, JsonComparator comparator) {\n\t\t\tthis.result.assertWithDiagnostics(() -> {\n\t\t\t\ttry {\n\t\t\t\t\tcomparator.assertIsMatch(expectedJson, getBodyAsString());\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AssertionError(\"JSON parsing error\", ex);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#json(expectedJson,compareMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedJson",
      "compareMode"
    ],
    "position": {
      "column": 1,
      "line": 665
    },
    "return": "BodyContentSpec",
    "signature": "public BodyContentSpec json(String expectedJson, JsonCompareMode compareMode)",
    "source_code": "\t\tpublic BodyContentSpec json(String expectedJson, JsonCompareMode compareMode) {\n\t\t\treturn json(expectedJson, JsonAssert.comparator(compareMode));\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#json(json,strict)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "json",
      "strict"
    ],
    "position": {
      "column": 1,
      "line": 659
    },
    "return": "BodyContentSpec",
    "signature": "public BodyContentSpec json(String json, boolean strict)",
    "source_code": "\t\tpublic BodyContentSpec json(String json, boolean strict) {\n\t\t\tJsonCompareMode compareMode = (strict ? JsonCompareMode.STRICT : JsonCompareMode.LENIENT);\n\t\t\treturn json(json, compareMode);\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#jsonPath(expression)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression"
    ],
    "position": {
      "column": 1,
      "line": 696
    },
    "return": "JsonPathAssertions",
    "signature": "public JsonPathAssertions jsonPath(String expression)",
    "source_code": "\t\tpublic JsonPathAssertions jsonPath(String expression) {\n\t\t\treturn new JsonPathAssertions(this, getBodyAsString(), expression,\n\t\t\t\t\tJsonPathConfigurationProvider.getConfiguration(this.jsonEncoderDecoder));\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#map(source,targetType,configuration)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "targetType",
      "configuration"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "T",
    "signature": "public T map(Object source, TypeRef<T> targetType, Configuration configuration)",
    "source_code": "\tpublic <T> @Nullable T map(Object source, TypeRef<T> targetType, Configuration configuration) {\n\t\treturn mapToTargetType(source, ResolvableType.forType(targetType.getType()));\n\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#method(httpMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "httpMethod"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "RequestBodyUriSpec",
    "signature": "public RequestBodyUriSpec method(HttpMethod httpMethod)",
    "source_code": "\tpublic RequestBodyUriSpec method(HttpMethod httpMethod) {\n\t\treturn methodInternal(httpMethod);\n\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#mutate()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "Builder",
    "signature": "public Builder mutate()",
    "source_code": "\tpublic Builder mutate() {\n\t\treturn new DefaultWebTestClientBuilder(this.builder);\n\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#mutateWith(configurer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configurer"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "WebTestClient",
    "signature": "public WebTestClient mutateWith(WebTestClientConfigurer configurer)",
    "source_code": "\tpublic WebTestClient mutateWith(WebTestClientConfigurer configurer) {\n\t\treturn mutate().apply(configurer).build();\n\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#patch()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "RequestBodyUriSpec",
    "signature": "public RequestBodyUriSpec patch()",
    "source_code": "\tpublic RequestBodyUriSpec patch() {\n\t\treturn methodInternal(HttpMethod.PATCH);\n\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#post()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "RequestBodyUriSpec",
    "signature": "public RequestBodyUriSpec post()",
    "source_code": "\tpublic RequestBodyUriSpec post() {\n\t\treturn methodInternal(HttpMethod.POST);\n\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#put()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "RequestBodyUriSpec",
    "signature": "public RequestBodyUriSpec put()",
    "source_code": "\tpublic RequestBodyUriSpec put() {\n\t\treturn methodInternal(HttpMethod.PUT);\n\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#returnResult()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 723
    },
    "return": "EntityExchangeResult<byte[]>",
    "signature": "public EntityExchangeResult<byte[]> returnResult()",
    "source_code": "\t\tpublic EntityExchangeResult<byte[]> returnResult() {\n\t\t\treturn this.result;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#returnResult(elementClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 482
    },
    "return": "FluxExchangeResult<T>",
    "signature": "public FluxExchangeResult<T> returnResult(Class<T> elementClass)",
    "source_code": "\t\tpublic <T> FluxExchangeResult<T> returnResult(Class<T> elementClass) {\n\t\t\tFlux<T> body;\n\t\t\tif (elementClass.equals(Void.class)) {\n\t\t\t\tthis.response.releaseBody().block();\n\t\t\t\tbody = Flux.empty();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbody = this.response.bodyToFlux(elementClass);\n\t\t\t}\n\t\t\treturn new FluxExchangeResult<>(this.exchangeResult, body);\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#returnResult(elementTypeRef)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 495
    },
    "return": "FluxExchangeResult<T>",
    "signature": "public FluxExchangeResult<T> returnResult(ParameterizedTypeReference<T> elementTypeRef)",
    "source_code": "\t\tpublic <T> FluxExchangeResult<T> returnResult(ParameterizedTypeReference<T> elementTypeRef) {\n\t\t\tFlux<T> body;\n\t\t\tif (elementTypeRef.getType().equals(Void.class)) {\n\t\t\t\tthis.response.releaseBody().block();\n\t\t\t\tbody = Flux.empty();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbody = this.response.bodyToFlux(elementTypeRef);\n\t\t\t}\n\t\t\treturn new FluxExchangeResult<>(this.exchangeResult, body);\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#uri(Function<UriBuilder,uriFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(Function<UriBuilder, URI> uriFunction) {\n\t\t\tthis.uriTemplate = null;\n\t\t\treturn uri(uriFunction.apply(DefaultWebTestClient.this.uriBuilderFactory.builder()));\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#uri(uri)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(URI uri)",
    "source_code": "\t\tpublic RequestBodySpec uri(URI uri) {\n\t\t\tthis.uri = uri;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#uri(uriTemplate,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Map<String, ? extends @Nullable Object> uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Map<String, ? extends @Nullable Object> uriVariables) {\n\t\t\tthis.uriTemplate = uriTemplate;\n\t\t\treturn uri(DefaultWebTestClient.this.uriBuilderFactory.expand(uriTemplate, uriVariables));\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#uri(uriTemplate,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, @Nullable Object... uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, @Nullable Object... uriVariables) {\n\t\t\tthis.uriTemplate = uriTemplate;\n\t\t\treturn uri(DefaultWebTestClient.this.uriBuilderFactory.expand(uriTemplate, uriVariables));\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#value(B,bodyMapper,matcher)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "B",
      "bodyMapper",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 558
    },
    "return": "T",
    "signature": "public T value(Function<@Nullable B, @Nullable R> bodyMapper, Matcher<? super @Nullable R> matcher)",
    "source_code": "\t\tpublic <T extends S, R> T value(Function<@Nullable B, @Nullable R> bodyMapper, Matcher<? super @Nullable R> matcher) {\n\t\t\tthis.result.assertWithDiagnostics(() -> {\n\t\t\t\tB body = this.result.getResponseBody();\n\t\t\t\tMatcherAssert.assertThat(bodyMapper.apply(body), matcher);\n\t\t\t});\n\t\t\treturn self();\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#value(consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "T",
    "signature": "public T value(Consumer<@Nullable B> consumer)",
    "source_code": "\t\tpublic <T extends S> T value(Consumer<@Nullable B> consumer) {\n\t\t\tthis.result.assertWithDiagnostics(() -> consumer.accept(this.result.getResponseBody()));\n\t\t\treturn self();\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#value(matcher)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 551
    },
    "return": "T",
    "signature": "public T value(Matcher<? super @Nullable B> matcher)",
    "source_code": "\t\tpublic <T extends S> T value(Matcher<? super @Nullable B> matcher) {\n\t\t\tthis.result.assertWithDiagnostics(() -> MatcherAssert.assertThat(this.result.getResponseBody(), matcher));\n\t\t\treturn self();\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#xml(expectedXml)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedXml"
    ],
    "position": {
      "column": 1,
      "line": 683
    },
    "return": "BodyContentSpec",
    "signature": "public BodyContentSpec xml(String expectedXml)",
    "source_code": "\t\tpublic BodyContentSpec xml(String expectedXml) {\n\t\t\tthis.result.assertWithDiagnostics(() -> {\n\t\t\t\ttry {\n\t\t\t\t\tnew XmlExpectationsHelper().assertXmlEqual(expectedXml, getBodyAsString());\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AssertionError(\"XML parsing error\", ex);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#xpath(expression,Map<String,namespaces,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression",
      "Map<String",
      "namespaces",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 702
    },
    "return": "XpathAssertions",
    "signature": "public XpathAssertions xpath(String expression, @Nullable Map<String, String> namespaces, Object... args)",
    "source_code": "\t\tpublic XpathAssertions xpath(String expression, @Nullable Map<String, String> namespaces, Object... args) {\n\t\t\treturn new XpathAssertions(this, expression, namespaces, args);\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.ExchangeResult#getRawStatusCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HTTP status code as an integer.\n\t * @since 5.1.10\n\t * @deprecated in favor of {@link #getStatus()}, for removal in 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "int",
    "signature": "public int getRawStatusCode()",
    "source_code": "\tpublic int getRawStatusCode() {\n\t\treturn getStatus().value();\n\t}"
  },
  "org.springframework.test.web.reactive.server.ExchangeResult#getRequestBodyContent()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the raw request body content written through the request.\n\t * <p><strong>Note:</strong> If the request content has not been consumed\n\t * for any reason yet, use of this method will trigger consumption.\n\t * @throws IllegalStateException if the request body has not been fully written.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "byte[]",
    "signature": "public byte[] getRequestBodyContent()",
    "source_code": "\tpublic byte[] getRequestBodyContent() {\n\t\treturn this.requestBody.block(this.timeout);\n\t}"
  },
  "org.springframework.test.web.reactive.server.ExchangeResult#getResponseBodyContent()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the raw request body content written to the response.\n\t * <p><strong>Note:</strong> If the response content has not been consumed\n\t * yet, use of this method will trigger consumption.\n\t * @throws IllegalStateException if the response has not been fully read.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "byte[]",
    "signature": "public byte[] getResponseBodyContent()",
    "source_code": "\tpublic byte[] getResponseBodyContent() {\n\t\treturn this.responseBody.block(this.timeout);\n\t}"
  },
  "org.springframework.test.web.reactive.server.WebTestClient": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Client for testing web servers that uses {@link WebClient} internally to\n * perform requests while also providing a fluent API to verify responses.\n * This client can connect to any server over HTTP, or to a WebFlux application\n * via mock request and response objects.\n *\n * <p>Use one of the bindToXxx methods to create an instance. For example:\n * <ul>\n * <li>{@link #bindToController(Object...)}\n * <li>{@link #bindToRouterFunction(RouterFunction)}\n * <li>{@link #bindToApplicationContext(ApplicationContext)}\n * <li>{@link #bindToServer()}\n * <li>...\n * </ul>\n *\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @author Sam Brannen\n * @author Micha\u0142 Rowicki\n * @since 5.0\n * @see StatusAssertions\n * @see HeaderAssertions\n * @see JsonPathAssertions\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "signature": "public interface WebTestClient",
    "source_code": "public interface WebTestClient {\n\n\t/**\n\t * The name of a request header used to assign a unique id to every request\n\t * performed through the {@code WebTestClient}. This can be useful for\n\t * storing contextual information at all phases of request processing (for example,\n\t * from a server-side component) under that id and later to look up\n\t * that information once an {@link ExchangeResult} is available.\n\t */\n\tString WEBTESTCLIENT_REQUEST_ID = \"WebTestClient-Request-Id\";\n\n\n\t/**\n\t * Prepare an HTTP GET request.\n\t * @return a spec for specifying the target URL\n\t */\n\tRequestHeadersUriSpec<?> get();\n\n\t/**\n\t * Prepare an HTTP HEAD request.\n\t * @return a spec for specifying the target URL\n\t */\n\tRequestHeadersUriSpec<?> head();\n\n\t/**\n\t * Prepare an HTTP POST request.\n\t * @return a spec for specifying the target URL\n\t */\n\tRequestBodyUriSpec post();\n\n\t/**\n\t * Prepare an HTTP PUT request.\n\t * @return a spec for specifying the target URL\n\t */\n\tRequestBodyUriSpec put();\n\n\t/**\n\t * Prepare an HTTP PATCH request.\n\t * @return a spec for specifying the target URL\n\t */\n\tRequestBodyUriSpec patch();\n\n\t/**\n\t * Prepare an HTTP DELETE request.\n\t * @return a spec for specifying the target URL\n\t */\n\tRequestHeadersUriSpec<?> delete();\n\n\t/**\n\t * Prepare an HTTP OPTIONS request.\n\t * @return a spec for specifying the target URL\n\t */\n\tRequestHeadersUriSpec<?> options();\n\n\t/**\n\t * Prepare a request for the specified {@code HttpMethod}.\n\t * @return a spec for specifying the target URL\n\t */\n\tRequestBodyUriSpec method(HttpMethod method);\n\n\n\t/**\n\t * Return a builder to mutate properties of this web test client.\n\t */\n\tBuilder mutate();\n\n\t/**\n\t * Mutate the {@link WebTestClient}, apply the given configurer, and build\n\t * a new instance. Essentially a shortcut for:\n\t * <pre>\n\t * mutate().apply(configurer).build();\n\t * </pre>\n\t * @param configurer the configurer to apply\n\t * @return the mutated test client\n\t */\n\tWebTestClient mutateWith(WebTestClientConfigurer configurer);\n\n\n\t// Static factory methods\n\n\t/**\n\t * Use this server setup to test one {@code @Controller} at a time.\n\t * This option loads the default configuration of\n\t * {@link org.springframework.web.reactive.config.EnableWebFlux @EnableWebFlux}.\n\t * There are builder methods to customize the Java config. The resulting\n\t * WebFlux application will be tested without an HTTP server using a mock\n\t * request and response.\n\t * @param controllers one or more controller instances to test\n\t * (specified {@code Class} will be turned into instance)\n\t * @return chained API to customize server and client config; use\n\t * {@link MockServerSpec#configureClient()} to transition to client config\n\t */\n\tstatic ControllerSpec bindToController(Object... controllers) {\n\t\treturn new DefaultControllerSpec(controllers);\n\t}\n\n\t/**\n\t * Use this option to set up a server from a {@link RouterFunction}.\n\t * Internally the provided configuration is passed to\n\t * {@code RouterFunctions#toWebHandler}. The resulting WebFlux application\n\t * will be tested without an HTTP server using a mock request and response.\n\t * @param routerFunction the RouterFunction to test\n\t * @return chained API to customize server and client config; use\n\t * {@link MockServerSpec#configureClient()} to transition to client config\n\t */\n\tstatic RouterFunctionSpec bindToRouterFunction(RouterFunction<?> routerFunction) {\n\t\treturn new DefaultRouterFunctionSpec(routerFunction);\n\t}\n\n\t/**\n\t * Use this option to set up a server from the Spring configuration of your\n\t * application, or some subset of it. Internally the provided configuration\n\t * is passed to {@code WebHttpHandlerBuilder} to set up the request\n\t * processing chain. The resulting WebFlux application will be tested\n\t * without an HTTP server using a mock request and response.\n\t * <p>Consider using the TestContext framework and\n\t * {@link org.springframework.test.context.ContextConfiguration @ContextConfiguration}\n\t * in order to efficiently load and inject the Spring configuration into the\n\t * test class.\n\t * @param applicationContext the Spring context\n\t * @return chained API to customize server and client config; use\n\t * {@link MockServerSpec#configureClient()} to transition to client config\n\t */\n\tstatic MockServerSpec<?> bindToApplicationContext(ApplicationContext applicationContext) {\n\t\treturn new ApplicationContextSpec(applicationContext);\n\t}\n\n\t/**\n\t * Integration testing with a \"mock\" server targeting the given WebHandler.\n\t * @param webHandler the handler to test\n\t * @return chained API to customize server and client config; use\n\t * {@link MockServerSpec#configureClient()} to transition to client config\n\t */\n\tstatic MockServerSpec<?> bindToWebHandler(WebHandler webHandler) {\n\t\treturn new DefaultMockServerSpec(webHandler);\n\t}\n\n\t/**\n\t * This server setup option allows you to connect to a live server through\n\t * a Reactor Netty client connector.\n\t * <p><pre class=\"code\">\n\t * WebTestClient client = WebTestClient.bindToServer()\n\t *         .baseUrl(\"http://localhost:8080\")\n\t *         .build();\n\t * </pre>\n\t * @return chained API to customize client config\n\t */\n\tstatic Builder bindToServer() {\n\t\treturn new DefaultWebTestClientBuilder();\n\t}\n\n\t/**\n\t * A variant of {@link #bindToServer()} with a pre-configured connector.\n\t * @return chained API to customize client config\n\t * @since 5.0.2\n\t */\n\tstatic Builder bindToServer(ClientHttpConnector connector) {\n\t\treturn new DefaultWebTestClientBuilder(connector);\n\t}\n\n\n\t/**\n\t * Base specification for setting up tests without a server.\n\t *\n\t * @param <B> a self reference to the builder type\n\t */\n\tinterface MockServerSpec<B extends MockServerSpec<B>> {\n\n\t\t/**\n\t\t * Register {@link WebFilter} instances to add to the mock server.\n\t\t * @param filter one or more filters\n\t\t */\n\t\t<T extends B> T webFilter(WebFilter... filter);\n\n\t\t/**\n\t\t * Provide a session manager instance for the mock server.\n\t\t * <p>By default an instance of\n\t\t * {@link org.springframework.web.server.session.DefaultWebSessionManager\n\t\t * DefaultWebSessionManager} is used.\n\t\t * @param sessionManager the session manager to use\n\t\t */\n\t\t<T extends B> T webSessionManager(WebSessionManager sessionManager);\n\n\t\t/**\n\t\t * Shortcut for pre-packaged customizations to the mock server setup.\n\t\t * @param configurer the configurer to apply\n\t\t */\n\t\t<T extends B> T apply(MockServerConfigurer configurer);\n\n\t\t/**\n\t\t * Proceed to configure and build the test client.\n\t\t */\n\t\tBuilder configureClient();\n\n\t\t/**\n\t\t * Shortcut to build the test client.\n\t\t */\n\t\tWebTestClient build();\n\t}\n\n\n\t/**\n\t * Specification for customizing controller configuration equivalent to, and\n\t * internally delegating to, a {@link WebFluxConfigurer}.\n\t */\n\tinterface ControllerSpec extends MockServerSpec<ControllerSpec> {\n\n\t\t/**\n\t\t * Register one or more {@link org.springframework.web.bind.annotation.ControllerAdvice}\n\t\t * instances to be used in tests (specified {@code Class} will be turned into instance).\n\t\t */\n\t\tControllerSpec controllerAdvice(Object... controllerAdvice);\n\n\t\t/**\n\t\t * Customize content type resolution.\n\t\t * @see WebFluxConfigurer#configureContentTypeResolver\n\t\t */\n\t\tControllerSpec contentTypeResolver(Consumer<RequestedContentTypeResolverBuilder> consumer);\n\n\t\t/**\n\t\t * Configure CORS support.\n\t\t * @see WebFluxConfigurer#addCorsMappings\n\t\t */\n\t\tControllerSpec corsMappings(Consumer<CorsRegistry> consumer);\n\n\t\t/**\n\t\t * Configure path matching options.\n\t\t * @see WebFluxConfigurer#configurePathMatching\n\t\t */\n\t\tControllerSpec pathMatching(Consumer<PathMatchConfigurer> consumer);\n\n\t\t/**\n\t\t * Configure resolvers for custom controller method arguments.\n\t\t * @see WebFluxConfigurer#configureHttpMessageCodecs\n\t\t */\n\t\tControllerSpec argumentResolvers(Consumer<ArgumentResolverConfigurer> configurer);\n\n\t\t/**\n\t\t * Configure custom HTTP message readers and writers or override built-in ones.\n\t\t * @see WebFluxConfigurer#configureHttpMessageCodecs\n\t\t */\n\t\tControllerSpec httpMessageCodecs(Consumer<ServerCodecConfigurer> configurer);\n\n\t\t/**\n\t\t * Register formatters and converters to use for type conversion.\n\t\t * @see WebFluxConfigurer#addFormatters\n\t\t */\n\t\tControllerSpec formatters(Consumer<FormatterRegistry> consumer);\n\n\t\t/**\n\t\t * Configure a global Validator.\n\t\t * @see WebFluxConfigurer#getValidator()\n\t\t */\n\t\tControllerSpec validator(Validator validator);\n\n\t\t/**\n\t\t * Configure view resolution.\n\t\t * @see WebFluxConfigurer#configureViewResolvers\n\t\t */\n\t\tControllerSpec viewResolvers(Consumer<ViewResolverRegistry> consumer);\n\n\t\t/**\n\t\t * Configure blocking execution options.\n\t\t * @since 6.1\n\t\t * @see WebFluxConfigurer#configureBlockingExecution\n\t\t */\n\t\tControllerSpec blockingExecution(Consumer<BlockingExecutionConfigurer> consumer);\n\t}\n\n\n\t/**\n\t * Specification for customizing router function configuration.\n\t */\n\tinterface RouterFunctionSpec extends MockServerSpec<RouterFunctionSpec> {\n\n\t\t/**\n\t\t * Configure handler strategies.\n\t\t */\n\t\tRouterFunctionSpec handlerStrategies(HandlerStrategies handlerStrategies);\n\t}\n\n\n\t/**\n\t * Steps for customizing the {@link WebClient} used to test with,\n\t * internally delegating to a\n\t * {@link org.springframework.web.reactive.function.client.WebClient.Builder\n\t * WebClient.Builder}.\n\t */\n\tinterface Builder {\n\n\t\t/**\n\t\t * Configure a base URI as described in\n\t\t * {@link org.springframework.web.reactive.function.client.WebClient#create(String)\n\t\t * WebClient.create(String)}.\n\t\t */\n\t\tBuilder baseUrl(String baseUrl);\n\n\t\t/**\n\t\t * Provide a pre-configured {@link UriBuilderFactory} instance as an\n\t\t * alternative to and effectively overriding {@link #baseUrl(String)}.\n\t\t */\n\t\tBuilder uriBuilderFactory(UriBuilderFactory uriBuilderFactory);\n\n\t\t/**\n\t\t * Add the given header to all requests that haven't added it.\n\t\t * @param headerName the header name\n\t\t * @param headerValues the header values\n\t\t */\n\t\tBuilder defaultHeader(String headerName, String... headerValues);\n\n\t\t/**\n\t\t * Manipulate the default headers with the given consumer. The\n\t\t * headers provided to the consumer are \"live\", so that the consumer can be used to\n\t\t * {@linkplain HttpHeaders#set(String, String) overwrite} existing header values,\n\t\t * {@linkplain HttpHeaders#remove(String) remove} values, or use any of the other\n\t\t * {@link HttpHeaders} methods.\n\t\t * @param headersConsumer a function that consumes the {@code HttpHeaders}\n\t\t * @return this builder\n\t\t */\n\t\tBuilder defaultHeaders(Consumer<HttpHeaders> headersConsumer);\n\n\t\t/**\n\t\t * Add the given header to all requests that haven't added it.\n\t\t * @param cookieName the cookie name\n\t\t * @param cookieValues the cookie values\n\t\t */\n\t\tBuilder defaultCookie(String cookieName, String... cookieValues);\n\n\t\t/**\n\t\t * Manipulate the default cookies with the given consumer. The\n\t\t * map provided to the consumer is \"live\", so that the consumer can be used to\n\t\t * {@linkplain MultiValueMap#set(Object, Object) overwrite} existing header values,\n\t\t * {@linkplain MultiValueMap#remove(Object) remove} values, or use any of the other\n\t\t * {@link MultiValueMap} methods.\n\t\t * @param cookiesConsumer a function that consumes the cookies map\n\t\t * @return this builder\n\t\t */\n\t\tBuilder defaultCookies(Consumer<MultiValueMap<String, String>> cookiesConsumer);\n\n\t\t/**\n\t\t * Add the given filter to the filter chain.\n\t\t * @param filter the filter to be added to the chain\n\t\t */\n\t\tBuilder filter(ExchangeFilterFunction filter);\n\n\t\t/**\n\t\t * Manipulate the filters with the given consumer. The\n\t\t * list provided to the consumer is \"live\", so that the consumer can be used to remove\n\t\t * filters, change ordering, etc.\n\t\t * @param filtersConsumer a function that consumes the filter list\n\t\t * @return this builder\n\t\t */\n\t\tBuilder filters(Consumer<List<ExchangeFilterFunction>> filtersConsumer);\n\n\t\t/**\n\t\t * Configure an {@code EntityExchangeResult} callback that is invoked\n\t\t * every time after a response is fully decoded to a single entity, to a\n\t\t * List of entities, or to a byte[]. In effect, equivalent to each and\n\t\t * all of the below but registered once, globally:\n\t\t * <pre>\n\t\t * client.get().uri(\"/accounts/1\")\n\t\t *         .exchange()\n\t\t *         .expectBody(Person.class).consumeWith(exchangeResult -&gt; ... ));\n\t\t *\n\t\t * client.get().uri(\"/accounts\")\n\t\t *         .exchange()\n\t\t *         .expectBodyList(Person.class).consumeWith(exchangeResult -&gt; ... ));\n\t\t *\n\t\t * client.get().uri(\"/accounts/1\")\n\t\t *         .exchange()\n\t\t *         .expectBody().consumeWith(exchangeResult -&gt; ... ));\n\t\t * </pre>\n\t\t * <p>Note that the configured consumer does not apply to responses\n\t\t * decoded to {@code Flux<T>} which can be consumed outside the workflow\n\t\t * of the test client, for example via {@code reactor.test.StepVerifier}.\n\t\t * @param consumer the consumer to apply to entity responses\n\t\t * @return the builder\n\t\t * @since 5.3.5\n\t\t */\n\t\tBuilder entityExchangeResultConsumer(Consumer<EntityExchangeResult<?>> consumer);\n\n\t\t/**\n\t\t * Configure the codecs for the {@code WebClient} in the\n\t\t * {@link #exchangeStrategies(ExchangeStrategies) underlying}\n\t\t * {@code ExchangeStrategies}.\n\t\t * @param configurer the configurer to apply\n\t\t * @since 5.1.13\n\t\t */\n\t\tBuilder codecs(Consumer<ClientCodecConfigurer> configurer);\n\n\t\t/**\n\t\t * Configure the {@link ExchangeStrategies} to use.\n\t\t * <p>For most cases, prefer using {@link #codecs(Consumer)} which allows\n\t\t * customizing the codecs in the {@code ExchangeStrategies} rather than\n\t\t * replace them. That ensures multiple parties can contribute to codecs\n\t\t * configuration.\n\t\t * <p>By default this is set to {@link ExchangeStrategies#withDefaults()}.\n\t\t * @param strategies the strategies to use\n\t\t */\n\t\tBuilder exchangeStrategies(ExchangeStrategies strategies);\n\n\t\t/**\n\t\t * Max amount of time to wait for responses.\n\t\t * <p>By default 5 seconds.\n\t\t * @param timeout the response timeout value\n\t\t */\n\t\tBuilder responseTimeout(Duration timeout);\n\n\t\t/**\n\t\t * Set the {@link ClientHttpConnector} to use.\n\t\t * <p>By default, this is initialized and set internally. However, the\n\t\t * connector may also be prepared externally and passed via\n\t\t * {@link WebTestClient#bindToServer(ClientHttpConnector)} such as for\n\t\t * {@code MockMvcWebTestClient} tests, and in that case you can use this\n\t\t * from {@link #mutateWith(WebTestClientConfigurer)} to replace it.\n\t\t * @param connector the connector to use\n\t\t * @since 6.1\n\t\t */\n\t\tBuilder clientConnector(ClientHttpConnector connector);\n\n\t\t/**\n\t\t * Apply the given configurer to this builder instance.\n\t\t * <p>This can be useful for applying pre-packaged customizations.\n\t\t * @param configurer the configurer to apply\n\t\t */\n\t\tBuilder apply(WebTestClientConfigurer configurer);\n\n\t\t/**\n\t\t * Build the {@link WebTestClient} instance.\n\t\t */\n\t\tWebTestClient build();\n\t}\n\n\n\t/**\n\t * Specification for providing the URI of a request.\n\t *\n\t * @param <S> a self reference to the spec type\n\t */\n\tinterface UriSpec<S extends RequestHeadersSpec<?>> {\n\n\t\t/**\n\t\t * Specify the URI using an absolute, fully constructed {@link java.net.URI}.\n\t\t * <p>If a {@link UriBuilderFactory} was configured for the client with\n\t\t * a base URI, that base URI will <strong>not</strong> be applied to the\n\t\t * supplied {@code java.net.URI}. If you wish to have a base URI applied to a\n\t\t * {@code java.net.URI} you must invoke either {@link #uri(String, Object...)}\n\t\t * or {@link #uri(String, Map)} &mdash; for example, {@code uri(myUri.toString())}.\n\t\t * @return spec to add headers or perform the exchange\n\t\t */\n\t\tS uri(URI uri);\n\n\t\t/**\n\t\t * Specify the URI for the request using a URI template and URI variables.\n\t\t * <p>If a {@link UriBuilderFactory} was configured for the client (for example,\n\t\t * with a base URI) it will be used to expand the URI template.\n\t\t * @return spec to add headers or perform the exchange\n\t\t */\n\t\tS uri(String uri, @Nullable Object... uriVariables);\n\n\t\t/**\n\t\t * Specify the URI for the request using a URI template and URI variables.\n\t\t * <p>If a {@link UriBuilderFactory} was configured for the client (for example,\n\t\t * with a base URI) it will be used to expand the URI template.\n\t\t * @return spec to add headers or perform the exchange\n\t\t */\n\t\tS uri(String uri, Map<String, ? extends @Nullable Object> uriVariables);\n\n\t\t/**\n\t\t * Build the URI for the request with a {@link UriBuilder} obtained\n\t\t * through the {@link UriBuilderFactory} configured for this client.\n\t\t * @return spec to add headers or perform the exchange\n\t\t */\n\t\tS uri(Function<UriBuilder, URI> uriFunction);\n\t}\n\n\n\t/**\n\t * Specification for adding request headers and performing an exchange.\n\t *\n\t * @param <S> a self reference to the spec type\n\t */\n\tinterface RequestHeadersSpec<S extends RequestHeadersSpec<S>> {\n\n\t\t/**\n\t\t * Set the list of acceptable {@linkplain MediaType media types}, as\n\t\t * specified by the {@code Accept} header.\n\t\t * @param acceptableMediaTypes the acceptable media types\n\t\t * @return the same instance\n\t\t */\n\t\tS accept(MediaType... acceptableMediaTypes);\n\n\t\t/**\n\t\t * Set the list of acceptable {@linkplain Charset charsets}, as specified\n\t\t * by the {@code Accept-Charset} header.\n\t\t * @param acceptableCharsets the acceptable charsets\n\t\t * @return the same instance\n\t\t */\n\t\tS acceptCharset(Charset... acceptableCharsets);\n\n\t\t/**\n\t\t * Add a cookie with the given name and value.\n\t\t * @param name the cookie name\n\t\t * @param value the cookie value\n\t\t * @return the same instance\n\t\t */\n\t\tS cookie(String name, String value);\n\n\t\t/**\n\t\t * Manipulate this request's cookies with the given consumer. The\n\t\t * map provided to the consumer is \"live\", so that the consumer can be used to\n\t\t * {@linkplain MultiValueMap#set(Object, Object) overwrite} existing header values,\n\t\t * {@linkplain MultiValueMap#remove(Object) remove} values, or use any of the other\n\t\t * {@link MultiValueMap} methods.\n\t\t * @param cookiesConsumer a function that consumes the cookies map\n\t\t * @return this builder\n\t\t */\n\t\tS cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer);\n\n\t\t/**\n\t\t * Set the value of the {@code If-Modified-Since} header.\n\t\t * <p>The date should be specified as the number of milliseconds since\n\t\t * January 1, 1970 GMT.\n\t\t * @param ifModifiedSince the new value of the header\n\t\t * @return the same instance\n\t\t */\n\t\tS ifModifiedSince(ZonedDateTime ifModifiedSince);\n\n\t\t/**\n\t\t * Set the values of the {@code If-None-Match} header.\n\t\t * @param ifNoneMatches the new value of the header\n\t\t * @return the same instance\n\t\t */\n\t\tS ifNoneMatch(String... ifNoneMatches);\n\n\t\t/**\n\t\t * Add the given, single header value under the given name.\n\t\t * @param headerName  the header name\n\t\t * @param headerValues the header value(s)\n\t\t * @return the same instance\n\t\t */\n\t\tS header(String headerName, String... headerValues);\n\n\t\t/**\n\t\t * Manipulate the request's headers with the given consumer. The\n\t\t * headers provided to the consumer are \"live\", so that the consumer can be used to\n\t\t * {@linkplain HttpHeaders#set(String, String) overwrite} existing header values,\n\t\t * {@linkplain HttpHeaders#remove(String) remove} values, or use any of the other\n\t\t * {@link HttpHeaders} methods.\n\t\t * @param headersConsumer a function that consumes the {@code HttpHeaders}\n\t\t * @return this builder\n\t\t */\n\t\tS headers(Consumer<HttpHeaders> headersConsumer);\n\n\t\t/**\n\t\t * Set the attribute with the given name to the given value.\n\t\t * @param name the name of the attribute to add\n\t\t * @param value the value of the attribute to add\n\t\t * @return this builder\n\t\t */\n\t\tS attribute(String name, Object value);\n\n\t\t/**\n\t\t * Manipulate the request attributes with the given consumer. The attributes provided to\n\t\t * the consumer are \"live\", so that the consumer can be used to inspect attributes,\n\t\t * remove attributes, or use any of the other map-provided methods.\n\t\t * @param attributesConsumer a function that consumes the attributes\n\t\t * @return this builder\n\t\t */\n\t\tS attributes(Consumer<Map<String, Object>> attributesConsumer);\n\n\t\t/**\n\t\t * Perform the exchange without a request body.\n\t\t * @return spec for decoding the response\n\t\t */\n\t\tResponseSpec exchange();\n\t}\n\n\n\t/**\n\t * Specification for providing body of a request.\n\t */\n\tinterface RequestBodySpec extends RequestHeadersSpec<RequestBodySpec> {\n\t\t/**\n\t\t * Set the length of the body in bytes, as specified by the\n\t\t * {@code Content-Length} header.\n\t\t * @param contentLength the content length\n\t\t * @return the same instance\n\t\t * @see HttpHeaders#setContentLength(long)\n\t\t */\n\t\tRequestBodySpec contentLength(long contentLength);\n\n\t\t/**\n\t\t * Set the {@linkplain MediaType media type} of the body, as specified\n\t\t * by the {@code Content-Type} header.\n\t\t * @param contentType the content type\n\t\t * @return the same instance\n\t\t * @see HttpHeaders#setContentType(MediaType)\n\t\t */\n\t\tRequestBodySpec contentType(MediaType contentType);\n\n\t\t/**\n\t\t * Set the body to the given {@code Object} value. This method invokes the\n\t\t * {@link org.springframework.web.reactive.function.client.WebClient.RequestBodySpec#bodyValue(Object)\n\t\t * bodyValue} method on the underlying {@code WebClient}.\n\t\t * @param body the value to write to the request body\n\t\t * @return spec for further declaration of the request\n\t\t * @since 5.2\n\t\t */\n\t\tRequestHeadersSpec<?> bodyValue(Object body);\n\n\t\t/**\n\t\t * Set the body from the given {@code Publisher}. Shortcut for\n\t\t * {@link #body(BodyInserter)} with a\n\t\t * {@linkplain BodyInserters#fromPublisher Publisher inserter}.\n\t\t * @param publisher the request body data\n\t\t * @param elementClass the class of elements contained in the publisher\n\t\t * @param <T> the type of the elements contained in the publisher\n\t\t * @param <S> the type of the {@code Publisher}\n\t\t * @return spec for further declaration of the request\n\t\t */\n\t\t<T, S extends Publisher<T>> RequestHeadersSpec<?> body(S publisher, Class<T> elementClass);\n\n\t\t/**\n\t\t * Variant of {@link #body(Publisher, Class)} that allows providing\n\t\t * element type information with generics.\n\t\t * @param publisher the request body data\n\t\t * @param elementTypeRef the type reference of elements contained in the publisher\n\t\t * @param <T> the type of the elements contained in the publisher\n\t\t * @param <S> the type of the {@code Publisher}\n\t\t * @return spec for further declaration of the request\n\t\t * @since 5.2\n\t\t */\n\t\t<T, S extends Publisher<T>> RequestHeadersSpec<?> body(\n\t\t\t\tS publisher, ParameterizedTypeReference<T> elementTypeRef);\n\n\t\t/**\n\t\t * Set the body from the given producer. This method invokes the\n\t\t * {@link org.springframework.web.reactive.function.client.WebClient.RequestBodySpec#body(Object, Class)\n\t\t * body(Object, Class)} method on the underlying {@code WebClient}.\n\t\t * @param producer the producer to write to the request. This must be a\n\t\t * {@link Publisher} or another producer adaptable to a\n\t\t * {@code Publisher} via {@link ReactiveAdapterRegistry}\n\t\t * @param elementClass the class of elements contained in the producer\n\t\t * @return spec for further declaration of the request\n\t\t * @since 5.2\n\t\t */\n\t\tRequestHeadersSpec<?> body(Object producer, Class<?> elementClass);\n\n\t\t/**\n\t\t * Set the body from the given producer. This method invokes the\n\t\t * {@link org.springframework.web.reactive.function.client.WebClient.RequestBodySpec#body(Object, ParameterizedTypeReference)\n\t\t * body(Object, ParameterizedTypeReference)} method on the underlying {@code WebClient}.\n\t\t * @param producer the producer to write to the request. This must be a\n\t\t * {@link Publisher} or another producer adaptable to a\n\t\t * {@code Publisher} via {@link ReactiveAdapterRegistry}\n\t\t * @param elementTypeRef the type reference of elements contained in the producer\n\t\t * @return spec for further declaration of the request\n\t\t * @since 5.2\n\t\t */\n\t\tRequestHeadersSpec<?> body(Object producer, ParameterizedTypeReference<?> elementTypeRef);\n\n\t\t/**\n\t\t * Set the body of the request to the given {@code BodyInserter}.\n\t\t * This method invokes the\n\t\t * {@link org.springframework.web.reactive.function.client.WebClient.RequestBodySpec#body(BodyInserter)\n\t\t * body(BodyInserter)} method on the underlying {@code WebClient}.\n\t\t * @param inserter the body inserter to use\n\t\t * @return spec for further declaration of the request\n\t\t * @see org.springframework.web.reactive.function.BodyInserters\n\t\t */\n\t\tRequestHeadersSpec<?> body(BodyInserter<?, ? super ClientHttpRequest> inserter);\n\t}\n\n\n\t/**\n\t * Specification for providing request headers and the URI of a request.\n\t *\n\t * @param <S> a self reference to the spec type\n\t */\n\tinterface RequestHeadersUriSpec<S extends RequestHeadersSpec<S>> extends UriSpec<S>, RequestHeadersSpec<S> {\n\t}\n\n\t/**\n\t * Specification for providing the body and the URI of a request.\n\t */\n\tinterface RequestBodyUriSpec extends RequestBodySpec, RequestHeadersUriSpec<RequestBodySpec> {\n\t}\n\n\n\t/**\n\t * Chained API for applying assertions to a response.\n\t */\n\tinterface ResponseSpec {\n\n\t\t/**\n\t\t * Apply multiple assertions to a response with the given\n\t\t * {@linkplain ResponseSpecConsumer consumers}, with the guarantee that\n\t\t * all assertions will be applied even if one or more assertions fails\n\t\t * with an exception.\n\t\t * <p>If a single {@link Error} or {@link RuntimeException} is thrown,\n\t\t * it will be rethrown.\n\t\t * <p>If multiple exceptions are thrown, this method will throw an\n\t\t * {@link AssertionError} whose error message is a summary of all the\n\t\t * exceptions. In addition, each exception will be added as a\n\t\t * {@linkplain Throwable#addSuppressed(Throwable) suppressed exception} to\n\t\t * the {@code AssertionError}.\n\t\t * <p>This feature is similar to the {@code SoftAssertions} support in\n\t\t * AssertJ and the {@code assertAll()} support in JUnit Jupiter.\n\t\t *\n\t\t * <h4>Example</h4>\n\t\t * <pre class=\"code\">\n\t\t * webTestClient.get().uri(\"/hello\").exchange()\n\t\t *     .expectAll(\n\t\t *         responseSpec -&gt; responseSpec.expectStatus().isOk(),\n\t\t *         responseSpec -&gt; responseSpec.expectBody(String.class).isEqualTo(\"Hello, World!\")\n\t\t *     );\n\t\t * </pre>\n\t\t * @param consumers the list of {@code ResponseSpec} consumers\n\t\t * @since 5.3.10\n\t\t */\n\t\tResponseSpec expectAll(ResponseSpecConsumer... consumers);\n\n\t\t/**\n\t\t * Assertions on the response status.\n\t\t */\n\t\tStatusAssertions expectStatus();\n\n\t\t/**\n\t\t * Assertions on the headers of the response.\n\t\t */\n\t\tHeaderAssertions expectHeader();\n\n\t\t/**\n\t\t * Assertions on the cookies of the response.\n\t\t * @since 5.3\n\t\t */\n\t\tCookieAssertions expectCookie();\n\n\t\t/**\n\t\t * Consume and decode the response body to a single object of type\n\t\t * {@code <B>} and then apply assertions.\n\t\t * @param bodyType the expected body type\n\t\t */\n\t\t<B> BodySpec<B, ?> expectBody(Class<B> bodyType);\n\n\t\t/**\n\t\t * Alternative to {@link #expectBody(Class)} that accepts information\n\t\t * about a target type with generics.\n\t\t */\n\t\t<B> BodySpec<B, ?> expectBody(ParameterizedTypeReference<B> bodyType);\n\n\t\t/**\n\t\t * Consume and decode the response body to {@code List<E>} and then apply\n\t\t * List-specific assertions.\n\t\t * @param elementType the expected List element type\n\t\t */\n\t\t<E> ListBodySpec<E> expectBodyList(Class<E> elementType);\n\n\t\t/**\n\t\t * Alternative to {@link #expectBodyList(Class)} that accepts information\n\t\t * about a target type with generics.\n\t\t */\n\t\t<E> ListBodySpec<E> expectBodyList(ParameterizedTypeReference<E> elementType);\n\n\t\t/**\n\t\t * Consume and decode the response body to {@code byte[]} and then apply\n\t\t * assertions on the raw content (for example, isEmpty, JSONPath, etc.).\n\t\t */\n\t\tBodyContentSpec expectBody();\n\n\t\t/**\n\t\t * Exit the chained flow in order to consume the response body\n\t\t * externally, for example, via {@link reactor.test.StepVerifier}.\n\t\t * <p>Note that when {@code Void.class} is passed in, the response body\n\t\t * is consumed and released. If no content is expected, then consider\n\t\t * using {@code .expectBody().isEmpty()} instead which asserts that\n\t\t * there is no content.\n\t\t */\n\t\t<T> FluxExchangeResult<T> returnResult(Class<T> elementClass);\n\n\t\t/**\n\t\t * Alternative to {@link #returnResult(Class)} that accepts information\n\t\t * about a target type with generics.\n\t\t */\n\t\t<T> FluxExchangeResult<T> returnResult(ParameterizedTypeReference<T> elementTypeRef);\n\n\t\t/**\n\t\t * {@link Consumer} of a {@link ResponseSpec}.\n\t\t * @since 5.3.10\n\t\t * @see ResponseSpec#expectAll(ResponseSpecConsumer...)\n\t\t */\n\t\t@FunctionalInterface\n\t\tinterface ResponseSpecConsumer extends Consumer<ResponseSpec> {\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Spec for expectations on the response body decoded to a single Object.\n\t *\n\t * @param <S> a self reference to the spec type\n\t * @param <B> the body type\n\t */\n\tinterface BodySpec<B, S extends BodySpec<B, S>> {\n\n\t\t/**\n\t\t * Assert the extracted body is equal to the given value.\n\t\t */\n\t\t<T extends S> T isEqualTo(@Nullable B expected);\n\n\t\t/**\n\t\t * Assert the extracted body with a {@link Matcher}.\n\t\t * @since 5.1\n\t\t */\n\t\t<T extends S> T value(Matcher<? super @Nullable B> matcher);\n\n\t\t/**\n\t\t * Transform the extracted the body with a function, for example, extracting a\n\t\t * property, and assert the mapped value with a {@link Matcher}.\n\t\t * @since 5.1\n\t\t */\n\t\t<T extends S, R> T value(Function<@Nullable B, @Nullable R> bodyMapper, Matcher<? super @Nullable R> matcher);\n\n\t\t/**\n\t\t * Assert the extracted body with a {@link Consumer}.\n\t\t * @since 5.1\n\t\t */\n\t\t<T extends S> T value(Consumer<@Nullable B> consumer);\n\n\t\t/**\n\t\t * Assert the exchange result with the given {@link Consumer}.\n\t\t */\n\t\t<T extends S> T consumeWith(Consumer<EntityExchangeResult<B>> consumer);\n\n\t\t/**\n\t\t * Exit the chained API and return an {@code ExchangeResult} with the\n\t\t * decoded response content.\n\t\t */\n\t\tEntityExchangeResult<B> returnResult();\n\t}\n\n\n\t/**\n\t * Spec for expectations on the response body decoded to a List.\n\t *\n\t * @param <E> the body list element type\n\t */\n\tinterface ListBodySpec<E> extends BodySpec<List<@Nullable E>, ListBodySpec<E>> {\n\n\t\t/**\n\t\t * Assert the extracted list of values is of the given size.\n\t\t * @param size the expected size\n\t\t */\n\t\tListBodySpec<E> hasSize(int size);\n\n\t\t/**\n\t\t * Assert the extracted list of values contains the given elements.\n\t\t * @param elements the elements to check\n\t\t */\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tListBodySpec<E> contains(@Nullable E... elements);\n\n\t\t/**\n\t\t * Assert the extracted list of values doesn't contain the given elements.\n\t\t * @param elements the elements to check\n\t\t */\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tListBodySpec<E> doesNotContain(@Nullable E... elements);\n\t}\n\n\n\t/**\n\t * Spec for expectations on the response body content.\n\t */\n\tinterface BodyContentSpec {\n\n\t\t/**\n\t\t * Assert the response body is empty and return the exchange result.\n\t\t */\n\t\tEntityExchangeResult<Void> isEmpty();\n\n\t\t/**\n\t\t * Parse the expected and actual response content as JSON and perform a\n\t\t * comparison verifying that they contain the same attribute-value pairs\n\t\t * regardless of formatting with <em>lenient</em> checking (extensible\n\t\t * and non-strict array ordering).\n\t\t * <p>Use of this method requires the\n\t\t * <a href=\"https://jsonassert.skyscreamer.org/\">JSONassert</a> library\n\t\t * to be on the classpath.\n\t\t * @param expectedJson the expected JSON content\n\t\t * @see #json(String, JsonCompareMode)\n\t\t */\n\t\tdefault BodyContentSpec json(String expectedJson) {\n\t\t\treturn json(expectedJson, JsonCompareMode.LENIENT);\n\t\t}\n\n\t\t/**\n\t\t * Parse the expected and actual response content as JSON and perform a\n\t\t * comparison verifying that they contain the same attribute-value pairs\n\t\t * regardless of formatting.\n\t\t * <p>Can compare in two modes, depending on the {@code strict} parameter value:\n\t\t * <ul>\n\t\t * <li>{@code true}: strict checking. Not extensible and strict array ordering.</li>\n\t\t * <li>{@code false}: lenient checking. Extensible and non-strict array ordering.</li>\n\t\t * </ul>\n\t\t * <p>Use of this method requires the\n\t\t * <a href=\"https://jsonassert.skyscreamer.org/\">JSONassert</a> library\n\t\t * to be on the classpath.\n\t\t * @param expectedJson the expected JSON content\n\t\t * @param strict enables strict checking if {@code true}\n\t\t * @since 5.3.16\n\t\t * @see #json(String)\n\t\t * @deprecated in favor of {@link #json(String, JsonCompareMode)}\n\t\t */\n\t\t@Deprecated(since = \"6.2\")\n\t\tBodyContentSpec json(String expectedJson, boolean strict);\n\n\t\t/**\n\t\t * Parse the expected and actual response content as JSON and perform a\n\t\t * comparison using the given {@linkplain JsonCompareMode mode}. If the\n\t\t * comparison failed, throws an {@link AssertionError} with the message\n\t\t * of the {@link JsonComparison}.\n\t\t * <p>Use of this method requires the\n\t\t * <a href=\"https://jsonassert.skyscreamer.org/\">JSONassert</a> library\n\t\t * to be on the classpath.\n\t\t * @param expectedJson the expected JSON content\n\t\t * @param compareMode the compare mode\n\t\t * @since 6.2\n\t\t * @see #json(String)\n\t\t */\n\t\tBodyContentSpec json(String expectedJson, JsonCompareMode compareMode);\n\n\t\t/**\n\t\t * Parse the expected and actual response content as JSON and perform a\n\t\t * comparison using the given {@link JsonComparator}. If the comparison\n\t\t * failed, throws an {@link AssertionError} with the message  of the\n\t\t * {@link JsonComparison}.\n\t\t * @param expectedJson the expected JSON content\n\t\t * @param comparator the comparator to use\n\t\t * @since 6.2\n\t\t */\n\t\tBodyContentSpec json(String expectedJson, JsonComparator comparator);\n\n\t\t/**\n\t\t * Parse expected and actual response content as XML and assert that\n\t\t * the two are \"similar\", i.e. they contain the same elements and\n\t\t * attributes regardless of order.\n\t\t * <p>Use of this method requires the\n\t\t * <a href=\"https://github.com/xmlunit/xmlunit\">XMLUnit</a> library on\n\t\t * the classpath.\n\t\t * @param expectedXml the expected XML content.\n\t\t * @since 5.1\n\t\t * @see org.springframework.test.util.XmlExpectationsHelper#assertXmlEqual(String, String)\n\t\t */\n\t\tBodyContentSpec xml(String expectedXml);\n\n\t\t/**\n\t\t * Access to response body assertions using a\n\t\t * <a href=\"https://github.com/jayway/JsonPath\">JsonPath</a> expression\n\t\t * to inspect a specific subset of the body.\n\t\t * @param expression the JsonPath expression\n\t\t * @since 6.2\n\t\t */\n\t\tJsonPathAssertions jsonPath(String expression);\n\n\t\t/**\n\t\t * Access to response body assertions using an XPath expression to\n\t\t * inspect a specific subset of the body.\n\t\t * <p>The XPath expression can be a parameterized string using\n\t\t * formatting specifiers as defined in {@link String#format}.\n\t\t * @param expression the XPath expression\n\t\t * @param args arguments to parameterize the expression\n\t\t * @since 5.1\n\t\t * @see #xpath(String, Map, Object...)\n\t\t */\n\t\tdefault XpathAssertions xpath(String expression, Object... args) {\n\t\t\treturn xpath(expression, null, args);\n\t\t}\n\n\t\t/**\n\t\t * Access to response body assertions with specific namespaces using an\n\t\t * XPath expression to inspect a specific subset of the body.\n\t\t * <p>The XPath expression can be a parameterized string using\n\t\t * formatting specifiers as defined in {@link String#format}.\n\t\t * @param expression the XPath expression\n\t\t * @param namespaces the namespaces to use\n\t\t * @param args arguments to parameterize the expression\n\t\t * @since 5.1\n\t\t */\n\t\tXpathAssertions xpath(String expression, @Nullable Map<String, String> namespaces, Object... args);\n\n\t\t/**\n\t\t * Assert the response body content with the given {@link Consumer}.\n\t\t * @param consumer the consumer for the response body; the input\n\t\t * {@code byte[]} may be {@code null} if there was no response body.\n\t\t */\n\t\tBodyContentSpec consumeWith(Consumer<EntityExchangeResult<byte[]>> consumer);\n\n\t\t/**\n\t\t * Exit the chained API and return an {@code ExchangeResult} with the\n\t\t * raw response content.\n\t\t */\n\t\tEntityExchangeResult<byte[]> returnResult();\n\t}\n\n}"
  },
  "org.springframework.test.web.servlet.<unknown>#getAsyncResult()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "Object",
    "signature": "public Object getAsyncResult()",
    "source_code": "\tpublic @Nullable Object getAsyncResult() {\n\t\treturn getAsyncResult(-1);\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#getAsyncResult(timeToWait)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeToWait"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "Object",
    "signature": "public Object getAsyncResult(long timeToWait)",
    "source_code": "\tpublic @Nullable Object getAsyncResult(long timeToWait) {\n\t\tif (this.mockRequest.getAsyncContext() != null && timeToWait == -1) {\n\t\t\tlong requestTimeout = this.mockRequest.getAsyncContext().getTimeout();\n\t\t\ttimeToWait = requestTimeout == -1 ? Long.MAX_VALUE : requestTimeout;\n\t\t}\n\t\tif (!awaitAsyncDispatch(timeToWait)) {\n\t\t\tthrow new IllegalStateException(\"Async result for handler [\" + this.handler + \"]\" +\n\t\t\t\t\t\" was not set during the specified timeToWait=\" + timeToWait);\n\t\t}\n\t\tObject result = this.asyncResult.get();\n\t\tAssert.state(result != RESULT_NONE, () -> \"Async result for handler [\" + this.handler + \"] was not set\");\n\t\treturn this.asyncResult.get();\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#getFlashMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "FlashMap",
    "signature": "public FlashMap getFlashMap()",
    "source_code": "\tpublic FlashMap getFlashMap() {\n\t\treturn RequestContextUtils.getOutputFlashMap(this.mockRequest);\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#getHandler()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "Object",
    "signature": "public Object getHandler()",
    "source_code": "\tpublic @Nullable Object getHandler() {\n\t\treturn this.handler;\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#getModelAndView()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView getModelAndView()",
    "source_code": "\tpublic @Nullable ModelAndView getModelAndView() {\n\t\treturn this.modelAndView;\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#getRequest()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "MockHttpServletRequest",
    "signature": "public MockHttpServletRequest getRequest()",
    "source_code": "\tpublic MockHttpServletRequest getRequest() {\n\t\treturn this.mockRequest;\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#getResolvedException()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "Exception",
    "signature": "public Exception getResolvedException()",
    "source_code": "\tpublic @Nullable Exception getResolvedException() {\n\t\treturn this.resolvedException;\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#getResponse()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "MockHttpServletResponse",
    "signature": "public MockHttpServletResponse getResponse()",
    "source_code": "\tpublic MockHttpServletResponse getResponse() {\n\t\treturn this.mockResponse;\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#setAsyncResult(asyncResult)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "asyncResult"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void setAsyncResult(@Nullable Object asyncResult)",
    "source_code": "\tpublic void setAsyncResult(@Nullable Object asyncResult) {\n\t\tthis.asyncResult.set(asyncResult);\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#setHandler(handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "void",
    "signature": "public void setHandler(@Nullable Object handler)",
    "source_code": "\tpublic void setHandler(@Nullable Object handler) {\n\t\tthis.handler = handler;\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#setInterceptors(interceptors)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "void",
    "signature": "public void setInterceptors(HandlerInterceptor @Nullable ... interceptors)",
    "source_code": "\tpublic void setInterceptors(HandlerInterceptor @Nullable ... interceptors) {\n\t\tthis.interceptors = interceptors;\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#setModelAndView(mav)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mav"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void setModelAndView(@Nullable ModelAndView mav)",
    "source_code": "\tpublic void setModelAndView(@Nullable ModelAndView mav) {\n\t\tthis.modelAndView = mav;\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#setResolvedException(resolvedException)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvedException"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void setResolvedException(Exception resolvedException)",
    "source_code": "\tpublic void setResolvedException(Exception resolvedException) {\n\t\tthis.resolvedException = resolvedException;\n\t}"
  },
  "org.springframework.test.web.servlet.MvcResult": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Provides access to the result of an executed request.\n *\n * @author Rossen Stoyanchev\n * @since 3.2\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 34
    },
    "signature": "public interface MvcResult",
    "source_code": "public interface MvcResult {\n\n\t/**\n\t * Return the performed request.\n\t * @return the request (never {@code null})\n\t */\n\tMockHttpServletRequest getRequest();\n\n\t/**\n\t * Return the resulting response.\n\t * @return the response (never {@code null})\n\t */\n\tMockHttpServletResponse getResponse();\n\n\t/**\n\t * Return the executed handler.\n\t * @return the handler, possibly {@code null} if none were executed\n\t */\n\t@Nullable Object getHandler();\n\n\t/**\n\t * Return interceptors around the handler.\n\t * @return interceptors, or {@code null} if none were selected\n\t */\n\tHandlerInterceptor @Nullable [] getInterceptors();\n\n\t/**\n\t * Return the {@code ModelAndView} prepared by the handler.\n\t * @return a {@code ModelAndView}, or {@code null} if none\n\t */\n\t@Nullable ModelAndView getModelAndView();\n\n\t/**\n\t * Return any exception raised by a handler and successfully resolved\n\t * through a {@link HandlerExceptionResolver}.\n\t * @return an exception, or {@code null} if none\n\t */\n\t@Nullable Exception getResolvedException();\n\n\t/**\n\t * Return the \"output\" flash attributes saved during request processing.\n\t * @return the {@code FlashMap}, possibly empty\n\t */\n\tFlashMap getFlashMap();\n\n\t/**\n\t * Get the result of async execution.\n\t * <p>This method will wait for the async result to be set within the\n\t * timeout value associated with the async request, see\n\t * {@link org.springframework.mock.web.MockAsyncContext#setTimeout\n\t * MockAsyncContext#setTimeout}. Alternatively, use\n\t * {@link #getAsyncResult(long)} to specify the amount of time to wait.\n\t * @throws IllegalStateException if the async result was not set\n\t */\n\t@Nullable Object getAsyncResult();\n\n\t/**\n\t * Get the result of async execution and wait if necessary.\n\t * @param timeToWait how long to wait for the async result to be set, in\n\t * \tmilliseconds; if -1, then fall back on the timeout value associated with\n\t * \tthe async request, see\n\t * \t{@link org.springframework.mock.web.MockAsyncContext#setTimeout\n\t * \tMockAsyncContext#setTimeout} for more details.\n\t * @throws IllegalStateException if the async result was not set\n\t */\n\t@Nullable Object getAsyncResult(long timeToWait);\n\n}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#asyncRequestTimeout(timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "StandaloneMockMvcSpec",
    "signature": "public StandaloneMockMvcSpec asyncRequestTimeout(long timeout)",
    "source_code": "\tpublic StandaloneMockMvcSpec asyncRequestTimeout(long timeout) {\n\t\tthis.mockMvcBuilder.setAsyncRequestTimeout(timeout);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#contentNegotiationManager(manager)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "manager"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "StandaloneMockMvcSpec",
    "signature": "public StandaloneMockMvcSpec contentNegotiationManager(ContentNegotiationManager manager)",
    "source_code": "\tpublic StandaloneMockMvcSpec contentNegotiationManager(ContentNegotiationManager manager) {\n\t\tthis.mockMvcBuilder.setContentNegotiationManager(manager);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#controllerAdvice(controllerAdvice)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllerAdvice"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "StandaloneMockMvcSpec",
    "signature": "public StandaloneMockMvcSpec controllerAdvice(Object... controllerAdvice)",
    "source_code": "\tpublic StandaloneMockMvcSpec controllerAdvice(Object... controllerAdvice) {\n\t\tthis.mockMvcBuilder.setControllerAdvice(controllerAdvice);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#conversionService(conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "StandaloneMockMvcSpec",
    "signature": "public StandaloneMockMvcSpec conversionService(FormattingConversionService conversionService)",
    "source_code": "\tpublic StandaloneMockMvcSpec conversionService(FormattingConversionService conversionService) {\n\t\tthis.mockMvcBuilder.setConversionService(conversionService);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#customArgumentResolvers(argumentResolvers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argumentResolvers"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "StandaloneMockMvcSpec",
    "signature": "public StandaloneMockMvcSpec customArgumentResolvers(HandlerMethodArgumentResolver... argumentResolvers)",
    "source_code": "\tpublic StandaloneMockMvcSpec customArgumentResolvers(HandlerMethodArgumentResolver... argumentResolvers) {\n\t\tthis.mockMvcBuilder.setCustomArgumentResolvers(argumentResolvers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#customHandlerMapping(factory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "StandaloneMockMvcSpec",
    "signature": "public StandaloneMockMvcSpec customHandlerMapping(Supplier<RequestMappingHandlerMapping> factory)",
    "source_code": "\tpublic StandaloneMockMvcSpec customHandlerMapping(Supplier<RequestMappingHandlerMapping> factory) {\n\t\tthis.mockMvcBuilder.setCustomHandlerMapping(factory);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#customReturnValueHandlers(handlers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handlers"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "StandaloneMockMvcSpec",
    "signature": "public StandaloneMockMvcSpec customReturnValueHandlers(HandlerMethodReturnValueHandler... handlers)",
    "source_code": "\tpublic StandaloneMockMvcSpec customReturnValueHandlers(HandlerMethodReturnValueHandler... handlers) {\n\t\tthis.mockMvcBuilder.setCustomReturnValueHandlers(handlers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#flashMapManager(flashMapManager)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "flashMapManager"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "StandaloneMockMvcSpec",
    "signature": "public StandaloneMockMvcSpec flashMapManager(FlashMapManager flashMapManager)",
    "source_code": "\tpublic StandaloneMockMvcSpec flashMapManager(FlashMapManager flashMapManager) {\n\t\tthis.mockMvcBuilder.setFlashMapManager(flashMapManager);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#handlerExceptionResolvers(exceptionResolvers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exceptionResolvers"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "StandaloneMockMvcSpec",
    "signature": "public StandaloneMockMvcSpec handlerExceptionResolvers(HandlerExceptionResolver... exceptionResolvers)",
    "source_code": "\tpublic StandaloneMockMvcSpec handlerExceptionResolvers(HandlerExceptionResolver... exceptionResolvers) {\n\t\tthis.mockMvcBuilder.setHandlerExceptionResolvers(exceptionResolvers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#interceptors(interceptors)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "StandaloneMockMvcSpec",
    "signature": "public StandaloneMockMvcSpec interceptors(HandlerInterceptor... interceptors)",
    "source_code": "\tpublic StandaloneMockMvcSpec interceptors(HandlerInterceptor... interceptors) {\n\t\tmappedInterceptors(null, interceptors);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#localeResolver(localeResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "localeResolver"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "StandaloneMockMvcSpec",
    "signature": "public StandaloneMockMvcSpec localeResolver(LocaleResolver localeResolver)",
    "source_code": "\tpublic StandaloneMockMvcSpec localeResolver(LocaleResolver localeResolver) {\n\t\tthis.mockMvcBuilder.setLocaleResolver(localeResolver);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#mappedInterceptors(pathPatterns,interceptors)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathPatterns",
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "StandaloneMockMvcSpec",
    "signature": "public StandaloneMockMvcSpec mappedInterceptors(String @Nullable [] pathPatterns, HandlerInterceptor... interceptors)",
    "source_code": "\tpublic StandaloneMockMvcSpec mappedInterceptors("
  },
  "org.springframework.test.web.servlet.client.<unknown>#messageConverters(messageConverters)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageConverters"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "StandaloneMockMvcSpec",
    "signature": "public StandaloneMockMvcSpec messageConverters(HttpMessageConverter<?>... messageConverters)",
    "source_code": "\tpublic StandaloneMockMvcSpec messageConverters(HttpMessageConverter<?>... messageConverters) {\n\t\tthis.mockMvcBuilder.setMessageConverters(messageConverters);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#patternParser(parser)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parser"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "StandaloneMockMvcSpec",
    "signature": "public StandaloneMockMvcSpec patternParser(PathPatternParser parser)",
    "source_code": "\tpublic StandaloneMockMvcSpec patternParser(PathPatternParser parser) {\n\t\tthis.mockMvcBuilder.setPatternParser(parser);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#placeholderValue(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "StandaloneMockMvcSpec",
    "signature": "public StandaloneMockMvcSpec placeholderValue(String name, String value)",
    "source_code": "\tpublic StandaloneMockMvcSpec placeholderValue(String name, String value) {\n\t\tthis.mockMvcBuilder.addPlaceholderValue(name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#singleView(view)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "view"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "StandaloneMockMvcSpec",
    "signature": "public StandaloneMockMvcSpec singleView(View view)",
    "source_code": "\tpublic StandaloneMockMvcSpec singleView(View view) {\n\t\tthis.mockMvcBuilder.setSingleView(view);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#validator(validator)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "validator"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "StandaloneMockMvcSpec",
    "signature": "public StandaloneMockMvcSpec validator(Validator validator)",
    "source_code": "\tpublic StandaloneMockMvcSpec validator(Validator validator) {\n\t\tthis.mockMvcBuilder.setValidator(validator);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#viewResolvers(resolvers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvers"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "StandaloneMockMvcSpec",
    "signature": "public StandaloneMockMvcSpec viewResolvers(ViewResolver... resolvers)",
    "source_code": "\tpublic StandaloneMockMvcSpec viewResolvers(ViewResolver... resolvers) {\n\t\tthis.mockMvcBuilder.setViewResolvers(resolvers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.client.MockMvcHttpConnector#getInterceptors()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "HandlerInterceptor[]",
    "signature": "public HandlerInterceptor[] getInterceptors()",
    "source_code": "\t\tpublic HandlerInterceptor[] getInterceptors() {\n\t\t\treturn this.mvcResult.getInterceptors();\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder#setUseSuffixPatternMatch(useSuffixPatternMatch)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to use suffix pattern match (\".*\") when matching patterns to\n\t * requests. If enabled a method mapped to \"/users\" also matches to \"/users.*\".\n\t * <p>The default value is {@code false}.\n\t * @deprecated as of 5.2.4. See class-level note in\n\t * {@link RequestMappingHandlerMapping} on the deprecation of path extension\n\t * config options.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "useSuffixPatternMatch"
    ],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "StandaloneMockMvcBuilder",
    "signature": "public StandaloneMockMvcBuilder setUseSuffixPatternMatch(boolean useSuffixPatternMatch)",
    "source_code": "\tpublic StandaloneMockMvcBuilder setUseSuffixPatternMatch(boolean useSuffixPatternMatch) {\n\t\tthis.useSuffixPatternMatch = useSuffixPatternMatch;\n\t\tthis.preferPathMatcher |= useSuffixPatternMatch;\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder#setUseTrailingSlashPatternMatch(useTrailingSlashPatternMatch)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to match to URLs irrespective of the presence of a trailing slash.\n\t * If enabled a method mapped to \"/users\" also matches to \"/users/\".\n\t * @deprecated as of 6.0, see\n\t * {@link PathPatternParser#setMatchOptionalTrailingSeparator(boolean)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "useTrailingSlashPatternMatch"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "StandaloneMockMvcBuilder",
    "signature": "public StandaloneMockMvcBuilder setUseTrailingSlashPatternMatch(boolean useTrailingSlashPatternMatch)",
    "source_code": "\tpublic StandaloneMockMvcBuilder setUseTrailingSlashPatternMatch(boolean useTrailingSlashPatternMatch) {\n\t\tthis.useTrailingSlashPatternMatch = useTrailingSlashPatternMatch;\n\t\treturn this;\n\t}"
  },
  "org.springframework.transaction.support.<unknown>#execute(action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "action"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "return": "T",
    "signature": "public T execute(TransactionCallback<T> action)",
    "source_code": "\tpublic <T> @Nullable T execute(TransactionCallback<T> action) throws TransactionException {\n\t\treturn action.doInTransaction(new SimpleTransactionStatus(false));\n\t}"
  },
  "org.springframework.transaction.support.<unknown>#executeWithoutResult(action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "action"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "void",
    "signature": "public void executeWithoutResult(Consumer<TransactionStatus> action)",
    "source_code": "\tpublic void executeWithoutResult(Consumer<TransactionStatus> action) throws TransactionException {\n\t\taction.accept(new SimpleTransactionStatus(false));\n\t}"
  },
  "org.springframework.transaction.support.CallbackPreferringPlatformTransactionManager": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Extension of the {@link org.springframework.transaction.PlatformTransactionManager}\n * interface, exposing a method for executing a given callback within a transaction.\n *\n * <p>Implementors of this interface automatically express a preference for\n * callbacks over programmatic {@code getTransaction}, {@code commit}\n * and {@code rollback} calls. Calling code may check whether a given\n * transaction manager implements this interface to choose to prepare a\n * callback instead of explicit transaction demarcation control.\n *\n * <p>Spring's {@link TransactionTemplate} and\n * {@link org.springframework.transaction.interceptor.TransactionInterceptor}\n * detect and use this PlatformTransactionManager variant automatically.\n *\n * @author Juergen Hoeller\n * @since 2.0\n * @see TransactionTemplate\n * @see org.springframework.transaction.interceptor.TransactionInterceptor\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public interface CallbackPreferringPlatformTransactionManager",
    "source_code": "public interface CallbackPreferringPlatformTransactionManager extends PlatformTransactionManager {\n\n\t/**\n\t * Execute the action specified by the given callback object within a transaction.\n\t * <p>Allows for returning a result object created within the transaction, that is,\n\t * a domain object or a collection of domain objects. A RuntimeException thrown\n\t * by the callback is treated as a fatal exception that enforces a rollback.\n\t * Such an exception gets propagated to the caller of the template.\n\t * @param definition the definition for the transaction to wrap the callback in\n\t * @param callback the callback object that specifies the transactional action\n\t * @return a result object returned by the callback, or {@code null} if none\n\t * @throws TransactionException in case of initialization, rollback, or system errors\n\t * @throws RuntimeException if thrown by the TransactionCallback\n\t */\n\t<T> @Nullable T execute(@Nullable TransactionDefinition definition, TransactionCallback<T> callback)\n\t\t\tthrows TransactionException;\n\n}"
  },
  "org.springframework.transaction.support.TransactionOperations": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Interface specifying basic transaction execution operations.\n * Implemented by {@link TransactionTemplate}. Not often used directly,\n * but a useful option to enhance testability, as it can easily be\n * mocked or stubbed.\n *\n * @author Juergen Hoeller\n * @since 2.0.4\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public interface TransactionOperations",
    "source_code": "public interface TransactionOperations {\n\n\t/**\n\t * Execute the action specified by the given callback object within a transaction.\n\t * <p>Allows for returning a result object created within the transaction, that is,\n\t * a domain object or a collection of domain objects. A RuntimeException thrown\n\t * by the callback is treated as a fatal exception that enforces a rollback.\n\t * Such an exception gets propagated to the caller of the template.\n\t * @param action the callback object that specifies the transactional action\n\t * @return a result object returned by the callback, or {@code null} if none\n\t * @throws TransactionException in case of initialization, rollback, or system errors\n\t * @throws RuntimeException if thrown by the TransactionCallback\n\t * @see #executeWithoutResult(Consumer)\n\t */\n\t<T> @Nullable T execute(TransactionCallback<T> action) throws TransactionException;\n\n\t/**\n\t * Execute the action specified by the given {@link Runnable} within a transaction.\n\t * <p>If you need to return an object from the callback or access the\n\t * {@link org.springframework.transaction.TransactionStatus} from within the callback,\n\t * use {@link #execute(TransactionCallback)} instead.\n\t * <p>This variant is analogous to using a {@link TransactionCallbackWithoutResult}\n\t * but with a simplified signature for common cases - and conveniently usable with\n\t * Java 8 lambda expressions.\n\t * @param action the Runnable that specifies the transactional action\n\t * @throws TransactionException in case of initialization, rollback, or system errors\n\t * @throws RuntimeException if thrown by the Runnable\n\t * @since 5.2\n\t * @see #execute(TransactionCallback)\n\t * @see TransactionCallbackWithoutResult\n\t */\n\tdefault void executeWithoutResult(Consumer<TransactionStatus> action) throws TransactionException {\n\t\texecute(status -> {\n\t\t\taction.accept(status);\n\t\t\treturn null;\n\t\t});\n\t}\n\n\n\t/**\n\t * Return an implementation of the {@code TransactionOperations} interface which\n\t * executes a given {@link TransactionCallback} without an actual transaction.\n\t * <p>Useful for testing: The behavior is equivalent to running with a\n\t * transaction manager with no actual transaction (PROPAGATION_SUPPORTS)\n\t * and no synchronization (SYNCHRONIZATION_NEVER).\n\t * <p>For a {@link TransactionOperations} implementation with actual\n\t * transaction processing, use {@link TransactionTemplate} with an appropriate\n\t * {@link org.springframework.transaction.PlatformTransactionManager}.\n\t * @since 5.2\n\t * @see org.springframework.transaction.TransactionDefinition#PROPAGATION_SUPPORTS\n\t * @see AbstractPlatformTransactionManager#SYNCHRONIZATION_NEVER\n\t * @see TransactionTemplate\n\t */\n\tstatic TransactionOperations withoutTransaction() {\n\t\treturn WithoutTransactionOperations.INSTANCE;\n\t}\n\n}"
  },
  "org.springframework.ui.context.support.ResourceBundleThemeSource": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * {@link ThemeSource} implementation that looks up an individual\n * {@link java.util.ResourceBundle} per theme. The theme name gets\n * interpreted as ResourceBundle basename, supporting a common\n * basename prefix for all themes.\n *\n * @author Jean-Pierre Pawlak\n * @author Juergen Hoeller\n * @see #setBasenamePrefix\n * @see java.util.ResourceBundle\n * @see org.springframework.context.support.ResourceBundleMessageSource\n * @deprecated as of 6.0 in favor of using CSS, without direct replacement\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class ResourceBundleThemeSource",
    "source_code": "public class ResourceBundleThemeSource implements HierarchicalThemeSource, BeanClassLoaderAware {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t@Nullable\n\tprivate ThemeSource parentThemeSource;\n\n\tprivate String basenamePrefix = \"\";\n\n\t@Nullable\n\tprivate String defaultEncoding;\n\n\t@Nullable\n\tprivate Boolean fallbackToSystemLocale;\n\n\t@Nullable\n\tprivate ClassLoader beanClassLoader;\n\n\t/** Map from theme name to Theme instance. */\n\tprivate final Map<String, Theme> themeCache = new ConcurrentHashMap<>();\n\n\n\t@Override\n\tpublic void setParentThemeSource(@Nullable ThemeSource parent) {\n\t\tthis.parentThemeSource = parent;\n\n\t\t// Update existing Theme objects.\n\t\t// Usually there shouldn't be any at the time of this call.\n\t\tsynchronized (this.themeCache) {\n\t\t\tfor (Theme theme : this.themeCache.values()) {\n\t\t\t\tinitParent(theme);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic ThemeSource getParentThemeSource() {\n\t\treturn this.parentThemeSource;\n\t}\n\n\t/**\n\t * Set the prefix that gets applied to the ResourceBundle basenames,\n\t * i.e. the theme names.\n\t * For example: basenamePrefix=\"test.\", themeName=\"theme\" &rarr; basename=\"test.theme\".\n\t * <p>Note that ResourceBundle names are effectively classpath locations: As a\n\t * consequence, the JDK's standard ResourceBundle treats dots as package separators.\n\t * This means that \"test.theme\" is effectively equivalent to \"test/theme\",\n\t * just like it is for programmatic {@code java.util.ResourceBundle} usage.\n\t * @see java.util.ResourceBundle#getBundle(String)\n\t */\n\tpublic void setBasenamePrefix(@Nullable String basenamePrefix) {\n\t\tthis.basenamePrefix = (basenamePrefix != null ? basenamePrefix : \"\");\n\t}\n\n\t/**\n\t * Set the default charset to use for parsing resource bundle files.\n\t * <p>{@link ResourceBundleMessageSource}'s default is the\n\t * {@code java.util.ResourceBundle} default encoding: ISO-8859-1.\n\t * @since 4.2\n\t * @see ResourceBundleMessageSource#setDefaultEncoding\n\t */\n\tpublic void setDefaultEncoding(@Nullable String defaultEncoding) {\n\t\tthis.defaultEncoding = defaultEncoding;\n\t}\n\n\t/**\n\t * Set whether to fall back to the system Locale if no files for a\n\t * specific Locale have been found.\n\t * <p>{@link ResourceBundleMessageSource}'s default is \"true\".\n\t * @since 4.2\n\t * @see ResourceBundleMessageSource#setFallbackToSystemLocale\n\t */\n\tpublic void setFallbackToSystemLocale(boolean fallbackToSystemLocale) {\n\t\tthis.fallbackToSystemLocale = fallbackToSystemLocale;\n\t}\n\n\t@Override\n\tpublic void setBeanClassLoader(@Nullable ClassLoader beanClassLoader) {\n\t\tthis.beanClassLoader = beanClassLoader;\n\t}\n\n\n\t/**\n\t * This implementation returns a SimpleTheme instance, holding a\n\t * ResourceBundle-based MessageSource whose basename corresponds to\n\t * the given theme name (prefixed by the configured \"basenamePrefix\").\n\t * <p>SimpleTheme instances are cached per theme name. Use a reloadable\n\t * MessageSource if themes should reflect changes to the underlying files.\n\t * @see #setBasenamePrefix\n\t * @see #createMessageSource\n\t */\n\t@Override\n\t@Nullable\n\tpublic Theme getTheme(String themeName) {\n\t\tTheme theme = this.themeCache.get(themeName);\n\t\tif (theme == null) {\n\t\t\tsynchronized (this.themeCache) {\n\t\t\t\ttheme = this.themeCache.get(themeName);\n\t\t\t\tif (theme == null) {\n\t\t\t\t\tString basename = this.basenamePrefix + themeName;\n\t\t\t\t\tMessageSource messageSource = createMessageSource(basename);\n\t\t\t\t\ttheme = new SimpleTheme(themeName, messageSource);\n\t\t\t\t\tinitParent(theme);\n\t\t\t\t\tthis.themeCache.put(themeName, theme);\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Theme created: name '\" + themeName + \"', basename [\" + basename + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theme;\n\t}\n\n\t/**\n\t * Create a MessageSource for the given basename,\n\t * to be used as MessageSource for the corresponding theme.\n\t * <p>Default implementation creates a ResourceBundleMessageSource.\n\t * for the given basename. A subclass could create a specifically\n\t * configured ReloadableResourceBundleMessageSource, for example.\n\t * @param basename the basename to create a MessageSource for\n\t * @return the MessageSource\n\t * @see org.springframework.context.support.ResourceBundleMessageSource\n\t * @see org.springframework.context.support.ReloadableResourceBundleMessageSource\n\t */\n\tprotected MessageSource createMessageSource(String basename) {\n\t\tResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();\n\t\tmessageSource.setBasename(basename);\n\t\tif (this.defaultEncoding != null) {\n\t\t\tmessageSource.setDefaultEncoding(this.defaultEncoding);\n\t\t}\n\t\tif (this.fallbackToSystemLocale != null) {\n\t\t\tmessageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale);\n\t\t}\n\t\tif (this.beanClassLoader != null) {\n\t\t\tmessageSource.setBeanClassLoader(this.beanClassLoader);\n\t\t}\n\t\treturn messageSource;\n\t}\n\n\t/**\n\t * Initialize the MessageSource of the given theme with the\n\t * one from the corresponding parent of this ThemeSource.\n\t * @param theme the Theme to (re-)initialize\n\t */\n\tprotected void initParent(Theme theme) {\n\t\tif (theme.getMessageSource() instanceof HierarchicalMessageSource messageSource) {\n\t\t\tif (getParentThemeSource() != null && messageSource.getParentMessageSource() == null) {\n\t\t\t\tTheme parentTheme = getParentThemeSource().getTheme(theme.getName());\n\t\t\t\tif (parentTheme != null) {\n\t\t\t\t\tmessageSource.setParentMessageSource(parentTheme.getMessageSource());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.ui.context.support.ResourceBundleThemeSource#createMessageSource(basename)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a MessageSource for the given basename,\n\t * to be used as MessageSource for the corresponding theme.\n\t * <p>Default implementation creates a ResourceBundleMessageSource.\n\t * for the given basename. A subclass could create a specifically\n\t * configured ReloadableResourceBundleMessageSource, for example.\n\t * @param basename the basename to create a MessageSource for\n\t * @return the MessageSource\n\t * @see org.springframework.context.support.ResourceBundleMessageSource\n\t * @see org.springframework.context.support.ReloadableResourceBundleMessageSource\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "basename"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "MessageSource",
    "signature": "protected MessageSource createMessageSource(String basename)",
    "source_code": "\tprotected MessageSource createMessageSource(String basename) {\n\t\tResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();\n\t\tmessageSource.setBasename(basename);\n\t\tif (this.defaultEncoding != null) {\n\t\t\tmessageSource.setDefaultEncoding(this.defaultEncoding);\n\t\t}\n\t\tif (this.fallbackToSystemLocale != null) {\n\t\t\tmessageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale);\n\t\t}\n\t\tif (this.beanClassLoader != null) {\n\t\t\tmessageSource.setBeanClassLoader(this.beanClassLoader);\n\t\t}\n\t\treturn messageSource;\n\t}"
  },
  "org.springframework.ui.context.support.ResourceBundleThemeSource#getParentThemeSource()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "ThemeSource",
    "signature": "public ThemeSource getParentThemeSource()",
    "source_code": "\tpublic ThemeSource getParentThemeSource() {\n\t\treturn this.parentThemeSource;\n\t}"
  },
  "org.springframework.ui.context.support.ResourceBundleThemeSource#getTheme(themeName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns a SimpleTheme instance, holding a\n\t * ResourceBundle-based MessageSource whose basename corresponds to\n\t * the given theme name (prefixed by the configured \"basenamePrefix\").\n\t * <p>SimpleTheme instances are cached per theme name. Use a reloadable\n\t * MessageSource if themes should reflect changes to the underlying files.\n\t * @see #setBasenamePrefix\n\t * @see #createMessageSource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "themeName"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "Theme",
    "signature": "public Theme getTheme(String themeName)",
    "source_code": "\tpublic Theme getTheme(String themeName) {\n\t\tTheme theme = this.themeCache.get(themeName);\n\t\tif (theme == null) {\n\t\t\tsynchronized (this.themeCache) {\n\t\t\t\ttheme = this.themeCache.get(themeName);\n\t\t\t\tif (theme == null) {\n\t\t\t\t\tString basename = this.basenamePrefix + themeName;\n\t\t\t\t\tMessageSource messageSource = createMessageSource(basename);\n\t\t\t\t\ttheme = new SimpleTheme(themeName, messageSource);\n\t\t\t\t\tinitParent(theme);\n\t\t\t\t\tthis.themeCache.put(themeName, theme);\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Theme created: name '\" + themeName + \"', basename [\" + basename + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theme;\n\t}"
  },
  "org.springframework.ui.context.support.ResourceBundleThemeSource#initParent(theme)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the MessageSource of the given theme with the\n\t * one from the corresponding parent of this ThemeSource.\n\t * @param theme the Theme to (re-)initialize\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "theme"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "void",
    "signature": "protected void initParent(Theme theme)",
    "source_code": "\tprotected void initParent(Theme theme) {\n\t\tif (theme.getMessageSource() instanceof HierarchicalMessageSource messageSource) {\n\t\t\tif (getParentThemeSource() != null && messageSource.getParentMessageSource() == null) {\n\t\t\t\tTheme parentTheme = getParentThemeSource().getTheme(theme.getName());\n\t\t\t\tif (parentTheme != null) {\n\t\t\t\t\tmessageSource.setParentMessageSource(parentTheme.getMessageSource());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.ui.context.support.ResourceBundleThemeSource#setBasenamePrefix(basenamePrefix)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the prefix that gets applied to the ResourceBundle basenames,\n\t * i.e. the theme names.\n\t * For example: basenamePrefix=\"test.\", themeName=\"theme\" &rarr; basename=\"test.theme\".\n\t * <p>Note that ResourceBundle names are effectively classpath locations: As a\n\t * consequence, the JDK's standard ResourceBundle treats dots as package separators.\n\t * This means that \"test.theme\" is effectively equivalent to \"test/theme\",\n\t * just like it is for programmatic {@code java.util.ResourceBundle} usage.\n\t * @see java.util.ResourceBundle#getBundle(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "basenamePrefix"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void setBasenamePrefix(@Nullable String basenamePrefix)",
    "source_code": "\tpublic void setBasenamePrefix(@Nullable String basenamePrefix) {\n\t\tthis.basenamePrefix = (basenamePrefix != null ? basenamePrefix : \"\");\n\t}"
  },
  "org.springframework.ui.context.support.ResourceBundleThemeSource#setBeanClassLoader(beanClassLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClassLoader"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void setBeanClassLoader(@Nullable ClassLoader beanClassLoader)",
    "source_code": "\tpublic void setBeanClassLoader(@Nullable ClassLoader beanClassLoader) {\n\t\tthis.beanClassLoader = beanClassLoader;\n\t}"
  },
  "org.springframework.ui.context.support.ResourceBundleThemeSource#setDefaultEncoding(defaultEncoding)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the default charset to use for parsing resource bundle files.\n\t * <p>{@link ResourceBundleMessageSource}'s default is the\n\t * {@code java.util.ResourceBundle} default encoding: ISO-8859-1.\n\t * @since 4.2\n\t * @see ResourceBundleMessageSource#setDefaultEncoding\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultEncoding"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void setDefaultEncoding(@Nullable String defaultEncoding)",
    "source_code": "\tpublic void setDefaultEncoding(@Nullable String defaultEncoding) {\n\t\tthis.defaultEncoding = defaultEncoding;\n\t}"
  },
  "org.springframework.ui.context.support.ResourceBundleThemeSource#setFallbackToSystemLocale(fallbackToSystemLocale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to fall back to the system Locale if no files for a\n\t * specific Locale have been found.\n\t * <p>{@link ResourceBundleMessageSource}'s default is \"true\".\n\t * @since 4.2\n\t * @see ResourceBundleMessageSource#setFallbackToSystemLocale\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fallbackToSystemLocale"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void setFallbackToSystemLocale(boolean fallbackToSystemLocale)",
    "source_code": "\tpublic void setFallbackToSystemLocale(boolean fallbackToSystemLocale) {\n\t\tthis.fallbackToSystemLocale = fallbackToSystemLocale;\n\t}"
  },
  "org.springframework.ui.context.support.ResourceBundleThemeSource#setParentThemeSource(parent)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parent"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "public void setParentThemeSource(@Nullable ThemeSource parent)",
    "source_code": "\tpublic void setParentThemeSource(@Nullable ThemeSource parent) {\n\t\tthis.parentThemeSource = parent;\n\n\t\t// Update existing Theme objects.\n\t\t// Usually there shouldn't be any at the time of this call.\n\t\tsynchronized (this.themeCache) {\n\t\t\tfor (Theme theme : this.themeCache.values()) {\n\t\t\t\tinitParent(theme);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.ui.context.support.THEME_SOURCE_BEAN_NAME": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Name of the ThemeSource bean in the factory.\n\t * If none is supplied, theme resolution is delegated to the parent.\n\t * @see org.springframework.ui.context.ThemeSource\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public String THEME_SOURCE_BEAN_NAME",
    "source_code": "\tpublic static final String THEME_SOURCE_BEAN_NAME = \"themeSource\";",
    "type": "String"
  },
  "org.springframework.ui.context.support.UiApplicationContextUtils": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Utility class for UI application context implementations.\n * Provides support for a special bean named \"themeSource\",\n * of type {@link org.springframework.ui.context.ThemeSource}.\n *\n * @author Jean-Pierre Pawlak\n * @author Juergen Hoeller\n * @since 17.06.2003\n * @deprecated as of 6.0 in favor of using CSS, without direct replacement\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class UiApplicationContextUtils",
    "source_code": "public abstract class UiApplicationContextUtils {\n\n\t/**\n\t * Name of the ThemeSource bean in the factory.\n\t * If none is supplied, theme resolution is delegated to the parent.\n\t * @see org.springframework.ui.context.ThemeSource\n\t */\n\tpublic static final String THEME_SOURCE_BEAN_NAME = \"themeSource\";\n\n\n\tprivate static final Log logger = LogFactory.getLog(UiApplicationContextUtils.class);\n\n\n\t/**\n\t * Initialize the ThemeSource for the given application context,\n\t * autodetecting a bean with the name \"themeSource\". If no such\n\t * bean is found, a default (empty) ThemeSource will be used.\n\t * @param context current application context\n\t * @return the initialized theme source (will never be {@code null})\n\t * @see #THEME_SOURCE_BEAN_NAME\n\t */\n\tpublic static ThemeSource initThemeSource(ApplicationContext context) {\n\t\tif (context.containsLocalBean(THEME_SOURCE_BEAN_NAME)) {\n\t\t\tThemeSource themeSource = context.getBean(THEME_SOURCE_BEAN_NAME, ThemeSource.class);\n\t\t\t// Make ThemeSource aware of parent ThemeSource.\n\t\t\tif (context.getParent() instanceof ThemeSource pts && themeSource instanceof HierarchicalThemeSource hts) {\n\t\t\t\tif (hts.getParentThemeSource() == null) {\n\t\t\t\t\t// Only set parent context as parent ThemeSource if no parent ThemeSource\n\t\t\t\t\t// registered already.\n\t\t\t\t\thts.setParentThemeSource(pts);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Using ThemeSource [\" + themeSource + \"]\");\n\t\t\t}\n\t\t\treturn themeSource;\n\t\t}\n\t\telse {\n\t\t\t// Use default ThemeSource to be able to accept getTheme calls, either\n\t\t\t// delegating to parent context's default or to local ResourceBundleThemeSource.\n\t\t\tHierarchicalThemeSource themeSource = null;\n\t\t\tif (context.getParent() instanceof ThemeSource pts) {\n\t\t\t\tthemeSource = new DelegatingThemeSource();\n\t\t\t\tthemeSource.setParentThemeSource(pts);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthemeSource = new ResourceBundleThemeSource();\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Unable to locate ThemeSource with name '\" + THEME_SOURCE_BEAN_NAME +\n\t\t\t\t\t\t\"': using default [\" + themeSource + \"]\");\n\t\t\t}\n\t\t\treturn themeSource;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.ui.context.support.UiApplicationContextUtils#initThemeSource(context)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the ThemeSource for the given application context,\n\t * autodetecting a bean with the name \"themeSource\". If no such\n\t * bean is found, a default (empty) ThemeSource will be used.\n\t * @param context current application context\n\t * @return the initialized theme source (will never be {@code null})\n\t * @see #THEME_SOURCE_BEAN_NAME\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "ThemeSource",
    "signature": "public ThemeSource initThemeSource(ApplicationContext context)",
    "source_code": "\tpublic static ThemeSource initThemeSource(ApplicationContext context) {\n\t\tif (context.containsLocalBean(THEME_SOURCE_BEAN_NAME)) {\n\t\t\tThemeSource themeSource = context.getBean(THEME_SOURCE_BEAN_NAME, ThemeSource.class);\n\t\t\t// Make ThemeSource aware of parent ThemeSource.\n\t\t\tif (context.getParent() instanceof ThemeSource pts && themeSource instanceof HierarchicalThemeSource hts) {\n\t\t\t\tif (hts.getParentThemeSource() == null) {\n\t\t\t\t\t// Only set parent context as parent ThemeSource if no parent ThemeSource\n\t\t\t\t\t// registered already.\n\t\t\t\t\thts.setParentThemeSource(pts);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Using ThemeSource [\" + themeSource + \"]\");\n\t\t\t}\n\t\t\treturn themeSource;\n\t\t}\n\t\telse {\n\t\t\t// Use default ThemeSource to be able to accept getTheme calls, either\n\t\t\t// delegating to parent context's default or to local ResourceBundleThemeSource.\n\t\t\tHierarchicalThemeSource themeSource = null;\n\t\t\tif (context.getParent() instanceof ThemeSource pts) {\n\t\t\t\tthemeSource = new DelegatingThemeSource();\n\t\t\t\tthemeSource.setParentThemeSource(pts);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthemeSource = new ResourceBundleThemeSource();\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Unable to locate ThemeSource with name '\" + THEME_SOURCE_BEAN_NAME +\n\t\t\t\t\t\t\"': using default [\" + themeSource + \"]\");\n\t\t\t}\n\t\t\treturn themeSource;\n\t\t}\n\t}"
  },
  "org.springframework.ui.context.support.logger": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.util.<unknown>#add(e)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "boolean",
    "signature": "public boolean add(E e)",
    "source_code": "\tpublic boolean add(E e) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#entrySet()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "V>>",
    "signature": "public V>> entrySet()",
    "source_code": "\tpublic Set<Entry<K, V>> entrySet() {\n\t\tSet<Entry<K, V>> entries = this.entries;\n\t\tif (entries == null) {\n\t\t\tSet<Entry<K, List<V>>> targetEntries = this.targetMap.entrySet();\n\t\t\tentries = new AbstractSet<>() {\n\t\t\t\t@Override\n\t\t\t\tpublic Iterator<Entry<K, V>> iterator() {\n\t\t\t\t\tIterator<Entry<K, List<V>>> targetIterator = targetEntries.iterator();\n\t\t\t\t\treturn new Iterator<>() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\t\t\treturn targetIterator.hasNext();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Entry<K, V> next() {\n\t\t\t\t\t\t\tEntry<K, List<V>> entry = targetIterator.next();\n\t\t\t\t\t\t\treturn new AbstractMap.SimpleImmutableEntry<>(entry.getKey(), entry.getValue().get(0));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int size() {\n\t\t\t\t\treturn targetEntries.size();\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.entries = entries;\n\t\t}\n\t\treturn entries;\n\t}"
  },
  "org.springframework.util.<unknown>#get(key)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "V",
    "signature": "public V get(Object key)",
    "source_code": "\tpublic @Nullable V get(Object key) {\n\t\treturn adaptValue(this.targetMap.get(key));\n\t}"
  },
  "org.springframework.util.<unknown>#iterator()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "Iterator<E>",
    "signature": "public Iterator<E> iterator()",
    "source_code": "\tpublic Iterator<E> iterator() {\n\t\tCompositeIterator<E> iterator = new CompositeIterator<>();\n\t\titerator.add(this.first.iterator());\n\t\titerator.add(this.second.iterator());\n\t\treturn iterator;\n\t}"
  },
  "org.springframework.util.<unknown>#next()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "V>",
    "signature": "public V> next()",
    "source_code": "\t\t\t\t\t\tpublic Entry<K, V> next() {\n\t\t\t\t\t\t\tEntry<K, List<V>> entry = targetIterator.next();\n\t\t\t\t\t\t\treturn new AbstractMap.SimpleImmutableEntry<>(entry.getKey(), entry.getValue().get(0));\n\t\t\t\t\t\t}"
  },
  "org.springframework.util.<unknown>#put(key,value)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "V",
    "signature": "public V put(K key, @Nullable V value)",
    "source_code": "\tpublic @Nullable V put(K key, @Nullable V value) {\n\t\treturn adaptValue(this.targetMap.put(key, adaptValue(value)));\n\t}"
  },
  "org.springframework.util.<unknown>#remove(key)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "V",
    "signature": "public V remove(Object key)",
    "source_code": "\tpublic @Nullable V remove(Object key) {\n\t\treturn adaptValue(this.targetMap.remove(key));\n\t}"
  },
  "org.springframework.util.<unknown>#values()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "Collection<V>",
    "signature": "public Collection<V> values()",
    "source_code": "\tpublic Collection<V> values() {\n\t\tCollection<V> values = this.values;\n\t\tif (values == null) {\n\t\t\tCollection<List<V>> targetValues = this.targetMap.values();\n\t\t\tvalues = new AbstractCollection<>() {\n\t\t\t\t@Override\n\t\t\t\tpublic Iterator<V> iterator() {\n\t\t\t\t\tIterator<List<V>> targetIterator = targetValues.iterator();\n\t\t\t\t\treturn new Iterator<>() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\t\t\treturn targetIterator.hasNext();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic V next() {\n\t\t\t\t\t\t\treturn targetIterator.next().get(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic int size() {\n\t\t\t\t\treturn targetValues.size();\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.values = values;\n\t\t}\n\t\treturn values;\n\t}"
  },
  "org.springframework.util.ARRAY_SUFFIX": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Suffix for array class names: {@code \"[]\"}. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "signature": "public String ARRAY_SUFFIX",
    "source_code": "\tpublic static final String ARRAY_SUFFIX = \"[]\";",
    "type": "String"
  },
  "org.springframework.util.Assert": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Assertion utility class that assists in validating arguments.\n *\n * <p>Useful for identifying programmer errors early and clearly at runtime.\n *\n * <p>For example, if the contract of a public method states it does not\n * allow {@code null} arguments, {@code Assert} can be used to validate that\n * contract. Doing this clearly indicates a contract violation when it\n * occurs and protects the class's invariants.\n *\n * <p>Typically used to validate method arguments rather than configuration\n * properties, to check for cases that are usually programmer errors rather\n * than configuration errors. In contrast to configuration initialization\n * code, there is usually no point in falling back to defaults in such methods.\n *\n * <p>This class is similar to JUnit's assertion library. If an argument value is\n * deemed invalid, an {@link IllegalArgumentException} is thrown (typically).\n * For example:\n *\n * <pre class=\"code\">\n * Assert.notNull(clazz, \"The class must not be null\");\n * Assert.isTrue(i &gt; 0, \"The value must be greater than zero\");</pre>\n *\n * <p>Mainly for internal use within the framework; for a more comprehensive suite\n * of assertion utilities consider {@code org.apache.commons.lang3.Validate} from\n * <a href=\"https://commons.apache.org/proper/commons-lang/\">Apache Commons Lang</a>,\n * Google Guava's\n * <a href=\"https://github.com/google/guava/wiki/PreconditionsExplained\">Preconditions</a>,\n * or similar third-party libraries.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Colin Sampaleanu\n * @author Rob Harrop\n * @author Sebastien Deleuze\n * @since 1.1.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "signature": "public class Assert",
    "source_code": "public abstract class Assert {\n\n\t/**\n\t * Assert a boolean expression, throwing an {@code IllegalStateException}\n\t * if the expression evaluates to {@code false}.\n\t * <p>Call {@link #isTrue} if you wish to throw an {@code IllegalArgumentException}\n\t * on an assertion failure.\n\t * <pre class=\"code\">Assert.state(id == null, \"The id property must not already be initialized\");</pre>\n\t * @param expression a boolean expression\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalStateException if {@code expression} is {@code false}\n\t */\n\t@Contract(\"false, _ -> fail\")\n\tpublic static void state(boolean expression, String message) {\n\t\tif (!expression) {\n\t\t\tthrow new IllegalStateException(message);\n\t\t}\n\t}\n\n\t/**\n\t * Assert a boolean expression, throwing an {@code IllegalStateException}\n\t * if the expression evaluates to {@code false}.\n\t * <p>Call {@link #isTrue} if you wish to throw an {@code IllegalArgumentException}\n\t * on an assertion failure.\n\t * <pre class=\"code\">\n\t * Assert.state(entity.getId() == null,\n\t *     () -&gt; \"ID for entity \" + entity.getName() + \" must not already be initialized\");\n\t * </pre>\n\t * @param expression a boolean expression\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalStateException if {@code expression} is {@code false}\n\t * @since 5.0\n\t */\n\t@Contract(\"false, _ -> fail\")\n\tpublic static void state(boolean expression, Supplier<String> messageSupplier) {\n\t\tif (!expression) {\n\t\t\tthrow new IllegalStateException(nullSafeGet(messageSupplier));\n\t\t}\n\t}\n\n\t/**\n\t * Assert a boolean expression, throwing an {@code IllegalArgumentException}\n\t * if the expression evaluates to {@code false}.\n\t * <pre class=\"code\">Assert.isTrue(i &gt; 0, \"The value must be greater than zero\");</pre>\n\t * @param expression a boolean expression\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if {@code expression} is {@code false}\n\t */\n\t@Contract(\"false, _ -> fail\")\n\tpublic static void isTrue(boolean expression, String message) {\n\t\tif (!expression) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}\n\n\t/**\n\t * Assert a boolean expression, throwing an {@code IllegalArgumentException}\n\t * if the expression evaluates to {@code false}.\n\t * <pre class=\"code\">\n\t * Assert.isTrue(i &gt; 0, () -&gt; \"The value '\" + i + \"' must be greater than zero\");\n\t * </pre>\n\t * @param expression a boolean expression\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if {@code expression} is {@code false}\n\t * @since 5.0\n\t */\n\t@Contract(\"false, _ -> fail\")\n\tpublic static void isTrue(boolean expression, Supplier<String> messageSupplier) {\n\t\tif (!expression) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}\n\n\t/**\n\t * Assert that an object is {@code null}.\n\t * <pre class=\"code\">Assert.isNull(value, \"The value must be null\");</pre>\n\t * @param object the object to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the object is not {@code null}\n\t */\n\t@Contract(\"!null, _ -> fail\")\n\tpublic static void isNull(@Nullable Object object, String message) {\n\t\tif (object != null) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}\n\n\t/**\n\t * Assert that an object is {@code null}.\n\t * <pre class=\"code\">\n\t * Assert.isNull(value, () -&gt; \"The value '\" + value + \"' must be null\");\n\t * </pre>\n\t * @param object the object to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object is not {@code null}\n\t * @since 5.0\n\t */\n\t@Contract(\"!null, _ -> fail\")\n\tpublic static void isNull(@Nullable Object object, Supplier<String> messageSupplier) {\n\t\tif (object != null) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}\n\n\t/**\n\t * Assert that an object is not {@code null}.\n\t * <pre class=\"code\">Assert.notNull(clazz, \"The class must not be null\");</pre>\n\t * @param object the object to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the object is {@code null}\n\t */\n\t@Contract(\"null, _ -> fail\")\n\tpublic static void notNull(@Nullable Object object, String message) {\n\t\tif (object == null) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}\n\n\t/**\n\t * Assert that an object is not {@code null}.\n\t * <pre class=\"code\">\n\t * Assert.notNull(entity.getId(),\n\t *     () -&gt; \"ID for entity \" + entity.getName() + \" must not be null\");\n\t * </pre>\n\t * @param object the object to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object is {@code null}\n\t * @since 5.0\n\t */\n\t@Contract(\"null, _ -> fail\")\n\tpublic static void notNull(@Nullable Object object, Supplier<String> messageSupplier) {\n\t\tif (object == null) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}\n\n\t/**\n\t * Assert that the given String is not empty; that is,\n\t * it must not be {@code null} and not the empty String.\n\t * <pre class=\"code\">Assert.hasLength(name, \"Name must not be empty\");</pre>\n\t * @param text the String to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the text is empty\n\t * @see StringUtils#hasLength\n\t */\n\t@Contract(\"null, _ -> fail\")\n\tpublic static void hasLength(@Nullable String text, String message) {\n\t\tif (!StringUtils.hasLength(text)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}\n\n\t/**\n\t * Assert that the given String is not empty; that is,\n\t * it must not be {@code null} and not the empty String.\n\t * <pre class=\"code\">\n\t * Assert.hasLength(account.getName(),\n\t *     () -&gt; \"Name for account '\" + account.getId() + \"' must not be empty\");\n\t * </pre>\n\t * @param text the String to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the text is empty\n\t * @since 5.0\n\t * @see StringUtils#hasLength\n\t */\n\t@Contract(\"null, _ -> fail\")\n\tpublic static void hasLength(@Nullable String text, Supplier<String> messageSupplier) {\n\t\tif (!StringUtils.hasLength(text)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}\n\n\t/**\n\t * Assert that the given String contains valid text content; that is, it must not\n\t * be {@code null} and must contain at least one non-whitespace character.\n\t * <pre class=\"code\">Assert.hasText(name, \"'name' must not be empty\");</pre>\n\t * @param text the String to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the text does not contain valid text content\n\t * @see StringUtils#hasText\n\t */\n\t@Contract(\"null, _ -> fail\")\n\tpublic static void hasText(@Nullable String text, String message) {\n\t\tif (!StringUtils.hasText(text)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}\n\n\t/**\n\t * Assert that the given String contains valid text content; that is, it must not\n\t * be {@code null} and must contain at least one non-whitespace character.\n\t * <pre class=\"code\">\n\t * Assert.hasText(account.getName(),\n\t *     () -&gt; \"Name for account '\" + account.getId() + \"' must not be empty\");\n\t * </pre>\n\t * @param text the String to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the text does not contain valid text content\n\t * @since 5.0\n\t * @see StringUtils#hasText\n\t */\n\t@Contract(\"null, _ -> fail\")\n\tpublic static void hasText(@Nullable String text, Supplier<String> messageSupplier) {\n\t\tif (!StringUtils.hasText(text)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}\n\n\t/**\n\t * Assert that the given text does not contain the given substring.\n\t * <pre class=\"code\">Assert.doesNotContain(name, \"rod\", \"Name must not contain 'rod'\");</pre>\n\t * @param textToSearch the text to search\n\t * @param substring the substring to find within the text\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the text contains the substring\n\t */\n\tpublic static void doesNotContain(@Nullable String textToSearch, String substring, String message) {\n\t\tif (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring) &&\n\t\t\t\ttextToSearch.contains(substring)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}\n\n\t/**\n\t * Assert that the given text does not contain the given substring.\n\t * <pre class=\"code\">\n\t * Assert.doesNotContain(name, forbidden, () -&gt; \"Name must not contain '\" + forbidden + \"'\");\n\t * </pre>\n\t * @param textToSearch the text to search\n\t * @param substring the substring to find within the text\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the text contains the substring\n\t * @since 5.0\n\t */\n\tpublic static void doesNotContain(@Nullable String textToSearch, String substring, Supplier<String> messageSupplier) {\n\t\tif (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring) &&\n\t\t\t\ttextToSearch.contains(substring)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}\n\n\t/**\n\t * Assert that an array contains elements; that is, it must not be\n\t * {@code null} and must contain at least one element.\n\t * <pre class=\"code\">Assert.notEmpty(array, \"The array must contain elements\");</pre>\n\t * @param array the array to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the object array is {@code null} or contains no elements\n\t */\n\t@Contract(\"null, _ -> fail\")\n\tpublic static void notEmpty(@Nullable Object @Nullable [] array, String message) {\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}\n\n\t/**\n\t * Assert that an array contains elements; that is, it must not be\n\t * {@code null} and must contain at least one element.\n\t * <pre class=\"code\">\n\t * Assert.notEmpty(array, () -&gt; \"The \" + arrayType + \" array must contain elements\");\n\t * </pre>\n\t * @param array the array to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object array is {@code null} or contains no elements\n\t * @since 5.0\n\t */\n\t@Contract(\"null, _ -> fail\")\n\tpublic static void notEmpty(Object @Nullable [] array, Supplier<String> messageSupplier) {\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}\n\n\t/**\n\t * Assert that an array contains no {@code null} elements.\n\t * <p>Note: Does not complain if the array is empty!\n\t * <pre class=\"code\">Assert.noNullElements(array, \"The array must contain non-null elements\");</pre>\n\t * @param array the array to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the object array contains a {@code null} element\n\t */\n\tpublic static void noNullElements(Object @Nullable [] array, String message) {\n\t\tif (array != null) {\n\t\t\tfor (Object element : array) {\n\t\t\t\tif (element == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Assert that an array contains no {@code null} elements.\n\t * <p>Note: Does not complain if the array is empty!\n\t * <pre class=\"code\">\n\t * Assert.noNullElements(array, () -&gt; \"The \" + arrayType + \" array must contain non-null elements\");\n\t * </pre>\n\t * @param array the array to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object array contains a {@code null} element\n\t * @since 5.0\n\t */\n\tpublic static void noNullElements(Object @Nullable [] array, Supplier<String> messageSupplier) {\n\t\tif (array != null) {\n\t\t\tfor (Object element : array) {\n\t\t\t\tif (element == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Assert that a collection contains elements; that is, it must not be\n\t * {@code null} and must contain at least one element.\n\t * <pre class=\"code\">Assert.notEmpty(collection, \"Collection must contain elements\");</pre>\n\t * @param collection the collection to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the collection is {@code null} or\n\t * contains no elements\n\t */\n\t@Contract(\"null, _ -> fail\")\n\tpublic static void notEmpty(@Nullable Collection<?> collection, String message) {\n\t\tif (CollectionUtils.isEmpty(collection)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}\n\n\t/**\n\t * Assert that a collection contains elements; that is, it must not be\n\t * {@code null} and must contain at least one element.\n\t * <pre class=\"code\">\n\t * Assert.notEmpty(collection, () -&gt; \"The \" + collectionType + \" collection must contain elements\");\n\t * </pre>\n\t * @param collection the collection to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the collection is {@code null} or\n\t * contains no elements\n\t * @since 5.0\n\t */\n\t@Contract(\"null, _ -> fail\")\n\tpublic static void notEmpty(@Nullable Collection<?> collection, Supplier<String> messageSupplier) {\n\t\tif (CollectionUtils.isEmpty(collection)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}\n\n\t/**\n\t * Assert that a collection contains no {@code null} elements.\n\t * <p>Note: Does not complain if the collection is empty!\n\t * <pre class=\"code\">Assert.noNullElements(collection, \"Collection must contain non-null elements\");</pre>\n\t * @param collection the collection to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the collection contains a {@code null} element\n\t * @since 5.2\n\t */\n\tpublic static void noNullElements(@Nullable Collection<?> collection, String message) {\n\t\tif (collection != null) {\n\t\t\tfor (Object element : collection) {\n\t\t\t\tif (element == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Assert that a collection contains no {@code null} elements.\n\t * <p>Note: Does not complain if the collection is empty!\n\t * <pre class=\"code\">\n\t * Assert.noNullElements(collection, () -&gt; \"Collection \" + collectionName + \" must contain non-null elements\");\n\t * </pre>\n\t * @param collection the collection to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the collection contains a {@code null} element\n\t * @since 5.2\n\t */\n\tpublic static void noNullElements(@Nullable Collection<?> collection, Supplier<String> messageSupplier) {\n\t\tif (collection != null) {\n\t\t\tfor (Object element : collection) {\n\t\t\t\tif (element == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Assert that a Map contains entries; that is, it must not be {@code null}\n\t * and must contain at least one entry.\n\t * <pre class=\"code\">Assert.notEmpty(map, \"Map must contain entries\");</pre>\n\t * @param map the map to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the map is {@code null} or contains no entries\n\t */\n\t@Contract(\"null, _ -> fail\")\n\tpublic static void notEmpty(@Nullable Map<?, ?> map, String message) {\n\t\tif (CollectionUtils.isEmpty(map)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}\n\n\t/**\n\t * Assert that a Map contains entries; that is, it must not be {@code null}\n\t * and must contain at least one entry.\n\t * <pre class=\"code\">\n\t * Assert.notEmpty(map, () -&gt; \"The \" + mapType + \" map must contain entries\");\n\t * </pre>\n\t * @param map the map to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the map is {@code null} or contains no entries\n\t * @since 5.0\n\t */\n\t@Contract(\"null, _ -> fail\")\n\tpublic static void notEmpty(@Nullable Map<?, ?> map, Supplier<String> messageSupplier) {\n\t\tif (CollectionUtils.isEmpty(map)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}\n\n\t/**\n\t * Assert that the provided object is an instance of the provided class.\n\t * <pre class=\"code\">Assert.instanceOf(Foo.class, foo, \"Foo expected\");</pre>\n\t * @param type the type to check against\n\t * @param obj the object to check\n\t * @param message a message which will be prepended to provide further context.\n\t * If it is empty or ends in \":\" or \";\" or \",\" or \".\", a full exception message\n\t * will be appended. If it ends in a space, the name of the offending object's\n\t * type will be appended. In any other case, a \":\" with a space and the name\n\t * of the offending object's type will be appended.\n\t * @throws IllegalArgumentException if the object is not an instance of type\n\t */\n\t@Contract(\"_, null, _ -> fail\")\n\tpublic static void isInstanceOf(Class<?> type, @Nullable Object obj, String message) {\n\t\tnotNull(type, \"Type to check against must not be null\");\n\t\tif (!type.isInstance(obj)) {\n\t\t\tinstanceCheckFailed(type, obj, message);\n\t\t}\n\t}\n\n\t/**\n\t * Assert that the provided object is an instance of the provided class.\n\t * <pre class=\"code\">\n\t * Assert.instanceOf(Foo.class, foo, () -&gt; \"Processing \" + Foo.class.getSimpleName() + \":\");\n\t * </pre>\n\t * @param type the type to check against\n\t * @param obj the object to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails. See {@link #isInstanceOf(Class, Object, String)} for details.\n\t * @throws IllegalArgumentException if the object is not an instance of type\n\t * @since 5.0\n\t */\n\t@Contract(\"_, null, _ -> fail\")\n\tpublic static void isInstanceOf(Class<?> type, @Nullable Object obj, Supplier<String> messageSupplier) {\n\t\tnotNull(type, \"Type to check against must not be null\");\n\t\tif (!type.isInstance(obj)) {\n\t\t\tinstanceCheckFailed(type, obj, nullSafeGet(messageSupplier));\n\t\t}\n\t}\n\n\t/**\n\t * Assert that the provided object is an instance of the provided class.\n\t * <pre class=\"code\">Assert.instanceOf(Foo.class, foo);</pre>\n\t * @param type the type to check against\n\t * @param obj the object to check\n\t * @throws IllegalArgumentException if the object is not an instance of type\n\t */\n\t@Contract(\"_, null -> fail\")\n\tpublic static void isInstanceOf(Class<?> type, @Nullable Object obj) {\n\t\tisInstanceOf(type, obj, \"\");\n\t}\n\n\t/**\n\t * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.\n\t * <pre class=\"code\">Assert.isAssignable(Number.class, myClass, \"Number expected\");</pre>\n\t * @param superType the supertype to check against\n\t * @param subType the subtype to check\n\t * @param message a message which will be prepended to provide further context.\n\t * If it is empty or ends in \":\" or \";\" or \",\" or \".\", a full exception message\n\t * will be appended. If it ends in a space, the name of the offending subtype\n\t * will be appended. In any other case, a \":\" with a space and the name of the\n\t * offending subtype will be appended.\n\t * @throws IllegalArgumentException if the classes are not assignable\n\t */\n\t@Contract(\"_, null, _ -> fail\")\n\tpublic static void isAssignable(Class<?> superType, @Nullable Class<?> subType, String message) {\n\t\tnotNull(superType, \"Supertype to check against must not be null\");\n\t\tif (subType == null || !superType.isAssignableFrom(subType)) {\n\t\t\tassignableCheckFailed(superType, subType, message);\n\t\t}\n\t}\n\n\t/**\n\t * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.\n\t * <pre class=\"code\">\n\t * Assert.isAssignable(Number.class, myClass, () -&gt; \"Processing \" + myAttributeName + \":\");\n\t * </pre>\n\t * @param superType the supertype to check against\n\t * @param subType the subtype to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails. See {@link #isAssignable(Class, Class, String)} for details.\n\t * @throws IllegalArgumentException if the classes are not assignable\n\t * @since 5.0\n\t */\n\t@Contract(\"_, null, _ -> fail\")\n\tpublic static void isAssignable(Class<?> superType, @Nullable Class<?> subType, Supplier<String> messageSupplier) {\n\t\tnotNull(superType, \"Supertype to check against must not be null\");\n\t\tif (subType == null || !superType.isAssignableFrom(subType)) {\n\t\t\tassignableCheckFailed(superType, subType, nullSafeGet(messageSupplier));\n\t\t}\n\t}\n\n\t/**\n\t * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.\n\t * <pre class=\"code\">Assert.isAssignable(Number.class, myClass);</pre>\n\t * @param superType the supertype to check\n\t * @param subType the subtype to check\n\t * @throws IllegalArgumentException if the classes are not assignable\n\t */\n\t@Contract(\"_, null -> fail\")\n\tpublic static void isAssignable(Class<?> superType, @Nullable Class<?> subType) {\n\t\tisAssignable(superType, subType, \"\");\n\t}\n\n\n\tprivate static void instanceCheckFailed(Class<?> type, @Nullable Object obj, @Nullable String msg) {\n\t\tString className = (obj != null ? obj.getClass().getName() : \"null\");\n\t\tString result = \"\";\n\t\tboolean defaultMessage = true;\n\t\tif (StringUtils.hasLength(msg)) {\n\t\t\tif (endsWithSeparator(msg)) {\n\t\t\t\tresult = msg + \" \";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = messageWithTypeName(msg, className);\n\t\t\t\tdefaultMessage = false;\n\t\t\t}\n\t\t}\n\t\tif (defaultMessage) {\n\t\t\tresult = result + (\"Object of class [\" + className + \"] must be an instance of \" + type);\n\t\t}\n\t\tthrow new IllegalArgumentException(result);\n\t}\n\n\tprivate static void assignableCheckFailed(Class<?> superType, @Nullable Class<?> subType, @Nullable String msg) {\n\t\tString result = \"\";\n\t\tboolean defaultMessage = true;\n\t\tif (StringUtils.hasLength(msg)) {\n\t\t\tif (endsWithSeparator(msg)) {\n\t\t\t\tresult = msg + \" \";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = messageWithTypeName(msg, subType);\n\t\t\t\tdefaultMessage = false;\n\t\t\t}\n\t\t}\n\t\tif (defaultMessage) {\n\t\t\tresult = result + (subType + \" is not assignable to \" + superType);\n\t\t}\n\t\tthrow new IllegalArgumentException(result);\n\t}\n\n\tprivate static boolean endsWithSeparator(String msg) {\n\t\treturn (msg.endsWith(\":\") || msg.endsWith(\";\") || msg.endsWith(\",\") || msg.endsWith(\".\"));\n\t}\n\n\tprivate static String messageWithTypeName(String msg, @Nullable Object typeName) {\n\t\treturn msg + (msg.endsWith(\" \") ? \"\" : \": \") + typeName;\n\t}\n\n\tprivate static @Nullable String nullSafeGet(@Nullable Supplier<String> messageSupplier) {\n\t\treturn (messageSupplier != null ? messageSupplier.get() : null);\n\t}\n\n}"
  },
  "org.springframework.util.Assert#doesNotContain(textToSearch,substring,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the given text does not contain the given substring.\n\t * <pre class=\"code\">Assert.doesNotContain(name, \"rod\", \"Name must not contain 'rod'\");</pre>\n\t * @param textToSearch the text to search\n\t * @param substring the substring to find within the text\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the text contains the substring\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "textToSearch",
      "substring",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "void",
    "signature": "public void doesNotContain(@Nullable String textToSearch, String substring, String message)",
    "source_code": "\tpublic static void doesNotContain(@Nullable String textToSearch, String substring, String message) {\n\t\tif (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring) &&\n\t\t\t\ttextToSearch.contains(substring)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#doesNotContain(textToSearch,substring,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the given text does not contain the given substring.\n\t * <pre class=\"code\">\n\t * Assert.doesNotContain(name, forbidden, () -&gt; \"Name must not contain '\" + forbidden + \"'\");\n\t * </pre>\n\t * @param textToSearch the text to search\n\t * @param substring the substring to find within the text\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the text contains the substring\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "textToSearch",
      "substring",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "void",
    "signature": "public void doesNotContain(@Nullable String textToSearch, String substring, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void doesNotContain(@Nullable String textToSearch, String substring, Supplier<String> messageSupplier) {\n\t\tif (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring) &&\n\t\t\t\ttextToSearch.contains(substring)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#hasLength(text,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the given String is not empty; that is,\n\t * it must not be {@code null} and not the empty String.\n\t * <pre class=\"code\">Assert.hasLength(name, \"Name must not be empty\");</pre>\n\t * @param text the String to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the text is empty\n\t * @see StringUtils#hasLength\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "public void hasLength(@Nullable String text, String message)",
    "source_code": "\tpublic static void hasLength(@Nullable String text, String message) {\n\t\tif (!StringUtils.hasLength(text)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#hasLength(text,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the given String is not empty; that is,\n\t * it must not be {@code null} and not the empty String.\n\t * <pre class=\"code\">\n\t * Assert.hasLength(account.getName(),\n\t *     () -&gt; \"Name for account '\" + account.getId() + \"' must not be empty\");\n\t * </pre>\n\t * @param text the String to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the text is empty\n\t * @since 5.0\n\t * @see StringUtils#hasLength\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "void",
    "signature": "public void hasLength(@Nullable String text, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void hasLength(@Nullable String text, Supplier<String> messageSupplier) {\n\t\tif (!StringUtils.hasLength(text)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#hasText(text,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the given String contains valid text content; that is, it must not\n\t * be {@code null} and must contain at least one non-whitespace character.\n\t * <pre class=\"code\">Assert.hasText(name, \"'name' must not be empty\");</pre>\n\t * @param text the String to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the text does not contain valid text content\n\t * @see StringUtils#hasText\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "void",
    "signature": "public void hasText(@Nullable String text, String message)",
    "source_code": "\tpublic static void hasText(@Nullable String text, String message) {\n\t\tif (!StringUtils.hasText(text)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#hasText(text,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the given String contains valid text content; that is, it must not\n\t * be {@code null} and must contain at least one non-whitespace character.\n\t * <pre class=\"code\">\n\t * Assert.hasText(account.getName(),\n\t *     () -&gt; \"Name for account '\" + account.getId() + \"' must not be empty\");\n\t * </pre>\n\t * @param text the String to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the text does not contain valid text content\n\t * @since 5.0\n\t * @see StringUtils#hasText\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "void",
    "signature": "public void hasText(@Nullable String text, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void hasText(@Nullable String text, Supplier<String> messageSupplier) {\n\t\tif (!StringUtils.hasText(text)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#isAssignable(superType,subType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.\n\t * <pre class=\"code\">Assert.isAssignable(Number.class, myClass);</pre>\n\t * @param superType the supertype to check\n\t * @param subType the subtype to check\n\t * @throws IllegalArgumentException if the classes are not assignable\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "superType",
      "subType"
    ],
    "position": {
      "column": 1,
      "line": 598
    },
    "return": "void",
    "signature": "public void isAssignable(Class<?> superType, @Nullable Class<?> subType)",
    "source_code": "\tpublic static void isAssignable(Class<?> superType, @Nullable Class<?> subType) {\n\t\tisAssignable(superType, subType, \"\");\n\t}"
  },
  "org.springframework.util.Assert#isAssignable(superType,subType,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.\n\t * <pre class=\"code\">Assert.isAssignable(Number.class, myClass, \"Number expected\");</pre>\n\t * @param superType the supertype to check against\n\t * @param subType the subtype to check\n\t * @param message a message which will be prepended to provide further context.\n\t * If it is empty or ends in \":\" or \";\" or \",\" or \".\", a full exception message\n\t * will be appended. If it ends in a space, the name of the offending subtype\n\t * will be appended. In any other case, a \":\" with a space and the name of the\n\t * offending subtype will be appended.\n\t * @throws IllegalArgumentException if the classes are not assignable\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "superType",
      "subType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "void",
    "signature": "public void isAssignable(Class<?> superType, @Nullable Class<?> subType, String message)",
    "source_code": "\tpublic static void isAssignable(Class<?> superType, @Nullable Class<?> subType, String message) {\n\t\tnotNull(superType, \"Supertype to check against must not be null\");\n\t\tif (subType == null || !superType.isAssignableFrom(subType)) {\n\t\t\tassignableCheckFailed(superType, subType, message);\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#isAssignable(superType,subType,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.\n\t * <pre class=\"code\">\n\t * Assert.isAssignable(Number.class, myClass, () -&gt; \"Processing \" + myAttributeName + \":\");\n\t * </pre>\n\t * @param superType the supertype to check against\n\t * @param subType the subtype to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails. See {@link #isAssignable(Class, Class, String)} for details.\n\t * @throws IllegalArgumentException if the classes are not assignable\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "superType",
      "subType",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 583
    },
    "return": "void",
    "signature": "public void isAssignable(Class<?> superType, @Nullable Class<?> subType, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void isAssignable(Class<?> superType, @Nullable Class<?> subType, Supplier<String> messageSupplier) {\n\t\tnotNull(superType, \"Supertype to check against must not be null\");\n\t\tif (subType == null || !superType.isAssignableFrom(subType)) {\n\t\t\tassignableCheckFailed(superType, subType, nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#isInstanceOf(type,obj)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the provided object is an instance of the provided class.\n\t * <pre class=\"code\">Assert.instanceOf(Foo.class, foo);</pre>\n\t * @param type the type to check against\n\t * @param obj the object to check\n\t * @throws IllegalArgumentException if the object is not an instance of type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 546
    },
    "return": "void",
    "signature": "public void isInstanceOf(Class<?> type, @Nullable Object obj)",
    "source_code": "\tpublic static void isInstanceOf(Class<?> type, @Nullable Object obj) {\n\t\tisInstanceOf(type, obj, \"\");\n\t}"
  },
  "org.springframework.util.Assert#isInstanceOf(type,obj,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the provided object is an instance of the provided class.\n\t * <pre class=\"code\">Assert.instanceOf(Foo.class, foo, \"Foo expected\");</pre>\n\t * @param type the type to check against\n\t * @param obj the object to check\n\t * @param message a message which will be prepended to provide further context.\n\t * If it is empty or ends in \":\" or \";\" or \",\" or \".\", a full exception message\n\t * will be appended. If it ends in a space, the name of the offending object's\n\t * type will be appended. In any other case, a \":\" with a space and the name\n\t * of the offending object's type will be appended.\n\t * @throws IllegalArgumentException if the object is not an instance of type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "obj",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 511
    },
    "return": "void",
    "signature": "public void isInstanceOf(Class<?> type, @Nullable Object obj, String message)",
    "source_code": "\tpublic static void isInstanceOf(Class<?> type, @Nullable Object obj, String message) {\n\t\tnotNull(type, \"Type to check against must not be null\");\n\t\tif (!type.isInstance(obj)) {\n\t\t\tinstanceCheckFailed(type, obj, message);\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#isInstanceOf(type,obj,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the provided object is an instance of the provided class.\n\t * <pre class=\"code\">\n\t * Assert.instanceOf(Foo.class, foo, () -&gt; \"Processing \" + Foo.class.getSimpleName() + \":\");\n\t * </pre>\n\t * @param type the type to check against\n\t * @param obj the object to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails. See {@link #isInstanceOf(Class, Object, String)} for details.\n\t * @throws IllegalArgumentException if the object is not an instance of type\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "obj",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 531
    },
    "return": "void",
    "signature": "public void isInstanceOf(Class<?> type, @Nullable Object obj, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void isInstanceOf(Class<?> type, @Nullable Object obj, Supplier<String> messageSupplier) {\n\t\tnotNull(type, \"Type to check against must not be null\");\n\t\tif (!type.isInstance(obj)) {\n\t\t\tinstanceCheckFailed(type, obj, nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#isNull(object,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an object is {@code null}.\n\t * <pre class=\"code\">Assert.isNull(value, \"The value must be null\");</pre>\n\t * @param object the object to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the object is not {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void isNull(@Nullable Object object, String message)",
    "source_code": "\tpublic static void isNull(@Nullable Object object, String message) {\n\t\tif (object != null) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#isNull(object,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an object is {@code null}.\n\t * <pre class=\"code\">\n\t * Assert.isNull(value, () -&gt; \"The value '\" + value + \"' must be null\");\n\t * </pre>\n\t * @param object the object to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object is not {@code null}\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "void",
    "signature": "public void isNull(@Nullable Object object, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void isNull(@Nullable Object object, Supplier<String> messageSupplier) {\n\t\tif (object != null) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#isTrue(expression,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a boolean expression, throwing an {@code IllegalArgumentException}\n\t * if the expression evaluates to {@code false}.\n\t * <pre class=\"code\">Assert.isTrue(i &gt; 0, \"The value must be greater than zero\");</pre>\n\t * @param expression a boolean expression\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if {@code expression} is {@code false}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void isTrue(boolean expression, String message)",
    "source_code": "\tpublic static void isTrue(boolean expression, String message) {\n\t\tif (!expression) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#isTrue(expression,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a boolean expression, throwing an {@code IllegalArgumentException}\n\t * if the expression evaluates to {@code false}.\n\t * <pre class=\"code\">\n\t * Assert.isTrue(i &gt; 0, () -&gt; \"The value '\" + i + \"' must be greater than zero\");\n\t * </pre>\n\t * @param expression a boolean expression\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if {@code expression} is {@code false}\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void isTrue(boolean expression, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void isTrue(boolean expression, Supplier<String> messageSupplier) {\n\t\tif (!expression) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#noNullElements(array,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an array contains no {@code null} elements.\n\t * <p>Note: Does not complain if the array is empty!\n\t * <pre class=\"code\">Assert.noNullElements(array, \"The array must contain non-null elements\");</pre>\n\t * @param array the array to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the object array contains a {@code null} element\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "void",
    "signature": "public void noNullElements(Object @Nullable [] array, String message)",
    "source_code": "\tpublic static void noNullElements(Object @Nullable [] array, String message) {\n\t\tif (array != null) {\n\t\t\tfor (Object element : array) {\n\t\t\t\tif (element == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#noNullElements(array,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an array contains no {@code null} elements.\n\t * <p>Note: Does not complain if the array is empty!\n\t * <pre class=\"code\">\n\t * Assert.noNullElements(array, () -&gt; \"The \" + arrayType + \" array must contain non-null elements\");\n\t * </pre>\n\t * @param array the array to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object array contains a {@code null} element\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "void",
    "signature": "public void noNullElements(Object @Nullable [] array, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void noNullElements(Object @Nullable [] array, Supplier<String> messageSupplier) {\n\t\tif (array != null) {\n\t\t\tfor (Object element : array) {\n\t\t\t\tif (element == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#noNullElements(collection,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that a collection contains no {@code null} elements.\n\t * <p>Note: Does not complain if the collection is empty!\n\t * <pre class=\"code\">Assert.noNullElements(collection, \"Collection must contain non-null elements\");</pre>\n\t * @param collection the collection to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the collection contains a {@code null} element\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "void",
    "signature": "public void noNullElements(@Nullable Collection<?> collection, String message)",
    "source_code": "\tpublic static void noNullElements(@Nullable Collection<?> collection, String message) {\n\t\tif (collection != null) {\n\t\t\tfor (Object element : collection) {\n\t\t\t\tif (element == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#noNullElements(collection,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that a collection contains no {@code null} elements.\n\t * <p>Note: Does not complain if the collection is empty!\n\t * <pre class=\"code\">\n\t * Assert.noNullElements(collection, () -&gt; \"Collection \" + collectionName + \" must contain non-null elements\");\n\t * </pre>\n\t * @param collection the collection to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the collection contains a {@code null} element\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "void",
    "signature": "public void noNullElements(@Nullable Collection<?> collection, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void noNullElements(@Nullable Collection<?> collection, Supplier<String> messageSupplier) {\n\t\tif (collection != null) {\n\t\t\tfor (Object element : collection) {\n\t\t\t\tif (element == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#notEmpty(Map<?,map,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that a Map contains entries; that is, it must not be {@code null}\n\t * and must contain at least one entry.\n\t * <pre class=\"code\">Assert.notEmpty(map, \"Map must contain entries\");</pre>\n\t * @param map the map to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the map is {@code null} or contains no entries\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 473
    },
    "return": "void",
    "signature": "public void notEmpty(@Nullable Map<?, ?> map, String message)",
    "source_code": "\tpublic static void notEmpty(@Nullable Map<?, ?> map, String message) {\n\t\tif (CollectionUtils.isEmpty(map)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#notEmpty(Map<?,map,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that a Map contains entries; that is, it must not be {@code null}\n\t * and must contain at least one entry.\n\t * <pre class=\"code\">\n\t * Assert.notEmpty(map, () -&gt; \"The \" + mapType + \" map must contain entries\");\n\t * </pre>\n\t * @param map the map to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the map is {@code null} or contains no entries\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 492
    },
    "return": "void",
    "signature": "public void notEmpty(@Nullable Map<?, ?> map, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void notEmpty(@Nullable Map<?, ?> map, Supplier<String> messageSupplier) {\n\t\tif (CollectionUtils.isEmpty(map)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#notEmpty(array,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an array contains elements; that is, it must not be\n\t * {@code null} and must contain at least one element.\n\t * <pre class=\"code\">Assert.notEmpty(array, \"The array must contain elements\");</pre>\n\t * @param array the array to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the object array is {@code null} or contains no elements\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "void",
    "signature": "public void notEmpty(@Nullable Object @Nullable [] array, String message)",
    "source_code": "\tpublic static void notEmpty(@Nullable Object @Nullable [] array, String message) {\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#notEmpty(array,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an array contains elements; that is, it must not be\n\t * {@code null} and must contain at least one element.\n\t * <pre class=\"code\">\n\t * Assert.notEmpty(array, () -&gt; \"The \" + arrayType + \" array must contain elements\");\n\t * </pre>\n\t * @param array the array to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object array is {@code null} or contains no elements\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "void",
    "signature": "public void notEmpty(Object @Nullable [] array, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void notEmpty(Object @Nullable [] array, Supplier<String> messageSupplier) {\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#notEmpty(collection,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that a collection contains elements; that is, it must not be\n\t * {@code null} and must contain at least one element.\n\t * <pre class=\"code\">Assert.notEmpty(collection, \"Collection must contain elements\");</pre>\n\t * @param collection the collection to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the collection is {@code null} or\n\t * contains no elements\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "void",
    "signature": "public void notEmpty(@Nullable Collection<?> collection, String message)",
    "source_code": "\tpublic static void notEmpty(@Nullable Collection<?> collection, String message) {\n\t\tif (CollectionUtils.isEmpty(collection)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#notEmpty(collection,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that a collection contains elements; that is, it must not be\n\t * {@code null} and must contain at least one element.\n\t * <pre class=\"code\">\n\t * Assert.notEmpty(collection, () -&gt; \"The \" + collectionType + \" collection must contain elements\");\n\t * </pre>\n\t * @param collection the collection to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the collection is {@code null} or\n\t * contains no elements\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "void",
    "signature": "public void notEmpty(@Nullable Collection<?> collection, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void notEmpty(@Nullable Collection<?> collection, Supplier<String> messageSupplier) {\n\t\tif (CollectionUtils.isEmpty(collection)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#notNull(object,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an object is not {@code null}.\n\t * <pre class=\"code\">Assert.notNull(clazz, \"The class must not be null\");</pre>\n\t * @param object the object to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the object is {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "void",
    "signature": "public void notNull(@Nullable Object object, String message)",
    "source_code": "\tpublic static void notNull(@Nullable Object object, String message) {\n\t\tif (object == null) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#notNull(object,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an object is not {@code null}.\n\t * <pre class=\"code\">\n\t * Assert.notNull(entity.getId(),\n\t *     () -&gt; \"ID for entity \" + entity.getName() + \" must not be null\");\n\t * </pre>\n\t * @param object the object to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object is {@code null}\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "public void notNull(@Nullable Object object, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void notNull(@Nullable Object object, Supplier<String> messageSupplier) {\n\t\tif (object == null) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#state(expression,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a boolean expression, throwing an {@code IllegalStateException}\n\t * if the expression evaluates to {@code false}.\n\t * <p>Call {@link #isTrue} if you wish to throw an {@code IllegalArgumentException}\n\t * on an assertion failure.\n\t * <pre class=\"code\">Assert.state(id == null, \"The id property must not already be initialized\");</pre>\n\t * @param expression a boolean expression\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalStateException if {@code expression} is {@code false}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "void",
    "signature": "public void state(boolean expression, String message)",
    "source_code": "\tpublic static void state(boolean expression, String message) {\n\t\tif (!expression) {\n\t\t\tthrow new IllegalStateException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.Assert#state(expression,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a boolean expression, throwing an {@code IllegalStateException}\n\t * if the expression evaluates to {@code false}.\n\t * <p>Call {@link #isTrue} if you wish to throw an {@code IllegalArgumentException}\n\t * on an assertion failure.\n\t * <pre class=\"code\">\n\t * Assert.state(entity.getId() == null,\n\t *     () -&gt; \"ID for entity \" + entity.getName() + \" must not already be initialized\");\n\t * </pre>\n\t * @param expression a boolean expression\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalStateException if {@code expression} is {@code false}\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void state(boolean expression, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void state(boolean expression, Supplier<String> messageSupplier) {\n\t\tif (!expression) {\n\t\t\tthrow new IllegalStateException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.CGLIB_CLASS_SEPARATOR": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** The CGLIB class separator: {@code \"$$\"}. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "signature": "public String CGLIB_CLASS_SEPARATOR",
    "source_code": "\tpublic static final String CGLIB_CLASS_SEPARATOR = \"$$\";",
    "type": "String"
  },
  "org.springframework.util.CLASS_FILE_SUFFIX": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** The \".class\" file suffix. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "signature": "public String CLASS_FILE_SUFFIX",
    "source_code": "\tpublic static final String CLASS_FILE_SUFFIX = \".class\";",
    "type": "String"
  },
  "org.springframework.util.ClassUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Miscellaneous {@code java.lang.Class} utility methods.\n *\n * <p>Mainly for internal use within the framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @author Sebastien Deleuze\n * @author Sungbin Yang\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "signature": "public class ClassUtils",
    "source_code": "public abstract class ClassUtils {\n\n\t/** Suffix for array class names: {@code \"[]\"}. */\n\tpublic static final String ARRAY_SUFFIX = \"[]\";\n\n\t/** A reusable empty class array constant. */\n\tprivate static final Class<?>[] EMPTY_CLASS_ARRAY = {};\n\n\t/** The package separator character: {@code '.'}. */\n\tprivate static final char PACKAGE_SEPARATOR = '.';\n\n\t/** The path separator character: {@code '/'}. */\n\tprivate static final char PATH_SEPARATOR = '/';\n\n\t/** The nested class separator character: {@code '$'}. */\n\tprivate static final char NESTED_CLASS_SEPARATOR = '$';\n\n\t/** The CGLIB class separator: {@code \"$$\"}. */\n\tpublic static final String CGLIB_CLASS_SEPARATOR = \"$$\";\n\n\t/** The \".class\" file suffix. */\n\tpublic static final String CLASS_FILE_SUFFIX = \".class\";\n\n\t/** Precomputed value for the combination of private, static and final modifiers. */\n\tprivate static final int NON_OVERRIDABLE_MODIFIER = Modifier.PRIVATE | Modifier.STATIC | Modifier.FINAL;\n\n\t/** Precomputed value for the combination of public and protected modifiers. */\n\tprivate static final int OVERRIDABLE_MODIFIER = Modifier.PUBLIC | Modifier.PROTECTED;\n\n\n\t/**\n\t * Map with primitive wrapper type as key and corresponding primitive\n\t * type as value, for example: {@code Integer.class -> int.class}.\n\t */\n\tprivate static final Map<Class<?>, Class<?>> primitiveWrapperTypeMap = new IdentityHashMap<>(9);\n\n\t/**\n\t * Map with primitive type as key and corresponding wrapper\n\t * type as value, for example: {@code int.class -> Integer.class}.\n\t */\n\tprivate static final Map<Class<?>, Class<?>> primitiveTypeToWrapperMap = new IdentityHashMap<>(9);\n\n\t/**\n\t * Map with primitive type name as key and corresponding primitive\n\t * type as value, for example: {@code \"int\" -> int.class}.\n\t */\n\tprivate static final Map<String, Class<?>> primitiveTypeNameMap = new HashMap<>(32);\n\n\t/**\n\t * Map with common Java language class name as key and corresponding Class as value.\n\t * Primarily for efficient deserialization of remote invocations.\n\t */\n\tprivate static final Map<String, Class<?>> commonClassCache = new HashMap<>(64);\n\n\t/**\n\t * Common Java language interfaces which are supposed to be ignored\n\t * when searching for 'primary' user-level interfaces.\n\t */\n\tprivate static final Set<Class<?>> javaLanguageInterfaces;\n\n\t/**\n\t * Cache for equivalent methods on a interface implemented by the declaring class.\n\t * <p>A {@code null} value signals that no interface method was found for the key.\n\t */\n\tprivate static final Map<Method, Method> interfaceMethodCache = new ConcurrentReferenceHashMap<>(256);\n\n\t/**\n\t * Cache for equivalent methods on a public interface implemented by the declaring class.\n\t * <p>A {@code null} value signals that no public interface method was found for the key.\n\t * @since 6.2\n\t */\n\tprivate static final Map<Method, Method> publicInterfaceMethodCache = new ConcurrentReferenceHashMap<>(256);\n\n\t/**\n\t * Cache for equivalent public methods in a public declaring type within the type hierarchy\n\t * of the method's declaring class.\n\t * <p>A {@code null} value signals that no publicly accessible method was found for the key.\n\t * @since 6.2\n\t */\n\tprivate static final Map<Method, Method> publiclyAccessibleMethodCache = new ConcurrentReferenceHashMap<>(256);\n\n\n\tstatic {\n\t\tprimitiveWrapperTypeMap.put(Boolean.class, boolean.class);\n\t\tprimitiveWrapperTypeMap.put(Byte.class, byte.class);\n\t\tprimitiveWrapperTypeMap.put(Character.class, char.class);\n\t\tprimitiveWrapperTypeMap.put(Double.class, double.class);\n\t\tprimitiveWrapperTypeMap.put(Float.class, float.class);\n\t\tprimitiveWrapperTypeMap.put(Integer.class, int.class);\n\t\tprimitiveWrapperTypeMap.put(Long.class, long.class);\n\t\tprimitiveWrapperTypeMap.put(Short.class, short.class);\n\t\tprimitiveWrapperTypeMap.put(Void.class, void.class);\n\n\t\t// Map entry iteration is less expensive to initialize than forEach with lambdas\n\t\tfor (Map.Entry<Class<?>, Class<?>> entry : primitiveWrapperTypeMap.entrySet()) {\n\t\t\tprimitiveTypeToWrapperMap.put(entry.getValue(), entry.getKey());\n\t\t\tregisterCommonClasses(entry.getKey());\n\t\t}\n\n\t\tSet<Class<?>> primitiveTypes = new HashSet<>(32);\n\t\tprimitiveTypes.addAll(primitiveWrapperTypeMap.values());\n\t\tCollections.addAll(primitiveTypes, boolean[].class, byte[].class, char[].class,\n\t\t\t\tdouble[].class, float[].class, int[].class, long[].class, short[].class);\n\t\tfor (Class<?> primitiveType : primitiveTypes) {\n\t\t\tprimitiveTypeNameMap.put(primitiveType.getName(), primitiveType);\n\t\t}\n\n\t\tregisterCommonClasses(Boolean[].class, Byte[].class, Character[].class, Double[].class,\n\t\t\t\tFloat[].class, Integer[].class, Long[].class, Short[].class);\n\t\tregisterCommonClasses(Number.class, Number[].class, String.class, String[].class,\n\t\t\t\tClass.class, Class[].class, Object.class, Object[].class);\n\t\tregisterCommonClasses(Throwable.class, Exception.class, RuntimeException.class,\n\t\t\t\tError.class, StackTraceElement.class, StackTraceElement[].class);\n\t\tregisterCommonClasses(Enum.class, Iterable.class, Iterator.class, Enumeration.class,\n\t\t\t\tCollection.class, List.class, Set.class, Map.class, Map.Entry.class, Optional.class);\n\n\t\tClass<?>[] javaLanguageInterfaceArray = {Serializable.class, Externalizable.class,\n\t\t\t\tCloseable.class, AutoCloseable.class, Cloneable.class, Comparable.class};\n\t\tregisterCommonClasses(javaLanguageInterfaceArray);\n\t\tjavaLanguageInterfaces = Set.of(javaLanguageInterfaceArray);\n\t}\n\n\n\t/**\n\t * Register the given common classes with the ClassUtils cache.\n\t */\n\tprivate static void registerCommonClasses(Class<?>... commonClasses) {\n\t\tfor (Class<?> clazz : commonClasses) {\n\t\t\tcommonClassCache.put(clazz.getName(), clazz);\n\t\t}\n\t}\n\n\t/**\n\t * Return the default ClassLoader to use: typically the thread context\n\t * ClassLoader, if available; the ClassLoader that loaded the ClassUtils\n\t * class will be used as fallback.\n\t * <p>Call this method if you intend to use the thread context ClassLoader\n\t * in a scenario where you clearly prefer a non-null ClassLoader reference:\n\t * for example, for class path resource loading (but not necessarily for\n\t * {@code Class.forName}, which accepts a {@code null} ClassLoader\n\t * reference as well).\n\t * @return the default ClassLoader (only {@code null} if even the system\n\t * ClassLoader isn't accessible)\n\t * @see Thread#getContextClassLoader()\n\t * @see ClassLoader#getSystemClassLoader()\n\t */\n\tpublic static @Nullable ClassLoader getDefaultClassLoader() {\n\t\tClassLoader cl = null;\n\t\ttry {\n\t\t\tcl = Thread.currentThread().getContextClassLoader();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// Cannot access thread context ClassLoader - falling back...\n\t\t}\n\t\tif (cl == null) {\n\t\t\t// No thread context class loader -> use class loader of this class.\n\t\t\tcl = ClassUtils.class.getClassLoader();\n\t\t\tif (cl == null) {\n\t\t\t\t// getClassLoader() returning null indicates the bootstrap ClassLoader\n\t\t\t\ttry {\n\t\t\t\t\tcl = ClassLoader.getSystemClassLoader();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t// Cannot access system ClassLoader - oh well, maybe the caller can live with null...\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cl;\n\t}\n\n\t/**\n\t * Override the thread context ClassLoader with the environment's bean ClassLoader\n\t * if necessary, i.e. if the bean ClassLoader is not equivalent to the thread\n\t * context ClassLoader already.\n\t * @param classLoaderToUse the actual ClassLoader to use for the thread context\n\t * @return the original thread context ClassLoader, or {@code null} if not overridden\n\t */\n\tpublic static @Nullable ClassLoader overrideThreadContextClassLoader(@Nullable ClassLoader classLoaderToUse) {\n\t\tThread currentThread = Thread.currentThread();\n\t\tClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\n\t\tif (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {\n\t\t\tcurrentThread.setContextClassLoader(classLoaderToUse);\n\t\t\treturn threadContextClassLoader;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Replacement for {@code Class.forName()} that also returns Class instances\n\t * for primitives (for example, \"int\") and array class names (for example, \"String[]\").\n\t * Furthermore, it is also capable of resolving nested class names in Java source\n\t * style (for example, \"java.lang.Thread.State\" instead of \"java.lang.Thread$State\").\n\t * @param name the name of the Class\n\t * @param classLoader the class loader to use\n\t * (can be {@code null}, which indicates the default class loader)\n\t * @return a class instance for the supplied name\n\t * @throws ClassNotFoundException if the class was not found\n\t * @throws LinkageError if the class file could not be loaded\n\t * @see Class#forName(String, boolean, ClassLoader)\n\t */\n\tpublic static Class<?> forName(String name, @Nullable ClassLoader classLoader)\n\t\t\tthrows ClassNotFoundException, LinkageError {\n\n\t\tAssert.notNull(name, \"Name must not be null\");\n\n\t\tClass<?> clazz = resolvePrimitiveClassName(name);\n\t\tif (clazz == null) {\n\t\t\tclazz = commonClassCache.get(name);\n\t\t}\n\t\tif (clazz != null) {\n\t\t\treturn clazz;\n\t\t}\n\n\t\t// \"java.lang.String[]\" style arrays\n\t\tif (name.endsWith(ARRAY_SUFFIX)) {\n\t\t\tString elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());\n\t\t\tClass<?> elementClass = forName(elementClassName, classLoader);\n\t\t\treturn elementClass.arrayType();\n\t\t}\n\n\t\tClassLoader clToUse = classLoader;\n\t\tif (clToUse == null) {\n\t\t\tclToUse = getDefaultClassLoader();\n\t\t}\n\t\ttry {\n\t\t\treturn Class.forName(name, false, clToUse);\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\tint lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);\n\t\t\tint previousDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR, lastDotIndex - 1);\n\t\t\tif (lastDotIndex != -1 && previousDotIndex != -1 && Character.isUpperCase(name.charAt(previousDotIndex + 1))) {\n\t\t\t\tString nestedClassName =\n\t\t\t\t\t\tname.substring(0, lastDotIndex) + NESTED_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);\n\t\t\t\ttry {\n\t\t\t\t\treturn Class.forName(nestedClassName, false, clToUse);\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex2) {\n\t\t\t\t\t// Swallow - let original exception get through\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\t/**\n\t * Resolve the given class name into a Class instance. Supports\n\t * primitives (like \"int\") and array class names (like \"String[]\").\n\t * <p>This is effectively equivalent to the {@code forName}\n\t * method with the same arguments, with the only difference being\n\t * the exceptions thrown in case of class loading failure.\n\t * @param className the name of the Class\n\t * @param classLoader the class loader to use\n\t * (can be {@code null}, which indicates the default class loader)\n\t * @return a class instance for the supplied name\n\t * @throws IllegalArgumentException if the class name was not resolvable\n\t * (that is, the class could not be found or the class file could not be loaded)\n\t * @throws IllegalStateException if the corresponding class is resolvable but there\n\t * was a readability mismatch in the inheritance hierarchy of the class (typically a\n\t * missing dependency declaration in a Java Module System module definition for a\n\t * superclass or interface implemented by the class to be loaded here)\n\t * @see #forName(String, ClassLoader)\n\t */\n\tpublic static Class<?> resolveClassName(String className, @Nullable ClassLoader classLoader)\n\t\t\tthrows IllegalArgumentException {\n\n\t\ttry {\n\t\t\treturn forName(className, classLoader);\n\t\t}\n\t\tcatch (IllegalAccessError err) {\n\t\t\tthrow new IllegalStateException(\"Readability mismatch in inheritance hierarchy of class [\" +\n\t\t\t\t\tclassName + \"]: \" + err.getMessage(), err);\n\t\t}\n\t\tcatch (LinkageError err) {\n\t\t\tthrow new IllegalArgumentException(\"Unresolvable class definition for class [\" + className + \"]\", err);\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Could not find class [\" + className + \"]\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether the {@link Class} identified by the supplied name is present\n\t * and can be loaded. Will return {@code false} if either the class or\n\t * one of its dependencies is not present or cannot be loaded.\n\t * @param className the name of the class to check\n\t * @param classLoader the class loader to use\n\t * (can be {@code null} which indicates the default class loader)\n\t * @return whether the specified class is present (including all of its\n\t * superclasses and interfaces)\n\t * @throws IllegalStateException if the corresponding class is resolvable but there\n\t * was a readability mismatch in the inheritance hierarchy of the class (typically a\n\t * missing dependency declaration in a Java Module System module definition for a\n\t * superclass or interface implemented by the class to be checked here)\n\t */\n\tpublic static boolean isPresent(String className, @Nullable ClassLoader classLoader) {\n\t\ttry {\n\t\t\tforName(className, classLoader);\n\t\t\treturn true;\n\t\t}\n\t\tcatch (IllegalAccessError err) {\n\t\t\tthrow new IllegalStateException(\"Readability mismatch in inheritance hierarchy of class [\" +\n\t\t\t\t\tclassName + \"]: \" + err.getMessage(), err);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// Typically ClassNotFoundException or NoClassDefFoundError...\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Check whether the given class is visible in the given ClassLoader.\n\t * @param clazz the class to check (typically an interface)\n\t * @param classLoader the ClassLoader to check against\n\t * (can be {@code null} in which case this method will always return {@code true})\n\t */\n\tpublic static boolean isVisible(Class<?> clazz, @Nullable ClassLoader classLoader) {\n\t\tif (classLoader == null) {\n\t\t\treturn true;\n\t\t}\n\t\ttry {\n\t\t\tif (clazz.getClassLoader() == classLoader) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (SecurityException ex) {\n\t\t\t// Fall through to loadable check below\n\t\t}\n\n\t\t// Visible if same Class can be loaded from given ClassLoader\n\t\treturn isLoadable(clazz, classLoader);\n\t}\n\n\t/**\n\t * Check whether the given class is cache-safe in the given context,\n\t * i.e. whether it is loaded by the given ClassLoader or a parent of it.\n\t * @param clazz the class to analyze\n\t * @param classLoader the ClassLoader to potentially cache metadata in\n\t * (can be {@code null} which indicates the system class loader)\n\t */\n\tpublic static boolean isCacheSafe(Class<?> clazz, @Nullable ClassLoader classLoader) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\ttry {\n\t\t\tClassLoader target = clazz.getClassLoader();\n\t\t\t// Common cases\n\t\t\tif (target == classLoader || target == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (classLoader == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// Check for match in ancestors -> positive\n\t\t\tClassLoader current = classLoader;\n\t\t\twhile (current != null) {\n\t\t\t\tcurrent = current.getParent();\n\t\t\t\tif (current == target) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check for match in children -> negative\n\t\t\twhile (target != null) {\n\t\t\t\ttarget = target.getParent();\n\t\t\t\tif (target == classLoader) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (SecurityException ex) {\n\t\t\t// Fall through to loadable check below\n\t\t}\n\n\t\t// Fallback for ClassLoaders without parent/child relationship:\n\t\t// safe if same Class can be loaded from given ClassLoader\n\t\treturn (classLoader != null && isLoadable(clazz, classLoader));\n\t}\n\n\t/**\n\t * Check whether the given class is loadable in the given ClassLoader.\n\t * @param clazz the class to check (typically an interface)\n\t * @param classLoader the ClassLoader to check against\n\t * @since 5.0.6\n\t */\n\tprivate static boolean isLoadable(Class<?> clazz, ClassLoader classLoader) {\n\t\ttry {\n\t\t\treturn (clazz == classLoader.loadClass(clazz.getName()));\n\t\t\t// Else: different class with same name found\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t// No corresponding class found at all\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Resolve the given class name as primitive class, if appropriate,\n\t * according to the JVM's naming rules for primitive classes.\n\t * <p>Also supports the JVM's internal class names for primitive arrays.\n\t * Does <i>not</i> support the \"[]\" suffix notation for primitive arrays;\n\t * this is only supported by {@link #forName(String, ClassLoader)}.\n\t * @param name the name of the potentially primitive class\n\t * @return the primitive class, or {@code null} if the name does not denote\n\t * a primitive class or primitive array class\n\t */\n\tpublic static @Nullable Class<?> resolvePrimitiveClassName(@Nullable String name) {\n\t\tClass<?> result = null;\n\t\t// Most class names will be quite long, considering that they\n\t\t// SHOULD sit in a package, so a length check is worthwhile.\n\t\tif (name != null && name.length() <= 7) {\n\t\t\t// Could be a primitive - likely.\n\t\t\tresult = primitiveTypeNameMap.get(name);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Check if the given class represents a primitive wrapper,\n\t * i.e. Boolean, Byte, Character, Short, Integer, Long, Float, Double, or\n\t * Void.\n\t * @param clazz the class to check\n\t * @return whether the given class is a primitive wrapper class\n\t */\n\tpublic static boolean isPrimitiveWrapper(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\treturn primitiveWrapperTypeMap.containsKey(clazz);\n\t}\n\n\t/**\n\t * Check if the given class represents a primitive (i.e. boolean, byte,\n\t * char, short, int, long, float, or double), {@code void}, or a wrapper for\n\t * those types (i.e. Boolean, Byte, Character, Short, Integer, Long, Float,\n\t * Double, or Void).\n\t * @param clazz the class to check\n\t * @return {@code true} if the given class represents a primitive, void, or\n\t * a wrapper class\n\t */\n\tpublic static boolean isPrimitiveOrWrapper(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\treturn (clazz.isPrimitive() || isPrimitiveWrapper(clazz));\n\t}\n\n\t/**\n\t * Check if the given class represents an array of primitives,\n\t * i.e. boolean, byte, char, short, int, long, float, or double.\n\t * @param clazz the class to check\n\t * @return whether the given class is a primitive array class\n\t */\n\tpublic static boolean isPrimitiveArray(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\treturn (clazz.isArray() && clazz.componentType().isPrimitive());\n\t}\n\n\t/**\n\t * Check if the given class represents an array of primitive wrappers,\n\t * i.e. Boolean, Byte, Character, Short, Integer, Long, Float, or Double.\n\t * @param clazz the class to check\n\t * @return whether the given class is a primitive wrapper array class\n\t */\n\tpublic static boolean isPrimitiveWrapperArray(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\treturn (clazz.isArray() && isPrimitiveWrapper(clazz.componentType()));\n\t}\n\n\t/**\n\t * Resolve the given class if it is a primitive class,\n\t * returning the corresponding primitive wrapper type instead.\n\t * @param clazz the class to check\n\t * @return the original class, or a primitive wrapper for the original primitive type\n\t */\n\t@SuppressWarnings(\"NullAway\") // Dataflow analysis limitation\n\tpublic static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\treturn (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);\n\t}\n\n\t/**\n\t * Determine if the given type represents either {@code Void} or {@code void}.\n\t * @param type the type to check\n\t * @return {@code true} if the type represents {@code Void} or {@code void}\n\t * @since 6.1.4\n\t * @see Void\n\t * @see Void#TYPE\n\t */\n\tpublic static boolean isVoidType(@Nullable Class<?> type) {\n\t\treturn (type == void.class || type == Void.class);\n\t}\n\n\t/**\n\t * Delegate for {@link org.springframework.beans.BeanUtils#isSimpleValueType}.\n\t * Also used by {@link ObjectUtils#nullSafeConciseToString}.\n\t * <p>Check if the given type represents a common \"simple\" value type:\n\t * primitive or primitive wrapper, {@link Enum}, {@link String} or other\n\t * {@link CharSequence}, {@link Number}, {@link Date}, {@link Temporal},\n\t * {@link ZoneId}, {@link TimeZone}, {@link File}, {@link Path}, {@link URI},\n\t * {@link URL}, {@link InetAddress}, {@link Charset}, {@link Currency},\n\t * {@link Locale}, {@link UUID}, {@link Pattern}, or {@link Class}.\n\t * <p>{@code Void} and {@code void} are not considered simple value types.\n\t * @param type the type to check\n\t * @return whether the given type represents a \"simple\" value type,\n\t * suggesting value-based data binding and {@code toString} output\n\t * @since 6.1\n\t */\n\tpublic static boolean isSimpleValueType(Class<?> type) {\n\t\treturn (!isVoidType(type) &&\n\t\t\t\t(isPrimitiveOrWrapper(type) ||\n\t\t\t\tEnum.class.isAssignableFrom(type) ||\n\t\t\t\tCharSequence.class.isAssignableFrom(type) ||\n\t\t\t\tNumber.class.isAssignableFrom(type) ||\n\t\t\t\tDate.class.isAssignableFrom(type) ||\n\t\t\t\tTemporal.class.isAssignableFrom(type) ||\n\t\t\t\tZoneId.class.isAssignableFrom(type) ||\n\t\t\t\tTimeZone.class.isAssignableFrom(type) ||\n\t\t\t\tFile.class.isAssignableFrom(type) ||\n\t\t\t\tPath.class.isAssignableFrom(type) ||\n\t\t\t\tCharset.class.isAssignableFrom(type) ||\n\t\t\t\tCurrency.class.isAssignableFrom(type) ||\n\t\t\t\tInetAddress.class.isAssignableFrom(type) ||\n\t\t\t\tURI.class == type ||\n\t\t\t\tURL.class == type ||\n\t\t\t\tUUID.class == type ||\n\t\t\t\tLocale.class == type ||\n\t\t\t\tPattern.class == type ||\n\t\t\t\tClass.class == type));\n\t}\n\n\t/**\n\t * Check if the right-hand side type may be assigned to the left-hand side\n\t * type, assuming setting by reflection. Considers primitive wrapper\n\t * classes as assignable to the corresponding primitive types.\n\t * @param lhsType the target type (left-hand side (LHS) type)\n\t * @param rhsType the value type (right-hand side (RHS) type) that should\n\t * be assigned to the target type\n\t * @return {@code true} if {@code rhsType} is assignable to {@code lhsType}\n\t * @see TypeUtils#isAssignable(java.lang.reflect.Type, java.lang.reflect.Type)\n\t */\n\tpublic static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {\n\t\tAssert.notNull(lhsType, \"Left-hand side type must not be null\");\n\t\tAssert.notNull(rhsType, \"Right-hand side type must not be null\");\n\t\tif (lhsType.isAssignableFrom(rhsType)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (lhsType.isPrimitive()) {\n\t\t\tClass<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);\n\t\t\treturn (lhsType == resolvedPrimitive);\n\t\t}\n\t\telse {\n\t\t\tClass<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);\n\t\t\treturn (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper));\n\t\t}\n\t}\n\n\t/**\n\t * Determine if the given type is assignable from the given value,\n\t * assuming setting by reflection. Considers primitive wrapper classes\n\t * as assignable to the corresponding primitive types.\n\t * @param type the target type\n\t * @param value the value that should be assigned to the type\n\t * @return if the type is assignable from the value\n\t */\n\tpublic static boolean isAssignableValue(Class<?> type, @Nullable Object value) {\n\t\tAssert.notNull(type, \"Type must not be null\");\n\t\treturn (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());\n\t}\n\n\t/**\n\t * Convert a \"/\"-based resource path to a \".\"-based fully qualified class name.\n\t * @param resourcePath the resource path pointing to a class\n\t * @return the corresponding fully qualified class name\n\t */\n\tpublic static String convertResourcePathToClassName(String resourcePath) {\n\t\tAssert.notNull(resourcePath, \"Resource path must not be null\");\n\t\treturn resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);\n\t}\n\n\t/**\n\t * Convert a \".\"-based fully qualified class name to a \"/\"-based resource path.\n\t * @param className the fully qualified class name\n\t * @return the corresponding resource path, pointing to the class\n\t */\n\tpublic static String convertClassNameToResourcePath(String className) {\n\t\tAssert.notNull(className, \"Class name must not be null\");\n\t\treturn className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n\t}\n\n\t/**\n\t * Return a path suitable for use with {@code ClassLoader.getResource}\n\t * (also suitable for use with {@code Class.getResource} by prepending a\n\t * slash ('/') to the return value). Built by taking the package of the specified\n\t * class file, converting all dots ('.') to slashes ('/'), adding a trailing slash\n\t * if necessary, and concatenating the specified resource name to this.\n\t * <br/>As such, this function may be used to build a path suitable for\n\t * loading a resource file that is in the same package as a class file,\n\t * although {@link org.springframework.core.io.ClassPathResource} is usually\n\t * even more convenient.\n\t * @param clazz the Class whose package will be used as the base\n\t * @param resourceName the resource name to append. A leading slash is optional.\n\t * @return the built-up resource path\n\t * @see ClassLoader#getResource\n\t * @see Class#getResource\n\t */\n\tpublic static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {\n\t\tAssert.notNull(resourceName, \"Resource name must not be null\");\n\t\tif (!resourceName.startsWith(\"/\")) {\n\t\t\treturn classPackageAsResourcePath(clazz) + PATH_SEPARATOR + resourceName;\n\t\t}\n\t\treturn classPackageAsResourcePath(clazz) + resourceName;\n\t}\n\n\t/**\n\t * Given an input class object, return a string which consists of the\n\t * class's package name as a pathname, i.e., all dots ('.') are replaced by\n\t * slashes ('/'). Neither a leading nor trailing slash is added. The result\n\t * could be concatenated with a slash and the name of a resource and fed\n\t * directly to {@code ClassLoader.getResource()}. For it to be fed to\n\t * {@code Class.getResource} instead, a leading slash would also have\n\t * to be prepended to the returned value.\n\t * @param clazz the input class. A {@code null} value or the default\n\t * (empty) package will result in an empty string (\"\") being returned.\n\t * @return a path which represents the package name\n\t * @see ClassLoader#getResource\n\t * @see Class#getResource\n\t */\n\tpublic static String classPackageAsResourcePath(@Nullable Class<?> clazz) {\n\t\tif (clazz == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tString className = clazz.getName();\n\t\tint packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n\t\tif (packageEndIndex == -1) {\n\t\t\treturn \"\";\n\t\t}\n\t\tString packageName = className.substring(0, packageEndIndex);\n\t\treturn packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n\t}\n\n\t/**\n\t * Build a String that consists of the names of the classes/interfaces\n\t * in the given array.\n\t * <p>Basically like {@code AbstractCollection.toString()}, but stripping\n\t * the \"class \"/\"interface \" prefix before every class name.\n\t * @param classes an array of Class objects\n\t * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n\t * @see java.util.AbstractCollection#toString()\n\t */\n\tpublic static String classNamesToString(Class<?>... classes) {\n\t\treturn classNamesToString(Arrays.asList(classes));\n\t}\n\n\t/**\n\t * Build a String that consists of the names of the classes/interfaces\n\t * in the given collection.\n\t * <p>Basically like {@code AbstractCollection.toString()}, but stripping\n\t * the \"class \"/\"interface \" prefix before every class name.\n\t * @param classes a Collection of Class objects (can be {@code null})\n\t * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n\t * @see java.util.AbstractCollection#toString()\n\t */\n\tpublic static String classNamesToString(@Nullable Collection<Class<?>> classes) {\n\t\tif (CollectionUtils.isEmpty(classes)) {\n\t\t\treturn \"[]\";\n\t\t}\n\t\tStringJoiner stringJoiner = new StringJoiner(\", \", \"[\", \"]\");\n\t\tfor (Class<?> clazz : classes) {\n\t\t\tstringJoiner.add(clazz.getName());\n\t\t}\n\t\treturn stringJoiner.toString();\n\t}\n\n\t/**\n\t * Copy the given {@code Collection} into a {@code Class} array.\n\t * <p>The {@code Collection} must contain {@code Class} elements only.\n\t * @param collection the {@code Collection} to copy\n\t * @return the {@code Class} array\n\t * @since 3.1\n\t * @see StringUtils#toStringArray\n\t */\n\tpublic static Class<?>[] toClassArray(@Nullable Collection<Class<?>> collection) {\n\t\treturn (!CollectionUtils.isEmpty(collection) ? collection.toArray(EMPTY_CLASS_ARRAY) : EMPTY_CLASS_ARRAY);\n\t}\n\n\t/**\n\t * Return all interfaces that the given instance implements as an array,\n\t * including ones implemented by superclasses.\n\t * @param instance the instance to analyze for interfaces\n\t * @return all interfaces that the given instance implements as an array\n\t */\n\tpublic static Class<?>[] getAllInterfaces(Object instance) {\n\t\tAssert.notNull(instance, \"Instance must not be null\");\n\t\treturn getAllInterfacesForClass(instance.getClass());\n\t}\n\n\t/**\n\t * Return all interfaces that the given class implements as an array,\n\t * including ones implemented by superclasses.\n\t * <p>If the class itself is an interface, it gets returned as sole interface.\n\t * @param clazz the class to analyze for interfaces\n\t * @return all interfaces that the given object implements as an array\n\t */\n\tpublic static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {\n\t\treturn getAllInterfacesForClass(clazz, null);\n\t}\n\n\t/**\n\t * Return all interfaces that the given class implements as an array,\n\t * including ones implemented by superclasses.\n\t * <p>If the class itself is an interface, it gets returned as sole interface.\n\t * @param clazz the class to analyze for interfaces\n\t * @param classLoader the ClassLoader that the interfaces need to be visible in\n\t * (can be {@code null} when accepting all declared interfaces)\n\t * @return all interfaces that the given object implements as an array\n\t */\n\tpublic static Class<?>[] getAllInterfacesForClass(Class<?> clazz, @Nullable ClassLoader classLoader) {\n\t\treturn toClassArray(getAllInterfacesForClassAsSet(clazz, classLoader));\n\t}\n\n\t/**\n\t * Return all interfaces that the given instance implements as a Set,\n\t * including ones implemented by superclasses.\n\t * @param instance the instance to analyze for interfaces\n\t * @return all interfaces that the given instance implements as a Set\n\t */\n\tpublic static Set<Class<?>> getAllInterfacesAsSet(Object instance) {\n\t\tAssert.notNull(instance, \"Instance must not be null\");\n\t\treturn getAllInterfacesForClassAsSet(instance.getClass());\n\t}\n\n\t/**\n\t * Return all interfaces that the given class implements as a Set,\n\t * including ones implemented by superclasses.\n\t * <p>If the class itself is an interface, it gets returned as sole interface.\n\t * @param clazz the class to analyze for interfaces\n\t * @return all interfaces that the given object implements as a Set\n\t */\n\tpublic static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz) {\n\t\treturn getAllInterfacesForClassAsSet(clazz, null);\n\t}\n\n\t/**\n\t * Return all interfaces that the given class implements as a Set,\n\t * including ones implemented by superclasses.\n\t * <p>If the class itself is an interface, it gets returned as sole interface.\n\t * @param clazz the class to analyze for interfaces\n\t * @param classLoader the ClassLoader that the interfaces need to be visible in\n\t * (can be {@code null} when accepting all declared interfaces)\n\t * @return all interfaces that the given object implements as a Set\n\t */\n\tpublic static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, @Nullable ClassLoader classLoader) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tif (clazz.isInterface() && isVisible(clazz, classLoader)) {\n\t\t\treturn Collections.singleton(clazz);\n\t\t}\n\t\tSet<Class<?>> interfaces = new LinkedHashSet<>();\n\t\tClass<?> current = clazz;\n\t\twhile (current != null) {\n\t\t\tClass<?>[] ifcs = current.getInterfaces();\n\t\t\tfor (Class<?> ifc : ifcs) {\n\t\t\t\tif (isVisible(ifc, classLoader)) {\n\t\t\t\t\tinterfaces.add(ifc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.getSuperclass();\n\t\t}\n\t\treturn interfaces;\n\t}\n\n\t/**\n\t * Create a composite interface Class for the given interfaces,\n\t * implementing the given interfaces in one single Class.\n\t * <p>This implementation builds a JDK proxy class for the given interfaces.\n\t * @param interfaces the interfaces to merge\n\t * @param classLoader the ClassLoader to create the composite Class in\n\t * @return the merged interface as Class\n\t * @throws IllegalArgumentException if the specified interfaces expose\n\t * conflicting method signatures (or a similar constraint is violated)\n\t * @see java.lang.reflect.Proxy#getProxyClass\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static Class<?> createCompositeInterface(Class<?>[] interfaces, @Nullable ClassLoader classLoader) {\n\t\tAssert.notEmpty(interfaces, \"Interface array must not be empty\");\n\t\treturn Proxy.getProxyClass(classLoader, interfaces);\n\t}\n\n\t/**\n\t * Determine the common ancestor of the given classes, if any.\n\t * @param clazz1 the class to introspect\n\t * @param clazz2 the other class to introspect\n\t * @return the common ancestor (i.e. common superclass, one interface\n\t * extending the other), or {@code null} if none found. If any of the\n\t * given classes is {@code null}, the other class will be returned.\n\t * @since 3.2.6\n\t */\n\tpublic static @Nullable Class<?> determineCommonAncestor(@Nullable Class<?> clazz1, @Nullable Class<?> clazz2) {\n\t\tif (clazz1 == null) {\n\t\t\treturn clazz2;\n\t\t}\n\t\tif (clazz2 == null) {\n\t\t\treturn clazz1;\n\t\t}\n\t\tif (clazz1.isAssignableFrom(clazz2)) {\n\t\t\treturn clazz1;\n\t\t}\n\t\tif (clazz2.isAssignableFrom(clazz1)) {\n\t\t\treturn clazz2;\n\t\t}\n\t\tClass<?> ancestor = clazz1;\n\t\tdo {\n\t\t\tancestor = ancestor.getSuperclass();\n\t\t\tif (ancestor == null || Object.class == ancestor) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\twhile (!ancestor.isAssignableFrom(clazz2));\n\t\treturn ancestor;\n\t}\n\n\t/**\n\t * Determine whether the given interface is a common Java language interface:\n\t * {@link Serializable}, {@link Externalizable}, {@link Closeable}, {@link AutoCloseable},\n\t * {@link Cloneable}, {@link Comparable} - all of which can be ignored when looking\n\t * for 'primary' user-level interfaces. Common characteristics: no service-level\n\t * operations, no bean property methods, no default methods.\n\t * @param ifc the interface to check\n\t * @since 5.0.3\n\t */\n\tpublic static boolean isJavaLanguageInterface(Class<?> ifc) {\n\t\treturn javaLanguageInterfaces.contains(ifc);\n\t}\n\n\t/**\n\t * Determine if the supplied class is a static class.\n\t * @return {@code true} if the supplied class is a static class\n\t * @since 6.0\n\t * @see Modifier#isStatic(int)\n\t * @see #isInnerClass(Class)\n\t */\n\tpublic static boolean isStaticClass(Class<?> clazz) {\n\t\treturn Modifier.isStatic(clazz.getModifiers());\n\t}\n\n\t/**\n\t * Determine if the supplied class is an <em>inner class</em>,\n\t * i.e. a non-static member of an enclosing class.\n\t * @return {@code true} if the supplied class is an inner class\n\t * @since 5.0.5\n\t * @see Class#isMemberClass()\n\t * @see #isStaticClass(Class)\n\t */\n\tpublic static boolean isInnerClass(Class<?> clazz) {\n\t\treturn (clazz.isMemberClass() && !isStaticClass(clazz));\n\t}\n\n\t/**\n\t * Determine if the supplied {@link Class} is a JVM-generated implementation\n\t * class for a lambda expression or method reference.\n\t * <p>This method makes a best-effort attempt at determining this, based on\n\t * checks that work on modern, mainstream JVMs.\n\t * @param clazz the class to check\n\t * @return {@code true} if the class is a lambda implementation class\n\t * @since 5.3.19\n\t */\n\tpublic static boolean isLambdaClass(Class<?> clazz) {\n\t\treturn (clazz.isSynthetic() && (clazz.getSuperclass() == Object.class) &&\n\t\t\t\t(clazz.getInterfaces().length > 0) && clazz.getName().contains(\"$$Lambda\"));\n\t}\n\n\t/**\n\t * Check whether the given object is a CGLIB proxy.\n\t * @param object the object to check\n\t * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)\n\t * @deprecated as of 5.2, in favor of custom (possibly narrower) checks\n\t * such as for a Spring AOP proxy\n\t */\n\t@Deprecated\n\tpublic static boolean isCglibProxy(Object object) {\n\t\treturn isCglibProxyClass(object.getClass());\n\t}\n\n\t/**\n\t * Check whether the specified class is a CGLIB-generated class.\n\t * @param clazz the class to check\n\t * @see #getUserClass(Class)\n\t * @deprecated as of 5.2, in favor of custom (possibly narrower) checks\n\t * or simply a check for containing {@link #CGLIB_CLASS_SEPARATOR}\n\t */\n\t@Deprecated\n\tpublic static boolean isCglibProxyClass(@Nullable Class<?> clazz) {\n\t\treturn (clazz != null && isCglibProxyClassName(clazz.getName()));\n\t}\n\n\t/**\n\t * Check whether the specified class name is a CGLIB-generated class.\n\t * @param className the class name to check\n\t * @see #CGLIB_CLASS_SEPARATOR\n\t * @deprecated as of 5.2, in favor of custom (possibly narrower) checks\n\t * or simply a check for containing {@link #CGLIB_CLASS_SEPARATOR}\n\t */\n\t@Deprecated\n\tpublic static boolean isCglibProxyClassName(@Nullable String className) {\n\t\treturn (className != null && className.contains(CGLIB_CLASS_SEPARATOR));\n\t}\n\n\t/**\n\t * Return the user-defined class for the given instance: usually simply\n\t * the class of the given instance, but the original class in case of a\n\t * CGLIB-generated subclass.\n\t * @param instance the instance to check\n\t * @return the user-defined class\n\t */\n\tpublic static Class<?> getUserClass(Object instance) {\n\t\tAssert.notNull(instance, \"Instance must not be null\");\n\t\treturn getUserClass(instance.getClass());\n\t}\n\n\t/**\n\t * Return the user-defined class for the given class: usually simply the given\n\t * class, but the original class in case of a CGLIB-generated subclass.\n\t * @param clazz the class to check\n\t * @return the user-defined class\n\t * @see #CGLIB_CLASS_SEPARATOR\n\t */\n\tpublic static Class<?> getUserClass(Class<?> clazz) {\n\t\tif (clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {\n\t\t\tClass<?> superclass = clazz.getSuperclass();\n\t\t\tif (superclass != null && superclass != Object.class) {\n\t\t\t\treturn superclass;\n\t\t\t}\n\t\t}\n\t\treturn clazz;\n\t}\n\n\t/**\n\t * Return a descriptive name for the given object's type: usually simply\n\t * the class name, but component type class name + \"[]\" for arrays,\n\t * and an appended list of implemented interfaces for JDK proxies.\n\t * @param value the value to introspect\n\t * @return the qualified name of the class\n\t */\n\tpublic static @Nullable String getDescriptiveType(@Nullable Object value) {\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\tClass<?> clazz = value.getClass();\n\t\tif (Proxy.isProxyClass(clazz)) {\n\t\t\tString prefix = clazz.getTypeName() + \" implementing \";\n\t\t\tStringJoiner result = new StringJoiner(\",\", prefix, \"\");\n\t\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\t\t\t\tresult.add(ifc.getTypeName());\n\t\t\t}\n\t\t\treturn result.toString();\n\t\t}\n\t\telse {\n\t\t\treturn clazz.getTypeName();\n\t\t}\n\t}\n\n\t/**\n\t * Check whether the given class matches the user-specified type name.\n\t * @param clazz the class to check\n\t * @param typeName the type name to match\n\t */\n\tpublic static boolean matchesTypeName(Class<?> clazz, @Nullable String typeName) {\n\t\treturn (typeName != null &&\n\t\t\t\t(typeName.equals(clazz.getTypeName()) || typeName.equals(clazz.getSimpleName())));\n\t}\n\n\t/**\n\t * Get the class name without the qualified package name.\n\t * @param className the className to get the short name for\n\t * @return the class name of the class without the package name\n\t * @throws IllegalArgumentException if the className is empty\n\t */\n\tpublic static String getShortName(String className) {\n\t\tAssert.hasLength(className, \"Class name must not be empty\");\n\t\tint lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n\t\tint nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);\n\t\tif (nameEndIndex == -1) {\n\t\t\tnameEndIndex = className.length();\n\t\t}\n\t\tString shortName = className.substring(lastDotIndex + 1, nameEndIndex);\n\t\tshortName = shortName.replace(NESTED_CLASS_SEPARATOR, PACKAGE_SEPARATOR);\n\t\treturn shortName;\n\t}\n\n\t/**\n\t * Get the class name without the qualified package name.\n\t * @param clazz the class to get the short name for\n\t * @return the class name of the class without the package name\n\t */\n\tpublic static String getShortName(Class<?> clazz) {\n\t\treturn getShortName(getQualifiedName(clazz));\n\t}\n\n\t/**\n\t * Return the short string name of a Java class in uncapitalized JavaBeans\n\t * property format. Strips the outer class name in case of a nested class.\n\t * @param clazz the class\n\t * @return the short name rendered in a standard JavaBeans property format\n\t * @see StringUtils#uncapitalizeAsProperty(String)\n\t */\n\tpublic static String getShortNameAsProperty(Class<?> clazz) {\n\t\tString shortName = getShortName(clazz);\n\t\tint dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);\n\t\tshortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);\n\t\treturn StringUtils.uncapitalizeAsProperty(shortName);\n\t}\n\n\t/**\n\t * Determine the name of the class file, relative to the containing\n\t * package: for example, \"String.class\".\n\t * @param clazz the class\n\t * @return the file name of the \".class\" file\n\t */\n\tpublic static String getClassFileName(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tString className = clazz.getName();\n\t\tint lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n\t\treturn className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;\n\t}\n\n\t/**\n\t * Determine the name of the package of the given class,\n\t * for example, \"java.lang\" for the {@code java.lang.String} class.\n\t * @param clazz the class\n\t * @return the package name, or the empty String if the class\n\t * is defined in the default package\n\t */\n\tpublic static String getPackageName(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\treturn getPackageName(clazz.getName());\n\t}\n\n\t/**\n\t * Determine the name of the package of the given fully-qualified class name,\n\t * for example, \"java.lang\" for the {@code java.lang.String} class name.\n\t * @param fqClassName the fully-qualified class name\n\t * @return the package name, or the empty String if the class\n\t * is defined in the default package\n\t */\n\tpublic static String getPackageName(String fqClassName) {\n\t\tAssert.notNull(fqClassName, \"Class name must not be null\");\n\t\tint lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);\n\t\treturn (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : \"\");\n\t}\n\n\t/**\n\t * Return the qualified name of the given class: usually simply\n\t * the class name, but component type class name + \"[]\" for arrays.\n\t * @param clazz the class\n\t * @return the qualified name of the class\n\t */\n\tpublic static String getQualifiedName(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\treturn clazz.getTypeName();\n\t}\n\n\t/**\n\t * Return the qualified name of the given method, consisting of\n\t * fully qualified interface/class name + \".\" + method name.\n\t * @param method the method\n\t * @return the qualified name of the method\n\t */\n\tpublic static String getQualifiedMethodName(Method method) {\n\t\treturn getQualifiedMethodName(method, null);\n\t}\n\n\t/**\n\t * Return the qualified name of the given method, consisting of\n\t * fully qualified interface/class name + \".\" + method name.\n\t * @param method the method\n\t * @param clazz the clazz that the method is being invoked on\n\t * (can be {@code null} to indicate the method's declaring class)\n\t * @return the qualified name of the method\n\t * @since 4.3.4\n\t */\n\tpublic static String getQualifiedMethodName(Method method, @Nullable Class<?> clazz) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\treturn (clazz != null ? clazz : method.getDeclaringClass()).getName() + '.' + method.getName();\n\t}\n\n\t/**\n\t * Determine whether the given class has a public constructor with the given signature.\n\t * <p>Essentially translates {@code NoSuchMethodException} to \"false\".\n\t * @param clazz the clazz to analyze\n\t * @param paramTypes the parameter types of the method\n\t * @return whether the class has a corresponding constructor\n\t * @see Class#getConstructor\n\t */\n\tpublic static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {\n\t\treturn (getConstructorIfAvailable(clazz, paramTypes) != null);\n\t}\n\n\t/**\n\t * Determine whether the given class has a public constructor with the given signature,\n\t * and return it if available (else return {@code null}).\n\t * <p>Essentially translates {@code NoSuchMethodException} to {@code null}.\n\t * @param clazz the clazz to analyze\n\t * @param paramTypes the parameter types of the method\n\t * @return the constructor, or {@code null} if not found\n\t * @see Class#getConstructor\n\t */\n\tpublic static <T> @Nullable Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\ttry {\n\t\t\treturn clazz.getConstructor(paramTypes);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether the given class has a public method with the given signature.\n\t * @param clazz the clazz to analyze\n\t * @param method the method to look for\n\t * @return whether the class has a corresponding method\n\t * @since 5.2.3\n\t */\n\tpublic static boolean hasMethod(Class<?> clazz, Method method) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tif (clazz == method.getDeclaringClass()) {\n\t\t\treturn true;\n\t\t}\n\t\tString methodName = method.getName();\n\t\tClass<?>[] paramTypes = method.getParameterTypes();\n\t\treturn getMethodOrNull(clazz, methodName, paramTypes) != null;\n\t}\n\n\t/**\n\t * Determine whether the given class has a public method with the given signature.\n\t * <p>Essentially translates {@code NoSuchMethodException} to \"false\".\n\t * @param clazz the clazz to analyze\n\t * @param methodName the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * @return whether the class has a corresponding method\n\t * @see Class#getMethod\n\t */\n\tpublic static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n\t\treturn (getMethodIfAvailable(clazz, methodName, paramTypes) != null);\n\t}\n\n\t/**\n\t * Determine whether the given class has a public method with the given signature,\n\t * and return it if available (else throws an {@code IllegalStateException}).\n\t * <p>In case of any signature specified, only returns the method if there is a\n\t * unique candidate, i.e. a single public method with the specified name.\n\t * <p>Essentially translates {@code NoSuchMethodException} to {@code IllegalStateException}.\n\t * @param clazz the clazz to analyze\n\t * @param methodName the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * (can be {@code null} to indicate any signature)\n\t * @return the method (never {@code null})\n\t * @throws IllegalStateException if the method has not been found\n\t * @see Class#getMethod\n\t */\n\tpublic static Method getMethod(Class<?> clazz, String methodName, @Nullable Class<?>... paramTypes) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\tif (paramTypes != null) {\n\t\t\ttry {\n\t\t\t\treturn clazz.getMethod(methodName, paramTypes);\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Expected method not found: \" + ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSet<Method> candidates = findMethodCandidatesByName(clazz, methodName);\n\t\t\tif (candidates.size() == 1) {\n\t\t\t\treturn candidates.iterator().next();\n\t\t\t}\n\t\t\telse if (candidates.isEmpty()) {\n\t\t\t\tthrow new IllegalStateException(\"Expected method not found: \" + clazz.getName() + '.' + methodName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"No unique method found: \" + clazz.getName() + '.' + methodName);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether the given class has a public method with the given signature,\n\t * and return it if available (else return {@code null}).\n\t * <p>In case of any signature specified, only returns the method if there is a\n\t * unique candidate, i.e. a single public method with the specified name.\n\t * <p>Essentially translates {@code NoSuchMethodException} to {@code null}.\n\t * @param clazz the clazz to analyze\n\t * @param methodName the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * (can be {@code null} to indicate any signature)\n\t * @return the method, or {@code null} if not found\n\t * @see Class#getMethod\n\t */\n\tpublic static @Nullable Method getMethodIfAvailable(Class<?> clazz, String methodName, @Nullable Class<?> @Nullable ... paramTypes) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\tif (paramTypes != null) {\n\t\t\treturn getMethodOrNull(clazz, methodName, paramTypes);\n\t\t}\n\t\telse {\n\t\t\tSet<Method> candidates = findMethodCandidatesByName(clazz, methodName);\n\t\t\tif (candidates.size() == 1) {\n\t\t\t\treturn candidates.iterator().next();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Return the number of methods with a given name (with any argument types),\n\t * for the given class and/or its superclasses. Includes non-public methods.\n\t * @param clazz\tthe clazz to check\n\t * @param methodName the name of the method\n\t * @return the number of methods with the given name\n\t */\n\tpublic static int getMethodCountForName(Class<?> clazz, String methodName) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\tint count = 0;\n\t\tMethod[] declaredMethods = clazz.getDeclaredMethods();\n\t\tfor (Method method : declaredMethods) {\n\t\t\tif (methodName.equals(method.getName())) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tClass<?>[] ifcs = clazz.getInterfaces();\n\t\tfor (Class<?> ifc : ifcs) {\n\t\t\tcount += getMethodCountForName(ifc, methodName);\n\t\t}\n\t\tif (clazz.getSuperclass() != null) {\n\t\t\tcount += getMethodCountForName(clazz.getSuperclass(), methodName);\n\t\t}\n\t\treturn count;\n\t}\n\n\t/**\n\t * Does the given class or one of its superclasses at least have one or more\n\t * methods with the supplied name (with any argument types)?\n\t * Includes non-public methods.\n\t * @param clazz\tthe clazz to check\n\t * @param methodName the name of the method\n\t * @return whether there is at least one method with the given name\n\t */\n\tpublic static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\tMethod[] declaredMethods = clazz.getDeclaredMethods();\n\t\tfor (Method method : declaredMethods) {\n\t\t\tif (method.getName().equals(methodName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tClass<?>[] ifcs = clazz.getInterfaces();\n\t\tfor (Class<?> ifc : ifcs) {\n\t\t\tif (hasAtLeastOneMethodWithName(ifc, methodName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));\n\t}\n\n\t/**\n\t * Given a method, which may come from an interface, and a target class used\n\t * in the current reflective invocation, find the corresponding target method\n\t * if there is one &mdash; for example, the method may be {@code IFoo.bar()},\n\t * and the target class may be {@code DefaultFoo}. In this case, the method may be\n\t * {@code DefaultFoo.bar()}. This enables attributes on that method to be found.\n\t * <p><b>NOTE:</b> In contrast to {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\n\t * this method does <i>not</i> resolve bridge methods automatically.\n\t * Call {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\n\t * if bridge method resolution is desirable &mdash; for example, to obtain\n\t * metadata from the original method definition.\n\t * <p><b>NOTE:</b> If Java security settings disallow reflective access &mdash;\n\t * for example, calls to {@code Class#getDeclaredMethods}, etc. &mdash; this\n\t * implementation will fall back to returning the originally provided method.\n\t * @param method the method to be invoked, which may come from an interface\n\t * @param targetClass the target class for the current invocation\n\t * (can be {@code null} or may not even implement the method)\n\t * @return the specific target method, or the original method if the\n\t * {@code targetClass} does not implement it\n\t * @see #getInterfaceMethodIfPossible(Method, Class)\n\t */\n\tpublic static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {\n\t\tif (targetClass != null && targetClass != method.getDeclaringClass() &&\n\t\t\t\t(isOverridable(method, targetClass) || !method.getDeclaringClass().isAssignableFrom(targetClass))) {\n\t\t\ttry {\n\t\t\t\tif (Modifier.isPublic(method.getModifiers())) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn targetClass.getMethod(method.getName(), method.getParameterTypes());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\treturn method;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMethod specificMethod =\n\t\t\t\t\t\t\tReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\n\t\t\t\t\treturn (specificMethod != null ? specificMethod : method);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (SecurityException ex) {\n\t\t\t\t// Security settings are disallowing reflective access; fall back to 'method' below.\n\t\t\t}\n\t\t}\n\t\treturn method;\n\t}\n\n\t/**\n\t * Determine a corresponding interface method for the given method handle, if possible.\n\t * <p>This is particularly useful for arriving at a public exported type on the Java\n\t * Module System which allows the method to be invoked via reflection without an illegal\n\t * access warning.\n\t * @param method the method to be invoked, potentially from an implementation class\n\t * @return the corresponding interface method, or the original method if none found\n\t * @since 5.1\n\t * @see #getPubliclyAccessibleMethodIfPossible(Method, Class)\n\t * @deprecated in favor of {@link #getInterfaceMethodIfPossible(Method, Class)}\n\t */\n\t@Deprecated\n\tpublic static Method getInterfaceMethodIfPossible(Method method) {\n\t\treturn getInterfaceMethodIfPossible(method, null);\n\t}\n\n\t/**\n\t * Determine a corresponding interface method for the given method handle, if possible.\n\t * <p>This is particularly useful for arriving at a public exported type on the Java\n\t * Module System which allows the method to be invoked via reflection without an illegal\n\t * access warning.\n\t * @param method the method to be invoked, potentially from an implementation class\n\t * @param targetClass the target class to invoke the method on, or {@code null} if unknown\n\t * @return the corresponding interface method, or the original method if none found\n\t * @since 5.3.16\n\t * @see #getPubliclyAccessibleMethodIfPossible(Method, Class)\n\t * @see #getMostSpecificMethod\n\t */\n\tpublic static Method getInterfaceMethodIfPossible(Method method, @Nullable Class<?> targetClass) {\n\t\treturn getInterfaceMethodIfPossible(method, targetClass, false);\n\t}\n\n\tprivate static Method getInterfaceMethodIfPossible(Method method, @Nullable Class<?> targetClass,\n\t\t\tboolean requirePublicInterface) {\n\n\t\tClass<?> declaringClass = method.getDeclaringClass();\n\t\tif (!Modifier.isPublic(method.getModifiers()) || (declaringClass.isInterface() &&\n\t\t\t\t(!requirePublicInterface || Modifier.isPublic(declaringClass.getModifiers())))) {\n\t\t\treturn method;\n\t\t}\n\t\tString methodName = method.getName();\n\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\n\t\tMap<Method, Method> methodCache = (requirePublicInterface ? publicInterfaceMethodCache : interfaceMethodCache);\n\t\t// Try cached version of method in its declaring class\n\t\tMethod result = methodCache.computeIfAbsent(method, key -> findInterfaceMethodIfPossible(\n\t\t\t\tmethodName, parameterTypes, declaringClass, Object.class, requirePublicInterface));\n\t\tif (result == null && targetClass != null) {\n\t\t\t// No interface method found yet -> try given target class (possibly a subclass of the\n\t\t\t// declaring class, late-binding a base class method to a subclass-declared interface:\n\t\t\t// see, for example, HashMap.HashIterator.hasNext)\n\t\t\tresult = findInterfaceMethodIfPossible(\n\t\t\t\t\tmethodName, parameterTypes, targetClass, declaringClass, requirePublicInterface);\n\t\t}\n\t\treturn (result != null ? result : method);\n\t}\n\n\tprivate static @Nullable Method findInterfaceMethodIfPossible(String methodName, Class<?>[] parameterTypes,\n\t\t\tClass<?> startClass, Class<?> endClass, boolean requirePublicInterface) {\n\n\t\tClass<?> current = startClass;\n\t\twhile (current != null && current != endClass) {\n\t\t\tfor (Class<?> ifc : current.getInterfaces()) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!requirePublicInterface || Modifier.isPublic(ifc.getModifiers())) {\n\t\t\t\t\t\treturn ifc.getMethod(methodName, parameterTypes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get the first publicly accessible method in the supplied method's type hierarchy that\n\t * has a method signature equivalent to the supplied method, if possible.\n\t * <p>If the supplied method is {@code public} and declared in a {@code public} type,\n\t * the supplied method will be returned.\n\t * <p>Otherwise, this method recursively searches the class hierarchy and implemented\n\t * interfaces for an equivalent method that is {@code public} and declared in a\n\t * {@code public} type.\n\t * <p>If a publicly accessible equivalent method cannot be found, the supplied method\n\t * will be returned, indicating that no such equivalent method exists. Consequently,\n\t * callers of this method must manually validate the accessibility of the returned method\n\t * if public access is a requirement.\n\t * <p>This is particularly useful for arriving at a public exported type on the Java\n\t * Module System which allows the method to be invoked via reflection without an illegal\n\t * access warning. This is also useful for invoking methods via a public API in bytecode\n\t * &mdash; for example, for use with the Spring Expression Language (SpEL) compiler.\n\t * For example, if a non-public class overrides {@code toString()}, this method will\n\t * traverse up the type hierarchy to find the first public type that declares the method\n\t * (if there is one). For {@code toString()}, it may traverse as far as {@link Object}.\n\t * @param method the method to be invoked, potentially from an implementation class\n\t * @param targetClass the target class to invoke the method on, or {@code null} if unknown\n\t * @return the corresponding publicly accessible method, or the original method if none found\n\t * @since 6.2\n\t * @see #getInterfaceMethodIfPossible(Method, Class)\n\t * @see #getMostSpecificMethod(Method, Class)\n\t */\n\tpublic static Method getPubliclyAccessibleMethodIfPossible(Method method, @Nullable Class<?> targetClass) {\n\t\tClass<?> declaringClass = method.getDeclaringClass();\n\t\t// If the method is not public, we can abort the search immediately; or if the method's\n\t\t// declaring class is public, the method is already publicly accessible.\n\t\tif (!Modifier.isPublic(method.getModifiers()) || Modifier.isPublic(declaringClass.getModifiers())) {\n\t\t\treturn method;\n\t\t}\n\n\t\tMethod interfaceMethod = getInterfaceMethodIfPossible(method, targetClass, true);\n\t\t// If we found a method in a public interface, return the interface method.\n\t\tif (!interfaceMethod.equals(method)) {\n\t\t\treturn interfaceMethod;\n\t\t}\n\n\t\tMethod result = publiclyAccessibleMethodCache.computeIfAbsent(method,\n\t\t\t\tkey -> findPubliclyAccessibleMethodIfPossible(key.getName(), key.getParameterTypes(), declaringClass));\n\t\treturn (result != null ? result : method);\n\t}\n\n\tprivate static @Nullable Method findPubliclyAccessibleMethodIfPossible(\n\t\t\tString methodName, Class<?>[] parameterTypes, Class<?> declaringClass) {\n\n\t\tClass<?> current = declaringClass.getSuperclass();\n\t\twhile (current != null) {\n\t\t\tif (Modifier.isPublic(current.getModifiers())) {\n\t\t\t\ttry {\n\t\t\t\t\treturn current.getDeclaredMethod(methodName, parameterTypes);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Determine whether the given method is declared by the user or at least pointing to\n\t * a user-declared method.\n\t * <p>Checks {@link Method#isSynthetic()} (for implementation methods) as well as the\n\t * {@code GroovyObject} interface (for interface methods; on an implementation class,\n\t * implementations of the {@code GroovyObject} methods will be marked as synthetic anyway).\n\t * Note that, despite being synthetic, bridge methods ({@link Method#isBridge()}) are considered\n\t * as user-level methods since they are eventually pointing to a user-declared generic method.\n\t * @param method the method to check\n\t * @return {@code true} if the method can be considered as user-declared; {@code false} otherwise\n\t */\n\tpublic static boolean isUserLevelMethod(Method method) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\treturn (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));\n\t}\n\n\tprivate static boolean isGroovyObjectMethod(Method method) {\n\t\treturn method.getDeclaringClass().getName().equals(\"groovy.lang.GroovyObject\");\n\t}\n\n\t/**\n\t * Determine whether the given method is overridable in the given target class.\n\t * @param method the method to check\n\t * @param targetClass the target class to check against\n\t */\n\tprivate static boolean isOverridable(Method method, @Nullable Class<?> targetClass) {\n\t\tif ((method.getModifiers() & NON_OVERRIDABLE_MODIFIER) != 0) {\n\t\t\treturn false;\n\t\t}\n\t\tif ((method.getModifiers() & OVERRIDABLE_MODIFIER) != 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (targetClass == null ||\n\t\t\t\tgetPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass)));\n\t}\n\n\t/**\n\t * Return a public static method of a class.\n\t * @param clazz the class which defines the method\n\t * @param methodName the static method name\n\t * @param args the parameter types to the method\n\t * @return the static method, or {@code null} if no static method was found\n\t * @throws IllegalArgumentException if the method name is blank or the clazz is null\n\t */\n\tpublic static @Nullable Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\ttry {\n\t\t\tMethod method = clazz.getMethod(methodName, args);\n\t\t\treturn (Modifier.isStatic(method.getModifiers()) ? method : null);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\tprivate static @Nullable Method getMethodOrNull(Class<?> clazz, String methodName, @Nullable Class<?> @Nullable [] paramTypes) {\n\t\ttry {\n\t\t\treturn clazz.getMethod(methodName, paramTypes);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate static Set<Method> findMethodCandidatesByName(Class<?> clazz, String methodName) {\n\t\tSet<Method> candidates = new HashSet<>(1);\n\t\tMethod[] methods = clazz.getMethods();\n\t\tfor (Method method : methods) {\n\t\t\tif (methodName.equals(method.getName())) {\n\t\t\t\tcandidates.add(method);\n\t\t\t}\n\t\t}\n\t\treturn candidates;\n\t}\n\n}"
  },
  "org.springframework.util.ClassUtils#addResourcePathToPackagePath(clazz,resourceName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a path suitable for use with {@code ClassLoader.getResource}\n\t * (also suitable for use with {@code Class.getResource} by prepending a\n\t * slash ('/') to the return value). Built by taking the package of the specified\n\t * class file, converting all dots ('.') to slashes ('/'), adding a trailing slash\n\t * if necessary, and concatenating the specified resource name to this.\n\t * <br/>As such, this function may be used to build a path suitable for\n\t * loading a resource file that is in the same package as a class file,\n\t * although {@link org.springframework.core.io.ClassPathResource} is usually\n\t * even more convenient.\n\t * @param clazz the Class whose package will be used as the base\n\t * @param resourceName the resource name to append. A leading slash is optional.\n\t * @return the built-up resource path\n\t * @see ClassLoader#getResource\n\t * @see Class#getResource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "resourceName"
    ],
    "position": {
      "column": 1,
      "line": 672
    },
    "return": "String",
    "signature": "public String addResourcePathToPackagePath(Class<?> clazz, String resourceName)",
    "source_code": "\tpublic static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {\n\t\tAssert.notNull(resourceName, \"Resource name must not be null\");\n\t\tif (!resourceName.startsWith(\"/\")) {\n\t\t\treturn classPackageAsResourcePath(clazz) + PATH_SEPARATOR + resourceName;\n\t\t}\n\t\treturn classPackageAsResourcePath(clazz) + resourceName;\n\t}"
  },
  "org.springframework.util.ClassUtils#classNamesToString(classes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a String that consists of the names of the classes/interfaces\n\t * in the given collection.\n\t * <p>Basically like {@code AbstractCollection.toString()}, but stripping\n\t * the \"class \"/\"interface \" prefix before every class name.\n\t * @param classes a Collection of Class objects (can be {@code null})\n\t * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n\t * @see java.util.AbstractCollection#toString()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classes"
    ],
    "position": {
      "column": 1,
      "line": 729
    },
    "return": "String",
    "signature": "public String classNamesToString(@Nullable Collection<Class<?>> classes)",
    "source_code": "\tpublic static String classNamesToString(@Nullable Collection<Class<?>> classes) {\n\t\tif (CollectionUtils.isEmpty(classes)) {\n\t\t\treturn \"[]\";\n\t\t}\n\t\tStringJoiner stringJoiner = new StringJoiner(\", \", \"[\", \"]\");\n\t\tfor (Class<?> clazz : classes) {\n\t\t\tstringJoiner.add(clazz.getName());\n\t\t}\n\t\treturn stringJoiner.toString();\n\t}"
  },
  "org.springframework.util.ClassUtils#classPackageAsResourcePath(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Given an input class object, return a string which consists of the\n\t * class's package name as a pathname, i.e., all dots ('.') are replaced by\n\t * slashes ('/'). Neither a leading nor trailing slash is added. The result\n\t * could be concatenated with a slash and the name of a resource and fed\n\t * directly to {@code ClassLoader.getResource()}. For it to be fed to\n\t * {@code Class.getResource} instead, a leading slash would also have\n\t * to be prepended to the returned value.\n\t * @param clazz the input class. A {@code null} value or the default\n\t * (empty) package will result in an empty string (\"\") being returned.\n\t * @return a path which represents the package name\n\t * @see ClassLoader#getResource\n\t * @see Class#getResource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 694
    },
    "return": "String",
    "signature": "public String classPackageAsResourcePath(@Nullable Class<?> clazz)",
    "source_code": "\tpublic static String classPackageAsResourcePath(@Nullable Class<?> clazz) {\n\t\tif (clazz == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tString className = clazz.getName();\n\t\tint packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n\t\tif (packageEndIndex == -1) {\n\t\t\treturn \"\";\n\t\t}\n\t\tString packageName = className.substring(0, packageEndIndex);\n\t\treturn packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n\t}"
  },
  "org.springframework.util.ClassUtils#convertClassNameToResourcePath(className)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a \".\"-based fully qualified class name to a \"/\"-based resource path.\n\t * @param className the fully qualified class name\n\t * @return the corresponding resource path, pointing to the class\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "className"
    ],
    "position": {
      "column": 1,
      "line": 651
    },
    "return": "String",
    "signature": "public String convertClassNameToResourcePath(String className)",
    "source_code": "\tpublic static String convertClassNameToResourcePath(String className) {\n\t\tAssert.notNull(className, \"Class name must not be null\");\n\t\treturn className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n\t}"
  },
  "org.springframework.util.ClassUtils#convertResourcePathToClassName(resourcePath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a \"/\"-based resource path to a \".\"-based fully qualified class name.\n\t * @param resourcePath the resource path pointing to a class\n\t * @return the corresponding fully qualified class name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourcePath"
    ],
    "position": {
      "column": 1,
      "line": 641
    },
    "return": "String",
    "signature": "public String convertResourcePathToClassName(String resourcePath)",
    "source_code": "\tpublic static String convertResourcePathToClassName(String resourcePath) {\n\t\tAssert.notNull(resourcePath, \"Resource path must not be null\");\n\t\treturn resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);\n\t}"
  },
  "org.springframework.util.ClassUtils#getClassFileName(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the name of the class file, relative to the containing\n\t * package: for example, \"String.class\".\n\t * @param clazz the class\n\t * @return the file name of the \".class\" file\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 1084
    },
    "return": "String",
    "signature": "public String getClassFileName(Class<?> clazz)",
    "source_code": "\tpublic static String getClassFileName(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tString className = clazz.getName();\n\t\tint lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n\t\treturn className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;\n\t}"
  },
  "org.springframework.util.ClassUtils#getConstructorIfAvailable(clazz,paramTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class has a public constructor with the given signature,\n\t * and return it if available (else return {@code null}).\n\t * <p>Essentially translates {@code NoSuchMethodException} to {@code null}.\n\t * @param clazz the clazz to analyze\n\t * @param paramTypes the parameter types of the method\n\t * @return the constructor, or {@code null} if not found\n\t * @see Class#getConstructor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "paramTypes"
    ],
    "position": {
      "column": 1,
      "line": 1172
    },
    "return": "Constructor<T>",
    "signature": "public Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes)",
    "source_code": "\tpublic static <T> @Nullable Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\ttry {\n\t\t\treturn clazz.getConstructor(paramTypes);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.util.ClassUtils#getDefaultClassLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the default ClassLoader to use: typically the thread context\n\t * ClassLoader, if available; the ClassLoader that loaded the ClassUtils\n\t * class will be used as fallback.\n\t * <p>Call this method if you intend to use the thread context ClassLoader\n\t * in a scenario where you clearly prefer a non-null ClassLoader reference:\n\t * for example, for class path resource loading (but not necessarily for\n\t * {@code Class.forName}, which accepts a {@code null} ClassLoader\n\t * reference as well).\n\t * @return the default ClassLoader (only {@code null} if even the system\n\t * ClassLoader isn't accessible)\n\t * @see Thread#getContextClassLoader()\n\t * @see ClassLoader#getSystemClassLoader()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "ClassLoader",
    "signature": "public ClassLoader getDefaultClassLoader()",
    "source_code": "\tpublic static @Nullable ClassLoader getDefaultClassLoader() {\n\t\tClassLoader cl = null;\n\t\ttry {\n\t\t\tcl = Thread.currentThread().getContextClassLoader();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// Cannot access thread context ClassLoader - falling back...\n\t\t}\n\t\tif (cl == null) {\n\t\t\t// No thread context class loader -> use class loader of this class.\n\t\t\tcl = ClassUtils.class.getClassLoader();\n\t\t\tif (cl == null) {\n\t\t\t\t// getClassLoader() returning null indicates the bootstrap ClassLoader\n\t\t\t\ttry {\n\t\t\t\t\tcl = ClassLoader.getSystemClassLoader();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t// Cannot access system ClassLoader - oh well, maybe the caller can live with null...\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cl;\n\t}"
  },
  "org.springframework.util.ClassUtils#getDescriptiveType(value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a descriptive name for the given object's type: usually simply\n\t * the class name, but component type class name + \"[]\" for arrays,\n\t * and an appended list of implemented interfaces for JDK proxies.\n\t * @param value the value to introspect\n\t * @return the qualified name of the class\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1009
    },
    "return": "String",
    "signature": "public String getDescriptiveType(@Nullable Object value)",
    "source_code": "\tpublic static @Nullable String getDescriptiveType(@Nullable Object value) {\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\tClass<?> clazz = value.getClass();\n\t\tif (Proxy.isProxyClass(clazz)) {\n\t\t\tString prefix = clazz.getTypeName() + \" implementing \";\n\t\t\tStringJoiner result = new StringJoiner(\",\", prefix, \"\");\n\t\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\t\t\t\tresult.add(ifc.getTypeName());\n\t\t\t}\n\t\t\treturn result.toString();\n\t\t}\n\t\telse {\n\t\t\treturn clazz.getTypeName();\n\t\t}\n\t}"
  },
  "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine a corresponding interface method for the given method handle, if possible.\n\t * <p>This is particularly useful for arriving at a public exported type on the Java\n\t * Module System which allows the method to be invoked via reflection without an illegal\n\t * access warning.\n\t * @param method the method to be invoked, potentially from an implementation class\n\t * @return the corresponding interface method, or the original method if none found\n\t * @since 5.1\n\t * @see #getPubliclyAccessibleMethodIfPossible(Method, Class)\n\t * @deprecated in favor of {@link #getInterfaceMethodIfPossible(Method, Class)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 1391
    },
    "return": "Method",
    "signature": "public Method getInterfaceMethodIfPossible(Method method)",
    "source_code": "\tpublic static Method getInterfaceMethodIfPossible(Method method) {\n\t\treturn getInterfaceMethodIfPossible(method, null);\n\t}"
  },
  "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine a corresponding interface method for the given method handle, if possible.\n\t * <p>This is particularly useful for arriving at a public exported type on the Java\n\t * Module System which allows the method to be invoked via reflection without an illegal\n\t * access warning.\n\t * @param method the method to be invoked, potentially from an implementation class\n\t * @param targetClass the target class to invoke the method on, or {@code null} if unknown\n\t * @return the corresponding interface method, or the original method if none found\n\t * @since 5.3.16\n\t * @see #getPubliclyAccessibleMethodIfPossible(Method, Class)\n\t * @see #getMostSpecificMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 1407
    },
    "return": "Method",
    "signature": "public Method getInterfaceMethodIfPossible(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic static Method getInterfaceMethodIfPossible(Method method, @Nullable Class<?> targetClass) {\n\t\treturn getInterfaceMethodIfPossible(method, targetClass, false);\n\t}"
  },
  "org.springframework.util.ClassUtils#getMethod(clazz,methodName,paramTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class has a public method with the given signature,\n\t * and return it if available (else throws an {@code IllegalStateException}).\n\t * <p>In case of any signature specified, only returns the method if there is a\n\t * unique candidate, i.e. a single public method with the specified name.\n\t * <p>Essentially translates {@code NoSuchMethodException} to {@code IllegalStateException}.\n\t * @param clazz the clazz to analyze\n\t * @param methodName the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * (can be {@code null} to indicate any signature)\n\t * @return the method (never {@code null})\n\t * @throws IllegalStateException if the method has not been found\n\t * @see Class#getMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName",
      "paramTypes"
    ],
    "position": {
      "column": 1,
      "line": 1227
    },
    "return": "Method",
    "signature": "public Method getMethod(Class<?> clazz, String methodName, @Nullable Class<?>... paramTypes)",
    "source_code": "\tpublic static Method getMethod(Class<?> clazz, String methodName, @Nullable Class<?>... paramTypes) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\tif (paramTypes != null) {\n\t\t\ttry {\n\t\t\t\treturn clazz.getMethod(methodName, paramTypes);\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Expected method not found: \" + ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSet<Method> candidates = findMethodCandidatesByName(clazz, methodName);\n\t\t\tif (candidates.size() == 1) {\n\t\t\t\treturn candidates.iterator().next();\n\t\t\t}\n\t\t\telse if (candidates.isEmpty()) {\n\t\t\t\tthrow new IllegalStateException(\"Expected method not found: \" + clazz.getName() + '.' + methodName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"No unique method found: \" + clazz.getName() + '.' + methodName);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.ClassUtils#getMethodCountForName(clazz,methodName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the number of methods with a given name (with any argument types),\n\t * for the given class and/or its superclasses. Includes non-public methods.\n\t * @param clazz\tthe clazz to check\n\t * @param methodName the name of the method\n\t * @return the number of methods with the given name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName"
    ],
    "position": {
      "column": 1,
      "line": 1287
    },
    "return": "int",
    "signature": "public int getMethodCountForName(Class<?> clazz, String methodName)",
    "source_code": "\tpublic static int getMethodCountForName(Class<?> clazz, String methodName) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\tint count = 0;\n\t\tMethod[] declaredMethods = clazz.getDeclaredMethods();\n\t\tfor (Method method : declaredMethods) {\n\t\t\tif (methodName.equals(method.getName())) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tClass<?>[] ifcs = clazz.getInterfaces();\n\t\tfor (Class<?> ifc : ifcs) {\n\t\t\tcount += getMethodCountForName(ifc, methodName);\n\t\t}\n\t\tif (clazz.getSuperclass() != null) {\n\t\t\tcount += getMethodCountForName(clazz.getSuperclass(), methodName);\n\t\t}\n\t\treturn count;\n\t}"
  },
  "org.springframework.util.ClassUtils#getMethodIfAvailable(clazz,methodName,paramTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class has a public method with the given signature,\n\t * and return it if available (else return {@code null}).\n\t * <p>In case of any signature specified, only returns the method if there is a\n\t * unique candidate, i.e. a single public method with the specified name.\n\t * <p>Essentially translates {@code NoSuchMethodException} to {@code null}.\n\t * @param clazz the clazz to analyze\n\t * @param methodName the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * (can be {@code null} to indicate any signature)\n\t * @return the method, or {@code null} if not found\n\t * @see Class#getMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName",
      "paramTypes"
    ],
    "position": {
      "column": 1,
      "line": 1265
    },
    "return": "Method",
    "signature": "public Method getMethodIfAvailable(Class<?> clazz, String methodName, @Nullable Class<?> @Nullable ... paramTypes)",
    "source_code": "\tpublic static @Nullable Method getMethodIfAvailable(Class<?> clazz, String methodName, @Nullable Class<?> @Nullable ... paramTypes) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\tif (paramTypes != null) {\n\t\t\treturn getMethodOrNull(clazz, methodName, paramTypes);\n\t\t}\n\t\telse {\n\t\t\tSet<Method> candidates = findMethodCandidatesByName(clazz, methodName);\n\t\t\tif (candidates.size() == 1) {\n\t\t\t\treturn candidates.iterator().next();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.util.ClassUtils#getMostSpecificMethod(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Given a method, which may come from an interface, and a target class used\n\t * in the current reflective invocation, find the corresponding target method\n\t * if there is one &mdash; for example, the method may be {@code IFoo.bar()},\n\t * and the target class may be {@code DefaultFoo}. In this case, the method may be\n\t * {@code DefaultFoo.bar()}. This enables attributes on that method to be found.\n\t * <p><b>NOTE:</b> In contrast to {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\n\t * this method does <i>not</i> resolve bridge methods automatically.\n\t * Call {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\n\t * if bridge method resolution is desirable &mdash; for example, to obtain\n\t * metadata from the original method definition.\n\t * <p><b>NOTE:</b> If Java security settings disallow reflective access &mdash;\n\t * for example, calls to {@code Class#getDeclaredMethods}, etc. &mdash; this\n\t * implementation will fall back to returning the originally provided method.\n\t * @param method the method to be invoked, which may come from an interface\n\t * @param targetClass the target class for the current invocation\n\t * (can be {@code null} or may not even implement the method)\n\t * @return the specific target method, or the original method if the\n\t * {@code targetClass} does not implement it\n\t * @see #getInterfaceMethodIfPossible(Method, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 1354
    },
    "return": "Method",
    "signature": "public Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {\n\t\tif (targetClass != null && targetClass != method.getDeclaringClass() &&\n\t\t\t\t(isOverridable(method, targetClass) || !method.getDeclaringClass().isAssignableFrom(targetClass))) {\n\t\t\ttry {\n\t\t\t\tif (Modifier.isPublic(method.getModifiers())) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn targetClass.getMethod(method.getName(), method.getParameterTypes());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\treturn method;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMethod specificMethod =\n\t\t\t\t\t\t\tReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\n\t\t\t\t\treturn (specificMethod != null ? specificMethod : method);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (SecurityException ex) {\n\t\t\t\t// Security settings are disallowing reflective access; fall back to 'method' below.\n\t\t\t}\n\t\t}\n\t\treturn method;\n\t}"
  },
  "org.springframework.util.ClassUtils#getPackageName(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the name of the package of the given class,\n\t * for example, \"java.lang\" for the {@code java.lang.String} class.\n\t * @param clazz the class\n\t * @return the package name, or the empty String if the class\n\t * is defined in the default package\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 1098
    },
    "return": "String",
    "signature": "public String getPackageName(Class<?> clazz)",
    "source_code": "\tpublic static String getPackageName(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\treturn getPackageName(clazz.getName());\n\t}"
  },
  "org.springframework.util.ClassUtils#getPackageName(fqClassName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the name of the package of the given fully-qualified class name,\n\t * for example, \"java.lang\" for the {@code java.lang.String} class name.\n\t * @param fqClassName the fully-qualified class name\n\t * @return the package name, or the empty String if the class\n\t * is defined in the default package\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fqClassName"
    ],
    "position": {
      "column": 1,
      "line": 1110
    },
    "return": "String",
    "signature": "public String getPackageName(String fqClassName)",
    "source_code": "\tpublic static String getPackageName(String fqClassName) {\n\t\tAssert.notNull(fqClassName, \"Class name must not be null\");\n\t\tint lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);\n\t\treturn (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : \"\");\n\t}"
  },
  "org.springframework.util.ClassUtils#getPubliclyAccessibleMethodIfPossible(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the first publicly accessible method in the supplied method's type hierarchy that\n\t * has a method signature equivalent to the supplied method, if possible.\n\t * <p>If the supplied method is {@code public} and declared in a {@code public} type,\n\t * the supplied method will be returned.\n\t * <p>Otherwise, this method recursively searches the class hierarchy and implemented\n\t * interfaces for an equivalent method that is {@code public} and declared in a\n\t * {@code public} type.\n\t * <p>If a publicly accessible equivalent method cannot be found, the supplied method\n\t * will be returned, indicating that no such equivalent method exists. Consequently,\n\t * callers of this method must manually validate the accessibility of the returned method\n\t * if public access is a requirement.\n\t * <p>This is particularly useful for arriving at a public exported type on the Java\n\t * Module System which allows the method to be invoked via reflection without an illegal\n\t * access warning. This is also useful for invoking methods via a public API in bytecode\n\t * &mdash; for example, for use with the Spring Expression Language (SpEL) compiler.\n\t * For example, if a non-public class overrides {@code toString()}, this method will\n\t * traverse up the type hierarchy to find the first public type that declares the method\n\t * (if there is one). For {@code toString()}, it may traverse as far as {@link Object}.\n\t * @param method the method to be invoked, potentially from an implementation class\n\t * @param targetClass the target class to invoke the method on, or {@code null} if unknown\n\t * @return the corresponding publicly accessible method, or the original method if none found\n\t * @since 6.2\n\t * @see #getInterfaceMethodIfPossible(Method, Class)\n\t * @see #getMostSpecificMethod(Method, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 1482
    },
    "return": "Method",
    "signature": "public Method getPubliclyAccessibleMethodIfPossible(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic static Method getPubliclyAccessibleMethodIfPossible(Method method, @Nullable Class<?> targetClass) {\n\t\tClass<?> declaringClass = method.getDeclaringClass();\n\t\t// If the method is not public, we can abort the search immediately; or if the method's\n\t\t// declaring class is public, the method is already publicly accessible.\n\t\tif (!Modifier.isPublic(method.getModifiers()) || Modifier.isPublic(declaringClass.getModifiers())) {\n\t\t\treturn method;\n\t\t}\n\n\t\tMethod interfaceMethod = getInterfaceMethodIfPossible(method, targetClass, true);\n\t\t// If we found a method in a public interface, return the interface method.\n\t\tif (!interfaceMethod.equals(method)) {\n\t\t\treturn interfaceMethod;\n\t\t}\n\n\t\tMethod result = publiclyAccessibleMethodCache.computeIfAbsent(method,\n\t\t\t\tkey -> findPubliclyAccessibleMethodIfPossible(key.getName(), key.getParameterTypes(), declaringClass));\n\t\treturn (result != null ? result : method);\n\t}"
  },
  "org.springframework.util.ClassUtils#getQualifiedMethodName(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the qualified name of the given method, consisting of\n\t * fully qualified interface/class name + \".\" + method name.\n\t * @param method the method\n\t * @return the qualified name of the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 1133
    },
    "return": "String",
    "signature": "public String getQualifiedMethodName(Method method)",
    "source_code": "\tpublic static String getQualifiedMethodName(Method method) {\n\t\treturn getQualifiedMethodName(method, null);\n\t}"
  },
  "org.springframework.util.ClassUtils#getQualifiedMethodName(method,clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the qualified name of the given method, consisting of\n\t * fully qualified interface/class name + \".\" + method name.\n\t * @param method the method\n\t * @param clazz the clazz that the method is being invoked on\n\t * (can be {@code null} to indicate the method's declaring class)\n\t * @return the qualified name of the method\n\t * @since 4.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 1146
    },
    "return": "String",
    "signature": "public String getQualifiedMethodName(Method method, @Nullable Class<?> clazz)",
    "source_code": "\tpublic static String getQualifiedMethodName(Method method, @Nullable Class<?> clazz) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\treturn (clazz != null ? clazz : method.getDeclaringClass()).getName() + '.' + method.getName();\n\t}"
  },
  "org.springframework.util.ClassUtils#getQualifiedName(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the qualified name of the given class: usually simply\n\t * the class name, but component type class name + \"[]\" for arrays.\n\t * @param clazz the class\n\t * @return the qualified name of the class\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 1122
    },
    "return": "String",
    "signature": "public String getQualifiedName(Class<?> clazz)",
    "source_code": "\tpublic static String getQualifiedName(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\treturn clazz.getTypeName();\n\t}"
  },
  "org.springframework.util.ClassUtils#getShortName(className)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the class name without the qualified package name.\n\t * @param className the className to get the short name for\n\t * @return the class name of the class without the package name\n\t * @throws IllegalArgumentException if the className is empty\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "className"
    ],
    "position": {
      "column": 1,
      "line": 1043
    },
    "return": "String",
    "signature": "public String getShortName(String className)",
    "source_code": "\tpublic static String getShortName(String className) {\n\t\tAssert.hasLength(className, \"Class name must not be empty\");\n\t\tint lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n\t\tint nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);\n\t\tif (nameEndIndex == -1) {\n\t\t\tnameEndIndex = className.length();\n\t\t}\n\t\tString shortName = className.substring(lastDotIndex + 1, nameEndIndex);\n\t\tshortName = shortName.replace(NESTED_CLASS_SEPARATOR, PACKAGE_SEPARATOR);\n\t\treturn shortName;\n\t}"
  },
  "org.springframework.util.ClassUtils#getShortName(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the class name without the qualified package name.\n\t * @param clazz the class to get the short name for\n\t * @return the class name of the class without the package name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 1060
    },
    "return": "String",
    "signature": "public String getShortName(Class<?> clazz)",
    "source_code": "\tpublic static String getShortName(Class<?> clazz) {\n\t\treturn getShortName(getQualifiedName(clazz));\n\t}"
  },
  "org.springframework.util.ClassUtils#getShortNameAsProperty(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the short string name of a Java class in uncapitalized JavaBeans\n\t * property format. Strips the outer class name in case of a nested class.\n\t * @param clazz the class\n\t * @return the short name rendered in a standard JavaBeans property format\n\t * @see StringUtils#uncapitalizeAsProperty(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 1071
    },
    "return": "String",
    "signature": "public String getShortNameAsProperty(Class<?> clazz)",
    "source_code": "\tpublic static String getShortNameAsProperty(Class<?> clazz) {\n\t\tString shortName = getShortName(clazz);\n\t\tint dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);\n\t\tshortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);\n\t\treturn StringUtils.uncapitalizeAsProperty(shortName);\n\t}"
  },
  "org.springframework.util.ClassUtils#getStaticMethod(clazz,methodName,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a public static method of a class.\n\t * @param clazz the class which defines the method\n\t * @param methodName the static method name\n\t * @param args the parameter types to the method\n\t * @return the static method, or {@code null} if no static method was found\n\t * @throws IllegalArgumentException if the method name is blank or the clazz is null\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1563
    },
    "return": "Method",
    "signature": "public Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args)",
    "source_code": "\tpublic static @Nullable Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\ttry {\n\t\t\tMethod method = clazz.getMethod(methodName, args);\n\t\t\treturn (Modifier.isStatic(method.getModifiers()) ? method : null);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.util.ClassUtils#hasAtLeastOneMethodWithName(clazz,methodName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Does the given class or one of its superclasses at least have one or more\n\t * methods with the supplied name (with any argument types)?\n\t * Includes non-public methods.\n\t * @param clazz\tthe clazz to check\n\t * @param methodName the name of the method\n\t * @return whether there is at least one method with the given name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName"
    ],
    "position": {
      "column": 1,
      "line": 1315
    },
    "return": "boolean",
    "signature": "public boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName)",
    "source_code": "\tpublic static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\tMethod[] declaredMethods = clazz.getDeclaredMethods();\n\t\tfor (Method method : declaredMethods) {\n\t\t\tif (method.getName().equals(methodName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tClass<?>[] ifcs = clazz.getInterfaces();\n\t\tfor (Class<?> ifc : ifcs) {\n\t\t\tif (hasAtLeastOneMethodWithName(ifc, methodName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));\n\t}"
  },
  "org.springframework.util.ClassUtils#hasConstructor(clazz,paramTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class has a public constructor with the given signature.\n\t * <p>Essentially translates {@code NoSuchMethodException} to \"false\".\n\t * @param clazz the clazz to analyze\n\t * @param paramTypes the parameter types of the method\n\t * @return whether the class has a corresponding constructor\n\t * @see Class#getConstructor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "paramTypes"
    ],
    "position": {
      "column": 1,
      "line": 1159
    },
    "return": "boolean",
    "signature": "public boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes)",
    "source_code": "\tpublic static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {\n\t\treturn (getConstructorIfAvailable(clazz, paramTypes) != null);\n\t}"
  },
  "org.springframework.util.ClassUtils#hasMethod(clazz,method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class has a public method with the given signature.\n\t * @param clazz the clazz to analyze\n\t * @param method the method to look for\n\t * @return whether the class has a corresponding method\n\t * @since 5.2.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 1189
    },
    "return": "boolean",
    "signature": "public boolean hasMethod(Class<?> clazz, Method method)",
    "source_code": "\tpublic static boolean hasMethod(Class<?> clazz, Method method) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tif (clazz == method.getDeclaringClass()) {\n\t\t\treturn true;\n\t\t}\n\t\tString methodName = method.getName();\n\t\tClass<?>[] paramTypes = method.getParameterTypes();\n\t\treturn getMethodOrNull(clazz, methodName, paramTypes) != null;\n\t}"
  },
  "org.springframework.util.ClassUtils#hasMethod(clazz,methodName,paramTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class has a public method with the given signature.\n\t * <p>Essentially translates {@code NoSuchMethodException} to \"false\".\n\t * @param clazz the clazz to analyze\n\t * @param methodName the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * @return whether the class has a corresponding method\n\t * @see Class#getMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName",
      "paramTypes"
    ],
    "position": {
      "column": 1,
      "line": 1209
    },
    "return": "boolean",
    "signature": "public boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)",
    "source_code": "\tpublic static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n\t\treturn (getMethodIfAvailable(clazz, methodName, paramTypes) != null);\n\t}"
  },
  "org.springframework.util.ClassUtils#isAssignable(lhsType,rhsType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if the right-hand side type may be assigned to the left-hand side\n\t * type, assuming setting by reflection. Considers primitive wrapper\n\t * classes as assignable to the corresponding primitive types.\n\t * @param lhsType the target type (left-hand side (LHS) type)\n\t * @param rhsType the value type (right-hand side (RHS) type) that should\n\t * be assigned to the target type\n\t * @return {@code true} if {@code rhsType} is assignable to {@code lhsType}\n\t * @see TypeUtils#isAssignable(java.lang.reflect.Type, java.lang.reflect.Type)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lhsType",
      "rhsType"
    ],
    "position": {
      "column": 1,
      "line": 607
    },
    "return": "boolean",
    "signature": "public boolean isAssignable(Class<?> lhsType, Class<?> rhsType)",
    "source_code": "\tpublic static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {\n\t\tAssert.notNull(lhsType, \"Left-hand side type must not be null\");\n\t\tAssert.notNull(rhsType, \"Right-hand side type must not be null\");\n\t\tif (lhsType.isAssignableFrom(rhsType)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (lhsType.isPrimitive()) {\n\t\t\tClass<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);\n\t\t\treturn (lhsType == resolvedPrimitive);\n\t\t}\n\t\telse {\n\t\t\tClass<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);\n\t\t\treturn (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper));\n\t\t}\n\t}"
  },
  "org.springframework.util.ClassUtils#isAssignableValue(type,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the given type is assignable from the given value,\n\t * assuming setting by reflection. Considers primitive wrapper classes\n\t * as assignable to the corresponding primitive types.\n\t * @param type the target type\n\t * @param value the value that should be assigned to the type\n\t * @return if the type is assignable from the value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 631
    },
    "return": "boolean",
    "signature": "public boolean isAssignableValue(Class<?> type, @Nullable Object value)",
    "source_code": "\tpublic static boolean isAssignableValue(Class<?> type, @Nullable Object value) {\n\t\tAssert.notNull(type, \"Type must not be null\");\n\t\treturn (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());\n\t}"
  },
  "org.springframework.util.ClassUtils#isCacheSafe(clazz,classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given class is cache-safe in the given context,\n\t * i.e. whether it is loaded by the given ClassLoader or a parent of it.\n\t * @param clazz the class to analyze\n\t * @param classLoader the ClassLoader to potentially cache metadata in\n\t * (can be {@code null} which indicates the system class loader)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 413
    },
    "return": "boolean",
    "signature": "public boolean isCacheSafe(Class<?> clazz, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static boolean isCacheSafe(Class<?> clazz, @Nullable ClassLoader classLoader) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\ttry {\n\t\t\tClassLoader target = clazz.getClassLoader();\n\t\t\t// Common cases\n\t\t\tif (target == classLoader || target == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (classLoader == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// Check for match in ancestors -> positive\n\t\t\tClassLoader current = classLoader;\n\t\t\twhile (current != null) {\n\t\t\t\tcurrent = current.getParent();\n\t\t\t\tif (current == target) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check for match in children -> negative\n\t\t\twhile (target != null) {\n\t\t\t\ttarget = target.getParent();\n\t\t\t\tif (target == classLoader) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (SecurityException ex) {\n\t\t\t// Fall through to loadable check below\n\t\t}\n\n\t\t// Fallback for ClassLoaders without parent/child relationship:\n\t\t// safe if same Class can be loaded from given ClassLoader\n\t\treturn (classLoader != null && isLoadable(clazz, classLoader));\n\t}"
  },
  "org.springframework.util.ClassUtils#isCglibProxy(object)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given object is a CGLIB proxy.\n\t * @param object the object to check\n\t * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)\n\t * @deprecated as of 5.2, in favor of custom (possibly narrower) checks\n\t * such as for a Spring AOP proxy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object"
    ],
    "position": {
      "column": 1,
      "line": 945
    },
    "return": "boolean",
    "signature": "public boolean isCglibProxy(Object object)",
    "source_code": "\tpublic static boolean isCglibProxy(Object object) {\n\t\treturn isCglibProxyClass(object.getClass());\n\t}"
  },
  "org.springframework.util.ClassUtils#isCglibProxyClass(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the specified class is a CGLIB-generated class.\n\t * @param clazz the class to check\n\t * @see #getUserClass(Class)\n\t * @deprecated as of 5.2, in favor of custom (possibly narrower) checks\n\t * or simply a check for containing {@link #CGLIB_CLASS_SEPARATOR}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 957
    },
    "return": "boolean",
    "signature": "public boolean isCglibProxyClass(@Nullable Class<?> clazz)",
    "source_code": "\tpublic static boolean isCglibProxyClass(@Nullable Class<?> clazz) {\n\t\treturn (clazz != null && isCglibProxyClassName(clazz.getName()));\n\t}"
  },
  "org.springframework.util.ClassUtils#isCglibProxyClassName(className)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the specified class name is a CGLIB-generated class.\n\t * @param className the class name to check\n\t * @see #CGLIB_CLASS_SEPARATOR\n\t * @deprecated as of 5.2, in favor of custom (possibly narrower) checks\n\t * or simply a check for containing {@link #CGLIB_CLASS_SEPARATOR}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "className"
    ],
    "position": {
      "column": 1,
      "line": 969
    },
    "return": "boolean",
    "signature": "public boolean isCglibProxyClassName(@Nullable String className)",
    "source_code": "\tpublic static boolean isCglibProxyClassName(@Nullable String className) {\n\t\treturn (className != null && className.contains(CGLIB_CLASS_SEPARATOR));\n\t}"
  },
  "org.springframework.util.ClassUtils#isInnerClass(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied class is an <em>inner class</em>,\n\t * i.e. a non-static member of an enclosing class.\n\t * @return {@code true} if the supplied class is an inner class\n\t * @since 5.0.5\n\t * @see Class#isMemberClass()\n\t * @see #isStaticClass(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 919
    },
    "return": "boolean",
    "signature": "public boolean isInnerClass(Class<?> clazz)",
    "source_code": "\tpublic static boolean isInnerClass(Class<?> clazz) {\n\t\treturn (clazz.isMemberClass() && !isStaticClass(clazz));\n\t}"
  },
  "org.springframework.util.ClassUtils#isJavaLanguageInterface(ifc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given interface is a common Java language interface:\n\t * {@link Serializable}, {@link Externalizable}, {@link Closeable}, {@link AutoCloseable},\n\t * {@link Cloneable}, {@link Comparable} - all of which can be ignored when looking\n\t * for 'primary' user-level interfaces. Common characteristics: no service-level\n\t * operations, no bean property methods, no default methods.\n\t * @param ifc the interface to check\n\t * @since 5.0.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ifc"
    ],
    "position": {
      "column": 1,
      "line": 896
    },
    "return": "boolean",
    "signature": "public boolean isJavaLanguageInterface(Class<?> ifc)",
    "source_code": "\tpublic static boolean isJavaLanguageInterface(Class<?> ifc) {\n\t\treturn javaLanguageInterfaces.contains(ifc);\n\t}"
  },
  "org.springframework.util.ClassUtils#isLambdaClass(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied {@link Class} is a JVM-generated implementation\n\t * class for a lambda expression or method reference.\n\t * <p>This method makes a best-effort attempt at determining this, based on\n\t * checks that work on modern, mainstream JVMs.\n\t * @param clazz the class to check\n\t * @return {@code true} if the class is a lambda implementation class\n\t * @since 5.3.19\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 932
    },
    "return": "boolean",
    "signature": "public boolean isLambdaClass(Class<?> clazz)",
    "source_code": "\tpublic static boolean isLambdaClass(Class<?> clazz) {\n\t\treturn (clazz.isSynthetic() && (clazz.getSuperclass() == Object.class) &&\n\t\t\t\t(clazz.getInterfaces().length > 0) && clazz.getName().contains(\"$$Lambda\"));\n\t}"
  },
  "org.springframework.util.ClassUtils#isPresent(className,classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the {@link Class} identified by the supplied name is present\n\t * and can be loaded. Will return {@code false} if either the class or\n\t * one of its dependencies is not present or cannot be loaded.\n\t * @param className the name of the class to check\n\t * @param classLoader the class loader to use\n\t * (can be {@code null} which indicates the default class loader)\n\t * @return whether the specified class is present (including all of its\n\t * superclasses and interfaces)\n\t * @throws IllegalStateException if the corresponding class is resolvable but there\n\t * was a readability mismatch in the inheritance hierarchy of the class (typically a\n\t * missing dependency declaration in a Java Module System module definition for a\n\t * superclass or interface implemented by the class to be checked here)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "className",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 368
    },
    "return": "boolean",
    "signature": "public boolean isPresent(String className, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static boolean isPresent(String className, @Nullable ClassLoader classLoader) {\n\t\ttry {\n\t\t\tforName(className, classLoader);\n\t\t\treturn true;\n\t\t}\n\t\tcatch (IllegalAccessError err) {\n\t\t\tthrow new IllegalStateException(\"Readability mismatch in inheritance hierarchy of class [\" +\n\t\t\t\t\tclassName + \"]: \" + err.getMessage(), err);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// Typically ClassNotFoundException or NoClassDefFoundError...\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.util.ClassUtils#isPrimitiveArray(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if the given class represents an array of primitives,\n\t * i.e. boolean, byte, char, short, int, long, float, or double.\n\t * @param clazz the class to check\n\t * @return whether the given class is a primitive array class\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 519
    },
    "return": "boolean",
    "signature": "public boolean isPrimitiveArray(Class<?> clazz)",
    "source_code": "\tpublic static boolean isPrimitiveArray(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\treturn (clazz.isArray() && clazz.componentType().isPrimitive());\n\t}"
  },
  "org.springframework.util.ClassUtils#isPrimitiveOrWrapper(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if the given class represents a primitive (i.e. boolean, byte,\n\t * char, short, int, long, float, or double), {@code void}, or a wrapper for\n\t * those types (i.e. Boolean, Byte, Character, Short, Integer, Long, Float,\n\t * Double, or Void).\n\t * @param clazz the class to check\n\t * @return {@code true} if the given class represents a primitive, void, or\n\t * a wrapper class\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 508
    },
    "return": "boolean",
    "signature": "public boolean isPrimitiveOrWrapper(Class<?> clazz)",
    "source_code": "\tpublic static boolean isPrimitiveOrWrapper(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\treturn (clazz.isPrimitive() || isPrimitiveWrapper(clazz));\n\t}"
  },
  "org.springframework.util.ClassUtils#isPrimitiveWrapper(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if the given class represents a primitive wrapper,\n\t * i.e. Boolean, Byte, Character, Short, Integer, Long, Float, Double, or\n\t * Void.\n\t * @param clazz the class to check\n\t * @return whether the given class is a primitive wrapper class\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "boolean",
    "signature": "public boolean isPrimitiveWrapper(Class<?> clazz)",
    "source_code": "\tpublic static boolean isPrimitiveWrapper(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\treturn primitiveWrapperTypeMap.containsKey(clazz);\n\t}"
  },
  "org.springframework.util.ClassUtils#isPrimitiveWrapperArray(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if the given class represents an array of primitive wrappers,\n\t * i.e. Boolean, Byte, Character, Short, Integer, Long, Float, or Double.\n\t * @param clazz the class to check\n\t * @return whether the given class is a primitive wrapper array class\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 530
    },
    "return": "boolean",
    "signature": "public boolean isPrimitiveWrapperArray(Class<?> clazz)",
    "source_code": "\tpublic static boolean isPrimitiveWrapperArray(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\treturn (clazz.isArray() && isPrimitiveWrapper(clazz.componentType()));\n\t}"
  },
  "org.springframework.util.ClassUtils#isSimpleValueType(type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate for {@link org.springframework.beans.BeanUtils#isSimpleValueType}.\n\t * Also used by {@link ObjectUtils#nullSafeConciseToString}.\n\t * <p>Check if the given type represents a common \"simple\" value type:\n\t * primitive or primitive wrapper, {@link Enum}, {@link String} or other\n\t * {@link CharSequence}, {@link Number}, {@link Date}, {@link Temporal},\n\t * {@link ZoneId}, {@link TimeZone}, {@link File}, {@link Path}, {@link URI},\n\t * {@link URL}, {@link InetAddress}, {@link Charset}, {@link Currency},\n\t * {@link Locale}, {@link UUID}, {@link Pattern}, or {@link Class}.\n\t * <p>{@code Void} and {@code void} are not considered simple value types.\n\t * @param type the type to check\n\t * @return whether the given type represents a \"simple\" value type,\n\t * suggesting value-based data binding and {@code toString} output\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 574
    },
    "return": "boolean",
    "signature": "public boolean isSimpleValueType(Class<?> type)",
    "source_code": "\tpublic static boolean isSimpleValueType(Class<?> type) {\n\t\treturn (!isVoidType(type) &&\n\t\t\t\t(isPrimitiveOrWrapper(type) ||\n\t\t\t\tEnum.class.isAssignableFrom(type) ||\n\t\t\t\tCharSequence.class.isAssignableFrom(type) ||\n\t\t\t\tNumber.class.isAssignableFrom(type) ||\n\t\t\t\tDate.class.isAssignableFrom(type) ||\n\t\t\t\tTemporal.class.isAssignableFrom(type) ||\n\t\t\t\tZoneId.class.isAssignableFrom(type) ||\n\t\t\t\tTimeZone.class.isAssignableFrom(type) ||\n\t\t\t\tFile.class.isAssignableFrom(type) ||\n\t\t\t\tPath.class.isAssignableFrom(type) ||\n\t\t\t\tCharset.class.isAssignableFrom(type) ||\n\t\t\t\tCurrency.class.isAssignableFrom(type) ||\n\t\t\t\tInetAddress.class.isAssignableFrom(type) ||\n\t\t\t\tURI.class == type ||\n\t\t\t\tURL.class == type ||\n\t\t\t\tUUID.class == type ||\n\t\t\t\tLocale.class == type ||\n\t\t\t\tPattern.class == type ||\n\t\t\t\tClass.class == type));\n\t}"
  },
  "org.springframework.util.ClassUtils#isStaticClass(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied class is a static class.\n\t * @return {@code true} if the supplied class is a static class\n\t * @since 6.0\n\t * @see Modifier#isStatic(int)\n\t * @see #isInnerClass(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 907
    },
    "return": "boolean",
    "signature": "public boolean isStaticClass(Class<?> clazz)",
    "source_code": "\tpublic static boolean isStaticClass(Class<?> clazz) {\n\t\treturn Modifier.isStatic(clazz.getModifiers());\n\t}"
  },
  "org.springframework.util.ClassUtils#isUserLevelMethod(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given method is declared by the user or at least pointing to\n\t * a user-declared method.\n\t * <p>Checks {@link Method#isSynthetic()} (for implementation methods) as well as the\n\t * {@code GroovyObject} interface (for interface methods; on an implementation class,\n\t * implementations of the {@code GroovyObject} methods will be marked as synthetic anyway).\n\t * Note that, despite being synthetic, bridge methods ({@link Method#isBridge()}) are considered\n\t * as user-level methods since they are eventually pointing to a user-declared generic method.\n\t * @param method the method to check\n\t * @return {@code true} if the method can be considered as user-declared; {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 1530
    },
    "return": "boolean",
    "signature": "public boolean isUserLevelMethod(Method method)",
    "source_code": "\tpublic static boolean isUserLevelMethod(Method method) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\treturn (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));\n\t}"
  },
  "org.springframework.util.ClassUtils#isVisible(clazz,classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given class is visible in the given ClassLoader.\n\t * @param clazz the class to check (typically an interface)\n\t * @param classLoader the ClassLoader to check against\n\t * (can be {@code null} in which case this method will always return {@code true})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "boolean",
    "signature": "public boolean isVisible(Class<?> clazz, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static boolean isVisible(Class<?> clazz, @Nullable ClassLoader classLoader) {\n\t\tif (classLoader == null) {\n\t\t\treturn true;\n\t\t}\n\t\ttry {\n\t\t\tif (clazz.getClassLoader() == classLoader) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (SecurityException ex) {\n\t\t\t// Fall through to loadable check below\n\t\t}\n\n\t\t// Visible if same Class can be loaded from given ClassLoader\n\t\treturn isLoadable(clazz, classLoader);\n\t}"
  },
  "org.springframework.util.ClassUtils#isVoidType(type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the given type represents either {@code Void} or {@code void}.\n\t * @param type the type to check\n\t * @return {@code true} if the type represents {@code Void} or {@code void}\n\t * @since 6.1.4\n\t * @see Void\n\t * @see Void#TYPE\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 555
    },
    "return": "boolean",
    "signature": "public boolean isVoidType(@Nullable Class<?> type)",
    "source_code": "\tpublic static boolean isVoidType(@Nullable Class<?> type) {\n\t\treturn (type == void.class || type == Void.class);\n\t}"
  },
  "org.springframework.util.ClassUtils#matchesTypeName(clazz,typeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given class matches the user-specified type name.\n\t * @param clazz the class to check\n\t * @param typeName the type name to match\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "typeName"
    ],
    "position": {
      "column": 1,
      "line": 1032
    },
    "return": "boolean",
    "signature": "public boolean matchesTypeName(Class<?> clazz, @Nullable String typeName)",
    "source_code": "\tpublic static boolean matchesTypeName(Class<?> clazz, @Nullable String typeName) {\n\t\treturn (typeName != null &&\n\t\t\t\t(typeName.equals(clazz.getTypeName()) || typeName.equals(clazz.getSimpleName())));\n\t}"
  },
  "org.springframework.util.ClassUtils#overrideThreadContextClassLoader(classLoaderToUse)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Override the thread context ClassLoader with the environment's bean ClassLoader\n\t * if necessary, i.e. if the bean ClassLoader is not equivalent to the thread\n\t * context ClassLoader already.\n\t * @param classLoaderToUse the actual ClassLoader to use for the thread context\n\t * @return the original thread context ClassLoader, or {@code null} if not overridden\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoaderToUse"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "ClassLoader",
    "signature": "public ClassLoader overrideThreadContextClassLoader(@Nullable ClassLoader classLoaderToUse)",
    "source_code": "\tpublic static @Nullable ClassLoader overrideThreadContextClassLoader(@Nullable ClassLoader classLoaderToUse) {\n\t\tThread currentThread = Thread.currentThread();\n\t\tClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\n\t\tif (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {\n\t\t\tcurrentThread.setContextClassLoader(classLoaderToUse);\n\t\t\treturn threadContextClassLoader;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.util.FastByteArrayOutputStream": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A speedy alternative to {@link java.io.ByteArrayOutputStream}. Note that\n * this variant does <i>not</i> extend {@code ByteArrayOutputStream}, unlike\n * its sibling {@link ResizableByteArrayOutputStream}.\n *\n * <p>Unlike {@link java.io.ByteArrayOutputStream}, this implementation is backed\n * by a {@link java.util.ArrayDeque} of {@code byte[]} buffers instead of one\n * constantly resizing {@code byte[]}. It does not copy buffers when it gets expanded.\n *\n * <p>The initial buffer is only created when the stream is first written.\n * There is also no copying of the internal buffers if the stream's content is\n * extracted via the {@link #writeTo(OutputStream)} method.\n *\n * @author Craig Andrews\n * @author Juergen Hoeller\n * @since 4.2\n * @see #resize\n * @see ResizableByteArrayOutputStream\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class FastByteArrayOutputStream",
    "source_code": "public class FastByteArrayOutputStream extends OutputStream {\n\n\tprivate static final int DEFAULT_BLOCK_SIZE = 256;\n\n\n\t// The buffers used to store the content bytes\n\tprivate final Deque<byte[]> buffers = new ArrayDeque<>();\n\n\t// The size, in bytes, to use when allocating the first byte[]\n\tprivate final int initialBlockSize;\n\n\t// The size, in bytes, to use when allocating the next byte[]\n\tprivate int nextBlockSize = 0;\n\n\t// The number of bytes in previous buffers.\n\t// (The number of bytes in the current buffer is in 'index'.)\n\tprivate int alreadyBufferedSize = 0;\n\n\t// The index in the byte[] found at buffers.getLast() to be written next\n\tprivate int index = 0;\n\n\t// Is the stream closed?\n\tprivate boolean closed = false;\n\n\n\t/**\n\t * Create a new {@code FastByteArrayOutputStream} with the default initial\n\t * capacity of 256 bytes.\n\t */\n\tpublic FastByteArrayOutputStream() {\n\t\tthis(DEFAULT_BLOCK_SIZE);\n\t}\n\n\t/**\n\t * Create a new {@code FastByteArrayOutputStream} with the specified initial\n\t * capacity.\n\t * @param initialBlockSize the initial buffer size in bytes\n\t */\n\tpublic FastByteArrayOutputStream(int initialBlockSize) {\n\t\tAssert.isTrue(initialBlockSize > 0, \"Initial block size must be greater than 0\");\n\t\tthis.initialBlockSize = initialBlockSize;\n\t\tthis.nextBlockSize = initialBlockSize;\n\t}\n\n\n\t// Overridden methods\n\n\t@Override\n\tpublic void write(int datum) throws IOException {\n\t\tif (this.closed) {\n\t\t\tthrow new IOException(\"Stream closed\");\n\t\t}\n\t\tif (this.buffers.peekLast() == null || this.buffers.getLast().length == this.index) {\n\t\t\taddBuffer(1);\n\t\t}\n\t\t// store the byte\n\t\tthis.buffers.getLast()[this.index++] = (byte) datum;\n\t}\n\n\t@Override\n\tpublic void write(byte[] data, int offset, int length) throws IOException {\n\t\tif (offset < 0 || offset + length > data.length || length < 0) {\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\telse if (this.closed) {\n\t\t\tthrow new IOException(\"Stream closed\");\n\t\t}\n\t\telse {\n\t\t\tif (this.buffers.peekLast() == null || this.buffers.getLast().length == this.index) {\n\t\t\t\taddBuffer(length);\n\t\t\t}\n\t\t\tif (this.index + length > this.buffers.getLast().length) {\n\t\t\t\tint pos = offset;\n\t\t\t\tdo {\n\t\t\t\t\tif (this.index == this.buffers.getLast().length) {\n\t\t\t\t\t\taddBuffer(length);\n\t\t\t\t\t}\n\t\t\t\t\tint copyLength = this.buffers.getLast().length - this.index;\n\t\t\t\t\tif (length < copyLength) {\n\t\t\t\t\t\tcopyLength = length;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.arraycopy(data, pos, this.buffers.getLast(), this.index, copyLength);\n\t\t\t\t\tpos += copyLength;\n\t\t\t\t\tthis.index += copyLength;\n\t\t\t\t\tlength -= copyLength;\n\t\t\t\t}\n\t\t\t\twhile (length > 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// copy in the sub-array\n\t\t\t\tSystem.arraycopy(data, offset, this.buffers.getLast(), this.index, length);\n\t\t\t\tthis.index += length;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tthis.closed = true;\n\t}\n\n\t/**\n\t * Convert this stream's contents to a string by decoding the bytes using the\n\t * platform's default character set. The length of the new {@code String}\n\t * is a function of the character set, and hence may not be equal to the\n\t * size of the buffers.\n\t * <p>This method always replaces malformed-input and unmappable-character\n\t * sequences with the default replacement string for the platform's\n\t * default character set. The {@linkplain java.nio.charset.CharsetDecoder}\n\t * class should be used when more control over the decoding process is\n\t * required.\n\t * @return a String decoded from this stream's contents\n\t * @see #toString(Charset)\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn toString(Charset.defaultCharset());\n\t}\n\n\t/**\n\t * Convert this stream's contents to a string by decoding the bytes using the\n\t * specified {@link Charset}.\n\t * @param charset the {@link Charset} to use to decode the bytes\n\t * @return a String decoded from this stream's contents\n\t * @since 6.1.2\n\t * @see #toString()\n\t */\n\tpublic String toString(Charset charset) {\n\t\tif (size() == 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\tif (this.buffers.size() == 1) {\n\t\t\treturn new String(this.buffers.getFirst(), 0, this.index, charset);\n\t\t}\n\t\treturn new String(toByteArrayUnsafe(), charset);\n\t}\n\n\t// Custom methods\n\n\t/**\n\t * Return the number of bytes stored in this {@code FastByteArrayOutputStream}.\n\t */\n\tpublic int size() {\n\t\treturn (this.alreadyBufferedSize + this.index);\n\t}\n\n\t/**\n\t * Convert this stream's contents to a byte array and return the byte array.\n\t * <p>Also replaces the internal structures with the byte array to\n\t * conserve memory: if the byte array is being created anyway, we might\n\t * as well as use it. This approach also means that if this method is\n\t * called twice without any writes in the interim, the second call is\n\t * a no-op.\n\t * <p>This method is \"unsafe\" as it returns the internal buffer.\n\t * Callers should not modify the returned buffer.\n\t * @return the current contents of this stream as a byte array\n\t * @see #size()\n\t * @see #toByteArray()\n\t */\n\tpublic byte[] toByteArrayUnsafe() {\n\t\tint totalSize = size();\n\t\tif (totalSize == 0) {\n\t\t\treturn new byte[0];\n\t\t}\n\t\tresize(totalSize);\n\t\treturn this.buffers.getFirst();\n\t}\n\n\t/**\n\t * Create a newly allocated byte array.\n\t * <p>Its size is the current size of this output stream, and it will\n\t * contain the valid contents of the internal buffers.\n\t * @return the current contents of this stream as a byte array\n\t * @see #size()\n\t * @see #toByteArrayUnsafe()\n\t */\n\tpublic byte[] toByteArray() {\n\t\tbyte[] bytesUnsafe = toByteArrayUnsafe();\n\t\treturn bytesUnsafe.clone();\n\t}\n\n\t/**\n\t * Reset the contents of this {@code FastByteArrayOutputStream}.\n\t * <p>All currently accumulated output in the output stream is discarded.\n\t * The output stream can be used again.\n\t */\n\tpublic void reset() {\n\t\tthis.buffers.clear();\n\t\tthis.nextBlockSize = this.initialBlockSize;\n\t\tthis.closed = false;\n\t\tthis.index = 0;\n\t\tthis.alreadyBufferedSize = 0;\n\t}\n\n\t/**\n\t * Get an {@link InputStream} to retrieve the contents of this\n\t * {@code FastByteArrayOutputStream}.\n\t * <p>Note that if any methods are called on this {@code FastByteArrayOutputStream}\n\t * (including, but not limited to, any of the write methods, {@link #reset()},\n\t * {@link #toByteArray()}, and {@link #toByteArrayUnsafe()}) then the\n\t * {@code InputStream}'s behavior is undefined.\n\t * @return {@code  InputStream} of the contents of this {@code FastByteArrayOutputStream}\n\t */\n\tpublic InputStream getInputStream() {\n\t\treturn new FastByteArrayInputStream(this);\n\t}\n\n\t/**\n\t * Write the contents of this {@code FastByteArrayOutputStream} to the given\n\t * {@link OutputStream}.\n\t * @param out the OutputStream to write to\n\t */\n\tpublic void writeTo(OutputStream out) throws IOException {\n\t\tIterator<byte[]> it = this.buffers.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tbyte[] bytes = it.next();\n\t\t\tif (it.hasNext()) {\n\t\t\t\tout.write(bytes, 0, bytes.length);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout.write(bytes, 0, this.index);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Resize the internal buffer size to the specified capacity.\n\t * @param targetCapacity the desired size of the buffer\n\t * @throws IllegalArgumentException if the given capacity is smaller than\n\t * the actual size of the content stored in the buffer already\n\t * @see FastByteArrayOutputStream#size()\n\t */\n\tpublic void resize(int targetCapacity) {\n\t\tAssert.isTrue(targetCapacity >= size(), \"New capacity must not be smaller than current size\");\n\t\tif (this.buffers.peekFirst() == null) {\n\t\t\tthis.nextBlockSize = targetCapacity - size();\n\t\t}\n\t\telse if (size() == targetCapacity && this.buffers.getFirst().length == targetCapacity) {\n\t\t\t// do nothing - already at the targetCapacity\n\t\t}\n\t\telse {\n\t\t\tint totalSize = size();\n\t\t\tbyte[] data = new byte[targetCapacity];\n\t\t\tint pos = 0;\n\t\t\tIterator<byte[]> it = this.buffers.iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tbyte[] bytes = it.next();\n\t\t\t\tif (it.hasNext()) {\n\t\t\t\t\tSystem.arraycopy(bytes, 0, data, pos, bytes.length);\n\t\t\t\t\tpos += bytes.length;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.arraycopy(bytes, 0, data, pos, this.index);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.buffers.clear();\n\t\t\tthis.buffers.add(data);\n\t\t\tthis.index = totalSize;\n\t\t\tthis.alreadyBufferedSize = 0;\n\t\t}\n\t}\n\n\t/**\n\t * Create a new buffer and store it in the ArrayDeque.\n\t * <p>Adds a new buffer that can store at least {@code minCapacity} bytes.\n\t */\n\tprivate void addBuffer(int minCapacity) {\n\t\tif (this.buffers.peekLast() != null) {\n\t\t\tthis.alreadyBufferedSize += this.index;\n\t\t\tthis.index = 0;\n\t\t}\n\t\tif (this.nextBlockSize < minCapacity) {\n\t\t\tthis.nextBlockSize = nextPowerOf2(minCapacity);\n\t\t}\n\t\tthis.buffers.add(new byte[this.nextBlockSize]);\n\t\tthis.nextBlockSize *= 2;  // block size doubles each time\n\t}\n\n\t/**\n\t * Get the next power of 2 of a number (ex, the next power of 2 of 119 is 128).\n\t */\n\tprivate static int nextPowerOf2(int val) {\n\t\tval--;\n\t\tval = (val >> 1) | val;\n\t\tval = (val >> 2) | val;\n\t\tval = (val >> 4) | val;\n\t\tval = (val >> 8) | val;\n\t\tval = (val >> 16) | val;\n\t\tval++;\n\t\treturn val;\n\t}\n\n\n\t/**\n\t * An implementation of {@link java.io.InputStream} that reads from a given\n\t * {@code FastByteArrayOutputStream}.\n\t */\n\tprivate static final class FastByteArrayInputStream extends UpdateMessageDigestInputStream {\n\n\t\tprivate final FastByteArrayOutputStream fastByteArrayOutputStream;\n\n\t\tprivate final Iterator<byte[]> buffersIterator;\n\n\t\tprivate byte @Nullable [] currentBuffer;\n\n\t\tprivate int currentBufferLength = 0;\n\n\t\tprivate int nextIndexInCurrentBuffer = 0;\n\n\t\tprivate int totalBytesRead = 0;\n\n\t\t/**\n\t\t * Create a new {@code FastByteArrayInputStream} backed by the given\n\t\t * {@code FastByteArrayOutputStream}.\n\t\t */\n\t\tpublic FastByteArrayInputStream(FastByteArrayOutputStream fastByteArrayOutputStream) {\n\t\t\tthis.fastByteArrayOutputStream = fastByteArrayOutputStream;\n\t\t\tthis.buffersIterator = fastByteArrayOutputStream.buffers.iterator();\n\t\t\tif (this.buffersIterator.hasNext()) {\n\t\t\t\tthis.currentBuffer = this.buffersIterator.next();\n\t\t\t\tif (this.currentBuffer == fastByteArrayOutputStream.buffers.getLast()) {\n\t\t\t\t\tthis.currentBufferLength = fastByteArrayOutputStream.index;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.currentBufferLength = (this.currentBuffer != null ? this.currentBuffer.length : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int read() {\n\t\t\tif (this.currentBuffer == null) {\n\t\t\t\t// This stream doesn't have any data in it...\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\n\t\t\t\tthis.totalBytesRead++;\n\t\t\t\treturn this.currentBuffer[this.nextIndexInCurrentBuffer++] & 0xFF;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this.buffersIterator.hasNext()) {\n\t\t\t\t\tthis.currentBuffer = this.buffersIterator.next();\n\t\t\t\t\tupdateCurrentBufferLength();\n\t\t\t\t\tthis.nextIndexInCurrentBuffer = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.currentBuffer = null;\n\t\t\t\t}\n\t\t\t\treturn read();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int read(byte[] b) {\n\t\t\treturn read(b, 0, b.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic int read(byte[] b, int off, int len) {\n\t\t\tif (off < 0 || len < 0 || len > b.length - off) {\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\t}\n\t\t\telse if (len == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this.currentBuffer == null) {\n\t\t\t\t\t// This stream doesn't have any data in it...\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\n\t\t\t\t\t\tint bytesToCopy = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);\n\t\t\t\t\t\tSystem.arraycopy(this.currentBuffer, this.nextIndexInCurrentBuffer, b, off, bytesToCopy);\n\t\t\t\t\t\tthis.totalBytesRead += bytesToCopy;\n\t\t\t\t\t\tthis.nextIndexInCurrentBuffer += bytesToCopy;\n\t\t\t\t\t\tint remaining = read(b, off + bytesToCopy, len - bytesToCopy);\n\t\t\t\t\t\treturn bytesToCopy + Math.max(remaining, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (this.buffersIterator.hasNext()) {\n\t\t\t\t\t\t\tthis.currentBuffer = this.buffersIterator.next();\n\t\t\t\t\t\t\tupdateCurrentBufferLength();\n\t\t\t\t\t\t\tthis.nextIndexInCurrentBuffer = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis.currentBuffer = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn read(b, off, len);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic long skip(long n) throws IOException {\n\t\t\tif (n > Integer.MAX_VALUE) {\n\t\t\t\tthrow new IllegalArgumentException(\"n exceeds maximum (\" + Integer.MAX_VALUE + \"): \" + n);\n\t\t\t}\n\t\t\telse if (n == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse if (n < 0) {\n\t\t\t\tthrow new IllegalArgumentException(\"n must be 0 or greater: \" + n);\n\t\t\t}\n\t\t\tint len = (int) n;\n\t\t\tif (this.currentBuffer == null) {\n\t\t\t\t// This stream doesn't have any data in it...\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\n\t\t\t\t\tint bytesToSkip = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);\n\t\t\t\t\tthis.totalBytesRead += bytesToSkip;\n\t\t\t\t\tthis.nextIndexInCurrentBuffer += bytesToSkip;\n\t\t\t\t\treturn (bytesToSkip + skip(len - bytesToSkip));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (this.buffersIterator.hasNext()) {\n\t\t\t\t\t\tthis.currentBuffer = this.buffersIterator.next();\n\t\t\t\t\t\tupdateCurrentBufferLength();\n\t\t\t\t\t\tthis.nextIndexInCurrentBuffer = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.currentBuffer = null;\n\t\t\t\t\t}\n\t\t\t\t\treturn skip(len);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int available() {\n\t\t\treturn (this.fastByteArrayOutputStream.size() - this.totalBytesRead);\n\t\t}\n\n\t\t/**\n\t\t * Update the message digest with the remaining bytes in this stream.\n\t\t * @param messageDigest the message digest to update\n\t\t */\n\t\t@Override\n\t\tpublic void updateMessageDigest(MessageDigest messageDigest) {\n\t\t\tupdateMessageDigest(messageDigest, available());\n\t\t}\n\n\t\t/**\n\t\t * Update the message digest with the next len bytes in this stream.\n\t\t * Avoids creating new byte arrays and use internal buffers for performance.\n\t\t * @param messageDigest the message digest to update\n\t\t * @param len how many bytes to read from this stream and use to update the message digest\n\t\t */\n\t\t@Override\n\t\tpublic void updateMessageDigest(MessageDigest messageDigest, int len) {\n\t\t\tif (this.currentBuffer == null) {\n\t\t\t\t// This stream doesn't have any data in it...\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (len == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (len < 0) {\n\t\t\t\tthrow new IllegalArgumentException(\"len must be 0 or greater: \" + len);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\n\t\t\t\t\tint bytesToCopy = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);\n\t\t\t\t\tmessageDigest.update(this.currentBuffer, this.nextIndexInCurrentBuffer, bytesToCopy);\n\t\t\t\t\tthis.nextIndexInCurrentBuffer += bytesToCopy;\n\t\t\t\t\tupdateMessageDigest(messageDigest, len - bytesToCopy);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (this.buffersIterator.hasNext()) {\n\t\t\t\t\t\tthis.currentBuffer = this.buffersIterator.next();\n\t\t\t\t\t\tupdateCurrentBufferLength();\n\t\t\t\t\t\tthis.nextIndexInCurrentBuffer = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.currentBuffer = null;\n\t\t\t\t\t}\n\t\t\t\t\tupdateMessageDigest(messageDigest, len);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void updateCurrentBufferLength() {\n\t\t\tif (this.currentBuffer == this.fastByteArrayOutputStream.buffers.getLast()) {\n\t\t\t\tthis.currentBufferLength = this.fastByteArrayOutputStream.index;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.currentBufferLength = (this.currentBuffer != null ? this.currentBuffer.length : 0);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.util.FastByteArrayOutputStream#available()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 481
    },
    "return": "int",
    "signature": "public int available()",
    "source_code": "\t\tpublic int available() {\n\t\t\treturn (this.fastByteArrayOutputStream.size() - this.totalBytesRead);\n\t\t}"
  },
  "org.springframework.util.FastByteArrayOutputStream#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\tpublic void close() {\n\t\tthis.closed = true;\n\t}"
  },
  "org.springframework.util.FastByteArrayOutputStream#getInputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get an {@link InputStream} to retrieve the contents of this\n\t * {@code FastByteArrayOutputStream}.\n\t * <p>Note that if any methods are called on this {@code FastByteArrayOutputStream}\n\t * (including, but not limited to, any of the write methods, {@link #reset()},\n\t * {@link #toByteArray()}, and {@link #toByteArrayUnsafe()}) then the\n\t * {@code InputStream}'s behavior is undefined.\n\t * @return {@code  InputStream} of the contents of this {@code FastByteArrayOutputStream}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "InputStream",
    "signature": "public InputStream getInputStream()",
    "source_code": "\tpublic InputStream getInputStream() {\n\t\treturn new FastByteArrayInputStream(this);\n\t}"
  },
  "org.springframework.util.FastByteArrayOutputStream#read()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "int",
    "signature": "public int read()",
    "source_code": "\t\tpublic int read() {\n\t\t\tif (this.currentBuffer == null) {\n\t\t\t\t// This stream doesn't have any data in it...\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\n\t\t\t\tthis.totalBytesRead++;\n\t\t\t\treturn this.currentBuffer[this.nextIndexInCurrentBuffer++] & 0xFF;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this.buffersIterator.hasNext()) {\n\t\t\t\t\tthis.currentBuffer = this.buffersIterator.next();\n\t\t\t\t\tupdateCurrentBufferLength();\n\t\t\t\t\tthis.nextIndexInCurrentBuffer = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.currentBuffer = null;\n\t\t\t\t}\n\t\t\t\treturn read();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.util.FastByteArrayOutputStream#read(b)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b"
    ],
    "position": {
      "column": 1,
      "line": 402
    },
    "return": "int",
    "signature": "public int read(byte[] b)",
    "source_code": "\t\tpublic int read(byte[] b) {\n\t\t\treturn read(b, 0, b.length);\n\t\t}"
  },
  "org.springframework.util.FastByteArrayOutputStream#read(b,off,len)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 407
    },
    "return": "int",
    "signature": "public int read(byte[] b, int off, int len)",
    "source_code": "\t\tpublic int read(byte[] b, int off, int len) {\n\t\t\tif (off < 0 || len < 0 || len > b.length - off) {\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\t}\n\t\t\telse if (len == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this.currentBuffer == null) {\n\t\t\t\t\t// This stream doesn't have any data in it...\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\n\t\t\t\t\t\tint bytesToCopy = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);\n\t\t\t\t\t\tSystem.arraycopy(this.currentBuffer, this.nextIndexInCurrentBuffer, b, off, bytesToCopy);\n\t\t\t\t\t\tthis.totalBytesRead += bytesToCopy;\n\t\t\t\t\t\tthis.nextIndexInCurrentBuffer += bytesToCopy;\n\t\t\t\t\t\tint remaining = read(b, off + bytesToCopy, len - bytesToCopy);\n\t\t\t\t\t\treturn bytesToCopy + Math.max(remaining, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (this.buffersIterator.hasNext()) {\n\t\t\t\t\t\t\tthis.currentBuffer = this.buffersIterator.next();\n\t\t\t\t\t\t\tupdateCurrentBufferLength();\n\t\t\t\t\t\t\tthis.nextIndexInCurrentBuffer = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis.currentBuffer = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn read(b, off, len);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.util.FastByteArrayOutputStream#reset()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset the contents of this {@code FastByteArrayOutputStream}.\n\t * <p>All currently accumulated output in the output stream is discarded.\n\t * The output stream can be used again.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "void",
    "signature": "public void reset()",
    "source_code": "\tpublic void reset() {\n\t\tthis.buffers.clear();\n\t\tthis.nextBlockSize = this.initialBlockSize;\n\t\tthis.closed = false;\n\t\tthis.index = 0;\n\t\tthis.alreadyBufferedSize = 0;\n\t}"
  },
  "org.springframework.util.FastByteArrayOutputStream#resize(targetCapacity)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resize the internal buffer size to the specified capacity.\n\t * @param targetCapacity the desired size of the buffer\n\t * @throws IllegalArgumentException if the given capacity is smaller than\n\t * the actual size of the content stored in the buffer already\n\t * @see FastByteArrayOutputStream#size()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetCapacity"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "void",
    "signature": "public void resize(int targetCapacity)",
    "source_code": "\tpublic void resize(int targetCapacity) {\n\t\tAssert.isTrue(targetCapacity >= size(), \"New capacity must not be smaller than current size\");\n\t\tif (this.buffers.peekFirst() == null) {\n\t\t\tthis.nextBlockSize = targetCapacity - size();\n\t\t}\n\t\telse if (size() == targetCapacity && this.buffers.getFirst().length == targetCapacity) {\n\t\t\t// do nothing - already at the targetCapacity\n\t\t}\n\t\telse {\n\t\t\tint totalSize = size();\n\t\t\tbyte[] data = new byte[targetCapacity];\n\t\t\tint pos = 0;\n\t\t\tIterator<byte[]> it = this.buffers.iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tbyte[] bytes = it.next();\n\t\t\t\tif (it.hasNext()) {\n\t\t\t\t\tSystem.arraycopy(bytes, 0, data, pos, bytes.length);\n\t\t\t\t\tpos += bytes.length;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.arraycopy(bytes, 0, data, pos, this.index);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.buffers.clear();\n\t\t\tthis.buffers.add(data);\n\t\t\tthis.index = totalSize;\n\t\t\tthis.alreadyBufferedSize = 0;\n\t\t}\n\t}"
  },
  "org.springframework.util.FastByteArrayOutputStream#size()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the number of bytes stored in this {@code FastByteArrayOutputStream}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\tpublic int size() {\n\t\treturn (this.alreadyBufferedSize + this.index);\n\t}"
  },
  "org.springframework.util.FastByteArrayOutputStream#skip(n)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "n"
    ],
    "position": {
      "column": 1,
      "line": 444
    },
    "return": "long",
    "signature": "public long skip(long n)",
    "source_code": "\t\tpublic long skip(long n) throws IOException {\n\t\t\tif (n > Integer.MAX_VALUE) {\n\t\t\t\tthrow new IllegalArgumentException(\"n exceeds maximum (\" + Integer.MAX_VALUE + \"): \" + n);\n\t\t\t}\n\t\t\telse if (n == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse if (n < 0) {\n\t\t\t\tthrow new IllegalArgumentException(\"n must be 0 or greater: \" + n);\n\t\t\t}\n\t\t\tint len = (int) n;\n\t\t\tif (this.currentBuffer == null) {\n\t\t\t\t// This stream doesn't have any data in it...\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\n\t\t\t\t\tint bytesToSkip = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);\n\t\t\t\t\tthis.totalBytesRead += bytesToSkip;\n\t\t\t\t\tthis.nextIndexInCurrentBuffer += bytesToSkip;\n\t\t\t\t\treturn (bytesToSkip + skip(len - bytesToSkip));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (this.buffersIterator.hasNext()) {\n\t\t\t\t\t\tthis.currentBuffer = this.buffersIterator.next();\n\t\t\t\t\t\tupdateCurrentBufferLength();\n\t\t\t\t\t\tthis.nextIndexInCurrentBuffer = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.currentBuffer = null;\n\t\t\t\t\t}\n\t\t\t\t\treturn skip(len);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.util.FastByteArrayOutputStream#toByteArray()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a newly allocated byte array.\n\t * <p>Its size is the current size of this output stream, and it will\n\t * contain the valid contents of the internal buffers.\n\t * @return the current contents of this stream as a byte array\n\t * @see #size()\n\t * @see #toByteArrayUnsafe()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "byte[]",
    "signature": "public byte[] toByteArray()",
    "source_code": "\tpublic byte[] toByteArray() {\n\t\tbyte[] bytesUnsafe = toByteArrayUnsafe();\n\t\treturn bytesUnsafe.clone();\n\t}"
  },
  "org.springframework.util.FastByteArrayOutputStream#toByteArrayUnsafe()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert this stream's contents to a byte array and return the byte array.\n\t * <p>Also replaces the internal structures with the byte array to\n\t * conserve memory: if the byte array is being created anyway, we might\n\t * as well as use it. This approach also means that if this method is\n\t * called twice without any writes in the interim, the second call is\n\t * a no-op.\n\t * <p>This method is \"unsafe\" as it returns the internal buffer.\n\t * Callers should not modify the returned buffer.\n\t * @return the current contents of this stream as a byte array\n\t * @see #size()\n\t * @see #toByteArray()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "byte[]",
    "signature": "public byte[] toByteArrayUnsafe()",
    "source_code": "\tpublic byte[] toByteArrayUnsafe() {\n\t\tint totalSize = size();\n\t\tif (totalSize == 0) {\n\t\t\treturn new byte[0];\n\t\t}\n\t\tresize(totalSize);\n\t\treturn this.buffers.getFirst();\n\t}"
  },
  "org.springframework.util.FastByteArrayOutputStream#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert this stream's contents to a string by decoding the bytes using the\n\t * platform's default character set. The length of the new {@code String}\n\t * is a function of the character set, and hence may not be equal to the\n\t * size of the buffers.\n\t * <p>This method always replaces malformed-input and unmappable-character\n\t * sequences with the default replacement string for the platform's\n\t * default character set. The {@linkplain java.nio.charset.CharsetDecoder}\n\t * class should be used when more control over the decoding process is\n\t * required.\n\t * @return a String decoded from this stream's contents\n\t * @see #toString(Charset)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn toString(Charset.defaultCharset());\n\t}"
  },
  "org.springframework.util.FastByteArrayOutputStream#toString(charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert this stream's contents to a string by decoding the bytes using the\n\t * specified {@link Charset}.\n\t * @param charset the {@link Charset} to use to decode the bytes\n\t * @return a String decoded from this stream's contents\n\t * @since 6.1.2\n\t * @see #toString()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "String",
    "signature": "public String toString(Charset charset)",
    "source_code": "\tpublic String toString(Charset charset) {\n\t\tif (size() == 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\tif (this.buffers.size() == 1) {\n\t\t\treturn new String(this.buffers.getFirst(), 0, this.index, charset);\n\t\t}\n\t\treturn new String(toByteArrayUnsafe(), charset);\n\t}"
  },
  "org.springframework.util.FastByteArrayOutputStream#updateMessageDigest(messageDigest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Update the message digest with the remaining bytes in this stream.\n\t\t * @param messageDigest the message digest to update\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageDigest"
    ],
    "position": {
      "column": 1,
      "line": 490
    },
    "return": "void",
    "signature": "public void updateMessageDigest(MessageDigest messageDigest)",
    "source_code": "\t\tpublic void updateMessageDigest(MessageDigest messageDigest) {\n\t\t\tupdateMessageDigest(messageDigest, available());\n\t\t}"
  },
  "org.springframework.util.FastByteArrayOutputStream#updateMessageDigest(messageDigest,len)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Update the message digest with the next len bytes in this stream.\n\t\t * Avoids creating new byte arrays and use internal buffers for performance.\n\t\t * @param messageDigest the message digest to update\n\t\t * @param len how many bytes to read from this stream and use to update the message digest\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageDigest",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 501
    },
    "return": "void",
    "signature": "public void updateMessageDigest(MessageDigest messageDigest, int len)",
    "source_code": "\t\tpublic void updateMessageDigest(MessageDigest messageDigest, int len) {\n\t\t\tif (this.currentBuffer == null) {\n\t\t\t\t// This stream doesn't have any data in it...\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (len == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (len < 0) {\n\t\t\t\tthrow new IllegalArgumentException(\"len must be 0 or greater: \" + len);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\n\t\t\t\t\tint bytesToCopy = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);\n\t\t\t\t\tmessageDigest.update(this.currentBuffer, this.nextIndexInCurrentBuffer, bytesToCopy);\n\t\t\t\t\tthis.nextIndexInCurrentBuffer += bytesToCopy;\n\t\t\t\t\tupdateMessageDigest(messageDigest, len - bytesToCopy);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (this.buffersIterator.hasNext()) {\n\t\t\t\t\t\tthis.currentBuffer = this.buffersIterator.next();\n\t\t\t\t\t\tupdateCurrentBufferLength();\n\t\t\t\t\t\tthis.nextIndexInCurrentBuffer = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.currentBuffer = null;\n\t\t\t\t\t}\n\t\t\t\t\tupdateMessageDigest(messageDigest, len);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.util.FastByteArrayOutputStream#write(data,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "data",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void write(byte[] data, int offset, int length)",
    "source_code": "\tpublic void write(byte[] data, int offset, int length) throws IOException {\n\t\tif (offset < 0 || offset + length > data.length || length < 0) {\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\telse if (this.closed) {\n\t\t\tthrow new IOException(\"Stream closed\");\n\t\t}\n\t\telse {\n\t\t\tif (this.buffers.peekLast() == null || this.buffers.getLast().length == this.index) {\n\t\t\t\taddBuffer(length);\n\t\t\t}\n\t\t\tif (this.index + length > this.buffers.getLast().length) {\n\t\t\t\tint pos = offset;\n\t\t\t\tdo {\n\t\t\t\t\tif (this.index == this.buffers.getLast().length) {\n\t\t\t\t\t\taddBuffer(length);\n\t\t\t\t\t}\n\t\t\t\t\tint copyLength = this.buffers.getLast().length - this.index;\n\t\t\t\t\tif (length < copyLength) {\n\t\t\t\t\t\tcopyLength = length;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.arraycopy(data, pos, this.buffers.getLast(), this.index, copyLength);\n\t\t\t\t\tpos += copyLength;\n\t\t\t\t\tthis.index += copyLength;\n\t\t\t\t\tlength -= copyLength;\n\t\t\t\t}\n\t\t\t\twhile (length > 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// copy in the sub-array\n\t\t\t\tSystem.arraycopy(data, offset, this.buffers.getLast(), this.index, length);\n\t\t\t\tthis.index += length;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.FastByteArrayOutputStream#write(datum)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "datum"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "public void write(int datum)",
    "source_code": "\tpublic void write(int datum) throws IOException {\n\t\tif (this.closed) {\n\t\t\tthrow new IOException(\"Stream closed\");\n\t\t}\n\t\tif (this.buffers.peekLast() == null || this.buffers.getLast().length == this.index) {\n\t\t\taddBuffer(1);\n\t\t}\n\t\t// store the byte\n\t\tthis.buffers.getLast()[this.index++] = (byte) datum;\n\t}"
  },
  "org.springframework.util.FastByteArrayOutputStream#writeTo(out)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Write the contents of this {@code FastByteArrayOutputStream} to the given\n\t * {@link OutputStream}.\n\t * @param out the OutputStream to write to\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "out"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "void",
    "signature": "public void writeTo(OutputStream out)",
    "source_code": "\tpublic void writeTo(OutputStream out) throws IOException {\n\t\tIterator<byte[]> it = this.buffers.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tbyte[] bytes = it.next();\n\t\t\tif (it.hasNext()) {\n\t\t\t\tout.write(bytes, 0, bytes.length);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout.write(bytes, 0, this.index);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.MethodInvoker": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Helper class that allows for specifying a method to invoke in a declarative\n * fashion, be it static or non-static.\n *\n * <p>Usage: Specify \"targetClass\"/\"targetMethod\" or \"targetObject\"/\"targetMethod\",\n * optionally specify arguments, prepare the invoker. Afterwards, you may\n * invoke the method any number of times, obtaining the invocation result.\n *\n * @author Colin Sampaleanu\n * @author Juergen Hoeller\n * @since 19.02.2004\n * @see #prepare\n * @see #invoke\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class MethodInvoker",
    "source_code": "public class MethodInvoker {\n\n\tprivate static final Object[] EMPTY_ARGUMENTS = new Object[0];\n\n\n\tprotected @Nullable Class<?> targetClass;\n\n\tprivate @Nullable Object targetObject;\n\n\tprivate @Nullable String targetMethod;\n\n\tprivate @Nullable String staticMethod;\n\n\tprivate @Nullable Object @Nullable [] arguments;\n\n\t/** The method we will call. */\n\tprivate @Nullable Method methodObject;\n\n\n\t/**\n\t * Set the target class on which to call the target method.\n\t * Only necessary when the target method is static; else,\n\t * a target object needs to be specified anyway.\n\t * @see #setTargetObject\n\t * @see #setTargetMethod\n\t */\n\tpublic void setTargetClass(@Nullable Class<?> targetClass) {\n\t\tthis.targetClass = targetClass;\n\t}\n\n\t/**\n\t * Return the target class on which to call the target method.\n\t */\n\tpublic @Nullable Class<?> getTargetClass() {\n\t\treturn this.targetClass;\n\t}\n\n\t/**\n\t * Set the target object on which to call the target method.\n\t * Only necessary when the target method is not static;\n\t * else, a target class is sufficient.\n\t * @see #setTargetClass\n\t * @see #setTargetMethod\n\t */\n\tpublic void setTargetObject(@Nullable Object targetObject) {\n\t\tthis.targetObject = targetObject;\n\t\tif (targetObject != null) {\n\t\t\tthis.targetClass = targetObject.getClass();\n\t\t}\n\t}\n\n\t/**\n\t * Return the target object on which to call the target method.\n\t */\n\tpublic @Nullable Object getTargetObject() {\n\t\treturn this.targetObject;\n\t}\n\n\t/**\n\t * Set the name of the method to be invoked.\n\t * Refers to either a static method or a non-static method,\n\t * depending on a target object being set.\n\t * @see #setTargetClass\n\t * @see #setTargetObject\n\t */\n\tpublic void setTargetMethod(@Nullable String targetMethod) {\n\t\tthis.targetMethod = targetMethod;\n\t}\n\n\t/**\n\t * Return the name of the method to be invoked.\n\t */\n\tpublic @Nullable String getTargetMethod() {\n\t\treturn this.targetMethod;\n\t}\n\n\t/**\n\t * Set a fully qualified static method name to invoke,\n\t * for example, \"example.MyExampleClass.myExampleMethod\". This is a\n\t * convenient alternative to specifying targetClass and targetMethod.\n\t * @see #setTargetClass\n\t * @see #setTargetMethod\n\t */\n\tpublic void setStaticMethod(String staticMethod) {\n\t\tthis.staticMethod = staticMethod;\n\t}\n\n\t/**\n\t * Set arguments for the method invocation. If this property is not set,\n\t * or the Object array is of length 0, a method with no arguments is assumed.\n\t */\n\tpublic void setArguments(@Nullable Object... arguments) {\n\t\tthis.arguments = arguments;\n\t}\n\n\t/**\n\t * Return the arguments for the method invocation.\n\t */\n\tpublic @Nullable Object[] getArguments() {\n\t\treturn (this.arguments != null ? this.arguments : EMPTY_ARGUMENTS);\n\t}\n\n\n\t/**\n\t * Prepare the specified method.\n\t * The method can be invoked any number of times afterwards.\n\t * @see #getPreparedMethod\n\t * @see #invoke\n\t */\n\tpublic void prepare() throws ClassNotFoundException, NoSuchMethodException {\n\t\tif (this.staticMethod != null) {\n\t\t\tint lastDotIndex = this.staticMethod.lastIndexOf('.');\n\t\t\tif (lastDotIndex == -1 || lastDotIndex == this.staticMethod.length() - 1) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"staticMethod must be a fully qualified class plus method name: \" +\n\t\t\t\t\t\t\"for example, 'example.MyExampleClass.myExampleMethod'\");\n\t\t\t}\n\t\t\tString className = this.staticMethod.substring(0, lastDotIndex);\n\t\t\tString methodName = this.staticMethod.substring(lastDotIndex + 1);\n\t\t\tif (this.targetClass == null || !this.targetClass.getName().equals(className)) {\n\t\t\t\tthis.targetClass = resolveClassName(className);\n\t\t\t}\n\t\t\tthis.targetMethod = methodName;\n\t\t}\n\n\t\tClass<?> targetClass = getTargetClass();\n\t\tString targetMethod = getTargetMethod();\n\t\tAssert.notNull(targetClass, \"Either 'targetClass' or 'targetObject' is required\");\n\t\tAssert.notNull(targetMethod, \"Property 'targetMethod' is required\");\n\n\t\t@Nullable Object[] arguments = getArguments();\n\t\tClass<?>[] argTypes = new Class<?>[arguments.length];\n\t\tfor (int i = 0; i < arguments.length; ++i) {\n\t\t\targTypes[i] = (arguments[i] != null ? arguments[i].getClass() : Object.class);\n\t\t}\n\n\t\t// Try to get the exact method first.\n\t\ttry {\n\t\t\tthis.methodObject = targetClass.getMethod(targetMethod, argTypes);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\t// Just rethrow exception if we can't get any match.\n\t\t\tthis.methodObject = findMatchingMethod();\n\t\t\tif (this.methodObject == null) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Resolve the given class name into a Class.\n\t * <p>The default implementations uses {@code ClassUtils.forName},\n\t * using the thread context class loader.\n\t * @param className the class name to resolve\n\t * @return the resolved Class\n\t * @throws ClassNotFoundException if the class name was invalid\n\t */\n\tprotected Class<?> resolveClassName(String className) throws ClassNotFoundException {\n\t\treturn ClassUtils.forName(className, ClassUtils.getDefaultClassLoader());\n\t}\n\n\t/**\n\t * Find a matching method with the specified name for the specified arguments.\n\t * @return a matching method, or {@code null} if none\n\t * @see #getTargetClass()\n\t * @see #getTargetMethod()\n\t * @see #getArguments()\n\t */\n\tprotected @Nullable Method findMatchingMethod() {\n\t\tString targetMethod = getTargetMethod();\n\t\t@Nullable Object[] arguments = getArguments();\n\t\tint argCount = arguments.length;\n\n\t\tClass<?> targetClass = getTargetClass();\n\t\tAssert.state(targetClass != null, \"No target class set\");\n\t\tMethod[] candidates = ReflectionUtils.getAllDeclaredMethods(targetClass);\n\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n\t\tMethod matchingMethod = null;\n\n\t\tfor (Method candidate : candidates) {\n\t\t\tif (candidate.getName().equals(targetMethod) && candidate.getParameterCount() == argCount) {\n\t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n\t\t\t\tint typeDiffWeight = getTypeDifferenceWeight(paramTypes, arguments);\n\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n\t\t\t\t\tmatchingMethod = candidate;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn matchingMethod;\n\t}\n\n\t/**\n\t * Return the prepared Method object that will be invoked.\n\t * <p>Can for example be used to determine the return type.\n\t * @return the prepared Method object (never {@code null})\n\t * @throws IllegalStateException if the invoker hasn't been prepared yet\n\t * @see #prepare\n\t * @see #invoke\n\t */\n\tpublic Method getPreparedMethod() throws IllegalStateException {\n\t\tif (this.methodObject == null) {\n\t\t\tthrow new IllegalStateException(\"prepare() must be called prior to invoke() on MethodInvoker\");\n\t\t}\n\t\treturn this.methodObject;\n\t}\n\n\t/**\n\t * Return whether this invoker has been prepared already,\n\t * i.e. whether it allows access to {@link #getPreparedMethod()} already.\n\t */\n\tpublic boolean isPrepared() {\n\t\treturn (this.methodObject != null);\n\t}\n\n\t/**\n\t * Invoke the specified method.\n\t * <p>The invoker needs to have been prepared before.\n\t * @return the object (possibly null) returned by the method invocation,\n\t * or {@code null} if the method has a void return type\n\t * @throws InvocationTargetException if the target method threw an exception\n\t * @throws IllegalAccessException if the target method couldn't be accessed\n\t * @see #prepare\n\t */\n\tpublic @Nullable Object invoke() throws InvocationTargetException, IllegalAccessException {\n\t\t// In the static case, target will simply be {@code null}.\n\t\tObject targetObject = getTargetObject();\n\t\tMethod preparedMethod = getPreparedMethod();\n\t\tif (targetObject == null && !Modifier.isStatic(preparedMethod.getModifiers())) {\n\t\t\tthrow new IllegalArgumentException(\"Target method must not be non-static without a target\");\n\t\t}\n\t\tReflectionUtils.makeAccessible(preparedMethod);\n\t\treturn preparedMethod.invoke(targetObject, getArguments());\n\t}\n\n\n\t/**\n\t * Algorithm that judges the match between the declared parameter types of a candidate method\n\t * and a specific list of arguments that this method is supposed to be invoked with.\n\t * <p>Determines a weight that represents the class hierarchy difference between types and\n\t * arguments. A direct match, i.e. type Integer &rarr; arg of class Integer, does not increase\n\t * the result - all direct matches means weight 0. A match between type Object and arg of\n\t * class Integer would increase the weight by 2, due to the superclass 2 steps up in the\n\t * hierarchy (i.e. Object) being the last one that still matches the required type Object.\n\t * Type Number and class Integer would increase the weight by 1 accordingly, due to the\n\t * superclass 1 step up the hierarchy (i.e. Number) still matching the required type Number.\n\t * Therefore, with an arg of type Integer, a constructor (Integer) would be preferred to a\n\t * constructor (Number) which would in turn be preferred to a constructor (Object).\n\t * All argument weights get accumulated.\n\t * <p>Note: This is the algorithm used by MethodInvoker itself and also the algorithm\n\t * used for constructor and factory method selection in Spring's bean container (in case\n\t * of lenient constructor resolution which is the default for regular bean definitions).\n\t * @param paramTypes the parameter types to match\n\t * @param args the arguments to match\n\t * @return the accumulated weight for all arguments\n\t */\n\tpublic static int getTypeDifferenceWeight(Class<?>[] paramTypes, @Nullable Object[] args) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < paramTypes.length; i++) {\n\t\t\tif (!ClassUtils.isAssignableValue(paramTypes[i], args[i])) {\n\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t}\n\t\t\tif (args[i] != null) {\n\t\t\t\tClass<?> paramType = paramTypes[i];\n\t\t\t\tClass<?> superClass = args[i].getClass().getSuperclass();\n\t\t\t\twhile (superClass != null) {\n\t\t\t\t\tif (paramType.equals(superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ClassUtils.isAssignable(paramType, superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = superClass.getSuperclass();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (paramType.isInterface()) {\n\t\t\t\t\tresult = result + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}"
  },
  "org.springframework.util.MethodInvoker#findMatchingMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a matching method with the specified name for the specified arguments.\n\t * @return a matching method, or {@code null} if none\n\t * @see #getTargetClass()\n\t * @see #getTargetMethod()\n\t * @see #getArguments()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "Method",
    "signature": "protected Method findMatchingMethod()",
    "source_code": "\tprotected @Nullable Method findMatchingMethod() {\n\t\tString targetMethod = getTargetMethod();\n\t\t@Nullable Object[] arguments = getArguments();\n\t\tint argCount = arguments.length;\n\n\t\tClass<?> targetClass = getTargetClass();\n\t\tAssert.state(targetClass != null, \"No target class set\");\n\t\tMethod[] candidates = ReflectionUtils.getAllDeclaredMethods(targetClass);\n\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n\t\tMethod matchingMethod = null;\n\n\t\tfor (Method candidate : candidates) {\n\t\t\tif (candidate.getName().equals(targetMethod) && candidate.getParameterCount() == argCount) {\n\t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n\t\t\t\tint typeDiffWeight = getTypeDifferenceWeight(paramTypes, arguments);\n\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n\t\t\t\t\tmatchingMethod = candidate;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn matchingMethod;\n\t}"
  },
  "org.springframework.util.MethodInvoker#getArguments()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the arguments for the method invocation.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "Object[]",
    "signature": "public Object[] getArguments()",
    "source_code": "\tpublic @Nullable Object[] getArguments() {\n\t\treturn (this.arguments != null ? this.arguments : EMPTY_ARGUMENTS);\n\t}"
  },
  "org.springframework.util.MethodInvoker#getPreparedMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the prepared Method object that will be invoked.\n\t * <p>Can for example be used to determine the return type.\n\t * @return the prepared Method object (never {@code null})\n\t * @throws IllegalStateException if the invoker hasn't been prepared yet\n\t * @see #prepare\n\t * @see #invoke\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "Method",
    "signature": "public Method getPreparedMethod()",
    "source_code": "\tpublic Method getPreparedMethod() throws IllegalStateException {\n\t\tif (this.methodObject == null) {\n\t\t\tthrow new IllegalStateException(\"prepare() must be called prior to invoke() on MethodInvoker\");\n\t\t}\n\t\treturn this.methodObject;\n\t}"
  },
  "org.springframework.util.MethodInvoker#getTargetMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the method to be invoked.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "String",
    "signature": "public String getTargetMethod()",
    "source_code": "\tpublic @Nullable String getTargetMethod() {\n\t\treturn this.targetMethod;\n\t}"
  },
  "org.springframework.util.MethodInvoker#getTargetObject()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the target object on which to call the target method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "Object",
    "signature": "public Object getTargetObject()",
    "source_code": "\tpublic @Nullable Object getTargetObject() {\n\t\treturn this.targetObject;\n\t}"
  },
  "org.springframework.util.MethodInvoker#getTypeDifferenceWeight(paramTypes,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Algorithm that judges the match between the declared parameter types of a candidate method\n\t * and a specific list of arguments that this method is supposed to be invoked with.\n\t * <p>Determines a weight that represents the class hierarchy difference between types and\n\t * arguments. A direct match, i.e. type Integer &rarr; arg of class Integer, does not increase\n\t * the result - all direct matches means weight 0. A match between type Object and arg of\n\t * class Integer would increase the weight by 2, due to the superclass 2 steps up in the\n\t * hierarchy (i.e. Object) being the last one that still matches the required type Object.\n\t * Type Number and class Integer would increase the weight by 1 accordingly, due to the\n\t * superclass 1 step up the hierarchy (i.e. Number) still matching the required type Number.\n\t * Therefore, with an arg of type Integer, a constructor (Integer) would be preferred to a\n\t * constructor (Number) which would in turn be preferred to a constructor (Object).\n\t * All argument weights get accumulated.\n\t * <p>Note: This is the algorithm used by MethodInvoker itself and also the algorithm\n\t * used for constructor and factory method selection in Spring's bean container (in case\n\t * of lenient constructor resolution which is the default for regular bean definitions).\n\t * @param paramTypes the parameter types to match\n\t * @param args the arguments to match\n\t * @return the accumulated weight for all arguments\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramTypes",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "int",
    "signature": "public int getTypeDifferenceWeight(Class<?>[] paramTypes, @Nullable Object[] args)",
    "source_code": "\tpublic static int getTypeDifferenceWeight(Class<?>[] paramTypes, @Nullable Object[] args) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < paramTypes.length; i++) {\n\t\t\tif (!ClassUtils.isAssignableValue(paramTypes[i], args[i])) {\n\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t}\n\t\t\tif (args[i] != null) {\n\t\t\t\tClass<?> paramType = paramTypes[i];\n\t\t\t\tClass<?> superClass = args[i].getClass().getSuperclass();\n\t\t\t\twhile (superClass != null) {\n\t\t\t\t\tif (paramType.equals(superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ClassUtils.isAssignable(paramType, superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = superClass.getSuperclass();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (paramType.isInterface()) {\n\t\t\t\t\tresult = result + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.util.MethodInvoker#invoke()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified method.\n\t * <p>The invoker needs to have been prepared before.\n\t * @return the object (possibly null) returned by the method invocation,\n\t * or {@code null} if the method has a void return type\n\t * @throws InvocationTargetException if the target method threw an exception\n\t * @throws IllegalAccessException if the target method couldn't be accessed\n\t * @see #prepare\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "Object",
    "signature": "public Object invoke()",
    "source_code": "\tpublic @Nullable Object invoke() throws InvocationTargetException, IllegalAccessException {\n\t\t// In the static case, target will simply be {@code null}.\n\t\tObject targetObject = getTargetObject();\n\t\tMethod preparedMethod = getPreparedMethod();\n\t\tif (targetObject == null && !Modifier.isStatic(preparedMethod.getModifiers())) {\n\t\t\tthrow new IllegalArgumentException(\"Target method must not be non-static without a target\");\n\t\t}\n\t\tReflectionUtils.makeAccessible(preparedMethod);\n\t\treturn preparedMethod.invoke(targetObject, getArguments());\n\t}"
  },
  "org.springframework.util.MethodInvoker#isPrepared()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this invoker has been prepared already,\n\t * i.e. whether it allows access to {@link #getPreparedMethod()} already.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "boolean",
    "signature": "public boolean isPrepared()",
    "source_code": "\tpublic boolean isPrepared() {\n\t\treturn (this.methodObject != null);\n\t}"
  },
  "org.springframework.util.MethodInvoker#prepare()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the specified method.\n\t * The method can be invoked any number of times afterwards.\n\t * @see #getPreparedMethod\n\t * @see #invoke\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void prepare()",
    "source_code": "\tpublic void prepare() throws ClassNotFoundException, NoSuchMethodException {\n\t\tif (this.staticMethod != null) {\n\t\t\tint lastDotIndex = this.staticMethod.lastIndexOf('.');\n\t\t\tif (lastDotIndex == -1 || lastDotIndex == this.staticMethod.length() - 1) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"staticMethod must be a fully qualified class plus method name: \" +\n\t\t\t\t\t\t\"for example, 'example.MyExampleClass.myExampleMethod'\");\n\t\t\t}\n\t\t\tString className = this.staticMethod.substring(0, lastDotIndex);\n\t\t\tString methodName = this.staticMethod.substring(lastDotIndex + 1);\n\t\t\tif (this.targetClass == null || !this.targetClass.getName().equals(className)) {\n\t\t\t\tthis.targetClass = resolveClassName(className);\n\t\t\t}\n\t\t\tthis.targetMethod = methodName;\n\t\t}\n\n\t\tClass<?> targetClass = getTargetClass();\n\t\tString targetMethod = getTargetMethod();\n\t\tAssert.notNull(targetClass, \"Either 'targetClass' or 'targetObject' is required\");\n\t\tAssert.notNull(targetMethod, \"Property 'targetMethod' is required\");\n\n\t\t@Nullable Object[] arguments = getArguments();\n\t\tClass<?>[] argTypes = new Class<?>[arguments.length];\n\t\tfor (int i = 0; i < arguments.length; ++i) {\n\t\t\targTypes[i] = (arguments[i] != null ? arguments[i].getClass() : Object.class);\n\t\t}\n\n\t\t// Try to get the exact method first.\n\t\ttry {\n\t\t\tthis.methodObject = targetClass.getMethod(targetMethod, argTypes);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\t// Just rethrow exception if we can't get any match.\n\t\t\tthis.methodObject = findMatchingMethod();\n\t\t\tif (this.methodObject == null) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.MethodInvoker#setArguments(arguments)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set arguments for the method invocation. If this property is not set,\n\t * or the Object array is of length 0, a method with no arguments is assumed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void setArguments(@Nullable Object... arguments)",
    "source_code": "\tpublic void setArguments(@Nullable Object... arguments) {\n\t\tthis.arguments = arguments;\n\t}"
  },
  "org.springframework.util.MethodInvoker#setStaticMethod(staticMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a fully qualified static method name to invoke,\n\t * for example, \"example.MyExampleClass.myExampleMethod\". This is a\n\t * convenient alternative to specifying targetClass and targetMethod.\n\t * @see #setTargetClass\n\t * @see #setTargetMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "staticMethod"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void setStaticMethod(String staticMethod)",
    "source_code": "\tpublic void setStaticMethod(String staticMethod) {\n\t\tthis.staticMethod = staticMethod;\n\t}"
  },
  "org.springframework.util.MethodInvoker#setTargetClass(targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the target class on which to call the target method.\n\t * Only necessary when the target method is static; else,\n\t * a target object needs to be specified anyway.\n\t * @see #setTargetObject\n\t * @see #setTargetMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void setTargetClass(@Nullable Class<?> targetClass)",
    "source_code": "\tpublic void setTargetClass(@Nullable Class<?> targetClass) {\n\t\tthis.targetClass = targetClass;\n\t}"
  },
  "org.springframework.util.MethodInvoker#setTargetMethod(targetMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the method to be invoked.\n\t * Refers to either a static method or a non-static method,\n\t * depending on a target object being set.\n\t * @see #setTargetClass\n\t * @see #setTargetObject\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetMethod"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "void",
    "signature": "public void setTargetMethod(@Nullable String targetMethod)",
    "source_code": "\tpublic void setTargetMethod(@Nullable String targetMethod) {\n\t\tthis.targetMethod = targetMethod;\n\t}"
  },
  "org.springframework.util.MethodInvoker#setTargetObject(targetObject)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the target object on which to call the target method.\n\t * Only necessary when the target method is not static;\n\t * else, a target class is sufficient.\n\t * @see #setTargetClass\n\t * @see #setTargetMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetObject"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void setTargetObject(@Nullable Object targetObject)",
    "source_code": "\tpublic void setTargetObject(@Nullable Object targetObject) {\n\t\tthis.targetObject = targetObject;\n\t\tif (targetObject != null) {\n\t\t\tthis.targetClass = targetObject.getClass();\n\t\t}\n\t}"
  },
  "org.springframework.util.MimeType#compare(mimeType1,mimeType2)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mimeType1",
      "mimeType2"
    ],
    "position": {
      "column": 1,
      "line": 709
    },
    "return": "int",
    "signature": "public int compare(T mimeType1, T mimeType2)",
    "source_code": "\t\tpublic int compare(T mimeType1, T mimeType2) {\n\t\t\tif (mimeType1.isWildcardType() && !mimeType2.isWildcardType()) {  // */* < audio/*\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if (mimeType2.isWildcardType() && !mimeType1.isWildcardType()) {  // audio/* > */*\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (!mimeType1.getType().equals(mimeType2.getType())) {  // audio/basic == text/html\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {  // mediaType1.getType().equals(mediaType2.getType())\n\t\t\t\tif (mimeType1.isWildcardSubtype() && !mimeType2.isWildcardSubtype()) {  // audio/* < audio/basic\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if (mimeType2.isWildcardSubtype() && !mimeType1.isWildcardSubtype()) {  // audio/basic > audio/*\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse if (!mimeType1.getSubtype().equals(mimeType2.getSubtype())) {  // audio/basic == audio/wave\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse {  // mediaType2.getSubtype().equals(mediaType2.getSubtype())\n\t\t\t\t\treturn compareParameters(mimeType1, mimeType2);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.util.MimeType#compareParameters(mimeType1,mimeType2)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mimeType1",
      "mimeType2"
    ],
    "position": {
      "column": 1,
      "line": 735
    },
    "return": "int",
    "signature": "protected int compareParameters(T mimeType1, T mimeType2)",
    "source_code": "\t\tprotected int compareParameters(T mimeType1, T mimeType2) {\n\t\t\tint paramsSize1 = mimeType1.getParameters().size();\n\t\t\tint paramsSize2 = mimeType2.getParameters().size();\n\t\t\treturn Integer.compare(paramsSize2, paramsSize1);  // audio/basic;level=1 < audio/basic\n\t\t}"
  },
  "org.springframework.util.MultiValueMap": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Extension of the {@code Map} interface that stores multiple values.\n *\n * @author Arjen Poutsma\n * @since 3.0\n * @param <K> the key type\n * @param <V> the value element type\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 32
    },
    "signature": "public interface MultiValueMap",
    "source_code": "public interface MultiValueMap<K, V extends @Nullable Object> extends Map<K, List<V>> {\n\n\t/**\n\t * Return the first value for the given key.\n\t * @param key the key\n\t * @return the first value for the specified key, or {@code null} if none\n\t */\n\t@Nullable V getFirst(K key);\n\n\t/**\n\t * Add the given single value to the current list of values for the given key.\n\t * @param key the key\n\t * @param value the value to be added\n\t */\n\tvoid add(K key, @Nullable V value);\n\n\t/**\n\t * Add all the values of the given list to the current list of values for the given key.\n\t * @param key they key\n\t * @param values the values to be added\n\t * @since 5.0\n\t */\n\tvoid addAll(K key, List<? extends V> values);\n\n\t/**\n\t * Add all the values of the given {@code MultiValueMap} to the current values.\n\t * @param values the values to be added\n\t * @since 5.0\n\t */\n\tvoid addAll(MultiValueMap<K, V> values);\n\n\t/**\n\t * {@link #add(Object, Object) Add} the given value, only when the map does not\n\t * {@link #containsKey(Object) contain} the given key.\n\t * @param key the key\n\t * @param value the value to be added\n\t * @since 5.2\n\t */\n\tdefault void addIfAbsent(K key, @Nullable V value) {\n\t\tif (!containsKey(key)) {\n\t\t\tadd(key, value);\n\t\t}\n\t}\n\n\t/**\n\t * Set the given single value under the given key.\n\t * @param key the key\n\t * @param value the value to set\n\t */\n\tvoid set(K key, @Nullable V value);\n\n\t/**\n\t * Set the given values under.\n\t * @param values the values.\n\t */\n\tvoid setAll(Map<K, V> values);\n\n\t/**\n\t * Return a {@code Map} with the first values contained in this {@code MultiValueMap}.\n\t * The difference between this method and {@link #asSingleValueMap()} is\n\t * that this method returns a copy of the entries of this map, whereas\n\t * the latter returns a view.\n\t * @return a single value representation of this map\n\t */\n\tMap<K, V> toSingleValueMap();\n\n\t/**\n\t * Return this map as a {@code Map} with the first values contained in this\n\t * {@code MultiValueMap}.\n\t * <p>The difference between this method and {@link #toSingleValueMap()} is\n\t * that this method returns a view of the entries of this map, whereas\n\t * the latter returns a copy.\n\t * @return a single value representation of this map\n\t * @since 6.2\n\t */\n\tdefault Map<K, V> asSingleValueMap() {\n\t\treturn new MultiToSingleValueMapAdapter<>(this);\n\t}\n\n\n\t/**\n\t * Return a {@code MultiValueMap<K, V>} that adapts the given single-value\n\t * {@code Map<K, V>}.\n\t * <p>The returned map cannot map multiple values to the same key,\n\t * and doing so results in an {@link UnsupportedOperationException}.\n\t * Use {@link #fromMultiValue(Map)} to support multiple values.\n\t * @param map the map to be adapted\n\t * @param <K> the key type\n\t * @param <V> the value element type\n\t * @return a multi-value-map that delegates to {@code map}\n\t * @since 6.2\n\t * @see #fromMultiValue(Map)\n\t */\n\tstatic <K, V> MultiValueMap<K, V> fromSingleValue(Map<K, V> map) {\n\t\tAssert.notNull(map, \"Map must not be null\");\n\t\treturn new SingleToMultiValueMapAdapter<>(map);\n\t}\n\n\t/**\n\t * Return a {@code MultiValueMap<K, V>} that adapts the given multi-value\n\t * {@code Map<K, List<V>>}.\n\t * @param map the map to be adapted\n\t * @param <K> the key type\n\t * @param <V> the value element type\n\t * @return a multi-value-map that delegates to {@code map}\n\t * @since 6.2\n\t * @see #fromSingleValue(Map)\n\t */\n\tstatic <K, V> MultiValueMap<K, V> fromMultiValue(Map<K, List<V>> map) {\n\t\tAssert.notNull(map, \"Map must not be null\");\n\t\treturn new MultiValueMapAdapter<>(map);\n\t}\n\n}"
  },
  "org.springframework.util.PatternMatchUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility methods for simple pattern matching, in particular for Spring's typical\n * {@code xxx*}, {@code *xxx}, {@code *xxx*}, and {@code xxx*yyy} pattern styles.\n *\n * @author Juergen Hoeller\n * @since 2.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 28
    },
    "signature": "public class PatternMatchUtils",
    "source_code": "public abstract class PatternMatchUtils {\n\n\t/**\n\t * Match a String against the given pattern, supporting direct equality as\n\t * well as the following simple pattern styles: {@code xxx*}, {@code *xxx},\n\t * {@code *xxx*}, and {@code xxx*yyy} (with an arbitrary number of pattern parts).\n\t * <p>Returns {@code false} if the supplied String or pattern is {@code null}.\n\t * @param pattern the pattern to match against\n\t * @param str the String to match\n\t * @return whether the String matches the given pattern\n\t */\n\tpublic static boolean simpleMatch(@Nullable String pattern, @Nullable String str) {\n\t\tif (pattern == null || str == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint firstIndex = pattern.indexOf('*');\n\t\tif (firstIndex == -1) {\n\t\t\treturn pattern.equals(str);\n\t\t}\n\n\t\tif (firstIndex == 0) {\n\t\t\tif (pattern.length() == 1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tint nextIndex = pattern.indexOf('*', 1);\n\t\t\tif (nextIndex == -1) {\n\t\t\t\treturn str.endsWith(pattern.substring(1));\n\t\t\t}\n\t\t\tString part = pattern.substring(1, nextIndex);\n\t\t\tif (part.isEmpty()) {\n\t\t\t\treturn simpleMatch(pattern.substring(nextIndex), str);\n\t\t\t}\n\t\t\tint partIndex = str.indexOf(part);\n\t\t\twhile (partIndex != -1) {\n\t\t\t\tif (simpleMatch(pattern.substring(nextIndex), str.substring(partIndex + part.length()))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tpartIndex = str.indexOf(part, partIndex + 1);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn (str.length() >= firstIndex &&\n\t\t\t\tpattern.startsWith(str.substring(0, firstIndex)) &&\n\t\t\t\tsimpleMatch(pattern.substring(firstIndex), str.substring(firstIndex)));\n\t}\n\n\t/**\n\t * Match a String against the given patterns, supporting direct equality as\n\t * well as the following simple pattern styles: {@code xxx*}, {@code *xxx},\n\t * {@code *xxx*}, and {@code xxx*yyy} (with an arbitrary number of pattern parts).\n\t * <p>Returns {@code false} if the supplied String is {@code null} or if the\n\t * supplied patterns array is {@code null} or empty.\n\t * @param patterns the patterns to match against\n\t * @param str the String to match\n\t * @return whether the String matches any of the given patterns\n\t */\n\tpublic static boolean simpleMatch(String @Nullable [] patterns, @Nullable String str) {\n\t\tif (patterns != null) {\n\t\t\tfor (String pattern : patterns) {\n\t\t\t\tif (simpleMatch(pattern, str)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}"
  },
  "org.springframework.util.PatternMatchUtils#simpleMatch(pattern,str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Match a String against the given pattern, supporting direct equality as\n\t * well as the following simple pattern styles: {@code xxx*}, {@code *xxx},\n\t * {@code *xxx*}, and {@code xxx*yyy} (with an arbitrary number of pattern parts).\n\t * <p>Returns {@code false} if the supplied String or pattern is {@code null}.\n\t * @param pattern the pattern to match against\n\t * @param str the String to match\n\t * @return whether the String matches the given pattern\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pattern",
      "str"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "return": "boolean",
    "signature": "public boolean simpleMatch(@Nullable String pattern, @Nullable String str)",
    "source_code": "\tpublic static boolean simpleMatch(@Nullable String pattern, @Nullable String str) {\n\t\tif (pattern == null || str == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint firstIndex = pattern.indexOf('*');\n\t\tif (firstIndex == -1) {\n\t\t\treturn pattern.equals(str);\n\t\t}\n\n\t\tif (firstIndex == 0) {\n\t\t\tif (pattern.length() == 1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tint nextIndex = pattern.indexOf('*', 1);\n\t\t\tif (nextIndex == -1) {\n\t\t\t\treturn str.endsWith(pattern.substring(1));\n\t\t\t}\n\t\t\tString part = pattern.substring(1, nextIndex);\n\t\t\tif (part.isEmpty()) {\n\t\t\t\treturn simpleMatch(pattern.substring(nextIndex), str);\n\t\t\t}\n\t\t\tint partIndex = str.indexOf(part);\n\t\t\twhile (partIndex != -1) {\n\t\t\t\tif (simpleMatch(pattern.substring(nextIndex), str.substring(partIndex + part.length()))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tpartIndex = str.indexOf(part, partIndex + 1);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn (str.length() >= firstIndex &&\n\t\t\t\tpattern.startsWith(str.substring(0, firstIndex)) &&\n\t\t\t\tsimpleMatch(pattern.substring(firstIndex), str.substring(firstIndex)));\n\t}"
  },
  "org.springframework.util.PatternMatchUtils#simpleMatch(patterns,str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Match a String against the given patterns, supporting direct equality as\n\t * well as the following simple pattern styles: {@code xxx*}, {@code *xxx},\n\t * {@code *xxx*}, and {@code xxx*yyy} (with an arbitrary number of pattern parts).\n\t * <p>Returns {@code false} if the supplied String is {@code null} or if the\n\t * supplied patterns array is {@code null} or empty.\n\t * @param patterns the patterns to match against\n\t * @param str the String to match\n\t * @return whether the String matches any of the given patterns\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "patterns",
      "str"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "boolean",
    "signature": "public boolean simpleMatch(String @Nullable [] patterns, @Nullable String str)",
    "source_code": "\tpublic static boolean simpleMatch(String @Nullable [] patterns, @Nullable String str) {\n\t\tif (patterns != null) {\n\t\t\tfor (String pattern : patterns) {\n\t\t\t\tif (simpleMatch(pattern, str)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.SPECIFICITY_COMPARATOR": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Comparator formally used by {@link #sortBySpecificity(List)}.\n\t * @deprecated As of 6.0, with no direct replacement\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public Comparator<MimeType> SPECIFICITY_COMPARATOR",
    "source_code": "\tpublic static final Comparator<MimeType> SPECIFICITY_COMPARATOR = new MimeType.SpecificityComparator<>();",
    "type": "Comparator<MimeType>"
  },
  "org.springframework.util.SerializationUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Static utilities for serialization and deserialization using\n * <a href=\"https://docs.oracle.com/en/java/javase/17/docs/specs/serialization/\"\n * target=\"_blank\">Java Object Serialization</a>.\n *\n * <p><strong>WARNING</strong>: These utilities should be used with caution. See\n * <a href=\"https://www.oracle.com/java/technologies/javase/seccodeguide.html#8\"\n * target=\"_blank\">Secure Coding Guidelines for the Java Programming Language</a>\n * for details.\n *\n * @author Dave Syer\n * @author Lo\u00efc Ledoyen\n * @author Sam Brannen\n * @since 3.0.5\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public class SerializationUtils",
    "source_code": "public abstract class SerializationUtils {\n\n\t/**\n\t * Serialize the given object to a byte array.\n\t * @param object the object to serialize\n\t * @return an array of bytes representing the object in a portable fashion\n\t */\n\tpublic static byte @Nullable [] serialize(@Nullable Object object) {\n\t\tif (object == null) {\n\t\t\treturn null;\n\t\t}\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream(1024);\n\t\ttry (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n\t\t\toos.writeObject(object);\n\t\t\toos.flush();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Failed to serialize object of type: \" + object.getClass(), ex);\n\t\t}\n\t\treturn baos.toByteArray();\n\t}\n\n\t/**\n\t * Deserialize the byte array into an object.\n\t * @param bytes a serialized object\n\t * @return the result of deserializing the bytes\n\t * @deprecated This utility uses Java Object Serialization, which allows\n\t * arbitrary code to be run and is known for being the source of many Remote\n\t * Code Execution (RCE) vulnerabilities.\n\t * <p>Prefer the use of an external tool (that serializes to JSON, XML, or\n\t * any other format) which is regularly checked and updated for not allowing RCE.\n\t */\n\t@Deprecated\n\tpublic static @Nullable Object deserialize(byte @Nullable [] bytes) {\n\t\tif (bytes == null) {\n\t\t\treturn null;\n\t\t}\n\t\ttry (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes))) {\n\t\t\treturn ois.readObject();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Failed to deserialize object\", ex);\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\tthrow new IllegalStateException(\"Failed to deserialize object type\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Clone the given object using Java Object Serialization.\n\t * @param object the object to clone\n\t * @param <T> the type of the object to clone\n\t * @return a clone (deep-copy) of the given object\n\t * @since 6.0\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T extends Serializable> T clone(T object) {\n\t\tObject result = SerializationUtils.deserialize(SerializationUtils.serialize(object));\n\t\tAssert.state(result != null, \"Deserialized object must not be null\");\n\t\treturn (T) result;\n\t}\n\n}"
  },
  "org.springframework.util.SerializationUtils#clone(object)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Clone the given object using Java Object Serialization.\n\t * @param object the object to clone\n\t * @param <T> the type of the object to clone\n\t * @return a clone (deep-copy) of the given object\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "T",
    "signature": "public T clone(T object)",
    "source_code": "\tpublic static <T extends Serializable> T clone(T object) {\n\t\tObject result = SerializationUtils.deserialize(SerializationUtils.serialize(object));\n\t\tAssert.state(result != null, \"Deserialized object must not be null\");\n\t\treturn (T) result;\n\t}"
  },
  "org.springframework.util.SerializationUtils#deserialize(bytes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Deserialize the byte array into an object.\n\t * @param bytes a serialized object\n\t * @return the result of deserializing the bytes\n\t * @deprecated This utility uses Java Object Serialization, which allows\n\t * arbitrary code to be run and is known for being the source of many Remote\n\t * Code Execution (RCE) vulnerabilities.\n\t * <p>Prefer the use of an external tool (that serializes to JSON, XML, or\n\t * any other format) which is regularly checked and updated for not allowing RCE.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bytes"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "Object",
    "signature": "public Object deserialize(byte @Nullable [] bytes)",
    "source_code": "\tpublic static @Nullable Object deserialize(byte @Nullable [] bytes) {\n\t\tif (bytes == null) {\n\t\t\treturn null;\n\t\t}\n\t\ttry (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes))) {\n\t\t\treturn ois.readObject();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Failed to deserialize object\", ex);\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\tthrow new IllegalStateException(\"Failed to deserialize object type\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.util.SpecificityComparator": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Comparator to sort {@link MimeType MimeTypes} in order of specificity.\n\t *\n\t * @param <T> the type of mime types that may be compared by this comparator\n\t * @deprecated As of 6.0, with no direct replacement\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 706
    },
    "signature": "public class SpecificityComparator",
    "source_code": "\tpublic static class SpecificityComparator<T extends MimeType> implements Comparator<T> {\n\n\t\t@Override\n\t\tpublic int compare(T mimeType1, T mimeType2) {\n\t\t\tif (mimeType1.isWildcardType() && !mimeType2.isWildcardType()) {  // */* < audio/*\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if (mimeType2.isWildcardType() && !mimeType1.isWildcardType()) {  // audio/* > */*\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (!mimeType1.getType().equals(mimeType2.getType())) {  // audio/basic == text/html\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {  // mediaType1.getType().equals(mediaType2.getType())\n\t\t\t\tif (mimeType1.isWildcardSubtype() && !mimeType2.isWildcardSubtype()) {  // audio/* < audio/basic\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if (mimeType2.isWildcardSubtype() && !mimeType1.isWildcardSubtype()) {  // audio/basic > audio/*\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse if (!mimeType1.getSubtype().equals(mimeType2.getSubtype())) {  // audio/basic == audio/wave\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse {  // mediaType2.getSubtype().equals(mediaType2.getSubtype())\n\t\t\t\t\treturn compareParameters(mimeType1, mimeType2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprotected int compareParameters(T mimeType1, T mimeType2) {\n\t\t\tint paramsSize1 = mimeType1.getParameters().size();\n\t\t\tint paramsSize2 = mimeType2.getParameters().size();\n\t\t\treturn Integer.compare(paramsSize2, paramsSize1);  // audio/basic;level=1 < audio/basic\n\t\t}\n\t}"
  },
  "org.springframework.util.StringUtils#concatenateStringArrays(array1,array2)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Concatenate the given {@code String} arrays into one,\n\t * with overlapping array elements included twice.\n\t * <p>The order of elements in the original arrays is preserved.\n\t * @param array1 the first array (can be {@code null})\n\t * @param array2 the second array (can be {@code null})\n\t * @return the new array ({@code null} if both given arrays were {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array1",
      "array2"
    ],
    "position": {
      "column": 1,
      "line": 1013
    },
    "return": "String[]",
    "signature": "public String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2)",
    "source_code": "\tpublic static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {\n\t\tif (ObjectUtils.isEmpty(array1)) {\n\t\t\treturn array2;\n\t\t}\n\t\tif (ObjectUtils.isEmpty(array2)) {\n\t\t\treturn array1;\n\t\t}\n\n\t\tString[] newArr = new String[array1.length + array2.length];\n\t\tSystem.arraycopy(array1, 0, newArr, 0, array1.length);\n\t\tSystem.arraycopy(array2, 0, newArr, array1.length, array2.length);\n\t\treturn newArr;\n\t}"
  },
  "org.springframework.util.StringUtils#split(toSplit,delimiter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Split a {@code String} at the first occurrence of the delimiter.\n\t * Does not include the delimiter in the result.\n\t * @param toSplit the string to split (potentially {@code null} or empty)\n\t * @param delimiter to split the string up with (potentially {@code null} or empty)\n\t * @return a two element array with index 0 being before the delimiter, and\n\t * index 1 being after the delimiter (neither element includes the delimiter);\n\t * or {@code null} if the delimiter wasn't found in the given input {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "toSplit",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 1085
    },
    "return": "String[]",
    "signature": "public String[] split(@Nullable String toSplit, @Nullable String delimiter)",
    "source_code": "\tpublic static String[] split(@Nullable String toSplit, @Nullable String delimiter) {\n\t\tif (!hasLength(toSplit) || !hasLength(delimiter)) {\n\t\t\treturn null;\n\t\t}\n\t\tint offset = toSplit.indexOf(delimiter);\n\t\tif (offset < 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString beforeDelimiter = toSplit.substring(0, offset);\n\t\tString afterDelimiter = toSplit.substring(offset + delimiter.length());\n\t\treturn new String[] {beforeDelimiter, afterDelimiter};\n\t}"
  },
  "org.springframework.util.concurrent.ListenableFutureCallbackRegistry": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Helper class for {@link ListenableFuture} implementations that maintains a queue\n * of success and failure callbacks and helps to notify them.\n *\n * <p>Inspired by {@code com.google.common.util.concurrent.ExecutionList}.\n *\n * @author Arjen Poutsma\n * @author Sebastien Deleuze\n * @author Rossen Stoyanchev\n * @since 4.0\n * @param <T> the callback result type\n * @deprecated as of 6.0, with no concrete replacement\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class ListenableFutureCallbackRegistry",
    "source_code": "public class ListenableFutureCallbackRegistry<T> {\n\n\tprivate final Queue<SuccessCallback<? super T>> successCallbacks = new ArrayDeque<>(1);\n\n\tprivate final Queue<FailureCallback> failureCallbacks = new ArrayDeque<>(1);\n\n\tprivate State state = State.NEW;\n\n\t@Nullable\n\tprivate Object result;\n\n\tprivate final Object mutex = new Object();\n\n\n\t/**\n\t * Add the given callback to this registry.\n\t * @param callback the callback to add\n\t */\n\tpublic void addCallback(ListenableFutureCallback<? super T> callback) {\n\t\tAssert.notNull(callback, \"'callback' must not be null\");\n\t\tsynchronized (this.mutex) {\n\t\t\tswitch (this.state) {\n\t\t\t\tcase NEW -> {\n\t\t\t\t\tthis.successCallbacks.add(callback);\n\t\t\t\t\tthis.failureCallbacks.add(callback);\n\t\t\t\t}\n\t\t\t\tcase SUCCESS -> notifySuccess(callback);\n\t\t\t\tcase FAILURE -> notifyFailure(callback);\n\t\t\t}\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void notifySuccess(SuccessCallback<? super T> callback) {\n\t\ttry {\n\t\t\tcallback.onSuccess((T) this.result);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// Ignore\n\t\t}\n\t}\n\n\tprivate void notifyFailure(FailureCallback callback) {\n\t\tAssert.state(this.result instanceof Throwable, \"No Throwable result for failure state\");\n\t\ttry {\n\t\t\tcallback.onFailure((Throwable) this.result);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// Ignore\n\t\t}\n\t}\n\n\t/**\n\t * Add the given success callback to this registry.\n\t * @param callback the success callback to add\n\t * @since 4.1\n\t */\n\tpublic void addSuccessCallback(SuccessCallback<? super T> callback) {\n\t\tAssert.notNull(callback, \"'callback' must not be null\");\n\t\tsynchronized (this.mutex) {\n\t\t\tswitch (this.state) {\n\t\t\t\tcase NEW -> this.successCallbacks.add(callback);\n\t\t\t\tcase SUCCESS -> notifySuccess(callback);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Add the given failure callback to this registry.\n\t * @param callback the failure callback to add\n\t * @since 4.1\n\t */\n\tpublic void addFailureCallback(FailureCallback callback) {\n\t\tAssert.notNull(callback, \"'callback' must not be null\");\n\t\tsynchronized (this.mutex) {\n\t\t\tswitch (this.state) {\n\t\t\t\tcase NEW -> this.failureCallbacks.add(callback);\n\t\t\t\tcase FAILURE -> notifyFailure(callback);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Trigger a {@link ListenableFutureCallback#onSuccess(Object)} call on all\n\t * added callbacks with the given result.\n\t * @param result the result to trigger the callbacks with\n\t */\n\tpublic void success(@Nullable T result) {\n\t\tsynchronized (this.mutex) {\n\t\t\tthis.state = State.SUCCESS;\n\t\t\tthis.result = result;\n\t\t\tSuccessCallback<? super T> callback;\n\t\t\twhile ((callback = this.successCallbacks.poll()) != null) {\n\t\t\t\tnotifySuccess(callback);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Trigger a {@link ListenableFutureCallback#onFailure(Throwable)} call on all\n\t * added callbacks with the given {@code Throwable}.\n\t * @param ex the exception to trigger the callbacks with\n\t */\n\tpublic void failure(Throwable ex) {\n\t\tsynchronized (this.mutex) {\n\t\t\tthis.state = State.FAILURE;\n\t\t\tthis.result = ex;\n\t\t\tFailureCallback callback;\n\t\t\twhile ((callback = this.failureCallbacks.poll()) != null) {\n\t\t\t\tnotifyFailure(callback);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate enum State {NEW, SUCCESS, FAILURE}\n\n}"
  },
  "org.springframework.util.concurrent.ListenableFutureCallbackRegistry#addCallback(callback)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given callback to this registry.\n\t * @param callback the callback to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "void",
    "signature": "public void addCallback(ListenableFutureCallback<? super T> callback)",
    "source_code": "\tpublic void addCallback(ListenableFutureCallback<? super T> callback) {\n\t\tAssert.notNull(callback, \"'callback' must not be null\");\n\t\tsynchronized (this.mutex) {\n\t\t\tswitch (this.state) {\n\t\t\t\tcase NEW -> {\n\t\t\t\t\tthis.successCallbacks.add(callback);\n\t\t\t\t\tthis.failureCallbacks.add(callback);\n\t\t\t\t}\n\t\t\t\tcase SUCCESS -> notifySuccess(callback);\n\t\t\t\tcase FAILURE -> notifyFailure(callback);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.concurrent.ListenableFutureCallbackRegistry#addFailureCallback(callback)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given failure callback to this registry.\n\t * @param callback the failure callback to add\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void addFailureCallback(FailureCallback callback)",
    "source_code": "\tpublic void addFailureCallback(FailureCallback callback) {\n\t\tAssert.notNull(callback, \"'callback' must not be null\");\n\t\tsynchronized (this.mutex) {\n\t\t\tswitch (this.state) {\n\t\t\t\tcase NEW -> this.failureCallbacks.add(callback);\n\t\t\t\tcase FAILURE -> notifyFailure(callback);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.concurrent.ListenableFutureCallbackRegistry#addSuccessCallback(callback)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given success callback to this registry.\n\t * @param callback the success callback to add\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "public void addSuccessCallback(SuccessCallback<? super T> callback)",
    "source_code": "\tpublic void addSuccessCallback(SuccessCallback<? super T> callback) {\n\t\tAssert.notNull(callback, \"'callback' must not be null\");\n\t\tsynchronized (this.mutex) {\n\t\t\tswitch (this.state) {\n\t\t\t\tcase NEW -> this.successCallbacks.add(callback);\n\t\t\t\tcase SUCCESS -> notifySuccess(callback);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.concurrent.ListenableFutureCallbackRegistry#failure(ex)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Trigger a {@link ListenableFutureCallback#onFailure(Throwable)} call on all\n\t * added callbacks with the given {@code Throwable}.\n\t * @param ex the exception to trigger the callbacks with\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void failure(Throwable ex)",
    "source_code": "\tpublic void failure(Throwable ex) {\n\t\tsynchronized (this.mutex) {\n\t\t\tthis.state = State.FAILURE;\n\t\t\tthis.result = ex;\n\t\t\tFailureCallback callback;\n\t\t\twhile ((callback = this.failureCallbacks.poll()) != null) {\n\t\t\t\tnotifyFailure(callback);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.concurrent.ListenableFutureCallbackRegistry#success(result)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Trigger a {@link ListenableFutureCallback#onSuccess(Object)} call on all\n\t * added callbacks with the given result.\n\t * @param result the result to trigger the callbacks with\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void success(@Nullable T result)",
    "source_code": "\tpublic void success(@Nullable T result) {\n\t\tsynchronized (this.mutex) {\n\t\t\tthis.state = State.SUCCESS;\n\t\t\tthis.result = result;\n\t\t\tSuccessCallback<? super T> callback;\n\t\t\twhile ((callback = this.successCallbacks.poll()) != null) {\n\t\t\t\tnotifySuccess(callback);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.function.SingletonSupplier": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@link java.util.function.Supplier} decorator that caches a singleton result and\n * makes it available from {@link #get()} (nullable) and {@link #obtain()} (null-safe).\n *\n * <p>A {@code SingletonSupplier} can be constructed via {@code of} factory methods\n * or via constructors that provide a default supplier as a fallback. This is\n * particularly useful for method reference suppliers, falling back to a default\n * supplier for a method that returned {@code null} and caching the result.\n *\n * @author Juergen Hoeller\n * @author Yanming Zhou\n * @since 5.1\n * @param <T> the type of results supplied by this supplier\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class SingletonSupplier",
    "source_code": "public class SingletonSupplier<T> implements Supplier<@Nullable T> {\n\n\tprivate final @Nullable Supplier<? extends @Nullable T> instanceSupplier;\n\n\tprivate final @Nullable Supplier<? extends @Nullable T> defaultSupplier;\n\n\tprivate volatile @Nullable T singletonInstance;\n\n\t/**\n\t * Guards access to write operations on the {@code singletonInstance} field.\n\t */\n\tprivate final Lock writeLock = new ReentrantLock();\n\n\n\t/**\n\t * Build a {@code SingletonSupplier} with the given singleton instance\n\t * and a default supplier for the case when the instance is {@code null}.\n\t * @param instance the singleton instance (potentially {@code null})\n\t * @param defaultSupplier the default supplier as a fallback\n\t */\n\tpublic SingletonSupplier(@Nullable T instance, Supplier<? extends @Nullable T> defaultSupplier) {\n\t\tthis.instanceSupplier = null;\n\t\tthis.defaultSupplier = defaultSupplier;\n\t\tthis.singletonInstance = instance;\n\t}\n\n\t/**\n\t * Build a {@code SingletonSupplier} with the given instance supplier\n\t * and a default supplier for the case when the instance is {@code null}.\n\t * @param instanceSupplier the immediate instance supplier\n\t * @param defaultSupplier the default supplier as a fallback\n\t */\n\tpublic SingletonSupplier(@Nullable Supplier<? extends @Nullable T> instanceSupplier, Supplier<? extends @Nullable T> defaultSupplier) {\n\t\tthis.instanceSupplier = instanceSupplier;\n\t\tthis.defaultSupplier = defaultSupplier;\n\t}\n\n\tprivate SingletonSupplier(Supplier<? extends @Nullable T> supplier) {\n\t\tthis.instanceSupplier = supplier;\n\t\tthis.defaultSupplier = null;\n\t}\n\n\tprivate SingletonSupplier(@Nullable T singletonInstance) {\n\t\tthis.instanceSupplier = null;\n\t\tthis.defaultSupplier = null;\n\t\tthis.singletonInstance = singletonInstance;\n\t}\n\n\n\t/**\n\t * Get the shared singleton instance for this supplier.\n\t * @return the singleton instance (or {@code null} if none)\n\t */\n\t@Override\n\tpublic @Nullable T get() {\n\t\tT instance = this.singletonInstance;\n\t\tif (instance == null) {\n\t\t\tthis.writeLock.lock();\n\t\t\ttry {\n\t\t\t\tinstance = this.singletonInstance;\n\t\t\t\tif (instance == null) {\n\t\t\t\t\tif (this.instanceSupplier != null) {\n\t\t\t\t\t\tinstance = this.instanceSupplier.get();\n\t\t\t\t\t}\n\t\t\t\t\tif (instance == null && this.defaultSupplier != null) {\n\t\t\t\t\t\tinstance = this.defaultSupplier.get();\n\t\t\t\t\t}\n\t\t\t\t\tthis.singletonInstance = instance;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.writeLock.unlock();\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n\n\t/**\n\t * Obtain the shared singleton instance for this supplier.\n\t * @return the singleton instance (never {@code null})\n\t * @throws IllegalStateException in case of no instance\n\t */\n\tpublic T obtain() {\n\t\tT instance = get();\n\t\tAssert.state(instance != null, \"No instance from Supplier\");\n\t\treturn instance;\n\t}\n\n\n\t/**\n\t * Build a {@code SingletonSupplier} with the given singleton instance.\n\t * @param instance the singleton instance (never {@code null})\n\t * @return the singleton supplier (never {@code null})\n\t */\n\tpublic static <T> SingletonSupplier<T> of(T instance) {\n\t\treturn new SingletonSupplier<>(instance);\n\t}\n\n\t/**\n\t * Build a {@code SingletonSupplier} with the given singleton instance.\n\t * @param instance the singleton instance (potentially {@code null})\n\t * @return the singleton supplier, or {@code null} if the instance was {@code null}\n\t */\n\t@Contract(\"null -> null; !null -> !null\")\n\tpublic static <T> @Nullable SingletonSupplier<T> ofNullable(@Nullable T instance) {\n\t\treturn (instance != null ? new SingletonSupplier<>(instance) : null);\n\t}\n\n\t/**\n\t * Build a {@code SingletonSupplier} with the given supplier.\n\t * @param supplier the instance supplier (never {@code null})\n\t * @return the singleton supplier (never {@code null})\n\t */\n\tpublic static <T> SingletonSupplier<T> of(Supplier<T> supplier) {\n\t\treturn new SingletonSupplier<>(supplier);\n\t}\n\n\t/**\n\t * Build a {@code SingletonSupplier} with the given supplier.\n\t * @param supplier the instance supplier (potentially {@code null})\n\t * @return the singleton supplier, or {@code null} if the instance supplier was {@code null}\n\t */\n\t@Contract(\"null -> null; !null -> !null\")\n\tpublic static <T> @Nullable SingletonSupplier<T> ofNullable(@Nullable Supplier<? extends @Nullable T> supplier) {\n\t\treturn (supplier != null ? new SingletonSupplier<>(supplier) : null);\n\t}\n\n}"
  },
  "org.springframework.util.function.SingletonSupplier#get()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the shared singleton instance for this supplier.\n\t * @return the singleton instance (or {@code null} if none)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "T",
    "signature": "public T get()",
    "source_code": "\tpublic @Nullable T get() {\n\t\tT instance = this.singletonInstance;\n\t\tif (instance == null) {\n\t\t\tthis.writeLock.lock();\n\t\t\ttry {\n\t\t\t\tinstance = this.singletonInstance;\n\t\t\t\tif (instance == null) {\n\t\t\t\t\tif (this.instanceSupplier != null) {\n\t\t\t\t\t\tinstance = this.instanceSupplier.get();\n\t\t\t\t\t}\n\t\t\t\t\tif (instance == null && this.defaultSupplier != null) {\n\t\t\t\t\t\tinstance = this.defaultSupplier.get();\n\t\t\t\t\t}\n\t\t\t\t\tthis.singletonInstance = instance;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.writeLock.unlock();\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}"
  },
  "org.springframework.util.function.SingletonSupplier#obtain()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the shared singleton instance for this supplier.\n\t * @return the singleton instance (never {@code null})\n\t * @throws IllegalStateException in case of no instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "T",
    "signature": "public T obtain()",
    "source_code": "\tpublic T obtain() {\n\t\tT instance = get();\n\t\tAssert.state(instance != null, \"No instance from Supplier\");\n\t\treturn instance;\n\t}"
  },
  "org.springframework.util.function.SingletonSupplier#of(instance)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@code SingletonSupplier} with the given singleton instance.\n\t * @param instance the singleton instance (never {@code null})\n\t * @return the singleton supplier (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "instance"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "SingletonSupplier<T>",
    "signature": "public SingletonSupplier<T> of(T instance)",
    "source_code": "\tpublic static <T> SingletonSupplier<T> of(T instance) {\n\t\treturn new SingletonSupplier<>(instance);\n\t}"
  },
  "org.springframework.util.function.SingletonSupplier#of(supplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@code SingletonSupplier} with the given supplier.\n\t * @param supplier the instance supplier (never {@code null})\n\t * @return the singleton supplier (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "supplier"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "SingletonSupplier<T>",
    "signature": "public SingletonSupplier<T> of(Supplier<T> supplier)",
    "source_code": "\tpublic static <T> SingletonSupplier<T> of(Supplier<T> supplier) {\n\t\treturn new SingletonSupplier<>(supplier);\n\t}"
  },
  "org.springframework.util.function.SingletonSupplier#ofNullable(instance)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@code SingletonSupplier} with the given singleton instance.\n\t * @param instance the singleton instance (potentially {@code null})\n\t * @return the singleton supplier, or {@code null} if the instance was {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "instance"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "SingletonSupplier<T>",
    "signature": "public SingletonSupplier<T> ofNullable(@Nullable T instance)",
    "source_code": "\tpublic static <T> @Nullable SingletonSupplier<T> ofNullable(@Nullable T instance) {\n\t\treturn (instance != null ? new SingletonSupplier<>(instance) : null);\n\t}"
  },
  "org.springframework.util.function.SingletonSupplier#ofNullable(supplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@code SingletonSupplier} with the given supplier.\n\t * @param supplier the instance supplier (potentially {@code null})\n\t * @return the singleton supplier, or {@code null} if the instance supplier was {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "supplier"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "SingletonSupplier<T>",
    "signature": "public SingletonSupplier<T> ofNullable(@Nullable Supplier<? extends @Nullable T> supplier)",
    "source_code": "\tpublic static <T> @Nullable SingletonSupplier<T> ofNullable(@Nullable Supplier<? extends @Nullable T> supplier) {\n\t\treturn (supplier != null ? new SingletonSupplier<>(supplier) : null);\n\t}"
  },
  "org.springframework.validation.BindException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Thrown when binding errors are considered fatal. Implements the\n * {@link BindingResult} interface (and its super-interface {@link Errors})\n * to allow for the direct analysis of binding errors.\n *\n * <p>As of Spring 2.0, this is a special-purpose class. Normally,\n * application code will work with the {@link BindingResult} interface,\n * or with a {@link DataBinder} that in turn exposes a BindingResult via\n * {@link org.springframework.validation.DataBinder#getBindingResult()}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @see BindingResult\n * @see DataBinder#getBindingResult()\n * @see DataBinder#close()\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class BindException",
    "source_code": "public class BindException extends Exception implements BindingResult {\n\n\tprivate final BindingResult bindingResult;\n\n\n\t/**\n\t * Create a new BindException instance for a BindingResult.\n\t * @param bindingResult the BindingResult instance to wrap\n\t */\n\tpublic BindException(BindingResult bindingResult) {\n\t\tAssert.notNull(bindingResult, \"BindingResult must not be null\");\n\t\tthis.bindingResult = bindingResult;\n\t}\n\n\t/**\n\t * Create a new BindException instance for a target bean.\n\t * @param target the target bean to bind onto\n\t * @param objectName the name of the target object\n\t * @see BeanPropertyBindingResult\n\t */\n\tpublic BindException(Object target, String objectName) {\n\t\tAssert.notNull(target, \"Target object must not be null\");\n\t\tthis.bindingResult = new BeanPropertyBindingResult(target, objectName);\n\t}\n\n\n\t/**\n\t * Return the BindingResult that this BindException wraps.\n\t */\n\tpublic final BindingResult getBindingResult() {\n\t\treturn this.bindingResult;\n\t}\n\n\n\t@Override\n\tpublic String getObjectName() {\n\t\treturn this.bindingResult.getObjectName();\n\t}\n\n\t@Override\n\tpublic void setNestedPath(String nestedPath) {\n\t\tthis.bindingResult.setNestedPath(nestedPath);\n\t}\n\n\t@Override\n\tpublic String getNestedPath() {\n\t\treturn this.bindingResult.getNestedPath();\n\t}\n\n\t@Override\n\tpublic void pushNestedPath(String subPath) {\n\t\tthis.bindingResult.pushNestedPath(subPath);\n\t}\n\n\t@Override\n\tpublic void popNestedPath() throws IllegalStateException {\n\t\tthis.bindingResult.popNestedPath();\n\t}\n\n\n\t@Override\n\tpublic void reject(String errorCode) {\n\t\tthis.bindingResult.reject(errorCode);\n\t}\n\n\t@Override\n\tpublic void reject(String errorCode, String defaultMessage) {\n\t\tthis.bindingResult.reject(errorCode, defaultMessage);\n\t}\n\n\t@Override\n\tpublic void reject(String errorCode, Object @Nullable [] errorArgs, @Nullable String defaultMessage) {\n\t\tthis.bindingResult.reject(errorCode, errorArgs, defaultMessage);\n\t}\n\n\t@Override\n\tpublic void rejectValue(@Nullable String field, String errorCode) {\n\t\tthis.bindingResult.rejectValue(field, errorCode);\n\t}\n\n\t@Override\n\tpublic void rejectValue(@Nullable String field, String errorCode, String defaultMessage) {\n\t\tthis.bindingResult.rejectValue(field, errorCode, defaultMessage);\n\t}\n\n\t@Override\n\tpublic void rejectValue(@Nullable String field, String errorCode,\n\t\t\tObject @Nullable [] errorArgs, @Nullable String defaultMessage) {\n\n\t\tthis.bindingResult.rejectValue(field, errorCode, errorArgs, defaultMessage);\n\t}\n\n\t@Override\n\tpublic void addAllErrors(Errors errors) {\n\t\tthis.bindingResult.addAllErrors(errors);\n\t}\n\n\n\t@Override\n\tpublic boolean hasErrors() {\n\t\treturn this.bindingResult.hasErrors();\n\t}\n\n\t@Override\n\tpublic int getErrorCount() {\n\t\treturn this.bindingResult.getErrorCount();\n\t}\n\n\t@Override\n\tpublic List<ObjectError> getAllErrors() {\n\t\treturn this.bindingResult.getAllErrors();\n\t}\n\n\t@Override\n\tpublic boolean hasGlobalErrors() {\n\t\treturn this.bindingResult.hasGlobalErrors();\n\t}\n\n\t@Override\n\tpublic int getGlobalErrorCount() {\n\t\treturn this.bindingResult.getGlobalErrorCount();\n\t}\n\n\t@Override\n\tpublic List<ObjectError> getGlobalErrors() {\n\t\treturn this.bindingResult.getGlobalErrors();\n\t}\n\n\t@Override\n\tpublic @Nullable ObjectError getGlobalError() {\n\t\treturn this.bindingResult.getGlobalError();\n\t}\n\n\t@Override\n\tpublic boolean hasFieldErrors() {\n\t\treturn this.bindingResult.hasFieldErrors();\n\t}\n\n\t@Override\n\tpublic int getFieldErrorCount() {\n\t\treturn this.bindingResult.getFieldErrorCount();\n\t}\n\n\t@Override\n\tpublic List<FieldError> getFieldErrors() {\n\t\treturn this.bindingResult.getFieldErrors();\n\t}\n\n\t@Override\n\tpublic @Nullable FieldError getFieldError() {\n\t\treturn this.bindingResult.getFieldError();\n\t}\n\n\t@Override\n\tpublic boolean hasFieldErrors(String field) {\n\t\treturn this.bindingResult.hasFieldErrors(field);\n\t}\n\n\t@Override\n\tpublic int getFieldErrorCount(String field) {\n\t\treturn this.bindingResult.getFieldErrorCount(field);\n\t}\n\n\t@Override\n\tpublic List<FieldError> getFieldErrors(String field) {\n\t\treturn this.bindingResult.getFieldErrors(field);\n\t}\n\n\t@Override\n\tpublic @Nullable FieldError getFieldError(String field) {\n\t\treturn this.bindingResult.getFieldError(field);\n\t}\n\n\t@Override\n\tpublic @Nullable Object getFieldValue(String field) {\n\t\treturn this.bindingResult.getFieldValue(field);\n\t}\n\n\t@Override\n\tpublic @Nullable Class<?> getFieldType(String field) {\n\t\treturn this.bindingResult.getFieldType(field);\n\t}\n\n\t@Override\n\tpublic @Nullable Object getTarget() {\n\t\treturn this.bindingResult.getTarget();\n\t}\n\n\t@Override\n\tpublic Map<String, Object> getModel() {\n\t\treturn this.bindingResult.getModel();\n\t}\n\n\t@Override\n\tpublic @Nullable Object getRawFieldValue(String field) {\n\t\treturn this.bindingResult.getRawFieldValue(field);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"rawtypes\")\n\tpublic @Nullable PropertyEditor findEditor(@Nullable String field, @Nullable Class valueType) {\n\t\treturn this.bindingResult.findEditor(field, valueType);\n\t}\n\n\t@Override\n\tpublic @Nullable PropertyEditorRegistry getPropertyEditorRegistry() {\n\t\treturn this.bindingResult.getPropertyEditorRegistry();\n\t}\n\n\t@Override\n\tpublic String[] resolveMessageCodes(String errorCode) {\n\t\treturn this.bindingResult.resolveMessageCodes(errorCode);\n\t}\n\n\t@Override\n\tpublic String[] resolveMessageCodes(String errorCode, String field) {\n\t\treturn this.bindingResult.resolveMessageCodes(errorCode, field);\n\t}\n\n\t@Override\n\tpublic void addError(ObjectError error) {\n\t\tthis.bindingResult.addError(error);\n\t}\n\n\t@Override\n\tpublic void recordFieldValue(String field, Class<?> type, @Nullable Object value) {\n\t\tthis.bindingResult.recordFieldValue(field, type, value);\n\t}\n\n\t@Override\n\tpublic void recordSuppressedField(String field) {\n\t\tthis.bindingResult.recordSuppressedField(field);\n\t}\n\n\t@Override\n\tpublic String[] getSuppressedFields() {\n\t\treturn this.bindingResult.getSuppressedFields();\n\t}\n\n\n\t/**\n\t * Returns diagnostic information about the errors held in this object.\n\t */\n\t@Override\n\tpublic String getMessage() {\n\t\treturn this.bindingResult.toString();\n\t}\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || this.bindingResult.equals(other));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.bindingResult.hashCode();\n\t}\n\n}"
  },
  "org.springframework.validation.BindException#addAllErrors(errors)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "void",
    "signature": "public void addAllErrors(Errors errors)",
    "source_code": "\tpublic void addAllErrors(Errors errors) {\n\t\tthis.bindingResult.addAllErrors(errors);\n\t}"
  },
  "org.springframework.validation.BindException#addError(error)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "error"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "void",
    "signature": "public void addError(ObjectError error)",
    "source_code": "\tpublic void addError(ObjectError error) {\n\t\tthis.bindingResult.addError(error);\n\t}"
  },
  "org.springframework.validation.BindException#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || this.bindingResult.equals(other));\n\t}"
  },
  "org.springframework.validation.BindException#findEditor(field,valueType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "valueType"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "PropertyEditor",
    "signature": "public PropertyEditor findEditor(@Nullable String field, @Nullable Class valueType)",
    "source_code": "\tpublic @Nullable PropertyEditor findEditor(@Nullable String field, @Nullable Class valueType) {\n\t\treturn this.bindingResult.findEditor(field, valueType);\n\t}"
  },
  "org.springframework.validation.BindException#getAllErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "List<ObjectError>",
    "signature": "public List<ObjectError> getAllErrors()",
    "source_code": "\tpublic List<ObjectError> getAllErrors() {\n\t\treturn this.bindingResult.getAllErrors();\n\t}"
  },
  "org.springframework.validation.BindException#getBindingResult()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the BindingResult that this BindException wraps.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "BindingResult",
    "signature": "public BindingResult getBindingResult()",
    "source_code": "\tpublic final BindingResult getBindingResult() {\n\t\treturn this.bindingResult;\n\t}"
  },
  "org.springframework.validation.BindException#getErrorCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "int",
    "signature": "public int getErrorCount()",
    "source_code": "\tpublic int getErrorCount() {\n\t\treturn this.bindingResult.getErrorCount();\n\t}"
  },
  "org.springframework.validation.BindException#getFieldError()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "FieldError",
    "signature": "public FieldError getFieldError()",
    "source_code": "\tpublic @Nullable FieldError getFieldError() {\n\t\treturn this.bindingResult.getFieldError();\n\t}"
  },
  "org.springframework.validation.BindException#getFieldError(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "FieldError",
    "signature": "public FieldError getFieldError(String field)",
    "source_code": "\tpublic @Nullable FieldError getFieldError(String field) {\n\t\treturn this.bindingResult.getFieldError(field);\n\t}"
  },
  "org.springframework.validation.BindException#getFieldErrorCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "int",
    "signature": "public int getFieldErrorCount()",
    "source_code": "\tpublic int getFieldErrorCount() {\n\t\treturn this.bindingResult.getFieldErrorCount();\n\t}"
  },
  "org.springframework.validation.BindException#getFieldErrorCount(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "int",
    "signature": "public int getFieldErrorCount(String field)",
    "source_code": "\tpublic int getFieldErrorCount(String field) {\n\t\treturn this.bindingResult.getFieldErrorCount(field);\n\t}"
  },
  "org.springframework.validation.BindException#getFieldErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "List<FieldError>",
    "signature": "public List<FieldError> getFieldErrors()",
    "source_code": "\tpublic List<FieldError> getFieldErrors() {\n\t\treturn this.bindingResult.getFieldErrors();\n\t}"
  },
  "org.springframework.validation.BindException#getFieldErrors(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "List<FieldError>",
    "signature": "public List<FieldError> getFieldErrors(String field)",
    "source_code": "\tpublic List<FieldError> getFieldErrors(String field) {\n\t\treturn this.bindingResult.getFieldErrors(field);\n\t}"
  },
  "org.springframework.validation.BindException#getFieldValue(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "Object",
    "signature": "public Object getFieldValue(String field)",
    "source_code": "\tpublic @Nullable Object getFieldValue(String field) {\n\t\treturn this.bindingResult.getFieldValue(field);\n\t}"
  },
  "org.springframework.validation.BindException#getGlobalError()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "ObjectError",
    "signature": "public ObjectError getGlobalError()",
    "source_code": "\tpublic @Nullable ObjectError getGlobalError() {\n\t\treturn this.bindingResult.getGlobalError();\n\t}"
  },
  "org.springframework.validation.BindException#getGlobalErrorCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "int",
    "signature": "public int getGlobalErrorCount()",
    "source_code": "\tpublic int getGlobalErrorCount() {\n\t\treturn this.bindingResult.getGlobalErrorCount();\n\t}"
  },
  "org.springframework.validation.BindException#getGlobalErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "List<ObjectError>",
    "signature": "public List<ObjectError> getGlobalErrors()",
    "source_code": "\tpublic List<ObjectError> getGlobalErrors() {\n\t\treturn this.bindingResult.getGlobalErrors();\n\t}"
  },
  "org.springframework.validation.BindException#getMessage()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns diagnostic information about the errors held in this object.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "String",
    "signature": "public String getMessage()",
    "source_code": "\tpublic String getMessage() {\n\t\treturn this.bindingResult.toString();\n\t}"
  },
  "org.springframework.validation.BindException#getModel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "Object>",
    "signature": "public Object> getModel()",
    "source_code": "\tpublic Map<String, Object> getModel() {\n\t\treturn this.bindingResult.getModel();\n\t}"
  },
  "org.springframework.validation.BindException#getNestedPath()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "String",
    "signature": "public String getNestedPath()",
    "source_code": "\tpublic String getNestedPath() {\n\t\treturn this.bindingResult.getNestedPath();\n\t}"
  },
  "org.springframework.validation.BindException#getObjectName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "String",
    "signature": "public String getObjectName()",
    "source_code": "\tpublic String getObjectName() {\n\t\treturn this.bindingResult.getObjectName();\n\t}"
  },
  "org.springframework.validation.BindException#getPropertyEditorRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "PropertyEditorRegistry",
    "signature": "public PropertyEditorRegistry getPropertyEditorRegistry()",
    "source_code": "\tpublic @Nullable PropertyEditorRegistry getPropertyEditorRegistry() {\n\t\treturn this.bindingResult.getPropertyEditorRegistry();\n\t}"
  },
  "org.springframework.validation.BindException#getRawFieldValue(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "Object",
    "signature": "public Object getRawFieldValue(String field)",
    "source_code": "\tpublic @Nullable Object getRawFieldValue(String field) {\n\t\treturn this.bindingResult.getRawFieldValue(field);\n\t}"
  },
  "org.springframework.validation.BindException#getSuppressedFields()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "String[]",
    "signature": "public String[] getSuppressedFields()",
    "source_code": "\tpublic String[] getSuppressedFields() {\n\t\treturn this.bindingResult.getSuppressedFields();\n\t}"
  },
  "org.springframework.validation.BindException#getTarget()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "Object",
    "signature": "public Object getTarget()",
    "source_code": "\tpublic @Nullable Object getTarget() {\n\t\treturn this.bindingResult.getTarget();\n\t}"
  },
  "org.springframework.validation.BindException#hasErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "boolean",
    "signature": "public boolean hasErrors()",
    "source_code": "\tpublic boolean hasErrors() {\n\t\treturn this.bindingResult.hasErrors();\n\t}"
  },
  "org.springframework.validation.BindException#hasFieldErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "boolean",
    "signature": "public boolean hasFieldErrors()",
    "source_code": "\tpublic boolean hasFieldErrors() {\n\t\treturn this.bindingResult.hasFieldErrors();\n\t}"
  },
  "org.springframework.validation.BindException#hasFieldErrors(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "boolean",
    "signature": "public boolean hasFieldErrors(String field)",
    "source_code": "\tpublic boolean hasFieldErrors(String field) {\n\t\treturn this.bindingResult.hasFieldErrors(field);\n\t}"
  },
  "org.springframework.validation.BindException#hasGlobalErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "boolean",
    "signature": "public boolean hasGlobalErrors()",
    "source_code": "\tpublic boolean hasGlobalErrors() {\n\t\treturn this.bindingResult.hasGlobalErrors();\n\t}"
  },
  "org.springframework.validation.BindException#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.bindingResult.hashCode();\n\t}"
  },
  "org.springframework.validation.BindException#popNestedPath()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "void",
    "signature": "public void popNestedPath()",
    "source_code": "\tpublic void popNestedPath() throws IllegalStateException {\n\t\tthis.bindingResult.popNestedPath();\n\t}"
  },
  "org.springframework.validation.BindException#pushNestedPath(subPath)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subPath"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void pushNestedPath(String subPath)",
    "source_code": "\tpublic void pushNestedPath(String subPath) {\n\t\tthis.bindingResult.pushNestedPath(subPath);\n\t}"
  },
  "org.springframework.validation.BindException#recordFieldValue(field,type,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "type",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "void",
    "signature": "public void recordFieldValue(String field, Class<?> type, @Nullable Object value)",
    "source_code": "\tpublic void recordFieldValue(String field, Class<?> type, @Nullable Object value) {\n\t\tthis.bindingResult.recordFieldValue(field, type, value);\n\t}"
  },
  "org.springframework.validation.BindException#recordSuppressedField(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "void",
    "signature": "public void recordSuppressedField(String field)",
    "source_code": "\tpublic void recordSuppressedField(String field) {\n\t\tthis.bindingResult.recordSuppressedField(field);\n\t}"
  },
  "org.springframework.validation.BindException#reject(errorCode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void reject(String errorCode)",
    "source_code": "\tpublic void reject(String errorCode) {\n\t\tthis.bindingResult.reject(errorCode);\n\t}"
  },
  "org.springframework.validation.BindException#reject(errorCode,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void reject(String errorCode, String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, String defaultMessage) {\n\t\tthis.bindingResult.reject(errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.validation.BindException#reject(errorCode,errorArgs,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "void",
    "signature": "public void reject(String errorCode, Object @Nullable [] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, Object @Nullable [] errorArgs, @Nullable String defaultMessage) {\n\t\tthis.bindingResult.reject(errorCode, errorArgs, defaultMessage);\n\t}"
  },
  "org.springframework.validation.BindException#rejectValue(field,errorCode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode) {\n\t\tthis.bindingResult.rejectValue(field, errorCode);\n\t}"
  },
  "org.springframework.validation.BindException#rejectValue(field,errorCode,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode, String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode, String defaultMessage) {\n\t\tthis.bindingResult.rejectValue(field, errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.validation.BindException#rejectValue(field,errorCode,errorArgs,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode,\n\t\t\tObject @Nullable [] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode,"
  },
  "org.springframework.validation.BindException#resolveMessageCodes(errorCode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "String[]",
    "signature": "public String[] resolveMessageCodes(String errorCode)",
    "source_code": "\tpublic String[] resolveMessageCodes(String errorCode) {\n\t\treturn this.bindingResult.resolveMessageCodes(errorCode);\n\t}"
  },
  "org.springframework.validation.BindException#resolveMessageCodes(errorCode,field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "String[]",
    "signature": "public String[] resolveMessageCodes(String errorCode, String field)",
    "source_code": "\tpublic String[] resolveMessageCodes(String errorCode, String field) {\n\t\treturn this.bindingResult.resolveMessageCodes(errorCode, field);\n\t}"
  },
  "org.springframework.validation.BindException#setNestedPath(nestedPath)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestedPath"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void setNestedPath(String nestedPath)",
    "source_code": "\tpublic void setNestedPath(String nestedPath) {\n\t\tthis.bindingResult.setNestedPath(nestedPath);\n\t}"
  },
  "org.springframework.validation.DataBinder#getAllowedFields()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the field patterns that should be allowed for binding.\n\t * @return array of allowed field patterns\n\t * @see #setAllowedFields(String...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 539
    },
    "return": "String[]",
    "signature": "public String[] getAllowedFields()",
    "source_code": "\tpublic String[] getAllowedFields() {\n\t\treturn this.allowedFields;\n\t}"
  },
  "org.springframework.validation.DataBinder#getDisallowedFields()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the field patterns that should <i>not</i> be allowed for binding.\n\t * @return array of disallowed field patterns\n\t * @see #setDisallowedFields(String...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 587
    },
    "return": "String[]",
    "signature": "public String[] getDisallowedFields()",
    "source_code": "\tpublic String[] getDisallowedFields() {\n\t\treturn this.disallowedFields;\n\t}"
  },
  "org.springframework.validation.DataBinder#getRequiredFields()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the fields that are required for each binding process.\n\t * @return array of field names\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 617
    },
    "return": "String[]",
    "signature": "public String[] getRequiredFields()",
    "source_code": "\tpublic String[] getRequiredFields() {\n\t\treturn this.requiredFields;\n\t}"
  },
  "org.springframework.validation.Errors": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Stores and exposes information about data-binding and validation errors\n * for a specific object.\n *\n * <p>Field names are typically properties of the target object (for example, \"name\"\n * when binding to a customer object). Implementations may also support nested\n * fields in case of nested objects (for example, \"address.street\"), in conjunction\n * with subtree navigation via {@link #setNestedPath}: for example, an\n * {@code AddressValidator} may validate \"address\", not being aware that this\n * is a nested object of a top-level customer object.\n *\n * <p>Note: {@code Errors} objects are single-threaded.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @see Validator\n * @see ValidationUtils\n * @see SimpleErrors\n * @see BindingResult\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public interface Errors",
    "source_code": "public interface Errors {\n\n\t/**\n\t * The separator between path elements in a nested path,\n\t * for example in \"customer.name\" or \"customer.address.street\".\n\t * <p>\".\" = same as the\n\t * {@link org.springframework.beans.PropertyAccessor#NESTED_PROPERTY_SEPARATOR nested property separator}\n\t * in the beans package.\n\t */\n\tString NESTED_PATH_SEPARATOR = PropertyAccessor.NESTED_PROPERTY_SEPARATOR;\n\n\n\t/**\n\t * Return the name of the bound root object.\n\t */\n\tString getObjectName();\n\n\t/**\n\t * Allow context to be changed so that standard validators can validate\n\t * subtrees. Reject calls prepend the given path to the field names.\n\t * <p>For example, an address validator could validate the subobject\n\t * \"address\" of a customer object.\n\t * <p>The default implementation throws {@code UnsupportedOperationException}\n\t * since not all {@code Errors} implementations support nested paths.\n\t * @param nestedPath nested path within this object,\n\t * for example, \"address\" (defaults to \"\", {@code null} is also acceptable).\n\t * Can end with a dot: both \"address\" and \"address.\" are valid.\n\t * @see #getNestedPath()\n\t */\n\tdefault void setNestedPath(String nestedPath) {\n\t\tthrow new UnsupportedOperationException(getClass().getSimpleName() + \" does not support nested paths\");\n\t}\n\n\t/**\n\t * Return the current nested path of this {@link Errors} object.\n\t * <p>Returns a nested path with a dot, i.e. \"address.\", for easy\n\t * building of concatenated paths. Default is an empty String.\n\t * @see #setNestedPath(String)\n\t */\n\tdefault String getNestedPath() {\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Push the given sub path onto the nested path stack.\n\t * <p>A {@link #popNestedPath()} call will reset the original\n\t * nested path before the corresponding\n\t * {@code pushNestedPath(String)} call.\n\t * <p>Using the nested path stack allows to set temporary nested paths\n\t * for subobjects without having to worry about a temporary path holder.\n\t * <p>For example: current path \"spouse.\", pushNestedPath(\"child\") &rarr;\n\t * result path \"spouse.child.\"; popNestedPath() &rarr; \"spouse.\" again.\n\t * <p>The default implementation throws {@code UnsupportedOperationException}\n\t * since not all {@code Errors} implementations support nested paths.\n\t * @param subPath the sub path to push onto the nested path stack\n\t * @see #popNestedPath()\n\t */\n\tdefault void pushNestedPath(String subPath) {\n\t\tthrow new UnsupportedOperationException(getClass().getSimpleName() + \" does not support nested paths\");\n\t}\n\n\t/**\n\t * Pop the former nested path from the nested path stack.\n\t * @throws IllegalStateException if there is no former nested path on the stack\n\t * @see #pushNestedPath(String)\n\t */\n\tdefault void popNestedPath() throws IllegalStateException {\n\t\tthrow new IllegalStateException(\"Cannot pop nested path: no nested path on stack\");\n\t}\n\n\t/**\n\t * Register a global error for the entire target object,\n\t * using the given error description.\n\t * @param errorCode error code, interpretable as a message key\n\t * @see #reject(String, Object[], String)\n\t */\n\tdefault void reject(String errorCode) {\n\t\treject(errorCode, null, null);\n\t}\n\n\t/**\n\t * Register a global error for the entire target object,\n\t * using the given error description.\n\t * @param errorCode error code, interpretable as a message key\n\t * @param defaultMessage fallback default message\n\t * @see #reject(String, Object[], String)\n\t */\n\tdefault void reject(String errorCode, String defaultMessage) {\n\t\treject(errorCode, null, defaultMessage);\n\t}\n\n\t/**\n\t * Register a global error for the entire target object,\n\t * using the given error description.\n\t * @param errorCode error code, interpretable as a message key\n\t * @param errorArgs error arguments, for argument binding via MessageFormat\n\t * (can be {@code null})\n\t * @param defaultMessage fallback default message\n\t * @see #rejectValue(String, String, Object[], String)\n\t */\n\tvoid reject(String errorCode, Object @Nullable [] errorArgs, @Nullable String defaultMessage);\n\n\t/**\n\t * Register a field error for the specified field of the current object\n\t * (respecting the current nested path, if any), using the given error\n\t * description.\n\t * <p>The field name may be {@code null} or empty String to indicate\n\t * the current object itself rather than a field of it. This may result\n\t * in a corresponding field error within the nested object graph or a\n\t * global error if the current object is the top object.\n\t * @param field the field name (may be {@code null} or empty String)\n\t * @param errorCode error code, interpretable as a message key\n\t * @see #rejectValue(String, String, Object[], String)\n\t */\n\tdefault void rejectValue(@Nullable String field, String errorCode) {\n\t\trejectValue(field, errorCode, null, null);\n\t}\n\n\t/**\n\t * Register a field error for the specified field of the current object\n\t * (respecting the current nested path, if any), using the given error\n\t * description.\n\t * <p>The field name may be {@code null} or empty String to indicate\n\t * the current object itself rather than a field of it. This may result\n\t * in a corresponding field error within the nested object graph or a\n\t * global error if the current object is the top object.\n\t * @param field the field name (may be {@code null} or empty String)\n\t * @param errorCode error code, interpretable as a message key\n\t * @param defaultMessage fallback default message\n\t * @see #rejectValue(String, String, Object[], String)\n\t */\n\tdefault void rejectValue(@Nullable String field, String errorCode, String defaultMessage) {\n\t\trejectValue(field, errorCode, null, defaultMessage);\n\t}\n\n\t/**\n\t * Register a field error for the specified field of the current object\n\t * (respecting the current nested path, if any), using the given error\n\t * description.\n\t * <p>The field name may be {@code null} or empty String to indicate\n\t * the current object itself rather than a field of it. This may result\n\t * in a corresponding field error within the nested object graph or a\n\t * global error if the current object is the top object.\n\t * @param field the field name (may be {@code null} or empty String)\n\t * @param errorCode error code, interpretable as a message key\n\t * @param errorArgs error arguments, for argument binding via MessageFormat\n\t * (can be {@code null})\n\t * @param defaultMessage fallback default message\n\t * @see #reject(String, Object[], String)\n\t */\n\tvoid rejectValue(@Nullable String field, String errorCode,\n\t\t\tObject @Nullable [] errorArgs, @Nullable String defaultMessage);\n\n\t/**\n\t * Add all errors from the given {@code Errors} instance to this\n\t * {@code Errors} instance.\n\t * <p>This is a convenience method to avoid repeated {@code reject(..)}\n\t * calls for merging an {@code Errors} instance into another\n\t * {@code Errors} instance.\n\t * <p>Note that the passed-in {@code Errors} instance is supposed\n\t * to refer to the same target object, or at least contain compatible errors\n\t * that apply to the target object of this {@code Errors} instance.\n\t * <p>The default implementation throws {@code UnsupportedOperationException}\n\t * since not all {@code Errors} implementations support {@code #addAllErrors}.\n\t * @param errors the {@code Errors} instance to merge in\n\t * @see #getAllErrors()\n\t */\n\tdefault void addAllErrors(Errors errors) {\n\t\tthrow new UnsupportedOperationException(getClass().getSimpleName() + \" does not support addAllErrors\");\n\t}\n\n\t/**\n\t * Throw the mapped exception with a message summarizing the recorded errors.\n\t * @param messageToException a function mapping the message to the exception,\n\t * for example, {@code IllegalArgumentException::new} or {@code IllegalStateException::new}\n\t * @param <T> the exception type to be thrown\n\t * @since 6.1\n\t * @see #toString()\n\t */\n\tdefault <T extends Throwable> void failOnError(Function<String, T> messageToException) throws T {\n\t\tif (hasErrors()) {\n\t\t\tthrow messageToException.apply(toString());\n\t\t}\n\t}\n\n\t/**\n\t * Determine if there were any errors.\n\t * @see #hasGlobalErrors()\n\t * @see #hasFieldErrors()\n\t */\n\tdefault boolean hasErrors() {\n\t\treturn (!getGlobalErrors().isEmpty() || !getFieldErrors().isEmpty());\n\t}\n\n\t/**\n\t * Determine the total number of errors.\n\t * @see #getGlobalErrorCount()\n\t * @see #getFieldErrorCount()\n\t */\n\tdefault int getErrorCount() {\n\t\treturn (getGlobalErrors().size() + getFieldErrors().size());\n\t}\n\n\t/**\n\t * Get all errors, both global and field ones.\n\t * @return a list of {@link ObjectError}/{@link FieldError} instances\n\t * @see #getGlobalErrors()\n\t * @see #getFieldErrors()\n\t */\n\tdefault List<ObjectError> getAllErrors() {\n\t\treturn Stream.concat(getGlobalErrors().stream(), getFieldErrors().stream()).toList();\n\t}\n\n\t/**\n\t * Determine if there were any global errors.\n\t * @see #hasFieldErrors()\n\t */\n\tdefault boolean hasGlobalErrors() {\n\t\treturn !getGlobalErrors().isEmpty();\n\t}\n\n\t/**\n\t * Determine the number of global errors.\n\t * @see #getFieldErrorCount()\n\t */\n\tdefault int getGlobalErrorCount() {\n\t\treturn getGlobalErrors().size();\n\t}\n\n\t/**\n\t * Get all global errors.\n\t * @return a list of {@link ObjectError} instances\n\t * @see #getFieldErrors()\n\t */\n\tList<ObjectError> getGlobalErrors();\n\n\t/**\n\t * Get the <i>first</i> global error, if any.\n\t * @return the global error, or {@code null}\n\t * @see #getFieldError()\n\t */\n\tdefault @Nullable ObjectError getGlobalError() {\n\t\treturn getGlobalErrors().stream().findFirst().orElse(null);\n\t}\n\n\t/**\n\t * Determine if there were any errors associated with a field.\n\t * @see #hasGlobalErrors()\n\t */\n\tdefault boolean hasFieldErrors() {\n\t\treturn !getFieldErrors().isEmpty();\n\t}\n\n\t/**\n\t * Determine the number of errors associated with a field.\n\t * @see #getGlobalErrorCount()\n\t */\n\tdefault int getFieldErrorCount() {\n\t\treturn getFieldErrors().size();\n\t}\n\n\t/**\n\t * Get all errors associated with a field.\n\t * @return a List of {@link FieldError} instances\n\t * @see #getGlobalErrors()\n\t */\n\tList<FieldError> getFieldErrors();\n\n\t/**\n\t * Get the <i>first</i> error associated with a field, if any.\n\t * @return the field-specific error, or {@code null}\n\t * @see #getGlobalError()\n\t */\n\tdefault @Nullable FieldError getFieldError() {\n\t\treturn getFieldErrors().stream().findFirst().orElse(null);\n\t}\n\n\t/**\n\t * Determine if there were any errors associated with the given field.\n\t * @param field the field name\n\t * @see #hasFieldErrors()\n\t */\n\tdefault boolean hasFieldErrors(String field) {\n\t\treturn (getFieldError(field) != null);\n\t}\n\n\t/**\n\t * Determine the number of errors associated with the given field.\n\t * @param field the field name\n\t * @see #getFieldErrorCount()\n\t */\n\tdefault int getFieldErrorCount(String field) {\n\t\treturn getFieldErrors(field).size();\n\t}\n\n\t/**\n\t * Get all errors associated with the given field.\n\t * <p>Implementations may support not only full field names like\n\t * \"address.street\" but also pattern matches like \"address.*\".\n\t * @param field the field name\n\t * @return a List of {@link FieldError} instances\n\t * @see #getFieldErrors()\n\t */\n\tdefault List<FieldError> getFieldErrors(String field) {\n\t\treturn getFieldErrors().stream().filter(error -> field.equals(error.getField())).toList();\n\t}\n\n\t/**\n\t * Get the first error associated with the given field, if any.\n\t * @param field the field name\n\t * @return the field-specific error, or {@code null}\n\t * @see #getFieldError()\n\t */\n\tdefault @Nullable FieldError getFieldError(String field) {\n\t\treturn getFieldErrors().stream().filter(error -> field.equals(error.getField())).findFirst().orElse(null);\n\t}\n\n\t/**\n\t * Return the current value of the given field, either the current\n\t * bean property value or a rejected update from the last binding.\n\t * <p>Allows for convenient access to user-specified field values,\n\t * even if there were type mismatches.\n\t * @param field the field name\n\t * @return the current value of the given field\n\t * @see #getFieldType(String)\n\t */\n\t@Nullable Object getFieldValue(String field);\n\n\t/**\n\t * Determine the type of the given field, as far as possible.\n\t * <p>Implementations should be able to determine the type even\n\t * when the field value is {@code null}, for example from some\n\t * associated descriptor.\n\t * @param field the field name\n\t * @return the type of the field, or {@code null} if not determinable\n\t * @see #getFieldValue(String)\n\t */\n\tdefault @Nullable Class<?> getFieldType(String field) {\n\t\treturn Optional.ofNullable(getFieldValue(field)).map(Object::getClass).orElse(null);\n\t}\n\n\t/**\n\t * Return a summary of the recorded errors,\n\t * for example, for inclusion in an exception message.\n\t * @see #failOnError(Function)\n\t */\n\t@Override\n\tString toString();\n\n}"
  },
  "org.springframework.validation.SmartValidator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Extended variant of the {@link Validator} interface, adding support for\n * validation 'hints'.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 3.1\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 29
    },
    "signature": "public interface SmartValidator",
    "source_code": "public interface SmartValidator extends Validator {\n\n\t/**\n\t * Validate the supplied {@code target} object, which must be of a type of {@link Class}\n\t * for which the {@link #supports(Class)} method typically returns {@code true}.\n\t * <p>The supplied {@link Errors errors} instance can be used to report any\n\t * resulting validation errors.\n\t * <p><b>This variant of {@code validate()} supports validation hints, such as\n\t * validation groups against a JSR-303 provider</b> (in which case, the provided hint\n\t * objects need to be annotation arguments of type {@code Class}).\n\t * <p>Note: Validation hints may get ignored by the actual target {@code Validator},\n\t * in which case this method should behave just like its regular\n\t * {@link #validate(Object, Errors)} sibling.\n\t * @param target the object that is to be validated\n\t * @param errors contextual state about the validation process\n\t * @param validationHints one or more hint objects to be passed to the validation engine\n\t * @see jakarta.validation.Validator#validate(Object, Class[])\n\t */\n\tvoid validate(Object target, Errors errors, Object... validationHints);\n\n\t/**\n\t * Validate the supplied value for the specified field on the target type,\n\t * reporting the same validation errors as if the value would be bound to\n\t * the field on an instance of the target class.\n\t * @param targetType the target type\n\t * @param fieldName the name of the field\n\t * @param value the candidate value\n\t * @param errors contextual state about the validation process\n\t * @param validationHints one or more hint objects to be passed to the validation engine\n\t * @since 5.1\n\t * @see jakarta.validation.Validator#validateValue(Class, String, Object, Class[])\n\t */\n\tdefault void validateValue(\n\t\t\tClass<?> targetType, @Nullable String fieldName, @Nullable Object value, Errors errors, Object... validationHints) {\n\n\t\tthrow new IllegalArgumentException(\"Cannot validate individual value for \" + targetType);\n\t}\n\n\t/**\n\t * Return a contained validator instance of the specified type, unwrapping\n\t * as far as necessary.\n\t * @param type the class of the object to return\n\t * @param <T> the type of the object to return\n\t * @return a validator instance of the specified type; {@code null} if there\n\t * isn't a nested validator; an exception may be raised if the specified\n\t * validator type does not match.\n\t * @since 6.1\n\t */\n\tdefault <T> @Nullable T unwrap(@Nullable Class<T> type) {\n\t\treturn null;\n\t}\n\n}"
  },
  "org.springframework.validation.annotation.ValidationAnnotationUtils#determineValidationHints(ann)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine any validation hints by the given annotation.\n\t * <p>This implementation checks for Spring's\n\t * {@link org.springframework.validation.annotation.Validated},\n\t * {@code @jakarta.validation.Valid}, and custom annotations whose\n\t * name starts with \"Valid\" which may optionally declare validation\n\t * hints through the \"value\" attribute.\n\t * @param ann the annotation (potentially a validation annotation)\n\t * @return the validation hints to apply (possibly an empty array),\n\t * or {@code null} if this annotation does not trigger any validation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ann"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "Object[]",
    "signature": "public Object[] determineValidationHints(Annotation ann)",
    "source_code": "\tpublic static Object[] determineValidationHints(Annotation ann) {\n\t\t// Direct presence of @Validated ?\n\t\tif (ann instanceof Validated validated) {\n\t\t\treturn validated.value();\n\t\t}\n\t\t// Direct presence of @Valid ?\n\t\tClass<? extends Annotation> annotationType = ann.annotationType();\n\t\tif (\"jakarta.validation.Valid\".equals(annotationType.getName())) {\n\t\t\treturn EMPTY_OBJECT_ARRAY;\n\t\t}\n\t\t// Meta presence of @Validated ?\n\t\tValidated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class);\n\t\tif (validatedAnn != null) {\n\t\t\treturn validatedAnn.value();\n\t\t}\n\t\t// Custom validation annotation ?\n\t\tif (annotationType.getSimpleName().startsWith(\"Valid\")) {\n\t\t\treturn convertValidationHints(AnnotationUtils.getValue(ann));\n\t\t}\n\t\t// No validation triggered\n\t\treturn null;\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * This is the central class for {@code jakarta.validation} (JSR-303) setup in a Spring\n * application context: It bootstraps a {@code jakarta.validation.ValidationFactory} and\n * exposes it through the Spring {@link org.springframework.validation.Validator} interface\n * as well as through the JSR-303 {@link jakarta.validation.Validator} interface and the\n * {@link jakarta.validation.ValidatorFactory} interface itself.\n *\n * <p>When talking to an instance of this bean through the Spring or JSR-303 Validator interfaces,\n * you'll be talking to the default Validator of the underlying ValidatorFactory. This is very\n * convenient in that you don't have to perform yet another call on the factory, assuming that\n * you will almost always use the default Validator anyway. This can also be injected directly\n * into any target dependency of type {@link org.springframework.validation.Validator}!\n *\n * <p>This class is also being used by Spring's MVC configuration namespace, in case of the\n * {@code jakarta.validation} API being present but no explicit Validator having been configured.\n *\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @since 3.0\n * @see jakarta.validation.ValidatorFactory\n * @see jakarta.validation.Validator\n * @see jakarta.validation.Validation#buildDefaultValidatorFactory()\n * @see jakarta.validation.ValidatorFactory#getValidator()\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "signature": "public class LocalValidatorFactoryBean",
    "source_code": "public class LocalValidatorFactoryBean extends SpringValidatorAdapter"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tConfiguration<?> configuration;\n\t\tif (this.providerClass != null) {\n\t\t\tProviderSpecificBootstrap bootstrap = Validation.byProvider(this.providerClass);\n\t\t\tif (this.validationProviderResolver != null) {\n\t\t\t\tbootstrap = bootstrap.providerResolver(this.validationProviderResolver);\n\t\t\t}\n\t\t\tconfiguration = bootstrap.configure();\n\t\t}\n\t\telse {\n\t\t\tGenericBootstrap bootstrap = Validation.byDefaultProvider();\n\t\t\tif (this.validationProviderResolver != null) {\n\t\t\t\tbootstrap = bootstrap.providerResolver(this.validationProviderResolver);\n\t\t\t}\n\t\t\tconfiguration = bootstrap.configure();\n\t\t}\n\n\t\t// Try Hibernate Validator 5.2's externalClassLoader(ClassLoader) method\n\t\tif (this.applicationContext != null) {\n\t\t\ttry {\n\t\t\t\tMethod eclMethod = configuration.getClass().getMethod(\"externalClassLoader\", ClassLoader.class);\n\t\t\t\tReflectionUtils.invokeMethod(eclMethod, configuration, this.applicationContext.getClassLoader());\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t// Ignore - no Hibernate Validator 5.2+ or similar provider\n\t\t\t}\n\t\t}\n\n\t\tMessageInterpolator targetInterpolator = this.messageInterpolator;\n\t\tif (targetInterpolator == null) {\n\t\t\ttargetInterpolator = configuration.getDefaultMessageInterpolator();\n\t\t}\n\t\tconfiguration.messageInterpolator(new LocaleContextMessageInterpolator(targetInterpolator));\n\n\t\tif (this.traversableResolver != null) {\n\t\t\tconfiguration.traversableResolver(this.traversableResolver);\n\t\t}\n\n\t\tConstraintValidatorFactory targetConstraintValidatorFactory = this.constraintValidatorFactory;\n\t\tif (targetConstraintValidatorFactory == null && this.applicationContext != null) {\n\t\t\ttargetConstraintValidatorFactory =\n\t\t\t\t\tnew SpringConstraintValidatorFactory(this.applicationContext.getAutowireCapableBeanFactory());\n\t\t}\n\t\tif (targetConstraintValidatorFactory != null) {\n\t\t\tconfiguration.constraintValidatorFactory(targetConstraintValidatorFactory);\n\t\t}\n\n\t\tif (this.parameterNameDiscoverer != null) {\n\t\t\tconfigureParameterNameProvider(this.parameterNameDiscoverer, configuration);\n\t\t}\n\n\t\tList<InputStream> mappingStreams = null;\n\t\tif (this.mappingLocations != null) {\n\t\t\tmappingStreams = new ArrayList<>(this.mappingLocations.length);\n\t\t\tfor (Resource location : this.mappingLocations) {\n\t\t\t\ttry {\n\t\t\t\t\tInputStream stream = location.getInputStream();\n\t\t\t\t\tmappingStreams.add(stream);\n\t\t\t\t\tconfiguration.addMapping(stream);\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\tcloseMappingStreams(mappingStreams);\n\t\t\t\t\tthrow new IllegalStateException(\"Cannot read mapping resource: \" + location);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.validationPropertyMap.forEach(configuration::addProperty);\n\n\t\t// Allow for custom post-processing before we actually build the ValidatorFactory.\n\t\tif (this.configurationInitializer != null) {\n\t\t\tthis.configurationInitializer.accept(configuration);\n\t\t}\n\t\tpostProcessConfiguration(configuration);\n\n\t\ttry {\n\t\t\tthis.validatorFactory = configuration.buildValidatorFactory();\n\t\t\tsetTargetValidator(this.validatorFactory.getValidator());\n\t\t}\n\t\tfinally {\n\t\t\tcloseMappingStreams(mappingStreams);\n\t\t}\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#buildMessageInterpolator(messageSource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSource"
    ],
    "position": {
      "column": 1,
      "line": 457
    },
    "return": "MessageInterpolator",
    "signature": "public MessageInterpolator buildMessageInterpolator(MessageSource messageSource)",
    "source_code": "\t\tpublic static MessageInterpolator buildMessageInterpolator(MessageSource messageSource) {\n\t\t\treturn new ResourceBundleMessageInterpolator(new MessageSourceResourceBundleLocator(messageSource));\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 440
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\tpublic void close() {\n\t\tif (this.validatorFactory != null) {\n\t\t\tthis.validatorFactory.close();\n\t\t}\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 447
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t\tclose();\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#getClockProvider()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "ClockProvider",
    "signature": "public ClockProvider getClockProvider()",
    "source_code": "\tpublic ClockProvider getClockProvider() {\n\t\tAssert.state(this.validatorFactory != null, \"No target ValidatorFactory set\");\n\t\treturn this.validatorFactory.getClockProvider();\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#getConstraintValidatorFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 396
    },
    "return": "ConstraintValidatorFactory",
    "signature": "public ConstraintValidatorFactory getConstraintValidatorFactory()",
    "source_code": "\tpublic ConstraintValidatorFactory getConstraintValidatorFactory() {\n\t\tAssert.state(this.validatorFactory != null, \"No target ValidatorFactory set\");\n\t\treturn this.validatorFactory.getConstraintValidatorFactory();\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#getMessageInterpolator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "MessageInterpolator",
    "signature": "public MessageInterpolator getMessageInterpolator()",
    "source_code": "\tpublic MessageInterpolator getMessageInterpolator() {\n\t\tAssert.state(this.validatorFactory != null, \"No target ValidatorFactory set\");\n\t\treturn this.validatorFactory.getMessageInterpolator();\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#getParameterNameProvider()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 402
    },
    "return": "ParameterNameProvider",
    "signature": "public ParameterNameProvider getParameterNameProvider()",
    "source_code": "\tpublic ParameterNameProvider getParameterNameProvider() {\n\t\tAssert.state(this.validatorFactory != null, \"No target ValidatorFactory set\");\n\t\treturn this.validatorFactory.getParameterNameProvider();\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#getParameterNames(constructor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constructor"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "List<String>",
    "signature": "public List<String> getParameterNames(Constructor<?> constructor)",
    "source_code": "\t\t\tpublic List<String> getParameterNames(Constructor<?> constructor) {\n\t\t\t\t@Nullable String[] paramNames = discoverer.getParameterNames(constructor);\n\t\t\t\treturn (paramNames != null ? Arrays.asList(paramNames) :\n\t\t\t\t\t\tdefaultProvider.getParameterNames(constructor));\n\t\t\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#getParameterNames(method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "List<String>",
    "signature": "public List<String> getParameterNames(Method method)",
    "source_code": "\t\t\tpublic List<String> getParameterNames(Method method) {\n\t\t\t\t@Nullable String[] paramNames = discoverer.getParameterNames(method);\n\t\t\t\treturn (paramNames != null ? Arrays.asList(paramNames) :\n\t\t\t\t\t\tdefaultProvider.getParameterNames(method));\n\t\t\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#getTraversableResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "TraversableResolver",
    "signature": "public TraversableResolver getTraversableResolver()",
    "source_code": "\tpublic TraversableResolver getTraversableResolver() {\n\t\tAssert.state(this.validatorFactory != null, \"No target ValidatorFactory set\");\n\t\treturn this.validatorFactory.getTraversableResolver();\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#getValidationPropertyMap()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Allow Map access to the bean validation properties to be passed to the validation provider,\n\t * with the option to add or override specific entries.\n\t * <p>Useful for specifying entries directly, for example via \"validationPropertyMap[myKey]\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "String>",
    "signature": "public String> getValidationPropertyMap()",
    "source_code": "\tpublic Map<String, String> getValidationPropertyMap() {\n\t\treturn this.validationPropertyMap;\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#getValidator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "Validator",
    "signature": "public Validator getValidator()",
    "source_code": "\tpublic Validator getValidator() {\n\t\tAssert.state(this.validatorFactory != null, \"No target ValidatorFactory set\");\n\t\treturn this.validatorFactory.getValidator();\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#postProcessConfiguration(configuration)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Post-process the given Bean Validation configuration,\n\t * adding to or overriding any of its settings.\n\t * <p>Invoked right before building the {@link ValidatorFactory}.\n\t * @param configuration the Configuration object, pre-populated with\n\t * settings driven by LocalValidatorFactoryBean's properties\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "configuration"
    ],
    "position": {
      "column": 1,
      "line": 367
    },
    "return": "void",
    "signature": "protected void postProcessConfiguration(Configuration<?> configuration)",
    "source_code": "\tprotected void postProcessConfiguration(Configuration<?> configuration) {\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#setApplicationContext(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "void",
    "signature": "public void setApplicationContext(ApplicationContext applicationContext)",
    "source_code": "\tpublic void setApplicationContext(ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#setConfigurationInitializer(configurationInitializer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a callback for customizing the Bean Validation {@code Configuration} instance,\n\t * as an alternative to overriding the {@link #postProcessConfiguration(Configuration)}\n\t * method in custom {@code LocalValidatorFactoryBean} subclasses.\n\t * <p>This enables convenient customizations for application purposes. Infrastructure\n\t * extensions may keep overriding the {@link #postProcessConfiguration} template method.\n\t * @since 5.3.19\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configurationInitializer"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "void",
    "signature": "public void setConfigurationInitializer(Consumer<Configuration<?>> configurationInitializer)",
    "source_code": "\tpublic void setConfigurationInitializer(Consumer<Configuration<?>> configurationInitializer) {\n\t\tthis.configurationInitializer = configurationInitializer;\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#setConstraintValidatorFactory(constraintValidatorFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a custom ConstraintValidatorFactory to use for this ValidatorFactory.\n\t * <p>Default is a {@link SpringConstraintValidatorFactory}, delegating to the\n\t * containing ApplicationContext for creating autowired ConstraintValidator instances.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constraintValidatorFactory"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "void",
    "signature": "public void setConstraintValidatorFactory(ConstraintValidatorFactory constraintValidatorFactory)",
    "source_code": "\tpublic void setConstraintValidatorFactory(ConstraintValidatorFactory constraintValidatorFactory) {\n\t\tthis.constraintValidatorFactory = constraintValidatorFactory;\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#setMappingLocations(mappingLocations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify resource locations to load XML constraint mapping files from, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappingLocations"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "public void setMappingLocations(Resource... mappingLocations)",
    "source_code": "\tpublic void setMappingLocations(Resource... mappingLocations) {\n\t\tthis.mappingLocations = mappingLocations;\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#setMessageInterpolator(messageInterpolator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a custom MessageInterpolator to use for this ValidatorFactory\n\t * and its exposed default Validator.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageInterpolator"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void setMessageInterpolator(MessageInterpolator messageInterpolator)",
    "source_code": "\tpublic void setMessageInterpolator(MessageInterpolator messageInterpolator) {\n\t\tthis.messageInterpolator = messageInterpolator;\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#setParameterNameDiscoverer(parameterNameDiscoverer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the ParameterNameDiscoverer to use for resolving method and constructor\n\t * parameter names if needed for message interpolation.\n\t * <p>Default is Hibernate Validator's own internal use of standard Java reflection.\n\t * This may be overridden with a custom subclass or a Spring-controlled\n\t * {@link org.springframework.core.DefaultParameterNameDiscoverer} if necessary.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterNameDiscoverer"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "public void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer)",
    "source_code": "\tpublic void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tthis.parameterNameDiscoverer = parameterNameDiscoverer;\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#setProviderClass(providerClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the desired provider class, if any.\n\t * <p>If not specified, JSR-303's default search mechanism will be used.\n\t * @see jakarta.validation.Validation#byProvider(Class)\n\t * @see jakarta.validation.Validation#byDefaultProvider()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "providerClass"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "void",
    "signature": "public void setProviderClass(Class providerClass)",
    "source_code": "\tpublic void setProviderClass(Class providerClass) {\n\t\tthis.providerClass = providerClass;\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#setTraversableResolver(traversableResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a custom TraversableResolver to use for this ValidatorFactory\n\t * and its exposed default Validator.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "traversableResolver"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "void",
    "signature": "public void setTraversableResolver(TraversableResolver traversableResolver)",
    "source_code": "\tpublic void setTraversableResolver(TraversableResolver traversableResolver) {\n\t\tthis.traversableResolver = traversableResolver;\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#setValidationMessageSource(messageSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a custom Spring MessageSource for resolving validation messages,\n\t * instead of relying on JSR-303's default \"ValidationMessages.properties\" bundle\n\t * in the classpath. This may refer to a Spring context's shared \"messageSource\" bean,\n\t * or to some special MessageSource setup for validation purposes only.\n\t * <p><b>NOTE:</b> This feature requires Hibernate Validator 4.3 or higher on the classpath.\n\t * You may nevertheless use a different validation provider but Hibernate Validator's\n\t * {@link ResourceBundleMessageInterpolator} class must be accessible during configuration.\n\t * <p>Specify either this property or {@link #setMessageInterpolator \"messageInterpolator\"},\n\t * not both. If you would like to build a custom MessageInterpolator, consider deriving from\n\t * Hibernate Validator's {@link ResourceBundleMessageInterpolator} and passing in a\n\t * Spring-based {@code ResourceBundleLocator} when constructing your interpolator.\n\t * <p>In order for Hibernate's default validation messages to be resolved still, your\n\t * {@link MessageSource} must be configured for optional resolution (usually the default).\n\t * In particular, the {@code MessageSource} instance specified here should not apply\n\t * {@link org.springframework.context.support.AbstractMessageSource#setUseCodeAsDefaultMessage\n\t * \"useCodeAsDefaultMessage\"} behavior. Please double-check your setup accordingly.\n\t * @see ResourceBundleMessageInterpolator\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSource"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "public void setValidationMessageSource(MessageSource messageSource)",
    "source_code": "\tpublic void setValidationMessageSource(MessageSource messageSource) {\n\t\tthis.messageInterpolator = HibernateValidatorDelegate.buildMessageInterpolator(messageSource);\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#setValidationProperties(jpaProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify bean validation properties to be passed to the validation provider.\n\t * <p>Can be populated with a String \"value\" (parsed via PropertiesEditor)\n\t * or a \"props\" element in XML bean definitions.\n\t * @see jakarta.validation.Configuration#addProperty(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jpaProperties"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void setValidationProperties(Properties jpaProperties)",
    "source_code": "\tpublic void setValidationProperties(Properties jpaProperties) {\n\t\tCollectionUtils.mergePropertiesIntoMap(jpaProperties, this.validationPropertyMap);\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#setValidationPropertyMap(Map<String,validationProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify bean validation properties to be passed to the validation provider as a Map.\n\t * <p>Can be populated with a \"map\" or \"props\" element in XML bean definitions.\n\t * @see jakarta.validation.Configuration#addProperty(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "validationProperties"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "void",
    "signature": "public void setValidationPropertyMap(@Nullable Map<String, String> validationProperties)",
    "source_code": "\tpublic void setValidationPropertyMap(@Nullable Map<String, String> validationProperties) {\n\t\tif (validationProperties != null) {\n\t\t\tthis.validationPropertyMap.putAll(validationProperties);\n\t\t}\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#setValidationProviderResolver(validationProviderResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a JSR-303 {@link ValidationProviderResolver} for bootstrapping the\n\t * provider of choice, as an alternative to {@code META-INF} driven resolution.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "validationProviderResolver"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void setValidationProviderResolver(ValidationProviderResolver validationProviderResolver)",
    "source_code": "\tpublic void setValidationProviderResolver(ValidationProviderResolver validationProviderResolver) {\n\t\tthis.validationProviderResolver = validationProviderResolver;\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#unwrap(type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "T",
    "signature": "public T unwrap(@Nullable Class<T> type)",
    "source_code": "\tpublic <T> T unwrap(@Nullable Class<T> type) {\n\t\tif (type == null || !ValidatorFactory.class.isAssignableFrom(type)) {\n\t\t\ttry {\n\t\t\t\treturn super.unwrap(type);\n\t\t\t}\n\t\t\tcatch (ValidationException ex) {\n\t\t\t\t// Ignore - we'll try ValidatorFactory unwrapping next\n\t\t\t}\n\t\t}\n\t\tif (this.validatorFactory != null) {\n\t\t\ttry {\n\t\t\t\treturn this.validatorFactory.unwrap(type);\n\t\t\t}\n\t\t\tcatch (ValidationException ex) {\n\t\t\t\t// Ignore if just being asked for ValidatorFactory\n\t\t\t\tif (ValidatorFactory.class == type) {\n\t\t\t\t\treturn (T) this.validatorFactory;\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t\tthrow new ValidationException(\"Cannot unwrap to \" + type);\n\t}"
  },
  "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean#usingContext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 378
    },
    "return": "ValidatorContext",
    "signature": "public ValidatorContext usingContext()",
    "source_code": "\tpublic ValidatorContext usingContext() {\n\t\tAssert.state(this.validatorFactory != null, \"No target ValidatorFactory set\");\n\t\treturn this.validatorFactory.usingContext();\n\t}"
  },
  "org.springframework.validation.beanvalidation.SpringValidatorAdapter#getArguments()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 427
    },
    "return": "Object[]",
    "signature": "public Object[] getArguments()",
    "source_code": "\t\tpublic Object[] getArguments() {\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.validation.method.MethodValidator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Contract to apply method validation and handle the results.\n * Exposes methods that return {@link MethodValidationResult}, and methods that\n * handle the results, by default raising {@link MethodValidationException}.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 33
    },
    "signature": "public interface MethodValidator",
    "source_code": "public interface MethodValidator {\n\n\t/**\n\t * Determine the applicable validation groups. By default, obtained from an\n\t * {@link org.springframework.validation.annotation.Validated @Validated}\n\t * annotation on the method, or on the class level.\n\t * @param target the target Object\n\t * @param method the target method\n\t * @return the applicable validation groups as a {@code Class} array\n\t */\n\tClass<?>[] determineValidationGroups(Object target, Method method);\n\n\t/**\n\t * Validate the given method arguments and return validation results.\n\t * @param target the target Object\n\t * @param method the target method\n\t * @param parameters the parameters, if already created and available\n\t * @param arguments the candidate argument values to validate\n\t * @param groups validation groups from {@link #determineValidationGroups}\n\t * @return the result of validation\n\t */\n\tMethodValidationResult validateArguments(\n\t\t\tObject target, Method method, MethodParameter @Nullable [] parameters,\n\t\t\t@Nullable Object[] arguments, Class<?>[] groups);\n\n\t/**\n\t * Delegate to {@link #validateArguments} and handle the validation result,\n\t * by default raising {@link MethodValidationException} in case of errors.\n\t * Implementations may provide alternative handling, for example, injecting\n\t * {@link org.springframework.validation.Errors} into the method.\n\t * @throws MethodValidationException in case of unhandled errors.\n\t */\n\tdefault void applyArgumentValidation(\n\t\t\tObject target, Method method, MethodParameter @Nullable [] parameters,\n\t\t\t@Nullable Object[] arguments, Class<?>[] groups) {\n\n\t\tMethodValidationResult result = validateArguments(target, method, parameters, arguments, groups);\n\t\tif (result.hasErrors()) {\n\t\t\tthrow new MethodValidationException(result);\n\t\t}\n\t}\n\n\t/**\n\t * Validate the given return value and return validation results.\n\t * @param target the target Object\n\t * @param method the target method\n\t * @param returnType the return parameter, if already created and available\n\t * @param returnValue the return value to validate\n\t * @param groups validation groups from {@link #determineValidationGroups}\n\t * @return the result of validation\n\t */\n\tMethodValidationResult validateReturnValue(\n\t\t\tObject target, Method method, @Nullable MethodParameter returnType,\n\t\t\t@Nullable Object returnValue, Class<?>[] groups);\n\n\t/**\n\t * Delegate to {@link #validateReturnValue} and handle the validation result,\n\t * by default raising {@link MethodValidationException} in case of errors.\n\t * Implementations may provide alternative handling.\n\t * @throws MethodValidationException in case of unhandled errors.\n\t */\n\tdefault void applyReturnValueValidation(\n\t\t\tObject target, Method method, @Nullable MethodParameter returnType,\n\t\t\t@Nullable Object returnValue, Class<?>[] groups) {\n\n\t\tMethodValidationResult result = validateReturnValue(target, method, returnType, returnValue, groups);\n\t\tif (result.hasErrors()) {\n\t\t\tthrow new MethodValidationException(result);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.validation.method.ParameterErrors": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Extension of {@link ParameterValidationResult} created for Object method\n * parameters or return values with nested errors on their properties.\n *\n * <p>The base class method {@link #getResolvableErrors()} returns\n * {@link Errors#getAllErrors()}, but this subclass provides access to the same\n * as {@link FieldError}s.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class ParameterErrors",
    "source_code": "public class ParameterErrors extends ParameterValidationResult implements Errors {\n\n\tprivate final Errors errors;\n\n\n\t/**\n\t * Create a {@code ParameterErrors}.\n\t */\n\tpublic ParameterErrors(\n\t\t\tMethodParameter parameter, @Nullable Object argument, Errors errors,\n\t\t\t@Nullable Object container, @Nullable Integer index, @Nullable Object key) {\n\n\t\tsuper(parameter, argument, errors.getAllErrors(),\n\t\t\t\tcontainer, index, key, (error, sourceType) -> ((FieldError) error).unwrap(sourceType));\n\n\t\tthis.errors = errors;\n\t}\n\n\n\t// Errors implementation\n\n\t@Override\n\tpublic String getObjectName() {\n\t\treturn this.errors.getObjectName();\n\t}\n\n\t@Override\n\tpublic void setNestedPath(String nestedPath) {\n\t\tthis.errors.setNestedPath(nestedPath);\n\t}\n\n\t@Override\n\tpublic String getNestedPath() {\n\t\treturn this.errors.getNestedPath();\n\t}\n\n\t@Override\n\tpublic void pushNestedPath(String subPath) {\n\t\tthis.errors.pushNestedPath(subPath);\n\t}\n\n\t@Override\n\tpublic void popNestedPath() throws IllegalStateException {\n\t\tthis.errors.popNestedPath();\n\t}\n\n\t@Override\n\tpublic void reject(String errorCode) {\n\t\tthis.errors.reject(errorCode);\n\t}\n\n\t@Override\n\tpublic void reject(String errorCode, String defaultMessage) {\n\t\tthis.errors.reject(errorCode, defaultMessage);\n\t}\n\n\t@Override\n\tpublic void reject(String errorCode, Object @Nullable [] errorArgs, @Nullable String defaultMessage) {\n\t\tthis.errors.reject(errorCode, errorArgs, defaultMessage);\n\t}\n\n\t@Override\n\tpublic void rejectValue(@Nullable String field, String errorCode) {\n\t\tthis.errors.rejectValue(field, errorCode);\n\t}\n\n\t@Override\n\tpublic void rejectValue(@Nullable String field, String errorCode, String defaultMessage) {\n\t\tthis.errors.rejectValue(field, errorCode, defaultMessage);\n\t}\n\n\t@Override\n\tpublic void rejectValue(@Nullable String field, String errorCode,\n\t\t\tObject @Nullable [] errorArgs, @Nullable String defaultMessage) {\n\n\t\tthis.errors.rejectValue(field, errorCode, errorArgs, defaultMessage);\n\t}\n\n\t@Override\n\tpublic void addAllErrors(Errors errors) {\n\t\tthis.errors.addAllErrors(errors);\n\t}\n\n\t@Override\n\tpublic boolean hasErrors() {\n\t\treturn this.errors.hasErrors();\n\t}\n\n\t@Override\n\tpublic int getErrorCount() {\n\t\treturn this.errors.getErrorCount();\n\t}\n\n\t@Override\n\tpublic List<ObjectError> getAllErrors() {\n\t\treturn this.errors.getAllErrors();\n\t}\n\n\t@Override\n\tpublic boolean hasGlobalErrors() {\n\t\treturn this.errors.hasGlobalErrors();\n\t}\n\n\t@Override\n\tpublic int getGlobalErrorCount() {\n\t\treturn this.errors.getGlobalErrorCount();\n\t}\n\n\t@Override\n\tpublic List<ObjectError> getGlobalErrors() {\n\t\treturn this.errors.getGlobalErrors();\n\t}\n\n\t@Override\n\tpublic @Nullable ObjectError getGlobalError() {\n\t\treturn this.errors.getGlobalError();\n\t}\n\n\t@Override\n\tpublic boolean hasFieldErrors() {\n\t\treturn this.errors.hasFieldErrors();\n\t}\n\n\t@Override\n\tpublic int getFieldErrorCount() {\n\t\treturn this.errors.getFieldErrorCount();\n\t}\n\n\t@Override\n\tpublic List<FieldError> getFieldErrors() {\n\t\treturn this.errors.getFieldErrors();\n\t}\n\n\t@Override\n\tpublic @Nullable FieldError getFieldError() {\n\t\treturn this.errors.getFieldError();\n\t}\n\n\t@Override\n\tpublic boolean hasFieldErrors(String field) {\n\t\treturn this.errors.hasFieldErrors(field);\n\t}\n\n\t@Override\n\tpublic int getFieldErrorCount(String field) {\n\t\treturn this.errors.getFieldErrorCount(field);\n\t}\n\n\t@Override\n\tpublic List<FieldError> getFieldErrors(String field) {\n\t\treturn this.errors.getFieldErrors(field);\n\t}\n\n\t@Override\n\tpublic @Nullable FieldError getFieldError(String field) {\n\t\treturn this.errors.getFieldError(field);\n\t}\n\n\t@Override\n\tpublic @Nullable Object getFieldValue(String field) {\n\t\treturn this.errors.getFieldError(field);\n\t}\n\n\t@Override\n\tpublic @Nullable Class<?> getFieldType(String field) {\n\t\treturn this.errors.getFieldType(field);\n\t}\n\n}"
  },
  "org.springframework.validation.method.ParameterErrors#addAllErrors(errors)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "void",
    "signature": "public void addAllErrors(Errors errors)",
    "source_code": "\tpublic void addAllErrors(Errors errors) {\n\t\tthis.errors.addAllErrors(errors);\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#getAllErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "List<ObjectError>",
    "signature": "public List<ObjectError> getAllErrors()",
    "source_code": "\tpublic List<ObjectError> getAllErrors() {\n\t\treturn this.errors.getAllErrors();\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#getErrorCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "int",
    "signature": "public int getErrorCount()",
    "source_code": "\tpublic int getErrorCount() {\n\t\treturn this.errors.getErrorCount();\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#getFieldError()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "FieldError",
    "signature": "public FieldError getFieldError()",
    "source_code": "\tpublic @Nullable FieldError getFieldError() {\n\t\treturn this.errors.getFieldError();\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#getFieldError(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "FieldError",
    "signature": "public FieldError getFieldError(String field)",
    "source_code": "\tpublic @Nullable FieldError getFieldError(String field) {\n\t\treturn this.errors.getFieldError(field);\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#getFieldErrorCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "int",
    "signature": "public int getFieldErrorCount()",
    "source_code": "\tpublic int getFieldErrorCount() {\n\t\treturn this.errors.getFieldErrorCount();\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#getFieldErrorCount(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "int",
    "signature": "public int getFieldErrorCount(String field)",
    "source_code": "\tpublic int getFieldErrorCount(String field) {\n\t\treturn this.errors.getFieldErrorCount(field);\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#getFieldErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "List<FieldError>",
    "signature": "public List<FieldError> getFieldErrors()",
    "source_code": "\tpublic List<FieldError> getFieldErrors() {\n\t\treturn this.errors.getFieldErrors();\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#getFieldErrors(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "List<FieldError>",
    "signature": "public List<FieldError> getFieldErrors(String field)",
    "source_code": "\tpublic List<FieldError> getFieldErrors(String field) {\n\t\treturn this.errors.getFieldErrors(field);\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#getFieldValue(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "Object",
    "signature": "public Object getFieldValue(String field)",
    "source_code": "\tpublic @Nullable Object getFieldValue(String field) {\n\t\treturn this.errors.getFieldError(field);\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#getGlobalError()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "ObjectError",
    "signature": "public ObjectError getGlobalError()",
    "source_code": "\tpublic @Nullable ObjectError getGlobalError() {\n\t\treturn this.errors.getGlobalError();\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#getGlobalErrorCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "int",
    "signature": "public int getGlobalErrorCount()",
    "source_code": "\tpublic int getGlobalErrorCount() {\n\t\treturn this.errors.getGlobalErrorCount();\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#getGlobalErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "List<ObjectError>",
    "signature": "public List<ObjectError> getGlobalErrors()",
    "source_code": "\tpublic List<ObjectError> getGlobalErrors() {\n\t\treturn this.errors.getGlobalErrors();\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#getNestedPath()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "String",
    "signature": "public String getNestedPath()",
    "source_code": "\tpublic String getNestedPath() {\n\t\treturn this.errors.getNestedPath();\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#getObjectName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "String",
    "signature": "public String getObjectName()",
    "source_code": "\tpublic String getObjectName() {\n\t\treturn this.errors.getObjectName();\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#hasErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "boolean",
    "signature": "public boolean hasErrors()",
    "source_code": "\tpublic boolean hasErrors() {\n\t\treturn this.errors.hasErrors();\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#hasFieldErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "boolean",
    "signature": "public boolean hasFieldErrors()",
    "source_code": "\tpublic boolean hasFieldErrors() {\n\t\treturn this.errors.hasFieldErrors();\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#hasFieldErrors(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "boolean",
    "signature": "public boolean hasFieldErrors(String field)",
    "source_code": "\tpublic boolean hasFieldErrors(String field) {\n\t\treturn this.errors.hasFieldErrors(field);\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#hasGlobalErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "boolean",
    "signature": "public boolean hasGlobalErrors()",
    "source_code": "\tpublic boolean hasGlobalErrors() {\n\t\treturn this.errors.hasGlobalErrors();\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#popNestedPath()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "void",
    "signature": "public void popNestedPath()",
    "source_code": "\tpublic void popNestedPath() throws IllegalStateException {\n\t\tthis.errors.popNestedPath();\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#pushNestedPath(subPath)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subPath"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "void",
    "signature": "public void pushNestedPath(String subPath)",
    "source_code": "\tpublic void pushNestedPath(String subPath) {\n\t\tthis.errors.pushNestedPath(subPath);\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#reject(errorCode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void reject(String errorCode)",
    "source_code": "\tpublic void reject(String errorCode) {\n\t\tthis.errors.reject(errorCode);\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#reject(errorCode,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void reject(String errorCode, String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, String defaultMessage) {\n\t\tthis.errors.reject(errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#reject(errorCode,errorArgs,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void reject(String errorCode, Object @Nullable [] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, Object @Nullable [] errorArgs, @Nullable String defaultMessage) {\n\t\tthis.errors.reject(errorCode, errorArgs, defaultMessage);\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#rejectValue(field,errorCode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode) {\n\t\tthis.errors.rejectValue(field, errorCode);\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#rejectValue(field,errorCode,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode, String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode, String defaultMessage) {\n\t\tthis.errors.rejectValue(field, errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.validation.method.ParameterErrors#rejectValue(field,errorCode,errorArgs,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode,\n\t\t\tObject @Nullable [] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode,"
  },
  "org.springframework.validation.method.ParameterErrors#setNestedPath(nestedPath)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestedPath"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void setNestedPath(String nestedPath)",
    "source_code": "\tpublic void setNestedPath(String nestedPath) {\n\t\tthis.errors.setNestedPath(nestedPath);\n\t}"
  },
  "org.springframework.web.<unknown>#build()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "ErrorResponse",
    "signature": "public ErrorResponse build()",
    "source_code": "\tpublic ErrorResponse build() {\n\t\treturn new SimpleErrorResponse(\n\t\t\t\tthis.exception, this.statusCode, this.headers, this.problemDetail,\n\t\t\t\tthis.typeMessageCode, this.titleMessageCode, this.detailMessageCode,\n\t\t\t\tthis.detailMessageArguments);\n\t}"
  },
  "org.springframework.web.<unknown>#getBody()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "ProblemDetail",
    "signature": "public ProblemDetail getBody()",
    "source_code": "\t\tpublic ProblemDetail getBody() {\n\t\t\treturn this.problemDetail;\n\t\t}"
  },
  "org.springframework.web.<unknown>#getDetailMessageCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "String",
    "signature": "public String getDetailMessageCode()",
    "source_code": "\t\tpublic String getDetailMessageCode() {\n\t\t\treturn this.detailMessageCode;\n\t\t}"
  },
  "org.springframework.web.<unknown>#getHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHeaders()",
    "source_code": "\t\tpublic HttpHeaders getHeaders() {\n\t\t\treturn this.headers;\n\t\t}"
  },
  "org.springframework.web.<unknown>#getStatusCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "HttpStatusCode",
    "signature": "public HttpStatusCode getStatusCode()",
    "source_code": "\t\tpublic HttpStatusCode getStatusCode() {\n\t\t\treturn this.statusCode;\n\t\t}"
  },
  "org.springframework.web.<unknown>#getTitleMessageCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "String",
    "signature": "public String getTitleMessageCode()",
    "source_code": "\t\tpublic String getTitleMessageCode() {\n\t\t\treturn this.titleMessageCode;\n\t\t}"
  },
  "org.springframework.web.<unknown>#getTypeMessageCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "String",
    "signature": "public String getTypeMessageCode()",
    "source_code": "\t\tpublic String getTypeMessageCode() {\n\t\t\treturn this.typeMessageCode;\n\t\t}"
  },
  "org.springframework.web.<unknown>#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn \"ErrorResponse{status=\" + this.statusCode + \", \" +\n\t\t\t\t\t\"headers=\" + this.headers + \", body=\" + this.problemDetail + \", \" +\n\t\t\t\t\t\"exception=\" + this.exception + \"}\";\n\t\t}"
  },
  "org.springframework.web.ErrorResponse": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Representation of a complete RFC 9457 error response including status,\n * headers, and an RFC 9457 formatted {@link ProblemDetail} body. Allows any\n * exception to expose HTTP error response information.\n *\n * <p>{@link ErrorResponseException} is a default implementation of this\n * interface and a convenient base class for other exceptions to use.\n *\n * <p>{@code ErrorResponse} is supported as a return value from\n * {@code @ExceptionHandler} methods that render directly to the response, for example,\n * by being marked {@code @ResponseBody}, or declared in an\n * {@code @RestController} or {@code RestControllerAdvice} class.\n *\n * @author Rossen Stoyanchev\n * @since 6.0\n * @see ErrorResponseException\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public interface ErrorResponse",
    "source_code": "public interface ErrorResponse {\n\n\t/**\n\t * Return the HTTP status code to use for the response.\n\t */\n\tHttpStatusCode getStatusCode();\n\n\t/**\n\t * Return headers to use for the response.\n\t */\n\tdefault HttpHeaders getHeaders() {\n\t\treturn HttpHeaders.EMPTY;\n\t}\n\n\t/**\n\t * Return the body for the response, formatted as an RFC 9457\n\t * {@link ProblemDetail} whose {@link ProblemDetail#getStatus() status}\n\t * should match the response status.\n\t * <p><strong>Note:</strong> The returned {@code ProblemDetail} may be\n\t * updated before the response is rendered, for example, via\n\t * {@link #updateAndGetBody(MessageSource, Locale)}. Therefore, implementing\n\t * methods should use an instance field, and should not re-create the\n\t * {@code ProblemDetail} on every call, nor use a static variable.\n\t */\n\tProblemDetail getBody();\n\n\n\t// MessageSource codes and arguments\n\n\t/**\n\t * Return a code to use to resolve the problem \"type\" for this exception\n\t * through a {@link MessageSource}. The type resolved through the\n\t * {@code MessageSource} will be passed into {@link URI#create(String)}\n\t * and therefore must be an encoded URI String.\n\t * <p>By default this is initialized via {@link #getDefaultTypeMessageCode(Class)}.\n\t * @since 6.1\n\t */\n\tdefault String getTypeMessageCode() {\n\t\treturn getDefaultTypeMessageCode(getClass());\n\t}\n\n\t/**\n\t * Return a code to use to resolve the problem \"title\" for this exception\n\t * through a {@link MessageSource}.\n\t * <p>By default this is initialized via {@link #getDefaultTitleMessageCode(Class)}.\n\t */\n\tdefault String getTitleMessageCode() {\n\t\treturn getDefaultTitleMessageCode(getClass());\n\t}\n\n\t/**\n\t * Return a code to use to resolve the problem \"detail\" for this exception\n\t * through a {@link MessageSource}.\n\t * <p>By default this is initialized via\n\t * {@link #getDefaultDetailMessageCode(Class, String)}.\n\t */\n\tdefault String getDetailMessageCode() {\n\t\treturn getDefaultDetailMessageCode(getClass(), null);\n\t}\n\n\t/**\n\t * Return arguments to use along with a {@link #getDetailMessageCode()\n\t * message code} to resolve the problem \"detail\" for this exception\n\t * through a {@link MessageSource}. The arguments are expanded\n\t * into placeholders of the message value, for example, \"Invalid content type {0}\".\n\t */\n\tdefault Object @Nullable [] getDetailMessageArguments() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Variant of {@link #getDetailMessageArguments()} that uses the given\n\t * {@link MessageSource} for resolving the message argument values.\n\t * <p>This is useful for example to expand message codes from validation errors.\n\t * <p>The default implementation delegates to {@link #getDetailMessageArguments()},\n\t * ignoring the supplied {@code MessageSource} and {@code Locale}.\n\t * @param messageSource the {@code MessageSource} to use for the lookup\n\t * @param locale the {@code Locale} to use for the lookup\n\t */\n\tdefault Object @Nullable [] getDetailMessageArguments(MessageSource messageSource, Locale locale) {\n\t\treturn getDetailMessageArguments();\n\t}\n\n\t/**\n\t * Use the given {@link MessageSource} to resolve the\n\t * {@link #getTypeMessageCode() type}, {@link #getTitleMessageCode() title},\n\t * and {@link #getDetailMessageCode() detail} message codes, and then use the\n\t * resolved values to update the corresponding fields in {@link #getBody()}.\n\t * @param messageSource the {@code MessageSource} to use for the lookup\n\t * @param locale the {@code Locale} to use for the lookup\n\t */\n\tdefault ProblemDetail updateAndGetBody(@Nullable MessageSource messageSource, Locale locale) {\n\t\tif (messageSource != null) {\n\t\t\tString type = messageSource.getMessage(getTypeMessageCode(), null, null, locale);\n\t\t\tif (type != null) {\n\t\t\t\tgetBody().setType(URI.create(type));\n\t\t\t}\n\t\t\tObject[] arguments = getDetailMessageArguments(messageSource, locale);\n\t\t\tString detail = messageSource.getMessage(getDetailMessageCode(), arguments, null, locale);\n\t\t\tif (detail != null) {\n\t\t\t\tgetBody().setDetail(detail);\n\t\t\t}\n\t\t\tString title = messageSource.getMessage(getTitleMessageCode(), null, null, locale);\n\t\t\tif (title != null) {\n\t\t\t\tgetBody().setTitle(title);\n\t\t\t}\n\t\t}\n\t\treturn getBody();\n\t}\n\n\n\t/**\n\t * Build a message code for the \"type\" field, for the given exception type.\n\t * @param exceptionType the exception type associated with the problem\n\t * @return {@code \"problemDetail.type.\"} followed by the fully qualified\n\t * {@link Class#getName() class name}\n\t * @since 6.1\n\t */\n\tstatic String getDefaultTypeMessageCode(Class<?> exceptionType) {\n\t\treturn \"problemDetail.type.\" + exceptionType.getName();\n\t}\n\n\t/**\n\t * Build a message code for the \"title\" field, for the given exception type.\n\t * @param exceptionType the exception type associated with the problem\n\t * @return {@code \"problemDetail.title.\"} followed by the fully qualified\n\t * {@link Class#getName() class name}\n\t */\n\tstatic String getDefaultTitleMessageCode(Class<?> exceptionType) {\n\t\treturn \"problemDetail.title.\" + exceptionType.getName();\n\t}\n\n\t/**\n\t * Build a message code for the \"detail\" field, for the given exception type.\n\t * @param exceptionType the exception type associated with the problem\n\t * @param suffix an optional suffix, for example, for exceptions that may have multiple\n\t * error message with different arguments\n\t * @return {@code \"problemDetail.\"} followed by the fully qualified\n\t * {@link Class#getName() class name} and an optional suffix\n\t */\n\tstatic String getDefaultDetailMessageCode(Class<?> exceptionType, @Nullable String suffix) {\n\t\treturn \"problemDetail.\" + exceptionType.getName() + (suffix != null ? \".\" + suffix : \"\");\n\t}\n\n\n\t/**\n\t * Static factory method to build an instance via\n\t * {@link #builder(Throwable, HttpStatusCode, String)}.\n\t */\n\tstatic ErrorResponse create(Throwable ex, HttpStatusCode statusCode, String detail) {\n\t\treturn builder(ex, statusCode, detail).build();\n\t}\n\n\t/**\n\t * Return a builder to create an {@code ErrorResponse} instance.\n\t * @param ex the underlying exception that lead to the error response;\n\t * mainly to derive default values for the\n\t * {@linkplain #getDetailMessageCode() detail message code} and for the\n\t * {@linkplain #getTitleMessageCode() title message code}.\n\t * @param statusCode the status code to set in the response\n\t * @param detail the default value for the\n\t * {@link ProblemDetail#setDetail(String) detail} field, unless overridden\n\t * by a {@link MessageSource} lookup with {@link #getDetailMessageCode()}\n\t */\n\tstatic Builder builder(Throwable ex, HttpStatusCode statusCode, String detail) {\n\t\treturn builder(ex, ProblemDetail.forStatusAndDetail(statusCode, detail));\n\t}\n\n\t/**\n\t * Variant of {@link #builder(Throwable, HttpStatusCode, String)} for use\n\t * with a custom {@link ProblemDetail} instance.\n\t * @since 6.1\n\t */\n\tstatic Builder builder(Throwable ex, ProblemDetail problemDetail) {\n\t\treturn new DefaultErrorResponseBuilder(ex, problemDetail);\n\t}\n\n\n\t/**\n\t * Builder for an {@code ErrorResponse}.\n\t */\n\tinterface Builder {\n\n\t\t/**\n\t\t * Add the given header value(s) under the given name.\n\t\t * @param headerName the header name\n\t\t * @param headerValues the header value(s)\n\t\t * @return the same builder instance\n\t\t * @see HttpHeaders#add(String, String)\n\t\t */\n\t\tBuilder header(String headerName, String... headerValues);\n\n\t\t/**\n\t\t * Manipulate this response's headers with the given consumer. This is\n\t\t * useful to {@linkplain HttpHeaders#set(String, String) overwrite} or\n\t\t * {@linkplain HttpHeaders#remove(String) remove} existing values, or\n\t\t * use any other {@link HttpHeaders} methods.\n\t\t * @param headersConsumer a function that consumes the {@code HttpHeaders}\n\t\t * @return the same builder instance\n\t\t */\n\t\tBuilder headers(Consumer<HttpHeaders> headersConsumer);\n\n\t\t/**\n\t\t * Set the underlying {@link ProblemDetail#setType(URI) type} field.\n\t\t * @return the same builder instance\n\t\t */\n\t\tBuilder type(URI type);\n\n\t\t/**\n\t\t * Customize the {@link MessageSource} code to use to resolve the value\n\t\t * for {@link ProblemDetail#setType(URI)}.\n\t\t * <p>By default, set from {@link ErrorResponse#getDefaultTypeMessageCode(Class)}.\n\t\t * @param messageCode the message code to use\n\t\t * @return the same builder instance\n\t\t * @since 6.1\n\t\t * @see ErrorResponse#getTypeMessageCode()\n\t\t */\n\t\tBuilder typeMessageCode(String messageCode);\n\n\t\t/**\n\t\t * Set the underlying {@link ProblemDetail#setTitle(String) title} field.\n\t\t * @return the same builder instance\n\t\t */\n\t\tBuilder title(@Nullable String title);\n\n\t\t/**\n\t\t * Customize the {@link MessageSource} code to use to resolve the value\n\t\t * for {@link ProblemDetail#setTitle(String)}.\n\t\t * <p>By default, set from {@link ErrorResponse#getDefaultTitleMessageCode(Class)}.\n\t\t * @param messageCode the message code to use\n\t\t * @return the same builder instance\n\t\t * @see ErrorResponse#getTitleMessageCode()\n\t\t */\n\t\tBuilder titleMessageCode(String messageCode);\n\n\t\t/**\n\t\t * Set the underlying {@link ProblemDetail#setInstance(URI) instance} field.\n\t\t * @return the same builder instance\n\t\t */\n\t\tBuilder instance(@Nullable URI instance);\n\n\t\t/**\n\t\t * Set the underlying {@link ProblemDetail#setDetail(String) detail}.\n\t\t * @return the same builder instance\n\t\t */\n\t\tBuilder detail(String detail);\n\n\t\t/**\n\t\t * Customize the {@link MessageSource} code to use to resolve the value\n\t\t * for the {@link #detail(String)}.\n\t\t * <p>By default, set from {@link ErrorResponse#getDefaultDetailMessageCode(Class, String)}.\n\t\t * @param messageCode the message code to use\n\t\t * @return the same builder instance\n\t\t * @see ErrorResponse#getDetailMessageCode()\n\t\t */\n\t\tBuilder detailMessageCode(String messageCode);\n\n\t\t/**\n\t\t * Set the arguments to provide to the {@link MessageSource} lookup for\n\t\t * {@link #detailMessageCode(String)}.\n\t\t * @param messageArguments the arguments to provide\n\t\t * @return the same builder instance\n\t\t * @see ErrorResponse#getDetailMessageArguments()\n\t\t */\n\t\tBuilder detailMessageArguments(Object... messageArguments);\n\n\t\t/**\n\t\t * Set a \"dynamic\" {@link ProblemDetail#setProperty(String, Object)\n\t\t * property} on the underlying {@code ProblemDetail}.\n\t\t * @return the same builder instance\n\t\t */\n\t\tBuilder property(String name, @Nullable Object value);\n\n\t\t/**\n\t\t * Build the {@code ErrorResponse} instance.\n\t\t */\n\t\tErrorResponse build();\n\n\t\t/**\n\t\t * Build the {@code ErrorResponse} instance and also resolve the \"detail\"\n\t\t * and \"title\" through the given {@link MessageSource}. Effectively a\n\t\t * shortcut for calling {@link #build()} and then\n\t\t * {@link ErrorResponse#updateAndGetBody(MessageSource, Locale)}.\n\t\t * @since 6.0.3\n\t\t */\n\t\tdefault ErrorResponse build(@Nullable MessageSource messageSource, Locale locale) {\n\t\t\tErrorResponse response = build();\n\t\t\tresponse.updateAndGetBody(messageSource, locale);\n\t\t\treturn response;\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Callback to perform an action before an RFC-9457 {@link ProblemDetail}\n\t * response is rendered.\n\t *\n\t * @author Rossen Stoyanchev\n\t * @since 6.2\n\t */\n\tinterface Interceptor {\n\n\t\t/**\n\t\t * Handle the given {@code ProblemDetail} that's going to be rendered,\n\t\t * and the {@code ErrorResponse} it originates from, if applicable.\n\t\t * @param detail the {@code ProblemDetail} to be rendered\n\t\t * @param errorResponse the {@code ErrorResponse}, or {@code null} if there isn't one\n\t\t */\n\t\tvoid handleError(ProblemDetail detail, @Nullable ErrorResponse errorResponse);\n\n\t}\n\n}"
  },
  "org.springframework.web.ErrorResponseException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link RuntimeException} that implements {@link ErrorResponse} to expose\n * an HTTP status, response headers, and a body formatted as an RFC 9457\n * {@link ProblemDetail}.\n *\n * <p>The exception can be used as is, or it can be extended as a more specific\n * exception that populates the {@link ProblemDetail#setType(URI) type} or\n * {@link ProblemDetail#setDetail(String) detail} fields, or potentially adds\n * other non-standard properties.\n *\n * @author Rossen Stoyanchev\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class ErrorResponseException",
    "source_code": "public class ErrorResponseException extends NestedRuntimeException implements ErrorResponse {\n\n\tprivate final HttpStatusCode status;\n\n\tprivate final HttpHeaders headers = new HttpHeaders();\n\n\tprivate final ProblemDetail body;\n\n\tprivate final String messageDetailCode;\n\n\tprivate final Object @Nullable [] messageDetailArguments;\n\n\n\t/**\n\t * Constructor with an {@link HttpStatusCode}.\n\t */\n\tpublic ErrorResponseException(HttpStatusCode status) {\n\t\tthis(status, null);\n\t}\n\n\t/**\n\t * Constructor with an {@link HttpStatusCode} and an optional cause.\n\t */\n\tpublic ErrorResponseException(HttpStatusCode status, @Nullable Throwable cause) {\n\t\tthis(status, ProblemDetail.forStatus(status), cause);\n\t}\n\n\t/**\n\t * Constructor with a given {@link ProblemDetail} instance, possibly a\n\t * subclass of {@code ProblemDetail} with extended fields.\n\t */\n\tpublic ErrorResponseException(HttpStatusCode status, ProblemDetail body, @Nullable Throwable cause) {\n\t\tthis(status, body, cause, null, null);\n\t}\n\n\t/**\n\t * Constructor with a given {@link ProblemDetail}, and a\n\t * {@link org.springframework.context.MessageSource} code and arguments to\n\t * resolve the detail message with.\n\t * @since 6.0\n\t */\n\tpublic ErrorResponseException(\n\t\t\tHttpStatusCode status, ProblemDetail body, @Nullable Throwable cause,\n\t\t\t@Nullable String messageDetailCode, Object @Nullable [] messageDetailArguments) {\n\n\t\tsuper(null, cause);\n\t\tthis.status = status;\n\t\tthis.body = body;\n\t\tthis.messageDetailCode = initMessageDetailCode(messageDetailCode);\n\t\tthis.messageDetailArguments = messageDetailArguments;\n\t}\n\n\tprivate String initMessageDetailCode(@Nullable String messageDetailCode) {\n\t\treturn (messageDetailCode != null ?\n\t\t\t\tmessageDetailCode : ErrorResponse.getDefaultDetailMessageCode(getClass(), null));\n\t}\n\n\n\t@Override\n\tpublic HttpStatusCode getStatusCode() {\n\t\treturn this.status;\n\t}\n\n\t@Override\n\tpublic HttpHeaders getHeaders() {\n\t\treturn this.headers;\n\t}\n\n\t/**\n\t * Set the {@link ProblemDetail#setType(URI) type} field of the response body.\n\t * @param type the problem type\n\t */\n\tpublic void setType(URI type) {\n\t\tthis.body.setType(type);\n\t}\n\n\t/**\n\t * Set the {@link ProblemDetail#setTitle(String) title} field of the response body.\n\t * @param title the problem title\n\t */\n\tpublic void setTitle(@Nullable String title) {\n\t\tthis.body.setTitle(title);\n\t}\n\n\t/**\n\t * Set the {@link ProblemDetail#setDetail(String) detail} field of the response body.\n\t * @param detail the problem detail\n\t */\n\tpublic void setDetail(@Nullable String detail) {\n\t\tthis.body.setDetail(detail);\n\t}\n\n\t/**\n\t * Set the {@link ProblemDetail#setInstance(URI) instance} field of the response body.\n\t * @param instance the problem instance\n\t */\n\tpublic void setInstance(@Nullable URI instance) {\n\t\tthis.body.setInstance(instance);\n\t}\n\n\t/**\n\t * Return the body for the response. To customize the body content, use:\n\t * <ul>\n\t * <li>{@link #setType(URI)}\n\t * <li>{@link #setTitle(String)}\n\t * <li>{@link #setDetail(String)}\n\t * <li>{@link #setInstance(URI)}\n\t * </ul>\n\t * <p>By default, the status field of {@link ProblemDetail} is initialized\n\t * from the status provided to the constructor, which in turn may also\n\t * initialize the title field from the status reason phrase, if the status\n\t * is well-known. The instance field, if not set, is initialized from the\n\t * request path when a {@code ProblemDetail} is returned from an\n\t * {@code @ExceptionHandler} method.\n\t */\n\t@Override\n\tpublic final ProblemDetail getBody() {\n\t\treturn this.body;\n\t}\n\n\t@Override\n\tpublic String getDetailMessageCode() {\n\t\treturn this.messageDetailCode;\n\t}\n\n\t@Override\n\tpublic Object @Nullable [] getDetailMessageArguments() {\n\t\treturn this.messageDetailArguments;\n\t}\n\n\t@Override\n\tpublic String getMessage() {\n\t\treturn this.status + (!this.headers.isEmpty() ? \", headers=\" + this.headers : \"\") + \", \" + this.body;\n\t}\n\n}"
  },
  "org.springframework.web.ErrorResponseException#getBody()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the body for the response. To customize the body content, use:\n\t * <ul>\n\t * <li>{@link #setType(URI)}\n\t * <li>{@link #setTitle(String)}\n\t * <li>{@link #setDetail(String)}\n\t * <li>{@link #setInstance(URI)}\n\t * </ul>\n\t * <p>By default, the status field of {@link ProblemDetail} is initialized\n\t * from the status provided to the constructor, which in turn may also\n\t * initialize the title field from the status reason phrase, if the status\n\t * is well-known. The instance field, if not set, is initialized from the\n\t * request path when a {@code ProblemDetail} is returned from an\n\t * {@code @ExceptionHandler} method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "ProblemDetail",
    "signature": "public ProblemDetail getBody()",
    "source_code": "\tpublic final ProblemDetail getBody() {\n\t\treturn this.body;\n\t}"
  },
  "org.springframework.web.ErrorResponseException#getDetailMessageCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "String",
    "signature": "public String getDetailMessageCode()",
    "source_code": "\tpublic String getDetailMessageCode() {\n\t\treturn this.messageDetailCode;\n\t}"
  },
  "org.springframework.web.ErrorResponseException#getHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHeaders()",
    "source_code": "\tpublic HttpHeaders getHeaders() {\n\t\treturn this.headers;\n\t}"
  },
  "org.springframework.web.ErrorResponseException#getMessage()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "String",
    "signature": "public String getMessage()",
    "source_code": "\tpublic String getMessage() {\n\t\treturn this.status + (!this.headers.isEmpty() ? \", headers=\" + this.headers : \"\") + \", \" + this.body;\n\t}"
  },
  "org.springframework.web.ErrorResponseException#getStatusCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "HttpStatusCode",
    "signature": "public HttpStatusCode getStatusCode()",
    "source_code": "\tpublic HttpStatusCode getStatusCode() {\n\t\treturn this.status;\n\t}"
  },
  "org.springframework.web.ErrorResponseException#setDetail(detail)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link ProblemDetail#setDetail(String) detail} field of the response body.\n\t * @param detail the problem detail\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "detail"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void setDetail(@Nullable String detail)",
    "source_code": "\tpublic void setDetail(@Nullable String detail) {\n\t\tthis.body.setDetail(detail);\n\t}"
  },
  "org.springframework.web.ErrorResponseException#setInstance(instance)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link ProblemDetail#setInstance(URI) instance} field of the response body.\n\t * @param instance the problem instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "instance"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void setInstance(@Nullable URI instance)",
    "source_code": "\tpublic void setInstance(@Nullable URI instance) {\n\t\tthis.body.setInstance(instance);\n\t}"
  },
  "org.springframework.web.ErrorResponseException#setTitle(title)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link ProblemDetail#setTitle(String) title} field of the response body.\n\t * @param title the problem title\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "title"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void setTitle(@Nullable String title)",
    "source_code": "\tpublic void setTitle(@Nullable String title) {\n\t\tthis.body.setTitle(title);\n\t}"
  },
  "org.springframework.web.ErrorResponseException#setType(type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link ProblemDetail#setType(URI) type} field of the response body.\n\t * @param type the problem type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "void",
    "signature": "public void setType(URI type)",
    "source_code": "\tpublic void setType(URI type) {\n\t\tthis.body.setType(type);\n\t}"
  },
  "org.springframework.web.HttpMediaTypeException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base for exceptions related to media types. Adds a list of supported {@link MediaType MediaTypes}.\n *\n * @author Arjen Poutsma\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class HttpMediaTypeException",
    "source_code": "public abstract class HttpMediaTypeException extends ServletException implements ErrorResponse {\n\n\tprivate final List<MediaType> supportedMediaTypes;\n\n\tprivate final ProblemDetail body = ProblemDetail.forStatus(getStatusCode());\n\n\tprivate final String messageDetailCode;\n\n\tprivate final Object @Nullable [] messageDetailArguments;\n\n\n\t/**\n\t * Create a new HttpMediaTypeException with a list of supported media types.\n\t * @param supportedMediaTypes the list of supported media types\n\t * @param messageDetailCode the code to use to resolve the problem \"detail\"\n\t * through a {@link org.springframework.context.MessageSource}\n\t * @param messageDetailArguments the arguments to make available when\n\t * resolving the problem \"detail\" through a {@code MessageSource}\n\t * @since 6.0\n\t */\n\tprotected HttpMediaTypeException(@Nullable String message, List<MediaType> supportedMediaTypes,\n\t\t\t@Nullable String messageDetailCode, Object @Nullable [] messageDetailArguments) {\n\n\t\tsuper(message);\n\t\tthis.supportedMediaTypes = Collections.unmodifiableList(supportedMediaTypes);\n\t\tthis.messageDetailCode = (messageDetailCode != null ?\n\t\t\t\tmessageDetailCode : ErrorResponse.getDefaultDetailMessageCode(getClass(), null));\n\t\tthis.messageDetailArguments = messageDetailArguments;\n\t}\n\n\n\t/**\n\t * Return the list of supported media types.\n\t */\n\tpublic List<MediaType> getSupportedMediaTypes() {\n\t\treturn this.supportedMediaTypes;\n\t}\n\n\t@Override\n\tpublic ProblemDetail getBody() {\n\t\treturn this.body;\n\t}\n\n\t@Override\n\tpublic String getDetailMessageCode() {\n\t\treturn this.messageDetailCode;\n\t}\n\n\t@Override\n\tpublic Object @Nullable [] getDetailMessageArguments() {\n\t\treturn this.messageDetailArguments;\n\t}\n\n}"
  },
  "org.springframework.web.HttpMediaTypeException#getBody()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "ProblemDetail",
    "signature": "public ProblemDetail getBody()",
    "source_code": "\tpublic ProblemDetail getBody() {\n\t\treturn this.body;\n\t}"
  },
  "org.springframework.web.HttpMediaTypeException#getDetailMessageCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "String",
    "signature": "public String getDetailMessageCode()",
    "source_code": "\tpublic String getDetailMessageCode() {\n\t\treturn this.messageDetailCode;\n\t}"
  },
  "org.springframework.web.HttpMediaTypeException#getSupportedMediaTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the list of supported media types.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "List<MediaType>",
    "signature": "public List<MediaType> getSupportedMediaTypes()",
    "source_code": "\tpublic List<MediaType> getSupportedMediaTypes() {\n\t\treturn this.supportedMediaTypes;\n\t}"
  },
  "org.springframework.web.HttpRequestMethodNotSupportedException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Exception thrown when a request handler does not support a\n * specific request method.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 2.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public class HttpRequestMethodNotSupportedException",
    "source_code": "public class HttpRequestMethodNotSupportedException extends ServletException implements ErrorResponse {\n\n\tprivate final String method;\n\n\tprivate final String @Nullable [] supportedMethods;\n\n\tprivate final ProblemDetail body;\n\n\n\t/**\n\t * Create a new {@code HttpRequestMethodNotSupportedException}.\n\t * @param method the unsupported HTTP request method\n\t */\n\tpublic HttpRequestMethodNotSupportedException(String method) {\n\t\tthis(method, (String[]) null);\n\t}\n\n\t/**\n\t * Create a new {@code HttpRequestMethodNotSupportedException}.\n\t * @param method the unsupported HTTP request method\n\t * @param supportedMethods the actually supported HTTP methods (possibly {@code null})\n\t */\n\tpublic HttpRequestMethodNotSupportedException(String method, @Nullable Collection<String> supportedMethods) {\n\t\tthis(method, (supportedMethods != null ? StringUtils.toStringArray(supportedMethods) : null));\n\t}\n\n\t/**\n\t * Create a new {@code HttpRequestMethodNotSupportedException}.\n\t * @param method the unsupported HTTP request method\n\t * @param supportedMethods the actually supported HTTP methods (possibly {@code null})\n\t */\n\tprivate HttpRequestMethodNotSupportedException(String method, String @Nullable [] supportedMethods) {\n\t\tsuper(\"Request method '\" + method + \"' is not supported\");\n\t\tthis.method = method;\n\t\tthis.supportedMethods = supportedMethods;\n\n\t\tString detail = \"Method '\" + method + \"' is not supported.\";\n\t\tthis.body = ProblemDetail.forStatusAndDetail(getStatusCode(), detail);\n\t}\n\n\n\t/**\n\t * Return the HTTP request method that caused the failure.\n\t */\n\tpublic String getMethod() {\n\t\treturn this.method;\n\t}\n\n\t/**\n\t * Return the actually supported HTTP methods, or {@code null} if not known.\n\t */\n\tpublic String @Nullable [] getSupportedMethods() {\n\t\treturn this.supportedMethods;\n\t}\n\n\t/**\n\t * Return the actually supported HTTP methods as {@link HttpMethod} instances,\n\t * or {@code null} if not known.\n\t * @since 3.2\n\t */\n\tpublic @Nullable Set<HttpMethod> getSupportedHttpMethods() {\n\t\tif (this.supportedMethods == null) {\n\t\t\treturn null;\n\t\t}\n\t\tSet<HttpMethod> supportedMethods = CollectionUtils.newLinkedHashSet(this.supportedMethods.length);\n\t\tfor (String value : this.supportedMethods) {\n\t\t\tHttpMethod method = HttpMethod.valueOf(value);\n\t\t\tsupportedMethods.add(method);\n\t\t}\n\t\treturn supportedMethods;\n\t}\n\n\t@Override\n\tpublic HttpStatusCode getStatusCode() {\n\t\treturn HttpStatus.METHOD_NOT_ALLOWED;\n\t}\n\n\t@Override\n\tpublic HttpHeaders getHeaders() {\n\t\tif (ObjectUtils.isEmpty(this.supportedMethods)) {\n\t\t\treturn HttpHeaders.EMPTY;\n\t\t}\n\t\tHttpHeaders headers = new HttpHeaders();\n\t\theaders.add(HttpHeaders.ALLOW, StringUtils.arrayToDelimitedString(this.supportedMethods, \", \"));\n\t\treturn headers;\n\t}\n\n\t@Override\n\tpublic ProblemDetail getBody() {\n\t\treturn this.body;\n\t}\n\n\t@Override\n\tpublic Object[] getDetailMessageArguments() {\n\t\treturn new Object[] {getMethod(), getSupportedHttpMethods()};\n\t}\n\n}"
  },
  "org.springframework.web.HttpRequestMethodNotSupportedException#getBody()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "ProblemDetail",
    "signature": "public ProblemDetail getBody()",
    "source_code": "\tpublic ProblemDetail getBody() {\n\t\treturn this.body;\n\t}"
  },
  "org.springframework.web.HttpRequestMethodNotSupportedException#getDetailMessageArguments()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "Object[]",
    "signature": "public Object[] getDetailMessageArguments()",
    "source_code": "\tpublic Object[] getDetailMessageArguments() {\n\t\treturn new Object[] {getMethod(), getSupportedHttpMethods()};\n\t}"
  },
  "org.springframework.web.HttpRequestMethodNotSupportedException#getHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHeaders()",
    "source_code": "\tpublic HttpHeaders getHeaders() {\n\t\tif (ObjectUtils.isEmpty(this.supportedMethods)) {\n\t\t\treturn HttpHeaders.EMPTY;\n\t\t}\n\t\tHttpHeaders headers = new HttpHeaders();\n\t\theaders.add(HttpHeaders.ALLOW, StringUtils.arrayToDelimitedString(this.supportedMethods, \", \"));\n\t\treturn headers;\n\t}"
  },
  "org.springframework.web.HttpRequestMethodNotSupportedException#getMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HTTP request method that caused the failure.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "String",
    "signature": "public String getMethod()",
    "source_code": "\tpublic String getMethod() {\n\t\treturn this.method;\n\t}"
  },
  "org.springframework.web.HttpRequestMethodNotSupportedException#getStatusCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "HttpStatusCode",
    "signature": "public HttpStatusCode getStatusCode()",
    "source_code": "\tpublic HttpStatusCode getStatusCode() {\n\t\treturn HttpStatus.METHOD_NOT_ALLOWED;\n\t}"
  },
  "org.springframework.web.HttpRequestMethodNotSupportedException#getSupportedHttpMethods()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the actually supported HTTP methods as {@link HttpMethod} instances,\n\t * or {@code null} if not known.\n\t * @since 3.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "Set<HttpMethod>",
    "signature": "public Set<HttpMethod> getSupportedHttpMethods()",
    "source_code": "\tpublic @Nullable Set<HttpMethod> getSupportedHttpMethods() {\n\t\tif (this.supportedMethods == null) {\n\t\t\treturn null;\n\t\t}\n\t\tSet<HttpMethod> supportedMethods = CollectionUtils.newLinkedHashSet(this.supportedMethods.length);\n\t\tfor (String value : this.supportedMethods) {\n\t\t\tHttpMethod method = HttpMethod.valueOf(value);\n\t\t\tsupportedMethods.add(method);\n\t\t}\n\t\treturn supportedMethods;\n\t}"
  },
  "org.springframework.web.bind.MissingRequestValueException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Base class for {@link ServletRequestBindingException} exceptions that could\n * not bind because the request value is required but is either missing or\n * otherwise resolves to {@code null} after conversion.\n *\n * @author Rossen Stoyanchev\n * @since 5.3.6\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 32
    },
    "signature": "public class MissingRequestValueException",
    "source_code": "public class MissingRequestValueException extends ServletRequestBindingException {\n\n\tprivate final boolean missingAfterConversion;\n\n\n\t/**\n\t * Constructor with a message only.\n\t */\n\tpublic MissingRequestValueException(String msg) {\n\t\tthis(msg, false);\n\t}\n\n\t/**\n\t * Constructor with a message and a flag that indicates whether a value\n\t * was present but became {@code null} after conversion.\n\t */\n\tpublic MissingRequestValueException(String msg, boolean missingAfterConversion) {\n\t\tsuper(msg);\n\t\tthis.missingAfterConversion = missingAfterConversion;\n\t}\n\n\t/**\n\t * Constructor with a given {@link ProblemDetail}, and a\n\t * {@link org.springframework.context.MessageSource} code and arguments to\n\t * resolve the detail message with.\n\t * @since 6.0\n\t */\n\tprotected MissingRequestValueException(String msg, boolean missingAfterConversion,\n\t\t\t@Nullable String messageDetailCode, Object @Nullable [] messageDetailArguments) {\n\n\t\tsuper(msg, messageDetailCode, messageDetailArguments);\n\t\tthis.missingAfterConversion = missingAfterConversion;\n\t}\n\n\n\t/**\n\t * Whether the request value was present but converted to {@code null}, for example, via\n\t * {@code org.springframework.core.convert.support.IdToEntityConverter}.\n\t */\n\tpublic boolean isMissingAfterConversion() {\n\t\treturn this.missingAfterConversion;\n\t}\n\n}"
  },
  "org.springframework.web.bind.MissingRequestValueException#isMissingAfterConversion()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the request value was present but converted to {@code null}, for example, via\n\t * {@code org.springframework.core.convert.support.IdToEntityConverter}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "boolean",
    "signature": "public boolean isMissingAfterConversion()",
    "source_code": "\tpublic boolean isMissingAfterConversion() {\n\t\treturn this.missingAfterConversion;\n\t}"
  },
  "org.springframework.web.bind.ServletRequestBindingException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Fatal binding exception, thrown when we want to\n * treat binding exceptions as unrecoverable.\n *\n * <p>Extends ServletException for convenient throwing in any Servlet resource\n * (such as a Filter), and NestedServletException for proper root cause handling\n * (as the plain ServletException doesn't expose its root cause at all).\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class ServletRequestBindingException",
    "source_code": "public class ServletRequestBindingException extends ServletException implements ErrorResponse {\n\n\tprivate final ProblemDetail body = ProblemDetail.forStatus(getStatusCode());\n\n\tprivate final String messageDetailCode;\n\n\tprivate final Object @Nullable [] messageDetailArguments;\n\n\n\t/**\n\t * Constructor with a message only.\n\t * @param msg the detail message\n\t */\n\tpublic ServletRequestBindingException(@Nullable String msg) {\n\t\tthis(msg, null, null);\n\t}\n\n\t/**\n\t * Constructor with a message and a cause.\n\t * @param msg the detail message\n\t * @param cause the root cause\n\t */\n\tpublic ServletRequestBindingException(@Nullable String msg, @Nullable Throwable cause) {\n\t\tthis(msg, cause, null, null);\n\t}\n\n\t/**\n\t * Constructor for ServletRequestBindingException.\n\t * @param msg the detail message\n\t * @param messageDetailCode the code to use to resolve the problem \"detail\"\n\t * through a {@link org.springframework.context.MessageSource}\n\t * @param messageDetailArguments the arguments to make available when\n\t * resolving the problem \"detail\" through a {@code MessageSource}\n\t * @since 6.0\n\t */\n\tprotected ServletRequestBindingException(\n\t\t\t@Nullable String msg, @Nullable String messageDetailCode, Object @Nullable [] messageDetailArguments) {\n\n\t\tthis(msg, null, messageDetailCode, messageDetailArguments);\n\t}\n\n\t/**\n\t * Constructor for ServletRequestBindingException.\n\t * @param msg the detail message\n\t * @param cause the root cause\n\t * @param messageDetailCode the code to use to resolve the problem \"detail\"\n\t * through a {@link org.springframework.context.MessageSource}\n\t * @param messageDetailArguments the arguments to make available when\n\t * resolving the problem \"detail\" through a {@code MessageSource}\n\t * @since 6.0\n\t */\n\tprotected ServletRequestBindingException(@Nullable String msg, @Nullable Throwable cause,\n\t\t\t@Nullable String messageDetailCode, Object @Nullable [] messageDetailArguments) {\n\n\t\tsuper(msg, cause);\n\t\tthis.messageDetailCode = initMessageDetailCode(messageDetailCode);\n\t\tthis.messageDetailArguments = messageDetailArguments;\n\t}\n\n\tprivate String initMessageDetailCode(@Nullable String messageDetailCode) {\n\t\treturn (messageDetailCode != null ?\n\t\t\t\tmessageDetailCode : ErrorResponse.getDefaultDetailMessageCode(getClass(), null));\n\t}\n\n\n\t@Override\n\tpublic HttpStatusCode getStatusCode() {\n\t\treturn HttpStatus.BAD_REQUEST;\n\t}\n\n\t@Override\n\tpublic ProblemDetail getBody() {\n\t\treturn this.body;\n\t}\n\n\t@Override\n\tpublic String getDetailMessageCode() {\n\t\treturn this.messageDetailCode;\n\t}\n\n\t@Override\n\tpublic Object @Nullable [] getDetailMessageArguments() {\n\t\treturn this.messageDetailArguments;\n\t}\n\n}"
  },
  "org.springframework.web.bind.ServletRequestBindingException#getBody()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "ProblemDetail",
    "signature": "public ProblemDetail getBody()",
    "source_code": "\tpublic ProblemDetail getBody() {\n\t\treturn this.body;\n\t}"
  },
  "org.springframework.web.bind.ServletRequestBindingException#getDetailMessageCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "String",
    "signature": "public String getDetailMessageCode()",
    "source_code": "\tpublic String getDetailMessageCode() {\n\t\treturn this.messageDetailCode;\n\t}"
  },
  "org.springframework.web.bind.ServletRequestBindingException#getStatusCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "HttpStatusCode",
    "signature": "public HttpStatusCode getStatusCode()",
    "source_code": "\tpublic HttpStatusCode getStatusCode() {\n\t\treturn HttpStatus.BAD_REQUEST;\n\t}"
  },
  "org.springframework.web.bind.support.ConfigurableWebBindingInitializer": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Convenient {@link WebBindingInitializer} for declarative configuration\n * in a Spring application context. Allows for reusing pre-configured\n * initializers with multiple controller/handlers.\n *\n * @author Juergen Hoeller\n * @since 2.5\n * @see #setDirectFieldAccess\n * @see #setMessageCodesResolver\n * @see #setBindingErrorProcessor\n * @see #setValidator(Validator)\n * @see #setConversionService(ConversionService)\n * @see #setPropertyEditorRegistrar\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class ConfigurableWebBindingInitializer",
    "source_code": "public class ConfigurableWebBindingInitializer implements WebBindingInitializer {\n\n\tprivate boolean autoGrowNestedPaths = true;\n\n\tprivate boolean directFieldAccess = false;\n\n\tprivate @Nullable Boolean declarativeBinding;\n\n\tprivate @Nullable MessageCodesResolver messageCodesResolver;\n\n\tprivate @Nullable BindingErrorProcessor bindingErrorProcessor;\n\n\tprivate @Nullable Validator validator;\n\n\tprivate @Nullable ConversionService conversionService;\n\n\tprivate PropertyEditorRegistrar @Nullable [] propertyEditorRegistrars;\n\n\n\t/**\n\t * Set whether a binder should attempt to \"auto-grow\" a nested path that contains a null value.\n\t * <p>If \"true\", a null path location will be populated with a default object value and traversed\n\t * instead of resulting in an exception. This flag also enables auto-growth of collection elements\n\t * when accessing an out-of-bounds index.\n\t * <p>Default is \"true\" on a standard DataBinder. Note that this feature is only supported\n\t * for bean property access (DataBinder's default mode), not for field access.\n\t * @see org.springframework.validation.DataBinder#initBeanPropertyAccess()\n\t * @see org.springframework.validation.DataBinder#setAutoGrowNestedPaths\n\t */\n\tpublic void setAutoGrowNestedPaths(boolean autoGrowNestedPaths) {\n\t\tthis.autoGrowNestedPaths = autoGrowNestedPaths;\n\t}\n\n\t/**\n\t * Return whether a binder should attempt to \"auto-grow\" a nested path that contains a null value.\n\t */\n\tpublic boolean isAutoGrowNestedPaths() {\n\t\treturn this.autoGrowNestedPaths;\n\t}\n\n\t/**\n\t * Set whether to use direct field access instead of bean property access.\n\t * <p>Default is {@code false}, using bean property access.\n\t * Switch this to {@code true} in order to enforce direct field access.\n\t * @see org.springframework.validation.DataBinder#initDirectFieldAccess()\n\t * @see org.springframework.validation.DataBinder#initBeanPropertyAccess()\n\t */\n\tpublic final void setDirectFieldAccess(boolean directFieldAccess) {\n\t\tthis.directFieldAccess = directFieldAccess;\n\t}\n\n\t/**\n\t * Return whether to use direct field access instead of bean property access.\n\t */\n\tpublic boolean isDirectFieldAccess() {\n\t\treturn this.directFieldAccess;\n\t}\n\n\t/**\n\t * Set whether to bind only fields intended for binding as described in\n\t * {@link org.springframework.validation.DataBinder#setDeclarativeBinding}.\n\t * @since 6.1\n\t */\n\tpublic void setDeclarativeBinding(boolean declarativeBinding) {\n\t\tthis.declarativeBinding = declarativeBinding;\n\t}\n\n\t/**\n\t * Return whether to bind only fields intended for binding.\n\t * @since 6.1\n\t */\n\tpublic boolean isDeclarativeBinding() {\n\t\treturn (this.declarativeBinding != null ? this.declarativeBinding : false);\n\t}\n\n\t/**\n\t * Set the strategy to use for resolving errors into message codes.\n\t * Applies the given strategy to all data binders used by this controller.\n\t * <p>Default is {@code null}, i.e. using the default strategy of\n\t * the data binder.\n\t * @see org.springframework.validation.DataBinder#setMessageCodesResolver\n\t */\n\tpublic final void setMessageCodesResolver(@Nullable MessageCodesResolver messageCodesResolver) {\n\t\tthis.messageCodesResolver = messageCodesResolver;\n\t}\n\n\t/**\n\t * Return the strategy to use for resolving errors into message codes.\n\t */\n\tpublic final @Nullable MessageCodesResolver getMessageCodesResolver() {\n\t\treturn this.messageCodesResolver;\n\t}\n\n\t/**\n\t * Set the strategy to use for processing binding errors, that is,\n\t * required field errors and {@code PropertyAccessException}s.\n\t * <p>Default is {@code null}, that is, using the default strategy\n\t * of the data binder.\n\t * @see org.springframework.validation.DataBinder#setBindingErrorProcessor\n\t */\n\tpublic final void setBindingErrorProcessor(@Nullable BindingErrorProcessor bindingErrorProcessor) {\n\t\tthis.bindingErrorProcessor = bindingErrorProcessor;\n\t}\n\n\t/**\n\t * Return the strategy to use for processing binding errors.\n\t */\n\tpublic final @Nullable BindingErrorProcessor getBindingErrorProcessor() {\n\t\treturn this.bindingErrorProcessor;\n\t}\n\n\t/**\n\t * Set the Validator to apply after each binding step.\n\t */\n\tpublic final void setValidator(@Nullable Validator validator) {\n\t\tthis.validator = validator;\n\t}\n\n\t/**\n\t * Return the Validator to apply after each binding step, if any.\n\t */\n\tpublic final @Nullable Validator getValidator() {\n\t\treturn this.validator;\n\t}\n\n\t/**\n\t * Specify a ConversionService which will apply to every DataBinder.\n\t * @since 3.0\n\t */\n\tpublic final void setConversionService(@Nullable ConversionService conversionService) {\n\t\tthis.conversionService = conversionService;\n\t}\n\n\t/**\n\t * Return the ConversionService which will apply to every DataBinder.\n\t */\n\tpublic final @Nullable ConversionService getConversionService() {\n\t\treturn this.conversionService;\n\t}\n\n\t/**\n\t * Specify a single PropertyEditorRegistrar to be applied to every DataBinder.\n\t */\n\tpublic final void setPropertyEditorRegistrar(PropertyEditorRegistrar propertyEditorRegistrar) {\n\t\tthis.propertyEditorRegistrars = new PropertyEditorRegistrar[] {propertyEditorRegistrar};\n\t}\n\n\t/**\n\t * Specify multiple PropertyEditorRegistrars to be applied to every DataBinder.\n\t */\n\tpublic final void setPropertyEditorRegistrars(PropertyEditorRegistrar @Nullable [] propertyEditorRegistrars) {\n\t\tthis.propertyEditorRegistrars = propertyEditorRegistrars;\n\t}\n\n\t/**\n\t * Return the PropertyEditorRegistrars to be applied to every DataBinder.\n\t */\n\tpublic final PropertyEditorRegistrar @Nullable [] getPropertyEditorRegistrars() {\n\t\treturn this.propertyEditorRegistrars;\n\t}\n\n\n\t@Override\n\tpublic void initBinder(WebDataBinder binder) {\n\t\tbinder.setAutoGrowNestedPaths(this.autoGrowNestedPaths);\n\t\tif (this.directFieldAccess) {\n\t\t\tbinder.initDirectFieldAccess();\n\t\t}\n\t\tif (this.declarativeBinding != null) {\n\t\t\tbinder.setDeclarativeBinding(this.declarativeBinding);\n\t\t}\n\t\tif (this.messageCodesResolver != null) {\n\t\t\tbinder.setMessageCodesResolver(this.messageCodesResolver);\n\t\t}\n\t\tif (this.bindingErrorProcessor != null) {\n\t\t\tbinder.setBindingErrorProcessor(this.bindingErrorProcessor);\n\t\t}\n\t\tif (this.validator != null) {\n\t\t\tClass<?> type = getTargetType(binder);\n\t\t\tif (type != null && this.validator.supports(type)) {\n\t\t\t\tbinder.setValidator(this.validator);\n\t\t\t}\n\t\t}\n\t\tif (this.conversionService != null) {\n\t\t\tbinder.setConversionService(this.conversionService);\n\t\t}\n\t\tif (this.propertyEditorRegistrars != null) {\n\t\t\tfor (PropertyEditorRegistrar propertyEditorRegistrar : this.propertyEditorRegistrars) {\n\t\t\t\tpropertyEditorRegistrar.registerCustomEditors(binder);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static @Nullable Class<?> getTargetType(WebDataBinder binder) {\n\t\tClass<?> type = null;\n\t\tif (binder.getTarget() != null) {\n\t\t\ttype = binder.getTarget().getClass();\n\t\t}\n\t\telse if (binder.getTargetType() != null) {\n\t\t\ttype = binder.getTargetType().resolve();\n\t\t}\n\t\treturn type;\n\t}\n\n}"
  },
  "org.springframework.web.bind.support.ConfigurableWebBindingInitializer#getBindingErrorProcessor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the strategy to use for processing binding errors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "BindingErrorProcessor",
    "signature": "public BindingErrorProcessor getBindingErrorProcessor()",
    "source_code": "\tpublic final @Nullable BindingErrorProcessor getBindingErrorProcessor() {\n\t\treturn this.bindingErrorProcessor;\n\t}"
  },
  "org.springframework.web.bind.support.ConfigurableWebBindingInitializer#getConversionService()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the ConversionService which will apply to every DataBinder.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "ConversionService",
    "signature": "public ConversionService getConversionService()",
    "source_code": "\tpublic final @Nullable ConversionService getConversionService() {\n\t\treturn this.conversionService;\n\t}"
  },
  "org.springframework.web.bind.support.ConfigurableWebBindingInitializer#getMessageCodesResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the strategy to use for resolving errors into message codes.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "MessageCodesResolver",
    "signature": "public MessageCodesResolver getMessageCodesResolver()",
    "source_code": "\tpublic final @Nullable MessageCodesResolver getMessageCodesResolver() {\n\t\treturn this.messageCodesResolver;\n\t}"
  },
  "org.springframework.web.bind.support.ConfigurableWebBindingInitializer#getValidator()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Validator to apply after each binding step, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "Validator",
    "signature": "public Validator getValidator()",
    "source_code": "\tpublic final @Nullable Validator getValidator() {\n\t\treturn this.validator;\n\t}"
  },
  "org.springframework.web.bind.support.ConfigurableWebBindingInitializer#initBinder(binder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "binder"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "void",
    "signature": "public void initBinder(WebDataBinder binder)",
    "source_code": "\tpublic void initBinder(WebDataBinder binder) {\n\t\tbinder.setAutoGrowNestedPaths(this.autoGrowNestedPaths);\n\t\tif (this.directFieldAccess) {\n\t\t\tbinder.initDirectFieldAccess();\n\t\t}\n\t\tif (this.declarativeBinding != null) {\n\t\t\tbinder.setDeclarativeBinding(this.declarativeBinding);\n\t\t}\n\t\tif (this.messageCodesResolver != null) {\n\t\t\tbinder.setMessageCodesResolver(this.messageCodesResolver);\n\t\t}\n\t\tif (this.bindingErrorProcessor != null) {\n\t\t\tbinder.setBindingErrorProcessor(this.bindingErrorProcessor);\n\t\t}\n\t\tif (this.validator != null) {\n\t\t\tClass<?> type = getTargetType(binder);\n\t\t\tif (type != null && this.validator.supports(type)) {\n\t\t\t\tbinder.setValidator(this.validator);\n\t\t\t}\n\t\t}\n\t\tif (this.conversionService != null) {\n\t\t\tbinder.setConversionService(this.conversionService);\n\t\t}\n\t\tif (this.propertyEditorRegistrars != null) {\n\t\t\tfor (PropertyEditorRegistrar propertyEditorRegistrar : this.propertyEditorRegistrars) {\n\t\t\t\tpropertyEditorRegistrar.registerCustomEditors(binder);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.bind.support.ConfigurableWebBindingInitializer#isAutoGrowNestedPaths()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether a binder should attempt to \"auto-grow\" a nested path that contains a null value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "boolean",
    "signature": "public boolean isAutoGrowNestedPaths()",
    "source_code": "\tpublic boolean isAutoGrowNestedPaths() {\n\t\treturn this.autoGrowNestedPaths;\n\t}"
  },
  "org.springframework.web.bind.support.ConfigurableWebBindingInitializer#isDeclarativeBinding()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to bind only fields intended for binding.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "boolean",
    "signature": "public boolean isDeclarativeBinding()",
    "source_code": "\tpublic boolean isDeclarativeBinding() {\n\t\treturn (this.declarativeBinding != null ? this.declarativeBinding : false);\n\t}"
  },
  "org.springframework.web.bind.support.ConfigurableWebBindingInitializer#isDirectFieldAccess()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to use direct field access instead of bean property access.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "boolean",
    "signature": "public boolean isDirectFieldAccess()",
    "source_code": "\tpublic boolean isDirectFieldAccess() {\n\t\treturn this.directFieldAccess;\n\t}"
  },
  "org.springframework.web.bind.support.ConfigurableWebBindingInitializer#setAutoGrowNestedPaths(autoGrowNestedPaths)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether a binder should attempt to \"auto-grow\" a nested path that contains a null value.\n\t * <p>If \"true\", a null path location will be populated with a default object value and traversed\n\t * instead of resulting in an exception. This flag also enables auto-growth of collection elements\n\t * when accessing an out-of-bounds index.\n\t * <p>Default is \"true\" on a standard DataBinder. Note that this feature is only supported\n\t * for bean property access (DataBinder's default mode), not for field access.\n\t * @see org.springframework.validation.DataBinder#initBeanPropertyAccess()\n\t * @see org.springframework.validation.DataBinder#setAutoGrowNestedPaths\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "autoGrowNestedPaths"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "public void setAutoGrowNestedPaths(boolean autoGrowNestedPaths)",
    "source_code": "\tpublic void setAutoGrowNestedPaths(boolean autoGrowNestedPaths) {\n\t\tthis.autoGrowNestedPaths = autoGrowNestedPaths;\n\t}"
  },
  "org.springframework.web.bind.support.ConfigurableWebBindingInitializer#setBindingErrorProcessor(bindingErrorProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the strategy to use for processing binding errors, that is,\n\t * required field errors and {@code PropertyAccessException}s.\n\t * <p>Default is {@code null}, that is, using the default strategy\n\t * of the data binder.\n\t * @see org.springframework.validation.DataBinder#setBindingErrorProcessor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindingErrorProcessor"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "void",
    "signature": "public void setBindingErrorProcessor(@Nullable BindingErrorProcessor bindingErrorProcessor)",
    "source_code": "\tpublic final void setBindingErrorProcessor(@Nullable BindingErrorProcessor bindingErrorProcessor) {\n\t\tthis.bindingErrorProcessor = bindingErrorProcessor;\n\t}"
  },
  "org.springframework.web.bind.support.ConfigurableWebBindingInitializer#setConversionService(conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a ConversionService which will apply to every DataBinder.\n\t * @since 3.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "void",
    "signature": "public void setConversionService(@Nullable ConversionService conversionService)",
    "source_code": "\tpublic final void setConversionService(@Nullable ConversionService conversionService) {\n\t\tthis.conversionService = conversionService;\n\t}"
  },
  "org.springframework.web.bind.support.ConfigurableWebBindingInitializer#setDeclarativeBinding(declarativeBinding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to bind only fields intended for binding as described in\n\t * {@link org.springframework.validation.DataBinder#setDeclarativeBinding}.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "declarativeBinding"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void setDeclarativeBinding(boolean declarativeBinding)",
    "source_code": "\tpublic void setDeclarativeBinding(boolean declarativeBinding) {\n\t\tthis.declarativeBinding = declarativeBinding;\n\t}"
  },
  "org.springframework.web.bind.support.ConfigurableWebBindingInitializer#setDirectFieldAccess(directFieldAccess)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to use direct field access instead of bean property access.\n\t * <p>Default is {@code false}, using bean property access.\n\t * Switch this to {@code true} in order to enforce direct field access.\n\t * @see org.springframework.validation.DataBinder#initDirectFieldAccess()\n\t * @see org.springframework.validation.DataBinder#initBeanPropertyAccess()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "directFieldAccess"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void setDirectFieldAccess(boolean directFieldAccess)",
    "source_code": "\tpublic final void setDirectFieldAccess(boolean directFieldAccess) {\n\t\tthis.directFieldAccess = directFieldAccess;\n\t}"
  },
  "org.springframework.web.bind.support.ConfigurableWebBindingInitializer#setMessageCodesResolver(messageCodesResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the strategy to use for resolving errors into message codes.\n\t * Applies the given strategy to all data binders used by this controller.\n\t * <p>Default is {@code null}, i.e. using the default strategy of\n\t * the data binder.\n\t * @see org.springframework.validation.DataBinder#setMessageCodesResolver\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageCodesResolver"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "void",
    "signature": "public void setMessageCodesResolver(@Nullable MessageCodesResolver messageCodesResolver)",
    "source_code": "\tpublic final void setMessageCodesResolver(@Nullable MessageCodesResolver messageCodesResolver) {\n\t\tthis.messageCodesResolver = messageCodesResolver;\n\t}"
  },
  "org.springframework.web.bind.support.ConfigurableWebBindingInitializer#setPropertyEditorRegistrar(propertyEditorRegistrar)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a single PropertyEditorRegistrar to be applied to every DataBinder.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyEditorRegistrar"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "public void setPropertyEditorRegistrar(PropertyEditorRegistrar propertyEditorRegistrar)",
    "source_code": "\tpublic final void setPropertyEditorRegistrar(PropertyEditorRegistrar propertyEditorRegistrar) {\n\t\tthis.propertyEditorRegistrars = new PropertyEditorRegistrar[] {propertyEditorRegistrar};\n\t}"
  },
  "org.springframework.web.bind.support.ConfigurableWebBindingInitializer#setPropertyEditorRegistrars(propertyEditorRegistrars)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify multiple PropertyEditorRegistrars to be applied to every DataBinder.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyEditorRegistrars"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "public void setPropertyEditorRegistrars(PropertyEditorRegistrar @Nullable [] propertyEditorRegistrars)",
    "source_code": "\tpublic final void setPropertyEditorRegistrars(PropertyEditorRegistrar @Nullable [] propertyEditorRegistrars) {\n\t\tthis.propertyEditorRegistrars = propertyEditorRegistrars;\n\t}"
  },
  "org.springframework.web.bind.support.ConfigurableWebBindingInitializer#setValidator(validator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Validator to apply after each binding step.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "validator"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "void",
    "signature": "public void setValidator(@Nullable Validator validator)",
    "source_code": "\tpublic final void setValidator(@Nullable Validator validator) {\n\t\tthis.validator = validator;\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link ServerWebInputException} subclass that indicates a data binding or\n * validation failure.\n *\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class WebExchangeBindException",
    "source_code": "public class WebExchangeBindException extends ServerWebInputException implements BindingResult {\n\n\tprivate final BindingResult bindingResult;\n\n\n\tpublic WebExchangeBindException(MethodParameter parameter, BindingResult bindingResult) {\n\t\tsuper(\"Validation failure\", parameter, null, null, null);\n\t\tthis.bindingResult = bindingResult;\n\t\tgetBody().setDetail(\"Invalid request content.\");\n\t}\n\n\n\t/**\n\t * Return the BindingResult that this BindException wraps.\n\t * <p>Will typically be a BeanPropertyBindingResult.\n\t * @see BeanPropertyBindingResult\n\t */\n\tpublic final BindingResult getBindingResult() {\n\t\treturn this.bindingResult;\n\t}\n\n\n\t@Override\n\tpublic Object[] getDetailMessageArguments() {\n\t\treturn new Object[] {\n\t\t\t\tBindErrorUtils.resolveAndJoin(getGlobalErrors()),\n\t\t\t\tBindErrorUtils.resolveAndJoin(getFieldErrors())};\n\t}\n\n\t@Override\n\tpublic Object[] getDetailMessageArguments(MessageSource source, Locale locale) {\n\t\treturn new Object[] {\n\t\t\t\tBindErrorUtils.resolveAndJoin(getGlobalErrors(), source, locale),\n\t\t\t\tBindErrorUtils.resolveAndJoin(getFieldErrors(), source, locale)};\n\t}\n\n\n\t// BindingResult implementation methods\n\n\t@Override\n\tpublic String getObjectName() {\n\t\treturn this.bindingResult.getObjectName();\n\t}\n\n\t@Override\n\tpublic void setNestedPath(String nestedPath) {\n\t\tthis.bindingResult.setNestedPath(nestedPath);\n\t}\n\n\t@Override\n\tpublic String getNestedPath() {\n\t\treturn this.bindingResult.getNestedPath();\n\t}\n\n\t@Override\n\tpublic void pushNestedPath(String subPath) {\n\t\tthis.bindingResult.pushNestedPath(subPath);\n\t}\n\n\t@Override\n\tpublic void popNestedPath() throws IllegalStateException {\n\t\tthis.bindingResult.popNestedPath();\n\t}\n\n\t@Override\n\tpublic void reject(String errorCode) {\n\t\tthis.bindingResult.reject(errorCode);\n\t}\n\n\t@Override\n\tpublic void reject(String errorCode, String defaultMessage) {\n\t\tthis.bindingResult.reject(errorCode, defaultMessage);\n\t}\n\n\t@Override\n\tpublic void reject(String errorCode, Object @Nullable [] errorArgs, @Nullable String defaultMessage) {\n\t\tthis.bindingResult.reject(errorCode, errorArgs, defaultMessage);\n\t}\n\n\t@Override\n\tpublic void rejectValue(@Nullable String field, String errorCode) {\n\t\tthis.bindingResult.rejectValue(field, errorCode);\n\t}\n\n\t@Override\n\tpublic void rejectValue(@Nullable String field, String errorCode, String defaultMessage) {\n\t\tthis.bindingResult.rejectValue(field, errorCode, defaultMessage);\n\t}\n\n\t@Override\n\tpublic void rejectValue(@Nullable String field, String errorCode,\n\t\t\tObject @Nullable [] errorArgs, @Nullable String defaultMessage) {\n\n\t\tthis.bindingResult.rejectValue(field, errorCode, errorArgs, defaultMessage);\n\t}\n\n\t@Override\n\tpublic void addAllErrors(Errors errors) {\n\t\tthis.bindingResult.addAllErrors(errors);\n\t}\n\n\t@Override\n\tpublic boolean hasErrors() {\n\t\treturn this.bindingResult.hasErrors();\n\t}\n\n\t@Override\n\tpublic int getErrorCount() {\n\t\treturn this.bindingResult.getErrorCount();\n\t}\n\n\t@Override\n\tpublic List<ObjectError> getAllErrors() {\n\t\treturn this.bindingResult.getAllErrors();\n\t}\n\n\t@Override\n\tpublic boolean hasGlobalErrors() {\n\t\treturn this.bindingResult.hasGlobalErrors();\n\t}\n\n\t@Override\n\tpublic int getGlobalErrorCount() {\n\t\treturn this.bindingResult.getGlobalErrorCount();\n\t}\n\n\t@Override\n\tpublic List<ObjectError> getGlobalErrors() {\n\t\treturn this.bindingResult.getGlobalErrors();\n\t}\n\n\t@Override\n\tpublic @Nullable ObjectError getGlobalError() {\n\t\treturn this.bindingResult.getGlobalError();\n\t}\n\n\t@Override\n\tpublic boolean hasFieldErrors() {\n\t\treturn this.bindingResult.hasFieldErrors();\n\t}\n\n\t@Override\n\tpublic int getFieldErrorCount() {\n\t\treturn this.bindingResult.getFieldErrorCount();\n\t}\n\n\t@Override\n\tpublic List<FieldError> getFieldErrors() {\n\t\treturn this.bindingResult.getFieldErrors();\n\t}\n\n\t@Override\n\tpublic @Nullable FieldError getFieldError() {\n\t\treturn this.bindingResult.getFieldError();\n\t}\n\n\t@Override\n\tpublic boolean hasFieldErrors(String field) {\n\t\treturn this.bindingResult.hasFieldErrors(field);\n\t}\n\n\t@Override\n\tpublic int getFieldErrorCount(String field) {\n\t\treturn this.bindingResult.getFieldErrorCount(field);\n\t}\n\n\t@Override\n\tpublic List<FieldError> getFieldErrors(String field) {\n\t\treturn this.bindingResult.getFieldErrors(field);\n\t}\n\n\t@Override\n\tpublic @Nullable FieldError getFieldError(String field) {\n\t\treturn this.bindingResult.getFieldError(field);\n\t}\n\n\t@Override\n\tpublic @Nullable Object getFieldValue(String field) {\n\t\treturn this.bindingResult.getFieldValue(field);\n\t}\n\n\t@Override\n\tpublic @Nullable Class<?> getFieldType(String field) {\n\t\treturn this.bindingResult.getFieldType(field);\n\t}\n\n\t@Override\n\tpublic @Nullable Object getTarget() {\n\t\treturn this.bindingResult.getTarget();\n\t}\n\n\t@Override\n\tpublic Map<String, Object> getModel() {\n\t\treturn this.bindingResult.getModel();\n\t}\n\n\t@Override\n\tpublic @Nullable Object getRawFieldValue(String field) {\n\t\treturn this.bindingResult.getRawFieldValue(field);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"rawtypes\")\n\tpublic @Nullable PropertyEditor findEditor(@Nullable String field, @Nullable Class valueType) {\n\t\treturn this.bindingResult.findEditor(field, valueType);\n\t}\n\n\t@Override\n\tpublic @Nullable PropertyEditorRegistry getPropertyEditorRegistry() {\n\t\treturn this.bindingResult.getPropertyEditorRegistry();\n\t}\n\n\t@Override\n\tpublic String[] resolveMessageCodes(String errorCode) {\n\t\treturn this.bindingResult.resolveMessageCodes(errorCode);\n\t}\n\n\t@Override\n\tpublic String[] resolveMessageCodes(String errorCode, String field) {\n\t\treturn this.bindingResult.resolveMessageCodes(errorCode, field);\n\t}\n\n\t@Override\n\tpublic void addError(ObjectError error) {\n\t\tthis.bindingResult.addError(error);\n\t}\n\n\t@Override\n\tpublic void recordFieldValue(String field, Class<?> type, @Nullable Object value) {\n\t\tthis.bindingResult.recordFieldValue(field, type, value);\n\t}\n\n\t@Override\n\tpublic void recordSuppressedField(String field) {\n\t\tthis.bindingResult.recordSuppressedField(field);\n\t}\n\n\t@Override\n\tpublic String[] getSuppressedFields() {\n\t\treturn this.bindingResult.getSuppressedFields();\n\t}\n\n\n\t/**\n\t * Returns diagnostic information about the errors held in this object.\n\t */\n\t@Override\n\tpublic String getMessage() {\n\t\tMethodParameter parameter = getMethodParameter();\n\t\tAssert.state(parameter != null, \"No MethodParameter\");\n\t\tStringBuilder sb = new StringBuilder(\"Validation failed for argument at index \")\n\t\t\t\t.append(parameter.getParameterIndex()).append(\" in method: \")\n\t\t\t\t.append(parameter.getExecutable().toGenericString())\n\t\t\t\t.append(\", with \").append(getErrorCount()).append(\" error(s): \");\n\t\tfor (ObjectError error : getAllErrors()) {\n\t\t\tsb.append('[').append(error).append(\"] \");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || this.bindingResult.equals(other));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.bindingResult.hashCode();\n\t}\n\n}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#addAllErrors(errors)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void addAllErrors(Errors errors)",
    "source_code": "\tpublic void addAllErrors(Errors errors) {\n\t\tthis.bindingResult.addAllErrors(errors);\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#addError(error)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "error"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "void",
    "signature": "public void addError(ObjectError error)",
    "source_code": "\tpublic void addError(ObjectError error) {\n\t\tthis.bindingResult.addError(error);\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || this.bindingResult.equals(other));\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#findEditor(field,valueType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "valueType"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "PropertyEditor",
    "signature": "public PropertyEditor findEditor(@Nullable String field, @Nullable Class valueType)",
    "source_code": "\tpublic @Nullable PropertyEditor findEditor(@Nullable String field, @Nullable Class valueType) {\n\t\treturn this.bindingResult.findEditor(field, valueType);\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getAllErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "List<ObjectError>",
    "signature": "public List<ObjectError> getAllErrors()",
    "source_code": "\tpublic List<ObjectError> getAllErrors() {\n\t\treturn this.bindingResult.getAllErrors();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getBindingResult()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the BindingResult that this BindException wraps.\n\t * <p>Will typically be a BeanPropertyBindingResult.\n\t * @see BeanPropertyBindingResult\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "BindingResult",
    "signature": "public BindingResult getBindingResult()",
    "source_code": "\tpublic final BindingResult getBindingResult() {\n\t\treturn this.bindingResult;\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getDetailMessageArguments()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "Object[]",
    "signature": "public Object[] getDetailMessageArguments()",
    "source_code": "\tpublic Object[] getDetailMessageArguments() {\n\t\treturn new Object[] {\n\t\t\t\tBindErrorUtils.resolveAndJoin(getGlobalErrors()),\n\t\t\t\tBindErrorUtils.resolveAndJoin(getFieldErrors())};\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getDetailMessageArguments(source,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "Object[]",
    "signature": "public Object[] getDetailMessageArguments(MessageSource source, Locale locale)",
    "source_code": "\tpublic Object[] getDetailMessageArguments(MessageSource source, Locale locale) {\n\t\treturn new Object[] {\n\t\t\t\tBindErrorUtils.resolveAndJoin(getGlobalErrors(), source, locale),\n\t\t\t\tBindErrorUtils.resolveAndJoin(getFieldErrors(), source, locale)};\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getErrorCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "int",
    "signature": "public int getErrorCount()",
    "source_code": "\tpublic int getErrorCount() {\n\t\treturn this.bindingResult.getErrorCount();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getFieldError()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "FieldError",
    "signature": "public FieldError getFieldError()",
    "source_code": "\tpublic @Nullable FieldError getFieldError() {\n\t\treturn this.bindingResult.getFieldError();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getFieldError(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "FieldError",
    "signature": "public FieldError getFieldError(String field)",
    "source_code": "\tpublic @Nullable FieldError getFieldError(String field) {\n\t\treturn this.bindingResult.getFieldError(field);\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getFieldErrorCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "int",
    "signature": "public int getFieldErrorCount()",
    "source_code": "\tpublic int getFieldErrorCount() {\n\t\treturn this.bindingResult.getFieldErrorCount();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getFieldErrorCount(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "int",
    "signature": "public int getFieldErrorCount(String field)",
    "source_code": "\tpublic int getFieldErrorCount(String field) {\n\t\treturn this.bindingResult.getFieldErrorCount(field);\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getFieldErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "List<FieldError>",
    "signature": "public List<FieldError> getFieldErrors()",
    "source_code": "\tpublic List<FieldError> getFieldErrors() {\n\t\treturn this.bindingResult.getFieldErrors();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getFieldErrors(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "List<FieldError>",
    "signature": "public List<FieldError> getFieldErrors(String field)",
    "source_code": "\tpublic List<FieldError> getFieldErrors(String field) {\n\t\treturn this.bindingResult.getFieldErrors(field);\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getFieldValue(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "Object",
    "signature": "public Object getFieldValue(String field)",
    "source_code": "\tpublic @Nullable Object getFieldValue(String field) {\n\t\treturn this.bindingResult.getFieldValue(field);\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getGlobalError()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "ObjectError",
    "signature": "public ObjectError getGlobalError()",
    "source_code": "\tpublic @Nullable ObjectError getGlobalError() {\n\t\treturn this.bindingResult.getGlobalError();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getGlobalErrorCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "int",
    "signature": "public int getGlobalErrorCount()",
    "source_code": "\tpublic int getGlobalErrorCount() {\n\t\treturn this.bindingResult.getGlobalErrorCount();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getGlobalErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "List<ObjectError>",
    "signature": "public List<ObjectError> getGlobalErrors()",
    "source_code": "\tpublic List<ObjectError> getGlobalErrors() {\n\t\treturn this.bindingResult.getGlobalErrors();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getMessage()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns diagnostic information about the errors held in this object.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "String",
    "signature": "public String getMessage()",
    "source_code": "\tpublic String getMessage() {\n\t\tMethodParameter parameter = getMethodParameter();\n\t\tAssert.state(parameter != null, \"No MethodParameter\");\n\t\tStringBuilder sb = new StringBuilder(\"Validation failed for argument at index \")\n\t\t\t\t.append(parameter.getParameterIndex()).append(\" in method: \")\n\t\t\t\t.append(parameter.getExecutable().toGenericString())\n\t\t\t\t.append(\", with \").append(getErrorCount()).append(\" error(s): \");\n\t\tfor (ObjectError error : getAllErrors()) {\n\t\t\tsb.append('[').append(error).append(\"] \");\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getModel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "Object>",
    "signature": "public Object> getModel()",
    "source_code": "\tpublic Map<String, Object> getModel() {\n\t\treturn this.bindingResult.getModel();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getNestedPath()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "String",
    "signature": "public String getNestedPath()",
    "source_code": "\tpublic String getNestedPath() {\n\t\treturn this.bindingResult.getNestedPath();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getObjectName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "String",
    "signature": "public String getObjectName()",
    "source_code": "\tpublic String getObjectName() {\n\t\treturn this.bindingResult.getObjectName();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getPropertyEditorRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "PropertyEditorRegistry",
    "signature": "public PropertyEditorRegistry getPropertyEditorRegistry()",
    "source_code": "\tpublic @Nullable PropertyEditorRegistry getPropertyEditorRegistry() {\n\t\treturn this.bindingResult.getPropertyEditorRegistry();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getRawFieldValue(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "Object",
    "signature": "public Object getRawFieldValue(String field)",
    "source_code": "\tpublic @Nullable Object getRawFieldValue(String field) {\n\t\treturn this.bindingResult.getRawFieldValue(field);\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getSuppressedFields()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "String[]",
    "signature": "public String[] getSuppressedFields()",
    "source_code": "\tpublic String[] getSuppressedFields() {\n\t\treturn this.bindingResult.getSuppressedFields();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#getTarget()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "Object",
    "signature": "public Object getTarget()",
    "source_code": "\tpublic @Nullable Object getTarget() {\n\t\treturn this.bindingResult.getTarget();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#hasErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "boolean",
    "signature": "public boolean hasErrors()",
    "source_code": "\tpublic boolean hasErrors() {\n\t\treturn this.bindingResult.hasErrors();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#hasFieldErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "boolean",
    "signature": "public boolean hasFieldErrors()",
    "source_code": "\tpublic boolean hasFieldErrors() {\n\t\treturn this.bindingResult.hasFieldErrors();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#hasFieldErrors(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "boolean",
    "signature": "public boolean hasFieldErrors(String field)",
    "source_code": "\tpublic boolean hasFieldErrors(String field) {\n\t\treturn this.bindingResult.hasFieldErrors(field);\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#hasGlobalErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "boolean",
    "signature": "public boolean hasGlobalErrors()",
    "source_code": "\tpublic boolean hasGlobalErrors() {\n\t\treturn this.bindingResult.hasGlobalErrors();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.bindingResult.hashCode();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#popNestedPath()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "void",
    "signature": "public void popNestedPath()",
    "source_code": "\tpublic void popNestedPath() throws IllegalStateException {\n\t\tthis.bindingResult.popNestedPath();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#pushNestedPath(subPath)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subPath"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "void",
    "signature": "public void pushNestedPath(String subPath)",
    "source_code": "\tpublic void pushNestedPath(String subPath) {\n\t\tthis.bindingResult.pushNestedPath(subPath);\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#recordFieldValue(field,type,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "type",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "void",
    "signature": "public void recordFieldValue(String field, Class<?> type, @Nullable Object value)",
    "source_code": "\tpublic void recordFieldValue(String field, Class<?> type, @Nullable Object value) {\n\t\tthis.bindingResult.recordFieldValue(field, type, value);\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#recordSuppressedField(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "void",
    "signature": "public void recordSuppressedField(String field)",
    "source_code": "\tpublic void recordSuppressedField(String field) {\n\t\tthis.bindingResult.recordSuppressedField(field);\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#reject(errorCode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void reject(String errorCode)",
    "source_code": "\tpublic void reject(String errorCode) {\n\t\tthis.bindingResult.reject(errorCode);\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#reject(errorCode,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void reject(String errorCode, String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, String defaultMessage) {\n\t\tthis.bindingResult.reject(errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#reject(errorCode,errorArgs,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void reject(String errorCode, Object @Nullable [] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, Object @Nullable [] errorArgs, @Nullable String defaultMessage) {\n\t\tthis.bindingResult.reject(errorCode, errorArgs, defaultMessage);\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#rejectValue(field,errorCode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode) {\n\t\tthis.bindingResult.rejectValue(field, errorCode);\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#rejectValue(field,errorCode,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode, String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode, String defaultMessage) {\n\t\tthis.bindingResult.rejectValue(field, errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#rejectValue(field,errorCode,errorArgs,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode,\n\t\t\tObject @Nullable [] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode,"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#resolveMessageCodes(errorCode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "String[]",
    "signature": "public String[] resolveMessageCodes(String errorCode)",
    "source_code": "\tpublic String[] resolveMessageCodes(String errorCode) {\n\t\treturn this.bindingResult.resolveMessageCodes(errorCode);\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#resolveMessageCodes(errorCode,field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "String[]",
    "signature": "public String[] resolveMessageCodes(String errorCode, String field)",
    "source_code": "\tpublic String[] resolveMessageCodes(String errorCode, String field) {\n\t\treturn this.bindingResult.resolveMessageCodes(errorCode, field);\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeBindException#setNestedPath(nestedPath)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestedPath"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void setNestedPath(String nestedPath)",
    "source_code": "\tpublic void setNestedPath(String nestedPath) {\n\t\tthis.bindingResult.setNestedPath(nestedPath);\n\t}"
  },
  "org.springframework.web.client.<unknown>#defaultHandler(messageConverters)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageConverters"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "StatusHandler",
    "signature": "public StatusHandler defaultHandler(List<HttpMessageConverter<?>> messageConverters)",
    "source_code": "\tpublic static StatusHandler defaultHandler(List<HttpMessageConverter<?>> messageConverters) {\n\t\treturn new StatusHandler(response -> response.getStatusCode().isError(),\n\t\t\t\t(request, response) -> {\n\t\t\t\t\tHttpStatusCode statusCode = response.getStatusCode();\n\t\t\t\t\tString statusText = response.getStatusText();\n\t\t\t\t\tHttpHeaders headers = response.getHeaders();\n\t\t\t\t\tbyte[] body = RestClientUtils.getBody(response);\n\t\t\t\t\tCharset charset = RestClientUtils.getCharset(response);\n\t\t\t\t\tString message = getErrorMessage(statusCode.value(), statusText, body, charset);\n\t\t\t\t\tRestClientResponseException ex;\n\n\t\t\t\t\tif (statusCode.is4xxClientError()) {\n\t\t\t\t\t\tex = HttpClientErrorException.create(message, statusCode, statusText, headers, body, charset);\n\t\t\t\t\t}\n\t\t\t\t\telse if (statusCode.is5xxServerError()) {\n\t\t\t\t\t\tex = HttpServerErrorException.create(message, statusCode, statusText, headers, body, charset);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tex = new UnknownHttpStatusCodeException(message, statusCode.value(), statusText, headers, body, charset);\n\t\t\t\t\t}\n\t\t\t\t\tif (!CollectionUtils.isEmpty(messageConverters)) {\n\t\t\t\t\t\tex.setBodyConvertFunction(initBodyConvertFunction(response, body, messageConverters));\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t});\n\t}"
  },
  "org.springframework.web.client.<unknown>#fromErrorHandler(errorHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "StatusHandler",
    "signature": "public StatusHandler fromErrorHandler(ResponseErrorHandler errorHandler)",
    "source_code": "\tpublic static StatusHandler fromErrorHandler(ResponseErrorHandler errorHandler) {\n\t\tAssert.notNull(errorHandler, \"ResponseErrorHandler must not be null\");\n\n\t\treturn new StatusHandler(errorHandler::hasError, (request, response) ->\n\t\t\t\terrorHandler.handleError(request.getURI(), request.getMethod(), response));\n\t}"
  },
  "org.springframework.web.client.<unknown>#handle(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void handle(HttpRequest request, ClientHttpResponse response)",
    "source_code": "\tpublic void handle(HttpRequest request, ClientHttpResponse response) throws IOException {\n\t\tthis.errorHandler.handle(request, response);\n\t}"
  },
  "org.springframework.web.client.<unknown>#of(predicate,errorHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "StatusHandler",
    "signature": "public StatusHandler of(Predicate<HttpStatusCode> predicate,\n\t\t\tRestClient.ResponseSpec.ErrorHandler errorHandler)",
    "source_code": "\tpublic static StatusHandler of(Predicate<HttpStatusCode> predicate,"
  },
  "org.springframework.web.client.<unknown>#test(response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "response"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "boolean",
    "signature": "public boolean test(ClientHttpResponse response)",
    "source_code": "\tpublic boolean test(ClientHttpResponse response) throws IOException {\n\t\treturn this.predicate.test(response);\n\t}"
  },
  "org.springframework.web.client.DefaultResponseErrorHandler#handleError(response)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "response"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "void",
    "signature": "public void handleError(ClientHttpResponse response)",
    "source_code": "\tpublic void handleError(ClientHttpResponse response) throws IOException {\n\n\t\t// Called via handleError(url, method, response)\n\t\tif (response instanceof HandleErrorResponseDecorator decorator) {\n\t\t\tdecorator.setNotHandled();\n\t\t\treturn;\n\t\t}\n\n\t\t// Called directly, so do handle\n\t\thandleError(response, response.getStatusCode(), null, null);\n\t}"
  },
  "org.springframework.web.client.DefaultResponseErrorHandler#isHandled()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "boolean",
    "signature": "public boolean isHandled()",
    "source_code": "\t\tpublic boolean isHandled() {\n\t\t\treturn this.handled;\n\t\t}"
  },
  "org.springframework.web.client.DefaultResponseErrorHandler#setNotHandled()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "void",
    "signature": "public void setNotHandled()",
    "source_code": "\t\tpublic void setNotHandled() {\n\t\t\tthis.handled = false;\n\t\t}"
  },
  "org.springframework.web.client.RestClient": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Client to perform HTTP requests, exposing a fluent, synchronous API over\n * underlying HTTP client libraries such as the JDK {@code HttpClient}, Apache\n * HttpComponents, and others.\n *\n * <p>Use static factory methods {@link #create()}, {@link #create(String)},\n * or {@link RestClient#builder()} to prepare an instance. To use the same\n * configuration as a {@link RestTemplate}, use {@link #create(RestTemplate)} or\n * {@link #builder(RestTemplate)}.\n *\n * <p>For examples with a response body see:\n * <ul>\n * <li>{@link RequestHeadersSpec#retrieve() retrieve()}\n * <li>{@link RequestHeadersSpec#exchange(RequestHeadersSpec.ExchangeFunction) exchange(Function&lt;ClientHttpRequest, T&gt;)}\n * </ul>\n *\n * <p>For examples with a request body see:\n * <ul>\n * <li>{@link RequestBodySpec#body(Object) body(Object)}\n * <li>{@link RequestBodySpec#body(Object, ParameterizedTypeReference) body(Object, ParameterizedTypeReference)}\n * <li>{@link RequestBodySpec#body(StreamingHttpOutputMessage.Body) body(Consumer&lt;OutputStream&gt;)}\n * </ul>\n *\n * @author Arjen Poutsma\n * @author Sebastien Deleuze\n * @since 6.1\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "signature": "public interface RestClient",
    "source_code": "public interface RestClient {\n\n\t/**\n\t * Start building an HTTP GET request.\n\t * @return a spec for specifying the target URL\n\t */\n\tRequestHeadersUriSpec<?> get();\n\n\t/**\n\t * Start building an HTTP HEAD request.\n\t * @return a spec for specifying the target URL\n\t */\n\tRequestHeadersUriSpec<?> head();\n\n\t/**\n\t * Start building an HTTP POST request.\n\t * @return a spec for specifying the target URL\n\t */\n\tRequestBodyUriSpec post();\n\n\t/**\n\t * Start building an HTTP PUT request.\n\t * @return a spec for specifying the target URL\n\t */\n\tRequestBodyUriSpec put();\n\n\t/**\n\t * Start building an HTTP PATCH request.\n\t * @return a spec for specifying the target URL\n\t */\n\tRequestBodyUriSpec patch();\n\n\t/**\n\t * Start building an HTTP DELETE request.\n\t * @return a spec for specifying the target URL\n\t */\n\tRequestHeadersUriSpec<?> delete();\n\n\t/**\n\t * Start building an HTTP OPTIONS request.\n\t * @return a spec for specifying the target URL\n\t */\n\tRequestHeadersUriSpec<?> options();\n\n\t/**\n\t * Start building a request for the given {@code HttpMethod}.\n\t * @return a spec for specifying the target URL\n\t */\n\tRequestBodyUriSpec method(HttpMethod method);\n\n\n\t/**\n\t * Return a builder to create a new {@code RestClient} whose settings are\n\t * replicated from this {@code RestClient}.\n\t */\n\tBuilder mutate();\n\n\n\t// Static factory methods\n\n\t/**\n\t * Create a new {@code RestClient}.\n\t * @see #create(String)\n\t * @see #builder()\n\t */\n\tstatic RestClient create() {\n\t\treturn new DefaultRestClientBuilder().build();\n\t}\n\n\t/**\n\t * Variant of {@link #create()} that accepts a default base URL. For more\n\t * details see {@link Builder#baseUrl(String) Builder.baseUrl(String)}.\n\t * @param baseUrl the base URI for all requests\n\t * @see #builder()\n\t */\n\tstatic RestClient create(String baseUrl) {\n\t\treturn new DefaultRestClientBuilder().baseUrl(baseUrl).build();\n\t}\n\n\t/**\n\t * Variant of {@link #create()} that accepts a default base {@code URI}. For more\n\t * details see {@link Builder#baseUrl(URI) Builder.baseUrl(URI)}.\n\t * @param baseUrl the base URI for all requests\n\t * @since 6.2\n\t * @see #builder()\n\t */\n\tstatic RestClient create(URI baseUrl) {\n\t\treturn new DefaultRestClientBuilder().baseUrl(baseUrl).build();\n\t}\n\n\t/**\n\t * Create a new {@code RestClient} based on the configuration of the given\n\t * {@code RestTemplate}.\n\t * <p>The returned builder is configured with the following attributes of\n\t * the template.\n\t * <ul>\n\t * <li>{@link RestTemplate#getRequestFactory() ClientHttpRequestFactory}</li>\n\t * <li>{@link RestTemplate#getMessageConverters() HttpMessageConverters}</li>\n\t * <li>{@link RestTemplate#getInterceptors() ClientHttpRequestInterceptors}</li>\n\t * <li>{@link RestTemplate#getClientHttpRequestInitializers() ClientHttpRequestInitializers}</li>\n\t * <li>{@link RestTemplate#getUriTemplateHandler() UriBuilderFactory}</li>\n\t * <li>{@linkplain RestTemplate#getErrorHandler() error handler}</li>\n\t * </ul>\n\t * @param restTemplate the rest template to base the returned client's\n\t * configuration on\n\t * @return a {@code RestClient} initialized with the {@code restTemplate}'s\n\t * configuration\n\t */\n\tstatic RestClient create(RestTemplate restTemplate) {\n\t\treturn new DefaultRestClientBuilder(restTemplate).build();\n\t}\n\n\t/**\n\t * Obtain a {@code RestClient} builder.\n\t */\n\tstatic RestClient.Builder builder() {\n\t\treturn new DefaultRestClientBuilder();\n\t}\n\n\t/**\n\t * Obtain a {@code RestClient} builder based on the configuration of the\n\t * given {@code RestTemplate}.\n\t * <p>The returned builder is configured with the following attributes of\n\t * the template.\n\t * <ul>\n\t * <li>{@link RestTemplate#getRequestFactory() ClientHttpRequestFactory}</li>\n\t * <li>{@link RestTemplate#getMessageConverters() HttpMessageConverters}</li>\n\t * <li>{@link RestTemplate#getInterceptors() ClientHttpRequestInterceptors}</li>\n\t * <li>{@link RestTemplate#getClientHttpRequestInitializers() ClientHttpRequestInitializers}</li>\n\t * <li>{@link RestTemplate#getUriTemplateHandler() UriBuilderFactory}</li>\n\t * <li>{@linkplain RestTemplate#getErrorHandler() error handler}</li>\n\t * </ul>\n\t * @param restTemplate the rest template to base the returned builder's\n\t * configuration on\n\t * @return a {@code RestClient} builder initialized with {@code restTemplate}'s\n\t * configuration\n\t */\n\tstatic RestClient.Builder builder(RestTemplate restTemplate) {\n\t\treturn new DefaultRestClientBuilder(restTemplate);\n\t}\n\n\n\t/**\n\t * A mutable builder for creating a {@link RestClient}.\n\t */\n\tinterface Builder {\n\n\t\t/**\n\t\t * Configure a base URL for requests. Effectively a shortcut for:\n\t\t * <pre class=\"code\">\n\t\t * String baseUrl = \"https://abc.go.com/v1\";\n\t\t * DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);\n\t\t * RestClient client = RestClient.builder().uriBuilderFactory(factory).build();\n\t\t * </pre>\n\t\t * <p>The {@code DefaultUriBuilderFactory} is used to prepare the URL\n\t\t * for every request with the given base URL, unless the URL request\n\t\t * for a given URL is absolute in which case the base URL is ignored.\n\t\t * <p><strong>Note:</strong> this method is mutually exclusive with\n\t\t * {@link #uriBuilderFactory(UriBuilderFactory)}. If both are used, the\n\t\t * {@code baseUrl} value provided here will be ignored.\n\t\t * @return this builder\n\t\t * @see DefaultUriBuilderFactory#DefaultUriBuilderFactory(String)\n\t\t * @see #uriBuilderFactory(UriBuilderFactory)\n\t\t */\n\t\tBuilder baseUrl(String baseUrl);\n\n\t\t/**\n\t\t * Configure a base {@code URI} for requests. Effectively a shortcut for:\n\t\t * <pre class=\"code\">\n\t\t * URI baseUrl = URI.create(\"https://abc.go.com/v1\");\n\t\t * DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl.toString());\n\t\t * RestClient client = RestClient.builder().uriBuilderFactory(factory).build();\n\t\t * </pre>\n\t\t * <p>The {@code DefaultUriBuilderFactory} is used to prepare the URL\n\t\t * for every request with the given base URL, unless the URL request\n\t\t * for a given URL is absolute in which case the base URL is ignored.\n\t\t * <p><strong>Note:</strong> this method is mutually exclusive with\n\t\t * {@link #uriBuilderFactory(UriBuilderFactory)}. If both are used, the\n\t\t * {@code baseUrl} value provided here will be ignored.\n\t\t * @return this builder\n\t\t * @since 6.2\n\t\t * @see DefaultUriBuilderFactory#DefaultUriBuilderFactory(String)\n\t\t * @see #uriBuilderFactory(UriBuilderFactory)\n\t\t */\n\t\tBuilder baseUrl(URI baseUrl);\n\n\t\t/**\n\t\t * Configure default URL variable values to use when expanding URI\n\t\t * templates with a {@link Map}. Effectively a shortcut for:\n\t\t * <pre class=\"code\">\n\t\t * Map&lt;String, ?&gt; defaultVars = ...;\n\t\t * DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory();\n\t\t * factory.setDefaultVariables(defaultVars);\n\t\t * RestClient client = RestClient.builder().uriBuilderFactory(factory).build();\n\t\t * </pre>\n\t\t * <p><strong>Note:</strong> this method is mutually exclusive with\n\t\t * {@link #uriBuilderFactory(UriBuilderFactory)}. If both are used, the\n\t\t * {@code defaultUriVariables} value provided here will be ignored.\n\t\t * @return this builder\n\t\t * @see DefaultUriBuilderFactory#setDefaultUriVariables(Map)\n\t\t * @see #uriBuilderFactory(UriBuilderFactory)\n\t\t */\n\t\tBuilder defaultUriVariables(Map<String, ?> defaultUriVariables);\n\n\t\t/**\n\t\t * Provide a pre-configured {@link UriBuilderFactory} instance. This is\n\t\t * an alternative to, and effectively overrides the following shortcut\n\t\t * properties:\n\t\t * <ul>\n\t\t * <li>{@link #baseUrl(String)}\n\t\t * <li>{@link #defaultUriVariables(Map)}.\n\t\t * </ul>\n\t\t * @param uriBuilderFactory the URI builder factory to use\n\t\t * @return this builder\n\t\t * @see #baseUrl(String)\n\t\t * @see #defaultUriVariables(Map)\n\t\t */\n\t\tBuilder uriBuilderFactory(UriBuilderFactory uriBuilderFactory);\n\n\t\t/**\n\t\t * Global option to specify a header to be added to every request,\n\t\t * if the request does not already contain such a header.\n\t\t * @param header the header name\n\t\t * @param values the header values\n\t\t * @return this builder\n\t\t */\n\t\tBuilder defaultHeader(String header, String... values);\n\n\t\t/**\n\t\t * Provide a consumer to access to every {@linkplain #defaultHeader(String, String...)\n\t\t * default header} declared so far, with the possibility to add, replace, or remove.\n\t\t * @param headersConsumer the consumer\n\t\t * @return this builder\n\t\t */\n\t\tBuilder defaultHeaders(Consumer<HttpHeaders> headersConsumer);\n\n\t\t/**\n\t\t * Global option to specify a cookie to be added to every request,\n\t\t * if the request does not already contain such a cookie.\n\t\t * @param cookie the cookie name\n\t\t * @param values the cookie values\n\t\t * @since 6.2\n\t\t */\n\t\tBuilder defaultCookie(String cookie, String... values);\n\n\t\t/**\n\t\t * Provides access to every {@link #defaultCookie(String, String...)}\n\t\t * declared so far with the possibility to add, replace, or remove.\n\t\t * @param cookiesConsumer a function that consumes the cookies map\n\t\t * @since 6.2\n\t\t */\n\t\tBuilder defaultCookies(Consumer<MultiValueMap<String, String>> cookiesConsumer);\n\n\t\t/**\n\t\t * Provide a consumer to customize every request being built.\n\t\t * @param defaultRequest the consumer to use for modifying requests\n\t\t * @return this builder\n\t\t */\n\t\tBuilder defaultRequest(Consumer<RequestHeadersSpec<?>> defaultRequest);\n\n\t\t/**\n\t\t * Register a default\n\t\t * {@linkplain ResponseSpec#onStatus(Predicate, ResponseSpec.ErrorHandler) status handler}\n\t\t * to apply to every response. Such default handlers are applied in the\n\t\t * order in which they are registered, and after any others that are\n\t\t * registered for a specific response.\n\t\t * @param statusPredicate to match responses with\n\t\t * @param errorHandler handler that typically, though not necessarily,\n\t\t * throws an exception\n\t\t * @return this builder\n\t\t */\n\t\tBuilder defaultStatusHandler(Predicate<HttpStatusCode> statusPredicate,\n\t\t\t\t\t\tResponseSpec.ErrorHandler errorHandler);\n\n\t\t/**\n\t\t * Register a default\n\t\t * {@linkplain ResponseSpec#onStatus(ResponseErrorHandler) status handler}\n\t\t * to apply to every response. Such default handlers are applied in the\n\t\t * order in which they are registered, and after any others that are\n\t\t * registered for a specific response.\n\t\t * <p>The first status handler who claims that a response has an\n\t\t * error is invoked. If you want to disable other defaults, consider\n\t\t * using {@link #defaultStatusHandler(Predicate, ResponseSpec.ErrorHandler)}\n\t\t * with a predicate that matches all status codes.\n\t\t * @param errorHandler handler that typically, though not necessarily,\n\t\t * throws an exception\n\t\t * @return this builder\n\t\t */\n\t\tBuilder defaultStatusHandler(ResponseErrorHandler errorHandler);\n\n\t\t/**\n\t\t * Add the given request interceptor to the end of the interceptor chain.\n\t\t * @param interceptor the interceptor to be added to the chain\n\t\t * @return this builder\n\t\t */\n\t\tBuilder requestInterceptor(ClientHttpRequestInterceptor interceptor);\n\n\t\t/**\n\t\t * Manipulate the interceptors with the given consumer. The list provided to\n\t\t * the consumer is \"live\", so that the consumer can be used to remove\n\t\t * interceptors, change ordering, etc.\n\t\t * @param interceptorsConsumer a function that consumes the interceptors list\n\t\t * @return this builder\n\t\t */\n\t\tBuilder requestInterceptors(Consumer<List<ClientHttpRequestInterceptor>> interceptorsConsumer);\n\n\t\t/**\n\t\t * Enable buffering of request and response, aggregating all content before\n\t\t * it is sent, and making it possible to read the response body repeatedly.\n\t\t * @param predicate to determine whether to buffer for the given request\n\t\t * @return this builder\n\t\t * @since 7.0\n\t\t */\n\t\tBuilder bufferContent(BiPredicate<URI, HttpMethod> predicate);\n\n\t\t/**\n\t\t * Add the given request initializer to the end of the initializer chain.\n\t\t * @param initializer the initializer to be added to the chain\n\t\t * @return this builder\n\t\t */\n\t\tBuilder requestInitializer(ClientHttpRequestInitializer initializer);\n\n\t\t/**\n\t\t * Manipulate the initializers with the given consumer. The list provided to\n\t\t * the consumer is \"live\", so that the consumer can be used to remove\n\t\t * initializers, change ordering, etc.\n\t\t * @param initializersConsumer a function that consumes the initializers list\n\t\t * @return this builder\n\t\t */\n\t\tBuilder requestInitializers(Consumer<List<ClientHttpRequestInitializer>> initializersConsumer);\n\n\t\t/**\n\t\t * Configure the {@link ClientHttpRequestFactory} to use. This is useful\n\t\t * for plugging in and/or customizing options of the underlying HTTP\n\t\t * client library (for example, SSL).\n\t\t * <p>If no request factory is specified, {@code RestClient} uses\n\t\t * {@linkplain org.springframework.http.client.HttpComponentsClientHttpRequestFactory Apache Http Client},\n\t\t * {@linkplain org.springframework.http.client.JettyClientHttpRequestFactory Jetty Http Client}\n\t\t * if available on the classpath, and defaults to the\n\t\t * {@linkplain org.springframework.http.client.JdkClientHttpRequestFactory JDK HttpClient}\n\t\t * if the {@code java.net.http} module is loaded, or to a\n\t\t * {@linkplain org.springframework.http.client.SimpleClientHttpRequestFactory simple default}\n\t\t * otherwise.\n\t\t * @param requestFactory the request factory to use\n\t\t * @return this builder\n\t\t */\n\t\tBuilder requestFactory(ClientHttpRequestFactory requestFactory);\n\n\t\t/**\n\t\t * Configure the message converters for the {@code RestClient} to use.\n\t\t * @param configurer the configurer to apply on the list of default\n\t\t * {@link HttpMessageConverter} pre-initialized\n\t\t * @return this builder\n\t\t * @see #messageConverters(List)\n\t\t */\n\t\tBuilder messageConverters(Consumer<List<HttpMessageConverter<?>>> configurer);\n\n\t\t/**\n\t\t * Set the message converters for the {@code RestClient} to use.\n\t\t * @param messageConverters the list of {@link HttpMessageConverter} to use\n\t\t * @return this builder\n\t\t * @since 6.2\n\t\t * @see #messageConverters(Consumer)\n\t\t */\n\t\tBuilder messageConverters(List<HttpMessageConverter<?>> messageConverters);\n\n\t\t/**\n\t\t * Configure the {@link io.micrometer.observation.ObservationRegistry} to use\n\t\t * for recording HTTP client observations.\n\t\t * @param observationRegistry the observation registry to use\n\t\t * @return this builder\n\t\t */\n\t\tBuilder observationRegistry(ObservationRegistry observationRegistry);\n\n\t\t/**\n\t\t * Configure the {@link io.micrometer.observation.ObservationConvention} to use\n\t\t * for collecting metadata for the request observation. Will use\n\t\t * {@link org.springframework.http.client.observation.DefaultClientRequestObservationConvention}\n\t\t * if none provided.\n\t\t * @param observationConvention the observation convention to use\n\t\t * @return this builder\n\t\t */\n\t\tBuilder observationConvention(ClientRequestObservationConvention observationConvention);\n\n\t\t/**\n\t\t * Apply the given {@code Consumer} to this builder instance.\n\t\t * <p>This can be useful for applying pre-packaged customizations.\n\t\t * @param builderConsumer the consumer to apply\n\t\t * @return this builder\n\t\t */\n\t\tBuilder apply(Consumer<Builder> builderConsumer);\n\n\t\t/**\n\t\t * Clone this {@code RestClient.Builder}.\n\t\t */\n\t\tBuilder clone();\n\n\t\t/**\n\t\t * Build the {@link RestClient} instance.\n\t\t */\n\t\tRestClient build();\n\t}\n\n\n\t/**\n\t * Contract for specifying the URI for a request.\n\t * @param <S> a self reference to the spec type\n\t */\n\tinterface UriSpec<S extends RequestHeadersSpec<?>> {\n\n\t\t/**\n\t\t * Specify the URI using a fully constructed {@link URI}.\n\t\t * <p>If the given URI is absolute, it is used as given. If it is\n\t\t * a relative URI, the {@link UriBuilderFactory} configured for\n\t\t * the client (for example, with a base URI) will be used to\n\t\t * {@linkplain URI#resolve(URI) resolve} the given URI against.\n\t\t */\n\t\tS uri(URI uri);\n\n\t\t/**\n\t\t * Specify the URI for the request using a URI template and URI variables.\n\t\t * <p>If a {@link UriBuilderFactory} was configured for the client (for example,\n\t\t * with a base URI) it will be used to expand the URI template.\n\t\t */\n\t\tS uri(String uri, @Nullable Object... uriVariables);\n\n\t\t/**\n\t\t * Specify the URI for the request using a URI template and URI variables.\n\t\t * <p>If a {@link UriBuilderFactory} was configured for the client (for example,\n\t\t * with a base URI) it will be used to expand the URI template.\n\t\t */\n\t\tS uri(String uri, Map<String, ? extends @Nullable Object> uriVariables);\n\n\t\t/**\n\t\t * Specify the URI starting with a URI template and finishing off with a\n\t\t * {@link UriBuilder} created from the template.\n\t\t */\n\t\tS uri(String uri, Function<UriBuilder, URI> uriFunction);\n\n\t\t/**\n\t\t * Specify the URI by through a {@link UriBuilder}.\n\t\t * @see #uri(String, Function)\n\t\t */\n\t\tS uri(Function<UriBuilder, URI> uriFunction);\n\t}\n\n\n\t/**\n\t * Contract for specifying request headers leading up to the exchange.\n\t * @param <S> a self reference to the spec type\n\t */\n\tinterface RequestHeadersSpec<S extends RequestHeadersSpec<S>> {\n\n\t\t/**\n\t\t * Set the list of acceptable {@linkplain MediaType media types}, as\n\t\t * specified by the {@code Accept} header.\n\t\t * @param acceptableMediaTypes the acceptable media types\n\t\t * @return this builder\n\t\t */\n\t\tS accept(MediaType... acceptableMediaTypes);\n\n\t\t/**\n\t\t * Set the list of acceptable {@linkplain Charset charsets}, as specified\n\t\t * by the {@code Accept-Charset} header.\n\t\t * @param acceptableCharsets the acceptable charsets\n\t\t * @return this builder\n\t\t */\n\t\tS acceptCharset(Charset... acceptableCharsets);\n\n\t\t/**\n\t\t * Add a cookie with the given name and value.\n\t\t * @param name the cookie name\n\t\t * @param value the cookie value\n\t\t * @return this builder\n\t\t * @since 6.2\n\t\t */\n\t\tS cookie(String name, String value);\n\n\t\t/**\n\t\t * Provides access to every cookie declared so far with the possibility\n\t\t * to add, replace, or remove values.\n\t\t * @param cookiesConsumer the consumer to provide access to\n\t\t * @return this builder\n\t\t * @since 6.2\n\t\t */\n\t\tS cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer);\n\n\t\t/**\n\t\t * Set the value of the {@code If-Modified-Since} header.\n\t\t * @param ifModifiedSince the new value of the header\n\t\t * @return this builder\n\t\t */\n\t\tS ifModifiedSince(ZonedDateTime ifModifiedSince);\n\n\t\t/**\n\t\t * Set the values of the {@code If-None-Match} header.\n\t\t * @param ifNoneMatches the new value of the header\n\t\t * @return this builder\n\t\t */\n\t\tS ifNoneMatch(String... ifNoneMatches);\n\n\t\t/**\n\t\t * Add the given, single header value under the given name.\n\t\t * @param headerName  the header name\n\t\t * @param headerValues the header value(s)\n\t\t * @return this builder\n\t\t */\n\t\tS header(String headerName, String... headerValues);\n\n\t\t/**\n\t\t * Provides access to every header declared so far with the possibility\n\t\t * to add, replace, or remove values.\n\t\t * @param headersConsumer the consumer to provide access to\n\t\t * @return this builder\n\t\t */\n\t\tS headers(Consumer<HttpHeaders> headersConsumer);\n\n\t\t/**\n\t\t * Set the attribute with the given name to the given value.\n\t\t * @param name the name of the attribute to add\n\t\t * @param value the value of the attribute to add\n\t\t * @return this builder\n\t\t * @since 6.2\n\t\t */\n\t\tS attribute(String name, Object value);\n\n\t\t/**\n\t\t * Provides access to every attribute declared so far with the\n\t\t * possibility to add, replace, or remove values.\n\t\t * @param attributesConsumer the consumer to provide access to\n\t\t * @return this builder\n\t\t * @since 6.2\n\t\t */\n\t\tS attributes(Consumer<Map<String, Object>> attributesConsumer);\n\n\t\t/**\n\t\t * Callback for access to the {@link ClientHttpRequest} that in turn\n\t\t * provides access to the native request of the underlying HTTP library.\n\t\t * <p>This could be useful for setting advanced, per-request options that\n\t\t * are exposed by the underlying library.\n\t\t * @param requestConsumer a consumer to access the\n\t\t * {@code ClientHttpRequest} with\n\t\t * @return this builder\n\t\t */\n\t\tS httpRequest(Consumer<ClientHttpRequest> requestConsumer);\n\n\t\t/**\n\t\t * Enter the retrieve workflow and use the returned {@link ResponseSpec}\n\t\t * to select from a number of built-in options to extract the response.\n\t\t * For example:\n\t\t *\n\t\t * <pre class=\"code\">\n\t\t * ResponseEntity&lt;Person&gt; entity = client.get()\n\t\t *     .uri(\"/persons/1\")\n\t\t *     .accept(MediaType.APPLICATION_JSON)\n\t\t *     .retrieve()\n\t\t *     .toEntity(Person.class);\n\t\t * </pre>\n\t\t * <p>Or if interested only in the body:\n\t\t * <pre class=\"code\">\n\t\t * Person person = client.get()\n\t\t *     .uri(\"/persons/1\")\n\t\t *     .accept(MediaType.APPLICATION_JSON)\n\t\t *     .retrieve()\n\t\t *     .body(Person.class);\n\t\t * </pre>\n\t\t * Note that this method does not actually execute the request until you\n\t\t * call one of the returned {@link ResponseSpec}. Use the\n\t\t * {@link #exchange(ExchangeFunction)} variants if you need to separate\n\t\t * request execution from response extraction.\n\t\t * <p>By default, 4xx response code result in a\n\t\t * {@link HttpClientErrorException} and 5xx response codes in a\n\t\t * {@link HttpServerErrorException}. To customize error handling, use\n\t\t * {@link ResponseSpec#onStatus(Predicate, ResponseSpec.ErrorHandler) onStatus} handlers.\n\t\t * @return {@code ResponseSpec} to specify how to decode the body\n\t\t */\n\t\t@CheckReturnValue\n\t\tResponseSpec retrieve();\n\n\t\t/**\n\t\t * Exchange the {@link ClientHttpResponse} for a type {@code T}. This\n\t\t * can be useful for advanced scenarios, for example to decode the\n\t\t * response differently depending on the response status:\n\t\t * <pre class=\"code\">\n\t\t * Person person = client.get()\n\t\t *     .uri(\"/people/1\")\n\t\t *     .accept(MediaType.APPLICATION_JSON)\n\t\t *     .exchange((request, response) -&gt; {\n\t\t *         if (response.getStatusCode().equals(HttpStatus.OK)) {\n\t\t *             return deserialize(response.getBody());\n\t\t *         }\n\t\t *         else {\n\t\t *             throw new BusinessException();\n\t\t *         }\n\t\t *     });\n\t\t * </pre>\n\t\t * <p><strong>Note:</strong> The response is\n\t\t * {@linkplain ClientHttpResponse#close() closed} after the exchange\n\t\t * function has been invoked.\n\t\t * @param exchangeFunction the function to handle the response with\n\t\t * @param <T> the type the response will be transformed to\n\t\t * @return the value returned from the exchange function\n\t\t */\n\t\tdefault <T> @Nullable T exchange(ExchangeFunction<T> exchangeFunction) {\n\t\t\treturn exchange(exchangeFunction, true);\n\t\t}\n\n\t\t/**\n\t\t * Exchange the {@link ClientHttpResponse} for a type {@code T}. This\n\t\t * can be useful for advanced scenarios, for example to decode the\n\t\t * response differently depending on the response status:\n\t\t * <pre class=\"code\">\n\t\t * Person person = client.get()\n\t\t *     .uri(\"/people/1\")\n\t\t *     .accept(MediaType.APPLICATION_JSON)\n\t\t *     .exchange((request, response) -&gt; {\n\t\t *         if (response.getStatusCode().equals(HttpStatus.OK)) {\n\t\t *             return deserialize(response.getBody());\n\t\t *         }\n\t\t *         else {\n\t\t *             throw new BusinessException();\n\t\t *         }\n\t\t *     });\n\t\t * </pre>\n\t\t * <p><strong>Note:</strong> If {@code close} is {@code true},\n\t\t * then the response is {@linkplain ClientHttpResponse#close() closed}\n\t\t * after the exchange function has been invoked. When set to\n\t\t * {@code false}, the caller is responsible for closing the response.\n\t\t * @param exchangeFunction the function to handle the response with\n\t\t * @param close {@code true} to close the response after\n\t\t * {@code exchangeFunction} is invoked, {@code false} to keep it open\n\t\t * @param <T> the type the response will be transformed to\n\t\t * @return the value returned from the exchange function\n\t\t */\n\t\t<T> @Nullable T exchange(ExchangeFunction<T> exchangeFunction, boolean close);\n\n\n\t\t/**\n\t\t * Defines the contract for {@link #exchange(ExchangeFunction)}.\n\t\t * @param <T> the type the response will be transformed to\n\t\t */\n\t\t@FunctionalInterface\n\t\tinterface ExchangeFunction<T> {\n\n\t\t\t/**\n\t\t\t * Exchange the given response into a type {@code T}.\n\t\t\t * @param clientRequest the request\n\t\t\t * @param clientResponse the response\n\t\t\t * @return the exchanged type\n\t\t\t * @throws IOException in case of I/O errors\n\t\t\t */\n\t\t\t@Nullable T exchange(HttpRequest clientRequest, ConvertibleClientHttpResponse clientResponse) throws IOException;\n\t\t}\n\n\n\t\t/**\n\t\t * Extension of {@link ClientHttpResponse} that can convert the body.\n\t\t */\n\t\tinterface ConvertibleClientHttpResponse extends ClientHttpResponse {\n\n\t\t\t/**\n\t\t\t * Extract the response body as an object of the given type.\n\t\t\t * @param bodyType the type of return value\n\t\t\t * @param <T> the body type\n\t\t\t * @return the body, or {@code null} if no response body was available\n\t\t\t */\n\t\t\t<T> @Nullable T bodyTo(Class<T> bodyType);\n\n\t\t\t/**\n\t\t\t * Extract the response body as an object of the given type.\n\t\t\t * @param bodyType the type of return value\n\t\t\t * @param <T> the body type\n\t\t\t * @return the body, or {@code null} if no response body was available\n\t\t\t */\n\t\t\t<T> @Nullable T bodyTo(ParameterizedTypeReference<T> bodyType);\n\n\t\t}\n\t}\n\n\n\t/**\n\t * Contract for specifying request headers and body leading up to the exchange.\n\t */\n\tinterface RequestBodySpec extends RequestHeadersSpec<RequestBodySpec> {\n\n\t\t/**\n\t\t * Set the length of the body in bytes, as specified by the\n\t\t * {@code Content-Length} header.\n\t\t * @param contentLength the content length\n\t\t * @return this builder\n\t\t * @see HttpHeaders#setContentLength(long)\n\t\t */\n\t\tRequestBodySpec contentLength(long contentLength);\n\n\t\t/**\n\t\t * Set the {@linkplain MediaType media type} of the body, as specified\n\t\t * by the {@code Content-Type} header.\n\t\t * @param contentType the content type\n\t\t * @return this builder\n\t\t * @see HttpHeaders#setContentType(MediaType)\n\t\t */\n\t\tRequestBodySpec contentType(MediaType contentType);\n\n\t\t/**\n\t\t * Set the body of the request to the given {@code Object}.\n\t\t * For example:\n\t\t * <pre class=\"code\">\n\t\t * Person person = ... ;\n\t\t * ResponseEntity&lt;Void&gt; response = client.post()\n\t\t *     .uri(\"/persons/{id}\", id)\n\t\t *     .contentType(MediaType.APPLICATION_JSON)\n\t\t *     .body(person)\n\t\t *     .retrieve()\n\t\t *     .toBodilessEntity();\n\t\t * </pre>\n\t\t * @param body the body of the request\n\t\t * @return this builder\n\t\t */\n\t\tRequestBodySpec body(Object body);\n\n\t\t/**\n\t\t * Set the body of the request to the given {@code Object}.\n\t\t * The parameter {@code bodyType} is used to capture the generic type.\n\t\t * @param body the body of the request\n\t\t * @param bodyType the type of the body, used to capture the generic type\n\t\t * @return this builder\n\t\t */\n\t\t<T> RequestBodySpec body(T body, ParameterizedTypeReference<T> bodyType);\n\n\t\t/**\n\t\t * Set the body of the request to the given function that writes to\n\t\t * an {@link OutputStream}.\n\t\t * @param body a function that takes an {@code OutputStream} and can\n\t\t * throw an {@code IOException}\n\t\t * @return this builder\n\t\t */\n\t\tRequestBodySpec body(StreamingHttpOutputMessage.Body body);\n\t}\n\n\n\t/**\n\t * Contract for specifying response operations following the exchange.\n\t */\n\tinterface ResponseSpec {\n\n\t\t/**\n\t\t * Provide a function to map specific error status codes to an error handler.\n\t\t * <p>By default, if there are no matching status handlers, responses with\n\t\t * status codes &gt;= 400 wil throw a {@link RestClientResponseException}.\n\t\t * <p>Note that {@link IOException IOExceptions},\n\t\t * {@link java.io.UncheckedIOException UncheckedIOExceptions}, and\n\t\t * {@link org.springframework.http.converter.HttpMessageNotReadableException HttpMessageNotReadableExceptions}\n\t\t * thrown from {@code errorHandler} will be wrapped in a\n\t\t * {@link RestClientException}.\n\t\t * @param statusPredicate to match responses with\n\t\t * @param errorHandler handler that typically, though not necessarily,\n\t\t * throws an exception\n\t\t * @return this builder\n\t\t */\n\t\tResponseSpec onStatus(Predicate<HttpStatusCode> statusPredicate,\n\t\t\t\tErrorHandler errorHandler);\n\n\t\t/**\n\t\t * Provide a function to map specific error status codes to an error handler.\n\t\t * <p>By default, if there are no matching status handlers, responses with\n\t\t * status codes &gt;= 400 wil throw a {@link RestClientResponseException}.\n\t\t * <p>Note that {@link IOException IOExceptions},\n\t\t * {@link java.io.UncheckedIOException UncheckedIOExceptions}, and\n\t\t * {@link org.springframework.http.converter.HttpMessageNotReadableException HttpMessageNotReadableExceptions}\n\t\t * thrown from {@code errorHandler} will be wrapped in a\n\t\t * {@link RestClientException}.\n\t\t * @param errorHandler the error handler\n\t\t * @return this builder\n\t\t */\n\t\tResponseSpec onStatus(ResponseErrorHandler errorHandler);\n\n\t\t/**\n\t\t * Extract the body as an object of the given type.\n\t\t * @param bodyType the type of return value\n\t\t * @param <T> the body type\n\t\t * @return the body, or {@code null} if no response body was available\n\t\t * @throws RestClientResponseException by default when receiving a\n\t\t * response with a status code of 4xx or 5xx. Use\n\t\t * {@link #onStatus(Predicate, ErrorHandler)} to customize error response\n\t\t * handling.\n\t\t */\n\t\t<T> @Nullable T body(Class<T> bodyType);\n\n\t\t/**\n\t\t * Extract the body as an object of the given type.\n\t\t * @param bodyType the type of return value\n\t\t * @param <T> the body type\n\t\t * @return the body, or {@code null} if no response body was available\n\t\t * @throws RestClientResponseException by default when receiving a\n\t\t * response with a status code of 4xx or 5xx. Use\n\t\t * {@link #onStatus(Predicate, ErrorHandler)} to customize error response\n\t\t * handling.\n\t\t */\n\t\t<T> @Nullable T body(ParameterizedTypeReference<T> bodyType);\n\n\t\t/**\n\t\t * Return a {@code ResponseEntity} with the body decoded to an Object of\n\t\t * the given type.\n\t\t * @param bodyType the expected response body type\n\t\t * @param <T> response body type\n\t\t * @return the {@code ResponseEntity} with the decoded body\n\t\t * @throws RestClientResponseException by default when receiving a\n\t\t * response with a status code of 4xx or 5xx. Use\n\t\t * {@link #onStatus(Predicate, ErrorHandler)} to customize error response\n\t\t * handling.\n\t\t */\n\t\t<T> ResponseEntity<T> toEntity(Class<T> bodyType);\n\n\t\t/**\n\t\t * Return a {@code ResponseEntity} with the body decoded to an Object of\n\t\t * the given type.\n\t\t * @param bodyType the expected response body type\n\t\t * @param <T> response body type\n\t\t * @return the {@code ResponseEntity} with the decoded body\n\t\t * @throws RestClientResponseException by default when receiving a\n\t\t * response with a status code of 4xx or 5xx. Use\n\t\t * {@link #onStatus(Predicate, ErrorHandler)} to customize error response\n\t\t * handling.\n\t\t */\n\t\t<T> ResponseEntity<T> toEntity(ParameterizedTypeReference<T> bodyType);\n\n\t\t/**\n\t\t * Return a {@code ResponseEntity} without a body.\n\t\t * @return the {@code ResponseEntity}\n\t\t * @throws RestClientResponseException by default when receiving a\n\t\t * response with a status code of 4xx or 5xx. Use\n\t\t * {@link #onStatus(Predicate, ErrorHandler)} to customize error response\n\t\t * handling.\n\t\t */\n\t\tResponseEntity<Void> toBodilessEntity();\n\n\n\t\t/**\n\t\t * Used in {@link #onStatus(Predicate, ErrorHandler)}.\n\t\t */\n\t\t@FunctionalInterface\n\t\tinterface ErrorHandler {\n\n\t\t\t/**\n\t\t\t * Handle the error in the given response.\n\t\t\t * @param response the response with the error\n\t\t\t * @throws IOException in case of I/O errors\n\t\t\t */\n\t\t\tvoid handle(HttpRequest request, ClientHttpResponse response) throws IOException;\n\t\t}\n\t}\n\n\n\t/**\n\t * Contract for specifying request headers and URI for a request.\n\t * @param <S> a self reference to the spec type\n\t */\n\tinterface RequestHeadersUriSpec<S extends RequestHeadersSpec<S>> extends UriSpec<S>, RequestHeadersSpec<S> {\n\t}\n\n\n\t/**\n\t * Contract for specifying request headers, body and URI for a request.\n\t */\n\tinterface RequestBodyUriSpec extends RequestBodySpec, RequestHeadersUriSpec<RequestBodySpec> {\n\t}\n\n\n}"
  },
  "org.springframework.web.client.RestClientResponseException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Common base class for exceptions that contain actual HTTP response data.\n *\n * @author Rossen Stoyanchev\n * @since 4.3\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class RestClientResponseException",
    "source_code": "public class RestClientResponseException extends RestClientException {\n\n\tprivate static final long serialVersionUID = -8803556342728481792L;\n\n\tprivate static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;\n\n\n\tprivate final HttpStatusCode statusCode;\n\n\tprivate final String statusText;\n\n\tprivate final byte[] responseBody;\n\n\tprivate final @Nullable HttpHeaders responseHeaders;\n\n\tprivate final @Nullable String responseCharset;\n\n\tprivate transient @Nullable Function<ResolvableType, ? extends @Nullable Object> bodyConvertFunction;\n\n\n\t/**\n\t * Construct a new instance of with the given response data.\n\t * @param statusCode the raw status code value\n\t * @param statusText the status text\n\t * @param headers the response headers (may be {@code null})\n\t * @param responseBody the response body content (may be {@code null})\n\t * @param responseCharset the response body charset (may be {@code null})\n\t */\n\tpublic RestClientResponseException(\n\t\t\tString message, int statusCode, String statusText, @Nullable HttpHeaders headers,\n\t\t\tbyte @Nullable [] responseBody, @Nullable Charset responseCharset) {\n\n\t\tthis(message, HttpStatusCode.valueOf(statusCode), statusText, headers, responseBody, responseCharset);\n\t}\n\n\t/**\n\t * Construct a new instance of with the given response data.\n\t * @param statusCode the raw status code value\n\t * @param statusText the status text\n\t * @param headers the response headers (may be {@code null})\n\t * @param responseBody the response body content (may be {@code null})\n\t * @param responseCharset the response body charset (may be {@code null})\n\t * @since 6.0\n\t */\n\tpublic RestClientResponseException(\n\t\t\tString message, HttpStatusCode statusCode, String statusText, @Nullable HttpHeaders headers,\n\t\t\tbyte @Nullable [] responseBody, @Nullable Charset responseCharset) {\n\n\t\tsuper(message);\n\t\tthis.statusCode = statusCode;\n\t\tthis.statusText = statusText;\n\t\tthis.responseHeaders = copyHeaders(headers);\n\t\tthis.responseBody = (responseBody != null ? responseBody : new byte[0]);\n\t\tthis.responseCharset = (responseCharset != null ? responseCharset.name() : null);\n\t}\n\n\t/**\n\t * Copies the given headers, because the backing map might not be\n\t * serializable.\n\t */\n\tprivate static @Nullable HttpHeaders copyHeaders(@Nullable HttpHeaders headers) {\n\t\tif (headers != null) {\n\t\t\tMultiValueMap<String, String> result =\n\t\t\t\t\tCollectionUtils.toMultiValueMap(new LinkedCaseInsensitiveMap<>(headers.size(), Locale.ROOT));\n\t\t\theaders.forEach((name, values) -> values.forEach(value -> result.add(name, value)));\n\t\t\treturn HttpHeaders.readOnlyHttpHeaders(result);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * Return the HTTP status code.\n\t * @since 6.0\n\t */\n\tpublic HttpStatusCode getStatusCode() {\n\t\treturn this.statusCode;\n\t}\n\n\t/**\n\t * Return the HTTP status text.\n\t */\n\tpublic String getStatusText() {\n\t\treturn this.statusText;\n\t}\n\n\t/**\n\t * Return the HTTP response headers.\n\t */\n\tpublic @Nullable HttpHeaders getResponseHeaders() {\n\t\treturn this.responseHeaders;\n\t}\n\n\t/**\n\t * Return the response body as a byte array.\n\t */\n\tpublic byte[] getResponseBodyAsByteArray() {\n\t\treturn this.responseBody;\n\t}\n\n\t/**\n\t * Return the response body converted to String. The charset used is that\n\t * of the response \"Content-Type\" or otherwise {@code \"UTF-8\"}.\n\t */\n\tpublic String getResponseBodyAsString() {\n\t\treturn getResponseBodyAsString(DEFAULT_CHARSET);\n\t}\n\n\t/**\n\t * Return the response body converted to String. The charset used is that\n\t * of the response \"Content-Type\" or otherwise the one given.\n\t * @param fallbackCharset the charset to use on if the response doesn't specify.\n\t * @since 5.1.11\n\t */\n\tpublic String getResponseBodyAsString(Charset fallbackCharset) {\n\t\tif (this.responseCharset == null) {\n\t\t\treturn new String(this.responseBody, fallbackCharset);\n\t\t}\n\t\ttry {\n\t\t\treturn new String(this.responseBody, this.responseCharset);\n\t\t}\n\t\tcatch (UnsupportedEncodingException ex) {\n\t\t\t// should not occur\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t}\n\n\t/**\n\t * Convert the error response content to the specified type.\n\t * @param targetType the type to convert to\n\t * @param <E> the expected target type\n\t * @return the converted object, or {@code null} if there is no content\n\t * @since 6.0\n\t */\n\tpublic <E> @Nullable E getResponseBodyAs(Class<E> targetType) {\n\t\treturn getResponseBodyAs(ResolvableType.forClass(targetType));\n\t}\n\n\t/**\n\t * Variant of {@link #getResponseBodyAs(Class)} with\n\t * {@link ParameterizedTypeReference}.\n\t * @since 6.0\n\t */\n\tpublic <E> @Nullable E getResponseBodyAs(ParameterizedTypeReference<E> targetType) {\n\t\treturn getResponseBodyAs(ResolvableType.forType(targetType.getType()));\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate <E> @Nullable E getResponseBodyAs(ResolvableType targetType) {\n\t\tAssert.state(this.bodyConvertFunction != null, \"Function to convert body not set\");\n\t\treturn (E) this.bodyConvertFunction.apply(targetType);\n\t}\n\n\t/**\n\t * Provide a function to use to decode the response error content\n\t * via {@link #getResponseBodyAs(Class)}.\n\t * @param bodyConvertFunction the function to use\n\t * @since 6.0\n\t */\n\tpublic void setBodyConvertFunction(Function<ResolvableType, ? extends @Nullable Object> bodyConvertFunction) {\n\t\tthis.bodyConvertFunction = bodyConvertFunction;\n\t}\n\n}"
  },
  "org.springframework.web.client.RestClientResponseException#getResponseBodyAs(targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #getResponseBodyAs(Class)} with\n\t * {@link ParameterizedTypeReference}.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "E",
    "signature": "public E getResponseBodyAs(ParameterizedTypeReference<E> targetType)",
    "source_code": "\tpublic <E> @Nullable E getResponseBodyAs(ParameterizedTypeReference<E> targetType) {\n\t\treturn getResponseBodyAs(ResolvableType.forType(targetType.getType()));\n\t}"
  },
  "org.springframework.web.client.RestClientResponseException#getResponseBodyAsByteArray()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the response body as a byte array.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "byte[]",
    "signature": "public byte[] getResponseBodyAsByteArray()",
    "source_code": "\tpublic byte[] getResponseBodyAsByteArray() {\n\t\treturn this.responseBody;\n\t}"
  },
  "org.springframework.web.client.RestClientResponseException#getResponseBodyAsString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the response body converted to String. The charset used is that\n\t * of the response \"Content-Type\" or otherwise {@code \"UTF-8\"}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "String",
    "signature": "public String getResponseBodyAsString()",
    "source_code": "\tpublic String getResponseBodyAsString() {\n\t\treturn getResponseBodyAsString(DEFAULT_CHARSET);\n\t}"
  },
  "org.springframework.web.client.RestClientResponseException#getResponseBodyAsString(fallbackCharset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the response body converted to String. The charset used is that\n\t * of the response \"Content-Type\" or otherwise the one given.\n\t * @param fallbackCharset the charset to use on if the response doesn't specify.\n\t * @since 5.1.11\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fallbackCharset"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "String",
    "signature": "public String getResponseBodyAsString(Charset fallbackCharset)",
    "source_code": "\tpublic String getResponseBodyAsString(Charset fallbackCharset) {\n\t\tif (this.responseCharset == null) {\n\t\t\treturn new String(this.responseBody, fallbackCharset);\n\t\t}\n\t\ttry {\n\t\t\treturn new String(this.responseBody, this.responseCharset);\n\t\t}\n\t\tcatch (UnsupportedEncodingException ex) {\n\t\t\t// should not occur\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.client.RestClientResponseException#getResponseHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HTTP response headers.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getResponseHeaders()",
    "source_code": "\tpublic @Nullable HttpHeaders getResponseHeaders() {\n\t\treturn this.responseHeaders;\n\t}"
  },
  "org.springframework.web.client.RestClientResponseException#getStatusCode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HTTP status code.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "HttpStatusCode",
    "signature": "public HttpStatusCode getStatusCode()",
    "source_code": "\tpublic HttpStatusCode getStatusCode() {\n\t\treturn this.statusCode;\n\t}"
  },
  "org.springframework.web.client.RestClientResponseException#getStatusText()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HTTP status text.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "String",
    "signature": "public String getStatusText()",
    "source_code": "\tpublic String getStatusText() {\n\t\treturn this.statusText;\n\t}"
  },
  "org.springframework.web.client.RestClientResponseException#setBodyConvertFunction(Function<ResolvableType,bodyConvertFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a function to use to decode the response error content\n\t * via {@link #getResponseBodyAs(Class)}.\n\t * @param bodyConvertFunction the function to use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ResolvableType",
      "bodyConvertFunction"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void setBodyConvertFunction(Function<ResolvableType, ? extends @Nullable Object> bodyConvertFunction)",
    "source_code": "\tpublic void setBodyConvertFunction(Function<ResolvableType, ? extends @Nullable Object> bodyConvertFunction) {\n\t\tthis.bodyConvertFunction = bodyConvertFunction;\n\t}"
  },
  "org.springframework.web.client.RestOperations": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Interface specifying a basic set of RESTful operations.\n *\n * <p>Implemented by {@link RestTemplate}. Not often used directly, but a useful\n * option to enhance testability, as it can easily be mocked or stubbed.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @since 3.0\n * @see RestTemplate\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public interface RestOperations",
    "source_code": "public interface RestOperations {\n\n\t// GET\n\n\t/**\n\t * Retrieve a representation by doing a GET on the specified URL.\n\t * The response (if any) is converted and returned.\n\t * <p>URI Template variables are expanded using the given URI variables, if any.\n\t * @param url the URL\n\t * @param responseType the type of the return value\n\t * @param uriVariables the variables to expand the template\n\t * @return the converted object\n\t */\n\t<T> @Nullable T getForObject(String url, Class<T> responseType, @Nullable Object... uriVariables) throws RestClientException;\n\n\t/**\n\t * Retrieve a representation by doing a GET on the URI template.\n\t * The response (if any) is converted and returned.\n\t * <p>URI Template variables are expanded using the given map.\n\t * @param url the URL\n\t * @param responseType the type of the return value\n\t * @param uriVariables the map containing variables for the URI template\n\t * @return the converted object\n\t */\n\t<T> @Nullable T getForObject(String url, Class<T> responseType, Map<String, ? extends @Nullable Object> uriVariables) throws RestClientException;\n\n\t/**\n\t * Retrieve a representation by doing a GET on the URL.\n\t * The response (if any) is converted and returned.\n\t * @param url the URL\n\t * @param responseType the type of the return value\n\t * @return the converted object\n\t */\n\t<T> @Nullable T getForObject(URI url, Class<T> responseType) throws RestClientException;\n\n\t/**\n\t * Retrieve an entity by doing a GET on the specified URL.\n\t * The response is converted and stored in a {@link ResponseEntity}.\n\t * <p>URI Template variables are expanded using the given URI variables, if any.\n\t * @param url the URL\n\t * @param responseType the type of the return value\n\t * @param uriVariables the variables to expand the template\n\t * @return the entity\n\t * @since 3.0.2\n\t */\n\t<T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, @Nullable Object... uriVariables)\n\t\t\tthrows RestClientException;\n\n\t/**\n\t * Retrieve a representation by doing a GET on the URI template.\n\t * The response is converted and stored in a {@link ResponseEntity}.\n\t * <p>URI Template variables are expanded using the given map.\n\t * @param url the URL\n\t * @param responseType the type of the return value\n\t * @param uriVariables the map containing variables for the URI template\n\t * @return the converted object\n\t * @since 3.0.2\n\t */\n\t<T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Map<String, ? extends @Nullable Object> uriVariables)\n\t\t\tthrows RestClientException;\n\n\t/**\n\t * Retrieve a representation by doing a GET on the URL.\n\t * The response is converted and stored in a {@link ResponseEntity}.\n\t * @param url the URL\n\t * @param responseType the type of the return value\n\t * @return the converted object\n\t * @since 3.0.2\n\t */\n\t<T> ResponseEntity<T> getForEntity(URI url, Class<T> responseType) throws RestClientException;\n\n\n\t// HEAD\n\n\t/**\n\t * Retrieve all headers of the resource specified by the URI template.\n\t * <p>URI Template variables are expanded using the given URI variables, if any.\n\t * @param url the URL\n\t * @param uriVariables the variables to expand the template\n\t * @return all HTTP headers of that resource\n\t */\n\tHttpHeaders headForHeaders(String url, @Nullable Object... uriVariables) throws RestClientException;\n\n\t/**\n\t * Retrieve all headers of the resource specified by the URI template.\n\t * <p>URI Template variables are expanded using the given map.\n\t * @param url the URL\n\t * @param uriVariables the map containing variables for the URI template\n\t * @return all HTTP headers of that resource\n\t */\n\tHttpHeaders headForHeaders(String url, Map<String, ? extends @Nullable Object> uriVariables) throws RestClientException;\n\n\t/**\n\t * Retrieve all headers of the resource specified by the URL.\n\t * @param url the URL\n\t * @return all HTTP headers of that resource\n\t */\n\tHttpHeaders headForHeaders(URI url) throws RestClientException;\n\n\n\t// POST\n\n\t/**\n\t * Create a new resource by POSTing the given object to the URI template, and return the value of\n\t * the {@code Location} header. This header typically indicates where the new resource is stored.\n\t * <p>URI Template variables are expanded using the given URI variables, if any.\n\t * <p>The {@code request} parameter can be a {@link HttpEntity} in order to\n\t * add additional HTTP headers to the request.\n\t * <p>The body of the entity, or {@code request} itself, can be a\n\t * {@link org.springframework.util.MultiValueMap MultiValueMap} to create a multipart request.\n\t * The values in the {@code MultiValueMap} can be any Object representing the body of the part,\n\t * or an {@link org.springframework.http.HttpEntity HttpEntity} representing a part with body\n\t * and headers.\n\t * @param url the URL\n\t * @param request the Object to be POSTed (may be {@code null})\n\t * @param uriVariables the variables to expand the template\n\t * @return the value for the {@code Location} header\n\t * @see HttpEntity\n\t */\n\t@Nullable URI postForLocation(String url, @Nullable Object request, @Nullable Object... uriVariables) throws RestClientException;\n\n\t/**\n\t * Create a new resource by POSTing the given object to the URI template, and return the value of\n\t * the {@code Location} header. This header typically indicates where the new resource is stored.\n\t * <p>URI Template variables are expanded using the given map.\n\t * <p>The {@code request} parameter can be a {@link HttpEntity} in order to\n\t * add additional HTTP headers to the request\n\t * <p>The body of the entity, or {@code request} itself, can be a\n\t * {@link org.springframework.util.MultiValueMap MultiValueMap} to create a multipart request.\n\t * The values in the {@code MultiValueMap} can be any Object representing the body of the part,\n\t * or an {@link org.springframework.http.HttpEntity HttpEntity} representing a part with body\n\t * and headers.\n\t * @param url the URL\n\t * @param request the Object to be POSTed (may be {@code null})\n\t * @param uriVariables the variables to expand the template\n\t * @return the value for the {@code Location} header\n\t * @see HttpEntity\n\t */\n\t@Nullable URI postForLocation(String url, @Nullable Object request, Map<String, ? extends @Nullable Object> uriVariables)\n\t\t\tthrows RestClientException;\n\n\t/**\n\t * Create a new resource by POSTing the given object to the URL, and return the value of the\n\t * {@code Location} header. This header typically indicates where the new resource is stored.\n\t * <p>The {@code request} parameter can be a {@link HttpEntity} in order to\n\t * add additional HTTP headers to the request.\n\t * <p>The body of the entity, or {@code request} itself, can be a\n\t * {@link org.springframework.util.MultiValueMap MultiValueMap} to create a multipart request.\n\t * The values in the {@code MultiValueMap} can be any Object representing the body of the part,\n\t * or an {@link org.springframework.http.HttpEntity HttpEntity} representing a part with body\n\t * and headers.\n\t * @param url the URL\n\t * @param request the Object to be POSTed (may be {@code null})\n\t * @return the value for the {@code Location} header\n\t * @see HttpEntity\n\t */\n\t@Nullable URI postForLocation(URI url, @Nullable Object request) throws RestClientException;\n\n\t/**\n\t * Create a new resource by POSTing the given object to the URI template,\n\t * and return the representation found in the response.\n\t * <p>URI Template variables are expanded using the given URI variables, if any.\n\t * <p>The {@code request} parameter can be a {@link HttpEntity} in order to\n\t * add additional HTTP headers to the request.\n\t * <p>The body of the entity, or {@code request} itself, can be a\n\t * {@link org.springframework.util.MultiValueMap MultiValueMap} to create a multipart request.\n\t * The values in the {@code MultiValueMap} can be any Object representing the body of the part,\n\t * or an {@link org.springframework.http.HttpEntity HttpEntity} representing a part with body\n\t * and headers.\n\t * @param url the URL\n\t * @param request the Object to be POSTed (may be {@code null})\n\t * @param responseType the type of the return value\n\t * @param uriVariables the variables to expand the template\n\t * @return the converted object\n\t * @see HttpEntity\n\t */\n\t<T> @Nullable T postForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\t@Nullable Object... uriVariables) throws RestClientException;\n\n\t/**\n\t * Create a new resource by POSTing the given object to the URI template,\n\t * and return the representation found in the response.\n\t * <p>URI Template variables are expanded using the given map.\n\t * <p>The {@code request} parameter can be a {@link HttpEntity} in order to\n\t * add additional HTTP headers to the request.\n\t * <p>The body of the entity, or {@code request} itself, can be a\n\t * {@link org.springframework.util.MultiValueMap MultiValueMap} to create a multipart request.\n\t * The values in the {@code MultiValueMap} can be any Object representing the body of the part,\n\t * or an {@link org.springframework.http.HttpEntity HttpEntity} representing a part with body\n\t * and headers.\n\t * @param url the URL\n\t * @param request the Object to be POSTed (may be {@code null})\n\t * @param responseType the type of the return value\n\t * @param uriVariables the variables to expand the template\n\t * @return the converted object\n\t * @see HttpEntity\n\t */\n\t<T> @Nullable T postForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tMap<String, ? extends @Nullable Object> uriVariables) throws RestClientException;\n\n\t/**\n\t * Create a new resource by POSTing the given object to the URL,\n\t * and return the representation found in the response.\n\t * <p>The {@code request} parameter can be a {@link HttpEntity} in order to\n\t * add additional HTTP headers to the request.\n\t * <p>The body of the entity, or {@code request} itself, can be a\n\t * {@link org.springframework.util.MultiValueMap MultiValueMap} to create a multipart request.\n\t * The values in the {@code MultiValueMap} can be any Object representing the body of the part,\n\t * or an {@link org.springframework.http.HttpEntity HttpEntity} representing a part with body\n\t * and headers.\n\t * @param url the URL\n\t * @param request the Object to be POSTed (may be {@code null})\n\t * @param responseType the type of the return value\n\t * @return the converted object\n\t * @see HttpEntity\n\t */\n\t<T> @Nullable T postForObject(URI url, @Nullable Object request, Class<T> responseType) throws RestClientException;\n\n\t/**\n\t * Create a new resource by POSTing the given object to the URI template,\n\t * and return the response as {@link ResponseEntity}.\n\t * <p>URI Template variables are expanded using the given URI variables, if any.\n\t * <p>The {@code request} parameter can be a {@link HttpEntity} in order to\n\t * add additional HTTP headers to the request.\n\t * <p>The body of the entity, or {@code request} itself, can be a\n\t * {@link org.springframework.util.MultiValueMap MultiValueMap} to create a multipart request.\n\t * The values in the {@code MultiValueMap} can be any Object representing the body of the part,\n\t * or an {@link org.springframework.http.HttpEntity HttpEntity} representing a part with body\n\t * and headers.\n\t * @param url the URL\n\t * @param request the Object to be POSTed (may be {@code null})\n\t * @param uriVariables the variables to expand the template\n\t * @return the converted object\n\t * @since 3.0.2\n\t * @see HttpEntity\n\t */\n\t<T> ResponseEntity<T> postForEntity(String url, @Nullable Object request, Class<T> responseType,\n\t\t\t@Nullable Object... uriVariables) throws RestClientException;\n\n\t/**\n\t * Create a new resource by POSTing the given object to the URI template,\n\t * and return the response as {@link HttpEntity}.\n\t * <p>URI Template variables are expanded using the given map.\n\t * <p>The {@code request} parameter can be a {@link HttpEntity} in order to\n\t * add additional HTTP headers to the request.\n\t * <p>The body of the entity, or {@code request} itself, can be a\n\t * {@link org.springframework.util.MultiValueMap MultiValueMap} to create a multipart request.\n\t * The values in the {@code MultiValueMap} can be any Object representing the body of the part,\n\t * or an {@link org.springframework.http.HttpEntity HttpEntity} representing a part with body\n\t * and headers.\n\t * @param url the URL\n\t * @param request the Object to be POSTed (may be {@code null})\n\t * @param uriVariables the variables to expand the template\n\t * @return the converted object\n\t * @since 3.0.2\n\t * @see HttpEntity\n\t */\n\t<T> ResponseEntity<T> postForEntity(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tMap<String, ? extends @Nullable Object> uriVariables) throws RestClientException;\n\n\t/**\n\t * Create a new resource by POSTing the given object to the URL,\n\t * and return the response as {@link ResponseEntity}.\n\t * <p>The {@code request} parameter can be a {@link HttpEntity} in order to\n\t * add additional HTTP headers to the request.\n\t * <p>The body of the entity, or {@code request} itself, can be a\n\t * {@link org.springframework.util.MultiValueMap MultiValueMap} to create a multipart request.\n\t * The values in the {@code MultiValueMap} can be any Object representing the body of the part,\n\t * or an {@link org.springframework.http.HttpEntity HttpEntity} representing a part with body\n\t * and headers.\n\t * @param url the URL\n\t * @param request the Object to be POSTed (may be {@code null})\n\t * @return the converted object\n\t * @since 3.0.2\n\t * @see HttpEntity\n\t */\n\t<T> ResponseEntity<T> postForEntity(URI url, @Nullable Object request, Class<T> responseType)\n\t\t\tthrows RestClientException;\n\n\n\t// PUT\n\n\t/**\n\t * Create or update a resource by PUTting the given object to the URI.\n\t * <p>URI Template variables are expanded using the given URI variables, if any.\n\t * <p>The {@code request} parameter can be a {@link HttpEntity} in order to\n\t * add additional HTTP headers to the request.\n\t * @param url the URL\n\t * @param request the Object to be PUT (may be {@code null})\n\t * @param uriVariables the variables to expand the template\n\t * @see HttpEntity\n\t */\n\tvoid put(String url, @Nullable Object request, @Nullable Object... uriVariables) throws RestClientException;\n\n\t/**\n\t * Creates a new resource by PUTting the given object to URI template.\n\t * <p>URI Template variables are expanded using the given map.\n\t * <p>The {@code request} parameter can be a {@link HttpEntity} in order to\n\t * add additional HTTP headers to the request.\n\t * @param url the URL\n\t * @param request the Object to be PUT (may be {@code null})\n\t * @param uriVariables the variables to expand the template\n\t * @see HttpEntity\n\t */\n\tvoid put(String url, @Nullable Object request, Map<String, ? extends @Nullable Object> uriVariables) throws RestClientException;\n\n\t/**\n\t * Creates a new resource by PUTting the given object to URL.\n\t * <p>The {@code request} parameter can be a {@link HttpEntity} in order to\n\t * add additional HTTP headers to the request.\n\t * @param url the URL\n\t * @param request the Object to be PUT (may be {@code null})\n\t * @see HttpEntity\n\t */\n\tvoid put(URI url, @Nullable Object request) throws RestClientException;\n\n\n\t// PATCH\n\n\t/**\n\t * Update a resource by PATCHing the given object to the URI template,\n\t * and return the representation found in the response.\n\t * <p>URI Template variables are expanded using the given URI variables, if any.\n\t * <p>The {@code request} parameter can be a {@link HttpEntity} in order to\n\t * add additional HTTP headers to the request.\n\t * <p><b>NOTE: The standard JDK HTTP library does not support HTTP PATCH.\n\t * You need to use, for example, the Apache HttpComponents request factory.</b>\n\t * @param url the URL\n\t * @param request the object to be PATCHed (may be {@code null})\n\t * @param responseType the type of the return value\n\t * @param uriVariables the variables to expand the template\n\t * @return the converted object\n\t * @since 4.3.5\n\t * @see HttpEntity\n\t * @see RestTemplate#setRequestFactory\n\t * @see org.springframework.http.client.HttpComponentsClientHttpRequestFactory\n\t */\n\t<T> @Nullable T patchForObject(String url, @Nullable Object request, Class<T> responseType, @Nullable Object... uriVariables)\n\t\t\tthrows RestClientException;\n\n\t/**\n\t * Update a resource by PATCHing the given object to the URI template,\n\t * and return the representation found in the response.\n\t * <p>URI Template variables are expanded using the given map.\n\t * <p>The {@code request} parameter can be a {@link HttpEntity} in order to\n\t * add additional HTTP headers to the request.\n\t * <p><b>NOTE: The standard JDK HTTP library does not support HTTP PATCH.\n\t * You need to use, for example, the Apache HttpComponents request factory.</b>\n\t * @param url the URL\n\t * @param request the object to be PATCHed (may be {@code null})\n\t * @param responseType the type of the return value\n\t * @param uriVariables the variables to expand the template\n\t * @return the converted object\n\t * @since 4.3.5\n\t * @see HttpEntity\n\t * @see RestTemplate#setRequestFactory\n\t * @see org.springframework.http.client.HttpComponentsClientHttpRequestFactory\n\t */\n\t<T> @Nullable T patchForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tMap<String, ? extends @Nullable Object> uriVariables) throws RestClientException;\n\n\t/**\n\t * Update a resource by PATCHing the given object to the URL,\n\t * and return the representation found in the response.\n\t * <p>The {@code request} parameter can be a {@link HttpEntity} in order to\n\t * add additional HTTP headers to the request.\n\t * <p><b>NOTE: The standard JDK HTTP library does not support HTTP PATCH.\n\t * You need to use, for example, the Apache HttpComponents request factory.</b>\n\t * @param url the URL\n\t * @param request the object to be PATCHed (may be {@code null})\n\t * @param responseType the type of the return value\n\t * @return the converted object\n\t * @since 4.3.5\n\t * @see HttpEntity\n\t * @see RestTemplate#setRequestFactory\n\t * @see org.springframework.http.client.HttpComponentsClientHttpRequestFactory\n\t */\n\t<T> @Nullable T patchForObject(URI url, @Nullable Object request, Class<T> responseType)\n\t\t\tthrows RestClientException;\n\n\n\n\t// DELETE\n\n\t/**\n\t * Delete the resources at the specified URI.\n\t * <p>URI Template variables are expanded using the given URI variables, if any.\n\t * @param url the URL\n\t * @param uriVariables the variables to expand in the template\n\t */\n\tvoid delete(String url, @Nullable Object... uriVariables) throws RestClientException;\n\n\t/**\n\t * Delete the resources at the specified URI.\n\t * <p>URI Template variables are expanded using the given map.\n\t * @param url the URL\n\t * @param uriVariables the variables to expand the template\n\t */\n\tvoid delete(String url, Map<String, ? extends @Nullable Object> uriVariables) throws RestClientException;\n\n\t/**\n\t * Delete the resources at the specified URL.\n\t * @param url the URL\n\t */\n\tvoid delete(URI url) throws RestClientException;\n\n\n\t// OPTIONS\n\n\t/**\n\t * Return the value of the {@code Allow} header for the given URI.\n\t * <p>URI Template variables are expanded using the given URI variables, if any.\n\t * @param url the URL\n\t * @param uriVariables the variables to expand in the template\n\t * @return the value of the {@code Allow} header\n\t */\n\tSet<HttpMethod> optionsForAllow(String url, @Nullable Object... uriVariables) throws RestClientException;\n\n\t/**\n\t * Return the value of the {@code Allow} header for the given URI.\n\t * <p>URI Template variables are expanded using the given map.\n\t * @param url the URL\n\t * @param uriVariables the variables to expand in the template\n\t * @return the value of the {@code Allow} header\n\t */\n\tSet<HttpMethod> optionsForAllow(String url, Map<String, ? extends @Nullable Object> uriVariables) throws RestClientException;\n\n\t/**\n\t * Return the value of the {@code Allow} header for the given URL.\n\t * @param url the URL\n\t * @return the value of the {@code Allow} header\n\t */\n\tSet<HttpMethod> optionsForAllow(URI url) throws RestClientException;\n\n\n\t// exchange\n\n\t/**\n\t * Execute the HTTP method to the given URI template, writing the given request entity to the request,\n\t * and return the response as {@link ResponseEntity}.\n\t * <p>URI Template variables are expanded using the given URI variables, if any.\n\t * @param url the URL\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param requestEntity the entity (headers and/or body) to write to the request\n\t * may be {@code null})\n\t * @param responseType the type to convert the response to, or {@code Void.class} for no body\n\t * @param uriVariables the variables to expand in the template\n\t * @return the response as entity\n\t * @since 3.0.2\n\t */\n\t<T> ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tClass<T> responseType, @Nullable Object... uriVariables) throws RestClientException;\n\n\t/**\n\t * Execute the HTTP method to the given URI template, writing the given request entity to the request,\n\t * and return the response as {@link ResponseEntity}.\n\t * <p>URI Template variables are expanded using the given URI variables, if any.\n\t * @param url the URL\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param requestEntity the entity (headers and/or body) to write to the request\n\t * (may be {@code null})\n\t * @param responseType the type to convert the response to, or {@code Void.class} for no body\n\t * @param uriVariables the variables to expand in the template\n\t * @return the response as entity\n\t * @since 3.0.2\n\t */\n\t<T> ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tClass<T> responseType, Map<String, ? extends @Nullable Object> uriVariables) throws RestClientException;\n\n\t/**\n\t * Execute the HTTP method to the given URI template, writing the given request entity to the request,\n\t * and return the response as {@link ResponseEntity}.\n\t * @param url the URL\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param requestEntity the entity (headers and/or body) to write to the request\n\t * (may be {@code null})\n\t * @param responseType the type to convert the response to, or {@code Void.class} for no body\n\t * @return the response as entity\n\t * @since 3.0.2\n\t */\n\t<T> ResponseEntity<T> exchange(URI url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tClass<T> responseType) throws RestClientException;\n\n\t/**\n\t * Execute the HTTP method to the given URI template, writing the given\n\t * request entity to the request, and return the response as {@link ResponseEntity}.\n\t * The given {@link ParameterizedTypeReference} is used to pass generic type information:\n\t * <pre class=\"code\">\n\t * ParameterizedTypeReference&lt;List&lt;MyBean&gt;&gt; myBean =\n\t *     new ParameterizedTypeReference&lt;List&lt;MyBean&gt;&gt;() {};\n\t *\n\t * ResponseEntity&lt;List&lt;MyBean&gt;&gt; response =\n\t *     template.exchange(&quot;https://example.com&quot;,HttpMethod.GET, null, myBean);\n\t * </pre>\n\t * @param url the URL\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param requestEntity the entity (headers and/or body) to write to the\n\t * request (may be {@code null})\n\t * @param responseType the type to convert the response to, or {@code Void.class} for no body\n\t * @param uriVariables the variables to expand in the template\n\t * @return the response as entity\n\t * @since 3.2\n\t */\n\t<T> ResponseEntity<T> exchange(String url,HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType, @Nullable Object... uriVariables) throws RestClientException;\n\n\t/**\n\t * Execute the HTTP method to the given URI template, writing the given\n\t * request entity to the request, and return the response as {@link ResponseEntity}.\n\t * The given {@link ParameterizedTypeReference} is used to pass generic type information:\n\t * <pre class=\"code\">\n\t * ParameterizedTypeReference&lt;List&lt;MyBean&gt;&gt; myBean =\n\t *     new ParameterizedTypeReference&lt;List&lt;MyBean&gt;&gt;() {};\n\t *\n\t * ResponseEntity&lt;List&lt;MyBean&gt;&gt; response =\n\t *     template.exchange(&quot;https://example.com&quot;,HttpMethod.GET, null, myBean);\n\t * </pre>\n\t * @param url the URL\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param requestEntity the entity (headers and/or body) to write to the request\n\t * (may be {@code null})\n\t * @param responseType the type to convert the response to, or {@code Void.class} for no body\n\t * @param uriVariables the variables to expand in the template\n\t * @return the response as entity\n\t * @since 3.2\n\t */\n\t<T> ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType, Map<String, ? extends @Nullable Object> uriVariables) throws RestClientException;\n\n\t/**\n\t * Execute the HTTP method to the given URI template, writing the given\n\t * request entity to the request, and return the response as {@link ResponseEntity}.\n\t * The given {@link ParameterizedTypeReference} is used to pass generic type information:\n\t * <pre class=\"code\">\n\t * ParameterizedTypeReference&lt;List&lt;MyBean&gt;&gt; myBean =\n\t *     new ParameterizedTypeReference&lt;List&lt;MyBean&gt;&gt;() {};\n\t *\n\t * ResponseEntity&lt;List&lt;MyBean&gt;&gt; response =\n\t *     template.exchange(&quot;https://example.com&quot;,HttpMethod.GET, null, myBean);\n\t * </pre>\n\t * @param url the URL\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param requestEntity the entity (headers and/or body) to write to the request\n\t * (may be {@code null})\n\t * @param responseType the type to convert the response to, or {@code Void.class} for no body\n\t * @return the response as entity\n\t * @since 3.2\n\t */\n\t<T> ResponseEntity<T> exchange(URI url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType) throws RestClientException;\n\n\t/**\n\t * Execute the request specified in the given {@link RequestEntity} and return\n\t * the response as {@link ResponseEntity}. Typically used in combination\n\t * with the static builder methods on {@code RequestEntity}, for instance:\n\t * <pre class=\"code\">\n\t * MyRequest body = ...\n\t * RequestEntity request = RequestEntity\n\t *     .post(URI.create(&quot;https://example.com/foo&quot;))\n\t *     .accept(MediaType.APPLICATION_JSON)\n\t *     .body(body);\n\t * ResponseEntity&lt;MyResponse&gt; response = template.exchange(request, MyResponse.class);\n\t * </pre>\n\t * @param requestEntity the entity to write to the request\n\t * @param responseType the type to convert the response to, or {@code Void.class} for no body\n\t * @return the response as entity\n\t * @since 4.1\n\t */\n\t<T> ResponseEntity<T> exchange(RequestEntity<?> requestEntity, Class<T> responseType)\n\t\t\tthrows RestClientException;\n\n\t/**\n\t * Execute the request specified in the given {@link RequestEntity} and return\n\t * the response as {@link ResponseEntity}. The given\n\t * {@link ParameterizedTypeReference} is used to pass generic type information:\n\t * <pre class=\"code\">\n\t * MyRequest body = ...\n\t * RequestEntity request = RequestEntity\n\t *     .post(URI.create(&quot;https://example.com/foo&quot;))\n\t *     .accept(MediaType.APPLICATION_JSON)\n\t *     .body(body);\n\t * ParameterizedTypeReference&lt;List&lt;MyResponse&gt;&gt; myBean =\n\t *     new ParameterizedTypeReference&lt;List&lt;MyResponse&gt;&gt;() {};\n\t * ResponseEntity&lt;List&lt;MyResponse&gt;&gt; response = template.exchange(request, myBean);\n\t * </pre>\n\t * @param requestEntity the entity to write to the request\n\t * @param responseType the type to convert the response to, or {@code Void.class} for no body\n\t * @return the response as entity\n\t * @since 4.1\n\t */\n\t<T> ResponseEntity<T> exchange(RequestEntity<?> requestEntity, ParameterizedTypeReference<T> responseType)\n\t\t\tthrows RestClientException;\n\n\n\t// General execution\n\n\t/**\n\t * Execute the HTTP method to the given URI template, preparing the request with the\n\t * {@link RequestCallback}, and reading the response with a {@link ResponseExtractor}.\n\t * <p>URI Template variables are expanded using the given URI variables, if any.\n\t * @param uriTemplate the URI template\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param requestCallback object that prepares the request\n\t * @param responseExtractor object that extracts the return value from the response\n\t * @param uriVariables the variables to expand in the template\n\t * @return an arbitrary object, as returned by the {@link ResponseExtractor}\n\t */\n\t<T> @Nullable T execute(String uriTemplate, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor, @Nullable Object... uriVariables)\n\t\t\tthrows RestClientException;\n\n\t/**\n\t * Execute the HTTP method to the given URI template, preparing the request with the\n\t * {@link RequestCallback}, and reading the response with a {@link ResponseExtractor}.\n\t * <p>URI Template variables are expanded using the given URI variables map.\n\t * @param uriTemplate the URI template\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param requestCallback object that prepares the request\n\t * @param responseExtractor object that extracts the return value from the response\n\t * @param uriVariables the variables to expand in the template\n\t * @return an arbitrary object, as returned by the {@link ResponseExtractor}\n\t */\n\t<T> @Nullable T execute(String uriTemplate, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor, Map<String, ? extends @Nullable Object> uriVariables)\n\t\t\tthrows RestClientException;\n\n\t/**\n\t * Execute the HTTP method to the given URL, preparing the request with the\n\t * {@link RequestCallback}, and reading the response with a {@link ResponseExtractor}.\n\t * @param url the URL\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param requestCallback object that prepares the request\n\t * @param responseExtractor object that extracts the return value from the response\n\t * @return an arbitrary object, as returned by the {@link ResponseExtractor}\n\t */\n\t<T> @Nullable T execute(URI url, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor) throws RestClientException;\n\n}"
  },
  "org.springframework.web.client.RestTemplate#doExecute(url,method,requestCallback,responseExtractor)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the given method on the provided URI.\n\t * <p>The {@link ClientHttpRequest} is processed using the {@link RequestCallback};\n\t * the response with the {@link ResponseExtractor}.\n\t * @param url the fully-expanded URL to connect to\n\t * @param method the HTTP method to execute (GET, POST, etc.)\n\t * @param requestCallback object that prepares the request (can be {@code null})\n\t * @param responseExtractor object that extracts the return value from the response (can be {@code null})\n\t * @return an arbitrary object, as returned by the {@link ResponseExtractor}\n\t * @deprecated in favor of {@link #doExecute(URI, String, HttpMethod, RequestCallback, ResponseExtractor)}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "url",
      "method",
      "requestCallback",
      "responseExtractor"
    ],
    "position": {
      "column": 1,
      "line": 857
    },
    "return": "T",
    "signature": "protected T doExecute(URI url, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor)",
    "source_code": "\tprotected <T> T doExecute(URI url, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback,"
  },
  "org.springframework.web.client.UnknownHttpStatusCodeException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Exception thrown when an unknown (or custom) HTTP status code is received.\n *\n * @author Rossen Stoyanchev\n * @since 3.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 31
    },
    "signature": "public class UnknownHttpStatusCodeException",
    "source_code": "public class UnknownHttpStatusCodeException extends RestClientResponseException {\n\n\tprivate static final long serialVersionUID = 7103980251635005491L;\n\n\n\t/**\n\t * Construct a new instance of {@code HttpStatusCodeException} based on a\n\t * status code, status text, and response body content.\n\t * @param rawStatusCode the raw status code value\n\t * @param statusText the status text\n\t * @param responseHeaders the response headers (may be {@code null})\n\t * @param responseBody the response body content (may be {@code null})\n\t * @param responseCharset the response body charset (may be {@code null})\n\t */\n\tpublic UnknownHttpStatusCodeException(int rawStatusCode, String statusText, @Nullable HttpHeaders responseHeaders,\n\t\t\tbyte @Nullable [] responseBody, @Nullable Charset responseCharset) {\n\n\t\tthis(\"Unknown status code [\" + rawStatusCode + \"]\" + \" \" + statusText,\n\t\t\t\trawStatusCode, statusText, responseHeaders, responseBody, responseCharset);\n\t}\n\n\t/**\n\t * Construct a new instance of {@code HttpStatusCodeException} based on a\n\t * status code, status text, and response body content.\n\t * @param rawStatusCode the raw status code value\n\t * @param statusText the status text\n\t * @param responseHeaders the response headers (may be {@code null})\n\t * @param responseBody the response body content (may be {@code null})\n\t * @param responseCharset the response body charset (may be {@code null})\n\t * @since 5.2.2\n\t */\n\tpublic UnknownHttpStatusCodeException(String message, int rawStatusCode, String statusText,\n\t\t\t@Nullable HttpHeaders responseHeaders, byte @Nullable [] responseBody, @Nullable Charset responseCharset) {\n\n\t\tsuper(message, rawStatusCode, statusText, responseHeaders, responseBody, responseCharset);\n\t}\n}"
  },
  "org.springframework.web.client.support.RestClientAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link HttpExchangeAdapter} that enables an {@link HttpServiceProxyFactory}\n * to use {@link RestClient} for request execution.\n *\n * <p>Use static factory methods in this class to create an\n * {@link HttpServiceProxyFactory} configured with the given {@link RestClient}.\n *\n * @author Olga Maciaszek-Sharma\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class RestClientAdapter",
    "source_code": "public final class RestClientAdapter implements HttpExchangeAdapter {\n\n\tprivate final RestClient restClient;\n\n\n\tprivate RestClientAdapter(RestClient restClient) {\n\t\tthis.restClient = restClient;\n\t}\n\n\n\t@Override\n\tpublic boolean supportsRequestAttributes() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void exchange(HttpRequestValues requestValues) {\n\t\tnewRequest(requestValues).retrieve().toBodilessEntity();\n\t}\n\n\t@Override\n\tpublic HttpHeaders exchangeForHeaders(HttpRequestValues values) {\n\t\treturn newRequest(values).retrieve().toBodilessEntity().getHeaders();\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T exchangeForBody(HttpRequestValues values, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(values).retrieve().body(bodyType);\n\t}\n\n\t@Override\n\tpublic ResponseEntity<Void> exchangeForBodilessEntity(HttpRequestValues values) {\n\t\treturn newRequest(values).retrieve().toBodilessEntity();\n\t}\n\n\t@Override\n\tpublic <T> ResponseEntity<T> exchangeForEntity(HttpRequestValues values, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(values).retrieve().toEntity(bodyType);\n\t}\n\n\tprivate RestClient.RequestBodySpec newRequest(HttpRequestValues values) {\n\n\t\tHttpMethod httpMethod = values.getHttpMethod();\n\t\tAssert.notNull(httpMethod, \"HttpMethod is required\");\n\n\t\tRestClient.RequestBodyUriSpec uriSpec = this.restClient.method(httpMethod);\n\n\t\tRestClient.RequestBodySpec bodySpec;\n\t\tif (values.getUri() != null) {\n\t\t\tbodySpec = uriSpec.uri(values.getUri());\n\t\t}\n\t\telse if (values.getUriTemplate() != null) {\n\t\t\tUriBuilderFactory uriBuilderFactory = values.getUriBuilderFactory();\n\t\t\tif (uriBuilderFactory != null) {\n\t\t\t\tURI uri = uriBuilderFactory.expand(values.getUriTemplate(), values.getUriVariables());\n\t\t\t\tbodySpec = uriSpec.uri(uri);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbodySpec = uriSpec.uri(values.getUriTemplate(), values.getUriVariables());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Neither full URL nor URI template\");\n\t\t}\n\n\t\tbodySpec.headers(headers -> headers.putAll(values.getHeaders()));\n\n\t\tif (!values.getCookies().isEmpty()) {\n\t\t\tList<String> cookies = new ArrayList<>();\n\t\t\tvalues.getCookies().forEach((name, cookieValues) -> cookieValues.forEach(value -> {\n\t\t\t\tHttpCookie cookie = new HttpCookie(name, value);\n\t\t\t\tcookies.add(cookie.toString());\n\t\t\t}));\n\t\t\tbodySpec.header(HttpHeaders.COOKIE, String.join(\"; \", cookies));\n\t\t}\n\n\t\tbodySpec.attributes(attributes -> attributes.putAll(values.getAttributes()));\n\n\t\tif (values.getBodyValue() != null) {\n\t\t\tbodySpec.body(values.getBodyValue());\n\t\t}\n\n\t\treturn bodySpec;\n\t}\n\n\n\t/**\n\t * Create a {@link RestClientAdapter} for the given {@link RestClient}.\n\t */\n\tpublic static RestClientAdapter create(RestClient restClient) {\n\t\treturn new RestClientAdapter(restClient);\n\t}\n\n}"
  },
  "org.springframework.web.client.support.RestClientAdapter#create(restClient)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RestClientAdapter} for the given {@link RestClient}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "restClient"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "RestClientAdapter",
    "signature": "public RestClientAdapter create(RestClient restClient)",
    "source_code": "\tpublic static RestClientAdapter create(RestClient restClient) {\n\t\treturn new RestClientAdapter(restClient);\n\t}"
  },
  "org.springframework.web.client.support.RestClientAdapter#exchange(requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void exchange(HttpRequestValues requestValues)",
    "source_code": "\tpublic void exchange(HttpRequestValues requestValues) {\n\t\tnewRequest(requestValues).retrieve().toBodilessEntity();\n\t}"
  },
  "org.springframework.web.client.support.RestClientAdapter#exchangeForBodilessEntity(values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "values"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "ResponseEntity<Void>",
    "signature": "public ResponseEntity<Void> exchangeForBodilessEntity(HttpRequestValues values)",
    "source_code": "\tpublic ResponseEntity<Void> exchangeForBodilessEntity(HttpRequestValues values) {\n\t\treturn newRequest(values).retrieve().toBodilessEntity();\n\t}"
  },
  "org.springframework.web.client.support.RestClientAdapter#exchangeForBody(values,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "values",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "T",
    "signature": "public T exchangeForBody(HttpRequestValues values, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> @Nullable T exchangeForBody(HttpRequestValues values, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(values).retrieve().body(bodyType);\n\t}"
  },
  "org.springframework.web.client.support.RestClientAdapter#exchangeForEntity(values,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "values",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> exchangeForEntity(HttpRequestValues values, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> ResponseEntity<T> exchangeForEntity(HttpRequestValues values, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(values).retrieve().toEntity(bodyType);\n\t}"
  },
  "org.springframework.web.client.support.RestClientAdapter#exchangeForHeaders(values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "values"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders exchangeForHeaders(HttpRequestValues values)",
    "source_code": "\tpublic HttpHeaders exchangeForHeaders(HttpRequestValues values) {\n\t\treturn newRequest(values).retrieve().toBodilessEntity().getHeaders();\n\t}"
  },
  "org.springframework.web.client.support.RestClientAdapter#supportsRequestAttributes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "boolean",
    "signature": "public boolean supportsRequestAttributes()",
    "source_code": "\tpublic boolean supportsRequestAttributes() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.client.support.RestTemplateAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link HttpExchangeAdapter} that enables an {@link HttpServiceProxyFactory}\n * to use {@link RestTemplate} for request execution.\n *\n * <p>Use static factory methods in this class to create an\n * {@link HttpServiceProxyFactory} configured with the given {@link RestTemplate}.\n *\n * @author Olga Maciaszek-Sharma\n * @author Brian Clozel\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class RestTemplateAdapter",
    "source_code": "public final class RestTemplateAdapter implements HttpExchangeAdapter {\n\n\tprivate final RestTemplate restTemplate;\n\n\n\tprivate RestTemplateAdapter(RestTemplate restTemplate) {\n\t\tthis.restTemplate = restTemplate;\n\t}\n\n\n\t@Override\n\tpublic boolean supportsRequestAttributes() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void exchange(HttpRequestValues values) {\n\t\tthis.restTemplate.exchange(newRequest(values), Void.class);\n\t}\n\n\t@Override\n\tpublic HttpHeaders exchangeForHeaders(HttpRequestValues values) {\n\t\treturn this.restTemplate.exchange(newRequest(values), Void.class).getHeaders();\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T exchangeForBody(HttpRequestValues values, ParameterizedTypeReference<T> bodyType) {\n\t\treturn this.restTemplate.exchange(newRequest(values), bodyType).getBody();\n\t}\n\n\t@Override\n\tpublic ResponseEntity<Void> exchangeForBodilessEntity(HttpRequestValues values) {\n\t\treturn this.restTemplate.exchange(newRequest(values), Void.class);\n\t}\n\n\t@Override\n\tpublic <T> ResponseEntity<T> exchangeForEntity(HttpRequestValues values, ParameterizedTypeReference<T> bodyType) {\n\t\treturn this.restTemplate.exchange(newRequest(values), bodyType);\n\t}\n\n\tprivate RequestEntity<?> newRequest(HttpRequestValues values) {\n\t\tHttpMethod httpMethod = values.getHttpMethod();\n\t\tAssert.notNull(httpMethod, \"HttpMethod is required\");\n\n\t\tRequestEntity.BodyBuilder builder;\n\n\t\tif (values.getUri() != null) {\n\t\t\tbuilder = RequestEntity.method(httpMethod, values.getUri());\n\t\t}\n\t\telse if (values.getUriTemplate() != null) {\n\t\t\tUriBuilderFactory uriBuilderFactory = values.getUriBuilderFactory();\n\t\t\tif (uriBuilderFactory != null) {\n\t\t\t\tURI expanded = uriBuilderFactory.expand(values.getUriTemplate(), values.getUriVariables());\n\t\t\t\tbuilder = RequestEntity.method(httpMethod, expanded);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuilder = RequestEntity.method(httpMethod, values.getUriTemplate(), values.getUriVariables());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Neither full URL nor URI template\");\n\t\t}\n\n\t\tbuilder.headers(values.getHeaders());\n\n\t\tif (!values.getCookies().isEmpty()) {\n\t\t\tList<String> cookies = new ArrayList<>();\n\t\t\tvalues.getCookies().forEach((name, cookieValues) -> cookieValues.forEach(value -> {\n\t\t\t\tHttpCookie cookie = new HttpCookie(name, value);\n\t\t\t\tcookies.add(cookie.toString());\n\t\t\t}));\n\t\t\tbuilder.header(HttpHeaders.COOKIE, String.join(\"; \", cookies));\n\t\t}\n\n\t\tif (values.getBodyValue() != null) {\n\t\t\treturn builder.body(values.getBodyValue());\n\t\t}\n\n\t\treturn builder.build();\n\t}\n\n\n\t/**\n\t * Create a {@link RestTemplateAdapter} for the given {@link RestTemplate}.\n\t */\n\tpublic static RestTemplateAdapter create(RestTemplate restTemplate) {\n\t\treturn new RestTemplateAdapter(restTemplate);\n\t}\n\n}"
  },
  "org.springframework.web.client.support.RestTemplateAdapter#create(restTemplate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RestTemplateAdapter} for the given {@link RestTemplate}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "restTemplate"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "RestTemplateAdapter",
    "signature": "public RestTemplateAdapter create(RestTemplate restTemplate)",
    "source_code": "\tpublic static RestTemplateAdapter create(RestTemplate restTemplate) {\n\t\treturn new RestTemplateAdapter(restTemplate);\n\t}"
  },
  "org.springframework.web.client.support.RestTemplateAdapter#exchange(values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "values"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void exchange(HttpRequestValues values)",
    "source_code": "\tpublic void exchange(HttpRequestValues values) {\n\t\tthis.restTemplate.exchange(newRequest(values), Void.class);\n\t}"
  },
  "org.springframework.web.client.support.RestTemplateAdapter#exchangeForBodilessEntity(values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "values"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "ResponseEntity<Void>",
    "signature": "public ResponseEntity<Void> exchangeForBodilessEntity(HttpRequestValues values)",
    "source_code": "\tpublic ResponseEntity<Void> exchangeForBodilessEntity(HttpRequestValues values) {\n\t\treturn this.restTemplate.exchange(newRequest(values), Void.class);\n\t}"
  },
  "org.springframework.web.client.support.RestTemplateAdapter#exchangeForBody(values,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "values",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "T",
    "signature": "public T exchangeForBody(HttpRequestValues values, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> @Nullable T exchangeForBody(HttpRequestValues values, ParameterizedTypeReference<T> bodyType) {\n\t\treturn this.restTemplate.exchange(newRequest(values), bodyType).getBody();\n\t}"
  },
  "org.springframework.web.client.support.RestTemplateAdapter#exchangeForEntity(values,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "values",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> exchangeForEntity(HttpRequestValues values, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> ResponseEntity<T> exchangeForEntity(HttpRequestValues values, ParameterizedTypeReference<T> bodyType) {\n\t\treturn this.restTemplate.exchange(newRequest(values), bodyType);\n\t}"
  },
  "org.springframework.web.client.support.RestTemplateAdapter#exchangeForHeaders(values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "values"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders exchangeForHeaders(HttpRequestValues values)",
    "source_code": "\tpublic HttpHeaders exchangeForHeaders(HttpRequestValues values) {\n\t\treturn this.restTemplate.exchange(newRequest(values), Void.class).getHeaders();\n\t}"
  },
  "org.springframework.web.client.support.RestTemplateAdapter#supportsRequestAttributes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "boolean",
    "signature": "public boolean supportsRequestAttributes()",
    "source_code": "\tpublic boolean supportsRequestAttributes() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.context.AbstractContextLoaderInitializer": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Convenient base class for {@link WebApplicationInitializer} implementations\n * that register a {@link ContextLoaderListener} in the servlet context.\n *\n * <p>The only method required to be implemented by subclasses is\n * {@link #createRootApplicationContext()}, which gets invoked from\n * {@link #registerContextLoaderListener(ServletContext)}.\n *\n * @author Arjen Poutsma\n * @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public class AbstractContextLoaderInitializer",
    "source_code": "public abstract class AbstractContextLoaderInitializer implements WebApplicationInitializer {\n\n\t/** Logger available to subclasses. */\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\n\t@Override\n\tpublic void onStartup(ServletContext servletContext) throws ServletException {\n\t\tregisterContextLoaderListener(servletContext);\n\t}\n\n\t/**\n\t * Register a {@link ContextLoaderListener} against the given servlet context. The\n\t * {@code ContextLoaderListener} is initialized with the application context returned\n\t * from the {@link #createRootApplicationContext()} template method.\n\t * @param servletContext the servlet context to register the listener against\n\t */\n\tprotected void registerContextLoaderListener(ServletContext servletContext) {\n\t\tWebApplicationContext rootAppContext = createRootApplicationContext();\n\t\tif (rootAppContext != null) {\n\t\t\tContextLoaderListener listener = new ContextLoaderListener(rootAppContext, servletContext);\n\t\t\tlistener.setContextInitializers(getRootApplicationContextInitializers());\n\t\t\tservletContext.addListener(listener);\n\t\t}\n\t\telse {\n\t\t\tlogger.debug(\"No ContextLoaderListener registered, as \" +\n\t\t\t\t\t\"createRootApplicationContext() did not return an application context\");\n\t\t}\n\t}\n\n\t/**\n\t * Create the \"<strong>root</strong>\" application context to be provided to the\n\t * {@code ContextLoaderListener}.\n\t * <p>The returned context is delegated to\n\t * {@link ContextLoaderListener#ContextLoaderListener(WebApplicationContext)} and will\n\t * be established as the parent context for any {@code DispatcherServlet} application\n\t * contexts. As such, it typically contains middle-tier services, data sources, etc.\n\t * @return the root application context, or {@code null} if a root context is not\n\t * desired\n\t * @see org.springframework.web.servlet.support.AbstractDispatcherServletInitializer\n\t */\n\tprotected abstract @Nullable WebApplicationContext createRootApplicationContext();\n\n\t/**\n\t * Specify application context initializers to be applied to the root application\n\t * context that the {@code ContextLoaderListener} is being created with.\n\t * @since 4.2\n\t * @see #createRootApplicationContext()\n\t * @see ContextLoaderListener#setContextInitializers\n\t */\n\tprotected ApplicationContextInitializer<?> @Nullable [] getRootApplicationContextInitializers() {\n\t\treturn null;\n\t}\n\n}"
  },
  "org.springframework.web.context.AbstractContextLoaderInitializer#createRootApplicationContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the \"<strong>root</strong>\" application context to be provided to the\n\t * {@code ContextLoaderListener}.\n\t * <p>The returned context is delegated to\n\t * {@link ContextLoaderListener#ContextLoaderListener(WebApplicationContext)} and will\n\t * be established as the parent context for any {@code DispatcherServlet} application\n\t * contexts. As such, it typically contains middle-tier services, data sources, etc.\n\t * @return the root application context, or {@code null} if a root context is not\n\t * desired\n\t * @see org.springframework.web.servlet.support.AbstractDispatcherServletInitializer\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "WebApplicationContext",
    "signature": "protected WebApplicationContext createRootApplicationContext()",
    "source_code": "\tprotected abstract @Nullable WebApplicationContext createRootApplicationContext();"
  },
  "org.springframework.web.context.AbstractContextLoaderInitializer#onStartup(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "void",
    "signature": "public void onStartup(ServletContext servletContext)",
    "source_code": "\tpublic void onStartup(ServletContext servletContext) throws ServletException {\n\t\tregisterContextLoaderListener(servletContext);\n\t}"
  },
  "org.springframework.web.context.AbstractContextLoaderInitializer#registerContextLoaderListener(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a {@link ContextLoaderListener} against the given servlet context. The\n\t * {@code ContextLoaderListener} is initialized with the application context returned\n\t * from the {@link #createRootApplicationContext()} template method.\n\t * @param servletContext the servlet context to register the listener against\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "void",
    "signature": "protected void registerContextLoaderListener(ServletContext servletContext)",
    "source_code": "\tprotected void registerContextLoaderListener(ServletContext servletContext) {\n\t\tWebApplicationContext rootAppContext = createRootApplicationContext();\n\t\tif (rootAppContext != null) {\n\t\t\tContextLoaderListener listener = new ContextLoaderListener(rootAppContext, servletContext);\n\t\t\tlistener.setContextInitializers(getRootApplicationContextInitializers());\n\t\t\tservletContext.addListener(listener);\n\t\t}\n\t\telse {\n\t\t\tlogger.debug(\"No ContextLoaderListener registered, as \" +\n\t\t\t\t\t\"createRootApplicationContext() did not return an application context\");\n\t\t}\n\t}"
  },
  "org.springframework.web.context.ConfigurableWebApplicationContext": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Interface to be implemented by configurable web application contexts.\n * Supported by {@link ContextLoader} and\n * {@link org.springframework.web.servlet.FrameworkServlet}.\n *\n * <p>Note: The setters of this interface need to be called before an\n * invocation of the {@link #refresh} method inherited from\n * {@link org.springframework.context.ConfigurableApplicationContext}.\n * They do not cause an initialization of the context on their own.\n *\n * @author Juergen Hoeller\n * @since 05.12.2003\n * @see #refresh\n * @see ContextLoader#createWebApplicationContext\n * @see org.springframework.web.servlet.FrameworkServlet#createWebApplicationContext\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public interface ConfigurableWebApplicationContext",
    "source_code": "public interface ConfigurableWebApplicationContext extends WebApplicationContext, ConfigurableApplicationContext {\n\n\t/**\n\t * Prefix for ApplicationContext ids that refer to context path and/or servlet name.\n\t */\n\tString APPLICATION_CONTEXT_ID_PREFIX = WebApplicationContext.class.getName() + \":\";\n\n\t/**\n\t * Name of the ServletConfig environment bean in the factory.\n\t * @see jakarta.servlet.ServletConfig\n\t */\n\tString SERVLET_CONFIG_BEAN_NAME = \"servletConfig\";\n\n\n\t/**\n\t * Set the ServletContext for this web application context.\n\t * <p>Does not cause an initialization of the context: refresh needs to be\n\t * called after the setting of all configuration properties.\n\t * @see #refresh()\n\t */\n\tvoid setServletContext(@Nullable ServletContext servletContext);\n\n\t/**\n\t * Set the ServletConfig for this web application context.\n\t * Only called for a WebApplicationContext that belongs to a specific Servlet.\n\t * @see #refresh()\n\t */\n\tvoid setServletConfig(@Nullable ServletConfig servletConfig);\n\n\t/**\n\t * Return the ServletConfig for this web application context, if any.\n\t */\n\t@Nullable ServletConfig getServletConfig();\n\n\t/**\n\t * Set the namespace for this web application context,\n\t * to be used for building a default context config location.\n\t * The root web application context does not have a namespace.\n\t */\n\tvoid setNamespace(@Nullable String namespace);\n\n\t/**\n\t * Return the namespace for this web application context, if any.\n\t */\n\t@Nullable String getNamespace();\n\n\t/**\n\t * Set the config locations for this web application context in init-param style,\n\t * i.e. with distinct locations separated by commas, semicolons or whitespace.\n\t * <p>If not set, the implementation is supposed to use a default for the\n\t * given namespace or the root web application context, as appropriate.\n\t */\n\tvoid setConfigLocation(String configLocation);\n\n\t/**\n\t * Set the config locations for this web application context.\n\t * <p>If not set, the implementation is supposed to use a default for the\n\t * given namespace or the root web application context, as appropriate.\n\t */\n\tvoid setConfigLocations(String... configLocations);\n\n\t/**\n\t * Return the config locations for this web application context,\n\t * or {@code null} if none specified.\n\t */\n\tString @Nullable [] getConfigLocations();\n\n}"
  },
  "org.springframework.web.context.logger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Logger available to subclasses. */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.web.context.request.FacesWebRequest": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link WebRequest} adapter for a JSF {@link jakarta.faces.context.FacesContext}.\n *\n * <p>Requires JSF 2.0 or higher, as of Spring 4.0.\n *\n * @author Juergen Hoeller\n * @since 2.5.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class FacesWebRequest",
    "source_code": "public class FacesWebRequest extends FacesRequestAttributes implements NativeWebRequest {\n\n\t/**\n\t * Create a new FacesWebRequest adapter for the given FacesContext.\n\t * @param facesContext the current FacesContext\n\t * @see jakarta.faces.context.FacesContext#getCurrentInstance()\n\t */\n\tpublic FacesWebRequest(FacesContext facesContext) {\n\t\tsuper(facesContext);\n\t}\n\n\n\t@Override\n\tpublic Object getNativeRequest() {\n\t\treturn getExternalContext().getRequest();\n\t}\n\n\t@Override\n\tpublic Object getNativeResponse() {\n\t\treturn getExternalContext().getResponse();\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> @Nullable T getNativeRequest(@Nullable Class<T> requiredType) {\n\t\tif (requiredType != null) {\n\t\t\tObject request = getExternalContext().getRequest();\n\t\t\tif (requiredType.isInstance(request)) {\n\t\t\t\treturn (T) request;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> @Nullable T getNativeResponse(@Nullable Class<T> requiredType) {\n\t\tif (requiredType != null) {\n\t\t\tObject response = getExternalContext().getResponse();\n\t\t\tif (requiredType.isInstance(response)) {\n\t\t\t\treturn (T) response;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t@Override\n\tpublic @Nullable String getHeader(String headerName) {\n\t\treturn getExternalContext().getRequestHeaderMap().get(headerName);\n\t}\n\n\t@Override\n\tpublic String @Nullable [] getHeaderValues(String headerName) {\n\t\treturn getExternalContext().getRequestHeaderValuesMap().get(headerName);\n\t}\n\n\t@Override\n\tpublic Iterator<String> getHeaderNames() {\n\t\treturn getExternalContext().getRequestHeaderMap().keySet().iterator();\n\t}\n\n\t@Override\n\tpublic @Nullable String getParameter(String paramName) {\n\t\treturn getExternalContext().getRequestParameterMap().get(paramName);\n\t}\n\n\t@Override\n\tpublic Iterator<String> getParameterNames() {\n\t\treturn getExternalContext().getRequestParameterNames();\n\t}\n\n\t@Override\n\tpublic String @Nullable [] getParameterValues(String paramName) {\n\t\treturn getExternalContext().getRequestParameterValuesMap().get(paramName);\n\t}\n\n\t@Override\n\tpublic Map<String, String[]> getParameterMap() {\n\t\treturn getExternalContext().getRequestParameterValuesMap();\n\t}\n\n\t@Override\n\tpublic Locale getLocale() {\n\t\treturn getFacesContext().getExternalContext().getRequestLocale();\n\t}\n\n\t@Override\n\tpublic String getContextPath() {\n\t\treturn getFacesContext().getExternalContext().getRequestContextPath();\n\t}\n\n\t@Override\n\tpublic @Nullable String getRemoteUser() {\n\t\treturn getFacesContext().getExternalContext().getRemoteUser();\n\t}\n\n\t@Override\n\tpublic @Nullable Principal getUserPrincipal() {\n\t\treturn getFacesContext().getExternalContext().getUserPrincipal();\n\t}\n\n\t@Override\n\tpublic boolean isUserInRole(String role) {\n\t\treturn getFacesContext().getExternalContext().isUserInRole(role);\n\t}\n\n\t@Override\n\tpublic boolean isSecure() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean checkNotModified(long lastModifiedTimestamp) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean checkNotModified(@Nullable String eTag) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean checkNotModified(@Nullable String etag, long lastModifiedTimestamp) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic String getDescription(boolean includeClientInfo) {\n\t\tExternalContext externalContext = getExternalContext();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"context=\").append(externalContext.getRequestContextPath());\n\t\tif (includeClientInfo) {\n\t\t\tObject session = externalContext.getSession(false);\n\t\t\tif (session != null) {\n\t\t\t\tsb.append(\";session=\").append(getSessionId());\n\t\t\t}\n\t\t\tString user = externalContext.getRemoteUser();\n\t\t\tif (StringUtils.hasLength(user)) {\n\t\t\t\tsb.append(\";user=\").append(user);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"FacesWebRequest: \" + getDescription(true);\n\t}\n\n}"
  },
  "org.springframework.web.context.request.FacesWebRequest#checkNotModified(eTag)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "eTag"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "boolean",
    "signature": "public boolean checkNotModified(@Nullable String eTag)",
    "source_code": "\tpublic boolean checkNotModified(@Nullable String eTag) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.context.request.FacesWebRequest#checkNotModified(etag,lastModifiedTimestamp)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "etag",
      "lastModifiedTimestamp"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "boolean",
    "signature": "public boolean checkNotModified(@Nullable String etag, long lastModifiedTimestamp)",
    "source_code": "\tpublic boolean checkNotModified(@Nullable String etag, long lastModifiedTimestamp) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.context.request.FacesWebRequest#checkNotModified(lastModifiedTimestamp)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lastModifiedTimestamp"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "boolean",
    "signature": "public boolean checkNotModified(long lastModifiedTimestamp)",
    "source_code": "\tpublic boolean checkNotModified(long lastModifiedTimestamp) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.context.request.FacesWebRequest#getContextPath()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "String",
    "signature": "public String getContextPath()",
    "source_code": "\tpublic String getContextPath() {\n\t\treturn getFacesContext().getExternalContext().getRequestContextPath();\n\t}"
  },
  "org.springframework.web.context.request.FacesWebRequest#getDescription(includeClientInfo)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "includeClientInfo"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "String",
    "signature": "public String getDescription(boolean includeClientInfo)",
    "source_code": "\tpublic String getDescription(boolean includeClientInfo) {\n\t\tExternalContext externalContext = getExternalContext();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"context=\").append(externalContext.getRequestContextPath());\n\t\tif (includeClientInfo) {\n\t\t\tObject session = externalContext.getSession(false);\n\t\t\tif (session != null) {\n\t\t\t\tsb.append(\";session=\").append(getSessionId());\n\t\t\t}\n\t\t\tString user = externalContext.getRemoteUser();\n\t\t\tif (StringUtils.hasLength(user)) {\n\t\t\t\tsb.append(\";user=\").append(user);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.web.context.request.FacesWebRequest#getHeader(headerName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "String",
    "signature": "public String getHeader(String headerName)",
    "source_code": "\tpublic @Nullable String getHeader(String headerName) {\n\t\treturn getExternalContext().getRequestHeaderMap().get(headerName);\n\t}"
  },
  "org.springframework.web.context.request.FacesWebRequest#getHeaderNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "Iterator<String>",
    "signature": "public Iterator<String> getHeaderNames()",
    "source_code": "\tpublic Iterator<String> getHeaderNames() {\n\t\treturn getExternalContext().getRequestHeaderMap().keySet().iterator();\n\t}"
  },
  "org.springframework.web.context.request.FacesWebRequest#getLocale()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "Locale",
    "signature": "public Locale getLocale()",
    "source_code": "\tpublic Locale getLocale() {\n\t\treturn getFacesContext().getExternalContext().getRequestLocale();\n\t}"
  },
  "org.springframework.web.context.request.FacesWebRequest#getNativeRequest()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "Object",
    "signature": "public Object getNativeRequest()",
    "source_code": "\tpublic Object getNativeRequest() {\n\t\treturn getExternalContext().getRequest();\n\t}"
  },
  "org.springframework.web.context.request.FacesWebRequest#getNativeRequest(requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "T",
    "signature": "public T getNativeRequest(@Nullable Class<T> requiredType)",
    "source_code": "\tpublic <T> @Nullable T getNativeRequest(@Nullable Class<T> requiredType) {\n\t\tif (requiredType != null) {\n\t\t\tObject request = getExternalContext().getRequest();\n\t\t\tif (requiredType.isInstance(request)) {\n\t\t\t\treturn (T) request;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.context.request.FacesWebRequest#getNativeResponse()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "Object",
    "signature": "public Object getNativeResponse()",
    "source_code": "\tpublic Object getNativeResponse() {\n\t\treturn getExternalContext().getResponse();\n\t}"
  },
  "org.springframework.web.context.request.FacesWebRequest#getNativeResponse(requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "T",
    "signature": "public T getNativeResponse(@Nullable Class<T> requiredType)",
    "source_code": "\tpublic <T> @Nullable T getNativeResponse(@Nullable Class<T> requiredType) {\n\t\tif (requiredType != null) {\n\t\t\tObject response = getExternalContext().getResponse();\n\t\t\tif (requiredType.isInstance(response)) {\n\t\t\t\treturn (T) response;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.context.request.FacesWebRequest#getParameter(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "String",
    "signature": "public String getParameter(String paramName)",
    "source_code": "\tpublic @Nullable String getParameter(String paramName) {\n\t\treturn getExternalContext().getRequestParameterMap().get(paramName);\n\t}"
  },
  "org.springframework.web.context.request.FacesWebRequest#getParameterMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "String[]>",
    "signature": "public String[]> getParameterMap()",
    "source_code": "\tpublic Map<String, String[]> getParameterMap() {\n\t\treturn getExternalContext().getRequestParameterValuesMap();\n\t}"
  },
  "org.springframework.web.context.request.FacesWebRequest#getParameterNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Iterator<String>",
    "signature": "public Iterator<String> getParameterNames()",
    "source_code": "\tpublic Iterator<String> getParameterNames() {\n\t\treturn getExternalContext().getRequestParameterNames();\n\t}"
  },
  "org.springframework.web.context.request.FacesWebRequest#getRemoteUser()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "String",
    "signature": "public String getRemoteUser()",
    "source_code": "\tpublic @Nullable String getRemoteUser() {\n\t\treturn getFacesContext().getExternalContext().getRemoteUser();\n\t}"
  },
  "org.springframework.web.context.request.FacesWebRequest#getUserPrincipal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "Principal",
    "signature": "public Principal getUserPrincipal()",
    "source_code": "\tpublic @Nullable Principal getUserPrincipal() {\n\t\treturn getFacesContext().getExternalContext().getUserPrincipal();\n\t}"
  },
  "org.springframework.web.context.request.FacesWebRequest#isSecure()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "boolean",
    "signature": "public boolean isSecure()",
    "source_code": "\tpublic boolean isSecure() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.context.request.FacesWebRequest#isUserInRole(role)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "role"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "boolean",
    "signature": "public boolean isUserInRole(String role)",
    "source_code": "\tpublic boolean isUserInRole(String role) {\n\t\treturn getFacesContext().getExternalContext().isUserInRole(role);\n\t}"
  },
  "org.springframework.web.context.request.FacesWebRequest#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"FacesWebRequest: \" + getDescription(true);\n\t}"
  },
  "org.springframework.web.context.request.NativeWebRequest": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Extension of the {@link WebRequest} interface, exposing the\n * native request and response objects in a generic fashion.\n *\n * <p>Mainly intended for framework-internal usage,\n * in particular for generic argument resolution code.\n *\n * @author Juergen Hoeller\n * @since 2.5.2\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 31
    },
    "signature": "public interface NativeWebRequest",
    "source_code": "public interface NativeWebRequest extends WebRequest {\n\n\t/**\n\t * Return the underlying native request object.\n\t * @see jakarta.servlet.http.HttpServletRequest\n\t */\n\tObject getNativeRequest();\n\n\t/**\n\t * Return the underlying native response object, if any.\n\t * @see jakarta.servlet.http.HttpServletResponse\n\t */\n\t@Nullable Object getNativeResponse();\n\n\t/**\n\t * Return the underlying native request object, if available.\n\t * @param requiredType the desired type of request object\n\t * @return the matching request object, or {@code null} if none\n\t * of that type is available\n\t * @see jakarta.servlet.http.HttpServletRequest\n\t */\n\t<T> @Nullable T getNativeRequest(@Nullable Class<T> requiredType);\n\n\t/**\n\t * Return the underlying native response object, if available.\n\t * @param requiredType the desired type of response object\n\t * @return the matching response object, or {@code null} if none\n\t * of that type is available\n\t * @see jakarta.servlet.http.HttpServletResponse\n\t */\n\t<T> @Nullable T getNativeResponse(@Nullable Class<T> requiredType);\n\n}"
  },
  "org.springframework.web.context.request.ServletWebRequest": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link WebRequest} adapter for an {@link jakarta.servlet.http.HttpServletRequest}.\n *\n * @author Juergen Hoeller\n * @author Brian Clozel\n * @author Markus Malkusch\n * @since 2.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class ServletWebRequest",
    "source_code": "public class ServletWebRequest extends ServletRequestAttributes implements NativeWebRequest {\n\n\tprivate static final Set<String> SAFE_METHODS = Set.of(\"GET\", \"HEAD\");\n\n\t/**\n\t * Date formats as specified in the HTTP RFC.\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-7.1.1.1\">Section 7.1.1.1 of RFC 7231</a>\n\t */\n\tprivate static final String[] DATE_FORMATS = new String[] {\n\t\t\t\"EEE, dd MMM yyyy HH:mm:ss zzz\",\n\t\t\t\"EEE, dd-MMM-yy HH:mm:ss zzz\",\n\t\t\t\"EEE MMM dd HH:mm:ss yyyy\"\n\t};\n\n\tprivate static final TimeZone GMT = TimeZone.getTimeZone(\"GMT\");\n\n\tprivate boolean notModified = false;\n\n\n\t/**\n\t * Create a new ServletWebRequest instance for the given request.\n\t * @param request current HTTP request\n\t */\n\tpublic ServletWebRequest(HttpServletRequest request) {\n\t\tsuper(request);\n\t}\n\n\t/**\n\t * Create a new ServletWebRequest instance for the given request/response pair.\n\t * @param request current HTTP request\n\t * @param response current HTTP response (for automatic last-modified handling)\n\t */\n\tpublic ServletWebRequest(HttpServletRequest request, @Nullable HttpServletResponse response) {\n\t\tsuper(request, response);\n\t}\n\n\n\t@Override\n\tpublic Object getNativeRequest() {\n\t\treturn getRequest();\n\t}\n\n\t@Override\n\tpublic @Nullable Object getNativeResponse() {\n\t\treturn getResponse();\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T getNativeRequest(@Nullable Class<T> requiredType) {\n\t\treturn WebUtils.getNativeRequest(getRequest(), requiredType);\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T getNativeResponse(@Nullable Class<T> requiredType) {\n\t\tHttpServletResponse response = getResponse();\n\t\treturn (response != null ? WebUtils.getNativeResponse(response, requiredType) : null);\n\t}\n\n\t/**\n\t * Return the HTTP method of the request.\n\t * @since 4.0.2\n\t */\n\tpublic HttpMethod getHttpMethod() {\n\t\treturn HttpMethod.valueOf(getRequest().getMethod());\n\t}\n\n\t@Override\n\tpublic @Nullable String getHeader(String headerName) {\n\t\treturn getRequest().getHeader(headerName);\n\t}\n\n\t@Override\n\tpublic String @Nullable [] getHeaderValues(String headerName) {\n\t\tString[] headerValues = StringUtils.toStringArray(getRequest().getHeaders(headerName));\n\t\treturn (!ObjectUtils.isEmpty(headerValues) ? headerValues : null);\n\t}\n\n\t@Override\n\tpublic Iterator<String> getHeaderNames() {\n\t\treturn CollectionUtils.toIterator(getRequest().getHeaderNames());\n\t}\n\n\t@Override\n\tpublic @Nullable String getParameter(String paramName) {\n\t\treturn getRequest().getParameter(paramName);\n\t}\n\n\t@Override\n\tpublic String @Nullable [] getParameterValues(String paramName) {\n\t\treturn getRequest().getParameterValues(paramName);\n\t}\n\n\t@Override\n\tpublic Iterator<String> getParameterNames() {\n\t\treturn CollectionUtils.toIterator(getRequest().getParameterNames());\n\t}\n\n\t@Override\n\tpublic Map<String, String[]> getParameterMap() {\n\t\treturn getRequest().getParameterMap();\n\t}\n\n\t@Override\n\tpublic Locale getLocale() {\n\t\treturn getRequest().getLocale();\n\t}\n\n\t@Override\n\tpublic String getContextPath() {\n\t\treturn getRequest().getContextPath();\n\t}\n\n\t@Override\n\tpublic @Nullable String getRemoteUser() {\n\t\treturn getRequest().getRemoteUser();\n\t}\n\n\t@Override\n\tpublic @Nullable Principal getUserPrincipal() {\n\t\treturn getRequest().getUserPrincipal();\n\t}\n\n\t@Override\n\tpublic boolean isUserInRole(String role) {\n\t\treturn getRequest().isUserInRole(role);\n\t}\n\n\t@Override\n\tpublic boolean isSecure() {\n\t\treturn getRequest().isSecure();\n\t}\n\n\n\t@Override\n\tpublic boolean checkNotModified(long lastModifiedTimestamp) {\n\t\treturn checkNotModified(null, lastModifiedTimestamp);\n\t}\n\n\t@Override\n\tpublic boolean checkNotModified(String etag) {\n\t\treturn checkNotModified(etag, -1);\n\t}\n\n\t@Override\n\tpublic boolean checkNotModified(@Nullable String etag, long lastModifiedTimestamp) {\n\t\tif (this.notModified) {\n\t\t\treturn true;\n\t\t}\n\n\t\tHttpServletResponse response = getResponse();\n\t\tif (response != null && HttpStatus.OK.value() != response.getStatus()) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Evaluate conditions in order of precedence.\n\t\t// See https://datatracker.ietf.org/doc/html/rfc9110#section-13.2.2\n\t\tif (validateIfMatch(etag)) {\n\t\t\tupdateResponseStateChanging(etag, lastModifiedTimestamp);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 2) If-Unmodified-Since\n\t\tif (validateIfUnmodifiedSince(lastModifiedTimestamp)) {\n\t\t\tupdateResponseStateChanging(etag, lastModifiedTimestamp);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 3) If-None-Match\n\t\tif (!validateIfNoneMatch(etag)) {\n\t\t\t// 4) If-Modified-Since\n\t\t\tvalidateIfModifiedSince(lastModifiedTimestamp);\n\t\t}\n\t\tupdateResponseIdempotent(etag, lastModifiedTimestamp);\n\t\treturn this.notModified;\n\t}\n\n\tprivate boolean validateIfMatch(@Nullable String etag) {\n\t\tif (SAFE_METHODS.contains(getRequest().getMethod())) {\n\t\t\treturn false;\n\t\t}\n\t\tEnumeration<String> ifMatchHeaders = getRequest().getHeaders(HttpHeaders.IF_MATCH);\n\t\tif (!ifMatchHeaders.hasMoreElements()) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.notModified = matchRequestedETags(ifMatchHeaders, etag, false);\n\t\treturn true;\n\t}\n\n\tprivate boolean validateIfNoneMatch(@Nullable String etag) {\n\t\tEnumeration<String> ifNoneMatchHeaders = getRequest().getHeaders(HttpHeaders.IF_NONE_MATCH);\n\t\tif (!ifNoneMatchHeaders.hasMoreElements()) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.notModified = !matchRequestedETags(ifNoneMatchHeaders, etag, true);\n\t\treturn true;\n\t}\n\n\tprivate boolean matchRequestedETags(Enumeration<String> requestedETags, @Nullable String tag, boolean weakCompare) {\n\t\tif (StringUtils.hasLength(tag)) {\n\t\t\tETag eTag = ETag.create(tag);\n\t\t\tboolean isNotSafeMethod = !SAFE_METHODS.contains(getRequest().getMethod());\n\t\t\twhile (requestedETags.hasMoreElements()) {\n\t\t\t\t// Compare weak/strong ETags as per https://datatracker.ietf.org/doc/html/rfc9110#section-8.8.3\n\t\t\t\tfor (ETag requestedETag : ETag.parse(requestedETags.nextElement())) {\n\t\t\t\t\t// only consider \"lost updates\" checks for unsafe HTTP methods\n\t\t\t\t\tif (requestedETag.isWildcard() && isNotSafeMethod) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (requestedETag.compare(eTag, !weakCompare)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void updateResponseStateChanging(@Nullable String etag, long lastModifiedTimestamp) {\n\t\tif (this.notModified && getResponse() != null) {\n\t\t\tgetResponse().setStatus(HttpStatus.PRECONDITION_FAILED.value());\n\t\t}\n\t\telse {\n\t\t\taddCachingResponseHeaders(etag, lastModifiedTimestamp);\n\t\t}\n\t}\n\n\tprivate boolean validateIfUnmodifiedSince(long lastModifiedTimestamp) {\n\t\tif (lastModifiedTimestamp < 0) {\n\t\t\treturn false;\n\t\t}\n\t\tlong ifUnmodifiedSince = parseDateHeader(HttpHeaders.IF_UNMODIFIED_SINCE);\n\t\tif (ifUnmodifiedSince == -1) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.notModified = (ifUnmodifiedSince < (lastModifiedTimestamp / 1000 * 1000));\n\t\treturn true;\n\t}\n\n\tprivate void validateIfModifiedSince(long lastModifiedTimestamp) {\n\t\tif (lastModifiedTimestamp < 0) {\n\t\t\treturn;\n\t\t}\n\t\tlong ifModifiedSince = parseDateHeader(HttpHeaders.IF_MODIFIED_SINCE);\n\t\tif (ifModifiedSince != -1) {\n\t\t\t// We will perform this validation...\n\t\t\tthis.notModified = ifModifiedSince >= (lastModifiedTimestamp / 1000 * 1000);\n\t\t}\n\t}\n\n\tprivate void updateResponseIdempotent(@Nullable String etag, long lastModifiedTimestamp) {\n\t\tif (getResponse() != null) {\n\t\t\tboolean isHttpGetOrHead = SAFE_METHODS.contains(getRequest().getMethod());\n\t\t\tif (this.notModified) {\n\t\t\t\tgetResponse().setStatus(isHttpGetOrHead ?\n\t\t\t\t\t\tHttpStatus.NOT_MODIFIED.value() : HttpStatus.PRECONDITION_FAILED.value());\n\t\t\t}\n\t\t\taddCachingResponseHeaders(etag, lastModifiedTimestamp);\n\t\t}\n\t}\n\n\tprivate void addCachingResponseHeaders(@Nullable String eTag, long lastModifiedTimestamp) {\n\t\tif (getResponse() != null && SAFE_METHODS.contains(getRequest().getMethod())) {\n\t\t\tif (lastModifiedTimestamp > 0 && parseDateValue(getResponse().getHeader(HttpHeaders.LAST_MODIFIED)) == -1) {\n\t\t\t\tgetResponse().setDateHeader(HttpHeaders.LAST_MODIFIED, lastModifiedTimestamp);\n\t\t\t}\n\t\t\tif (StringUtils.hasLength(eTag) && getResponse().getHeader(HttpHeaders.ETAG) == null) {\n\t\t\t\tgetResponse().setHeader(HttpHeaders.ETAG, ETag.quoteETagIfNecessary(eTag));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean isNotModified() {\n\t\treturn this.notModified;\n\t}\n\n\tprivate long parseDateHeader(String headerName) {\n\t\tlong dateValue = -1;\n\t\ttry {\n\t\t\tdateValue = getRequest().getDateHeader(headerName);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tString headerValue = getHeader(headerName);\n\t\t\t// Possibly an IE 10 style value: \"Wed, 09 Apr 2014 09:57:42 GMT; length=13774\"\n\t\t\tif (headerValue != null) {\n\t\t\t\tint separatorIndex = headerValue.indexOf(';');\n\t\t\t\tif (separatorIndex != -1) {\n\t\t\t\t\tString datePart = headerValue.substring(0, separatorIndex);\n\t\t\t\t\tdateValue = parseDateValue(datePart);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dateValue;\n\t}\n\n\tprivate long parseDateValue(@Nullable String headerValue) {\n\t\tif (headerValue == null) {\n\t\t\t// No header value sent at all\n\t\t\treturn -1;\n\t\t}\n\t\tif (headerValue.length() >= 3) {\n\t\t\t// Short \"0\" or \"-1\" like values are never valid HTTP date headers...\n\t\t\t// Let's only bother with SimpleDateFormat parsing for long enough values.\n\t\t\tfor (String dateFormat : DATE_FORMATS) {\n\t\t\t\tSimpleDateFormat simpleDateFormat = new SimpleDateFormat(dateFormat, Locale.US);\n\t\t\t\tsimpleDateFormat.setTimeZone(GMT);\n\t\t\t\ttry {\n\t\t\t\t\treturn simpleDateFormat.parse(headerValue).getTime();\n\t\t\t\t}\n\t\t\t\tcatch (ParseException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic String getDescription(boolean includeClientInfo) {\n\t\tHttpServletRequest request = getRequest();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"uri=\").append(request.getRequestURI());\n\t\tif (includeClientInfo) {\n\t\t\tString client = request.getRemoteAddr();\n\t\t\tif (StringUtils.hasLength(client)) {\n\t\t\t\tsb.append(\";client=\").append(client);\n\t\t\t}\n\t\t\tHttpSession session = request.getSession(false);\n\t\t\tif (session != null) {\n\t\t\t\tsb.append(\";session=\").append(session.getId());\n\t\t\t}\n\t\t\tString user = request.getRemoteUser();\n\t\t\tif (StringUtils.hasLength(user)) {\n\t\t\t\tsb.append(\";user=\").append(user);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"ServletWebRequest: \" + getDescription(true);\n\t}\n\n}"
  },
  "org.springframework.web.context.request.ServletWebRequest#checkNotModified(etag)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "etag"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "boolean",
    "signature": "public boolean checkNotModified(String etag)",
    "source_code": "\tpublic boolean checkNotModified(String etag) {\n\t\treturn checkNotModified(etag, -1);\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#checkNotModified(etag,lastModifiedTimestamp)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "etag",
      "lastModifiedTimestamp"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "boolean",
    "signature": "public boolean checkNotModified(@Nullable String etag, long lastModifiedTimestamp)",
    "source_code": "\tpublic boolean checkNotModified(@Nullable String etag, long lastModifiedTimestamp) {\n\t\tif (this.notModified) {\n\t\t\treturn true;\n\t\t}\n\n\t\tHttpServletResponse response = getResponse();\n\t\tif (response != null && HttpStatus.OK.value() != response.getStatus()) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Evaluate conditions in order of precedence.\n\t\t// See https://datatracker.ietf.org/doc/html/rfc9110#section-13.2.2\n\t\tif (validateIfMatch(etag)) {\n\t\t\tupdateResponseStateChanging(etag, lastModifiedTimestamp);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 2) If-Unmodified-Since\n\t\tif (validateIfUnmodifiedSince(lastModifiedTimestamp)) {\n\t\t\tupdateResponseStateChanging(etag, lastModifiedTimestamp);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 3) If-None-Match\n\t\tif (!validateIfNoneMatch(etag)) {\n\t\t\t// 4) If-Modified-Since\n\t\t\tvalidateIfModifiedSince(lastModifiedTimestamp);\n\t\t}\n\t\tupdateResponseIdempotent(etag, lastModifiedTimestamp);\n\t\treturn this.notModified;\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#checkNotModified(lastModifiedTimestamp)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lastModifiedTimestamp"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "boolean",
    "signature": "public boolean checkNotModified(long lastModifiedTimestamp)",
    "source_code": "\tpublic boolean checkNotModified(long lastModifiedTimestamp) {\n\t\treturn checkNotModified(null, lastModifiedTimestamp);\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#getContextPath()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "String",
    "signature": "public String getContextPath()",
    "source_code": "\tpublic String getContextPath() {\n\t\treturn getRequest().getContextPath();\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#getDescription(includeClientInfo)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "includeClientInfo"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "String",
    "signature": "public String getDescription(boolean includeClientInfo)",
    "source_code": "\tpublic String getDescription(boolean includeClientInfo) {\n\t\tHttpServletRequest request = getRequest();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"uri=\").append(request.getRequestURI());\n\t\tif (includeClientInfo) {\n\t\t\tString client = request.getRemoteAddr();\n\t\t\tif (StringUtils.hasLength(client)) {\n\t\t\t\tsb.append(\";client=\").append(client);\n\t\t\t}\n\t\t\tHttpSession session = request.getSession(false);\n\t\t\tif (session != null) {\n\t\t\t\tsb.append(\";session=\").append(session.getId());\n\t\t\t}\n\t\t\tString user = request.getRemoteUser();\n\t\t\tif (StringUtils.hasLength(user)) {\n\t\t\t\tsb.append(\";user=\").append(user);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#getHeader(headerName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "String",
    "signature": "public String getHeader(String headerName)",
    "source_code": "\tpublic @Nullable String getHeader(String headerName) {\n\t\treturn getRequest().getHeader(headerName);\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#getHeaderNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "Iterator<String>",
    "signature": "public Iterator<String> getHeaderNames()",
    "source_code": "\tpublic Iterator<String> getHeaderNames() {\n\t\treturn CollectionUtils.toIterator(getRequest().getHeaderNames());\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#getHttpMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HTTP method of the request.\n\t * @since 4.0.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "HttpMethod",
    "signature": "public HttpMethod getHttpMethod()",
    "source_code": "\tpublic HttpMethod getHttpMethod() {\n\t\treturn HttpMethod.valueOf(getRequest().getMethod());\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#getLocale()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "Locale",
    "signature": "public Locale getLocale()",
    "source_code": "\tpublic Locale getLocale() {\n\t\treturn getRequest().getLocale();\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#getNativeRequest()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "Object",
    "signature": "public Object getNativeRequest()",
    "source_code": "\tpublic Object getNativeRequest() {\n\t\treturn getRequest();\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#getNativeRequest(requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "T",
    "signature": "public T getNativeRequest(@Nullable Class<T> requiredType)",
    "source_code": "\tpublic <T> @Nullable T getNativeRequest(@Nullable Class<T> requiredType) {\n\t\treturn WebUtils.getNativeRequest(getRequest(), requiredType);\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#getNativeResponse()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "Object",
    "signature": "public Object getNativeResponse()",
    "source_code": "\tpublic @Nullable Object getNativeResponse() {\n\t\treturn getResponse();\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#getNativeResponse(requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "T",
    "signature": "public T getNativeResponse(@Nullable Class<T> requiredType)",
    "source_code": "\tpublic <T> @Nullable T getNativeResponse(@Nullable Class<T> requiredType) {\n\t\tHttpServletResponse response = getResponse();\n\t\treturn (response != null ? WebUtils.getNativeResponse(response, requiredType) : null);\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#getParameter(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "String",
    "signature": "public String getParameter(String paramName)",
    "source_code": "\tpublic @Nullable String getParameter(String paramName) {\n\t\treturn getRequest().getParameter(paramName);\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#getParameterMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "String[]>",
    "signature": "public String[]> getParameterMap()",
    "source_code": "\tpublic Map<String, String[]> getParameterMap() {\n\t\treturn getRequest().getParameterMap();\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#getParameterNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "Iterator<String>",
    "signature": "public Iterator<String> getParameterNames()",
    "source_code": "\tpublic Iterator<String> getParameterNames() {\n\t\treturn CollectionUtils.toIterator(getRequest().getParameterNames());\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#getRemoteUser()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "String",
    "signature": "public String getRemoteUser()",
    "source_code": "\tpublic @Nullable String getRemoteUser() {\n\t\treturn getRequest().getRemoteUser();\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#getUserPrincipal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "Principal",
    "signature": "public Principal getUserPrincipal()",
    "source_code": "\tpublic @Nullable Principal getUserPrincipal() {\n\t\treturn getRequest().getUserPrincipal();\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#isNotModified()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "boolean",
    "signature": "public boolean isNotModified()",
    "source_code": "\tpublic boolean isNotModified() {\n\t\treturn this.notModified;\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#isSecure()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "boolean",
    "signature": "public boolean isSecure()",
    "source_code": "\tpublic boolean isSecure() {\n\t\treturn getRequest().isSecure();\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#isUserInRole(role)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "role"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "boolean",
    "signature": "public boolean isUserInRole(String role)",
    "source_code": "\tpublic boolean isUserInRole(String role) {\n\t\treturn getRequest().isUserInRole(role);\n\t}"
  },
  "org.springframework.web.context.request.ServletWebRequest#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"ServletWebRequest: \" + getDescription(true);\n\t}"
  },
  "org.springframework.web.context.request.WebRequest": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Generic interface for a web request. Mainly intended for generic web\n * request interceptors, giving them access to general request metadata,\n * not for actual handling of the request.\n *\n * @author Juergen Hoeller\n * @author Brian Clozel\n * @since 2.0\n * @see WebRequestInterceptor\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public interface WebRequest",
    "source_code": "public interface WebRequest extends RequestAttributes {\n\n\t/**\n\t * Return the request header of the given name, or {@code null} if none.\n\t * <p>Retrieves the first header value in case of a multi-value header.\n\t * @since 3.0\n\t * @see jakarta.servlet.http.HttpServletRequest#getHeader(String)\n\t */\n\t@Nullable String getHeader(String headerName);\n\n\t/**\n\t * Return the request header values for the given header name,\n\t * or {@code null} if none.\n\t * <p>A single-value header will be exposed as an array with a single element.\n\t * @since 3.0\n\t * @see jakarta.servlet.http.HttpServletRequest#getHeaders(String)\n\t */\n\tString @Nullable [] getHeaderValues(String headerName);\n\n\t/**\n\t * Return an Iterator over request header names.\n\t * @since 3.0\n\t * @see jakarta.servlet.http.HttpServletRequest#getHeaderNames()\n\t */\n\tIterator<String> getHeaderNames();\n\n\t/**\n\t * Return the request parameter of the given name, or {@code null} if none.\n\t * <p>Retrieves the first parameter value in case of a multi-value parameter.\n\t * @see jakarta.servlet.http.HttpServletRequest#getParameter(String)\n\t */\n\t@Nullable String getParameter(String paramName);\n\n\t/**\n\t * Return the request parameter values for the given parameter name,\n\t * or {@code null} if none.\n\t * <p>A single-value parameter will be exposed as an array with a single element.\n\t * @see jakarta.servlet.http.HttpServletRequest#getParameterValues(String)\n\t */\n\tString @Nullable [] getParameterValues(String paramName);\n\n\t/**\n\t * Return an Iterator over request parameter names.\n\t * @since 3.0\n\t * @see jakarta.servlet.http.HttpServletRequest#getParameterNames()\n\t */\n\tIterator<String> getParameterNames();\n\n\t/**\n\t * Return an immutable Map of the request parameters, with parameter names as map keys\n\t * and parameter values as map values. The map values will be of type String array.\n\t * <p>A single-value parameter will be exposed as an array with a single element.\n\t * @see jakarta.servlet.http.HttpServletRequest#getParameterMap()\n\t */\n\tMap<String, String[]> getParameterMap();\n\n\t/**\n\t * Return the primary Locale for this request.\n\t * @see jakarta.servlet.http.HttpServletRequest#getLocale()\n\t */\n\tLocale getLocale();\n\n\t/**\n\t * Return the context path for this request\n\t * (usually the base path that the current web application is mapped to).\n\t * @see jakarta.servlet.http.HttpServletRequest#getContextPath()\n\t */\n\tString getContextPath();\n\n\t/**\n\t * Return the remote user for this request, if any.\n\t * @see jakarta.servlet.http.HttpServletRequest#getRemoteUser()\n\t */\n\t@Nullable String getRemoteUser();\n\n\t/**\n\t * Return the user principal for this request, if any.\n\t * @see jakarta.servlet.http.HttpServletRequest#getUserPrincipal()\n\t */\n\t@Nullable Principal getUserPrincipal();\n\n\t/**\n\t * Determine whether the user is in the given role for this request.\n\t * @see jakarta.servlet.http.HttpServletRequest#isUserInRole(String)\n\t */\n\tboolean isUserInRole(String role);\n\n\t/**\n\t * Return whether this request has been sent over a secure transport\n\t * mechanism (such as SSL).\n\t * @see jakarta.servlet.http.HttpServletRequest#isSecure()\n\t */\n\tboolean isSecure();\n\n\t/**\n\t * Check whether the requested resource has been modified given the\n\t * supplied last-modified timestamp (as determined by the application).\n\t * <p>This will also transparently set the \"Last-Modified\" response header\n\t * and HTTP status when applicable.\n\t * <p>Typical usage:\n\t * <pre class=\"code\">\n\t * public String myHandleMethod(WebRequest request, Model model) {\n\t *   long lastModified = // application-specific calculation\n\t *   if (request.checkNotModified(lastModified)) {\n\t *     // shortcut exit - no further processing necessary\n\t *     return null;\n\t *   }\n\t *   // further request processing, actually building content\n\t *   model.addAttribute(...);\n\t *   return \"myViewName\";\n\t * }</pre>\n\t * <p>This method works with conditional GET/HEAD requests, but\n\t * also with conditional POST/PUT/DELETE requests.\n\t * <p><strong>Note:</strong> you can use either\n\t * this {@code #checkNotModified(long)} method; or\n\t * {@link #checkNotModified(String)}. If you want to enforce both\n\t * a strong entity tag and a Last-Modified value,\n\t * as recommended by the HTTP specification,\n\t * then you should use {@link #checkNotModified(String, long)}.\n\t * <p>If the \"If-Modified-Since\" header is set but cannot be parsed\n\t * to a date value, this method will ignore the header and proceed\n\t * with setting the last-modified timestamp on the response.\n\t * @param lastModifiedTimestamp the last-modified timestamp in\n\t * milliseconds that the application determined for the underlying\n\t * resource\n\t * @return whether the request qualifies as not modified,\n\t * allowing to abort request processing and relying on the response\n\t * telling the client that the content has not been modified\n\t */\n\tboolean checkNotModified(long lastModifiedTimestamp);\n\n\t/**\n\t * Check whether the requested resource has been modified given the\n\t * supplied {@code ETag} (entity tag), as determined by the application.\n\t * <p>This will also transparently set the \"ETag\" response header\n\t * and HTTP status when applicable.\n\t * <p>Typical usage:\n\t * <pre class=\"code\">\n\t * public String myHandleMethod(WebRequest request, Model model) {\n\t *   String eTag = // application-specific calculation\n\t *   if (request.checkNotModified(eTag)) {\n\t *     // shortcut exit - no further processing necessary\n\t *     return null;\n\t *   }\n\t *   // further request processing, actually building content\n\t *   model.addAttribute(...);\n\t *   return \"myViewName\";\n\t * }</pre>\n\t * <p><strong>Note:</strong> you can use either\n\t * this {@code #checkNotModified(String)} method; or\n\t * {@link #checkNotModified(long)}. If you want to enforce both\n\t * a strong entity tag and a Last-Modified value,\n\t * as recommended by the HTTP specification,\n\t * then you should use {@link #checkNotModified(String, long)}.\n\t * @param etag the entity tag that the application determined\n\t * for the underlying resource. This parameter will be padded\n\t * with quotes (\") if necessary.\n\t * @return true if the request does not require further processing.\n\t */\n\tboolean checkNotModified(String etag);\n\n\t/**\n\t * Check whether the requested resource has been modified given the\n\t * supplied {@code ETag} (entity tag) and last-modified timestamp,\n\t * as determined by the application.\n\t * <p>This will also transparently set the \"ETag\" and \"Last-Modified\"\n\t * response headers, and HTTP status when applicable.\n\t * <p>Typical usage:\n\t * <pre class=\"code\">\n\t * public String myHandleMethod(WebRequest request, Model model) {\n\t *   String eTag = // application-specific calculation\n\t *   long lastModified = // application-specific calculation\n\t *   if (request.checkNotModified(eTag, lastModified)) {\n\t *     // shortcut exit - no further processing necessary\n\t *     return null;\n\t *   }\n\t *   // further request processing, actually building content\n\t *   model.addAttribute(...);\n\t *   return \"myViewName\";\n\t * }</pre>\n\t * <p>This method works with conditional GET/HEAD requests, but\n\t * also with conditional POST/PUT/DELETE requests.\n\t * <p><strong>Note:</strong> The HTTP specification recommends\n\t * setting both ETag and Last-Modified values, but you can also\n\t * use {@link #checkNotModified(String)} or\n\t * {@link #checkNotModified(long)}.\n\t * @param etag the entity tag that the application determined\n\t * for the underlying resource. This parameter will be padded\n\t * with quotes (\") if necessary.\n\t * @param lastModifiedTimestamp the last-modified timestamp in\n\t * milliseconds that the application determined for the underlying\n\t * resource\n\t * @return true if the request does not require further processing.\n\t * @since 4.2\n\t */\n\tboolean checkNotModified(@Nullable String etag, long lastModifiedTimestamp);\n\n\t/**\n\t * Get a short description of this request,\n\t * typically containing request URI and session id.\n\t * @param includeClientInfo whether to include client-specific\n\t * information such as session id and user name\n\t * @return the requested description as String\n\t */\n\tString getDescription(boolean includeClientInfo);\n\n}"
  },
  "org.springframework.web.context.request.async.WebAsyncManager": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * The central class for managing asynchronous request processing, mainly intended\n * as an SPI and not typically used directly by application classes.\n *\n * <p>An async scenario starts with request processing as usual in a thread (T1).\n * Concurrent request handling can be initiated by calling\n * {@link #startCallableProcessing(Callable, Object...) startCallableProcessing} or\n * {@link #startDeferredResultProcessing(DeferredResult, Object...) startDeferredResultProcessing},\n * both of which produce a result in a separate thread (T2). The result is saved\n * and the request dispatched to the container, to resume processing with the saved\n * result in a third thread (T3). Within the dispatched thread (T3), the saved\n * result can be accessed via {@link #getConcurrentResult()} or its presence\n * detected via {@link #hasConcurrentResult()}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 3.2\n * @see org.springframework.web.context.request.AsyncWebRequestInterceptor\n * @see org.springframework.web.servlet.AsyncHandlerInterceptor\n * @see org.springframework.web.filter.OncePerRequestFilter#shouldNotFilterAsyncDispatch\n * @see org.springframework.web.filter.OncePerRequestFilter#isAsyncDispatch\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "signature": "public class WebAsyncManager",
    "source_code": "public final class WebAsyncManager {\n\n\tprivate static final Object RESULT_NONE = new Object();\n\n\tprivate static final AsyncTaskExecutor DEFAULT_TASK_EXECUTOR =\n\t\t\tnew SimpleAsyncTaskExecutor(WebAsyncManager.class.getSimpleName());\n\n\tprivate static final Log logger = LogFactory.getLog(WebAsyncManager.class);\n\n\tprivate static final CallableProcessingInterceptor timeoutCallableInterceptor =\n\t\t\tnew TimeoutCallableProcessingInterceptor();\n\n\tprivate static final DeferredResultProcessingInterceptor timeoutDeferredResultInterceptor =\n\t\t\tnew TimeoutDeferredResultProcessingInterceptor();\n\n\n\tprivate @Nullable AsyncWebRequest asyncWebRequest;\n\n\tprivate AsyncTaskExecutor taskExecutor = DEFAULT_TASK_EXECUTOR;\n\n\tprivate boolean isMultipartRequestParsed;\n\n\tprivate volatile @Nullable Object concurrentResult = RESULT_NONE;\n\n\tprivate volatile Object @Nullable [] concurrentResultContext;\n\n\tprivate final AtomicReference<State> state = new AtomicReference<>(State.NOT_STARTED);\n\n\tprivate final Map<Object, CallableProcessingInterceptor> callableInterceptors = new LinkedHashMap<>();\n\n\tprivate final Map<Object, DeferredResultProcessingInterceptor> deferredResultInterceptors = new LinkedHashMap<>();\n\n\n\t/**\n\t * Package-private constructor.\n\t * @see WebAsyncUtils#getAsyncManager(jakarta.servlet.ServletRequest)\n\t * @see WebAsyncUtils#getAsyncManager(org.springframework.web.context.request.WebRequest)\n\t */\n\tWebAsyncManager() {\n\t}\n\n\n\t/**\n\t * Configure the {@link AsyncWebRequest} to use. This property may be set\n\t * more than once during a single request to accurately reflect the current\n\t * state of the request (for example, following a forward, request/response\n\t * wrapping, etc). However, it should not be set while concurrent handling\n\t * is in progress, i.e. while {@link #isConcurrentHandlingStarted()} is\n\t * {@code true}.\n\t * @param asyncWebRequest the web request to use\n\t */\n\tpublic void setAsyncWebRequest(AsyncWebRequest asyncWebRequest) {\n\t\tAssert.notNull(asyncWebRequest, \"AsyncWebRequest must not be null\");\n\t\tthis.asyncWebRequest = asyncWebRequest;\n\t\tthis.asyncWebRequest.addCompletionHandler(() -> asyncWebRequest.removeAttribute(\n\t\t\t\tWebAsyncUtils.WEB_ASYNC_MANAGER_ATTRIBUTE, RequestAttributes.SCOPE_REQUEST));\n\t}\n\n\t/**\n\t * Return the current {@link AsyncWebRequest}.\n\t * @since 5.3.33\n\t */\n\tpublic @Nullable AsyncWebRequest getAsyncWebRequest() {\n\t\treturn this.asyncWebRequest;\n\t}\n\n\t/**\n\t * Configure an AsyncTaskExecutor for use with concurrent processing via\n\t * {@link #startCallableProcessing(Callable, Object...)}.\n\t * <p>By default a {@link SimpleAsyncTaskExecutor} instance is used.\n\t */\n\tpublic void setTaskExecutor(AsyncTaskExecutor taskExecutor) {\n\t\tthis.taskExecutor = taskExecutor;\n\t}\n\n\t/**\n\t * Return whether the selected handler for the current request chose to handle\n\t * the request asynchronously. A return value of \"true\" indicates concurrent\n\t * handling is under way and the response will remain open. A return value\n\t * of \"false\" means concurrent handling was either not started or possibly\n\t * that it has completed and the request was dispatched for further\n\t * processing of the concurrent result.\n\t */\n\tpublic boolean isConcurrentHandlingStarted() {\n\t\treturn (this.asyncWebRequest != null && this.asyncWebRequest.isAsyncStarted());\n\t}\n\n\t/**\n\t * Return whether a result value exists as a result of concurrent handling.\n\t */\n\tpublic boolean hasConcurrentResult() {\n\t\treturn (this.concurrentResult != RESULT_NONE);\n\t}\n\n\t/**\n\t * Get the result from concurrent handling.\n\t * @return an Object, possibly an {@code Exception} or {@code Throwable} if\n\t * concurrent handling raised one\n\t * @see #clearConcurrentResult()\n\t */\n\tpublic @Nullable Object getConcurrentResult() {\n\t\treturn this.concurrentResult;\n\t}\n\n\t/**\n\t * Get the additional processing context saved at the start of concurrent handling.\n\t * @see #clearConcurrentResult()\n\t */\n\tpublic Object @Nullable [] getConcurrentResultContext() {\n\t\treturn this.concurrentResultContext;\n\t}\n\n\t/**\n\t * Get the {@link CallableProcessingInterceptor} registered under the given key.\n\t * @param key the key\n\t * @return the interceptor registered under that key, or {@code null} if none\n\t */\n\tpublic @Nullable CallableProcessingInterceptor getCallableInterceptor(Object key) {\n\t\treturn this.callableInterceptors.get(key);\n\t}\n\n\t/**\n\t * Get the {@link DeferredResultProcessingInterceptor} registered under the given key.\n\t * @param key the key\n\t * @return the interceptor registered under that key, or {@code null} if none\n\t */\n\tpublic @Nullable DeferredResultProcessingInterceptor getDeferredResultInterceptor(Object key) {\n\t\treturn this.deferredResultInterceptors.get(key);\n\t}\n\n\t/**\n\t * Register a {@link CallableProcessingInterceptor} under the given key.\n\t * @param key the key\n\t * @param interceptor the interceptor to register\n\t */\n\tpublic void registerCallableInterceptor(Object key, CallableProcessingInterceptor interceptor) {\n\t\tAssert.notNull(key, \"Key is required\");\n\t\tAssert.notNull(interceptor, \"CallableProcessingInterceptor is required\");\n\t\tthis.callableInterceptors.put(key, interceptor);\n\t}\n\n\t/**\n\t * Register a {@link CallableProcessingInterceptor} without a key.\n\t * The key is derived from the class name and hash code.\n\t * @param interceptors one or more interceptors to register\n\t */\n\tpublic void registerCallableInterceptors(CallableProcessingInterceptor... interceptors) {\n\t\tAssert.notNull(interceptors, \"A CallableProcessingInterceptor is required\");\n\t\tfor (CallableProcessingInterceptor interceptor : interceptors) {\n\t\t\tString key = interceptor.getClass().getName() + \":\" + interceptor.hashCode();\n\t\t\tthis.callableInterceptors.put(key, interceptor);\n\t\t}\n\t}\n\n\t/**\n\t * Register a {@link DeferredResultProcessingInterceptor} under the given key.\n\t * @param key the key\n\t * @param interceptor the interceptor to register\n\t */\n\tpublic void registerDeferredResultInterceptor(Object key, DeferredResultProcessingInterceptor interceptor) {\n\t\tAssert.notNull(key, \"Key is required\");\n\t\tAssert.notNull(interceptor, \"DeferredResultProcessingInterceptor is required\");\n\t\tthis.deferredResultInterceptors.put(key, interceptor);\n\t}\n\n\t/**\n\t * Register one or more {@link DeferredResultProcessingInterceptor DeferredResultProcessingInterceptors}\n\t * without a specified key. The default key is derived from the interceptor class name and hash code.\n\t * @param interceptors one or more interceptors to register\n\t */\n\tpublic void registerDeferredResultInterceptors(DeferredResultProcessingInterceptor... interceptors) {\n\t\tAssert.notNull(interceptors, \"A DeferredResultProcessingInterceptor is required\");\n\t\tfor (DeferredResultProcessingInterceptor interceptor : interceptors) {\n\t\t\tString key = interceptor.getClass().getName() + \":\" + interceptor.hashCode();\n\t\t\tthis.deferredResultInterceptors.put(key, interceptor);\n\t\t}\n\t}\n\n\t/**\n\t * Mark the {@link WebAsyncManager} as wrapping a multipart async request.\n\t * @since 6.1.12\n\t */\n\tpublic void setMultipartRequestParsed(boolean isMultipart) {\n\t\tthis.isMultipartRequestParsed = isMultipart;\n\t}\n\n\t/**\n\t * Return {@code true} if this {@link WebAsyncManager} was previously marked\n\t * as wrapping a multipart async request, {@code false} otherwise.\n\t * @since 6.1.12\n\t */\n\tpublic boolean isMultipartRequestParsed() {\n\t\treturn this.isMultipartRequestParsed;\n\t}\n\n\t/**\n\t * Clear {@linkplain #getConcurrentResult() concurrentResult} and\n\t * {@linkplain #getConcurrentResultContext() concurrentResultContext}.\n\t */\n\tpublic void clearConcurrentResult() {\n\t\tif (!this.state.compareAndSet(State.RESULT_SET, State.NOT_STARTED)) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Unexpected call to clear: [\" + this.state.get() + \"]\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tsynchronized (WebAsyncManager.this) {\n\t\t\tthis.concurrentResult = RESULT_NONE;\n\t\t\tthis.concurrentResultContext = null;\n\t\t}\n\t}\n\n\t/**\n\t * Start concurrent request processing and execute the given task with an\n\t * {@link #setTaskExecutor(AsyncTaskExecutor) AsyncTaskExecutor}. The result\n\t * from the task execution is saved and the request dispatched in order to\n\t * resume processing of that result. If the task raises an Exception then\n\t * the saved result will be the raised Exception.\n\t * @param callable a unit of work to be executed asynchronously\n\t * @param processingContext additional context to save that can be accessed\n\t * via {@link #getConcurrentResultContext()}\n\t * @throws Exception if concurrent processing failed to start\n\t * @see #getConcurrentResult()\n\t * @see #getConcurrentResultContext()\n\t */\n\t@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n\tpublic void startCallableProcessing(Callable<?> callable, Object... processingContext) throws Exception {\n\t\tAssert.notNull(callable, \"Callable must not be null\");\n\t\tstartCallableProcessing(new WebAsyncTask(callable), processingContext);\n\t}\n\n\t/**\n\t * Use the given {@link WebAsyncTask} to configure the task executor as well as\n\t * the timeout value of the {@code AsyncWebRequest} before delegating to\n\t * {@link #startCallableProcessing(Callable, Object...)}.\n\t * @param webAsyncTask a WebAsyncTask containing the target {@code Callable}\n\t * @param processingContext additional context to save that can be accessed\n\t * via {@link #getConcurrentResultContext()}\n\t * @throws Exception if concurrent processing failed to start\n\t */\n\t@SuppressWarnings(\"NullAway\") // Lambda\n\tpublic void startCallableProcessing(final WebAsyncTask<?> webAsyncTask, Object... processingContext)\n\t\t\tthrows Exception {\n\n\t\tAssert.notNull(webAsyncTask, \"WebAsyncTask must not be null\");\n\t\tAssert.state(this.asyncWebRequest != null, \"AsyncWebRequest must not be null\");\n\n\t\tif (!this.state.compareAndSet(State.NOT_STARTED, State.ASYNC_PROCESSING)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Unexpected call to startCallableProcessing: [\" + this.state.get() + \"]\");\n\t\t}\n\n\t\tLong timeout = webAsyncTask.getTimeout();\n\t\tif (timeout != null) {\n\t\t\tthis.asyncWebRequest.setTimeout(timeout);\n\t\t}\n\n\t\tAsyncTaskExecutor executor = webAsyncTask.getExecutor();\n\t\tif (executor != null) {\n\t\t\tthis.taskExecutor = executor;\n\t\t}\n\n\t\tList<CallableProcessingInterceptor> interceptors = new ArrayList<>();\n\t\tinterceptors.add(webAsyncTask.getInterceptor());\n\t\tinterceptors.addAll(this.callableInterceptors.values());\n\t\tinterceptors.add(timeoutCallableInterceptor);\n\n\t\tfinal Callable<?> callable = webAsyncTask.getCallable();\n\t\tfinal CallableInterceptorChain interceptorChain = new CallableInterceptorChain(interceptors);\n\n\t\tthis.asyncWebRequest.addTimeoutHandler(() -> {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Servlet container timeout notification for \" + formatUri(this.asyncWebRequest));\n\t\t\t}\n\t\t\tObject result = interceptorChain.triggerAfterTimeout(this.asyncWebRequest, callable);\n\t\t\tif (result != CallableProcessingInterceptor.RESULT_NONE) {\n\t\t\t\tsetConcurrentResultAndDispatch(result);\n\t\t\t}\n\t\t});\n\n\t\tthis.asyncWebRequest.addErrorHandler(ex -> {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Servlet container error notification for \" + formatUri(this.asyncWebRequest) + \": \" + ex);\n\t\t\t}\n\t\t\tObject result = interceptorChain.triggerAfterError(this.asyncWebRequest, callable, ex);\n\t\t\tresult = (result != CallableProcessingInterceptor.RESULT_NONE ? result : ex);\n\t\t\tsetConcurrentResultAndDispatch(result);\n\t\t});\n\n\t\tthis.asyncWebRequest.addCompletionHandler(() ->\n\t\t\t\tinterceptorChain.triggerAfterCompletion(this.asyncWebRequest, callable));\n\n\t\tinterceptorChain.applyBeforeConcurrentHandling(this.asyncWebRequest, callable);\n\t\tstartAsyncProcessing(processingContext);\n\t\ttry {\n\t\t\tFuture<?> future = this.taskExecutor.submit(() -> {\n\t\t\t\tObject result = null;\n\t\t\t\ttry {\n\t\t\t\t\tinterceptorChain.applyPreProcess(this.asyncWebRequest, callable);\n\t\t\t\t\tresult = callable.call();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tresult = ex;\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tresult = interceptorChain.applyPostProcess(this.asyncWebRequest, callable, result);\n\t\t\t\t}\n\t\t\t\tsetConcurrentResultAndDispatch(result);\n\t\t\t});\n\t\t\tinterceptorChain.setTaskFuture(future);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tObject result = interceptorChain.applyPostProcess(this.asyncWebRequest, callable, ex);\n\t\t\tsetConcurrentResultAndDispatch(result);\n\t\t}\n\t}\n\n\t/**\n\t * Start concurrent request processing and initialize the given\n\t * {@link DeferredResult} with a {@link DeferredResultHandler} that saves\n\t * the result and dispatches the request to resume processing of that\n\t * result. The {@code AsyncWebRequest} is also updated with a completion\n\t * handler that expires the {@code DeferredResult} and a timeout handler\n\t * assuming the {@code DeferredResult} has a default timeout result.\n\t * @param deferredResult the DeferredResult instance to initialize\n\t * @param processingContext additional context to save that can be accessed\n\t * via {@link #getConcurrentResultContext()}\n\t * @throws Exception if concurrent processing failed to start\n\t * @see #getConcurrentResult()\n\t * @see #getConcurrentResultContext()\n\t */\n\t@SuppressWarnings(\"NullAway\") // Lambda\n\tpublic void startDeferredResultProcessing(\n\t\t\tfinal DeferredResult<?> deferredResult, Object... processingContext) throws Exception {\n\n\t\tAssert.notNull(deferredResult, \"DeferredResult must not be null\");\n\t\tAssert.state(this.asyncWebRequest != null, \"AsyncWebRequest must not be null\");\n\n\t\tif (!this.state.compareAndSet(State.NOT_STARTED, State.ASYNC_PROCESSING)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Unexpected call to startDeferredResultProcessing: [\" + this.state.get() + \"]\");\n\t\t}\n\n\t\tLong timeout = deferredResult.getTimeoutValue();\n\t\tif (timeout != null) {\n\t\t\tthis.asyncWebRequest.setTimeout(timeout);\n\t\t}\n\n\t\tList<DeferredResultProcessingInterceptor> interceptors = new ArrayList<>();\n\t\tinterceptors.add(deferredResult.getLifecycleInterceptor());\n\t\tinterceptors.addAll(this.deferredResultInterceptors.values());\n\t\tinterceptors.add(timeoutDeferredResultInterceptor);\n\n\t\tfinal DeferredResultInterceptorChain interceptorChain = new DeferredResultInterceptorChain(interceptors);\n\n\t\tthis.asyncWebRequest.addTimeoutHandler(() -> {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Servlet container timeout notification for \" + formatUri(this.asyncWebRequest));\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tinterceptorChain.triggerAfterTimeout(this.asyncWebRequest, deferredResult);\n\t\t\t\tsynchronized (WebAsyncManager.this) {\n\t\t\t\t\t// If application thread set the DeferredResult first in a race,\n\t\t\t\t\t// we must still not return until setConcurrentResultAndDispatch is done\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tsetConcurrentResultAndDispatch(ex);\n\t\t\t}\n\t\t});\n\n\t\tthis.asyncWebRequest.addErrorHandler(ex -> {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Servlet container error notification for \" + formatUri(this.asyncWebRequest));\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tinterceptorChain.triggerAfterError(this.asyncWebRequest, deferredResult, ex);\n\t\t\t\tsynchronized (WebAsyncManager.this) {\n\t\t\t\t\t// If application thread set the DeferredResult first in a race,\n\t\t\t\t\t// we must still not return until setConcurrentResultAndDispatch is done\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable interceptorEx) {\n\t\t\t\tsetConcurrentResultAndDispatch(interceptorEx);\n\t\t\t}\n\t\t});\n\n\t\tthis.asyncWebRequest.addCompletionHandler(() ->\n\t\t\t\tinterceptorChain.triggerAfterCompletion(this.asyncWebRequest, deferredResult));\n\n\t\tinterceptorChain.applyBeforeConcurrentHandling(this.asyncWebRequest, deferredResult);\n\t\tstartAsyncProcessing(processingContext);\n\n\t\ttry {\n\t\t\tinterceptorChain.applyPreProcess(this.asyncWebRequest, deferredResult);\n\t\t\tdeferredResult.setResultHandler(result -> {\n\t\t\t\tresult = interceptorChain.applyPostProcess(this.asyncWebRequest, deferredResult, result);\n\t\t\t\tsetConcurrentResultAndDispatch(result);\n\t\t\t});\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tsetConcurrentResultAndDispatch(ex);\n\t\t}\n\t}\n\n\tprivate void startAsyncProcessing(Object[] processingContext) {\n\t\tsynchronized (WebAsyncManager.this) {\n\t\t\tthis.concurrentResult = RESULT_NONE;\n\t\t\tthis.concurrentResultContext = processingContext;\n\t\t}\n\n\t\tAssert.state(this.asyncWebRequest != null, \"AsyncWebRequest must not be null\");\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Started async request for \" + formatUri(this.asyncWebRequest));\n\t\t}\n\n\t\tthis.asyncWebRequest.startAsync();\n\t}\n\n\tprivate void setConcurrentResultAndDispatch(@Nullable Object result) {\n\t\tAssert.state(this.asyncWebRequest != null, \"AsyncWebRequest must not be null\");\n\t\tsynchronized (WebAsyncManager.this) {\n\t\t\tif (!this.state.compareAndSet(State.ASYNC_PROCESSING, State.RESULT_SET)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Async result already set: [\" + this.state.get() + \"], \" +\n\t\t\t\t\t\t\t\"ignored result for \" + formatUri(this.asyncWebRequest));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.concurrentResult = result;\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Async result set for \" + formatUri(this.asyncWebRequest));\n\t\t\t}\n\n\t\t\tif (this.asyncWebRequest.isAsyncComplete()) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Async request already completed for \" + formatUri(this.asyncWebRequest));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Performing async dispatch for \" + formatUri(this.asyncWebRequest));\n\t\t\t}\n\t\t\tthis.asyncWebRequest.dispatch();\n\t\t}\n\t}\n\n\tprivate static String formatUri(AsyncWebRequest asyncWebRequest) {\n\t\tHttpServletRequest request = asyncWebRequest.getNativeRequest(HttpServletRequest.class);\n\t\treturn (request != null ? \"\\\"\" + request.getRequestURI() + \"\\\"\" : \"servlet container\");\n\t}\n\n\n\t/**\n\t * Represents a state for {@link WebAsyncManager} to be in.\n\t * <p><pre>\n\t *     +------> NOT_STARTED <------+\n\t *     |             |             |\n\t *     |             v             |\n\t *     |      ASYNC_PROCESSING     |\n\t *     |             |             |\n\t *     |             v             |\n\t *     <-------+ RESULT_SET -------+\n\t * </pre>\n\t * @since 5.3.33\n\t */\n\tprivate enum State {\n\n\t\t/** No async processing in progress. */\n\t\tNOT_STARTED,\n\n\t\t/** Async handling has started, but the result hasn't been set yet. */\n\t\tASYNC_PROCESSING,\n\n\t\t/** The result is set, and an async dispatch was performed, unless there is a network error. */\n\t\tRESULT_SET\n\n\t}\n\n}"
  },
  "org.springframework.web.context.request.async.WebAsyncManager#clearConcurrentResult()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Clear {@linkplain #getConcurrentResult() concurrentResult} and\n\t * {@linkplain #getConcurrentResultContext() concurrentResultContext}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "void",
    "signature": "public void clearConcurrentResult()",
    "source_code": "\tpublic void clearConcurrentResult() {\n\t\tif (!this.state.compareAndSet(State.RESULT_SET, State.NOT_STARTED)) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Unexpected call to clear: [\" + this.state.get() + \"]\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tsynchronized (WebAsyncManager.this) {\n\t\t\tthis.concurrentResult = RESULT_NONE;\n\t\t\tthis.concurrentResultContext = null;\n\t\t}\n\t}"
  },
  "org.springframework.web.context.request.async.WebAsyncManager#getAsyncWebRequest()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the current {@link AsyncWebRequest}.\n\t * @since 5.3.33\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "AsyncWebRequest",
    "signature": "public AsyncWebRequest getAsyncWebRequest()",
    "source_code": "\tpublic @Nullable AsyncWebRequest getAsyncWebRequest() {\n\t\treturn this.asyncWebRequest;\n\t}"
  },
  "org.springframework.web.context.request.async.WebAsyncManager#getCallableInterceptor(key)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link CallableProcessingInterceptor} registered under the given key.\n\t * @param key the key\n\t * @return the interceptor registered under that key, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "CallableProcessingInterceptor",
    "signature": "public CallableProcessingInterceptor getCallableInterceptor(Object key)",
    "source_code": "\tpublic @Nullable CallableProcessingInterceptor getCallableInterceptor(Object key) {\n\t\treturn this.callableInterceptors.get(key);\n\t}"
  },
  "org.springframework.web.context.request.async.WebAsyncManager#getConcurrentResult()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the result from concurrent handling.\n\t * @return an Object, possibly an {@code Exception} or {@code Throwable} if\n\t * concurrent handling raised one\n\t * @see #clearConcurrentResult()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "Object",
    "signature": "public Object getConcurrentResult()",
    "source_code": "\tpublic @Nullable Object getConcurrentResult() {\n\t\treturn this.concurrentResult;\n\t}"
  },
  "org.springframework.web.context.request.async.WebAsyncManager#getDeferredResultInterceptor(key)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link DeferredResultProcessingInterceptor} registered under the given key.\n\t * @param key the key\n\t * @return the interceptor registered under that key, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "DeferredResultProcessingInterceptor",
    "signature": "public DeferredResultProcessingInterceptor getDeferredResultInterceptor(Object key)",
    "source_code": "\tpublic @Nullable DeferredResultProcessingInterceptor getDeferredResultInterceptor(Object key) {\n\t\treturn this.deferredResultInterceptors.get(key);\n\t}"
  },
  "org.springframework.web.context.request.async.WebAsyncManager#hasConcurrentResult()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether a result value exists as a result of concurrent handling.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "boolean",
    "signature": "public boolean hasConcurrentResult()",
    "source_code": "\tpublic boolean hasConcurrentResult() {\n\t\treturn (this.concurrentResult != RESULT_NONE);\n\t}"
  },
  "org.springframework.web.context.request.async.WebAsyncManager#isConcurrentHandlingStarted()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the selected handler for the current request chose to handle\n\t * the request asynchronously. A return value of \"true\" indicates concurrent\n\t * handling is under way and the response will remain open. A return value\n\t * of \"false\" means concurrent handling was either not started or possibly\n\t * that it has completed and the request was dispatched for further\n\t * processing of the concurrent result.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "boolean",
    "signature": "public boolean isConcurrentHandlingStarted()",
    "source_code": "\tpublic boolean isConcurrentHandlingStarted() {\n\t\treturn (this.asyncWebRequest != null && this.asyncWebRequest.isAsyncStarted());\n\t}"
  },
  "org.springframework.web.context.request.async.WebAsyncManager#isMultipartRequestParsed()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if this {@link WebAsyncManager} was previously marked\n\t * as wrapping a multipart async request, {@code false} otherwise.\n\t * @since 6.1.12\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "boolean",
    "signature": "public boolean isMultipartRequestParsed()",
    "source_code": "\tpublic boolean isMultipartRequestParsed() {\n\t\treturn this.isMultipartRequestParsed;\n\t}"
  },
  "org.springframework.web.context.request.async.WebAsyncManager#registerCallableInterceptor(key,interceptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a {@link CallableProcessingInterceptor} under the given key.\n\t * @param key the key\n\t * @param interceptor the interceptor to register\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "interceptor"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "void",
    "signature": "public void registerCallableInterceptor(Object key, CallableProcessingInterceptor interceptor)",
    "source_code": "\tpublic void registerCallableInterceptor(Object key, CallableProcessingInterceptor interceptor) {\n\t\tAssert.notNull(key, \"Key is required\");\n\t\tAssert.notNull(interceptor, \"CallableProcessingInterceptor is required\");\n\t\tthis.callableInterceptors.put(key, interceptor);\n\t}"
  },
  "org.springframework.web.context.request.async.WebAsyncManager#registerCallableInterceptors(interceptors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a {@link CallableProcessingInterceptor} without a key.\n\t * The key is derived from the class name and hash code.\n\t * @param interceptors one or more interceptors to register\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void registerCallableInterceptors(CallableProcessingInterceptor... interceptors)",
    "source_code": "\tpublic void registerCallableInterceptors(CallableProcessingInterceptor... interceptors) {\n\t\tAssert.notNull(interceptors, \"A CallableProcessingInterceptor is required\");\n\t\tfor (CallableProcessingInterceptor interceptor : interceptors) {\n\t\t\tString key = interceptor.getClass().getName() + \":\" + interceptor.hashCode();\n\t\t\tthis.callableInterceptors.put(key, interceptor);\n\t\t}\n\t}"
  },
  "org.springframework.web.context.request.async.WebAsyncManager#registerDeferredResultInterceptor(key,interceptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a {@link DeferredResultProcessingInterceptor} under the given key.\n\t * @param key the key\n\t * @param interceptor the interceptor to register\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "interceptor"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "void",
    "signature": "public void registerDeferredResultInterceptor(Object key, DeferredResultProcessingInterceptor interceptor)",
    "source_code": "\tpublic void registerDeferredResultInterceptor(Object key, DeferredResultProcessingInterceptor interceptor) {\n\t\tAssert.notNull(key, \"Key is required\");\n\t\tAssert.notNull(interceptor, \"DeferredResultProcessingInterceptor is required\");\n\t\tthis.deferredResultInterceptors.put(key, interceptor);\n\t}"
  },
  "org.springframework.web.context.request.async.WebAsyncManager#registerDeferredResultInterceptors(interceptors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register one or more {@link DeferredResultProcessingInterceptor DeferredResultProcessingInterceptors}\n\t * without a specified key. The default key is derived from the interceptor class name and hash code.\n\t * @param interceptors one or more interceptors to register\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "void",
    "signature": "public void registerDeferredResultInterceptors(DeferredResultProcessingInterceptor... interceptors)",
    "source_code": "\tpublic void registerDeferredResultInterceptors(DeferredResultProcessingInterceptor... interceptors) {\n\t\tAssert.notNull(interceptors, \"A DeferredResultProcessingInterceptor is required\");\n\t\tfor (DeferredResultProcessingInterceptor interceptor : interceptors) {\n\t\t\tString key = interceptor.getClass().getName() + \":\" + interceptor.hashCode();\n\t\t\tthis.deferredResultInterceptors.put(key, interceptor);\n\t\t}\n\t}"
  },
  "org.springframework.web.context.request.async.WebAsyncManager#setAsyncWebRequest(asyncWebRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link AsyncWebRequest} to use. This property may be set\n\t * more than once during a single request to accurately reflect the current\n\t * state of the request (for example, following a forward, request/response\n\t * wrapping, etc). However, it should not be set while concurrent handling\n\t * is in progress, i.e. while {@link #isConcurrentHandlingStarted()} is\n\t * {@code true}.\n\t * @param asyncWebRequest the web request to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "asyncWebRequest"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void setAsyncWebRequest(AsyncWebRequest asyncWebRequest)",
    "source_code": "\tpublic void setAsyncWebRequest(AsyncWebRequest asyncWebRequest) {\n\t\tAssert.notNull(asyncWebRequest, \"AsyncWebRequest must not be null\");\n\t\tthis.asyncWebRequest = asyncWebRequest;\n\t\tthis.asyncWebRequest.addCompletionHandler(() -> asyncWebRequest.removeAttribute(\n\t\t\t\tWebAsyncUtils.WEB_ASYNC_MANAGER_ATTRIBUTE, RequestAttributes.SCOPE_REQUEST));\n\t}"
  },
  "org.springframework.web.context.request.async.WebAsyncManager#setMultipartRequestParsed(isMultipart)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Mark the {@link WebAsyncManager} as wrapping a multipart async request.\n\t * @since 6.1.12\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "isMultipart"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "void",
    "signature": "public void setMultipartRequestParsed(boolean isMultipart)",
    "source_code": "\tpublic void setMultipartRequestParsed(boolean isMultipart) {\n\t\tthis.isMultipartRequestParsed = isMultipart;\n\t}"
  },
  "org.springframework.web.context.request.async.WebAsyncManager#setTaskExecutor(taskExecutor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure an AsyncTaskExecutor for use with concurrent processing via\n\t * {@link #startCallableProcessing(Callable, Object...)}.\n\t * <p>By default a {@link SimpleAsyncTaskExecutor} instance is used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "taskExecutor"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void setTaskExecutor(AsyncTaskExecutor taskExecutor)",
    "source_code": "\tpublic void setTaskExecutor(AsyncTaskExecutor taskExecutor) {\n\t\tthis.taskExecutor = taskExecutor;\n\t}"
  },
  "org.springframework.web.context.request.async.WebAsyncManager#startCallableProcessing(callable,processingContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Start concurrent request processing and execute the given task with an\n\t * {@link #setTaskExecutor(AsyncTaskExecutor) AsyncTaskExecutor}. The result\n\t * from the task execution is saved and the request dispatched in order to\n\t * resume processing of that result. If the task raises an Exception then\n\t * the saved result will be the raised Exception.\n\t * @param callable a unit of work to be executed asynchronously\n\t * @param processingContext additional context to save that can be accessed\n\t * via {@link #getConcurrentResultContext()}\n\t * @throws Exception if concurrent processing failed to start\n\t * @see #getConcurrentResult()\n\t * @see #getConcurrentResultContext()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callable",
      "processingContext"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "void",
    "signature": "public void startCallableProcessing(Callable<?> callable, Object... processingContext)",
    "source_code": "\tpublic void startCallableProcessing(Callable<?> callable, Object... processingContext) throws Exception {\n\t\tAssert.notNull(callable, \"Callable must not be null\");\n\t\tstartCallableProcessing(new WebAsyncTask(callable), processingContext);\n\t}"
  },
  "org.springframework.web.context.request.async.WebAsyncManager#startCallableProcessing(webAsyncTask,processingContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Use the given {@link WebAsyncTask} to configure the task executor as well as\n\t * the timeout value of the {@code AsyncWebRequest} before delegating to\n\t * {@link #startCallableProcessing(Callable, Object...)}.\n\t * @param webAsyncTask a WebAsyncTask containing the target {@code Callable}\n\t * @param processingContext additional context to save that can be accessed\n\t * via {@link #getConcurrentResultContext()}\n\t * @throws Exception if concurrent processing failed to start\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webAsyncTask",
      "processingContext"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "void",
    "signature": "public void startCallableProcessing(final WebAsyncTask<?> webAsyncTask, Object... processingContext)",
    "source_code": "\tpublic void startCallableProcessing(final WebAsyncTask<?> webAsyncTask, Object... processingContext)"
  },
  "org.springframework.web.context.request.async.WebAsyncManager#startDeferredResultProcessing(deferredResult,processingContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Start concurrent request processing and initialize the given\n\t * {@link DeferredResult} with a {@link DeferredResultHandler} that saves\n\t * the result and dispatches the request to resume processing of that\n\t * result. The {@code AsyncWebRequest} is also updated with a completion\n\t * handler that expires the {@code DeferredResult} and a timeout handler\n\t * assuming the {@code DeferredResult} has a default timeout result.\n\t * @param deferredResult the DeferredResult instance to initialize\n\t * @param processingContext additional context to save that can be accessed\n\t * via {@link #getConcurrentResultContext()}\n\t * @throws Exception if concurrent processing failed to start\n\t * @see #getConcurrentResult()\n\t * @see #getConcurrentResultContext()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "deferredResult",
      "processingContext"
    ],
    "position": {
      "column": 1,
      "line": 393
    },
    "return": "void",
    "signature": "public void startDeferredResultProcessing(final DeferredResult<?> deferredResult, Object... processingContext)",
    "source_code": "\tpublic void startDeferredResultProcessing("
  },
  "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#getConfigLocations()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "String[]",
    "signature": "public String[] getConfigLocations()",
    "source_code": "\tpublic String[] getConfigLocations() {\n\t\treturn super.getConfigLocations();\n\t}"
  },
  "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#getTheme(themeName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "themeName"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "Theme",
    "signature": "public Theme getTheme(String themeName)",
    "source_code": "\tpublic Theme getTheme(String themeName) {\n\t\tAssert.state(this.themeSource != null, \"No ThemeSource available\");\n\t\treturn this.themeSource.getTheme(themeName);\n\t}"
  },
  "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#onRefresh()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the theme capability.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "protected void onRefresh()",
    "source_code": "\tprotected void onRefresh() {\n\t\tthis.themeSource = UiApplicationContextUtils.initThemeSource(this);\n\t}"
  },
  "org.springframework.web.context.support.GenericWebApplicationContext#getTheme(themeName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "themeName"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "Theme",
    "signature": "public Theme getTheme(String themeName)",
    "source_code": "\tpublic Theme getTheme(String themeName) {\n\t\tAssert.state(this.themeSource != null, \"No ThemeSource available\");\n\t\treturn this.themeSource.getTheme(themeName);\n\t}"
  },
  "org.springframework.web.context.support.GenericWebApplicationContext#onRefresh()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the theme capability.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "protected void onRefresh()",
    "source_code": "\tprotected void onRefresh() {\n\t\tthis.themeSource = UiApplicationContextUtils.initThemeSource(this);\n\t}"
  },
  "org.springframework.web.context.support.StaticWebApplicationContext": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Static {@link org.springframework.web.context.WebApplicationContext}\n * implementation for testing. Not intended for use in production applications.\n *\n * <p>Implements the {@link org.springframework.web.context.ConfigurableWebApplicationContext}\n * interface to allow for direct replacement of an {@link XmlWebApplicationContext},\n * despite not actually supporting external configuration files.\n *\n * <p>Interprets resource paths as servlet context resources, i.e. as paths beneath\n * the web application root. Absolute paths, for example, for files outside the web app root,\n * can be accessed via \"file:\" URLs, as implemented by\n * {@link org.springframework.core.io.DefaultResourceLoader}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class StaticWebApplicationContext",
    "source_code": "public class StaticWebApplicationContext extends StaticApplicationContext"
  },
  "org.springframework.web.context.support.StaticWebApplicationContext#createEnvironment()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create and return a new {@link StandardServletEnvironment}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "ConfigurableEnvironment",
    "signature": "protected ConfigurableEnvironment createEnvironment()",
    "source_code": "\tprotected ConfigurableEnvironment createEnvironment() {\n\t\treturn new StandardServletEnvironment();\n\t}"
  },
  "org.springframework.web.context.support.StaticWebApplicationContext#getNamespace()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "String",
    "signature": "public String getNamespace()",
    "source_code": "\tpublic @Nullable String getNamespace() {\n\t\treturn this.namespace;\n\t}"
  },
  "org.springframework.web.context.support.StaticWebApplicationContext#getResourceByPath(path)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation supports file paths beneath the root of the ServletContext.\n\t * @see ServletContextResource\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "Resource",
    "signature": "protected Resource getResourceByPath(String path)",
    "source_code": "\tprotected Resource getResourceByPath(String path) {\n\t\tAssert.state(this.servletContext != null, \"No ServletContext available\");\n\t\treturn new ServletContextResource(this.servletContext, path);\n\t}"
  },
  "org.springframework.web.context.support.StaticWebApplicationContext#getResourcePatternResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation supports pattern matching in unexpanded WARs too.\n\t * @see ServletContextResourcePatternResolver\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "ResourcePatternResolver",
    "signature": "protected ResourcePatternResolver getResourcePatternResolver()",
    "source_code": "\tprotected ResourcePatternResolver getResourcePatternResolver() {\n\t\treturn new ServletContextResourcePatternResolver(this);\n\t}"
  },
  "org.springframework.web.context.support.StaticWebApplicationContext#getServletConfig()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "ServletConfig",
    "signature": "public ServletConfig getServletConfig()",
    "source_code": "\tpublic @Nullable ServletConfig getServletConfig() {\n\t\treturn this.servletConfig;\n\t}"
  },
  "org.springframework.web.context.support.StaticWebApplicationContext#getServletContext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "ServletContext",
    "signature": "public ServletContext getServletContext()",
    "source_code": "\tpublic @Nullable ServletContext getServletContext() {\n\t\treturn this.servletContext;\n\t}"
  },
  "org.springframework.web.context.support.StaticWebApplicationContext#initPropertySources()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "void",
    "signature": "protected void initPropertySources()",
    "source_code": "\tprotected void initPropertySources() {\n\t\tWebApplicationContextUtils.initServletPropertySources(getEnvironment().getPropertySources(),\n\t\t\t\tthis.servletContext, this.servletConfig);\n\t}"
  },
  "org.springframework.web.context.support.StaticWebApplicationContext#postProcessBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register request/session scopes, a {@link ServletContextAwareProcessor}, etc.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)",
    "source_code": "\tprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n\t\tbeanFactory.addBeanPostProcessor(new ServletContextAwareProcessor(this.servletContext, this.servletConfig));\n\t\tbeanFactory.ignoreDependencyInterface(ServletContextAware.class);\n\t\tbeanFactory.ignoreDependencyInterface(ServletConfigAware.class);\n\n\t\tWebApplicationContextUtils.registerWebApplicationScopes(beanFactory, this.servletContext);\n\t\tWebApplicationContextUtils.registerEnvironmentBeans(beanFactory, this.servletContext, this.servletConfig);\n\t}"
  },
  "org.springframework.web.context.support.StaticWebApplicationContext#setConfigLocation(configLocation)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@link StaticWebApplicationContext} class does not support this method.\n\t * @throws UnsupportedOperationException <b>always</b>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configLocation"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void setConfigLocation(String configLocation)",
    "source_code": "\tpublic void setConfigLocation(String configLocation) {\n\t\tthrow new UnsupportedOperationException(\"StaticWebApplicationContext does not support config locations\");\n\t}"
  },
  "org.springframework.web.context.support.StaticWebApplicationContext#setConfigLocations(configLocations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@link StaticWebApplicationContext} class does not support this method.\n\t * @throws UnsupportedOperationException <b>always</b>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configLocations"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "void",
    "signature": "public void setConfigLocations(String... configLocations)",
    "source_code": "\tpublic void setConfigLocations(String... configLocations) {\n\t\tthrow new UnsupportedOperationException(\"StaticWebApplicationContext does not support config locations\");\n\t}"
  },
  "org.springframework.web.context.support.StaticWebApplicationContext#setNamespace(namespace)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "namespace"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void setNamespace(@Nullable String namespace)",
    "source_code": "\tpublic void setNamespace(@Nullable String namespace) {\n\t\tthis.namespace = namespace;\n\t\tif (namespace != null) {\n\t\t\tsetDisplayName(\"WebApplicationContext for namespace '\" + namespace + \"'\");\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.StaticWebApplicationContext#setServletConfig(servletConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletConfig"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "void",
    "signature": "public void setServletConfig(@Nullable ServletConfig servletConfig)",
    "source_code": "\tpublic void setServletConfig(@Nullable ServletConfig servletConfig) {\n\t\tthis.servletConfig = servletConfig;\n\t\tif (servletConfig != null && this.servletContext == null) {\n\t\t\tthis.servletContext = servletConfig.getServletContext();\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.StaticWebApplicationContext#setServletContext(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the ServletContext that this WebApplicationContext runs in.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "void",
    "signature": "public void setServletContext(@Nullable ServletContext servletContext)",
    "source_code": "\tpublic void setServletContext(@Nullable ServletContext servletContext) {\n\t\tthis.servletContext = servletContext;\n\t}"
  },
  "org.springframework.web.jsf.el.WebApplicationContextFacesELResolver#getFeatureDescriptors(elContext,base)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elContext",
      "base"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "Iterator<FeatureDescriptor>",
    "signature": "public Iterator<FeatureDescriptor> getFeatureDescriptors(ELContext elContext, Object base)",
    "source_code": "\tpublic Iterator<FeatureDescriptor> getFeatureDescriptors(ELContext elContext, Object base) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.method.support.ModelAndViewContainer#setIgnoreDefaultModelOnRedirect(ignoreDefaultModelOnRedirect)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * By default, the content of the \"default\" model is used both during\n\t * rendering and redirect scenarios. Alternatively controller methods\n\t * can declare an argument of type {@code RedirectAttributes} and use\n\t * it to provide attributes to prepare the redirect URL.\n\t * <p>Setting this flag to {@code true} guarantees the \"default\" model is\n\t * never used in a redirect scenario even if a RedirectAttributes argument\n\t * is not declared. Setting it to {@code false} means the \"default\" model\n\t * may be used in a redirect if the controller method doesn't declare a\n\t * RedirectAttributes argument.\n\t * <p>As of 6.0, this property is set to {@code true} by default.\n\t * @deprecated as of 6.0 without a replacement; once removed, the default\n\t * model will always be ignored on redirect\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ignoreDefaultModelOnRedirect"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void setIgnoreDefaultModelOnRedirect(boolean ignoreDefaultModelOnRedirect)",
    "source_code": "\tpublic void setIgnoreDefaultModelOnRedirect(boolean ignoreDefaultModelOnRedirect) {\n\t\tthis.ignoreDefaultModelOnRedirect = ignoreDefaultModelOnRedirect;\n\t}"
  },
  "org.springframework.web.reactive.config.WebFluxConfigurerComposite": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@link WebFluxConfigurer} that delegates to one or more others.\n *\n * @author Brian Clozel\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public class WebFluxConfigurerComposite",
    "source_code": "public class WebFluxConfigurerComposite implements WebFluxConfigurer {\n\n\tprivate final List<WebFluxConfigurer> delegates = new ArrayList<>();\n\n\n\tpublic void addWebFluxConfigurers(List<WebFluxConfigurer> configurers) {\n\t\tif (!CollectionUtils.isEmpty(configurers)) {\n\t\t\tthis.delegates.addAll(configurers);\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {\n\t\tthis.delegates.forEach(delegate -> delegate.configureHttpMessageCodecs(configurer));\n\t}\n\n\t@Override\n\tpublic void addFormatters(FormatterRegistry registry) {\n\t\tthis.delegates.forEach(delegate -> delegate.addFormatters(registry));\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"NullAway\") // https://github.com/uber/NullAway/issues/1128\n\tpublic @Nullable Validator getValidator() {\n\t\treturn createSingleBean(WebFluxConfigurer::getValidator, Validator.class);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"NullAway\") // https://github.com/uber/NullAway/issues/1128\n\tpublic @Nullable MessageCodesResolver getMessageCodesResolver() {\n\t\treturn createSingleBean(WebFluxConfigurer::getMessageCodesResolver, MessageCodesResolver.class);\n\t}\n\n\t@Override\n\tpublic void addCorsMappings(CorsRegistry registry) {\n\t\tthis.delegates.forEach(delegate -> delegate.addCorsMappings(registry));\n\t}\n\n\t@Override\n\tpublic void configureBlockingExecution(BlockingExecutionConfigurer configurer) {\n\t\tthis.delegates.forEach(delegate -> delegate.configureBlockingExecution(configurer));\n\t}\n\n\t@Override\n\tpublic void configureContentTypeResolver(RequestedContentTypeResolverBuilder builder) {\n\t\tthis.delegates.forEach(delegate -> delegate.configureContentTypeResolver(builder));\n\t}\n\n\t@Override\n\tpublic void configurePathMatching(PathMatchConfigurer configurer) {\n\t\tthis.delegates.forEach(delegate -> delegate.configurePathMatching(configurer));\n\t}\n\n\t@Override\n\tpublic void configureArgumentResolvers(ArgumentResolverConfigurer configurer) {\n\t\tthis.delegates.forEach(delegate -> delegate.configureArgumentResolvers(configurer));\n\t}\n\n\t@Override\n\tpublic void addErrorResponseInterceptors(List<ErrorResponse.Interceptor> interceptors) {\n\t\tfor (WebFluxConfigurer delegate : this.delegates) {\n\t\t\tdelegate.addErrorResponseInterceptors(interceptors);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void configureViewResolvers(ViewResolverRegistry registry) {\n\t\tthis.delegates.forEach(delegate -> delegate.configureViewResolvers(registry));\n\t}\n\n\t@Override\n\tpublic void addResourceHandlers(ResourceHandlerRegistry registry) {\n\t\tthis.delegates.forEach(delegate -> delegate.addResourceHandlers(registry));\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"NullAway\") // https://github.com/uber/NullAway/issues/1128\n\tpublic @Nullable WebSocketService getWebSocketService() {\n\t\treturn createSingleBean(WebFluxConfigurer::getWebSocketService, WebSocketService.class);\n\t}\n\n\tprivate <T> @Nullable T createSingleBean(Function<WebFluxConfigurer, @Nullable T> factory, Class<T> beanType) {\n\t\tList<T> result = this.delegates.stream().map(factory).filter(Objects::nonNull).toList();\n\t\tif (result.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\telse if (result.size() == 1) {\n\t\t\treturn result.get(0);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"More than one WebFluxConfigurer implements \" +\n\t\t\t\t\tbeanType.getSimpleName() + \" factory method.\");\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.config.WebFluxConfigurerComposite#addCorsMappings(registry)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "void",
    "signature": "public void addCorsMappings(CorsRegistry registry)",
    "source_code": "\tpublic void addCorsMappings(CorsRegistry registry) {\n\t\tthis.delegates.forEach(delegate -> delegate.addCorsMappings(registry));\n\t}"
  },
  "org.springframework.web.reactive.config.WebFluxConfigurerComposite#addErrorResponseInterceptors(interceptors)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void addErrorResponseInterceptors(List<ErrorResponse.Interceptor> interceptors)",
    "source_code": "\tpublic void addErrorResponseInterceptors(List<ErrorResponse.Interceptor> interceptors) {\n\t\tfor (WebFluxConfigurer delegate : this.delegates) {\n\t\t\tdelegate.addErrorResponseInterceptors(interceptors);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.config.WebFluxConfigurerComposite#addFormatters(registry)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "void",
    "signature": "public void addFormatters(FormatterRegistry registry)",
    "source_code": "\tpublic void addFormatters(FormatterRegistry registry) {\n\t\tthis.delegates.forEach(delegate -> delegate.addFormatters(registry));\n\t}"
  },
  "org.springframework.web.reactive.config.WebFluxConfigurerComposite#addResourceHandlers(registry)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void addResourceHandlers(ResourceHandlerRegistry registry)",
    "source_code": "\tpublic void addResourceHandlers(ResourceHandlerRegistry registry) {\n\t\tthis.delegates.forEach(delegate -> delegate.addResourceHandlers(registry));\n\t}"
  },
  "org.springframework.web.reactive.config.WebFluxConfigurerComposite#addWebFluxConfigurers(configurers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configurers"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "void",
    "signature": "public void addWebFluxConfigurers(List<WebFluxConfigurer> configurers)",
    "source_code": "\tpublic void addWebFluxConfigurers(List<WebFluxConfigurer> configurers) {\n\t\tif (!CollectionUtils.isEmpty(configurers)) {\n\t\t\tthis.delegates.addAll(configurers);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.config.WebFluxConfigurerComposite#configureArgumentResolvers(configurer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configurer"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void configureArgumentResolvers(ArgumentResolverConfigurer configurer)",
    "source_code": "\tpublic void configureArgumentResolvers(ArgumentResolverConfigurer configurer) {\n\t\tthis.delegates.forEach(delegate -> delegate.configureArgumentResolvers(configurer));\n\t}"
  },
  "org.springframework.web.reactive.config.WebFluxConfigurerComposite#configureBlockingExecution(configurer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configurer"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void configureBlockingExecution(BlockingExecutionConfigurer configurer)",
    "source_code": "\tpublic void configureBlockingExecution(BlockingExecutionConfigurer configurer) {\n\t\tthis.delegates.forEach(delegate -> delegate.configureBlockingExecution(configurer));\n\t}"
  },
  "org.springframework.web.reactive.config.WebFluxConfigurerComposite#configureContentTypeResolver(builder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void configureContentTypeResolver(RequestedContentTypeResolverBuilder builder)",
    "source_code": "\tpublic void configureContentTypeResolver(RequestedContentTypeResolverBuilder builder) {\n\t\tthis.delegates.forEach(delegate -> delegate.configureContentTypeResolver(builder));\n\t}"
  },
  "org.springframework.web.reactive.config.WebFluxConfigurerComposite#configureHttpMessageCodecs(configurer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configurer"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "void",
    "signature": "public void configureHttpMessageCodecs(ServerCodecConfigurer configurer)",
    "source_code": "\tpublic void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {\n\t\tthis.delegates.forEach(delegate -> delegate.configureHttpMessageCodecs(configurer));\n\t}"
  },
  "org.springframework.web.reactive.config.WebFluxConfigurerComposite#configurePathMatching(configurer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configurer"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "void",
    "signature": "public void configurePathMatching(PathMatchConfigurer configurer)",
    "source_code": "\tpublic void configurePathMatching(PathMatchConfigurer configurer) {\n\t\tthis.delegates.forEach(delegate -> delegate.configurePathMatching(configurer));\n\t}"
  },
  "org.springframework.web.reactive.config.WebFluxConfigurerComposite#configureViewResolvers(registry)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void configureViewResolvers(ViewResolverRegistry registry)",
    "source_code": "\tpublic void configureViewResolvers(ViewResolverRegistry registry) {\n\t\tthis.delegates.forEach(delegate -> delegate.configureViewResolvers(registry));\n\t}"
  },
  "org.springframework.web.reactive.config.WebFluxConfigurerComposite#getMessageCodesResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "MessageCodesResolver",
    "signature": "public MessageCodesResolver getMessageCodesResolver()",
    "source_code": "\tpublic @Nullable MessageCodesResolver getMessageCodesResolver() {\n\t\treturn createSingleBean(WebFluxConfigurer::getMessageCodesResolver, MessageCodesResolver.class);\n\t}"
  },
  "org.springframework.web.reactive.config.WebFluxConfigurerComposite#getValidator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "Validator",
    "signature": "public Validator getValidator()",
    "source_code": "\tpublic @Nullable Validator getValidator() {\n\t\treturn createSingleBean(WebFluxConfigurer::getValidator, Validator.class);\n\t}"
  },
  "org.springframework.web.reactive.config.WebFluxConfigurerComposite#getWebSocketService()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "WebSocketService",
    "signature": "public WebSocketService getWebSocketService()",
    "source_code": "\tpublic @Nullable WebSocketService getWebSocketService() {\n\t\treturn createSingleBean(WebFluxConfigurer::getWebSocketService, WebSocketService.class);\n\t}"
  },
  "org.springframework.web.reactive.function.BodyInserters#fromObject(body)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given object.\n\t * <p>Alternatively, consider using the {@code bodyValue(Object)} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param body the body to write to the response\n\t * @param <T> the type of the body\n\t * @return the inserter to write a single object\n\t * @throws IllegalArgumentException if {@code body} is a {@link Publisher} or an\n\t * instance of a type supported by {@link ReactiveAdapterRegistry#getSharedInstance()},\n\t * for which {@link #fromPublisher(Publisher, Class)} or\n\t * {@link #fromProducer(Object, Class)} should be used.\n\t * @see #fromPublisher(Publisher, Class)\n\t * @see #fromProducer(Object, Class)\n\t * @deprecated As of Spring Framework 5.2, in favor of {@link #fromValue(Object)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromObject(T body)",
    "source_code": "\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromObject(T body) {\n\t\treturn fromValue(body);\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#accept(acceptableMediaTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptableMediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec accept(MediaType... acceptableMediaTypes)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec accept(MediaType... acceptableMediaTypes) {\n\t\t\tgetHeaders().setAccept(Arrays.asList(acceptableMediaTypes));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#acceptCharset(acceptableCharsets)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptableCharsets"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec acceptCharset(Charset... acceptableCharsets)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec acceptCharset(Charset... acceptableCharsets) {\n\t\t\tgetHeaders().setAcceptCharset(Arrays.asList(acceptableCharsets));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#attribute(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attribute(String name, Object value)",
    "source_code": "\t\tpublic RequestBodySpec attribute(String name, Object value) {\n\t\t\tthis.attributes.put(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#attributes(Consumer<Map<String,attributesConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<Map<String",
      "attributesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer)",
    "source_code": "\t\tpublic RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer) {\n\t\t\tattributesConsumer.accept(this.attributes);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#contentLength(contentLength)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentLength"
    ],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec contentLength(long contentLength)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec contentLength(long contentLength) {\n\t\t\tgetHeaders().setContentLength(contentLength);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#contentType(contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec contentType(MediaType contentType)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec contentType(MediaType contentType) {\n\t\t\tgetHeaders().setContentType(contentType);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#cookie(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec cookie(String name, String value)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec cookie(String name, String value) {\n\t\t\tgetCookies().add(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#cookies(Consumer<MultiValueMap<String,cookiesConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<MultiValueMap<String",
      "cookiesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer) {\n\t\t\tcookiesConsumer.accept(getCookies());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#exchangeToFlux(Function<ClientResponse,responseHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ClientResponse",
      "responseHandler"
    ],
    "position": {
      "column": 1,
      "line": 407
    },
    "return": "Flux<V>",
    "signature": "public Flux<V> exchangeToFlux(Function<ClientResponse, ? extends Flux<V>> responseHandler)",
    "source_code": "\t\tpublic <V> Flux<V> exchangeToFlux(Function<ClientResponse, ? extends Flux<V>> responseHandler) {\n\t\t\treturn exchange().flatMapMany(response -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn responseHandler.apply(response)\n\t\t\t\t\t\t\t.concatWith(Flux.defer(() -> releaseIfNotConsumed(response).then(Mono.empty())))\n\t\t\t\t\t\t\t.onErrorResume(ex -> releaseIfNotConsumed(response, ex));\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\treturn releaseIfNotConsumed(response, ex);\n\t\t\t\t}\n\t\t\t});\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#exchangeToMono(Function<ClientResponse,responseHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ClientResponse",
      "responseHandler"
    ],
    "position": {
      "column": 1,
      "line": 392
    },
    "return": "Mono<V>",
    "signature": "public Mono<V> exchangeToMono(Function<ClientResponse, ? extends Mono<V>> responseHandler)",
    "source_code": "\t\tpublic <V> Mono<V> exchangeToMono(Function<ClientResponse, ? extends Mono<V>> responseHandler) {\n\t\t\treturn exchange().flatMap(response -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn responseHandler.apply(response)\n\t\t\t\t\t\t\t.flatMap(value -> releaseIfNotConsumed(response).thenReturn(value))\n\t\t\t\t\t\t\t.switchIfEmpty(Mono.defer(() -> releaseIfNotConsumed(response).then(Mono.empty())))\n\t\t\t\t\t\t\t.onErrorResume(ex -> releaseIfNotConsumed(response, ex));\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\treturn releaseIfNotConsumed(response, ex);\n\t\t\t\t}\n\t\t\t});\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#filter(request,next)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "next"
    ],
    "position": {
      "column": 1,
      "line": 710
    },
    "return": "Mono<ClientResponse>",
    "signature": "public Mono<ClientResponse> filter(ClientRequest request, ExchangeFunction next)",
    "source_code": "\t\tpublic Mono<ClientResponse> filter(ClientRequest request, ExchangeFunction next) {\n\t\t\treturn next.exchange(request).doOnNext(this.observationContext::setResponse);\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#header(headerName,headerValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tgetHeaders().add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#headers(headersConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headersConsumer"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec headers(Consumer<HttpHeaders> headersConsumer)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec headers(Consumer<HttpHeaders> headersConsumer) {\n\t\t\theadersConsumer.accept(getHeaders());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#httpRequest(requestConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestConsumer"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec httpRequest(Consumer<ClientHttpRequest> requestConsumer)",
    "source_code": "\t\tpublic RequestBodySpec httpRequest(Consumer<ClientHttpRequest> requestConsumer) {\n\t\t\tthis.httpRequestConsumer = (this.httpRequestConsumer != null ?\n\t\t\t\t\tthis.httpRequestConsumer.andThen(requestConsumer) : requestConsumer);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#ifModifiedSince(ifModifiedSince)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ifModifiedSince"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec ifModifiedSince(ZonedDateTime ifModifiedSince)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec ifModifiedSince(ZonedDateTime ifModifiedSince) {\n\t\t\tgetHeaders().setIfModifiedSince(ifModifiedSince);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#ifNoneMatch(ifNoneMatches)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ifNoneMatches"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec ifNoneMatch(String... ifNoneMatches)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec ifNoneMatch(String... ifNoneMatches) {\n\t\t\tgetHeaders().setIfNoneMatch(Arrays.asList(ifNoneMatches));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#method(httpMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "httpMethod"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "RequestBodyUriSpec",
    "signature": "public RequestBodyUriSpec method(HttpMethod httpMethod)",
    "source_code": "\tpublic RequestBodyUriSpec method(HttpMethod httpMethod) {\n\t\treturn methodInternal(httpMethod);\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#mutate()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "Builder",
    "signature": "public Builder mutate()",
    "source_code": "\tpublic Builder mutate() {\n\t\treturn new DefaultWebClientBuilder(this.builder);\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#onRawStatus(statusCodePredicate,Function<ClientResponse,exceptionFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCodePredicate",
      "Function<ClientResponse",
      "exceptionFunction"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec onRawStatus(IntPredicate statusCodePredicate,\n\t\t\t\tFunction<ClientResponse, Mono<? extends Throwable>> exceptionFunction)",
    "source_code": "\t\tpublic ResponseSpec onRawStatus(IntPredicate statusCodePredicate,"
  },
  "org.springframework.web.reactive.function.client.<unknown>#onStatus(statusCodePredicate,Function<ClientResponse,exceptionFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCodePredicate",
      "Function<ClientResponse",
      "exceptionFunction"
    ],
    "position": {
      "column": 1,
      "line": 523
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec onStatus(Predicate<HttpStatusCode> statusCodePredicate,\n\t\t\t\tFunction<ClientResponse, Mono<? extends Throwable>> exceptionFunction)",
    "source_code": "\t\tpublic ResponseSpec onStatus(Predicate<HttpStatusCode> statusCodePredicate,"
  },
  "org.springframework.web.reactive.function.client.<unknown>#patch()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "RequestBodyUriSpec",
    "signature": "public RequestBodyUriSpec patch()",
    "source_code": "\tpublic RequestBodyUriSpec patch() {\n\t\treturn methodInternal(HttpMethod.PATCH);\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#post()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "RequestBodyUriSpec",
    "signature": "public RequestBodyUriSpec post()",
    "source_code": "\tpublic RequestBodyUriSpec post() {\n\t\treturn methodInternal(HttpMethod.POST);\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#put()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "RequestBodyUriSpec",
    "signature": "public RequestBodyUriSpec put()",
    "source_code": "\tpublic RequestBodyUriSpec put() {\n\t\treturn methodInternal(HttpMethod.PUT);\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#retrieve()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec retrieve()",
    "source_code": "\t\tpublic ResponseSpec retrieve() {\n\t\t\treturn new DefaultResponseSpec(\n\t\t\t\t\tthis.httpMethod, initUri(), exchange(), DefaultWebClient.this.defaultStatusHandlers);\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#test(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "boolean",
    "signature": "public boolean test(HttpStatusCode status)",
    "source_code": "\t\t\tpublic boolean test(HttpStatusCode status) {\n\t\t\t\treturn this.predicate.test(status);\n\t\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#toEntity(bodyClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bodyClass"
    ],
    "position": {
      "column": 1,
      "line": 573
    },
    "return": "Mono<ResponseEntity<T>>",
    "signature": "public Mono<ResponseEntity<T>> toEntity(Class<T> bodyClass)",
    "source_code": "\t\tpublic <T> Mono<ResponseEntity<T>> toEntity(Class<T> bodyClass) {\n\t\t\treturn this.responseMono.flatMap(response ->\n\t\t\t\t\tWebClientUtils.mapToEntity(response,\n\t\t\t\t\t\t\thandleBodyMono(response, response.bodyToMono(bodyClass))));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#toEntity(bodyTypeRef)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bodyTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 580
    },
    "return": "Mono<ResponseEntity<T>>",
    "signature": "public Mono<ResponseEntity<T>> toEntity(ParameterizedTypeReference<T> bodyTypeRef)",
    "source_code": "\t\tpublic <T> Mono<ResponseEntity<T>> toEntity(ParameterizedTypeReference<T> bodyTypeRef) {\n\t\t\treturn this.responseMono.flatMap(response ->\n\t\t\t\t\tWebClientUtils.mapToEntity(response,\n\t\t\t\t\t\t\thandleBodyMono(response, response.bodyToMono(bodyTypeRef))));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#toEntityFlux(BodyExtractor<Flux<T>,bodyExtractor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BodyExtractor<Flux<T>",
      "bodyExtractor"
    ],
    "position": {
      "column": 1,
      "line": 613
    },
    "return": "Mono<ResponseEntity<Flux<T>>>",
    "signature": "public Mono<ResponseEntity<Flux<T>>> toEntityFlux(BodyExtractor<Flux<T>, ? super ClientHttpResponse> bodyExtractor)",
    "source_code": "\t\tpublic <T> Mono<ResponseEntity<Flux<T>>> toEntityFlux(BodyExtractor<Flux<T>, ? super ClientHttpResponse> bodyExtractor) {\n\t\t\treturn this.responseMono.flatMap(response ->\n\t\t\t\t\thandlerEntityFlux(response, response.body(bodyExtractor)));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#toEntityFlux(elementType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 601
    },
    "return": "Mono<ResponseEntity<Flux<T>>>",
    "signature": "public Mono<ResponseEntity<Flux<T>>> toEntityFlux(Class<T> elementType)",
    "source_code": "\t\tpublic <T> Mono<ResponseEntity<Flux<T>>> toEntityFlux(Class<T> elementType) {\n\t\t\treturn this.responseMono.flatMap(response ->\n\t\t\t\t\thandlerEntityFlux(response, response.bodyToFlux(elementType)));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#toEntityFlux(elementTypeRef)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 607
    },
    "return": "Mono<ResponseEntity<Flux<T>>>",
    "signature": "public Mono<ResponseEntity<Flux<T>>> toEntityFlux(ParameterizedTypeReference<T> elementTypeRef)",
    "source_code": "\t\tpublic <T> Mono<ResponseEntity<Flux<T>>> toEntityFlux(ParameterizedTypeReference<T> elementTypeRef) {\n\t\t\treturn this.responseMono.flatMap(response ->\n\t\t\t\t\thandlerEntityFlux(response, response.bodyToFlux(elementTypeRef)));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#uri(Function<UriBuilder,uriFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(Function<UriBuilder, URI> uriFunction) {\n\t\t\treturn uri(uriFunction.apply(uriBuilderFactory.builder()));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#uri(uri)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(URI uri)",
    "source_code": "\t\tpublic RequestBodySpec uri(URI uri) {\n\t\t\tthis.uri = uri;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#uri(uriTemplate,Function<UriBuilder,uriFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction) {\n\t\t\tUriBuilder uriBuilder = uriBuilderFactory.uriString(uriTemplate);\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriBuilder.toUriString());\n\t\t\treturn uri(uriFunction.apply(uriBuilder));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#uri(uriTemplate,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables) {\n\t\t\tUriBuilder uriBuilder = uriBuilderFactory.uriString(uriTemplate);\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriBuilder.toUriString());\n\t\t\treturn uri(uriBuilder.build(uriVariables));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#uri(uriTemplate,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, @Nullable Object... uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, @Nullable Object... uriVariables) {\n\t\t\tUriBuilder uriBuilder = uriBuilderFactory.uriString(uriTemplate);\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriBuilder.toUriString());\n\t\t\treturn uri(uriBuilder.build(uriVariables));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.ClientRequestObservationContext": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Context that holds information for metadata collection during the\n * {@link ClientHttpObservationDocumentation#HTTP_REACTIVE_CLIENT_EXCHANGES HTTP client exchange observations}.\n *\n * <p>The {@link #getCarrier() tracing context carrier} is a {@link ClientRequest.Builder request builder},\n * since the actual request is immutable. For {@code KeyValue} extraction,\n * the {@link #getRequest() actual request} should be used instead.\n *\n * @author Brian Clozel\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 33
    },
    "signature": "public class ClientRequestObservationContext",
    "source_code": "public class ClientRequestObservationContext extends RequestReplySenderContext<ClientRequest.Builder, ClientResponse> {\n\n\tprivate @Nullable String uriTemplate;\n\n\tprivate boolean aborted;\n\n\tprivate @Nullable ClientRequest request;\n\n\n\t/**\n\t * Create a new Observation context for HTTP client observations.\n\t * @param request client request builder\n\t * @since 6.1.2\n\t */\n\tpublic ClientRequestObservationContext(ClientRequest.Builder request) {\n\t\tsuper(ClientRequestObservationContext::setRequestHeader);\n\t\tsetCarrier(request);\n\t\tsetRequest(request.build());\n\t}\n\n\n\tprivate static void setRequestHeader(ClientRequest.@Nullable Builder request, String name, String value) {\n\t\tif (request != null) {\n\t\t\trequest.headers(headers -> headers.set(name, value));\n\t\t}\n\t}\n\n\n\t/**\n\t * Set the URI template used for the current client exchange.\n\t */\n\tpublic void setUriTemplate(@Nullable String uriTemplate) {\n\t\tthis.uriTemplate = uriTemplate;\n\t}\n\n\t/**\n\t * Return the URI template used for the current client exchange, {@code null} if none was used.\n\t */\n\tpublic @Nullable String getUriTemplate() {\n\t\treturn this.uriTemplate;\n\t}\n\n\t/**\n\t * Set whether the client aborted the current HTTP exchange.\n\t * @param aborted whether the exchange has been aborted\n\t */\n\tvoid setAborted(boolean aborted) {\n\t\tthis.aborted = aborted;\n\t}\n\n\t/**\n\t * Whether the client aborted the current HTTP exchange before receiving any response.\n\t * @return whether the exchange has been aborted\n\t */\n\tpublic boolean isAborted() {\n\t\treturn this.aborted;\n\t}\n\n\t/**\n\t * Set the client request.\n\t */\n\tpublic void setRequest(ClientRequest request) {\n\t\tthis.request = request;\n\t}\n\n\t/**\n\t * Return the immutable client request.\n\t */\n\tpublic @Nullable ClientRequest getRequest() {\n\t\treturn this.request;\n\t}\n\n}"
  },
  "org.springframework.web.reactive.function.client.ClientRequestObservationContext#getRequest()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the immutable client request.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "ClientRequest",
    "signature": "public ClientRequest getRequest()",
    "source_code": "\tpublic @Nullable ClientRequest getRequest() {\n\t\treturn this.request;\n\t}"
  },
  "org.springframework.web.reactive.function.client.ClientRequestObservationContext#getUriTemplate()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the URI template used for the current client exchange, {@code null} if none was used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "String",
    "signature": "public String getUriTemplate()",
    "source_code": "\tpublic @Nullable String getUriTemplate() {\n\t\treturn this.uriTemplate;\n\t}"
  },
  "org.springframework.web.reactive.function.client.ClientRequestObservationContext#isAborted()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the client aborted the current HTTP exchange before receiving any response.\n\t * @return whether the exchange has been aborted\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "boolean",
    "signature": "public boolean isAborted()",
    "source_code": "\tpublic boolean isAborted() {\n\t\treturn this.aborted;\n\t}"
  },
  "org.springframework.web.reactive.function.client.ClientRequestObservationContext#setRequest(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the client request.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void setRequest(ClientRequest request)",
    "source_code": "\tpublic void setRequest(ClientRequest request) {\n\t\tthis.request = request;\n\t}"
  },
  "org.springframework.web.reactive.function.client.ClientRequestObservationContext#setUriTemplate(uriTemplate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the URI template used for the current client exchange.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void setUriTemplate(@Nullable String uriTemplate)",
    "source_code": "\tpublic void setUriTemplate(@Nullable String uriTemplate) {\n\t\tthis.uriTemplate = uriTemplate;\n\t}"
  },
  "org.springframework.web.reactive.function.client.Credentials": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Stores username and password for HTTP basic authentication.\n\t * @deprecated as of Spring 5.1 in favor of using\n\t * {@link HttpHeaders#setBasicAuth(String, String)} while building the request.\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "signature": "public class Credentials",
    "source_code": "\tpublic static final class Credentials {\n\n\t\tprivate final String username;\n\n\t\tprivate final String password;\n\n\t\t/**\n\t\t * Create a new {@code Credentials} instance with the given username and password.\n\t\t * @param username the username\n\t\t * @param password the password\n\t\t */\n\t\tpublic Credentials(String username, String password) {\n\t\t\tAssert.notNull(username, \"'username' must not be null\");\n\t\t\tAssert.notNull(password, \"'password' must not be null\");\n\t\t\tthis.username = username;\n\t\t\tthis.password = password;\n\t\t}\n\n\t\t/**\n\t\t * Return a {@literal Consumer} that stores the given username and password\n\t\t * as a request attribute of type {@code Credentials} that is in turn\n\t\t * used by {@link ExchangeFilterFunctions#basicAuthentication()}.\n\t\t * @param username the username\n\t\t * @param password the password\n\t\t * @return a consumer that can be passed into\n\t\t * {@linkplain ClientRequest.Builder#attributes(java.util.function.Consumer)}\n\t\t * @see ClientRequest.Builder#attributes(java.util.function.Consumer)\n\t\t * @see #BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE\n\t\t */\n\t\tpublic static Consumer<Map<String, Object>> basicAuthenticationCredentials(String username, String password) {\n\t\t\tCredentials credentials = new Credentials(username, password);\n\t\t\treturn (map -> map.put(BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE, credentials));\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other ||(other instanceof Credentials that &&\n\t\t\t\t\tthis.username.equals(that.username) && this.password.equals(that.password)));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn this.username.hashCode() * 31 + this.password.hashCode();\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.function.client.ExchangeFilterFunctions": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Static factory methods providing access to built-in implementations of\n * {@link ExchangeFilterFunction} for basic authentication, error handling, etc.\n *\n * @author Rob Winch\n * @author Arjen Poutsma\n * @author Sam Brannen\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class ExchangeFilterFunctions",
    "source_code": "public abstract class ExchangeFilterFunctions {\n\n\t/**\n\t * Name of the request attribute with {@link Credentials} for {@link #basicAuthentication()}.\n\t */\n\tprivate static final String BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE =\n\t\t\tExchangeFilterFunctions.class.getName() + \".basicAuthenticationCredentials\";\n\n\n\t/**\n\t * Consume up to the specified number of bytes from the response body and\n\t * cancel if any more data arrives.\n\t * <p>Internally delegates to {@link DataBufferUtils#takeUntilByteCount}.\n\t * @param maxByteCount the limit as number of bytes\n\t * @return the filter to limit the response size with\n\t * @since 5.1\n\t */\n\tpublic static ExchangeFilterFunction limitResponseSize(long maxByteCount) {\n\t\treturn (request, next) ->\n\t\t\t\tnext.exchange(request).map(response ->\n\t\t\t\t\t\tresponse.mutate()\n\t\t\t\t\t\t\t\t.body(body -> DataBufferUtils.takeUntilByteCount(body, maxByteCount))\n\t\t\t\t\t\t\t\t.build());\n\t}\n\n\t/**\n\t * Return a filter that generates an error signal when the given\n\t * {@link HttpStatusCode} predicate matches.\n\t * @param statusPredicate the predicate to check the HTTP status with\n\t * @param exceptionFunction the function to create the exception\n\t * @return the filter to generate an error signal\n\t */\n\tpublic static ExchangeFilterFunction statusError(Predicate<HttpStatusCode> statusPredicate,\n\t\t\tFunction<ClientResponse, ? extends Throwable> exceptionFunction) {\n\n\t\tAssert.notNull(statusPredicate, \"Predicate must not be null\");\n\t\tAssert.notNull(exceptionFunction, \"Function must not be null\");\n\n\t\treturn ExchangeFilterFunction.ofResponseProcessor(\n\t\t\t\tresponse -> (statusPredicate.test(response.statusCode()) ?\n\t\t\t\t\t\tMono.error(exceptionFunction.apply(response)) : Mono.just(response)));\n\t}\n\n\t/**\n\t * Return a filter that applies HTTP Basic Authentication to the request\n\t * headers via {@link HttpHeaders#setBasicAuth(String)} and\n\t * {@link HttpHeaders#encodeBasicAuth(String, String, Charset)}.\n\t * @param username the username\n\t * @param password the password\n\t * @return the filter to add authentication headers with\n\t * @see HttpHeaders#encodeBasicAuth(String, String, Charset)\n\t * @see HttpHeaders#setBasicAuth(String)\n\t */\n\tpublic static ExchangeFilterFunction basicAuthentication(String username, String password) {\n\t\tString encodedCredentials = HttpHeaders.encodeBasicAuth(username, password, null);\n\t\treturn (request, next) ->\n\t\t\t\tnext.exchange(ClientRequest.from(request)\n\t\t\t\t\t\t.headers(headers -> headers.setBasicAuth(encodedCredentials))\n\t\t\t\t\t\t.build());\n\t}\n\n\t/**\n\t * Variant of {@link #basicAuthentication(String, String)} that looks up\n\t * the {@link Credentials Credentials} in a\n\t * {@link #BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE request attribute}.\n\t * @return the filter to use\n\t * @see Credentials\n\t * @deprecated as of Spring 5.1 in favor of using\n\t * {@link HttpHeaders#setBasicAuth(String, String)} while building the request.\n\t */\n\t@Deprecated\n\tpublic static ExchangeFilterFunction basicAuthentication() {\n\t\treturn (request, next) -> {\n\t\t\tObject attr = request.attributes().get(BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE);\n\t\t\tif (attr instanceof Credentials cred) {\n\t\t\t\treturn next.exchange(ClientRequest.from(request)\n\t\t\t\t\t\t.headers(headers -> headers.setBasicAuth(cred.username, cred.password))\n\t\t\t\t\t\t.build());\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn next.exchange(request);\n\t\t\t}\n\t\t};\n\t}\n\n\n\t/**\n\t * Stores username and password for HTTP basic authentication.\n\t * @deprecated as of Spring 5.1 in favor of using\n\t * {@link HttpHeaders#setBasicAuth(String, String)} while building the request.\n\t */\n\t@Deprecated\n\tpublic static final class Credentials {\n\n\t\tprivate final String username;\n\n\t\tprivate final String password;\n\n\t\t/**\n\t\t * Create a new {@code Credentials} instance with the given username and password.\n\t\t * @param username the username\n\t\t * @param password the password\n\t\t */\n\t\tpublic Credentials(String username, String password) {\n\t\t\tAssert.notNull(username, \"'username' must not be null\");\n\t\t\tAssert.notNull(password, \"'password' must not be null\");\n\t\t\tthis.username = username;\n\t\t\tthis.password = password;\n\t\t}\n\n\t\t/**\n\t\t * Return a {@literal Consumer} that stores the given username and password\n\t\t * as a request attribute of type {@code Credentials} that is in turn\n\t\t * used by {@link ExchangeFilterFunctions#basicAuthentication()}.\n\t\t * @param username the username\n\t\t * @param password the password\n\t\t * @return a consumer that can be passed into\n\t\t * {@linkplain ClientRequest.Builder#attributes(java.util.function.Consumer)}\n\t\t * @see ClientRequest.Builder#attributes(java.util.function.Consumer)\n\t\t * @see #BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE\n\t\t */\n\t\tpublic static Consumer<Map<String, Object>> basicAuthenticationCredentials(String username, String password) {\n\t\t\tCredentials credentials = new Credentials(username, password);\n\t\t\treturn (map -> map.put(BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE, credentials));\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other ||(other instanceof Credentials that &&\n\t\t\t\t\tthis.username.equals(that.username) && this.password.equals(that.password)));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn this.username.hashCode() * 31 + this.password.hashCode();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.function.client.ExchangeFilterFunctions#basicAuthentication()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #basicAuthentication(String, String)} that looks up\n\t * the {@link Credentials Credentials} in a\n\t * {@link #BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE request attribute}.\n\t * @return the filter to use\n\t * @see Credentials\n\t * @deprecated as of Spring 5.1 in favor of using\n\t * {@link HttpHeaders#setBasicAuth(String, String)} while building the request.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "ExchangeFilterFunction",
    "signature": "public ExchangeFilterFunction basicAuthentication()",
    "source_code": "\tpublic static ExchangeFilterFunction basicAuthentication() {\n\t\treturn (request, next) -> {\n\t\t\tObject attr = request.attributes().get(BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE);\n\t\t\tif (attr instanceof Credentials cred) {\n\t\t\t\treturn next.exchange(ClientRequest.from(request)\n\t\t\t\t\t\t.headers(headers -> headers.setBasicAuth(cred.username, cred.password))\n\t\t\t\t\t\t.build());\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn next.exchange(request);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.web.reactive.function.client.ExchangeFilterFunctions#basicAuthentication(username,password)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a filter that applies HTTP Basic Authentication to the request\n\t * headers via {@link HttpHeaders#setBasicAuth(String)} and\n\t * {@link HttpHeaders#encodeBasicAuth(String, String, Charset)}.\n\t * @param username the username\n\t * @param password the password\n\t * @return the filter to add authentication headers with\n\t * @see HttpHeaders#encodeBasicAuth(String, String, Charset)\n\t * @see HttpHeaders#setBasicAuth(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "ExchangeFilterFunction",
    "signature": "public ExchangeFilterFunction basicAuthentication(String username, String password)",
    "source_code": "\tpublic static ExchangeFilterFunction basicAuthentication(String username, String password) {\n\t\tString encodedCredentials = HttpHeaders.encodeBasicAuth(username, password, null);\n\t\treturn (request, next) ->\n\t\t\t\tnext.exchange(ClientRequest.from(request)\n\t\t\t\t\t\t.headers(headers -> headers.setBasicAuth(encodedCredentials))\n\t\t\t\t\t\t.build());\n\t}"
  },
  "org.springframework.web.reactive.function.client.ExchangeFilterFunctions#basicAuthenticationCredentials(username,password)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return a {@literal Consumer} that stores the given username and password\n\t\t * as a request attribute of type {@code Credentials} that is in turn\n\t\t * used by {@link ExchangeFilterFunctions#basicAuthentication()}.\n\t\t * @param username the username\n\t\t * @param password the password\n\t\t * @return a consumer that can be passed into\n\t\t * {@linkplain ClientRequest.Builder#attributes(java.util.function.Consumer)}\n\t\t * @see ClientRequest.Builder#attributes(java.util.function.Consumer)\n\t\t * @see #BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "Object>>",
    "signature": "public Object>> basicAuthenticationCredentials(String username, String password)",
    "source_code": "\t\tpublic static Consumer<Map<String, Object>> basicAuthenticationCredentials(String username, String password) {\n\t\t\tCredentials credentials = new Credentials(username, password);\n\t\t\treturn (map -> map.put(BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE, credentials));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.ExchangeFilterFunctions#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other ||(other instanceof Credentials that &&\n\t\t\t\t\tthis.username.equals(that.username) && this.password.equals(that.password)));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.ExchangeFilterFunctions#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn this.username.hashCode() * 31 + this.password.hashCode();\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.ExchangeFilterFunctions#limitResponseSize(maxByteCount)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Consume up to the specified number of bytes from the response body and\n\t * cancel if any more data arrives.\n\t * <p>Internally delegates to {@link DataBufferUtils#takeUntilByteCount}.\n\t * @param maxByteCount the limit as number of bytes\n\t * @return the filter to limit the response size with\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "maxByteCount"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "ExchangeFilterFunction",
    "signature": "public ExchangeFilterFunction limitResponseSize(long maxByteCount)",
    "source_code": "\tpublic static ExchangeFilterFunction limitResponseSize(long maxByteCount) {\n\t\treturn (request, next) ->\n\t\t\t\tnext.exchange(request).map(response ->\n\t\t\t\t\t\tresponse.mutate()\n\t\t\t\t\t\t\t\t.body(body -> DataBufferUtils.takeUntilByteCount(body, maxByteCount))\n\t\t\t\t\t\t\t\t.build());\n\t}"
  },
  "org.springframework.web.reactive.function.client.ExchangeFilterFunctions#statusError(statusPredicate,Function<ClientResponse,exceptionFunction)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a filter that generates an error signal when the given\n\t * {@link HttpStatusCode} predicate matches.\n\t * @param statusPredicate the predicate to check the HTTP status with\n\t * @param exceptionFunction the function to create the exception\n\t * @return the filter to generate an error signal\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusPredicate",
      "Function<ClientResponse",
      "exceptionFunction"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "ExchangeFilterFunction",
    "signature": "public ExchangeFilterFunction statusError(Predicate<HttpStatusCode> statusPredicate,\n\t\t\tFunction<ClientResponse, ? extends Throwable> exceptionFunction)",
    "source_code": "\tpublic static ExchangeFilterFunction statusError(Predicate<HttpStatusCode> statusPredicate,"
  },
  "org.springframework.web.reactive.function.client.WebClientResponseException#getRawStatusCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the raw HTTP status code value.\n\t * @deprecated in favor of {@link #getStatusCode()}, for removal in 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "int",
    "signature": "public int getRawStatusCode()",
    "source_code": "\tpublic int getRawStatusCode() {\n\t\treturn this.statusCode.value();\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#build()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> build()",
    "source_code": "\tpublic Mono<ServerResponse> build() {\n\t\treturn build((exchange, handlerStrategies) -> exchange.getResponse().setComplete());\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#rawStatusCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "int",
    "signature": "public int rawStatusCode()",
    "source_code": "\t\tpublic int rawStatusCode() {\n\t\t\treturn this.statusCode.value();\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#syncBody(body)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> syncBody(Object body)",
    "source_code": "\tpublic Mono<ServerResponse> syncBody(Object body) {\n\t\treturn bodyValue(body);\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#methodName()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1135
    },
    "return": "String",
    "signature": "public String methodName()",
    "source_code": "\t\tpublic String methodName() {\n\t\t\treturn this.delegate.methodName();\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#pathContainer()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1407
    },
    "return": "PathContainer",
    "signature": "public PathContainer pathContainer()",
    "source_code": "\t\tpublic PathContainer pathContainer() {\n\t\t\treturn this.requestPath;\n\t\t}"
  },
  "org.springframework.web.reactive.handler.AbstractHandlerMapping#setUseTrailingSlashMatch(trailingSlashMatch)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut method for setting the same property on the underlying pattern\n\t * parser in use. For more details see:\n\t * <ul>\n\t * <li>{@link #getPathPatternParser()} -- the underlying pattern parser\n\t * <li>{@link PathPatternParser#setMatchOptionalTrailingSeparator(boolean)} --\n\t * the trailing slash option, including its default value.\n\t * </ul>\n\t * <p>The default was changed in 6.0 from {@code true} to {@code false} in\n\t * order to support the deprecation of the property.\n\t * @deprecated as of 6.0, see\n\t * {@link PathPatternParser#setMatchOptionalTrailingSeparator(boolean)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "trailingSlashMatch"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void setUseTrailingSlashMatch(boolean trailingSlashMatch)",
    "source_code": "\tpublic void setUseTrailingSlashMatch(boolean trailingSlashMatch) {\n\t\tthis.patternParser.setMatchOptionalTrailingSeparator(trailingSlashMatch);\n\t}"
  },
  "org.springframework.web.reactive.resource.PathResourceResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A simple {@code ResourceResolver} that tries to find a resource under the given\n * locations matching to the request path.\n *\n * <p>This resolver does not delegate to the {@code ResourceResolverChain} and is\n * expected to be configured at the end in a chain of resolvers.\n *\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public class PathResourceResolver",
    "source_code": "public class PathResourceResolver extends AbstractResourceResolver {\n\n\tprivate Resource @Nullable [] allowedLocations;\n\n\n\t/**\n\t * By default, when a Resource is found, the path of the resolved resource is\n\t * compared to ensure it's under the input location where it was found.\n\t * However sometimes that may not be the case, for example, when\n\t * {@link CssLinkResourceTransformer}\n\t * resolves public URLs of links it contains, the CSS file is the location\n\t * and the resources being resolved are css files, images, fonts and others\n\t * located in adjacent or parent directories.\n\t * <p>This property allows configuring a complete list of locations under\n\t * which resources must be so that if a resource is not under the location\n\t * relative to which it was found, this list may be checked as well.\n\t * <p>By default {@link ResourceWebHandler} initializes this property\n\t * to match its list of locations.\n\t * @param locations the list of allowed locations\n\t */\n\tpublic void setAllowedLocations(Resource @Nullable ... locations) {\n\t\tthis.allowedLocations = locations;\n\t}\n\n\tpublic Resource @Nullable [] getAllowedLocations() {\n\t\treturn this.allowedLocations;\n\t}\n\n\n\t@Override\n\tprotected Mono<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,\n\t\t\tString requestPath, List<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\treturn getResource(requestPath, locations);\n\t}\n\n\t@Override\n\tprotected Mono<String> resolveUrlPathInternal(String path, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain) {\n\n\t\tif (StringUtils.hasText(path)) {\n\t\t\treturn getResource(path, locations).map(resource -> path);\n\t\t}\n\t\telse {\n\t\t\treturn Mono.empty();\n\t\t}\n\t}\n\n\tprivate Mono<Resource> getResource(String resourcePath, List<? extends Resource> locations) {\n\t\treturn Flux.fromIterable(locations)\n\t\t\t\t.concatMap(location -> getResource(resourcePath, location))\n\t\t\t\t.next();\n\t}\n\n\t/**\n\t * Find the resource under the given location.\n\t * <p>The default implementation checks if there is a readable\n\t * {@code Resource} for the given path relative to the location.\n\t * @param resourcePath the path to the resource\n\t * @param location the location to check\n\t * @return the resource, or empty {@link Mono} if none found\n\t */\n\tprotected Mono<Resource> getResource(String resourcePath, Resource location) {\n\t\ttry {\n\t\t\tResource resource = ResourceHandlerUtils.createRelativeResource(location, resourcePath);\n\t\t\tif (resource.isReadable()) {\n\t\t\t\tif (checkResource(resource, location)) {\n\t\t\t\t\treturn Mono.just(resource);\n\t\t\t\t}\n\t\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\t\tResource[] allowed = getAllowedLocations();\n\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\t\"Resource path \\\"\" + resourcePath + \"\\\" was successfully resolved \" +\n\t\t\t\t\t\t\t\t\t\"but resource \\\"\" + resource + \"\\\" is neither under the \" +\n\t\t\t\t\t\t\t\t\t\"current location \\\"\" + location + \"\\\" nor under any of the \" +\n\t\t\t\t\t\t\t\t\t\"allowed locations \" + (allowed != null ? Arrays.asList(allowed) : \"[]\"), -1, true));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tString error = \"Skip location [\" + location + \"] due to error\";\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(error, ex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.debug(error + \": \" + ex.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t}\n\n\t/**\n\t * Perform additional checks on a resolved resource beyond checking whether the\n\t * resource exists and is readable. The default implementation also verifies\n\t * the resource is either under the location relative to which it was found or\n\t * is under one of the {@link #setAllowedLocations allowed locations}.\n\t * @param resource the resource to check\n\t * @param location the location relative to which the resource was found\n\t * @return \"true\" if resource is in a valid location, \"false\" otherwise\n\t */\n\tprotected boolean checkResource(Resource resource, Resource location) throws IOException {\n\t\tif (ResourceHandlerUtils.isResourceUnderLocation(location, resource)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (getAllowedLocations() != null) {\n\t\t\tfor (Resource current : getAllowedLocations()) {\n\t\t\t\tif (ResourceHandlerUtils.isResourceUnderLocation(current, resource)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}"
  },
  "org.springframework.web.reactive.resource.PathResourceResolver#checkResource(resource,location)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform additional checks on a resolved resource beyond checking whether the\n\t * resource exists and is readable. The default implementation also verifies\n\t * the resource is either under the location relative to which it was found or\n\t * is under one of the {@link #setAllowedLocations allowed locations}.\n\t * @param resource the resource to check\n\t * @param location the location relative to which the resource was found\n\t * @return \"true\" if resource is in a valid location, \"false\" otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resource",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "boolean",
    "signature": "protected boolean checkResource(Resource resource, Resource location)",
    "source_code": "\tprotected boolean checkResource(Resource resource, Resource location) throws IOException {\n\t\tif (ResourceHandlerUtils.isResourceUnderLocation(location, resource)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (getAllowedLocations() != null) {\n\t\t\tfor (Resource current : getAllowedLocations()) {\n\t\t\t\tif (ResourceHandlerUtils.isResourceUnderLocation(current, resource)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.reactive.resource.PathResourceResolver#getResource(resourcePath,location)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the resource under the given location.\n\t * <p>The default implementation checks if there is a readable\n\t * {@code Resource} for the given path relative to the location.\n\t * @param resourcePath the path to the resource\n\t * @param location the location to check\n\t * @return the resource, or empty {@link Mono} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourcePath",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "Mono<Resource>",
    "signature": "protected Mono<Resource> getResource(String resourcePath, Resource location)",
    "source_code": "\tprotected Mono<Resource> getResource(String resourcePath, Resource location) {\n\t\ttry {\n\t\t\tResource resource = ResourceHandlerUtils.createRelativeResource(location, resourcePath);\n\t\t\tif (resource.isReadable()) {\n\t\t\t\tif (checkResource(resource, location)) {\n\t\t\t\t\treturn Mono.just(resource);\n\t\t\t\t}\n\t\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\t\tResource[] allowed = getAllowedLocations();\n\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\t\"Resource path \\\"\" + resourcePath + \"\\\" was successfully resolved \" +\n\t\t\t\t\t\t\t\t\t\"but resource \\\"\" + resource + \"\\\" is neither under the \" +\n\t\t\t\t\t\t\t\t\t\"current location \\\"\" + location + \"\\\" nor under any of the \" +\n\t\t\t\t\t\t\t\t\t\"allowed locations \" + (allowed != null ? Arrays.asList(allowed) : \"[]\"), -1, true));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tString error = \"Skip location [\" + location + \"] due to error\";\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(error, ex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.debug(error + \": \" + ex.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.resource.PathResourceResolver#resolveResourceInternal(exchange,requestPath,locations,chain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exchange",
      "requestPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "Mono<Resource>",
    "signature": "protected Mono<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,\n\t\t\tString requestPath, List<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected Mono<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,"
  },
  "org.springframework.web.reactive.resource.PathResourceResolver#resolveUrlPathInternal(path,locations,chain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "path",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "Mono<String>",
    "signature": "protected Mono<String> resolveUrlPathInternal(String path, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain)",
    "source_code": "\tprotected Mono<String> resolveUrlPathInternal(String path, List<? extends Resource> locations,"
  },
  "org.springframework.web.reactive.resource.PathResourceResolver#setAllowedLocations(locations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * By default, when a Resource is found, the path of the resolved resource is\n\t * compared to ensure it's under the input location where it was found.\n\t * However sometimes that may not be the case, for example, when\n\t * {@link CssLinkResourceTransformer}\n\t * resolves public URLs of links it contains, the CSS file is the location\n\t * and the resources being resolved are css files, images, fonts and others\n\t * located in adjacent or parent directories.\n\t * <p>This property allows configuring a complete list of locations under\n\t * which resources must be so that if a resource is not under the location\n\t * relative to which it was found, this list may be checked as well.\n\t * <p>By default {@link ResourceWebHandler} initializes this property\n\t * to match its list of locations.\n\t * @param locations the list of allowed locations\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "void",
    "signature": "public void setAllowedLocations(Resource @Nullable ... locations)",
    "source_code": "\tpublic void setAllowedLocations(Resource @Nullable ... locations) {\n\t\tthis.allowedLocations = locations;\n\t}"
  },
  "org.springframework.web.reactive.result.condition.CompositeRequestCondition": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Implements the {@link RequestCondition} contract by delegating to multiple\n * {@code RequestCondition} types and using a logical conjunction ({@code ' && '}) to\n * ensure all conditions match a given request.\n *\n * <p>When {@code CompositeRequestCondition} instances are combined or compared\n * is expected that (a) they contain the same number of conditions and (b)\n * conditions at the same index are of the same type. It is acceptable to\n * provide {@code null} conditions or no conditions at all to the constructor.\n *\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public class CompositeRequestCondition",
    "source_code": "public class CompositeRequestCondition extends AbstractRequestCondition<CompositeRequestCondition> {\n\n\tprivate final RequestConditionHolder[] requestConditions;\n\n\n\t/**\n\t * Create an instance with 0 or more {@code RequestCondition} types. It is\n\t * important to create {@code CompositeRequestCondition} instances with the\n\t * same number of conditions so they may be compared and combined.\n\t * It is acceptable to provide {@code null} conditions.\n\t */\n\tpublic CompositeRequestCondition(RequestCondition<?>... requestConditions) {\n\t\tthis.requestConditions = wrap(requestConditions);\n\t}\n\n\tprivate CompositeRequestCondition(RequestConditionHolder[] requestConditions) {\n\t\tthis.requestConditions = requestConditions;\n\t}\n\n\n\tprivate RequestConditionHolder[] wrap(RequestCondition<?>... rawConditions) {\n\t\tRequestConditionHolder[] wrappedConditions = new RequestConditionHolder[rawConditions.length];\n\t\tfor (int i = 0; i < rawConditions.length; i++) {\n\t\t\twrappedConditions[i] = new RequestConditionHolder(rawConditions[i]);\n\t\t}\n\t\treturn wrappedConditions;\n\t}\n\n\t/**\n\t * Whether this instance contains 0 conditions or not.\n\t */\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn ObjectUtils.isEmpty(this.requestConditions);\n\t}\n\n\t/**\n\t * Return the underlying conditions, possibly empty but never {@code null}.\n\t */\n\tpublic List<@Nullable RequestCondition<?>> getConditions() {\n\t\treturn unwrap();\n\t}\n\n\tprivate List<@Nullable RequestCondition<?>> unwrap() {\n\t\tList<@Nullable RequestCondition<?>> result = new ArrayList<>();\n\t\tfor (RequestConditionHolder holder : this.requestConditions) {\n\t\t\tresult.add(holder.getCondition());\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"NullAway\") // https://github.com/uber/NullAway/issues/1126\n\tprotected Collection<? extends @Nullable Object> getContent() {\n\t\treturn (!isEmpty() ? getConditions() : Collections.emptyList());\n\t}\n\n\t@Override\n\tprotected String getToStringInfix() {\n\t\treturn \" && \";\n\t}\n\n\tprivate int getLength() {\n\t\treturn this.requestConditions.length;\n\t}\n\n\t/**\n\t * If one instance is empty, return the other.\n\t * <p>If both instances have conditions, combine the individual conditions\n\t * after ensuring they are of the same type and number.\n\t */\n\t@Override\n\tpublic CompositeRequestCondition combine(CompositeRequestCondition other) {\n\t\tif (isEmpty() && other.isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\t\telse if (other.isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\t\telse if (isEmpty()) {\n\t\t\treturn other;\n\t\t}\n\t\telse {\n\t\t\tassertNumberOfConditions(other);\n\t\t\tRequestConditionHolder[] combinedConditions = new RequestConditionHolder[getLength()];\n\t\t\tfor (int i = 0; i < getLength(); i++) {\n\t\t\t\tcombinedConditions[i] = this.requestConditions[i].combine(other.requestConditions[i]);\n\t\t\t}\n\t\t\treturn new CompositeRequestCondition(combinedConditions);\n\t\t}\n\t}\n\n\tprivate void assertNumberOfConditions(CompositeRequestCondition other) {\n\t\tAssert.isTrue(getLength() == other.getLength(),\n\t\t\t\t() -> \"Cannot combine CompositeRequestConditions with a different number of conditions. \" +\n\t\t\t\tObjectUtils.nullSafeToString(this.requestConditions) + \" and \" +\n\t\t\t\tObjectUtils.nullSafeToString(other.requestConditions));\n\t}\n\n\t/**\n\t * Delegate to <em>all</em> contained conditions to match the request and return the\n\t * resulting \"matching\" condition instances.\n\t * <p>An empty {@code CompositeRequestCondition} matches to all requests.\n\t */\n\t@Override\n\tpublic @Nullable CompositeRequestCondition getMatchingCondition(ServerWebExchange exchange) {\n\t\tif (isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\t\tRequestConditionHolder[] matchingConditions = new RequestConditionHolder[getLength()];\n\t\tfor (int i = 0; i < getLength(); i++) {\n\t\t\tRequestConditionHolder matchingCondition = this.requestConditions[i].getMatchingCondition(exchange);\n\t\t\tif (matchingCondition == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tmatchingConditions[i] = matchingCondition;\n\t\t}\n\t\treturn new CompositeRequestCondition(matchingConditions);\n\t}\n\n\t/**\n\t * If one instance is empty, the other \"wins\". If both instances have\n\t * conditions, compare them in the order in which they were provided.\n\t */\n\t@Override\n\tpublic int compareTo(CompositeRequestCondition other, ServerWebExchange exchange) {\n\t\tif (isEmpty() && other.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\t\telse if (isEmpty()) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if (other.isEmpty()) {\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\tassertNumberOfConditions(other);\n\t\t\tfor (int i = 0; i < getLength(); i++) {\n\t\t\t\tint result = this.requestConditions[i].compareTo(other.requestConditions[i], exchange);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.result.condition.CompositeRequestCondition#combine(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * If one instance is empty, return the other.\n\t * <p>If both instances have conditions, combine the individual conditions\n\t * after ensuring they are of the same type and number.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "CompositeRequestCondition",
    "signature": "public CompositeRequestCondition combine(CompositeRequestCondition other)",
    "source_code": "\tpublic CompositeRequestCondition combine(CompositeRequestCondition other) {\n\t\tif (isEmpty() && other.isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\t\telse if (other.isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\t\telse if (isEmpty()) {\n\t\t\treturn other;\n\t\t}\n\t\telse {\n\t\t\tassertNumberOfConditions(other);\n\t\t\tRequestConditionHolder[] combinedConditions = new RequestConditionHolder[getLength()];\n\t\t\tfor (int i = 0; i < getLength(); i++) {\n\t\t\t\tcombinedConditions[i] = this.requestConditions[i].combine(other.requestConditions[i]);\n\t\t\t}\n\t\t\treturn new CompositeRequestCondition(combinedConditions);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.condition.CompositeRequestCondition#compareTo(other,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * If one instance is empty, the other \"wins\". If both instances have\n\t * conditions, compare them in the order in which they were provided.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "int",
    "signature": "public int compareTo(CompositeRequestCondition other, ServerWebExchange exchange)",
    "source_code": "\tpublic int compareTo(CompositeRequestCondition other, ServerWebExchange exchange) {\n\t\tif (isEmpty() && other.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\t\telse if (isEmpty()) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if (other.isEmpty()) {\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\tassertNumberOfConditions(other);\n\t\t\tfor (int i = 0; i < getLength(); i++) {\n\t\t\t\tint result = this.requestConditions[i].compareTo(other.requestConditions[i], exchange);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.condition.CompositeRequestCondition#getMatchingCondition(exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate to <em>all</em> contained conditions to match the request and return the\n\t * resulting \"matching\" condition instances.\n\t * <p>An empty {@code CompositeRequestCondition} matches to all requests.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "CompositeRequestCondition",
    "signature": "public CompositeRequestCondition getMatchingCondition(ServerWebExchange exchange)",
    "source_code": "\tpublic @Nullable CompositeRequestCondition getMatchingCondition(ServerWebExchange exchange) {\n\t\tif (isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\t\tRequestConditionHolder[] matchingConditions = new RequestConditionHolder[getLength()];\n\t\tfor (int i = 0; i < getLength(); i++) {\n\t\t\tRequestConditionHolder matchingCondition = this.requestConditions[i].getMatchingCondition(exchange);\n\t\t\tif (matchingCondition == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tmatchingConditions[i] = matchingCondition;\n\t\t}\n\t\treturn new CompositeRequestCondition(matchingConditions);\n\t}"
  },
  "org.springframework.web.reactive.result.condition.CompositeRequestCondition#getToStringInfix()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "String",
    "signature": "protected String getToStringInfix()",
    "source_code": "\tprotected String getToStringInfix() {\n\t\treturn \" && \";\n\t}"
  },
  "org.springframework.web.reactive.result.condition.CompositeRequestCondition#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether this instance contains 0 conditions or not.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn ObjectUtils.isEmpty(this.requestConditions);\n\t}"
  },
  "org.springframework.web.reactive.result.condition.ConsumesRequestCondition": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A logical disjunction (' || ') request condition to match a request's\n * 'Content-Type' header to a list of media type expressions. Two kinds of\n * media type expressions are supported, which are described in\n * {@link RequestMapping#consumes()} and {@link RequestMapping#headers()}\n * where the header name is 'Content-Type'. Regardless of which syntax is\n * used, the semantics are the same.\n *\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class ConsumesRequestCondition",
    "source_code": "public final class ConsumesRequestCondition extends AbstractRequestCondition<ConsumesRequestCondition> {\n\n\tprivate static final ConsumesRequestCondition EMPTY_CONDITION = new ConsumesRequestCondition();\n\n\n\tprivate final List<ConsumeMediaTypeExpression> expressions;\n\n\tprivate boolean bodyRequired = true;\n\n\n\t/**\n\t * Creates a new instance from 0 or more \"consumes\" expressions.\n\t * @param consumes expressions with the syntax described in\n\t * {@link RequestMapping#consumes()}; if 0 expressions are provided,\n\t * the condition will match to every request\n\t */\n\tpublic ConsumesRequestCondition(String... consumes) {\n\t\tthis(consumes, null);\n\t}\n\n\t/**\n\t * Creates a new instance with \"consumes\" and \"header\" expressions.\n\t * \"Header\" expressions where the header name is not 'Content-Type' or have\n\t * no header value defined are ignored. If 0 expressions are provided in\n\t * total, the condition will match to every request\n\t * @param consumes as described in {@link RequestMapping#consumes()}\n\t * @param headers as described in {@link RequestMapping#headers()}\n\t */\n\tpublic ConsumesRequestCondition(String @Nullable [] consumes, String @Nullable [] headers) {\n\t\tthis.expressions = parseExpressions(consumes, headers);\n\t\tif (this.expressions.size() > 1) {\n\t\t\tCollections.sort(this.expressions);\n\t\t}\n\t}\n\n\tprivate static List<ConsumeMediaTypeExpression> parseExpressions(String @Nullable [] consumes, String @Nullable [] headers) {\n\t\tSet<ConsumeMediaTypeExpression> result = null;\n\t\tif (!ObjectUtils.isEmpty(headers)) {\n\t\t\tfor (String header : headers) {\n\t\t\t\tHeadersRequestCondition.HeaderExpression expr = new HeadersRequestCondition.HeaderExpression(header);\n\t\t\t\tif (\"Content-Type\".equalsIgnoreCase(expr.name)) {\n\t\t\t\t\tresult = (result != null ? result : new LinkedHashSet<>());\n\t\t\t\t\tfor (MediaType mediaType : MediaType.parseMediaTypes(expr.value)) {\n\t\t\t\t\t\tresult.add(new ConsumeMediaTypeExpression(mediaType, expr.isNegated));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ObjectUtils.isEmpty(consumes)) {\n\t\t\tresult = (result != null ? result : new LinkedHashSet<>());\n\t\t\tfor (String consume : consumes) {\n\t\t\t\tresult.add(new ConsumeMediaTypeExpression(consume));\n\t\t\t}\n\t\t}\n\t\treturn (result != null ? new ArrayList<>(result) : Collections.emptyList());\n\t}\n\n\t/**\n\t * Private constructor for internal when creating matching conditions.\n\t */\n\tprivate ConsumesRequestCondition(List<ConsumeMediaTypeExpression> expressions) {\n\t\tthis.expressions = expressions;\n\t}\n\n\n\t/**\n\t * Return the contained MediaType expressions.\n\t */\n\tpublic Set<MediaTypeExpression> getExpressions() {\n\t\treturn new LinkedHashSet<>(this.expressions);\n\t}\n\n\t/**\n\t * Returns the media types for this condition excluding negated expressions.\n\t */\n\tpublic Set<MediaType> getConsumableMediaTypes() {\n\t\tSet<MediaType> result = new LinkedHashSet<>();\n\t\tfor (ConsumeMediaTypeExpression expression : this.expressions) {\n\t\t\tif (!expression.isNegated()) {\n\t\t\t\tresult.add(expression.getMediaType());\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Whether the condition has any media type expressions.\n\t */\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn this.expressions.isEmpty();\n\t}\n\n\t@Override\n\tprotected Collection<ConsumeMediaTypeExpression> getContent() {\n\t\treturn this.expressions;\n\t}\n\n\t@Override\n\tprotected String getToStringInfix() {\n\t\treturn \" || \";\n\t}\n\n\t/**\n\t * Whether this condition should expect requests to have a body.\n\t * <p>By default this is set to {@code true} in which case it is assumed a\n\t * request body is required and this condition matches to the \"Content-Type\"\n\t * header or falls back on \"Content-Type: application/octet-stream\".\n\t * <p>If set to {@code false}, and the request does not have a body, then this\n\t * condition matches automatically, i.e. without checking expressions.\n\t * @param bodyRequired whether requests are expected to have a body\n\t * @since 5.2\n\t */\n\tpublic void setBodyRequired(boolean bodyRequired) {\n\t\tthis.bodyRequired = bodyRequired;\n\t}\n\n\t/**\n\t * Return the setting for {@link #setBodyRequired(boolean)}.\n\t * @since 5.2\n\t */\n\tpublic boolean isBodyRequired() {\n\t\treturn this.bodyRequired;\n\t}\n\n\n\t/**\n\t * Returns the \"other\" instance if it has any expressions; returns \"this\"\n\t * instance otherwise. Practically that means a method-level \"consumes\"\n\t * overrides a type-level \"consumes\" condition.\n\t */\n\t@Override\n\tpublic ConsumesRequestCondition combine(ConsumesRequestCondition other) {\n\t\treturn (!other.expressions.isEmpty() ? other : this);\n\t}\n\n\t/**\n\t * Checks if any of the contained media type expressions match the given\n\t * request 'Content-Type' header and returns an instance that is guaranteed\n\t * to contain matching expressions only. The match is performed via\n\t * {@link MediaType#includes(MediaType)}.\n\t * @param exchange the current exchange\n\t * @return the same instance if the condition contains no expressions;\n\t * or a new condition with matching expressions only;\n\t * or {@code null} if no expressions match.\n\t */\n\t@Override\n\tpublic @Nullable ConsumesRequestCondition getMatchingCondition(ServerWebExchange exchange) {\n\t\tServerHttpRequest request = exchange.getRequest();\n\t\tif (CorsUtils.isPreFlightRequest(request)) {\n\t\t\treturn EMPTY_CONDITION;\n\t\t}\n\t\tif (isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\t\tif (!hasBody(request) && !this.bodyRequired) {\n\t\t\treturn EMPTY_CONDITION;\n\t\t}\n\t\tList<ConsumeMediaTypeExpression> result = getMatchingExpressions(exchange);\n\t\treturn !CollectionUtils.isEmpty(result) ? new ConsumesRequestCondition(result) : null;\n\t}\n\n\tprivate boolean hasBody(ServerHttpRequest request) {\n\t\tString contentLength = request.getHeaders().getFirst(HttpHeaders.CONTENT_LENGTH);\n\t\tString transferEncoding = request.getHeaders().getFirst(HttpHeaders.TRANSFER_ENCODING);\n\t\treturn StringUtils.hasText(transferEncoding) ||\n\t\t\t\t(StringUtils.hasText(contentLength) && !contentLength.trim().equals(\"0\"));\n\t}\n\n\tprivate @Nullable List<ConsumeMediaTypeExpression> getMatchingExpressions(ServerWebExchange exchange) {\n\t\tList<ConsumeMediaTypeExpression> result = null;\n\t\tfor (ConsumeMediaTypeExpression expression : this.expressions) {\n\t\t\tif (expression.match(exchange)) {\n\t\t\t\tresult = result != null ? result : new ArrayList<>();\n\t\t\t\tresult.add(expression);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns:\n\t * <ul>\n\t * <li>0 if the two conditions have the same number of expressions\n\t * <li>Less than 0 if \"this\" has more or more specific media type expressions\n\t * <li>Greater than 0 if \"other\" has more or more specific media type expressions\n\t * </ul>\n\t * <p>It is assumed that both instances have been obtained via\n\t * {@link #getMatchingCondition(ServerWebExchange)} and each instance contains\n\t * the matching consumable media type expression only or is otherwise empty.\n\t */\n\t@Override\n\tpublic int compareTo(ConsumesRequestCondition other, ServerWebExchange exchange) {\n\t\tif (this.expressions.isEmpty() && other.expressions.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\t\telse if (this.expressions.isEmpty()) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if (other.expressions.isEmpty()) {\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\treturn this.expressions.get(0).compareTo(other.expressions.get(0));\n\t\t}\n\t}\n\n\n\t/**\n\t * Parses and matches a single media type expression to a request's 'Content-Type' header.\n\t */\n\tstatic class ConsumeMediaTypeExpression extends AbstractMediaTypeExpression {\n\n\t\tConsumeMediaTypeExpression(String expression) {\n\t\t\tsuper(expression);\n\t\t}\n\n\t\tConsumeMediaTypeExpression(MediaType mediaType, boolean negated) {\n\t\t\tsuper(mediaType, negated);\n\t\t}\n\n\t\t@Override\n\t\tprotected boolean matchMediaType(ServerWebExchange exchange) throws UnsupportedMediaTypeStatusException {\n\t\t\ttry {\n\t\t\t\tMediaType contentType = exchange.getRequest().getHeaders().getContentType();\n\t\t\t\tcontentType = (contentType != null ? contentType : MediaType.APPLICATION_OCTET_STREAM);\n\t\t\t\treturn (getMediaType().includes(contentType) && matchParameters(contentType));\n\t\t\t}\n\t\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\t\tthrow new UnsupportedMediaTypeStatusException(\"Can't parse Content-Type [\" +\n\t\t\t\t\t\texchange.getRequest().getHeaders().getFirst(\"Content-Type\") +\n\t\t\t\t\t\t\"]: \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.result.condition.ConsumesRequestCondition#combine(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the \"other\" instance if it has any expressions; returns \"this\"\n\t * instance otherwise. Practically that means a method-level \"consumes\"\n\t * overrides a type-level \"consumes\" condition.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "ConsumesRequestCondition",
    "signature": "public ConsumesRequestCondition combine(ConsumesRequestCondition other)",
    "source_code": "\tpublic ConsumesRequestCondition combine(ConsumesRequestCondition other) {\n\t\treturn (!other.expressions.isEmpty() ? other : this);\n\t}"
  },
  "org.springframework.web.reactive.result.condition.ConsumesRequestCondition#compareTo(other,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns:\n\t * <ul>\n\t * <li>0 if the two conditions have the same number of expressions\n\t * <li>Less than 0 if \"this\" has more or more specific media type expressions\n\t * <li>Greater than 0 if \"other\" has more or more specific media type expressions\n\t * </ul>\n\t * <p>It is assumed that both instances have been obtained via\n\t * {@link #getMatchingCondition(ServerWebExchange)} and each instance contains\n\t * the matching consumable media type expression only or is otherwise empty.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "int",
    "signature": "public int compareTo(ConsumesRequestCondition other, ServerWebExchange exchange)",
    "source_code": "\tpublic int compareTo(ConsumesRequestCondition other, ServerWebExchange exchange) {\n\t\tif (this.expressions.isEmpty() && other.expressions.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\t\telse if (this.expressions.isEmpty()) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if (other.expressions.isEmpty()) {\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\treturn this.expressions.get(0).compareTo(other.expressions.get(0));\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.condition.ConsumesRequestCondition#getConsumableMediaTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the media types for this condition excluding negated expressions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "Set<MediaType>",
    "signature": "public Set<MediaType> getConsumableMediaTypes()",
    "source_code": "\tpublic Set<MediaType> getConsumableMediaTypes() {\n\t\tSet<MediaType> result = new LinkedHashSet<>();\n\t\tfor (ConsumeMediaTypeExpression expression : this.expressions) {\n\t\t\tif (!expression.isNegated()) {\n\t\t\t\tresult.add(expression.getMediaType());\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.reactive.result.condition.ConsumesRequestCondition#getContent()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "Collection<ConsumeMediaTypeExpression>",
    "signature": "protected Collection<ConsumeMediaTypeExpression> getContent()",
    "source_code": "\tprotected Collection<ConsumeMediaTypeExpression> getContent() {\n\t\treturn this.expressions;\n\t}"
  },
  "org.springframework.web.reactive.result.condition.ConsumesRequestCondition#getExpressions()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the contained MediaType expressions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "Set<MediaTypeExpression>",
    "signature": "public Set<MediaTypeExpression> getExpressions()",
    "source_code": "\tpublic Set<MediaTypeExpression> getExpressions() {\n\t\treturn new LinkedHashSet<>(this.expressions);\n\t}"
  },
  "org.springframework.web.reactive.result.condition.ConsumesRequestCondition#getMatchingCondition(exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Checks if any of the contained media type expressions match the given\n\t * request 'Content-Type' header and returns an instance that is guaranteed\n\t * to contain matching expressions only. The match is performed via\n\t * {@link MediaType#includes(MediaType)}.\n\t * @param exchange the current exchange\n\t * @return the same instance if the condition contains no expressions;\n\t * or a new condition with matching expressions only;\n\t * or {@code null} if no expressions match.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "ConsumesRequestCondition",
    "signature": "public ConsumesRequestCondition getMatchingCondition(ServerWebExchange exchange)",
    "source_code": "\tpublic @Nullable ConsumesRequestCondition getMatchingCondition(ServerWebExchange exchange) {\n\t\tServerHttpRequest request = exchange.getRequest();\n\t\tif (CorsUtils.isPreFlightRequest(request)) {\n\t\t\treturn EMPTY_CONDITION;\n\t\t}\n\t\tif (isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\t\tif (!hasBody(request) && !this.bodyRequired) {\n\t\t\treturn EMPTY_CONDITION;\n\t\t}\n\t\tList<ConsumeMediaTypeExpression> result = getMatchingExpressions(exchange);\n\t\treturn !CollectionUtils.isEmpty(result) ? new ConsumesRequestCondition(result) : null;\n\t}"
  },
  "org.springframework.web.reactive.result.condition.ConsumesRequestCondition#getToStringInfix()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "String",
    "signature": "protected String getToStringInfix()",
    "source_code": "\tprotected String getToStringInfix() {\n\t\treturn \" || \";\n\t}"
  },
  "org.springframework.web.reactive.result.condition.ConsumesRequestCondition#isBodyRequired()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the setting for {@link #setBodyRequired(boolean)}.\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "boolean",
    "signature": "public boolean isBodyRequired()",
    "source_code": "\tpublic boolean isBodyRequired() {\n\t\treturn this.bodyRequired;\n\t}"
  },
  "org.springframework.web.reactive.result.condition.ConsumesRequestCondition#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the condition has any media type expressions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn this.expressions.isEmpty();\n\t}"
  },
  "org.springframework.web.reactive.result.condition.ConsumesRequestCondition#matchMediaType(exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "boolean",
    "signature": "protected boolean matchMediaType(ServerWebExchange exchange)",
    "source_code": "\t\tprotected boolean matchMediaType(ServerWebExchange exchange) throws UnsupportedMediaTypeStatusException {\n\t\t\ttry {\n\t\t\t\tMediaType contentType = exchange.getRequest().getHeaders().getContentType();\n\t\t\t\tcontentType = (contentType != null ? contentType : MediaType.APPLICATION_OCTET_STREAM);\n\t\t\t\treturn (getMediaType().includes(contentType) && matchParameters(contentType));\n\t\t\t}\n\t\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\t\tthrow new UnsupportedMediaTypeStatusException(\"Can't parse Content-Type [\" +\n\t\t\t\t\t\texchange.getRequest().getHeaders().getFirst(\"Content-Type\") +\n\t\t\t\t\t\t\"]: \" + ex.getMessage());\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.result.condition.ConsumesRequestCondition#setBodyRequired(bodyRequired)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether this condition should expect requests to have a body.\n\t * <p>By default this is set to {@code true} in which case it is assumed a\n\t * request body is required and this condition matches to the \"Content-Type\"\n\t * header or falls back on \"Content-Type: application/octet-stream\".\n\t * <p>If set to {@code false}, and the request does not have a body, then this\n\t * condition matches automatically, i.e. without checking expressions.\n\t * @param bodyRequired whether requests are expected to have a body\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bodyRequired"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void setBodyRequired(boolean bodyRequired)",
    "source_code": "\tpublic void setBodyRequired(boolean bodyRequired) {\n\t\tthis.bodyRequired = bodyRequired;\n\t}"
  },
  "org.springframework.web.reactive.result.condition.ProducesRequestCondition": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A logical disjunction (' || ') request condition to match a request's 'Accept' header\n * to a list of media type expressions. Two kinds of media type expressions are\n * supported, which are described in {@link RequestMapping#produces()} and\n * {@link RequestMapping#headers()} where the header name is 'Accept'.\n * Regardless of which syntax is used, the semantics are the same.\n *\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class ProducesRequestCondition",
    "source_code": "public final class ProducesRequestCondition extends AbstractRequestCondition<ProducesRequestCondition> {\n\n\tprivate static final RequestedContentTypeResolver DEFAULT_CONTENT_TYPE_RESOLVER =\n\t\t\tnew RequestedContentTypeResolverBuilder().build();\n\n\tprivate static final ProducesRequestCondition EMPTY_CONDITION = new ProducesRequestCondition();\n\n\tprivate static final String MEDIA_TYPES_ATTRIBUTE = ProducesRequestCondition.class.getName() + \".MEDIA_TYPES\";\n\n\n\tprivate final List<ProduceMediaTypeExpression> mediaTypeAllList =\n\t\t\tList.of(new ProduceMediaTypeExpression(MediaType.ALL_VALUE));\n\n\tprivate final List<ProduceMediaTypeExpression> expressions;\n\n\tprivate final RequestedContentTypeResolver contentTypeResolver;\n\n\n\t/**\n\t * Creates a new instance from \"produces\" expressions. If 0 expressions\n\t * are provided in total, this condition will match to any request.\n\t * @param produces expressions with syntax defined by {@link RequestMapping#produces()}\n\t */\n\tpublic ProducesRequestCondition(String... produces) {\n\t\tthis(produces, null);\n\t}\n\n\t/**\n\t * Creates a new instance with \"produces\" and \"header\" expressions. \"Header\"\n\t * expressions where the header name is not 'Accept' or have no header value\n\t * defined are ignored. If 0 expressions are provided in total, this condition\n\t * will match to any request.\n\t * @param produces expressions with syntax defined by {@link RequestMapping#produces()}\n\t * @param headers expressions with syntax defined by {@link RequestMapping#headers()}\n\t */\n\tpublic ProducesRequestCondition(String @Nullable [] produces, String @Nullable [] headers) {\n\t\tthis(produces, headers, null);\n\t}\n\n\t/**\n\t * Same as {@link #ProducesRequestCondition(String[], String[])} but also\n\t * accepting a {@link ContentNegotiationManager}.\n\t * @param produces expressions with syntax defined by {@link RequestMapping#produces()}\n\t * @param headers expressions with syntax defined by {@link RequestMapping#headers()}\n\t * @param resolver used to determine requested content type\n\t */\n\tpublic ProducesRequestCondition(\n\t\t\tString @Nullable [] produces, String @Nullable [] headers, @Nullable RequestedContentTypeResolver resolver) {\n\n\t\tthis.expressions = parseExpressions(produces, headers);\n\t\tif (this.expressions.size() > 1) {\n\t\t\tCollections.sort(this.expressions);\n\t\t}\n\t\tthis.contentTypeResolver = (resolver != null ? resolver : DEFAULT_CONTENT_TYPE_RESOLVER);\n\t}\n\n\tprivate List<ProduceMediaTypeExpression> parseExpressions(String @Nullable [] produces, String @Nullable [] headers) {\n\t\tSet<ProduceMediaTypeExpression> result = null;\n\t\tif (!ObjectUtils.isEmpty(headers)) {\n\t\t\tfor (String header : headers) {\n\t\t\t\tHeadersRequestCondition.HeaderExpression expr = new HeadersRequestCondition.HeaderExpression(header);\n\t\t\t\tif (\"Accept\".equalsIgnoreCase(expr.name)) {\n\t\t\t\t\tfor (MediaType mediaType : MediaType.parseMediaTypes(expr.value)) {\n\t\t\t\t\t\tresult = (result != null ? result : new LinkedHashSet<>());\n\t\t\t\t\t\tresult.add(new ProduceMediaTypeExpression(mediaType, expr.isNegated));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ObjectUtils.isEmpty(produces)) {\n\t\t\tfor (String produce : produces) {\n\t\t\t\tresult = (result != null ? result : new LinkedHashSet<>());\n\t\t\t\tresult.add(new ProduceMediaTypeExpression(produce));\n\t\t\t}\n\t\t}\n\t\treturn (result != null ? new ArrayList<>(result) : Collections.emptyList());\n\t}\n\n\t/**\n\t * Private constructor for internal use to create matching conditions.\n\t * Note the expressions List is neither sorted, nor deep copied.\n\t */\n\tprivate ProducesRequestCondition(List<ProduceMediaTypeExpression> expressions, ProducesRequestCondition other) {\n\t\tthis.expressions = expressions;\n\t\tthis.contentTypeResolver = other.contentTypeResolver;\n\t}\n\n\n\t/**\n\t * Return the contained \"produces\" expressions.\n\t */\n\tpublic Set<MediaTypeExpression> getExpressions() {\n\t\treturn new LinkedHashSet<>(this.expressions);\n\t}\n\n\t/**\n\t * Return the contained producible media types excluding negated expressions.\n\t */\n\tpublic Set<MediaType> getProducibleMediaTypes() {\n\t\tSet<MediaType> result = new LinkedHashSet<>();\n\t\tfor (ProduceMediaTypeExpression expression : this.expressions) {\n\t\t\tif (!expression.isNegated()) {\n\t\t\t\tresult.add(expression.getMediaType());\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Whether the condition has any media type expressions.\n\t */\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn this.expressions.isEmpty();\n\t}\n\n\t@Override\n\tprotected List<ProduceMediaTypeExpression> getContent() {\n\t\treturn this.expressions;\n\t}\n\n\t@Override\n\tprotected String getToStringInfix() {\n\t\treturn \" || \";\n\t}\n\n\t/**\n\t * Returns the \"other\" instance if it has any expressions; returns \"this\"\n\t * instance otherwise. Practically that means a method-level \"produces\"\n\t * overrides a type-level \"produces\" condition.\n\t */\n\t@Override\n\tpublic ProducesRequestCondition combine(ProducesRequestCondition other) {\n\t\treturn (!other.expressions.isEmpty() ? other : this);\n\t}\n\n\t/**\n\t * Checks if any of the contained media type expressions match the given\n\t * request 'Content-Type' header and returns an instance that is guaranteed\n\t * to contain matching expressions only. The match is performed via\n\t * {@link MediaType#isCompatibleWith(MediaType)}.\n\t * @param exchange the current exchange\n\t * @return the same instance if there are no expressions;\n\t * or a new condition with matching expressions;\n\t * or {@code null} if no expressions match.\n\t */\n\t@Override\n\tpublic @Nullable ProducesRequestCondition getMatchingCondition(ServerWebExchange exchange) {\n\t\tif (CorsUtils.isPreFlightRequest(exchange.getRequest())) {\n\t\t\treturn EMPTY_CONDITION;\n\t\t}\n\t\tif (isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\t\tList<ProduceMediaTypeExpression> result = getMatchingExpressions(exchange);\n\t\tif (!CollectionUtils.isEmpty(result)) {\n\t\t\treturn new ProducesRequestCondition(result, this);\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tif (MediaType.ALL.isPresentIn(getAcceptedMediaTypes(exchange))) {\n\t\t\t\t\treturn EMPTY_CONDITION;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NotAcceptableStatusException | UnsupportedMediaTypeStatusException ex) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate @Nullable List<ProduceMediaTypeExpression> getMatchingExpressions(ServerWebExchange exchange) {\n\t\tList<ProduceMediaTypeExpression> result = null;\n\t\tfor (ProduceMediaTypeExpression expression : this.expressions) {\n\t\t\tif (expression.match(exchange)) {\n\t\t\t\tresult = result != null ? result : new ArrayList<>();\n\t\t\t\tresult.add(expression);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Compares this and another \"produces\" condition as follows:\n\t * <ol>\n\t * <li>Sort 'Accept' header media types by quality value via\n\t * {@link org.springframework.util.MimeTypeUtils#sortBySpecificity(List)}\n\t * and iterate the list.\n\t * <li>Get the first index of matching media types in each \"produces\"\n\t * condition first matching with {@link MediaType#equals(Object)} and\n\t * then with {@link MediaType#includes(MediaType)}.\n\t * <li>If a lower index is found, the condition at that index wins.\n\t * <li>If both indexes are equal, the media types at the index are\n\t * compared further with {@link MediaType#isMoreSpecific(MimeType)}.\n\t * </ol>\n\t * <p>It is assumed that both instances have been obtained via\n\t * {@link #getMatchingCondition(ServerWebExchange)} and each instance\n\t * contains the matching producible media type expression only or\n\t * is otherwise empty.\n\t */\n\t@Override\n\tpublic int compareTo(ProducesRequestCondition other, ServerWebExchange exchange) {\n\t\tif (this.expressions.isEmpty() && other.expressions.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\t\ttry {\n\t\t\tList<MediaType> acceptedMediaTypes = getAcceptedMediaTypes(exchange);\n\t\t\tfor (MediaType acceptedMediaType : acceptedMediaTypes) {\n\t\t\t\tint thisIndex = this.indexOfEqualMediaType(acceptedMediaType);\n\t\t\t\tint otherIndex = other.indexOfEqualMediaType(acceptedMediaType);\n\t\t\t\tint result = compareMatchingMediaTypes(this, thisIndex, other, otherIndex);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tthisIndex = this.indexOfIncludedMediaType(acceptedMediaType);\n\t\t\t\totherIndex = other.indexOfIncludedMediaType(acceptedMediaType);\n\t\t\t\tresult = compareMatchingMediaTypes(this, thisIndex, other, otherIndex);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tcatch (NotAcceptableStatusException ex) {\n\t\t\t// should never happen\n\t\t\tthrow new IllegalStateException(\"Cannot compare without having any requested media types\", ex);\n\t\t}\n\t}\n\n\tprivate List<MediaType> getAcceptedMediaTypes(ServerWebExchange exchange) throws NotAcceptableStatusException {\n\t\tList<MediaType> result = exchange.getAttribute(MEDIA_TYPES_ATTRIBUTE);\n\t\tif (result == null) {\n\t\t\tresult = this.contentTypeResolver.resolveMediaTypes(exchange);\n\t\t\texchange.getAttributes().put(MEDIA_TYPES_ATTRIBUTE, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate int indexOfEqualMediaType(MediaType mediaType) {\n\t\tfor (int i = 0; i < getExpressionsToCompare().size(); i++) {\n\t\t\tMediaType currentMediaType = getExpressionsToCompare().get(i).getMediaType();\n\t\t\tif (mediaType.getType().equalsIgnoreCase(currentMediaType.getType()) &&\n\t\t\t\t\tmediaType.getSubtype().equalsIgnoreCase(currentMediaType.getSubtype())) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate int indexOfIncludedMediaType(MediaType mediaType) {\n\t\tfor (int i = 0; i < getExpressionsToCompare().size(); i++) {\n\t\t\tif (mediaType.includes(getExpressionsToCompare().get(i).getMediaType())) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate int compareMatchingMediaTypes(ProducesRequestCondition condition1, int index1,\n\t\t\tProducesRequestCondition condition2, int index2) {\n\n\t\tint result = 0;\n\t\tif (index1 != index2) {\n\t\t\tresult = index2 - index1;\n\t\t}\n\t\telse if (index1 != -1) {\n\t\t\tProduceMediaTypeExpression expr1 = condition1.getExpressionsToCompare().get(index1);\n\t\t\tProduceMediaTypeExpression expr2 = condition2.getExpressionsToCompare().get(index2);\n\t\t\tresult = expr1.compareTo(expr2);\n\t\t\tresult = (result != 0 ? result : expr1.getMediaType().compareTo(expr2.getMediaType()));\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Return the contained \"produces\" expressions or if that's empty, a list\n\t * with a {@value MediaType#ALL_VALUE} expression.\n\t */\n\tprivate List<ProduceMediaTypeExpression> getExpressionsToCompare() {\n\t\treturn (this.expressions.isEmpty() ? this.mediaTypeAllList : this.expressions);\n\t}\n\n\n\t/**\n\t * Use this to clear {@link #MEDIA_TYPES_ATTRIBUTE} that contains the parsed,\n\t * requested media types.\n\t * @param exchange the current exchange\n\t * @since 5.2\n\t */\n\tpublic static void clearMediaTypesAttribute(ServerWebExchange exchange) {\n\t\texchange.getAttributes().remove(MEDIA_TYPES_ATTRIBUTE);\n\t}\n\n\n\t/**\n\t * Parses and matches a single media type expression to a request's 'Accept' header.\n\t */\n\tclass ProduceMediaTypeExpression extends AbstractMediaTypeExpression {\n\n\t\tProduceMediaTypeExpression(MediaType mediaType, boolean negated) {\n\t\t\tsuper(mediaType, negated);\n\t\t}\n\n\t\tProduceMediaTypeExpression(String expression) {\n\t\t\tsuper(expression);\n\t\t}\n\n\t\t@Override\n\t\tprotected boolean matchMediaType(ServerWebExchange exchange) throws NotAcceptableStatusException {\n\t\t\tList<MediaType> acceptedMediaTypes = getAcceptedMediaTypes(exchange);\n\t\t\tfor (MediaType acceptedMediaType : acceptedMediaTypes) {\n\t\t\t\tif (getMediaType().isCompatibleWith(acceptedMediaType) && matchParameters(acceptedMediaType)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.result.condition.ProducesRequestCondition#clearMediaTypesAttribute(exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Use this to clear {@link #MEDIA_TYPES_ATTRIBUTE} that contains the parsed,\n\t * requested media types.\n\t * @param exchange the current exchange\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "void",
    "signature": "public void clearMediaTypesAttribute(ServerWebExchange exchange)",
    "source_code": "\tpublic static void clearMediaTypesAttribute(ServerWebExchange exchange) {\n\t\texchange.getAttributes().remove(MEDIA_TYPES_ATTRIBUTE);\n\t}"
  },
  "org.springframework.web.reactive.result.condition.ProducesRequestCondition#combine(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the \"other\" instance if it has any expressions; returns \"this\"\n\t * instance otherwise. Practically that means a method-level \"produces\"\n\t * overrides a type-level \"produces\" condition.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "ProducesRequestCondition",
    "signature": "public ProducesRequestCondition combine(ProducesRequestCondition other)",
    "source_code": "\tpublic ProducesRequestCondition combine(ProducesRequestCondition other) {\n\t\treturn (!other.expressions.isEmpty() ? other : this);\n\t}"
  },
  "org.springframework.web.reactive.result.condition.ProducesRequestCondition#compareTo(other,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Compares this and another \"produces\" condition as follows:\n\t * <ol>\n\t * <li>Sort 'Accept' header media types by quality value via\n\t * {@link org.springframework.util.MimeTypeUtils#sortBySpecificity(List)}\n\t * and iterate the list.\n\t * <li>Get the first index of matching media types in each \"produces\"\n\t * condition first matching with {@link MediaType#equals(Object)} and\n\t * then with {@link MediaType#includes(MediaType)}.\n\t * <li>If a lower index is found, the condition at that index wins.\n\t * <li>If both indexes are equal, the media types at the index are\n\t * compared further with {@link MediaType#isMoreSpecific(MimeType)}.\n\t * </ol>\n\t * <p>It is assumed that both instances have been obtained via\n\t * {@link #getMatchingCondition(ServerWebExchange)} and each instance\n\t * contains the matching producible media type expression only or\n\t * is otherwise empty.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "int",
    "signature": "public int compareTo(ProducesRequestCondition other, ServerWebExchange exchange)",
    "source_code": "\tpublic int compareTo(ProducesRequestCondition other, ServerWebExchange exchange) {\n\t\tif (this.expressions.isEmpty() && other.expressions.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\t\ttry {\n\t\t\tList<MediaType> acceptedMediaTypes = getAcceptedMediaTypes(exchange);\n\t\t\tfor (MediaType acceptedMediaType : acceptedMediaTypes) {\n\t\t\t\tint thisIndex = this.indexOfEqualMediaType(acceptedMediaType);\n\t\t\t\tint otherIndex = other.indexOfEqualMediaType(acceptedMediaType);\n\t\t\t\tint result = compareMatchingMediaTypes(this, thisIndex, other, otherIndex);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tthisIndex = this.indexOfIncludedMediaType(acceptedMediaType);\n\t\t\t\totherIndex = other.indexOfIncludedMediaType(acceptedMediaType);\n\t\t\t\tresult = compareMatchingMediaTypes(this, thisIndex, other, otherIndex);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tcatch (NotAcceptableStatusException ex) {\n\t\t\t// should never happen\n\t\t\tthrow new IllegalStateException(\"Cannot compare without having any requested media types\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.condition.ProducesRequestCondition#getContent()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "List<ProduceMediaTypeExpression>",
    "signature": "protected List<ProduceMediaTypeExpression> getContent()",
    "source_code": "\tprotected List<ProduceMediaTypeExpression> getContent() {\n\t\treturn this.expressions;\n\t}"
  },
  "org.springframework.web.reactive.result.condition.ProducesRequestCondition#getExpressions()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the contained \"produces\" expressions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "Set<MediaTypeExpression>",
    "signature": "public Set<MediaTypeExpression> getExpressions()",
    "source_code": "\tpublic Set<MediaTypeExpression> getExpressions() {\n\t\treturn new LinkedHashSet<>(this.expressions);\n\t}"
  },
  "org.springframework.web.reactive.result.condition.ProducesRequestCondition#getMatchingCondition(exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Checks if any of the contained media type expressions match the given\n\t * request 'Content-Type' header and returns an instance that is guaranteed\n\t * to contain matching expressions only. The match is performed via\n\t * {@link MediaType#isCompatibleWith(MediaType)}.\n\t * @param exchange the current exchange\n\t * @return the same instance if there are no expressions;\n\t * or a new condition with matching expressions;\n\t * or {@code null} if no expressions match.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "ProducesRequestCondition",
    "signature": "public ProducesRequestCondition getMatchingCondition(ServerWebExchange exchange)",
    "source_code": "\tpublic @Nullable ProducesRequestCondition getMatchingCondition(ServerWebExchange exchange) {\n\t\tif (CorsUtils.isPreFlightRequest(exchange.getRequest())) {\n\t\t\treturn EMPTY_CONDITION;\n\t\t}\n\t\tif (isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\t\tList<ProduceMediaTypeExpression> result = getMatchingExpressions(exchange);\n\t\tif (!CollectionUtils.isEmpty(result)) {\n\t\t\treturn new ProducesRequestCondition(result, this);\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tif (MediaType.ALL.isPresentIn(getAcceptedMediaTypes(exchange))) {\n\t\t\t\t\treturn EMPTY_CONDITION;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NotAcceptableStatusException | UnsupportedMediaTypeStatusException ex) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.reactive.result.condition.ProducesRequestCondition#getProducibleMediaTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the contained producible media types excluding negated expressions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "Set<MediaType>",
    "signature": "public Set<MediaType> getProducibleMediaTypes()",
    "source_code": "\tpublic Set<MediaType> getProducibleMediaTypes() {\n\t\tSet<MediaType> result = new LinkedHashSet<>();\n\t\tfor (ProduceMediaTypeExpression expression : this.expressions) {\n\t\t\tif (!expression.isNegated()) {\n\t\t\t\tresult.add(expression.getMediaType());\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.reactive.result.condition.ProducesRequestCondition#getToStringInfix()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "String",
    "signature": "protected String getToStringInfix()",
    "source_code": "\tprotected String getToStringInfix() {\n\t\treturn \" || \";\n\t}"
  },
  "org.springframework.web.reactive.result.condition.ProducesRequestCondition#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the condition has any media type expressions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn this.expressions.isEmpty();\n\t}"
  },
  "org.springframework.web.reactive.result.condition.ProducesRequestCondition#matchMediaType(exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 358
    },
    "return": "boolean",
    "signature": "protected boolean matchMediaType(ServerWebExchange exchange)",
    "source_code": "\t\tprotected boolean matchMediaType(ServerWebExchange exchange) throws NotAcceptableStatusException {\n\t\t\tList<MediaType> acceptedMediaTypes = getAcceptedMediaTypes(exchange);\n\t\t\tfor (MediaType acceptedMediaType : acceptedMediaTypes) {\n\t\t\t\tif (getMediaType().isCompatibleWith(acceptedMediaType) && matchParameters(acceptedMediaType)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.AbstractMessageReaderArgumentResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for argument resolvers that resolve method arguments\n * by reading the request body with an {@link HttpMessageReader}.\n *\n * <p>Applies validation if the method argument is annotated with any\n * {@linkplain org.springframework.validation.annotation.ValidationAnnotationUtils#determineValidationHints\n * annotations that trigger validation}. Validation failure results in a\n * {@link ServerWebInputException}.\n *\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "signature": "public class AbstractMessageReaderArgumentResolver",
    "source_code": "public abstract class AbstractMessageReaderArgumentResolver extends HandlerMethodArgumentResolverSupport {\n\n\tprivate static final Set<HttpMethod> SUPPORTED_METHODS =\n\t\t\tSet.of(HttpMethod.POST, HttpMethod.PUT, HttpMethod.PATCH);\n\n\n\tprivate final List<HttpMessageReader<?>> messageReaders;\n\n\n\t/**\n\t * Constructor with {@link HttpMessageReader}'s and a {@link Validator}.\n\t * @param readers the readers to convert from the request body\n\t */\n\tprotected AbstractMessageReaderArgumentResolver(List<HttpMessageReader<?>> readers) {\n\t\tthis(readers, ReactiveAdapterRegistry.getSharedInstance());\n\t}\n\n\t/**\n\t * Constructor that also accepts a {@link ReactiveAdapterRegistry}.\n\t * @param messageReaders readers to convert from the request body\n\t * @param adapterRegistry for adapting to other reactive types from Flux and Mono\n\t */\n\tprotected AbstractMessageReaderArgumentResolver(\n\t\t\tList<HttpMessageReader<?>> messageReaders, ReactiveAdapterRegistry adapterRegistry) {\n\n\t\tsuper(adapterRegistry);\n\t\tAssert.notEmpty(messageReaders, \"At least one HttpMessageReader is required\");\n\t\tAssert.notNull(adapterRegistry, \"ReactiveAdapterRegistry is required\");\n\t\tthis.messageReaders = messageReaders;\n\t}\n\n\n\t/**\n\t * Return the configured message converters.\n\t */\n\tpublic List<HttpMessageReader<?>> getMessageReaders() {\n\t\treturn this.messageReaders;\n\t}\n\n\n\t/**\n\t * Read the body from a method argument with {@link HttpMessageReader}.\n\t * @param bodyParameter the {@link MethodParameter} to read\n\t * @param isBodyRequired true if the body is required\n\t * @param bindingContext the binding context to use\n\t * @param exchange the current exchange\n\t * @return the body\n\t * @see #readBody(MethodParameter, MethodParameter, boolean, BindingContext, ServerWebExchange)\n\t */\n\tprotected Mono<Object> readBody(MethodParameter bodyParameter, boolean isBodyRequired,\n\t\t\tBindingContext bindingContext, ServerWebExchange exchange) {\n\n\t\treturn this.readBody(bodyParameter, null, isBodyRequired, bindingContext, exchange);\n\t}\n\n\t/**\n\t * Read the body from a method argument with {@link HttpMessageReader}.\n\t * @param bodyParam represents the element type for the body\n\t * @param actualParam the actual method argument type; possibly different\n\t * from {@code bodyParam}, for example, for an {@code HttpEntity} argument\n\t * @param isBodyRequired true if the body is required\n\t * @param bindingContext the binding context to use\n\t * @param exchange the current exchange\n\t * @return a Mono with the value to use for the method argument\n\t * @since 5.0.2\n\t */\n\tprotected Mono<Object> readBody(MethodParameter bodyParam, @Nullable MethodParameter actualParam,\n\t\t\tboolean isBodyRequired, BindingContext bindingContext, ServerWebExchange exchange) {\n\n\t\tResolvableType bodyType = ResolvableType.forMethodParameter(bodyParam);\n\t\tResolvableType actualType = (actualParam != null ? ResolvableType.forMethodParameter(actualParam) : bodyType);\n\t\tClass<?> resolvedType = bodyType.resolve();\n\t\tReactiveAdapter adapter = (resolvedType != null ? getAdapterRegistry().getAdapter(resolvedType) : null);\n\t\tResolvableType elementType = (adapter != null ? bodyType.getGeneric() : bodyType);\n\t\tisBodyRequired = isBodyRequired || (adapter != null && !adapter.supportsEmpty());\n\n\t\tServerHttpRequest request = exchange.getRequest();\n\t\tServerHttpResponse response = exchange.getResponse();\n\n\t\tMediaType contentType;\n\t\tHttpHeaders headers = request.getHeaders();\n\t\ttry {\n\t\t\tcontentType = headers.getContentType();\n\t\t}\n\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\tthrow new UnsupportedMediaTypeStatusException(\n\t\t\t\t\t\"Can't parse Content-Type [\" + headers.getFirst(\"Content-Type\") + \"]: \" + ex.getMessage(),\n\t\t\t\t\tgetSupportedMediaTypes(elementType));\n\t\t}\n\n\t\tMediaType mediaType = (contentType != null ? contentType : MediaType.APPLICATION_OCTET_STREAM);\n\t\tObject[] hints = extractValidationHints(bodyParam);\n\n\t\tif (mediaType.isCompatibleWith(MediaType.APPLICATION_FORM_URLENCODED)) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Form data is accessed via ServerWebExchange.getFormData() in WebFlux.\");\n\t\t\t}\n\t\t\treturn Mono.error(new ResponseStatusException(HttpStatus.UNSUPPORTED_MEDIA_TYPE));\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(exchange.getLogPrefix() + (contentType != null ?\n\t\t\t\t\t\"Content-Type:\" + contentType :\n\t\t\t\t\t\"No Content-Type, using \" + MediaType.APPLICATION_OCTET_STREAM));\n\t\t}\n\n\t\tfor (HttpMessageReader<?> reader : getMessageReaders()) {\n\t\t\tif (reader.canRead(elementType, mediaType)) {\n\t\t\t\tMap<String, Object> readHints = Hints.from(Hints.LOG_PREFIX_HINT, exchange.getLogPrefix());\n\t\t\t\tif (adapter != null && adapter.isMultiValue()) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(exchange.getLogPrefix() + \"0..N [\" + elementType + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tFlux<?> flux = reader.read(actualType, elementType, request, response, readHints);\n\t\t\t\t\tflux = flux.onErrorMap(ex -> handleReadError(bodyParam, ex));\n\t\t\t\t\tif (isBodyRequired) {\n\t\t\t\t\t\tflux = flux.switchIfEmpty(Flux.error(() -> handleMissingBody(bodyParam)));\n\t\t\t\t\t}\n\t\t\t\t\tif (hints != null) {\n\t\t\t\t\t\tflux = flux.doOnNext(target ->\n\t\t\t\t\t\t\t\tvalidate(target, hints, bodyParam, bindingContext, exchange));\n\t\t\t\t\t}\n\t\t\t\t\treturn Mono.just(adapter.fromPublisher(flux));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Single-value (with or without reactive type wrapper)\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(exchange.getLogPrefix() + \"0..1 [\" + elementType + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tMono<?> mono = reader.readMono(actualType, elementType, request, response, readHints);\n\t\t\t\t\tmono = mono.onErrorMap(ex -> handleReadError(bodyParam, ex));\n\t\t\t\t\tif (isBodyRequired) {\n\t\t\t\t\t\tmono = mono.switchIfEmpty(Mono.error(() -> handleMissingBody(bodyParam)));\n\t\t\t\t\t}\n\t\t\t\t\tif (hints != null) {\n\t\t\t\t\t\tmono = mono.doOnNext(target ->\n\t\t\t\t\t\t\t\tvalidate(target, hints, bodyParam, bindingContext, exchange));\n\t\t\t\t\t}\n\t\t\t\t\treturn (adapter != null ? Mono.just(adapter.fromPublisher(mono)) : Mono.from(mono));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// No compatible reader but body may be empty.\n\n\t\tHttpMethod method = request.getMethod();\n\t\tif (contentType == null && SUPPORTED_METHODS.contains(method)) {\n\t\t\tFlux<DataBuffer> body = request.getBody().doOnNext(buffer -> {\n\t\t\t\tDataBufferUtils.release(buffer);\n\t\t\t\t// Body not empty, back to HTTP 415\n\t\t\t\tthrow new UnsupportedMediaTypeStatusException(\n\t\t\t\t\t\tmediaType, getSupportedMediaTypes(elementType), elementType);\n\t\t\t});\n\t\t\tif (isBodyRequired) {\n\t\t\t\tbody = body.switchIfEmpty(Mono.error(() -> handleMissingBody(bodyParam)));\n\t\t\t}\n\t\t\treturn (adapter != null ? Mono.just(adapter.fromPublisher(body)) : Mono.from(body));\n\t\t}\n\n\t\treturn Mono.error(new UnsupportedMediaTypeStatusException(\n\t\t\t\tmediaType, getSupportedMediaTypes(elementType), elementType));\n\t}\n\n\tprivate Throwable handleReadError(MethodParameter parameter, Throwable ex) {\n\t\tif (ex instanceof DataBufferLimitException) {\n\t\t\treturn new PayloadTooLargeException(ex);\n\t\t}\n\t\tif (ex instanceof DecodingException) {\n\t\t\treturn new ServerWebInputException(\"Failed to read HTTP message\", parameter, ex);\n\t\t}\n\t\treturn ex;\n\t}\n\n\tprivate ServerWebInputException handleMissingBody(MethodParameter parameter) {\n\n\t\tDecodingException cause = new DecodingException(\n\t\t\t\t\"No request body for: \" + parameter.getExecutable().toGenericString());\n\n\t\tServerWebInputException ex = new ServerWebInputException(\"No request body\", parameter, cause);\n\t\tex.setDetail(\"Invalid request content\");\n\n\t\treturn ex;\n\t}\n\n\t/**\n\t * Check if the given MethodParameter requires validation and if so return\n\t * a (possibly empty) Object[] with validation hints. A return value of\n\t * {@code null} indicates that validation is not required.\n\t */\n\tprivate Object @Nullable [] extractValidationHints(MethodParameter parameter) {\n\t\tAnnotation[] annotations = parameter.getParameterAnnotations();\n\t\tfor (Annotation ann : annotations) {\n\t\t\tObject[] hints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (hints != null) {\n\t\t\t\treturn hints;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate void validate(Object target, Object[] validationHints, MethodParameter parameter,\n\t\t\tBindingContext binding, ServerWebExchange exchange) {\n\n\t\tString name = Conventions.getVariableNameForParameter(parameter);\n\t\tResolvableType type = ResolvableType.forMethodParameter(parameter);\n\t\tWebExchangeDataBinder binder = binding.createDataBinder(exchange, target, name, type);\n\t\ttry {\n\t\t\tLocaleContextHolder.setLocaleContext(exchange.getLocaleContext());\n\t\t\tbinder.validate(validationHints);\n\t\t}\n\t\tfinally {\n\t\t\tLocaleContextHolder.resetLocaleContext();\n\t\t}\n\t\tif (binder.getBindingResult().hasErrors()) {\n\t\t\tthrow new WebExchangeBindException(parameter, binder.getBindingResult());\n\t\t}\n\t}\n\n\tprivate List<MediaType> getSupportedMediaTypes(ResolvableType elementType) {\n\t\tList<MediaType> mediaTypes = new ArrayList<>();\n\t\tfor (HttpMessageReader<?> reader : this.messageReaders) {\n\t\t\tmediaTypes.addAll(reader.getReadableMediaTypes(elementType));\n\t\t}\n\t\treturn mediaTypes;\n\t}\n\n}"
  },
  "org.springframework.web.reactive.result.method.annotation.AbstractMessageReaderArgumentResolver#readBody(bodyParam,actualParam,isBodyRequired,bindingContext,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Read the body from a method argument with {@link HttpMessageReader}.\n\t * @param bodyParam represents the element type for the body\n\t * @param actualParam the actual method argument type; possibly different\n\t * from {@code bodyParam}, for example, for an {@code HttpEntity} argument\n\t * @param isBodyRequired true if the body is required\n\t * @param bindingContext the binding context to use\n\t * @param exchange the current exchange\n\t * @return a Mono with the value to use for the method argument\n\t * @since 5.0.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bodyParam",
      "actualParam",
      "isBodyRequired",
      "bindingContext",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "Mono<Object>",
    "signature": "protected Mono<Object> readBody(MethodParameter bodyParam, @Nullable MethodParameter actualParam,\n\t\t\tboolean isBodyRequired, BindingContext bindingContext, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<Object> readBody(MethodParameter bodyParam, @Nullable MethodParameter actualParam,"
  },
  "org.springframework.web.reactive.result.method.annotation.AbstractMessageReaderArgumentResolver#readBody(bodyParameter,isBodyRequired,bindingContext,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Read the body from a method argument with {@link HttpMessageReader}.\n\t * @param bodyParameter the {@link MethodParameter} to read\n\t * @param isBodyRequired true if the body is required\n\t * @param bindingContext the binding context to use\n\t * @param exchange the current exchange\n\t * @return the body\n\t * @see #readBody(MethodParameter, MethodParameter, boolean, BindingContext, ServerWebExchange)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bodyParameter",
      "isBodyRequired",
      "bindingContext",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "Mono<Object>",
    "signature": "protected Mono<Object> readBody(MethodParameter bodyParameter, boolean isBodyRequired,\n\t\t\tBindingContext bindingContext, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<Object> readBody(MethodParameter bodyParameter, boolean isBodyRequired,"
  },
  "org.springframework.web.reactive.result.view.RedirectView": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * View that redirects to an absolute or context relative URL. The URL may be a\n * URI template in which case the URI template variables will be replaced with\n * values from the model or with URI variables from the current request.\n *\n * <p>By default {@link HttpStatus#SEE_OTHER} is used but alternate status codes\n * may be supplied via constructor or setters arguments.\n *\n * @author Sebastien Deleuze\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public class RedirectView",
    "source_code": "public class RedirectView extends AbstractUrlBasedView {\n\n\tprivate static final Pattern URI_TEMPLATE_VARIABLE_PATTERN = Pattern.compile(\"\\\\{([^/]+?)\\\\}\");\n\n\n\tprivate HttpStatusCode statusCode = HttpStatus.SEE_OTHER;\n\n\tprivate boolean contextRelative = true;\n\n\tprivate boolean propagateQuery = false;\n\n\tprivate String @Nullable [] hosts;\n\n\n\t/**\n\t * Constructor for use as a bean.\n\t */\n\tpublic RedirectView() {\n\t}\n\n\t/**\n\t * Create a new {@code RedirectView} with the given redirect URL.\n\t * <p>Status code {@link HttpStatus#SEE_OTHER} is used by default.\n\t */\n\tpublic RedirectView(String redirectUrl) {\n\t\tsuper(redirectUrl);\n\t}\n\n\t/**\n\t * Create a new {@code RedirectView} with the given URL and an alternate\n\t * redirect status code such as {@link HttpStatus#TEMPORARY_REDIRECT} or\n\t * {@link HttpStatus#PERMANENT_REDIRECT}.\n\t */\n\tpublic RedirectView(String redirectUrl, HttpStatusCode statusCode) {\n\t\tsuper(redirectUrl);\n\t\tsetStatusCode(statusCode);\n\t}\n\n\n\t/**\n\t * Set an alternate redirect status code such as\n\t * {@link HttpStatus#TEMPORARY_REDIRECT} or\n\t * {@link HttpStatus#PERMANENT_REDIRECT}.\n\t */\n\tpublic void setStatusCode(HttpStatusCode statusCode) {\n\t\tAssert.isTrue(statusCode.is3xxRedirection(), () -> \"Not a redirect status code: \" + statusCode);\n\t\tthis.statusCode = statusCode;\n\t}\n\n\t/**\n\t * Get the redirect status code to use.\n\t */\n\tpublic HttpStatusCode getStatusCode() {\n\t\treturn this.statusCode;\n\t}\n\n\t/**\n\t * Whether to interpret a given redirect URL that starts with a slash (\"/\")\n\t * as relative to the current context path ({@code true}, the default) or\n\t * relative to the web server root ({@code false}).\n\t */\n\tpublic void setContextRelative(boolean contextRelative) {\n\t\tthis.contextRelative = contextRelative;\n\t}\n\n\t/**\n\t * Whether to interpret URLs as relative to the current context path.\n\t */\n\tpublic boolean isContextRelative() {\n\t\treturn this.contextRelative;\n\t}\n\n\t/**\n\t * Whether to append the query string of the current URL to the redirect URL\n\t * ({@code true}) or not ({@code false}, the default).\n\t */\n\tpublic void setPropagateQuery(boolean propagateQuery) {\n\t\tthis.propagateQuery = propagateQuery;\n\t}\n\n\t/**\n\t * Whether the query string of the current URL is appended to the redirect URL.\n\t */\n\tpublic boolean isPropagateQuery() {\n\t\treturn this.propagateQuery;\n\t}\n\n\t/**\n\t * Configure one or more hosts associated with the application.\n\t * <p>All other hosts will be considered external hosts.\n\t * <p>In effect this provides a way turn off encoding for URLs that\n\t * have a host and that host is not listed as a known host.\n\t * <p>If not set (the default) all redirect URLs are encoded.\n\t * @param hosts one or more application hosts\n\t */\n\tpublic void setHosts(String @Nullable ... hosts) {\n\t\tthis.hosts = hosts;\n\t}\n\n\t/**\n\t * Return the configured application hosts.\n\t */\n\tpublic String @Nullable [] getHosts() {\n\t\treturn this.hosts;\n\t}\n\n\t@Override\n\tpublic boolean isRedirectView() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean checkResourceExists(Locale locale) throws Exception {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Convert model to request parameters and redirect to the given URL.\n\t */\n\t@Override\n\tprotected Mono<Void> renderInternal(\n\t\t\tMap<String, Object> model, @Nullable MediaType contentType, ServerWebExchange exchange) {\n\n\t\tString targetUrl = createTargetUrl(model, exchange);\n\t\treturn sendRedirect(targetUrl, exchange);\n\t}\n\n\t/**\n\t * Create the target URL and, if necessary, pre-pend the contextPath, expand\n\t * URI template variables, append the current request query, and apply the\n\t * configured {@link #getRequestDataValueProcessor()\n\t * RequestDataValueProcessor}.\n\t */\n\tprotected final String createTargetUrl(Map<String, Object> model, ServerWebExchange exchange) {\n\t\tString url = getUrl();\n\t\tAssert.state(url != null, \"'url' not set\");\n\n\t\tServerHttpRequest request = exchange.getRequest();\n\n\t\tStringBuilder targetUrl = new StringBuilder();\n\t\tif (isContextRelative() && url.startsWith(\"/\")) {\n\t\t\ttargetUrl.append(request.getPath().contextPath().value());\n\t\t}\n\t\ttargetUrl.append(url);\n\n\t\tif (StringUtils.hasText(targetUrl)) {\n\t\t\tMap<String, String> uriVars = getCurrentUriVariables(exchange);\n\t\t\ttargetUrl = expandTargetUrlTemplate(targetUrl.toString(), model, uriVars);\n\t\t}\n\n\t\tif (isPropagateQuery()) {\n\t\t\ttargetUrl = appendCurrentRequestQuery(targetUrl.toString(), request);\n\t\t}\n\n\t\tString result = targetUrl.toString();\n\n\t\tRequestDataValueProcessor processor = getRequestDataValueProcessor();\n\t\treturn (processor != null ? processor.processUrl(exchange, result) : result);\n\t}\n\n\tprivate Map<String, String> getCurrentUriVariables(ServerWebExchange exchange) {\n\t\tString name = HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE;\n\t\treturn exchange.getAttributeOrDefault(name, Collections.emptyMap());\n\t}\n\n\t/**\n\t * Expand URI template variables in the target URL with either model\n\t * attribute values or as a fallback with URI variable values from the\n\t * current request. Values are encoded.\n\t */\n\tprotected StringBuilder expandTargetUrlTemplate(String targetUrl,\n\t\t\tMap<String, Object> model, Map<String, String> uriVariables) {\n\n\t\tMatcher matcher = URI_TEMPLATE_VARIABLE_PATTERN.matcher(targetUrl);\n\t\tboolean found = matcher.find();\n\t\tif (!found) {\n\t\t\treturn new StringBuilder(targetUrl);\n\t\t}\n\t\tStringBuilder result = new StringBuilder();\n\t\tint endLastMatch = 0;\n\t\twhile (found) {\n\t\t\tString name = matcher.group(1);\n\t\t\tObject value = (model.containsKey(name) ? model.get(name) : uriVariables.get(name));\n\t\t\tAssert.notNull(value, () -> \"No value for URI variable '\" + name + \"'\");\n\t\t\tresult.append(targetUrl, endLastMatch, matcher.start());\n\t\t\tresult.append(encodeUriVariable(value.toString()));\n\t\t\tendLastMatch = matcher.end();\n\t\t\tfound = matcher.find();\n\t\t}\n\t\tresult.append(targetUrl, endLastMatch, targetUrl.length());\n\t\treturn result;\n\t}\n\n\tprivate String encodeUriVariable(String text) {\n\t\t// Strict encoding of all reserved URI characters\n\t\treturn UriUtils.encode(text, StandardCharsets.UTF_8);\n\t}\n\n\t/**\n\t * Append the query of the current request to the target redirect URL.\n\t */\n\tprotected StringBuilder appendCurrentRequestQuery(String targetUrl, ServerHttpRequest request) {\n\t\tString query = request.getURI().getRawQuery();\n\t\tif (!StringUtils.hasText(query)) {\n\t\t\treturn new StringBuilder(targetUrl);\n\t\t}\n\n\t\tint index = targetUrl.indexOf('#');\n\t\tString fragment = (index > -1 ? targetUrl.substring(index) : null);\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(index != -1 ? targetUrl.substring(0, index) : targetUrl);\n\t\tresult.append(targetUrl.indexOf('?') < 0 ? '?' : '&').append(query);\n\n\t\tif (fragment != null) {\n\t\t\tresult.append(fragment);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Send a redirect back to the HTTP client.\n\t * @param targetUrl the target URL to redirect to\n\t * @param exchange current exchange\n\t */\n\tprotected Mono<Void> sendRedirect(String targetUrl, ServerWebExchange exchange) {\n\t\tString transformedUrl = (isRemoteHost(targetUrl) ? targetUrl : exchange.transformUrl(targetUrl));\n\t\tServerHttpResponse response = exchange.getResponse();\n\t\tresponse.getHeaders().setLocation(URI.create(transformedUrl));\n\t\tresponse.setStatusCode(getStatusCode());\n\t\treturn Mono.empty();\n\t}\n\n\t/**\n\t * Whether the given targetUrl has a host that is a \"foreign\" system in which\n\t * case {@link jakarta.servlet.http.HttpServletResponse#encodeRedirectURL} will not be applied.\n\t * <p>This method returns {@code true} if the {@link #setHosts(String[])}\n\t * property is configured and the target URL has a host that does not match.\n\t * @param targetUrl the target redirect URL\n\t * @return {@code true} if the target URL has a remote host, {@code false} if\n\t * the URL does not have a host or the \"host\" property is not configured\n\t */\n\tprotected boolean isRemoteHost(String targetUrl) {\n\t\tif (ObjectUtils.isEmpty(this.hosts)) {\n\t\t\treturn false;\n\t\t}\n\t\tString targetHost = UriComponentsBuilder.fromUriString(targetUrl).build().getHost();\n\t\tif (!StringUtils.hasLength(targetHost)) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (String host : this.hosts) {\n\t\t\tif (targetHost.equals(host)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}"
  },
  "org.springframework.web.reactive.result.view.RedirectView#appendCurrentRequestQuery(targetUrl,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Append the query of the current request to the target redirect URL.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "StringBuilder",
    "signature": "protected StringBuilder appendCurrentRequestQuery(String targetUrl, ServerHttpRequest request)",
    "source_code": "\tprotected StringBuilder appendCurrentRequestQuery(String targetUrl, ServerHttpRequest request) {\n\t\tString query = request.getURI().getRawQuery();\n\t\tif (!StringUtils.hasText(query)) {\n\t\t\treturn new StringBuilder(targetUrl);\n\t\t}\n\n\t\tint index = targetUrl.indexOf('#');\n\t\tString fragment = (index > -1 ? targetUrl.substring(index) : null);\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(index != -1 ? targetUrl.substring(0, index) : targetUrl);\n\t\tresult.append(targetUrl.indexOf('?') < 0 ? '?' : '&').append(query);\n\n\t\tif (fragment != null) {\n\t\t\tresult.append(fragment);\n\t\t}\n\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.reactive.result.view.RedirectView#checkResourceExists(locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "boolean",
    "signature": "public boolean checkResourceExists(Locale locale)",
    "source_code": "\tpublic boolean checkResourceExists(Locale locale) throws Exception {\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.reactive.result.view.RedirectView#createTargetUrl(Map<String,model,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the target URL and, if necessary, pre-pend the contextPath, expand\n\t * URI template variables, append the current request query, and apply the\n\t * configured {@link #getRequestDataValueProcessor()\n\t * RequestDataValueProcessor}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "String",
    "signature": "protected String createTargetUrl(Map<String, Object> model, ServerWebExchange exchange)",
    "source_code": "\tprotected final String createTargetUrl(Map<String, Object> model, ServerWebExchange exchange) {\n\t\tString url = getUrl();\n\t\tAssert.state(url != null, \"'url' not set\");\n\n\t\tServerHttpRequest request = exchange.getRequest();\n\n\t\tStringBuilder targetUrl = new StringBuilder();\n\t\tif (isContextRelative() && url.startsWith(\"/\")) {\n\t\t\ttargetUrl.append(request.getPath().contextPath().value());\n\t\t}\n\t\ttargetUrl.append(url);\n\n\t\tif (StringUtils.hasText(targetUrl)) {\n\t\t\tMap<String, String> uriVars = getCurrentUriVariables(exchange);\n\t\t\ttargetUrl = expandTargetUrlTemplate(targetUrl.toString(), model, uriVars);\n\t\t}\n\n\t\tif (isPropagateQuery()) {\n\t\t\ttargetUrl = appendCurrentRequestQuery(targetUrl.toString(), request);\n\t\t}\n\n\t\tString result = targetUrl.toString();\n\n\t\tRequestDataValueProcessor processor = getRequestDataValueProcessor();\n\t\treturn (processor != null ? processor.processUrl(exchange, result) : result);\n\t}"
  },
  "org.springframework.web.reactive.result.view.RedirectView#expandTargetUrlTemplate(targetUrl,Map<String,model,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Expand URI template variables in the target URL with either model\n\t * attribute values or as a fallback with URI variable values from the\n\t * current request. Values are encoded.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "Map<String",
      "model",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "StringBuilder",
    "signature": "protected StringBuilder expandTargetUrlTemplate(String targetUrl,\n\t\t\tMap<String, Object> model, Map<String, String> uriVariables)",
    "source_code": "\tprotected StringBuilder expandTargetUrlTemplate(String targetUrl,"
  },
  "org.springframework.web.reactive.result.view.RedirectView#getStatusCode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the redirect status code to use.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "HttpStatusCode",
    "signature": "public HttpStatusCode getStatusCode()",
    "source_code": "\tpublic HttpStatusCode getStatusCode() {\n\t\treturn this.statusCode;\n\t}"
  },
  "org.springframework.web.reactive.result.view.RedirectView#isContextRelative()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to interpret URLs as relative to the current context path.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "boolean",
    "signature": "public boolean isContextRelative()",
    "source_code": "\tpublic boolean isContextRelative() {\n\t\treturn this.contextRelative;\n\t}"
  },
  "org.springframework.web.reactive.result.view.RedirectView#isPropagateQuery()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the query string of the current URL is appended to the redirect URL.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "boolean",
    "signature": "public boolean isPropagateQuery()",
    "source_code": "\tpublic boolean isPropagateQuery() {\n\t\treturn this.propagateQuery;\n\t}"
  },
  "org.springframework.web.reactive.result.view.RedirectView#isRedirectView()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "boolean",
    "signature": "public boolean isRedirectView()",
    "source_code": "\tpublic boolean isRedirectView() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.reactive.result.view.RedirectView#isRemoteHost(targetUrl)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the given targetUrl has a host that is a \"foreign\" system in which\n\t * case {@link jakarta.servlet.http.HttpServletResponse#encodeRedirectURL} will not be applied.\n\t * <p>This method returns {@code true} if the {@link #setHosts(String[])}\n\t * property is configured and the target URL has a host that does not match.\n\t * @param targetUrl the target redirect URL\n\t * @return {@code true} if the target URL has a remote host, {@code false} if\n\t * the URL does not have a host or the \"host\" property is not configured\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "boolean",
    "signature": "protected boolean isRemoteHost(String targetUrl)",
    "source_code": "\tprotected boolean isRemoteHost(String targetUrl) {\n\t\tif (ObjectUtils.isEmpty(this.hosts)) {\n\t\t\treturn false;\n\t\t}\n\t\tString targetHost = UriComponentsBuilder.fromUriString(targetUrl).build().getHost();\n\t\tif (!StringUtils.hasLength(targetHost)) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (String host : this.hosts) {\n\t\t\tif (targetHost.equals(host)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.reactive.result.view.RedirectView#renderInternal(Map<String,model,contentType,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert model to request parameters and redirect to the given URL.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "contentType",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> renderInternal(Map<String, Object> model, @Nullable MediaType contentType, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<Void> renderInternal("
  },
  "org.springframework.web.reactive.result.view.RedirectView#sendRedirect(targetUrl,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Send a redirect back to the HTTP client.\n\t * @param targetUrl the target URL to redirect to\n\t * @param exchange current exchange\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> sendRedirect(String targetUrl, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<Void> sendRedirect(String targetUrl, ServerWebExchange exchange) {\n\t\tString transformedUrl = (isRemoteHost(targetUrl) ? targetUrl : exchange.transformUrl(targetUrl));\n\t\tServerHttpResponse response = exchange.getResponse();\n\t\tresponse.getHeaders().setLocation(URI.create(transformedUrl));\n\t\tresponse.setStatusCode(getStatusCode());\n\t\treturn Mono.empty();\n\t}"
  },
  "org.springframework.web.reactive.result.view.RedirectView#setContextRelative(contextRelative)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to interpret a given redirect URL that starts with a slash (\"/\")\n\t * as relative to the current context path ({@code true}, the default) or\n\t * relative to the web server root ({@code false}).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contextRelative"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void setContextRelative(boolean contextRelative)",
    "source_code": "\tpublic void setContextRelative(boolean contextRelative) {\n\t\tthis.contextRelative = contextRelative;\n\t}"
  },
  "org.springframework.web.reactive.result.view.RedirectView#setHosts(hosts)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure one or more hosts associated with the application.\n\t * <p>All other hosts will be considered external hosts.\n\t * <p>In effect this provides a way turn off encoding for URLs that\n\t * have a host and that host is not listed as a known host.\n\t * <p>If not set (the default) all redirect URLs are encoded.\n\t * @param hosts one or more application hosts\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hosts"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "public void setHosts(String @Nullable ... hosts)",
    "source_code": "\tpublic void setHosts(String @Nullable ... hosts) {\n\t\tthis.hosts = hosts;\n\t}"
  },
  "org.springframework.web.reactive.result.view.RedirectView#setPropagateQuery(propagateQuery)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to append the query string of the current URL to the redirect URL\n\t * ({@code true}) or not ({@code false}, the default).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propagateQuery"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void setPropagateQuery(boolean propagateQuery)",
    "source_code": "\tpublic void setPropagateQuery(boolean propagateQuery) {\n\t\tthis.propagateQuery = propagateQuery;\n\t}"
  },
  "org.springframework.web.reactive.result.view.RedirectView#setStatusCode(statusCode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set an alternate redirect status code such as\n\t * {@link HttpStatus#TEMPORARY_REDIRECT} or\n\t * {@link HttpStatus#PERMANENT_REDIRECT}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCode"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void setStatusCode(HttpStatusCode statusCode)",
    "source_code": "\tpublic void setStatusCode(HttpStatusCode statusCode) {\n\t\tAssert.isTrue(statusCode.is3xxRedirection(), () -> \"Not a redirect status code: \" + statusCode);\n\t\tthis.statusCode = statusCode;\n\t}"
  },
  "org.springframework.web.reactive.result.view.UrlBasedViewResolver#getViewNames()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the view names (or name patterns) that can be handled by this\n\t * {@link ViewResolver}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "String[]",
    "signature": "protected String[] getViewNames()",
    "source_code": "\tprotected String[] getViewNames() {\n\t\treturn this.viewNames;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateConfig": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Interface to be implemented by objects that configure and manage a\n * JSR-223 {@link ScriptEngine} for automatic lookup in a web environment.\n * Detected and used by {@link ScriptTemplateView}.\n *\n * @author Sebastien Deleuze\n * @since 5.0\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public interface ScriptTemplateConfig",
    "source_code": "public interface ScriptTemplateConfig {\n\n\t/**\n\t * Return the {@link ScriptEngine} to use by the views.\n\t */\n\t@Nullable ScriptEngine getEngine();\n\n\t/**\n\t * Return the engine supplier that will be used to instantiate the {@link ScriptEngine}.\n\t * @since 5.2\n\t */\n\t@Nullable Supplier<ScriptEngine> getEngineSupplier();\n\n\t/**\n\t * Return the engine name that will be used to instantiate the {@link ScriptEngine}.\n\t */\n\t@Nullable String getEngineName();\n\n\t/**\n\t * Return whether to use a shared engine for all threads or whether to create\n\t * thread-local engine instances for each thread.\n\t */\n\t@Nullable Boolean isSharedEngine();\n\n\t/**\n\t * Return the scripts to be loaded by the script engine (library or user provided).\n\t */\n\tString @Nullable [] getScripts();\n\n\t/**\n\t * Return the object where the render function belongs (optional).\n\t */\n\t@Nullable String getRenderObject();\n\n\t/**\n\t * Return the render function name (optional). If not specified, the script templates\n\t * will be evaluated with {@link ScriptEngine#eval(String, Bindings)}.\n\t */\n\t@Nullable String getRenderFunction();\n\n\t/**\n\t * Return the charset used to read script and template files.\n\t */\n\t@Nullable Charset getCharset();\n\n\t/**\n\t * Return the resource loader path(s) via a Spring resource location.\n\t */\n\t@Nullable String getResourceLoaderPath();\n\n}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An implementation of the Spring WebFlux {@link ScriptTemplateConfig} for\n * creating a {@code ScriptEngine} for use in a web application.\n *\n * <pre class=\"code\">\n * // Add the following to an &#64;Configuration class\n * &#64;Bean\n * public ScriptTemplateConfigurer mustacheConfigurer() {\n *    ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();\n *    configurer.setEngineName(\"nashorn\");\n *    configurer.setScripts(\"mustache.js\");\n *    configurer.setRenderObject(\"Mustache\");\n *    configurer.setRenderFunction(\"render\");\n *    return configurer;\n * }\n * </pre>\n *\n * <p><b>NOTE:</b> It is possible to use non thread-safe script engines with\n * templating libraries not designed for concurrency, like Handlebars or React running on\n * Nashorn, by setting the {@link #setSharedEngine sharedEngine} property to {@code false}.\n *\n * @author Sebastien Deleuze\n * @since 5.0\n * @see ScriptTemplateView\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public class ScriptTemplateConfigurer",
    "source_code": "public class ScriptTemplateConfigurer implements ScriptTemplateConfig {\n\n\tprivate @Nullable ScriptEngine engine;\n\n\tprivate @Nullable Supplier<ScriptEngine> engineSupplier;\n\n\tprivate @Nullable String engineName;\n\n\tprivate @Nullable Boolean sharedEngine;\n\n\tprivate String @Nullable [] scripts;\n\n\tprivate @Nullable String renderObject;\n\n\tprivate @Nullable String renderFunction;\n\n\tprivate @Nullable Charset charset;\n\n\tprivate @Nullable String resourceLoaderPath;\n\n\n\t/**\n\t * Default constructor.\n\t */\n\tpublic ScriptTemplateConfigurer() {\n\t}\n\n\t/**\n\t * Create a new ScriptTemplateConfigurer using the given engine name.\n\t */\n\tpublic ScriptTemplateConfigurer(String engineName) {\n\t\tthis.engineName = engineName;\n\t}\n\n\n\t/**\n\t * Set the {@link ScriptEngine} to use by the view.\n\t * If {@code renderFunction} is specified, the script engine must implement {@code Invocable}.\n\t * You must define {@code engine} or {@code engineName}, not both.\n\t * <p>When the {@code sharedEngine} flag is set to {@code false}, you should not specify\n\t * the script engine with this setter, but with the {@link #setEngineName(String)}\n\t * or {@link #setEngineSupplier(Supplier)} (since it implies multiple lazy\n\t * instantiations of the script engine).\n\t * @see #setEngineName(String)\n\t * @see #setEngineSupplier(Supplier)\n\t */\n\tpublic void setEngine(@Nullable ScriptEngine engine) {\n\t\tthis.engine = engine;\n\t}\n\n\t@Override\n\tpublic @Nullable ScriptEngine getEngine() {\n\t\treturn this.engine;\n\t}\n\n\t/**\n\t * Set the {@link ScriptEngine} supplier to use by the view, usually used with\n\t * {@link #setSharedEngine(Boolean)} set to {@code false}.\n\t * If {@code renderFunction} is specified, the script engine must implement {@code Invocable}.\n\t * You must either define {@code engineSupplier}, {@code engine} or {@code engineName}.\n\t * @since 5.2\n\t * @see #setEngine(ScriptEngine)\n\t * @see #setEngineName(String)\n\t */\n\tpublic void setEngineSupplier(@Nullable Supplier<ScriptEngine> engineSupplier) {\n\t\tthis.engineSupplier = engineSupplier;\n\t}\n\n\t@Override\n\tpublic @Nullable Supplier<ScriptEngine> getEngineSupplier() {\n\t\treturn this.engineSupplier;\n\t}\n\n\t/**\n\t * Set the engine name that will be used to instantiate the {@link ScriptEngine}.\n\t * If {@code renderFunction} is specified, the script engine must implement {@code Invocable}.\n\t * You must define {@code engine} or {@code engineName}, not both.\n\t * @see #setEngine(ScriptEngine)\n\t * @see #setEngineSupplier(Supplier)\n\t */\n\tpublic void setEngineName(@Nullable String engineName) {\n\t\tthis.engineName = engineName;\n\t}\n\n\t@Override\n\tpublic @Nullable String getEngineName() {\n\t\treturn this.engineName;\n\t}\n\n\t/**\n\t * When set to {@code false}, a new  {@link ScriptEngine} instance will be created\n\t * for each request, else the same instance will be reused.\n\t * This flag should be set to {@code false} for those using non thread-safe script\n\t * engines with templating libraries not designed for\n\t * concurrency, like Handlebars or React running on Nashorn for example.\n\t * <p>When this flag is set to {@code false}, the script engine must be specified using\n\t * {@link #setEngineName(String)}. Using {@link #setEngine(ScriptEngine)} is not\n\t * possible because multiple instances of the script engine need to be created for\n\t * each request.\n\t * @see <a href=\"https://docs.oracle.com/javase/8/docs/api/javax/script/ScriptEngineFactory.html#getParameter-java.lang.String-\">THREADING ScriptEngine parameter</a>\n\t */\n\tpublic void setSharedEngine(@Nullable Boolean sharedEngine) {\n\t\tthis.sharedEngine = sharedEngine;\n\t}\n\n\t@Override\n\tpublic @Nullable Boolean isSharedEngine() {\n\t\treturn this.sharedEngine;\n\t}\n\n\t/**\n\t * Set the scripts to be loaded by the script engine (library or user provided).\n\t * Since {@code resourceLoaderPath} default value is \"classpath:\", you can load easily\n\t * any script available on the classpath.\n\t * <p>For example, in order to use a JavaScript library available as a WebJars dependency\n\t * and a custom \"render.js\" file, you should call\n\t * {@code configurer.setScripts(\"/META-INF/resources/webjars/library/version/library.js\",\n\t * \"com/myproject/script/render.js\");}.\n\t * @see #setResourceLoaderPath\n\t * @see <a href=\"https://www.webjars.org\">WebJars</a>\n\t */\n\tpublic void setScripts(String @Nullable ... scriptNames) {\n\t\tthis.scripts = scriptNames;\n\t}\n\n\t@Override\n\tpublic String @Nullable [] getScripts() {\n\t\treturn this.scripts;\n\t}\n\n\t/**\n\t * Set the object where the render function belongs (optional).\n\t * For example, in order to call {@code Mustache.render()}, {@code renderObject}\n\t * should be set to {@code \"Mustache\"} and {@code renderFunction} to {@code \"render\"}.\n\t */\n\tpublic void setRenderObject(@Nullable String renderObject) {\n\t\tthis.renderObject = renderObject;\n\t}\n\n\t@Override\n\tpublic @Nullable String getRenderObject() {\n\t\treturn this.renderObject;\n\t}\n\n\t/**\n\t * Set the render function name (optional). If not specified, the script templates\n\t * will be evaluated with {@link ScriptEngine#eval(String, Bindings)}.\n\t * <p>This function will be called with the following parameters:\n\t * <ol>\n\t * <li>{@code String template}: the template content</li>\n\t * <li>{@code Map model}: the view model</li>\n\t * <li>{@code RenderingContext context}: the rendering context</li>\n\t * </ol>\n\t * @see RenderingContext\n\t */\n\tpublic void setRenderFunction(@Nullable String renderFunction) {\n\t\tthis.renderFunction = renderFunction;\n\t}\n\n\t@Override\n\tpublic @Nullable String getRenderFunction() {\n\t\treturn this.renderFunction;\n\t}\n\n\t/**\n\t * Set the charset used to read script and template files.\n\t * ({@code UTF-8} by default).\n\t */\n\tpublic void setCharset(@Nullable Charset charset) {\n\t\tthis.charset = charset;\n\t}\n\n\t@Override\n\tpublic @Nullable Charset getCharset() {\n\t\treturn this.charset;\n\t}\n\n\t/**\n\t * Set the resource loader path(s) via a Spring resource location.\n\t * Accepts multiple locations as a comma-separated list of paths.\n\t * Standard URLs like \"file:\" and \"classpath:\" and pseudo URLs are supported\n\t * as understood by Spring's {@link org.springframework.core.io.ResourceLoader}.\n\t * Relative paths are allowed when running in an ApplicationContext.\n\t * <p>Default is \"classpath:\".\n\t */\n\tpublic void setResourceLoaderPath(@Nullable String resourceLoaderPath) {\n\t\tthis.resourceLoaderPath = resourceLoaderPath;\n\t}\n\n\t@Override\n\tpublic @Nullable String getResourceLoaderPath() {\n\t\treturn this.resourceLoaderPath;\n\t}\n\n}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer#getCharset()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "Charset",
    "signature": "public Charset getCharset()",
    "source_code": "\tpublic @Nullable Charset getCharset() {\n\t\treturn this.charset;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer#getEngine()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "ScriptEngine",
    "signature": "public ScriptEngine getEngine()",
    "source_code": "\tpublic @Nullable ScriptEngine getEngine() {\n\t\treturn this.engine;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer#getEngineName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "String",
    "signature": "public String getEngineName()",
    "source_code": "\tpublic @Nullable String getEngineName() {\n\t\treturn this.engineName;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer#getEngineSupplier()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "Supplier<ScriptEngine>",
    "signature": "public Supplier<ScriptEngine> getEngineSupplier()",
    "source_code": "\tpublic @Nullable Supplier<ScriptEngine> getEngineSupplier() {\n\t\treturn this.engineSupplier;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer#getRenderFunction()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "String",
    "signature": "public String getRenderFunction()",
    "source_code": "\tpublic @Nullable String getRenderFunction() {\n\t\treturn this.renderFunction;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer#getRenderObject()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "String",
    "signature": "public String getRenderObject()",
    "source_code": "\tpublic @Nullable String getRenderObject() {\n\t\treturn this.renderObject;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer#getResourceLoaderPath()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "String",
    "signature": "public String getResourceLoaderPath()",
    "source_code": "\tpublic @Nullable String getResourceLoaderPath() {\n\t\treturn this.resourceLoaderPath;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer#isSharedEngine()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "Boolean",
    "signature": "public Boolean isSharedEngine()",
    "source_code": "\tpublic @Nullable Boolean isSharedEngine() {\n\t\treturn this.sharedEngine;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer#setCharset(charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the charset used to read script and template files.\n\t * ({@code UTF-8} by default).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "void",
    "signature": "public void setCharset(@Nullable Charset charset)",
    "source_code": "\tpublic void setCharset(@Nullable Charset charset) {\n\t\tthis.charset = charset;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer#setEngine(engine)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link ScriptEngine} to use by the view.\n\t * If {@code renderFunction} is specified, the script engine must implement {@code Invocable}.\n\t * You must define {@code engine} or {@code engineName}, not both.\n\t * <p>When the {@code sharedEngine} flag is set to {@code false}, you should not specify\n\t * the script engine with this setter, but with the {@link #setEngineName(String)}\n\t * or {@link #setEngineSupplier(Supplier)} (since it implies multiple lazy\n\t * instantiations of the script engine).\n\t * @see #setEngineName(String)\n\t * @see #setEngineSupplier(Supplier)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "engine"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void setEngine(@Nullable ScriptEngine engine)",
    "source_code": "\tpublic void setEngine(@Nullable ScriptEngine engine) {\n\t\tthis.engine = engine;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer#setEngineName(engineName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the engine name that will be used to instantiate the {@link ScriptEngine}.\n\t * If {@code renderFunction} is specified, the script engine must implement {@code Invocable}.\n\t * You must define {@code engine} or {@code engineName}, not both.\n\t * @see #setEngine(ScriptEngine)\n\t * @see #setEngineSupplier(Supplier)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "engineName"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void setEngineName(@Nullable String engineName)",
    "source_code": "\tpublic void setEngineName(@Nullable String engineName) {\n\t\tthis.engineName = engineName;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer#setEngineSupplier(engineSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link ScriptEngine} supplier to use by the view, usually used with\n\t * {@link #setSharedEngine(Boolean)} set to {@code false}.\n\t * If {@code renderFunction} is specified, the script engine must implement {@code Invocable}.\n\t * You must either define {@code engineSupplier}, {@code engine} or {@code engineName}.\n\t * @since 5.2\n\t * @see #setEngine(ScriptEngine)\n\t * @see #setEngineName(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "engineSupplier"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void setEngineSupplier(@Nullable Supplier<ScriptEngine> engineSupplier)",
    "source_code": "\tpublic void setEngineSupplier(@Nullable Supplier<ScriptEngine> engineSupplier) {\n\t\tthis.engineSupplier = engineSupplier;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer#setRenderFunction(renderFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the render function name (optional). If not specified, the script templates\n\t * will be evaluated with {@link ScriptEngine#eval(String, Bindings)}.\n\t * <p>This function will be called with the following parameters:\n\t * <ol>\n\t * <li>{@code String template}: the template content</li>\n\t * <li>{@code Map model}: the view model</li>\n\t * <li>{@code RenderingContext context}: the rendering context</li>\n\t * </ol>\n\t * @see RenderingContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "renderFunction"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void setRenderFunction(@Nullable String renderFunction)",
    "source_code": "\tpublic void setRenderFunction(@Nullable String renderFunction) {\n\t\tthis.renderFunction = renderFunction;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer#setRenderObject(renderObject)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the object where the render function belongs (optional).\n\t * For example, in order to call {@code Mustache.render()}, {@code renderObject}\n\t * should be set to {@code \"Mustache\"} and {@code renderFunction} to {@code \"render\"}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "renderObject"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "void",
    "signature": "public void setRenderObject(@Nullable String renderObject)",
    "source_code": "\tpublic void setRenderObject(@Nullable String renderObject) {\n\t\tthis.renderObject = renderObject;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer#setResourceLoaderPath(resourceLoaderPath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the resource loader path(s) via a Spring resource location.\n\t * Accepts multiple locations as a comma-separated list of paths.\n\t * Standard URLs like \"file:\" and \"classpath:\" and pseudo URLs are supported\n\t * as understood by Spring's {@link org.springframework.core.io.ResourceLoader}.\n\t * Relative paths are allowed when running in an ApplicationContext.\n\t * <p>Default is \"classpath:\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLoaderPath"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "void",
    "signature": "public void setResourceLoaderPath(@Nullable String resourceLoaderPath)",
    "source_code": "\tpublic void setResourceLoaderPath(@Nullable String resourceLoaderPath) {\n\t\tthis.resourceLoaderPath = resourceLoaderPath;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer#setScripts(scriptNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the scripts to be loaded by the script engine (library or user provided).\n\t * Since {@code resourceLoaderPath} default value is \"classpath:\", you can load easily\n\t * any script available on the classpath.\n\t * <p>For example, in order to use a JavaScript library available as a WebJars dependency\n\t * and a custom \"render.js\" file, you should call\n\t * {@code configurer.setScripts(\"/META-INF/resources/webjars/library/version/library.js\",\n\t * \"com/myproject/script/render.js\");}.\n\t * @see #setResourceLoaderPath\n\t * @see <a href=\"https://www.webjars.org\">WebJars</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptNames"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "public void setScripts(String @Nullable ... scriptNames)",
    "source_code": "\tpublic void setScripts(String @Nullable ... scriptNames) {\n\t\tthis.scripts = scriptNames;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer#setSharedEngine(sharedEngine)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * When set to {@code false}, a new  {@link ScriptEngine} instance will be created\n\t * for each request, else the same instance will be reused.\n\t * This flag should be set to {@code false} for those using non thread-safe script\n\t * engines with templating libraries not designed for\n\t * concurrency, like Handlebars or React running on Nashorn for example.\n\t * <p>When this flag is set to {@code false}, the script engine must be specified using\n\t * {@link #setEngineName(String)}. Using {@link #setEngine(ScriptEngine)} is not\n\t * possible because multiple instances of the script engine need to be created for\n\t * each request.\n\t * @see <a href=\"https://docs.oracle.com/javase/8/docs/api/javax/script/ScriptEngineFactory.html#getParameter-java.lang.String-\">THREADING ScriptEngine parameter</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sharedEngine"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void setSharedEngine(@Nullable Boolean sharedEngine)",
    "source_code": "\tpublic void setSharedEngine(@Nullable Boolean sharedEngine) {\n\t\tthis.sharedEngine = sharedEngine;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateView": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An {@link AbstractUrlBasedView} subclass designed to run any template library\n * based on a JSR-223 script engine.\n *\n * <p>If not set, each property is auto-detected by looking up a single\n * {@link ScriptTemplateConfig} bean in the web application context and using\n * it to obtain the configured properties.\n *\n * <p>The Nashorn JavaScript engine requires Java 8+ and may require setting the\n * {@code sharedEngine} property to {@code false} in order to run properly. See\n * {@link ScriptTemplateConfigurer#setSharedEngine(Boolean)} for more details.\n *\n * @author Sebastien Deleuze\n * @author Juergen Hoeller\n * @since 5.0\n * @see ScriptTemplateConfigurer\n * @see ScriptTemplateViewResolver\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "signature": "public class ScriptTemplateView",
    "source_code": "public class ScriptTemplateView extends AbstractUrlBasedView {\n\n\tprivate static final String DEFAULT_RESOURCE_LOADER_PATH = \"classpath:\";\n\n\n\tprivate @Nullable ScriptEngine engine;\n\n\tprivate @Nullable Supplier<ScriptEngine> engineSupplier;\n\n\tprivate @Nullable String engineName;\n\n\tprivate @Nullable Boolean sharedEngine;\n\n\tprivate String @Nullable [] scripts;\n\n\tprivate @Nullable String renderObject;\n\n\tprivate @Nullable String renderFunction;\n\n\tprivate String @Nullable [] resourceLoaderPaths;\n\n\tprivate volatile @Nullable ScriptEngineManager scriptEngineManager;\n\n\n\t/**\n\t * Constructor for use as a bean.\n\t * @see #setUrl\n\t */\n\tpublic ScriptTemplateView() {\n\t}\n\n\t/**\n\t * Create a new ScriptTemplateView with the given URL.\n\t */\n\tpublic ScriptTemplateView(String url) {\n\t\tsuper(url);\n\t}\n\n\n\t/**\n\t * See {@link ScriptTemplateConfigurer#setEngine(ScriptEngine)} documentation.\n\t */\n\tpublic void setEngine(ScriptEngine engine) {\n\t\tthis.engine = engine;\n\t}\n\n\t/**\n\t * See {@link ScriptTemplateConfigurer#setEngineSupplier(Supplier)} documentation.\n\t * @since 5.2\n\t */\n\tpublic void setEngineSupplier(Supplier<ScriptEngine> engineSupplier) {\n\t\tthis.engineSupplier = engineSupplier;\n\t}\n\n\t/**\n\t * See {@link ScriptTemplateConfigurer#setEngineName(String)} documentation.\n\t */\n\tpublic void setEngineName(String engineName) {\n\t\tthis.engineName = engineName;\n\t}\n\n\t/**\n\t * See {@link ScriptTemplateConfigurer#setSharedEngine(Boolean)} documentation.\n\t */\n\tpublic void setSharedEngine(Boolean sharedEngine) {\n\t\tthis.sharedEngine = sharedEngine;\n\t}\n\n\t/**\n\t * See {@link ScriptTemplateConfigurer#setScripts(String...)} documentation.\n\t */\n\tpublic void setScripts(String... scripts) {\n\t\tthis.scripts = scripts;\n\t}\n\n\t/**\n\t * See {@link ScriptTemplateConfigurer#setRenderObject(String)} documentation.\n\t */\n\tpublic void setRenderObject(String renderObject) {\n\t\tthis.renderObject = renderObject;\n\t}\n\n\t/**\n\t * See {@link ScriptTemplateConfigurer#setRenderFunction(String)} documentation.\n\t */\n\tpublic void setRenderFunction(String functionName) {\n\t\tthis.renderFunction = functionName;\n\t}\n\n\t/**\n\t * See {@link ScriptTemplateConfigurer#setResourceLoaderPath(String)} documentation.\n\t */\n\tpublic void setResourceLoaderPath(String resourceLoaderPath) {\n\t\tString[] paths = StringUtils.commaDelimitedListToStringArray(resourceLoaderPath);\n\t\tthis.resourceLoaderPaths = new String[paths.length + 1];\n\t\tthis.resourceLoaderPaths[0] = \"\";\n\t\tfor (int i = 0; i < paths.length; i++) {\n\t\t\tString path = paths[i];\n\t\t\tif (!path.endsWith(\"/\") && !path.endsWith(\":\")) {\n\t\t\t\tpath = path + \"/\";\n\t\t\t}\n\t\t\tthis.resourceLoaderPaths[i + 1] = path;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setApplicationContext(@Nullable ApplicationContext context) {\n\t\tsuper.setApplicationContext(context);\n\n\t\tScriptTemplateConfig viewConfig = autodetectViewConfig();\n\t\tif (this.engine == null && viewConfig.getEngine() != null) {\n\t\t\tthis.engine = viewConfig.getEngine();\n\t\t}\n\t\tif (this.engineSupplier == null && viewConfig.getEngineSupplier() != null) {\n\t\t\tthis.engineSupplier = viewConfig.getEngineSupplier();\n\t\t}\n\t\tif (this.engineName == null && viewConfig.getEngineName() != null) {\n\t\t\tthis.engineName = viewConfig.getEngineName();\n\t\t}\n\t\tif (this.scripts == null && viewConfig.getScripts() != null) {\n\t\t\tthis.scripts = viewConfig.getScripts();\n\t\t}\n\t\tif (this.renderObject == null && viewConfig.getRenderObject() != null) {\n\t\t\tthis.renderObject = viewConfig.getRenderObject();\n\t\t}\n\t\tif (this.renderFunction == null && viewConfig.getRenderFunction() != null) {\n\t\t\tthis.renderFunction = viewConfig.getRenderFunction();\n\t\t}\n\t\tif (viewConfig.getCharset() != null) {\n\t\t\tsetDefaultCharset(viewConfig.getCharset());\n\t\t}\n\t\tif (this.resourceLoaderPaths == null) {\n\t\t\tString resourceLoaderPath = viewConfig.getResourceLoaderPath();\n\t\t\tsetResourceLoaderPath(resourceLoaderPath != null ? resourceLoaderPath : DEFAULT_RESOURCE_LOADER_PATH);\n\t\t}\n\t\tif (this.sharedEngine == null && viewConfig.isSharedEngine() != null) {\n\t\t\tthis.sharedEngine = viewConfig.isSharedEngine();\n\t\t}\n\n\t\tint engineCount = 0;\n\t\tif (this.engine != null) {\n\t\t\tengineCount++;\n\t\t}\n\t\tif (this.engineSupplier != null) {\n\t\t\tengineCount++;\n\t\t}\n\t\tif (this.engineName != null) {\n\t\t\tengineCount++;\n\t\t}\n\t\tAssert.isTrue(engineCount == 1,\n\t\t\t\t\"You should define either 'engine', 'engineSupplier', or 'engineName'.\");\n\n\t\tif (Boolean.FALSE.equals(this.sharedEngine)) {\n\t\t\tAssert.isTrue(this.engine == null,\n\t\t\t\t\t\"When 'sharedEngine' is set to false, you should specify the \" +\n\t\t\t\t\t\"script engine using 'engineName' or 'engineSupplier', not 'engine'.\");\n\t\t}\n\t\telse if (this.engine != null) {\n\t\t\tloadScripts(this.engine);\n\t\t}\n\t\telse if (this.engineName != null) {\n\t\t\tsetEngine(createEngineFromName(this.engineName));\n\t\t}\n\t\telse {\n\t\t\tsetEngine(createEngineFromSupplier());\n\t\t}\n\n\t\tif (this.renderFunction != null && this.engine != null) {\n\t\t\tAssert.isInstanceOf(Invocable.class, this.engine,\n\t\t\t\t\t\"ScriptEngine must implement Invocable when 'renderFunction' is specified\");\n\t\t}\n\t}\n\n\tprotected ScriptEngine getEngine() {\n\t\tif (Boolean.FALSE.equals(this.sharedEngine)) {\n\t\t\tif (this.engineName != null) {\n\t\t\t\treturn createEngineFromName(this.engineName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn createEngineFromSupplier();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tAssert.state(this.engine != null, \"No shared engine available\");\n\t\t\treturn this.engine;\n\t\t}\n\t}\n\n\tprotected ScriptEngine createEngineFromName(String engineName) {\n\t\tScriptEngineManager scriptEngineManager = this.scriptEngineManager;\n\t\tif (scriptEngineManager == null) {\n\t\t\tscriptEngineManager = new ScriptEngineManager(obtainApplicationContext().getClassLoader());\n\t\t\tthis.scriptEngineManager = scriptEngineManager;\n\t\t}\n\n\t\tScriptEngine engine = StandardScriptUtils.retrieveEngineByName(scriptEngineManager, engineName);\n\t\tloadScripts(engine);\n\t\treturn engine;\n\t}\n\n\tprivate ScriptEngine createEngineFromSupplier() {\n\t\tAssert.state(this.engineSupplier != null, \"No engine supplier available\");\n\t\tScriptEngine engine = this.engineSupplier.get();\n\t\tif (this.renderFunction != null) {\n\t\t\tAssert.isInstanceOf(Invocable.class, engine,\n\t\t\t\t\t\"ScriptEngine must implement Invocable when 'renderFunction' is specified\");\n\t\t}\n\t\tloadScripts(engine);\n\t\treturn engine;\n\t}\n\n\tprotected void loadScripts(ScriptEngine engine) {\n\t\tif (!ObjectUtils.isEmpty(this.scripts)) {\n\t\t\tfor (String script : this.scripts) {\n\t\t\t\tResource resource = getResource(script);\n\t\t\t\tif (resource == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Script resource [\" + script + \"] not found\");\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tengine.eval(new InputStreamReader(resource.getInputStream()));\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new IllegalStateException(\"Failed to evaluate script [\" + script + \"]\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected @Nullable Resource getResource(String location) {\n\t\tif (this.resourceLoaderPaths != null) {\n\t\t\tfor (String path : this.resourceLoaderPaths) {\n\t\t\t\tResource resource = obtainApplicationContext().getResource(path + location);\n\t\t\t\tif (resource.exists()) {\n\t\t\t\t\treturn resource;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected ScriptTemplateConfig autodetectViewConfig() throws BeansException {\n\t\ttry {\n\t\t\treturn BeanFactoryUtils.beanOfTypeIncludingAncestors(\n\t\t\t\t\tobtainApplicationContext(), ScriptTemplateConfig.class, true, false);\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\tthrow new ApplicationContextException(\"Expected a single ScriptTemplateConfig bean in the current \" +\n\t\t\t\t\t\"web application context or the parent root context: ScriptTemplateConfigurer is \" +\n\t\t\t\t\t\"the usual implementation. This bean may have any name.\", ex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean checkResourceExists(Locale locale) throws Exception {\n\t\tString url = getUrl();\n\t\tAssert.state(url != null, \"'url' not set\");\n\t\treturn (getResource(url) != null);\n\t}\n\n\t@Override\n\tprotected Mono<Void> renderInternal(\n\t\t\tMap<String, Object> model, @Nullable MediaType contentType, ServerWebExchange exchange) {\n\n\t\treturn exchange.getResponse().writeWith(Mono.fromCallable(() -> {\n\t\t\ttry {\n\t\t\t\tScriptEngine engine = getEngine();\n\t\t\t\tString url = getUrl();\n\t\t\t\tAssert.state(url != null, \"'url' not set\");\n\t\t\t\tString template = getTemplate(url);\n\n\t\t\t\tFunction<String, String> templateLoader = path -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn getTemplate(path);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tLocale locale = LocaleContextHolder.getLocale(exchange.getLocaleContext());\n\t\t\t\tRenderingContext context = new RenderingContext(\n\t\t\t\t\t\tobtainApplicationContext(), locale, templateLoader, url);\n\n\t\t\t\tObject html;\n\t\t\t\tif (this.renderFunction == null) {\n\t\t\t\t\tSimpleBindings bindings = new SimpleBindings();\n\t\t\t\t\tbindings.putAll(model);\n\t\t\t\t\tmodel.put(\"renderingContext\", context);\n\t\t\t\t\thtml = engine.eval(template, bindings);\n\t\t\t\t}\n\t\t\t\telse if (this.renderObject != null) {\n\t\t\t\t\tObject thiz = engine.eval(this.renderObject);\n\t\t\t\t\thtml = ((Invocable) engine).invokeMethod(thiz, this.renderFunction, template, model, context);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thtml = ((Invocable) engine).invokeFunction(this.renderFunction, template, model, context);\n\t\t\t\t}\n\n\t\t\t\tbyte[] bytes = String.valueOf(html).getBytes(StandardCharsets.UTF_8);\n\t\t\t\treturn exchange.getResponse().bufferFactory().wrap(bytes); // just wrapping, no allocation\n\t\t\t}\n\t\t\tcatch (ScriptException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to render script template\", new StandardScriptEvalException(ex));\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to render script template\", ex);\n\t\t\t}\n\t\t}));\n\t}\n\n\tprotected String getTemplate(String path) throws IOException {\n\t\tResource resource = getResource(path);\n\t\tif (resource == null) {\n\t\t\tthrow new IllegalStateException(\"Template resource [\" + path + \"] not found\");\n\t\t}\n\t\tInputStreamReader reader = new InputStreamReader(resource.getInputStream(), getDefaultCharset());\n\t\treturn FileCopyUtils.copyToString(reader);\n\t}\n\n}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateView#autodetectViewConfig()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "ScriptTemplateConfig",
    "signature": "protected ScriptTemplateConfig autodetectViewConfig()",
    "source_code": "\tprotected ScriptTemplateConfig autodetectViewConfig() throws BeansException {\n\t\ttry {\n\t\t\treturn BeanFactoryUtils.beanOfTypeIncludingAncestors(\n\t\t\t\t\tobtainApplicationContext(), ScriptTemplateConfig.class, true, false);\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\tthrow new ApplicationContextException(\"Expected a single ScriptTemplateConfig bean in the current \" +\n\t\t\t\t\t\"web application context or the parent root context: ScriptTemplateConfigurer is \" +\n\t\t\t\t\t\"the usual implementation. This bean may have any name.\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateView#checkResourceExists(locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "boolean",
    "signature": "public boolean checkResourceExists(Locale locale)",
    "source_code": "\tpublic boolean checkResourceExists(Locale locale) throws Exception {\n\t\tString url = getUrl();\n\t\tAssert.state(url != null, \"'url' not set\");\n\t\treturn (getResource(url) != null);\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateView#createEngineFromName(engineName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "engineName"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "ScriptEngine",
    "signature": "protected ScriptEngine createEngineFromName(String engineName)",
    "source_code": "\tprotected ScriptEngine createEngineFromName(String engineName) {\n\t\tScriptEngineManager scriptEngineManager = this.scriptEngineManager;\n\t\tif (scriptEngineManager == null) {\n\t\t\tscriptEngineManager = new ScriptEngineManager(obtainApplicationContext().getClassLoader());\n\t\t\tthis.scriptEngineManager = scriptEngineManager;\n\t\t}\n\n\t\tScriptEngine engine = StandardScriptUtils.retrieveEngineByName(scriptEngineManager, engineName);\n\t\tloadScripts(engine);\n\t\treturn engine;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateView#getEngine()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "ScriptEngine",
    "signature": "protected ScriptEngine getEngine()",
    "source_code": "\tprotected ScriptEngine getEngine() {\n\t\tif (Boolean.FALSE.equals(this.sharedEngine)) {\n\t\t\tif (this.engineName != null) {\n\t\t\t\treturn createEngineFromName(this.engineName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn createEngineFromSupplier();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tAssert.state(this.engine != null, \"No shared engine available\");\n\t\t\treturn this.engine;\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateView#getResource(location)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "location"
    ],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "Resource",
    "signature": "protected Resource getResource(String location)",
    "source_code": "\tprotected @Nullable Resource getResource(String location) {\n\t\tif (this.resourceLoaderPaths != null) {\n\t\t\tfor (String path : this.resourceLoaderPaths) {\n\t\t\t\tResource resource = obtainApplicationContext().getResource(path + location);\n\t\t\t\tif (resource.exists()) {\n\t\t\t\t\treturn resource;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateView#getTemplate(path)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "String",
    "signature": "protected String getTemplate(String path)",
    "source_code": "\tprotected String getTemplate(String path) throws IOException {\n\t\tResource resource = getResource(path);\n\t\tif (resource == null) {\n\t\t\tthrow new IllegalStateException(\"Template resource [\" + path + \"] not found\");\n\t\t}\n\t\tInputStreamReader reader = new InputStreamReader(resource.getInputStream(), getDefaultCharset());\n\t\treturn FileCopyUtils.copyToString(reader);\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateView#loadScripts(engine)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "engine"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "void",
    "signature": "protected void loadScripts(ScriptEngine engine)",
    "source_code": "\tprotected void loadScripts(ScriptEngine engine) {\n\t\tif (!ObjectUtils.isEmpty(this.scripts)) {\n\t\t\tfor (String script : this.scripts) {\n\t\t\t\tResource resource = getResource(script);\n\t\t\t\tif (resource == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Script resource [\" + script + \"] not found\");\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tengine.eval(new InputStreamReader(resource.getInputStream()));\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new IllegalStateException(\"Failed to evaluate script [\" + script + \"]\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateView#renderInternal(Map<String,model,contentType,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "contentType",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> renderInternal(Map<String, Object> model, @Nullable MediaType contentType, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<Void> renderInternal("
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateView#setApplicationContext(context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "void",
    "signature": "public void setApplicationContext(@Nullable ApplicationContext context)",
    "source_code": "\tpublic void setApplicationContext(@Nullable ApplicationContext context) {\n\t\tsuper.setApplicationContext(context);\n\n\t\tScriptTemplateConfig viewConfig = autodetectViewConfig();\n\t\tif (this.engine == null && viewConfig.getEngine() != null) {\n\t\t\tthis.engine = viewConfig.getEngine();\n\t\t}\n\t\tif (this.engineSupplier == null && viewConfig.getEngineSupplier() != null) {\n\t\t\tthis.engineSupplier = viewConfig.getEngineSupplier();\n\t\t}\n\t\tif (this.engineName == null && viewConfig.getEngineName() != null) {\n\t\t\tthis.engineName = viewConfig.getEngineName();\n\t\t}\n\t\tif (this.scripts == null && viewConfig.getScripts() != null) {\n\t\t\tthis.scripts = viewConfig.getScripts();\n\t\t}\n\t\tif (this.renderObject == null && viewConfig.getRenderObject() != null) {\n\t\t\tthis.renderObject = viewConfig.getRenderObject();\n\t\t}\n\t\tif (this.renderFunction == null && viewConfig.getRenderFunction() != null) {\n\t\t\tthis.renderFunction = viewConfig.getRenderFunction();\n\t\t}\n\t\tif (viewConfig.getCharset() != null) {\n\t\t\tsetDefaultCharset(viewConfig.getCharset());\n\t\t}\n\t\tif (this.resourceLoaderPaths == null) {\n\t\t\tString resourceLoaderPath = viewConfig.getResourceLoaderPath();\n\t\t\tsetResourceLoaderPath(resourceLoaderPath != null ? resourceLoaderPath : DEFAULT_RESOURCE_LOADER_PATH);\n\t\t}\n\t\tif (this.sharedEngine == null && viewConfig.isSharedEngine() != null) {\n\t\t\tthis.sharedEngine = viewConfig.isSharedEngine();\n\t\t}\n\n\t\tint engineCount = 0;\n\t\tif (this.engine != null) {\n\t\t\tengineCount++;\n\t\t}\n\t\tif (this.engineSupplier != null) {\n\t\t\tengineCount++;\n\t\t}\n\t\tif (this.engineName != null) {\n\t\t\tengineCount++;\n\t\t}\n\t\tAssert.isTrue(engineCount == 1,\n\t\t\t\t\"You should define either 'engine', 'engineSupplier', or 'engineName'.\");\n\n\t\tif (Boolean.FALSE.equals(this.sharedEngine)) {\n\t\t\tAssert.isTrue(this.engine == null,\n\t\t\t\t\t\"When 'sharedEngine' is set to false, you should specify the \" +\n\t\t\t\t\t\"script engine using 'engineName' or 'engineSupplier', not 'engine'.\");\n\t\t}\n\t\telse if (this.engine != null) {\n\t\t\tloadScripts(this.engine);\n\t\t}\n\t\telse if (this.engineName != null) {\n\t\t\tsetEngine(createEngineFromName(this.engineName));\n\t\t}\n\t\telse {\n\t\t\tsetEngine(createEngineFromSupplier());\n\t\t}\n\n\t\tif (this.renderFunction != null && this.engine != null) {\n\t\t\tAssert.isInstanceOf(Invocable.class, this.engine,\n\t\t\t\t\t\"ScriptEngine must implement Invocable when 'renderFunction' is specified\");\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateView#setEngine(engine)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * See {@link ScriptTemplateConfigurer#setEngine(ScriptEngine)} documentation.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "engine"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void setEngine(ScriptEngine engine)",
    "source_code": "\tpublic void setEngine(ScriptEngine engine) {\n\t\tthis.engine = engine;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateView#setEngineName(engineName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * See {@link ScriptTemplateConfigurer#setEngineName(String)} documentation.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "engineName"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "void",
    "signature": "public void setEngineName(String engineName)",
    "source_code": "\tpublic void setEngineName(String engineName) {\n\t\tthis.engineName = engineName;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateView#setEngineSupplier(engineSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * See {@link ScriptTemplateConfigurer#setEngineSupplier(Supplier)} documentation.\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "engineSupplier"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void setEngineSupplier(Supplier<ScriptEngine> engineSupplier)",
    "source_code": "\tpublic void setEngineSupplier(Supplier<ScriptEngine> engineSupplier) {\n\t\tthis.engineSupplier = engineSupplier;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateView#setRenderFunction(functionName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * See {@link ScriptTemplateConfigurer#setRenderFunction(String)} documentation.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "functionName"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "void",
    "signature": "public void setRenderFunction(String functionName)",
    "source_code": "\tpublic void setRenderFunction(String functionName) {\n\t\tthis.renderFunction = functionName;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateView#setRenderObject(renderObject)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * See {@link ScriptTemplateConfigurer#setRenderObject(String)} documentation.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "renderObject"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void setRenderObject(String renderObject)",
    "source_code": "\tpublic void setRenderObject(String renderObject) {\n\t\tthis.renderObject = renderObject;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateView#setResourceLoaderPath(resourceLoaderPath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * See {@link ScriptTemplateConfigurer#setResourceLoaderPath(String)} documentation.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLoaderPath"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "public void setResourceLoaderPath(String resourceLoaderPath)",
    "source_code": "\tpublic void setResourceLoaderPath(String resourceLoaderPath) {\n\t\tString[] paths = StringUtils.commaDelimitedListToStringArray(resourceLoaderPath);\n\t\tthis.resourceLoaderPaths = new String[paths.length + 1];\n\t\tthis.resourceLoaderPaths[0] = \"\";\n\t\tfor (int i = 0; i < paths.length; i++) {\n\t\t\tString path = paths[i];\n\t\t\tif (!path.endsWith(\"/\") && !path.endsWith(\":\")) {\n\t\t\t\tpath = path + \"/\";\n\t\t\t}\n\t\t\tthis.resourceLoaderPaths[i + 1] = path;\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateView#setScripts(scripts)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * See {@link ScriptTemplateConfigurer#setScripts(String...)} documentation.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scripts"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "void",
    "signature": "public void setScripts(String... scripts)",
    "source_code": "\tpublic void setScripts(String... scripts) {\n\t\tthis.scripts = scripts;\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.ScriptTemplateView#setSharedEngine(sharedEngine)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * See {@link ScriptTemplateConfigurer#setSharedEngine(Boolean)} documentation.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sharedEngine"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void setSharedEngine(Boolean sharedEngine)",
    "source_code": "\tpublic void setSharedEngine(Boolean sharedEngine) {\n\t\tthis.sharedEngine = sharedEngine;\n\t}"
  },
  "org.springframework.web.reactive.socket.CloseStatus#equalsCode(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * @deprecated as of 5.3 in favor of comparing codes directly\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "boolean",
    "signature": "public boolean equalsCode(CloseStatus other)",
    "source_code": "\tpublic boolean equalsCode(CloseStatus other) {\n\t\treturn (this.code == other.code);\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Base class for {@link WebSocketSession} implementations that bridge between\n * event-listener WebSocket APIs (for example, Jakarta WebSocket API (JSR-356), Jetty,\n * Undertow) and Reactive Streams.\n *\n * <p>Also implements {@code Subscriber<Void>} so it can be used to subscribe to\n * the completion of {@link WebSocketHandler#handle(WebSocketSession)}.\n *\n * @author Violeta Georgieva\n * @author Rossen Stoyanchev\n * @since 5.0\n * @param <T> the native delegate type\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "signature": "public class AbstractListenerWebSocketSession",
    "source_code": "public abstract class AbstractListenerWebSocketSession<T> extends AbstractWebSocketSession<T>"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#canSuspendReceiving()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the underlying WebSocket API has flow control and can suspend and\n\t * resume the receiving of messages.\n\t * <p><strong>Note:</strong> Sub-classes are encouraged to start out in\n\t * suspended mode, if possible, and wait until demand is received.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "boolean",
    "signature": "protected boolean canSuspendReceiving()",
    "source_code": "\tprotected abstract boolean canSuspendReceiving();"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#checkOnDataAvailable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "void",
    "signature": "protected void checkOnDataAvailable()",
    "source_code": "\t\tprotected void checkOnDataAvailable() {\n\t\t\tresumeReceiving();\n\t\t\tint size = this.pendingMessages.size();\n\t\t\tif (rsReadLogger.isTraceEnabled()) {\n\t\t\t\trsReadLogger.trace(getLogPrefix() + \"checkOnDataAvailable (\" + size + \" pending)\");\n\t\t\t}\n\t\t\tif (size > 0) {\n\t\t\t\tonDataAvailable();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#closeStatus()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "Mono<CloseStatus>",
    "signature": "public Mono<CloseStatus> closeStatus()",
    "source_code": "\tpublic Mono<CloseStatus> closeStatus() {\n\t\treturn this.closeStatusSink.asMono();\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#discardData()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "void",
    "signature": "protected void discardData()",
    "source_code": "\t\tprotected void discardData() {\n\t\t\tQueue<Object> queue = this.pendingMessages;\n\t\t\tthis.pendingMessages = Queues.empty().get(); // prevent further reading\n\t\t\twhile (true) {\n\t\t\t\tWebSocketMessage message = (WebSocketMessage) queue.poll();\n\t\t\t\tif (message == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmessage.release();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#discardData(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "void",
    "signature": "protected void discardData(WebSocketMessage message)",
    "source_code": "\t\tprotected void discardData(WebSocketMessage message) {\n\t\t\tmessage.release();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#getSendProcessor()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "WebSocketSendProcessor",
    "signature": "protected WebSocketSendProcessor getSendProcessor()",
    "source_code": "\tprotected WebSocketSendProcessor getSendProcessor() {\n\t\tWebSocketSendProcessor sendProcessor = this.sendProcessor;\n\t\tAssert.state(sendProcessor != null, \"No WebSocketSendProcessor available\");\n\t\treturn sendProcessor;\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#isDataEmpty(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "boolean",
    "signature": "protected boolean isDataEmpty(WebSocketMessage message)",
    "source_code": "\t\tprotected boolean isDataEmpty(WebSocketMessage message) {\n\t\t\treturn (message.getPayload().readableByteCount() == 0);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#isWritePossible()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 338
    },
    "return": "boolean",
    "signature": "protected boolean isWritePossible()",
    "source_code": "\t\tprotected boolean isWritePossible() {\n\t\t\treturn (this.isReady);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#onComplete()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "void",
    "signature": "public void onComplete()",
    "source_code": "\tpublic void onComplete() {\n\t\tif (this.handlerCompletionSink != null) {\n\t\t\t// Ignore result: can't overflow, ok if not first or no one listens\n\t\t\tthis.handlerCompletionSink.tryEmitEmpty();\n\t\t}\n\t\tclose();\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#onError(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "void",
    "signature": "public void onError(Throwable ex)",
    "source_code": "\tpublic void onError(Throwable ex) {\n\t\tif (this.handlerCompletionSink != null) {\n\t\t\t// Ignore result: can't overflow, ok if not first or no one listens\n\t\t\tthis.handlerCompletionSink.tryEmitError(ex);\n\t\t}\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"WebSocket session completed with error\", ex);\n\t\t}\n\t\telse if (logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"WebSocket session completed with error: \" + ex.getMessage());\n\t\t}\n\t\tclose(CloseStatus.SERVER_ERROR);\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#onNext(aVoid)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "aVoid"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "void",
    "signature": "public void onNext(Void aVoid)",
    "source_code": "\tpublic void onNext(Void aVoid) {\n\t\t// no op\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#onSubscribe(subscription)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "void",
    "signature": "public void onSubscribe(Subscription subscription)",
    "source_code": "\tpublic void onSubscribe(Subscription subscription) {\n\t\tsubscription.request(Long.MAX_VALUE);\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#read()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "WebSocketMessage",
    "signature": "protected WebSocketMessage read()",
    "source_code": "\t\tprotected @Nullable WebSocketMessage read() {\n\t\t\treturn (WebSocketMessage) this.pendingMessages.poll();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#readingPaused()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "void",
    "signature": "protected void readingPaused()",
    "source_code": "\t\tprotected void readingPaused() {\n\t\t\tsuspendReceiving();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#receive()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Flux<WebSocketMessage>",
    "signature": "public Flux<WebSocketMessage> receive()",
    "source_code": "\tpublic Flux<WebSocketMessage> receive() {\n\t\treturn (canSuspendReceiving() ?\n\t\t\t\tFlux.from(this.receivePublisher) :\n\t\t\t\tFlux.from(this.receivePublisher).onBackpressureBuffer(RECEIVE_BUFFER_SIZE));\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#resumeReceiving()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resume receiving new message(s) after demand is generated by the\n\t * downstream Subscriber.\n\t * <p><strong>Note:</strong> if the underlying WebSocket API does not provide\n\t * flow control for receiving messages, this method should be a no-op\n\t * and {@link #canSuspendReceiving()} should return {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "protected void resumeReceiving()",
    "source_code": "\tprotected abstract void resumeReceiving();"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#send(messages)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messages"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> send(Publisher<WebSocketMessage> messages)",
    "source_code": "\tpublic Mono<Void> send(Publisher<WebSocketMessage> messages) {\n\t\tif (this.sendCalled.compareAndSet(false, true)) {\n\t\t\tWebSocketSendProcessor sendProcessor = new WebSocketSendProcessor();\n\t\t\tthis.sendProcessor = sendProcessor;\n\t\t\treturn Mono.from(subscriber -> {\n\t\t\t\t\tmessages.subscribe(sendProcessor);\n\t\t\t\t\tsendProcessor.subscribe(subscriber);\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\treturn Mono.error(new IllegalStateException(\"send() has already been called\"));\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#sendMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Send the given WebSocket message.\n\t * <p><strong>Note:</strong> Sub-classes are responsible for releasing the\n\t * payload data buffer, once fully written, if pooled buffers apply to the\n\t * underlying container.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "boolean",
    "signature": "protected boolean sendMessage(WebSocketMessage message)",
    "source_code": "\tprotected abstract boolean sendMessage(WebSocketMessage message) throws IOException;"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#setReadyToSend(ready)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Subclasses can invoke this before sending a message (false) and\n\t\t * after receiving the async send callback (true) effective translating\n\t\t * async completion callback into simple flow control.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ready"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "void",
    "signature": "public void setReadyToSend(boolean ready)",
    "source_code": "\t\tpublic void setReadyToSend(boolean ready) {\n\t\t\tif (ready && rsWriteLogger.isTraceEnabled()) {\n\t\t\t\trsWriteLogger.trace(getLogPrefix() + \"Ready to send\");\n\t\t\t}\n\t\t\tthis.isReady = ready;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#suspendReceiving()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Suspend receiving until received message(s) are processed and more demand\n\t * is generated by the downstream Subscriber.\n\t * <p><strong>Note:</strong> if the underlying WebSocket API does not provide\n\t * flow control for receiving messages, this method should be a no-op\n\t * and {@link #canSuspendReceiving()} should return {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "protected void suspendReceiving()",
    "source_code": "\tprotected abstract void suspendReceiving();"
  },
  "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#write(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "boolean",
    "signature": "protected boolean write(WebSocketMessage message)",
    "source_code": "\t\tprotected boolean write(WebSocketMessage message) throws IOException {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(getLogPrefix() + \"Sending \" + message);\n\t\t\t}\n\t\t\telse if (rsWriteLogger.isTraceEnabled()) {\n\t\t\t\trsWriteLogger.trace(getLogPrefix() + \"Sending \" + message);\n\t\t\t}\n\t\t\t// In case of IOException, onError handling should call discardData(WebSocketMessage)..\n\t\t\treturn sendMessage(message);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.WebSocketSendProcessor": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Write processor for outbound WebSocket messages.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 310
    },
    "signature": "protected class WebSocketSendProcessor",
    "source_code": "\tprotected final class WebSocketSendProcessor extends AbstractListenerWriteProcessor<WebSocketMessage> {\n\n\t\tprivate volatile boolean isReady = true;\n\n\n\t\tWebSocketSendProcessor() {\n\t\t\tsuper(receivePublisher.getLogPrefix());\n\t\t}\n\n\n\t\t@Override\n\t\tprotected boolean write(WebSocketMessage message) throws IOException {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(getLogPrefix() + \"Sending \" + message);\n\t\t\t}\n\t\t\telse if (rsWriteLogger.isTraceEnabled()) {\n\t\t\t\trsWriteLogger.trace(getLogPrefix() + \"Sending \" + message);\n\t\t\t}\n\t\t\t// In case of IOException, onError handling should call discardData(WebSocketMessage)..\n\t\t\treturn sendMessage(message);\n\t\t}\n\n\t\t@Override\n\t\tprotected boolean isDataEmpty(WebSocketMessage message) {\n\t\t\treturn (message.getPayload().readableByteCount() == 0);\n\t\t}\n\n\t\t@Override\n\t\tprotected boolean isWritePossible() {\n\t\t\treturn (this.isReady);\n\t\t}\n\n\t\t/**\n\t\t * Subclasses can invoke this before sending a message (false) and\n\t\t * after receiving the async send callback (true) effective translating\n\t\t * async completion callback into simple flow control.\n\t\t */\n\t\tpublic void setReadyToSend(boolean ready) {\n\t\t\tif (ready && rsWriteLogger.isTraceEnabled()) {\n\t\t\t\trsWriteLogger.trace(getLogPrefix() + \"Ready to send\");\n\t\t\t}\n\t\t\tthis.isReady = ready;\n\t\t}\n\n\t\t@Override\n\t\tprotected void discardData(WebSocketMessage message) {\n\t\t\tmessage.release();\n\t\t}\n\t}"
  },
  "org.springframework.web.server.ResponseStatusException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Subclass of {@link ErrorResponseException} that accepts a \"reason\", and by\n * default maps that to the {@link ErrorResponseException#setDetail(String) \"detail\"}\n * of the {@code ProblemDetail}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class ResponseStatusException",
    "source_code": "public class ResponseStatusException extends ErrorResponseException {\n\n\tprivate final @Nullable String reason;\n\n\n\t/**\n\t * Constructor with a response status.\n\t * @param status the HTTP status (required)\n\t */\n\tpublic ResponseStatusException(HttpStatusCode status) {\n\t\tthis(status, null);\n\t}\n\n\t/**\n\t * Constructor with a response status and a reason to add to the exception\n\t * message as explanation.\n\t * @param status the HTTP status (required)\n\t * @param reason the associated reason (optional)\n\t */\n\tpublic ResponseStatusException(HttpStatusCode status, @Nullable String reason) {\n\t\tthis(status, reason, null);\n\t}\n\n\t/**\n\t * Constructor with a response status and a reason to add to the exception\n\t * message as explanation, as well as a nested exception.\n\t * @param rawStatusCode the HTTP status code value\n\t * @param reason the associated reason (optional)\n\t * @param cause a nested exception (optional)\n\t * @since 5.3\n\t */\n\tpublic ResponseStatusException(int rawStatusCode, @Nullable String reason, @Nullable Throwable cause) {\n\t\tthis(HttpStatusCode.valueOf(rawStatusCode), reason, cause);\n\t}\n\n\t/**\n\t * Constructor with a response status and a reason to add to the exception\n\t * message as explanation, as well as a nested exception.\n\t * @param status the HTTP status (required)\n\t * @param reason the associated reason (optional)\n\t * @param cause a nested exception (optional)\n\t */\n\tpublic ResponseStatusException(HttpStatusCode status, @Nullable String reason, @Nullable Throwable cause) {\n\t\tthis(status, reason, cause, null, null);\n\t}\n\n\t/**\n\t * Constructor with a message code and arguments for resolving the error\n\t * \"detail\" via {@link org.springframework.context.MessageSource}.\n\t * @param status the HTTP status (required)\n\t * @param reason the associated reason (optional)\n\t * @param cause a nested exception (optional)\n\t * @since 6.0\n\t */\n\tprotected ResponseStatusException(\n\t\t\tHttpStatusCode status, @Nullable String reason, @Nullable Throwable cause,\n\t\t\t@Nullable String messageDetailCode, Object @Nullable [] messageDetailArguments) {\n\n\t\tsuper(status, ProblemDetail.forStatus(status), cause, messageDetailCode, messageDetailArguments);\n\t\tthis.reason = reason;\n\t\tsetDetail(reason);\n\t}\n\n\n\t/**\n\t * The reason explaining the exception (potentially {@code null} or empty).\n\t */\n\tpublic @Nullable String getReason() {\n\t\treturn this.reason;\n\t}\n\n\t/**\n\t * Return headers to add to the error response, for example, \"Allow\", \"Accept\", etc.\n\t */\n\t@Override\n\tpublic HttpHeaders getHeaders() {\n\t\treturn HttpHeaders.EMPTY;\n\t}\n\n\t@Override\n\tpublic ProblemDetail updateAndGetBody(@Nullable MessageSource messageSource, Locale locale) {\n\t\tsuper.updateAndGetBody(messageSource, locale);\n\n\t\t// The reason may be a code (consistent with ResponseStatusExceptionResolver)\n\n\t\tif (messageSource != null && getReason() != null && getReason().equals(getBody().getDetail())) {\n\t\t\tObject[] arguments = getDetailMessageArguments(messageSource, locale);\n\t\t\tString resolved = messageSource.getMessage(getReason(), arguments, null, locale);\n\t\t\tif (resolved != null) {\n\t\t\t\tgetBody().setDetail(resolved);\n\t\t\t}\n\t\t}\n\n\t\treturn getBody();\n\t}\n\n\t@Override\n\tpublic String getMessage() {\n\t\treturn getStatusCode() + (this.reason != null ? \" \\\"\" + this.reason + \"\\\"\" : \"\");\n\t}\n\n}"
  },
  "org.springframework.web.server.ResponseStatusException#getHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return headers to add to the error response, for example, \"Allow\", \"Accept\", etc.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHeaders()",
    "source_code": "\tpublic HttpHeaders getHeaders() {\n\t\treturn HttpHeaders.EMPTY;\n\t}"
  },
  "org.springframework.web.server.ResponseStatusException#getMessage()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "String",
    "signature": "public String getMessage()",
    "source_code": "\tpublic String getMessage() {\n\t\treturn getStatusCode() + (this.reason != null ? \" \\\"\" + this.reason + \"\\\"\" : \"\");\n\t}"
  },
  "org.springframework.web.server.ResponseStatusException#getReason()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The reason explaining the exception (potentially {@code null} or empty).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "String",
    "signature": "public String getReason()",
    "source_code": "\tpublic @Nullable String getReason() {\n\t\treturn this.reason;\n\t}"
  },
  "org.springframework.web.server.ResponseStatusException#updateAndGetBody(messageSource,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "ProblemDetail",
    "signature": "public ProblemDetail updateAndGetBody(@Nullable MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic ProblemDetail updateAndGetBody(@Nullable MessageSource messageSource, Locale locale) {\n\t\tsuper.updateAndGetBody(messageSource, locale);\n\n\t\t// The reason may be a code (consistent with ResponseStatusExceptionResolver)\n\n\t\tif (messageSource != null && getReason() != null && getReason().equals(getBody().getDetail())) {\n\t\t\tObject[] arguments = getDetailMessageArguments(messageSource, locale);\n\t\t\tString resolved = messageSource.getMessage(getReason(), arguments, null, locale);\n\t\t\tif (resolved != null) {\n\t\t\t\tgetBody().setDetail(resolved);\n\t\t\t}\n\t\t}\n\n\t\treturn getBody();\n\t}"
  },
  "org.springframework.web.server.ServerWebExchange": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Contract for an HTTP request-response interaction. Provides access to the HTTP\n * request and response and also exposes additional server-side processing\n * related properties and features such as request attributes.\n *\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public interface ServerWebExchange",
    "source_code": "public interface ServerWebExchange {\n\n\t/**\n\t * Name of {@link #getAttributes() attribute} whose value can be used to\n\t * correlate log messages for this exchange. Use {@link #getLogPrefix()} to\n\t * obtain a consistently formatted prefix based on this attribute.\n\t * @since 5.1\n\t * @see #getLogPrefix()\n\t */\n\tString LOG_ID_ATTRIBUTE = ServerWebExchange.class.getName() + \".LOG_ID\";\n\n\n\t/**\n\t * Return the current HTTP request.\n\t */\n\tServerHttpRequest getRequest();\n\n\t/**\n\t * Return the current HTTP response.\n\t */\n\tServerHttpResponse getResponse();\n\n\t/**\n\t * Return a mutable map of request attributes for the current exchange.\n\t */\n\tMap<String, Object> getAttributes();\n\n\t/**\n\t * Return the request attribute value if present.\n\t * @param name the attribute name\n\t * @param <T> the attribute type\n\t * @return the attribute value\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tdefault <T> @Nullable T getAttribute(String name) {\n\t\treturn (T) getAttributes().get(name);\n\t}\n\n\t/**\n\t * Return the request attribute value or if not present raise an\n\t * {@link IllegalArgumentException}.\n\t * @param name the attribute name\n\t * @param <T> the attribute type\n\t * @return the attribute value\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tdefault <T> T getRequiredAttribute(String name) {\n\t\tT value = getAttribute(name);\n\t\tAssert.notNull(value, () -> \"Required attribute '\" + name + \"' is missing\");\n\t\treturn value;\n\t}\n\n\t/**\n\t * Return the request attribute value, or a default, fallback value.\n\t * @param name the attribute name\n\t * @param defaultValue a default value to return instead\n\t * @param <T> the attribute type\n\t * @return the attribute value\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tdefault <T> T getAttributeOrDefault(String name, T defaultValue) {\n\t\treturn (T) getAttributes().getOrDefault(name, defaultValue);\n\t}\n\n\t/**\n\t * Return the web session for the current request. Always guaranteed  to\n\t * return an instance either matching to the session id requested by the\n\t * client, or with a new session id either because the client did not\n\t * specify one or because the underlying session had expired. Use of this\n\t * method does not automatically create a session. See {@link WebSession}\n\t * for more details.\n\t */\n\tMono<WebSession> getSession();\n\n\t/**\n\t * Return the authenticated user for the request, if any.\n\t */\n\t<T extends Principal> Mono<T> getPrincipal();\n\n\t/**\n\t * Return the form data from the body of the request if the Content-Type is\n\t * {@code \"application/x-www-form-urlencoded\"} or an empty map otherwise.\n\t * <p><strong>Note:</strong> calling this method causes the request body to\n\t * be read and parsed in full and the resulting {@code MultiValueMap} is\n\t * cached so that this method is safe to call more than once.\n\t */\n\tMono<MultiValueMap<String, String>> getFormData();\n\n\t/**\n\t * Return the parts of a multipart request if the Content-Type is\n\t * {@code \"multipart/form-data\"} or an empty map otherwise.\n\t * <p><strong>Note:</strong> calling this method causes the request body to\n\t * be read and parsed in full and the resulting {@code MultiValueMap} is\n\t * cached so that this method is safe to call more than once.\n\t * <p><strong>Note:</strong>the {@linkplain Part#content() contents} of each\n\t * part is not cached, and can only be read once.\n\t */\n\tMono<MultiValueMap<String, Part>> getMultipartData();\n\n\t/**\n\t * Cleans up any storage used for multipart handling.\n\t * @since 6.0.10\n\t * @see Part#delete()\n\t */\n\tdefault Mono<Void> cleanupMultipart() {\n\t\treturn getMultipartData()\n\t\t\t\t.onErrorComplete()  // ignore errors reading multipart data\n\t\t\t\t.flatMapIterable(Map::values)\n\t\t\t\t.flatMapIterable(Function.identity())\n\t\t\t\t.flatMap(part -> part.delete().onErrorComplete())\n\t\t\t\t.then();\n\t}\n\n\t/**\n\t * Return the {@link LocaleContext} using the configured\n\t * {@link org.springframework.web.server.i18n.LocaleContextResolver}.\n\t */\n\tLocaleContext getLocaleContext();\n\n\t/**\n\t * Return the {@link ApplicationContext} associated with the web application,\n\t * if it was initialized with one via\n\t * {@link org.springframework.web.server.adapter.WebHttpHandlerBuilder#applicationContext(ApplicationContext)}.\n\t * @since 5.0.3\n\t * @see org.springframework.web.server.adapter.WebHttpHandlerBuilder#applicationContext(ApplicationContext)\n\t */\n\t@Nullable ApplicationContext getApplicationContext();\n\n\t/**\n\t * Returns {@code true} if the one of the {@code checkNotModified} methods\n\t * in this contract were used and they returned true.\n\t */\n\tboolean isNotModified();\n\n\t/**\n\t * An overloaded variant of {@link #checkNotModified(String, Instant)} with\n\t * a last-modified timestamp only.\n\t * @param lastModified the last-modified time\n\t * @return whether the request qualifies as not modified\n\t */\n\tboolean checkNotModified(Instant lastModified);\n\n\t/**\n\t * An overloaded variant of {@link #checkNotModified(String, Instant)} with\n\t * an {@code ETag} (entity tag) value only.\n\t * @param etag the entity tag for the underlying resource.\n\t * @return true if the request does not require further processing.\n\t */\n\tboolean checkNotModified(String etag);\n\n\t/**\n\t * Check whether the requested resource has been modified given the supplied\n\t * {@code ETag} (entity tag) and last-modified timestamp as determined by\n\t * the application. Also transparently prepares the response, setting HTTP\n\t * status, and adding \"ETag\" and \"Last-Modified\" headers when applicable.\n\t * This method works with conditional GET/HEAD requests as well as with\n\t * conditional POST/PUT/DELETE requests.\n\t * <p><strong>Note:</strong> The HTTP specification recommends setting both\n\t * ETag and Last-Modified values, but you can also use\n\t * {@code #checkNotModified(String)} or\n\t * {@link #checkNotModified(Instant)}.\n\t * @param etag the entity tag that the application determined for the\n\t * underlying resource. This parameter will be padded with quotes (\")\n\t * if necessary.\n\t * @param lastModified the last-modified timestamp that the application\n\t * determined for the underlying resource\n\t * @return true if the request does not require further processing.\n\t */\n\tboolean checkNotModified(@Nullable String etag, Instant lastModified);\n\n\t/**\n\t * Transform the given url according to the registered transformation function(s).\n\t * By default, this method returns the given {@code url}, though additional\n\t * transformation functions can be registered with {@link #addUrlTransformer}\n\t * @param url the URL to transform\n\t * @return the transformed URL\n\t */\n\tString transformUrl(String url);\n\n\t/**\n\t * Register an additional URL transformation function for use with {@link #transformUrl}.\n\t * The given function can be used to insert an id for authentication, a nonce for CSRF\n\t * protection, etc.\n\t * <p>Note that the given function is applied after any previously registered functions.\n\t * @param transformer a URL transformation function to add\n\t */\n\tvoid addUrlTransformer(Function<String, String> transformer);\n\n\t/**\n\t * Return a log message prefix to use to correlate messages for this exchange.\n\t * The prefix is based on the value of the attribute {@link #LOG_ID_ATTRIBUTE}\n\t * along with some extra formatting so that the prefix can be conveniently\n\t * prepended with no further formatting no separators required.\n\t * @return the log message prefix or an empty String if the\n\t * {@link #LOG_ID_ATTRIBUTE} is not set.\n\t * @since 5.1\n\t */\n\tString getLogPrefix();\n\n\t/**\n\t * Return a builder to mutate properties of this exchange by wrapping it\n\t * with {@link ServerWebExchangeDecorator} and returning either mutated\n\t * values or delegating back to this instance.\n\t */\n\tdefault Builder mutate() {\n\t\treturn new DefaultServerWebExchangeBuilder(this);\n\t}\n\n\n\t/**\n\t * Builder for mutating an existing {@link ServerWebExchange}.\n\t * Removes the need\n\t */\n\tinterface Builder {\n\n\t\t/**\n\t\t * Configure a consumer to modify the current request using a builder.\n\t\t * <p>Effectively this:\n\t\t * <pre>\n\t\t * exchange.mutate().request(builder -&gt; builder.method(HttpMethod.PUT));\n\t\t *\n\t\t * // vs...\n\t\t *\n\t\t * ServerHttpRequest request = exchange.getRequest().mutate()\n\t\t *     .method(HttpMethod.PUT)\n\t\t *     .build();\n\t\t *\n\t\t * exchange.mutate().request(request);\n\t\t * </pre>\n\t\t * @see ServerHttpRequest#mutate()\n\t\t */\n\t\tBuilder request(Consumer<ServerHttpRequest.Builder> requestBuilderConsumer);\n\n\t\t/**\n\t\t * Set the request to use especially when there is a need to override\n\t\t * {@link ServerHttpRequest} methods. To simply mutate request properties\n\t\t * see {@link #request(Consumer)} instead.\n\t\t * @see org.springframework.http.server.reactive.ServerHttpRequestDecorator\n\t\t */\n\t\tBuilder request(ServerHttpRequest request);\n\n\t\t/**\n\t\t * Set the response to use.\n\t\t * @see org.springframework.http.server.reactive.ServerHttpResponseDecorator\n\t\t */\n\t\tBuilder response(ServerHttpResponse response);\n\n\t\t/**\n\t\t * Set the {@code Mono<Principal>} to return for this exchange.\n\t\t */\n\t\tBuilder principal(Mono<Principal> principalMono);\n\n\t\t/**\n\t\t * Build a {@link ServerWebExchange} decorator with the mutated properties.\n\t\t */\n\t\tServerWebExchange build();\n\t}\n\n}"
  },
  "org.springframework.web.server.ServerWebInputException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Exception for errors that fit response status 400 (bad request) for use in\n * Spring Web applications. The exception provides additional fields (for example,\n * an optional {@link MethodParameter} if related to the error).\n *\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 33
    },
    "signature": "public class ServerWebInputException",
    "source_code": "public class ServerWebInputException extends ResponseStatusException {\n\n\tprivate final @Nullable MethodParameter parameter;\n\n\n\t/**\n\t * Constructor with an explanation only.\n\t */\n\tpublic ServerWebInputException(String reason) {\n\t\tthis(reason, null, null);\n\t}\n\n\t/**\n\t * Constructor for a 400 error linked to a specific {@code MethodParameter}.\n\t */\n\tpublic ServerWebInputException(String reason, @Nullable MethodParameter parameter) {\n\t\tthis(reason, parameter, null);\n\t}\n\n\t/**\n\t * Constructor for a 400 error with a root cause.\n\t */\n\tpublic ServerWebInputException(String reason, @Nullable MethodParameter parameter, @Nullable Throwable cause) {\n\t\tthis(reason, parameter, cause, null, null);\n\t}\n\n\t/**\n\t * Constructor with a message code and arguments for resolving the error\n\t * \"detail\" via {@link org.springframework.context.MessageSource}.\n\t * @since 6.0\n\t */\n\tprotected ServerWebInputException(String reason, @Nullable MethodParameter parameter, @Nullable Throwable cause,\n\t\t\t@Nullable String messageDetailCode, Object @Nullable [] messageDetailArguments) {\n\n\t\tsuper(HttpStatus.BAD_REQUEST, reason, cause, messageDetailCode, messageDetailArguments);\n\t\tthis.parameter = parameter;\n\t}\n\n\n\t/**\n\t * Return the {@code MethodParameter} associated with this error, if any.\n\t */\n\tpublic @Nullable MethodParameter getMethodParameter() {\n\t\treturn this.parameter;\n\t}\n\n}"
  },
  "org.springframework.web.server.ServerWebInputException#getMethodParameter()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@code MethodParameter} associated with this error, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getMethodParameter()",
    "source_code": "\tpublic @Nullable MethodParameter getMethodParameter() {\n\t\treturn this.parameter;\n\t}"
  },
  "org.springframework.web.server.WebSession": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Main contract for using a server-side session that provides access to session\n * attributes across HTTP requests.\n *\n * <p>The creation of a {@code WebSession} instance does not automatically start\n * a session thus causing the session id to be sent to the client (typically via\n * a cookie). A session starts implicitly when session attributes are added.\n * A session may also be created explicitly via {@link #start()}.\n *\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public interface WebSession",
    "source_code": "public interface WebSession {\n\n\t/**\n\t * Return a unique session identifier.\n\t */\n\tString getId();\n\n\t/**\n\t * Return a map that holds session attributes.\n\t */\n\tMap<String, Object> getAttributes();\n\n\t/**\n\t * Return the session attribute value if present.\n\t * @param name the attribute name\n\t * @param <T> the attribute type\n\t * @return the attribute value\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tdefault <T> @Nullable T getAttribute(String name) {\n\t\treturn (T) getAttributes().get(name);\n\t}\n\n\t/**\n\t * Return the session attribute value or if not present raise an\n\t * {@link IllegalArgumentException}.\n\t * @param name the attribute name\n\t * @param <T> the attribute type\n\t * @return the attribute value\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tdefault <T> T getRequiredAttribute(String name) {\n\t\tT value = getAttribute(name);\n\t\tAssert.notNull(value, () -> \"Required attribute '\" + name + \"' is missing.\");\n\t\treturn value;\n\t}\n\n\t/**\n\t * Return the session attribute value, or a default, fallback value.\n\t * @param name the attribute name\n\t * @param defaultValue a default value to return instead\n\t * @param <T> the attribute type\n\t * @return the attribute value\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tdefault <T> T getAttributeOrDefault(String name, T defaultValue) {\n\t\treturn (T) getAttributes().getOrDefault(name, defaultValue);\n\t}\n\n\t/**\n\t * Force the creation of a session causing the session id to be sent when\n\t * {@link #save()} is called.\n\t */\n\tvoid start();\n\n\t/**\n\t * Whether a session with the client has been started explicitly via\n\t * {@link #start()} or implicitly by adding session attributes.\n\t * If \"false\" then the session id is not sent to the client and the\n\t * {@link #save()} method is essentially a no-op.\n\t */\n\tboolean isStarted();\n\n\t/**\n\t * Generate a new id for the session and update the underlying session\n\t * storage to reflect the new id. After a successful call {@link #getId()}\n\t * reflects the new session id.\n\t * @return completion notification (success or error)\n\t */\n\tMono<Void> changeSessionId();\n\n\t/**\n\t * Invalidate the current session and clear session storage.\n\t * @return completion notification (success or error)\n\t */\n\tMono<Void> invalidate();\n\n\t/**\n\t * Save the session through the {@code WebSessionStore} as follows:\n\t * <ul>\n\t * <li>If the session is new (i.e. created but never persisted), it must have\n\t * been started explicitly via {@link #start()} or implicitly by adding\n\t * attributes, or otherwise this method should have no effect.\n\t * <li>If the session was retrieved through the {@code WebSessionStore},\n\t * the implementation for this method must check whether the session was\n\t * {@link #invalidate() invalidated} and if so return an error.\n\t * </ul>\n\t * <p>Note that this method is not intended for direct use by applications.\n\t * Instead it is automatically invoked just before the response is\n\t * committed.\n\t * @return {@code Mono} to indicate completion with success or error\n\t */\n\tMono<Void> save();\n\n\t/**\n\t * Return {@code true} if the session expired after {@link #getMaxIdleTime()\n\t * maxIdleTime} elapsed.\n\t * <p>Typically expiration checks should be automatically made when a session\n\t * is accessed, a new {@code WebSession} instance created if necessary, at\n\t * the start of request processing so that applications don't have to worry\n\t * about expired session by default.\n\t */\n\tboolean isExpired();\n\n\t/**\n\t * Return the time when the session was created.\n\t */\n\tInstant getCreationTime();\n\n\t/**\n\t * Return the last time of session access as a result of user activity such\n\t * as an HTTP request. Together with {@link #getMaxIdleTime()\n\t * maxIdleTimeInSeconds} this helps to determine when a session is\n\t * {@link #isExpired() expired}.\n\t */\n\tInstant getLastAccessTime();\n\n\t/**\n\t * Configure the max amount of time that may elapse after the\n\t * {@link #getLastAccessTime() lastAccessTime} before a session is considered\n\t * expired. A negative value indicates the session should not expire.\n\t */\n\tvoid setMaxIdleTime(Duration maxIdleTime);\n\n\t/**\n\t * Return the maximum time after the {@link #getLastAccessTime()\n\t * lastAccessTime} before a session expires. A negative time indicates the\n\t * session doesn't expire.\n\t */\n\tDuration getMaxIdleTime();\n\n}"
  },
  "org.springframework.web.server.handler.ResponseStatusExceptionHandler#determineRawStatusCode(ex)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the raw status code for the given exception.\n\t * @param ex the exception to check\n\t * @return the associated HTTP status code, or -1 if it can't be derived.\n\t * @since 5.3\n\t * @deprecated in favor of {@link #determineStatus(Throwable)}, for removal in 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "int",
    "signature": "protected int determineRawStatusCode(Throwable ex)",
    "source_code": "\tprotected int determineRawStatusCode(Throwable ex) {\n\t\tif (ex instanceof ResponseStatusException responseStatusException) {\n\t\t\treturn responseStatusException.getStatusCode().value();\n\t\t}\n\t\treturn -1;\n\t}"
  },
  "org.springframework.web.service.invoker.HttpExchangeAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Contract to abstract an HTTP client from {@linkplain HttpServiceProxyFactory}\n * and make it pluggable.\n *\n * <p>For reactive clients, see {@link ReactorHttpExchangeAdapter}.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 34
    },
    "signature": "public interface HttpExchangeAdapter",
    "source_code": "public interface HttpExchangeAdapter {\n\n\t/**\n\t * Whether the underlying client supports use of request attributes.\n\t */\n\tboolean supportsRequestAttributes();\n\n\t/**\n\t * Perform the given request, and release the response content, if any.\n\t * @param requestValues the request to perform\n\t */\n\tvoid exchange(HttpRequestValues requestValues);\n\n\t/**\n\t * Perform the given request, release the response content, and return the\n\t * response headers.\n\t * @param requestValues the request to perform\n\t * @return the response headers\n\t */\n\tHttpHeaders exchangeForHeaders(HttpRequestValues requestValues);\n\n\t/**\n\t * Perform the given request and decode the response content to the given type.\n\t * @param requestValues the request to perform\n\t * @param bodyType the target type to decode to\n\t * @param <T> the type the response is decoded to\n\t * @return the decoded response body.\n\t */\n\t<T> @Nullable T exchangeForBody(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType);\n\n\t/**\n\t * Variant of {@link #exchange(HttpRequestValues)} with additional\n\t * access to the response status and headers.\n\t * @return the response entity with status and headers.\n\t */\n\tResponseEntity<Void> exchangeForBodilessEntity(HttpRequestValues requestValues);\n\n\t/**\n\t * Variant of {@link #exchangeForBody(HttpRequestValues, ParameterizedTypeReference)}\n\t * with additional access to the response status and headers.\n\t * @return the response entity with status, headers, and body.\n\t */\n\t<T> ResponseEntity<T> exchangeForEntity(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType);\n\n}"
  },
  "org.springframework.web.servlet.DispatcherServlet#setThrowExceptionIfNoHandlerFound(throwExceptionIfNoHandlerFound)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to throw a NoHandlerFoundException when no Handler was found for this request.\n\t * This exception can then be caught with a HandlerExceptionResolver or an\n\t * {@code @ExceptionHandler} controller method.\n\t * <p>Note that if {@link org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler}\n\t * is used, then requests will always be forwarded to the default servlet and a\n\t * NoHandlerFoundException would never be thrown in that case.\n\t * <p>Default is \"false\", meaning the DispatcherServlet sends a NOT_FOUND error through the\n\t * Servlet response.\n\t * @since 4.0\n\t * @deprecated as of 6.1 this property is set to {@code true} by default, and\n\t * should not need to be customized; in effect, {@link DispatcherServlet}\n\t * should always raise {@link NoHandlerFoundException} and allow it to be\n\t * handled through a {@link HandlerExceptionResolver}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "throwExceptionIfNoHandlerFound"
    ],
    "position": {
      "column": 1,
      "line": 475
    },
    "return": "void",
    "signature": "public void setThrowExceptionIfNoHandlerFound(boolean throwExceptionIfNoHandlerFound)",
    "source_code": "\tpublic void setThrowExceptionIfNoHandlerFound(boolean throwExceptionIfNoHandlerFound) {\n\t\tthis.throwExceptionIfNoHandlerFound = throwExceptionIfNoHandlerFound;\n\t}"
  },
  "org.springframework.web.servlet.HandlerExecutionChain#getInterceptors()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the array of interceptors to apply (in the given order).\n\t * @return the array of HandlerInterceptors instances (may be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "HandlerInterceptor[]",
    "signature": "public HandlerInterceptor[] getInterceptors()",
    "source_code": "\tpublic HandlerInterceptor[] getInterceptors() {\n\t\treturn (!this.interceptorList.isEmpty() ? this.interceptorList.toArray(new HandlerInterceptor[0]) : null);\n\t}"
  },
  "org.springframework.web.servlet.THEME_RESOLVER_ATTRIBUTE": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Request attribute to hold the current ThemeResolver, retrievable by views.\n\t * @see org.springframework.web.servlet.support.RequestContextUtils#getThemeResolver\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "signature": "public String THEME_RESOLVER_ATTRIBUTE",
    "source_code": "\tpublic static final String THEME_RESOLVER_ATTRIBUTE = DispatcherServlet.class.getName() + \".THEME_RESOLVER\";",
    "type": "String"
  },
  "org.springframework.web.servlet.THEME_RESOLVER_BEAN_NAME": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Well-known name for the ThemeResolver object in the bean factory for this namespace.\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "signature": "public String THEME_RESOLVER_BEAN_NAME",
    "source_code": "\tpublic static final String THEME_RESOLVER_BEAN_NAME = \"themeResolver\";",
    "type": "String"
  },
  "org.springframework.web.servlet.THEME_SOURCE_ATTRIBUTE": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Request attribute to hold the current ThemeSource, retrievable by views.\n\t * @see org.springframework.web.servlet.support.RequestContextUtils#getThemeSource\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "signature": "public String THEME_SOURCE_ATTRIBUTE",
    "source_code": "\tpublic static final String THEME_SOURCE_ATTRIBUTE = DispatcherServlet.class.getName() + \".THEME_SOURCE\";",
    "type": "String"
  },
  "org.springframework.web.servlet.function.<unknown>#build()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "ServerRequest",
    "signature": "public ServerRequest build()",
    "source_code": "\tpublic ServerRequest build() {\n\t\treturn new BuiltServerRequest(this.servletRequest, this.method, this.uri, this.headers, this.cookies,\n\t\t\t\tthis.attributes, this.params, this.remoteAddress, this.body, this.messageConverters);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#methodName()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "String",
    "signature": "public String methodName()",
    "source_code": "\tpublic String methodName() {\n\t\treturn servletRequest().getMethod();\n\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#methodName()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1133
    },
    "return": "String",
    "signature": "public String methodName()",
    "source_code": "\t\tpublic String methodName() {\n\t\t\treturn this.delegate.methodName();\n\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#pathContainer()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1375
    },
    "return": "PathContainer",
    "signature": "public PathContainer pathContainer()",
    "source_code": "\t\tpublic PathContainer pathContainer() {\n\t\t\treturn this.requestPath;\n\t\t}"
  },
  "org.springframework.web.servlet.function.support.HandlerFunctionAdapter#getLastModified(request,handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\treturn -1L;\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for {@link HandlerExceptionResolver} implementations.\n *\n * <p>Supports mapped {@linkplain #setMappedHandlers handlers} and\n * {@linkplain #setMappedHandlerClasses handler classes} that the resolver\n * should be applied to and implements the {@link Ordered} interface.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class AbstractHandlerExceptionResolver",
    "source_code": "public abstract class AbstractHandlerExceptionResolver implements HandlerExceptionResolver, Ordered {\n\n\tprivate static final String HEADER_CACHE_CONTROL = \"Cache-Control\";\n\n\tprivate static final String DISCONNECTED_CLIENT_LOG_CATEGORY =\n\t\t\t\"org.springframework.web.servlet.handler.DisconnectedClient\";\n\n\tprivate static final DisconnectedClientHelper disconnectedClientHelper =\n\t\t\tnew DisconnectedClientHelper(DISCONNECTED_CLIENT_LOG_CATEGORY);\n\n\n\t/** Logger available to subclasses. */\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate int order = Ordered.LOWEST_PRECEDENCE;\n\n\tprivate @Nullable Predicate<Object> mappedHandlerPredicate;\n\n\tprivate @Nullable Set<?> mappedHandlers;\n\n\tprivate Class<?> @Nullable [] mappedHandlerClasses;\n\n\tprivate @Nullable Log warnLogger;\n\n\tprivate boolean preventResponseCaching = false;\n\n\n\tpublic void setOrder(int order) {\n\t\tthis.order = order;\n\t}\n\n\t@Override\n\tpublic int getOrder() {\n\t\treturn this.order;\n\t}\n\n\t/**\n\t * Use a {@code Predicate} to determine which handlers this exception\n\t * resolver applies to, including when the request was not mapped in which\n\t * case the handler is {@code null}.\n\t * <p>If no handler predicate, nor handlers, nor handler classes are set,\n\t * the exception resolver applies to all handlers.\n\t * @since 6.1.2\n\t */\n\tpublic void setMappedHandlerPredicate(Predicate<Object> predicate) {\n\t\tthis.mappedHandlerPredicate =\n\t\t\t\t(this.mappedHandlerPredicate != null ? this.mappedHandlerPredicate.and(predicate) : predicate);\n\t}\n\n\t/**\n\t * Specify the set of handlers that this exception resolver should apply to.\n\t * <p>If no handler predicate, nor handlers, nor handler classes are set,\n\t * the exception resolver applies to all handlers.\n\t * @see #setMappedHandlerPredicate(Predicate)\n\t */\n\tpublic void setMappedHandlers(Set<?> mappedHandlers) {\n\t\tthis.mappedHandlers = mappedHandlers;\n\t}\n\n\t/**\n\t * Specify the set of classes that this exception resolver should apply to.\n\t * The resolver will only apply to handlers of the specified types; the\n\t * specified types may be interfaces or superclasses of handlers as well.\n\t * <p>If no handler predicate, nor handlers, nor handler classes are set,\n\t * the exception resolver applies to all handlers.\n\t * @see #setMappedHandlerPredicate(Predicate)\n\t */\n\tpublic void setMappedHandlerClasses(Class<?>... mappedHandlerClasses) {\n\t\tthis.mappedHandlerClasses = mappedHandlerClasses;\n\t}\n\n\t/**\n\t * Alternative to {@link #setMappedHandlerClasses(Class[])}.\n\t * @since 6.1\n\t */\n\tpublic void addMappedHandlerClass(Class<?> mappedHandlerClass) {\n\t\tthis.mappedHandlerClasses = (this.mappedHandlerClasses != null ?\n\t\t\t\tObjectUtils.addObjectToArray(this.mappedHandlerClasses, mappedHandlerClass) :\n\t\t\t\tnew Class<?>[] {mappedHandlerClass});\n\t}\n\n\t/**\n\t * Return the {@link #setMappedHandlerClasses(Class[]) configured} mapped\n\t * handler classes.\n\t */\n\tprotected Class<?> @Nullable [] getMappedHandlerClasses() {\n\t\treturn this.mappedHandlerClasses;\n\t}\n\n\t/**\n\t * Set the log category for warn logging. The name will be passed to the underlying logger\n\t * implementation through Commons Logging, getting interpreted as a log category according\n\t * to the logger's configuration. If {@code null} or empty String is passed, warn logging\n\t * is turned off.\n\t * <p>By default there is no warn logging although subclasses like\n\t * {@link org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver}\n\t * can change that default. Specify this setting to activate warn logging into a specific\n\t * category. Alternatively, override the {@link #logException} method for custom logging.\n\t * @see org.apache.commons.logging.LogFactory#getLog(String)\n\t * @see java.util.logging.Logger#getLogger(String)\n\t */\n\tpublic void setWarnLogCategory(String loggerName) {\n\t\tthis.warnLogger = (StringUtils.hasLength(loggerName) ? LogFactory.getLog(loggerName) : null);\n\t}\n\n\t/**\n\t * Specify whether to prevent HTTP response caching for any view resolved\n\t * by this exception resolver.\n\t * <p>Default is {@code false}. Switch this to {@code true} in order to\n\t * automatically generate HTTP response headers that suppress response caching.\n\t */\n\tpublic void setPreventResponseCaching(boolean preventResponseCaching) {\n\t\tthis.preventResponseCaching = preventResponseCaching;\n\t}\n\n\n\t/**\n\t * Check whether this resolver is supposed to apply (i.e. if the supplied handler\n\t * matches any of the configured {@linkplain #setMappedHandlers handlers} or\n\t * {@linkplain #setMappedHandlerClasses handler classes}), and then delegate\n\t * to the {@link #doResolveException} template method.\n\t */\n\t@Override\n\tpublic @Nullable ModelAndView resolveException(\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {\n\n\t\tif (shouldApplyTo(request, handler)) {\n\t\t\tprepareResponse(ex, response);\n\t\t\tModelAndView result = doResolveException(request, response, handler, ex);\n\t\t\tif (result != null && !disconnectedClientHelper.checkAndLogClientDisconnectedException(ex)) {\n\t\t\t\t// Print debug message when warn logger is not enabled.\n\t\t\t\tif (logger.isDebugEnabled() && (this.warnLogger == null || !this.warnLogger.isWarnEnabled())) {\n\t\t\t\t\tlogger.debug(buildLogMessage(ex, request) + (result.isEmpty() ? \"\" : \" to \" + result));\n\t\t\t\t}\n\t\t\t\t// Explicitly configured warn logger in logException method.\n\t\t\t\tlogException(ex, request);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Check whether this resolver is supposed to apply to the given handler.\n\t * <p>The default implementation checks against the configured\n\t * {@linkplain #setMappedHandlerPredicate(Predicate) handlerPredicate}\n\t * {@linkplain #setMappedHandlers handlers} and\n\t * {@linkplain #setMappedHandlerClasses handler classes}, if any.\n\t * @param request current HTTP request\n\t * @param handler the executed handler, or {@code null} if none chosen\n\t * at the time of the exception (for example, if multipart resolution failed)\n\t * @return whether this resolved should proceed with resolving the exception\n\t * for the given request and handler\n\t * @see #setMappedHandlers\n\t * @see #setMappedHandlerClasses\n\t */\n\tprotected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler) {\n\t\tif (this.mappedHandlerPredicate != null) {\n\t\t\treturn this.mappedHandlerPredicate.test(handler);\n\t\t}\n\t\tif (handler != null) {\n\t\t\tif (this.mappedHandlers != null && this.mappedHandlers.contains(handler)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (this.mappedHandlerClasses != null) {\n\t\t\t\tfor (Class<?> handlerClass : this.mappedHandlerClasses) {\n\t\t\t\t\tif (handlerClass.isInstance(handler)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn !hasHandlerMappings();\n\t}\n\n\t/**\n\t * Whether there are any handler mappings registered via\n\t * {@link #setMappedHandlers(Set)}, {@link #setMappedHandlerClasses(Class[])}, or\n\t * {@link #setMappedHandlerPredicate(Predicate)}.\n\t * @since 5.3\n\t */\n\tprotected boolean hasHandlerMappings() {\n\t\treturn (this.mappedHandlers != null || this.mappedHandlerClasses != null ||\n\t\t\t\tthis.mappedHandlerPredicate != null);\n\t}\n\n\t/**\n\t * Log the given exception at warn level, provided that warn logging has been\n\t * activated through the {@link #setWarnLogCategory \"warnLogCategory\"} property.\n\t * <p>Calls {@link #buildLogMessage} in order to determine the concrete message to log.\n\t * @param ex the exception that got thrown during handler execution\n\t * @param request current HTTP request (useful for obtaining metadata)\n\t * @see #setWarnLogCategory\n\t * @see #buildLogMessage\n\t * @see org.apache.commons.logging.Log#warn(Object, Throwable)\n\t */\n\tprotected void logException(Exception ex, HttpServletRequest request) {\n\t\tif (this.warnLogger != null && this.warnLogger.isWarnEnabled()) {\n\t\t\tthis.warnLogger.warn(buildLogMessage(ex, request));\n\t\t}\n\t}\n\n\t/**\n\t * Build a log message for the given exception, occurred during processing the given request.\n\t * @param ex the exception that got thrown during handler execution\n\t * @param request current HTTP request (useful for obtaining metadata)\n\t * @return the log message to use\n\t */\n\tprotected String buildLogMessage(Exception ex, HttpServletRequest request) {\n\t\treturn \"Resolved [\" + LogFormatUtils.formatValue(ex, -1, true) + \"]\";\n\t}\n\n\t/**\n\t * Prepare the response for the exceptional case.\n\t * <p>The default implementation prevents the response from being cached,\n\t * if the {@link #setPreventResponseCaching \"preventResponseCaching\"} property\n\t * has been set to \"true\".\n\t * @param ex the exception that got thrown during handler execution\n\t * @param response current HTTP response\n\t * @see #preventCaching\n\t */\n\tprotected void prepareResponse(Exception ex, HttpServletResponse response) {\n\t\tif (this.preventResponseCaching) {\n\t\t\tpreventCaching(response);\n\t\t}\n\t}\n\n\t/**\n\t * Prevents the response from being cached, through setting corresponding\n\t * HTTP {@code Cache-Control: no-store} header.\n\t * @param response current HTTP response\n\t */\n\tprotected void preventCaching(HttpServletResponse response) {\n\t\tresponse.addHeader(HEADER_CACHE_CONTROL, \"no-store\");\n\t}\n\n\n\t/**\n\t * Actually resolve the given exception that got thrown during handler execution,\n\t * returning a {@link ModelAndView} that represents a specific error page if appropriate.\n\t * <p>May be overridden in subclasses, in order to apply specific exception checks.\n\t * Note that this template method will be invoked <i>after</i> checking whether this\n\t * resolver applies (\"mappedHandlers\" etc), so an implementation may simply proceed\n\t * with its actual exception handling.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen at the time\n\t * of the exception (for example, if multipart resolution failed)\n\t * @param ex the exception that got thrown during handler execution\n\t * @return a corresponding {@code ModelAndView} to forward to,\n\t * or {@code null} for default processing in the resolution chain\n\t */\n\tprotected abstract @Nullable ModelAndView doResolveException(\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex);\n\n}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver#addMappedHandlerClass(mappedHandlerClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Alternative to {@link #setMappedHandlerClasses(Class[])}.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedHandlerClass"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "public void addMappedHandlerClass(Class<?> mappedHandlerClass)",
    "source_code": "\tpublic void addMappedHandlerClass(Class<?> mappedHandlerClass) {\n\t\tthis.mappedHandlerClasses = (this.mappedHandlerClasses != null ?\n\t\t\t\tObjectUtils.addObjectToArray(this.mappedHandlerClasses, mappedHandlerClass) :\n\t\t\t\tnew Class<?>[] {mappedHandlerClass});\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver#buildLogMessage(ex,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a log message for the given exception, occurred during processing the given request.\n\t * @param ex the exception that got thrown during handler execution\n\t * @param request current HTTP request (useful for obtaining metadata)\n\t * @return the log message to use\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "String",
    "signature": "protected String buildLogMessage(Exception ex, HttpServletRequest request)",
    "source_code": "\tprotected String buildLogMessage(Exception ex, HttpServletRequest request) {\n\t\treturn \"Resolved [\" + LogFormatUtils.formatValue(ex, -1, true) + \"]\";\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver#doResolveException(request,response,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually resolve the given exception that got thrown during handler execution,\n\t * returning a {@link ModelAndView} that represents a specific error page if appropriate.\n\t * <p>May be overridden in subclasses, in order to apply specific exception checks.\n\t * Note that this template method will be invoked <i>after</i> checking whether this\n\t * resolver applies (\"mappedHandlers\" etc), so an implementation may simply proceed\n\t * with its actual exception handling.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen at the time\n\t * of the exception (for example, if multipart resolution failed)\n\t * @param ex the exception that got thrown during handler execution\n\t * @return a corresponding {@code ModelAndView} to forward to,\n\t * or {@code null} for default processing in the resolution chain\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)",
    "source_code": "\tprotected abstract @Nullable ModelAndView doResolveException("
  },
  "org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic int getOrder() {\n\t\treturn this.order;\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver#hasHandlerMappings()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether there are any handler mappings registered via\n\t * {@link #setMappedHandlers(Set)}, {@link #setMappedHandlerClasses(Class[])}, or\n\t * {@link #setMappedHandlerPredicate(Predicate)}.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "boolean",
    "signature": "protected boolean hasHandlerMappings()",
    "source_code": "\tprotected boolean hasHandlerMappings() {\n\t\treturn (this.mappedHandlers != null || this.mappedHandlerClasses != null ||\n\t\t\t\tthis.mappedHandlerPredicate != null);\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver#logException(ex,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Log the given exception at warn level, provided that warn logging has been\n\t * activated through the {@link #setWarnLogCategory \"warnLogCategory\"} property.\n\t * <p>Calls {@link #buildLogMessage} in order to determine the concrete message to log.\n\t * @param ex the exception that got thrown during handler execution\n\t * @param request current HTTP request (useful for obtaining metadata)\n\t * @see #setWarnLogCategory\n\t * @see #buildLogMessage\n\t * @see org.apache.commons.logging.Log#warn(Object, Throwable)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "void",
    "signature": "protected void logException(Exception ex, HttpServletRequest request)",
    "source_code": "\tprotected void logException(Exception ex, HttpServletRequest request) {\n\t\tif (this.warnLogger != null && this.warnLogger.isWarnEnabled()) {\n\t\t\tthis.warnLogger.warn(buildLogMessage(ex, request));\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver#prepareResponse(ex,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the response for the exceptional case.\n\t * <p>The default implementation prevents the response from being cached,\n\t * if the {@link #setPreventResponseCaching \"preventResponseCaching\"} property\n\t * has been set to \"true\".\n\t * @param ex the exception that got thrown during handler execution\n\t * @param response current HTTP response\n\t * @see #preventCaching\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "void",
    "signature": "protected void prepareResponse(Exception ex, HttpServletResponse response)",
    "source_code": "\tprotected void prepareResponse(Exception ex, HttpServletResponse response) {\n\t\tif (this.preventResponseCaching) {\n\t\t\tpreventCaching(response);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver#preventCaching(response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prevents the response from being cached, through setting corresponding\n\t * HTTP {@code Cache-Control: no-store} header.\n\t * @param response current HTTP response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "void",
    "signature": "protected void preventCaching(HttpServletResponse response)",
    "source_code": "\tprotected void preventCaching(HttpServletResponse response) {\n\t\tresponse.addHeader(HEADER_CACHE_CONTROL, \"no-store\");\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver#resolveException(request,response,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether this resolver is supposed to apply (i.e. if the supplied handler\n\t * matches any of the configured {@linkplain #setMappedHandlers handlers} or\n\t * {@linkplain #setMappedHandlerClasses handler classes}), and then delegate\n\t * to the {@link #doResolveException} template method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)",
    "source_code": "\tpublic @Nullable ModelAndView resolveException("
  },
  "org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver#setMappedHandlerClasses(mappedHandlerClasses)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the set of classes that this exception resolver should apply to.\n\t * The resolver will only apply to handlers of the specified types; the\n\t * specified types may be interfaces or superclasses of handlers as well.\n\t * <p>If no handler predicate, nor handlers, nor handler classes are set,\n\t * the exception resolver applies to all handlers.\n\t * @see #setMappedHandlerPredicate(Predicate)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedHandlerClasses"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void setMappedHandlerClasses(Class<?>... mappedHandlerClasses)",
    "source_code": "\tpublic void setMappedHandlerClasses(Class<?>... mappedHandlerClasses) {\n\t\tthis.mappedHandlerClasses = mappedHandlerClasses;\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver#setMappedHandlerPredicate(predicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Use a {@code Predicate} to determine which handlers this exception\n\t * resolver applies to, including when the request was not mapped in which\n\t * case the handler is {@code null}.\n\t * <p>If no handler predicate, nor handlers, nor handler classes are set,\n\t * the exception resolver applies to all handlers.\n\t * @since 6.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "void",
    "signature": "public void setMappedHandlerPredicate(Predicate<Object> predicate)",
    "source_code": "\tpublic void setMappedHandlerPredicate(Predicate<Object> predicate) {\n\t\tthis.mappedHandlerPredicate =\n\t\t\t\t(this.mappedHandlerPredicate != null ? this.mappedHandlerPredicate.and(predicate) : predicate);\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver#setMappedHandlers(mappedHandlers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the set of handlers that this exception resolver should apply to.\n\t * <p>If no handler predicate, nor handlers, nor handler classes are set,\n\t * the exception resolver applies to all handlers.\n\t * @see #setMappedHandlerPredicate(Predicate)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedHandlers"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void setMappedHandlers(Set<?> mappedHandlers)",
    "source_code": "\tpublic void setMappedHandlers(Set<?> mappedHandlers) {\n\t\tthis.mappedHandlers = mappedHandlers;\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver#setOrder(order)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "order"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "void",
    "signature": "public void setOrder(int order)",
    "source_code": "\tpublic void setOrder(int order) {\n\t\tthis.order = order;\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver#setPreventResponseCaching(preventResponseCaching)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to prevent HTTP response caching for any view resolved\n\t * by this exception resolver.\n\t * <p>Default is {@code false}. Switch this to {@code true} in order to\n\t * automatically generate HTTP response headers that suppress response caching.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "preventResponseCaching"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void setPreventResponseCaching(boolean preventResponseCaching)",
    "source_code": "\tpublic void setPreventResponseCaching(boolean preventResponseCaching) {\n\t\tthis.preventResponseCaching = preventResponseCaching;\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver#setWarnLogCategory(loggerName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the log category for warn logging. The name will be passed to the underlying logger\n\t * implementation through Commons Logging, getting interpreted as a log category according\n\t * to the logger's configuration. If {@code null} or empty String is passed, warn logging\n\t * is turned off.\n\t * <p>By default there is no warn logging although subclasses like\n\t * {@link org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver}\n\t * can change that default. Specify this setting to activate warn logging into a specific\n\t * category. Alternatively, override the {@link #logException} method for custom logging.\n\t * @see org.apache.commons.logging.LogFactory#getLog(String)\n\t * @see java.util.logging.Logger#getLogger(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "loggerName"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void setWarnLogCategory(String loggerName)",
    "source_code": "\tpublic void setWarnLogCategory(String loggerName) {\n\t\tthis.warnLogger = (StringUtils.hasLength(loggerName) ? LogFactory.getLog(loggerName) : null);\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver#shouldApplyTo(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether this resolver is supposed to apply to the given handler.\n\t * <p>The default implementation checks against the configured\n\t * {@linkplain #setMappedHandlerPredicate(Predicate) handlerPredicate}\n\t * {@linkplain #setMappedHandlers handlers} and\n\t * {@linkplain #setMappedHandlerClasses handler classes}, if any.\n\t * @param request current HTTP request\n\t * @param handler the executed handler, or {@code null} if none chosen\n\t * at the time of the exception (for example, if multipart resolution failed)\n\t * @return whether this resolved should proceed with resolving the exception\n\t * for the given request and handler\n\t * @see #setMappedHandlers\n\t * @see #setMappedHandlerClasses\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "boolean",
    "signature": "protected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler)",
    "source_code": "\tprotected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler) {\n\t\tif (this.mappedHandlerPredicate != null) {\n\t\t\treturn this.mappedHandlerPredicate.test(handler);\n\t\t}\n\t\tif (handler != null) {\n\t\t\tif (this.mappedHandlers != null && this.mappedHandlers.contains(handler)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (this.mappedHandlerClasses != null) {\n\t\t\t\tfor (Class<?> handlerClass : this.mappedHandlerClasses) {\n\t\t\t\t\tif (handlerClass.isInstance(handler)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn !hasHandlerMappings();\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerMapping#getAdaptedInterceptors()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return all configured interceptors adapted to {@link HandlerInterceptor}.\n\t * @return the array of configured interceptors, or {@code null} if none\n\t * are configured; this method also returns {@code null} if called too early,\n\t * or more specifically before\n\t * {@link org.springframework.context.ApplicationContextAware#setApplicationContext}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "HandlerInterceptor[]",
    "signature": "public HandlerInterceptor[] getAdaptedInterceptors()",
    "source_code": "\tpublic final HandlerInterceptor[] getAdaptedInterceptors() {\n\t\treturn (!this.adaptedInterceptors.isEmpty() ?\n\t\t\t\tthis.adaptedInterceptors.toArray(new HandlerInterceptor[0]) : null);\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerMapping#getMappedInterceptors()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return all configured {@link MappedInterceptor}s as an array.\n\t * @return the array of {@link MappedInterceptor}s, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "MappedInterceptor[]",
    "signature": "protected MappedInterceptor[] getMappedInterceptors()",
    "source_code": "\tprotected final MappedInterceptor[] getMappedInterceptors() {\n\t\tList<MappedInterceptor> mappedInterceptors = new ArrayList<>(this.adaptedInterceptors.size());\n\t\tfor (HandlerInterceptor interceptor : this.adaptedInterceptors) {\n\t\t\tif (interceptor instanceof MappedInterceptor mappedInterceptor) {\n\t\t\t\tmappedInterceptors.add(mappedInterceptor);\n\t\t\t}\n\t\t}\n\t\treturn (!mappedInterceptors.isEmpty() ? mappedInterceptors.toArray(new MappedInterceptor[0]) : null);\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#getMappingPathPatterns(mapping)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract and return the URL paths contained in the supplied mapping.\n\t * @deprecated as of 5.3 in favor of providing non-pattern mappings via\n\t * {@link #getDirectPaths(Object)} instead\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 529
    },
    "return": "Set<String>",
    "signature": "protected Set<String> getMappingPathPatterns(T mapping)",
    "source_code": "\tprotected Set<String> getMappingPathPatterns(T mapping) {\n\t\treturn Collections.emptySet();\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#setUseTrailingSlashMatch(useTrailingSlashMatch)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to match to URLs irrespective of the presence of a trailing slash.\n\t * If enabled a URL pattern such as \"/users\" also matches to \"/users/\".\n\t * <p>The default value is {@code false}.\n\t * @deprecated as of 6.0, see\n\t * {@link PathPatternParser#setMatchOptionalTrailingSeparator(boolean)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "useTrailingSlashMatch"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch)",
    "source_code": "\tpublic void setUseTrailingSlashMatch(boolean useTrailingSlashMatch) {\n\t\tthis.useTrailingSlashMatch = useTrailingSlashMatch;\n\t\tif (getPatternParser() != null) {\n\t\t\tgetPatternParser().setMatchOptionalTrailingSeparator(useTrailingSlashMatch);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#useTrailingSlashMatch()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to match to URLs irrespective of the presence of a trailing slash.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "boolean",
    "signature": "public boolean useTrailingSlashMatch()",
    "source_code": "\tpublic boolean useTrailingSlashMatch() {\n\t\treturn this.useTrailingSlashMatch;\n\t}"
  },
  "org.springframework.web.servlet.handler.DEFAULT_EXCEPTION_ATTRIBUTE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** The default name of the exception attribute: \"exception\". */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public String DEFAULT_EXCEPTION_ATTRIBUTE",
    "source_code": "\tpublic static final String DEFAULT_EXCEPTION_ATTRIBUTE = \"exception\";",
    "type": "String"
  },
  "org.springframework.web.servlet.handler.MappedInterceptor#getExcludePathPatterns()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the exclude path patterns this interceptor is mapped to.\n\t * @since 6.1\n\t * @see #getIncludePathPatterns()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "String[]",
    "signature": "public String[] getExcludePathPatterns()",
    "source_code": "\tpublic String[] getExcludePathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.excludePatterns) ?\n\t\t\t\tArrays.stream(this.excludePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}"
  },
  "org.springframework.web.servlet.handler.MappedInterceptor#getIncludePathPatterns()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the include path patterns this interceptor is mapped to.\n\t * @since 6.1\n\t * @see #getExcludePathPatterns()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "String[]",
    "signature": "public String[] getIncludePathPatterns()",
    "source_code": "\tpublic String[] getIncludePathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}"
  },
  "org.springframework.web.servlet.handler.MappedInterceptor#getPathPatterns()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the include path patterns this interceptor is mapped to.\n\t * @see #getIncludePathPatterns()\n\t * @see #getExcludePathPatterns()\n\t * @deprecated since 6.1 in favor of {@link #getIncludePathPatterns()}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "String[]",
    "signature": "public String[] getPathPatterns()",
    "source_code": "\tpublic String[] getPathPatterns() {\n\t\treturn getIncludePathPatterns();\n\t}"
  },
  "org.springframework.web.servlet.handler.MappedInterceptor#initPatterns(patterns,parser)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "patterns",
      "parser"
    ],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "PatternAdapter[]",
    "signature": "public PatternAdapter[] initPatterns(@Nullable String[] patterns, @Nullable PathPatternParser parser)",
    "source_code": "\t\tpublic static PatternAdapter[] initPatterns("
  },
  "org.springframework.web.servlet.handler.MappedInterceptor#matches(lookupPath,pathMatcher)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if there is a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lookupPath",
      "pathMatcher"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "boolean",
    "signature": "public boolean matches(String lookupPath, PathMatcher pathMatcher)",
    "source_code": "\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleMappingExceptionResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link org.springframework.web.servlet.HandlerExceptionResolver} implementation\n * that allows for mapping exception class names to view names, either for a set of\n * given handlers or for all handlers in the DispatcherServlet.\n *\n * <p>Error views are analogous to error page JSPs, but can be used with any kind of\n * exception including any checked one, with fine-granular mappings for specific handlers.\n *\n * @author Juergen Hoeller\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @since 22.11.2003\n * @see org.springframework.web.servlet.DispatcherServlet\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class SimpleMappingExceptionResolver",
    "source_code": "public class SimpleMappingExceptionResolver extends AbstractHandlerExceptionResolver {\n\n\t/** The default name of the exception attribute: \"exception\". */\n\tpublic static final String DEFAULT_EXCEPTION_ATTRIBUTE = \"exception\";\n\n\n\tprivate @Nullable Properties exceptionMappings;\n\n\tprivate Class<?> @Nullable [] excludedExceptions;\n\n\tprivate @Nullable String defaultErrorView;\n\n\tprivate @Nullable Integer defaultStatusCode;\n\n\tprivate final Map<String, Integer> statusCodes = new HashMap<>();\n\n\tprivate @Nullable String exceptionAttribute = DEFAULT_EXCEPTION_ATTRIBUTE;\n\n\n\t/**\n\t * Set the mappings between exception class names and error view names.\n\t * <p>The exception class name can be a substring, with no wildcard support\n\t * at present. For example, a value of \"ServletException\" would match\n\t * {@code jakarta.servlet.ServletException} and subclasses.\n\t * <p><b>NB:</b> Consider carefully how specific the pattern is and whether\n\t * to include package information (which isn't mandatory). For example,\n\t * \"Exception\" will match nearly anything and will probably hide other rules.\n\t * \"java.lang.Exception\" would be correct if \"Exception\" was meant to define\n\t * a rule for all checked exceptions. With more unique exception names such\n\t * as \"BaseBusinessException\" there's no need to use a fully-qualified class name.\n\t * @param mappings exception patterns (can also be fully-qualified class names)\n\t * as keys, and error view names as values\n\t */\n\tpublic void setExceptionMappings(Properties mappings) {\n\t\tthis.exceptionMappings = mappings;\n\t}\n\n\t/**\n\t * Set one or more exceptions to be excluded from the exception mappings.\n\t * Excluded exceptions are checked first and if one of them equals the actual\n\t * exception, the exception will remain unresolved.\n\t * @param excludedExceptions one or more excluded exception types\n\t */\n\tpublic void setExcludedExceptions(Class<?>... excludedExceptions) {\n\t\tthis.excludedExceptions = excludedExceptions;\n\t}\n\n\t/**\n\t * Set the name of the default error view.\n\t * This view will be returned if no specific mapping was found.\n\t * <p>Default is none.\n\t */\n\tpublic void setDefaultErrorView(String defaultErrorView) {\n\t\tthis.defaultErrorView = defaultErrorView;\n\t}\n\n\t/**\n\t * Set the HTTP status code that this exception resolver will apply for a given\n\t * resolved error view. Keys are view names; values are status codes.\n\t * <p>Note that this error code will only get applied in case of a top-level request.\n\t * It will not be set for an include request, since the HTTP status cannot be modified\n\t * from within an include.\n\t * <p>If not specified, the default status code will be applied.\n\t * @see #setDefaultStatusCode(int)\n\t */\n\tpublic void setStatusCodes(Properties statusCodes) {\n\t\tfor (Enumeration<?> enumeration = statusCodes.propertyNames(); enumeration.hasMoreElements();) {\n\t\t\tString viewName = (String) enumeration.nextElement();\n\t\t\tInteger statusCode = Integer.valueOf(statusCodes.getProperty(viewName));\n\t\t\tthis.statusCodes.put(viewName, statusCode);\n\t\t}\n\t}\n\n\t/**\n\t * An alternative to {@link #setStatusCodes(Properties)} for use with\n\t * Java-based configuration.\n\t */\n\tpublic void addStatusCode(String viewName, int statusCode) {\n\t\tthis.statusCodes.put(viewName, statusCode);\n\t}\n\n\t/**\n\t * Returns the HTTP status codes provided via {@link #setStatusCodes(Properties)}.\n\t * Keys are view names; values are status codes.\n\t */\n\tpublic Map<String, Integer> getStatusCodesAsMap() {\n\t\treturn Collections.unmodifiableMap(this.statusCodes);\n\t}\n\n\t/**\n\t * Set the default HTTP status code that this exception resolver will apply\n\t * if it resolves an error view and if there is no status code mapping defined.\n\t * <p>Note that this error code will only get applied in case of a top-level request.\n\t * It will not be set for an include request, since the HTTP status cannot be modified\n\t * from within an include.\n\t * <p>If not specified, no status code will be applied, either leaving this to the\n\t * controller or view, or keeping the servlet engine's default of 200 (OK).\n\t * @param defaultStatusCode the HTTP status code value, for example 500\n\t * ({@link HttpServletResponse#SC_INTERNAL_SERVER_ERROR}) or 404 ({@link HttpServletResponse#SC_NOT_FOUND})\n\t * @see #setStatusCodes(Properties)\n\t */\n\tpublic void setDefaultStatusCode(int defaultStatusCode) {\n\t\tthis.defaultStatusCode = defaultStatusCode;\n\t}\n\n\t/**\n\t * Set the name of the model attribute as which the exception should be exposed.\n\t * Default is \"exception\".\n\t * <p>This can be either set to a different attribute name or to {@code null}\n\t * for not exposing an exception attribute at all.\n\t * @see #DEFAULT_EXCEPTION_ATTRIBUTE\n\t */\n\tpublic void setExceptionAttribute(@Nullable String exceptionAttribute) {\n\t\tthis.exceptionAttribute = exceptionAttribute;\n\t}\n\n\n\t/**\n\t * Actually resolve the given exception that got thrown during on handler execution,\n\t * returning a ModelAndView that represents a specific error page if appropriate.\n\t * <p>May be overridden in subclasses, in order to apply specific exception checks.\n\t * Note that this template method will be invoked <i>after</i> checking whether this\n\t * resolved applies (\"mappedHandlers\" etc), so an implementation may simply proceed\n\t * with its actual exception handling.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen at the time\n\t * of the exception (for example, if multipart resolution failed)\n\t * @param ex the exception that got thrown during handler execution\n\t * @return a corresponding {@code ModelAndView} to forward to,\n\t * or {@code null} for default processing in the resolution chain\n\t */\n\t@Override\n\tprotected @Nullable ModelAndView doResolveException(\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {\n\n\t\t// Expose ModelAndView for chosen error view.\n\t\tString viewName = determineViewName(ex, request);\n\t\tif (viewName != null) {\n\t\t\t// Apply HTTP status code for error views, if specified.\n\t\t\t// Only apply it if we're processing a top-level request.\n\t\t\tInteger statusCode = determineStatusCode(request, viewName);\n\t\t\tif (statusCode != null) {\n\t\t\t\tapplyStatusCodeIfPossible(request, response, statusCode);\n\t\t\t}\n\t\t\treturn getModelAndView(viewName, ex, request);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Determine the view name for the given exception, first checking against the\n\t * {@link #setExcludedExceptions(Class[]) \"excludedExecptions\"}, then searching the\n\t * {@link #setExceptionMappings \"exceptionMappings\"}, and finally using the\n\t * {@link #setDefaultErrorView \"defaultErrorView\"} as a fallback.\n\t * @param ex the exception that got thrown during handler execution\n\t * @param request current HTTP request (useful for obtaining metadata)\n\t * @return the resolved view name, or {@code null} if excluded or none found\n\t */\n\tprotected @Nullable String determineViewName(Exception ex, HttpServletRequest request) {\n\t\tString viewName = null;\n\t\tif (this.excludedExceptions != null) {\n\t\t\tfor (Class<?> excludedEx : this.excludedExceptions) {\n\t\t\t\tif (excludedEx.equals(ex.getClass())) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Check for specific exception mappings.\n\t\tif (this.exceptionMappings != null) {\n\t\t\tviewName = findMatchingViewName(this.exceptionMappings, ex);\n\t\t}\n\t\t// Return default error view else, if defined.\n\t\tif (viewName == null && this.defaultErrorView != null) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Resolving to default view '\" + this.defaultErrorView + \"'\");\n\t\t\t}\n\t\t\tviewName = this.defaultErrorView;\n\t\t}\n\t\treturn viewName;\n\t}\n\n\t/**\n\t * Find a matching view name in the given exception mappings.\n\t * @param exceptionMappings mappings between exception class names and error view names\n\t * @param ex the exception that got thrown during handler execution\n\t * @return the view name, or {@code null} if none found\n\t * @see #setExceptionMappings\n\t */\n\tprotected @Nullable String findMatchingViewName(Properties exceptionMappings, Exception ex) {\n\t\tString viewName = null;\n\t\tString dominantMapping = null;\n\t\tint deepest = Integer.MAX_VALUE;\n\t\tfor (Enumeration<?> names = exceptionMappings.propertyNames(); names.hasMoreElements();) {\n\t\t\tString exceptionMapping = (String) names.nextElement();\n\t\t\tint depth = getDepth(exceptionMapping, ex);\n\t\t\tif (depth >= 0 && (depth < deepest || (depth == deepest &&\n\t\t\t\t\tdominantMapping != null && exceptionMapping.length() > dominantMapping.length()))) {\n\t\t\t\tdeepest = depth;\n\t\t\t\tdominantMapping = exceptionMapping;\n\t\t\t\tviewName = exceptionMappings.getProperty(exceptionMapping);\n\t\t\t}\n\t\t}\n\t\tif (viewName != null && logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Resolving to view '\" + viewName + \"' based on mapping [\" + dominantMapping + \"]\");\n\t\t}\n\t\treturn viewName;\n\t}\n\n\t/**\n\t * Return the depth to the superclass matching.\n\t * <p>0 means ex matches exactly. Returns -1 if there's no match.\n\t * Otherwise, returns depth. Lowest depth wins.\n\t */\n\tprotected int getDepth(String exceptionMapping, Exception ex) {\n\t\treturn getDepth(exceptionMapping, ex.getClass(), 0);\n\t}\n\n\tprivate int getDepth(String exceptionMapping, Class<?> exceptionClass, int depth) {\n\t\tif (exceptionClass.getName().contains(exceptionMapping)) {\n\t\t\t// Found it!\n\t\t\treturn depth;\n\t\t}\n\t\t// If we've gone as far as we can go and haven't found it...\n\t\tif (exceptionClass == Throwable.class) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn getDepth(exceptionMapping, exceptionClass.getSuperclass(), depth + 1);\n\t}\n\n\t/**\n\t * Determine the HTTP status code to apply for the given error view.\n\t * <p>The default implementation returns the status code for the given view name (specified through the\n\t * {@link #setStatusCodes(Properties) statusCodes} property), or falls back to the\n\t * {@link #setDefaultStatusCode defaultStatusCode} if there is no match.\n\t * <p>Override this in a custom subclass to customize this behavior.\n\t * @param request current HTTP request\n\t * @param viewName the name of the error view\n\t * @return the HTTP status code to use, or {@code null} for the servlet container's default\n\t * (200 in case of a standard error view)\n\t * @see #setDefaultStatusCode\n\t * @see #applyStatusCodeIfPossible\n\t */\n\tprotected @Nullable Integer determineStatusCode(HttpServletRequest request, String viewName) {\n\t\tif (this.statusCodes.containsKey(viewName)) {\n\t\t\treturn this.statusCodes.get(viewName);\n\t\t}\n\t\treturn this.defaultStatusCode;\n\t}\n\n\t/**\n\t * Apply the specified HTTP status code to the given response, if possible (that is,\n\t * if not executing within an include request).\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param statusCode the status code to apply\n\t * @see #determineStatusCode\n\t * @see #setDefaultStatusCode\n\t * @see HttpServletResponse#setStatus\n\t */\n\tprotected void applyStatusCodeIfPossible(HttpServletRequest request, HttpServletResponse response, int statusCode) {\n\t\tif (!WebUtils.isIncludeRequest(request)) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Applying HTTP status \" + statusCode);\n\t\t\t}\n\t\t\tresponse.setStatus(statusCode);\n\t\t\trequest.setAttribute(WebUtils.ERROR_STATUS_CODE_ATTRIBUTE, statusCode);\n\t\t}\n\t}\n\n\t/**\n\t * Return a ModelAndView for the given request, view name and exception.\n\t * <p>The default implementation delegates to {@link #getModelAndView(String, Exception)}.\n\t * @param viewName the name of the error view\n\t * @param ex the exception that got thrown during handler execution\n\t * @param request current HTTP request (useful for obtaining metadata)\n\t * @return the ModelAndView instance\n\t */\n\tprotected ModelAndView getModelAndView(String viewName, Exception ex, HttpServletRequest request) {\n\t\treturn getModelAndView(viewName, ex);\n\t}\n\n\t/**\n\t * Return a ModelAndView for the given view name and exception.\n\t * <p>The default implementation adds the specified exception attribute.\n\t * Can be overridden in subclasses.\n\t * @param viewName the name of the error view\n\t * @param ex the exception that got thrown during handler execution\n\t * @return the ModelAndView instance\n\t * @see #setExceptionAttribute\n\t */\n\tprotected ModelAndView getModelAndView(String viewName, Exception ex) {\n\t\tModelAndView mv = new ModelAndView(viewName);\n\t\tif (this.exceptionAttribute != null) {\n\t\t\tmv.addObject(this.exceptionAttribute, ex);\n\t\t}\n\t\treturn mv;\n\t}\n\n}"
  },
  "org.springframework.web.servlet.handler.SimpleMappingExceptionResolver#addStatusCode(viewName,statusCode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to {@link #setStatusCodes(Properties)} for use with\n\t * Java-based configuration.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewName",
      "statusCode"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "public void addStatusCode(String viewName, int statusCode)",
    "source_code": "\tpublic void addStatusCode(String viewName, int statusCode) {\n\t\tthis.statusCodes.put(viewName, statusCode);\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleMappingExceptionResolver#applyStatusCodeIfPossible(request,response,statusCode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the specified HTTP status code to the given response, if possible (that is,\n\t * if not executing within an include request).\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param statusCode the status code to apply\n\t * @see #determineStatusCode\n\t * @see #setDefaultStatusCode\n\t * @see HttpServletResponse#setStatus\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "statusCode"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "void",
    "signature": "protected void applyStatusCodeIfPossible(HttpServletRequest request, HttpServletResponse response, int statusCode)",
    "source_code": "\tprotected void applyStatusCodeIfPossible(HttpServletRequest request, HttpServletResponse response, int statusCode) {\n\t\tif (!WebUtils.isIncludeRequest(request)) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Applying HTTP status \" + statusCode);\n\t\t\t}\n\t\t\tresponse.setStatus(statusCode);\n\t\t\trequest.setAttribute(WebUtils.ERROR_STATUS_CODE_ATTRIBUTE, statusCode);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleMappingExceptionResolver#determineStatusCode(request,viewName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the HTTP status code to apply for the given error view.\n\t * <p>The default implementation returns the status code for the given view name (specified through the\n\t * {@link #setStatusCodes(Properties) statusCodes} property), or falls back to the\n\t * {@link #setDefaultStatusCode defaultStatusCode} if there is no match.\n\t * <p>Override this in a custom subclass to customize this behavior.\n\t * @param request current HTTP request\n\t * @param viewName the name of the error view\n\t * @return the HTTP status code to use, or {@code null} for the servlet container's default\n\t * (200 in case of a standard error view)\n\t * @see #setDefaultStatusCode\n\t * @see #applyStatusCodeIfPossible\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "viewName"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "Integer",
    "signature": "protected Integer determineStatusCode(HttpServletRequest request, String viewName)",
    "source_code": "\tprotected @Nullable Integer determineStatusCode(HttpServletRequest request, String viewName) {\n\t\tif (this.statusCodes.containsKey(viewName)) {\n\t\t\treturn this.statusCodes.get(viewName);\n\t\t}\n\t\treturn this.defaultStatusCode;\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleMappingExceptionResolver#determineViewName(ex,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the view name for the given exception, first checking against the\n\t * {@link #setExcludedExceptions(Class[]) \"excludedExecptions\"}, then searching the\n\t * {@link #setExceptionMappings \"exceptionMappings\"}, and finally using the\n\t * {@link #setDefaultErrorView \"defaultErrorView\"} as a fallback.\n\t * @param ex the exception that got thrown during handler execution\n\t * @param request current HTTP request (useful for obtaining metadata)\n\t * @return the resolved view name, or {@code null} if excluded or none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "String",
    "signature": "protected String determineViewName(Exception ex, HttpServletRequest request)",
    "source_code": "\tprotected @Nullable String determineViewName(Exception ex, HttpServletRequest request) {\n\t\tString viewName = null;\n\t\tif (this.excludedExceptions != null) {\n\t\t\tfor (Class<?> excludedEx : this.excludedExceptions) {\n\t\t\t\tif (excludedEx.equals(ex.getClass())) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Check for specific exception mappings.\n\t\tif (this.exceptionMappings != null) {\n\t\t\tviewName = findMatchingViewName(this.exceptionMappings, ex);\n\t\t}\n\t\t// Return default error view else, if defined.\n\t\tif (viewName == null && this.defaultErrorView != null) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Resolving to default view '\" + this.defaultErrorView + \"'\");\n\t\t\t}\n\t\t\tviewName = this.defaultErrorView;\n\t\t}\n\t\treturn viewName;\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleMappingExceptionResolver#doResolveException(request,response,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually resolve the given exception that got thrown during on handler execution,\n\t * returning a ModelAndView that represents a specific error page if appropriate.\n\t * <p>May be overridden in subclasses, in order to apply specific exception checks.\n\t * Note that this template method will be invoked <i>after</i> checking whether this\n\t * resolved applies (\"mappedHandlers\" etc), so an implementation may simply proceed\n\t * with its actual exception handling.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen at the time\n\t * of the exception (for example, if multipart resolution failed)\n\t * @param ex the exception that got thrown during handler execution\n\t * @return a corresponding {@code ModelAndView} to forward to,\n\t * or {@code null} for default processing in the resolution chain\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)",
    "source_code": "\tprotected @Nullable ModelAndView doResolveException("
  },
  "org.springframework.web.servlet.handler.SimpleMappingExceptionResolver#findMatchingViewName(exceptionMappings,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a matching view name in the given exception mappings.\n\t * @param exceptionMappings mappings between exception class names and error view names\n\t * @param ex the exception that got thrown during handler execution\n\t * @return the view name, or {@code null} if none found\n\t * @see #setExceptionMappings\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exceptionMappings",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "String",
    "signature": "protected String findMatchingViewName(Properties exceptionMappings, Exception ex)",
    "source_code": "\tprotected @Nullable String findMatchingViewName(Properties exceptionMappings, Exception ex) {\n\t\tString viewName = null;\n\t\tString dominantMapping = null;\n\t\tint deepest = Integer.MAX_VALUE;\n\t\tfor (Enumeration<?> names = exceptionMappings.propertyNames(); names.hasMoreElements();) {\n\t\t\tString exceptionMapping = (String) names.nextElement();\n\t\t\tint depth = getDepth(exceptionMapping, ex);\n\t\t\tif (depth >= 0 && (depth < deepest || (depth == deepest &&\n\t\t\t\t\tdominantMapping != null && exceptionMapping.length() > dominantMapping.length()))) {\n\t\t\t\tdeepest = depth;\n\t\t\t\tdominantMapping = exceptionMapping;\n\t\t\t\tviewName = exceptionMappings.getProperty(exceptionMapping);\n\t\t\t}\n\t\t}\n\t\tif (viewName != null && logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Resolving to view '\" + viewName + \"' based on mapping [\" + dominantMapping + \"]\");\n\t\t}\n\t\treturn viewName;\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleMappingExceptionResolver#getDepth(exceptionMapping,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the depth to the superclass matching.\n\t * <p>0 means ex matches exactly. Returns -1 if there's no match.\n\t * Otherwise, returns depth. Lowest depth wins.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exceptionMapping",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "int",
    "signature": "protected int getDepth(String exceptionMapping, Exception ex)",
    "source_code": "\tprotected int getDepth(String exceptionMapping, Exception ex) {\n\t\treturn getDepth(exceptionMapping, ex.getClass(), 0);\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleMappingExceptionResolver#getModelAndView(viewName,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a ModelAndView for the given view name and exception.\n\t * <p>The default implementation adds the specified exception attribute.\n\t * Can be overridden in subclasses.\n\t * @param viewName the name of the error view\n\t * @param ex the exception that got thrown during handler execution\n\t * @return the ModelAndView instance\n\t * @see #setExceptionAttribute\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView getModelAndView(String viewName, Exception ex)",
    "source_code": "\tprotected ModelAndView getModelAndView(String viewName, Exception ex) {\n\t\tModelAndView mv = new ModelAndView(viewName);\n\t\tif (this.exceptionAttribute != null) {\n\t\t\tmv.addObject(this.exceptionAttribute, ex);\n\t\t}\n\t\treturn mv;\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleMappingExceptionResolver#getModelAndView(viewName,ex,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a ModelAndView for the given request, view name and exception.\n\t * <p>The default implementation delegates to {@link #getModelAndView(String, Exception)}.\n\t * @param viewName the name of the error view\n\t * @param ex the exception that got thrown during handler execution\n\t * @param request current HTTP request (useful for obtaining metadata)\n\t * @return the ModelAndView instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "ex",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView getModelAndView(String viewName, Exception ex, HttpServletRequest request)",
    "source_code": "\tprotected ModelAndView getModelAndView(String viewName, Exception ex, HttpServletRequest request) {\n\t\treturn getModelAndView(viewName, ex);\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleMappingExceptionResolver#getStatusCodesAsMap()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the HTTP status codes provided via {@link #setStatusCodes(Properties)}.\n\t * Keys are view names; values are status codes.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "Integer>",
    "signature": "public Integer> getStatusCodesAsMap()",
    "source_code": "\tpublic Map<String, Integer> getStatusCodesAsMap() {\n\t\treturn Collections.unmodifiableMap(this.statusCodes);\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleMappingExceptionResolver#setDefaultErrorView(defaultErrorView)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the default error view.\n\t * This view will be returned if no specific mapping was found.\n\t * <p>Default is none.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultErrorView"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void setDefaultErrorView(String defaultErrorView)",
    "source_code": "\tpublic void setDefaultErrorView(String defaultErrorView) {\n\t\tthis.defaultErrorView = defaultErrorView;\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleMappingExceptionResolver#setDefaultStatusCode(defaultStatusCode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the default HTTP status code that this exception resolver will apply\n\t * if it resolves an error view and if there is no status code mapping defined.\n\t * <p>Note that this error code will only get applied in case of a top-level request.\n\t * It will not be set for an include request, since the HTTP status cannot be modified\n\t * from within an include.\n\t * <p>If not specified, no status code will be applied, either leaving this to the\n\t * controller or view, or keeping the servlet engine's default of 200 (OK).\n\t * @param defaultStatusCode the HTTP status code value, for example 500\n\t * ({@link HttpServletResponse#SC_INTERNAL_SERVER_ERROR}) or 404 ({@link HttpServletResponse#SC_NOT_FOUND})\n\t * @see #setStatusCodes(Properties)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultStatusCode"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void setDefaultStatusCode(int defaultStatusCode)",
    "source_code": "\tpublic void setDefaultStatusCode(int defaultStatusCode) {\n\t\tthis.defaultStatusCode = defaultStatusCode;\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleMappingExceptionResolver#setExceptionAttribute(exceptionAttribute)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the model attribute as which the exception should be exposed.\n\t * Default is \"exception\".\n\t * <p>This can be either set to a different attribute name or to {@code null}\n\t * for not exposing an exception attribute at all.\n\t * @see #DEFAULT_EXCEPTION_ATTRIBUTE\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exceptionAttribute"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "public void setExceptionAttribute(@Nullable String exceptionAttribute)",
    "source_code": "\tpublic void setExceptionAttribute(@Nullable String exceptionAttribute) {\n\t\tthis.exceptionAttribute = exceptionAttribute;\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleMappingExceptionResolver#setExceptionMappings(mappings)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the mappings between exception class names and error view names.\n\t * <p>The exception class name can be a substring, with no wildcard support\n\t * at present. For example, a value of \"ServletException\" would match\n\t * {@code jakarta.servlet.ServletException} and subclasses.\n\t * <p><b>NB:</b> Consider carefully how specific the pattern is and whether\n\t * to include package information (which isn't mandatory). For example,\n\t * \"Exception\" will match nearly anything and will probably hide other rules.\n\t * \"java.lang.Exception\" would be correct if \"Exception\" was meant to define\n\t * a rule for all checked exceptions. With more unique exception names such\n\t * as \"BaseBusinessException\" there's no need to use a fully-qualified class name.\n\t * @param mappings exception patterns (can also be fully-qualified class names)\n\t * as keys, and error view names as values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappings"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void setExceptionMappings(Properties mappings)",
    "source_code": "\tpublic void setExceptionMappings(Properties mappings) {\n\t\tthis.exceptionMappings = mappings;\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleMappingExceptionResolver#setExcludedExceptions(excludedExceptions)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set one or more exceptions to be excluded from the exception mappings.\n\t * Excluded exceptions are checked first and if one of them equals the actual\n\t * exception, the exception will remain unresolved.\n\t * @param excludedExceptions one or more excluded exception types\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "excludedExceptions"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void setExcludedExceptions(Class<?>... excludedExceptions)",
    "source_code": "\tpublic void setExcludedExceptions(Class<?>... excludedExceptions) {\n\t\tthis.excludedExceptions = excludedExceptions;\n\t}"
  },
  "org.springframework.web.servlet.handler.SimpleMappingExceptionResolver#setStatusCodes(statusCodes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the HTTP status code that this exception resolver will apply for a given\n\t * resolved error view. Keys are view names; values are status codes.\n\t * <p>Note that this error code will only get applied in case of a top-level request.\n\t * It will not be set for an include request, since the HTTP status cannot be modified\n\t * from within an include.\n\t * <p>If not specified, the default status code will be applied.\n\t * @see #setDefaultStatusCode(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCodes"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void setStatusCodes(Properties statusCodes)",
    "source_code": "\tpublic void setStatusCodes(Properties statusCodes) {\n\t\tfor (Enumeration<?> enumeration = statusCodes.propertyNames(); enumeration.hasMoreElements();) {\n\t\t\tString viewName = (String) enumeration.nextElement();\n\t\t\tInteger statusCode = Integer.valueOf(statusCodes.getProperty(viewName));\n\t\t\tthis.statusCodes.put(viewName, statusCode);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.UserRoleAuthorizationInterceptor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Interceptor that checks the authorization of the current user via the\n * user's roles, as evaluated by HttpServletRequest's isUserInRole method.\n *\n * @author Juergen Hoeller\n * @since 20.06.2003\n * @see jakarta.servlet.http.HttpServletRequest#isUserInRole\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "signature": "public class UserRoleAuthorizationInterceptor",
    "source_code": "public class UserRoleAuthorizationInterceptor implements HandlerInterceptor {\n\n\tprivate String @Nullable [] authorizedRoles;\n\n\n\t/**\n\t * Set the roles that this interceptor should treat as authorized.\n\t * @param authorizedRoles array of role names\n\t */\n\tpublic final void setAuthorizedRoles(String... authorizedRoles) {\n\t\tthis.authorizedRoles = authorizedRoles;\n\t}\n\n\n\t@Override\n\tpublic final boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (this.authorizedRoles != null) {\n\t\t\tfor (String role : this.authorizedRoles) {\n\t\t\t\tif (request.isUserInRole(role)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thandleNotAuthorized(request, response, handler);\n\t\treturn false;\n\t}\n\n\t/**\n\t * Handle a request that is not authorized according to this interceptor.\n\t * Default implementation sends HTTP status code 403 (\"forbidden\").\n\t * <p>This method can be overridden to write a custom message, forward or\n\t * redirect to some error page or login page, or throw a ServletException.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler chosen handler to execute, for type and/or instance evaluation\n\t * @throws jakarta.servlet.ServletException if there is an internal error\n\t * @throws java.io.IOException in case of an I/O error when writing the response\n\t */\n\tprotected void handleNotAuthorized(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows ServletException, IOException {\n\n\t\tresponse.sendError(HttpServletResponse.SC_FORBIDDEN);\n\t}\n\n}"
  },
  "org.springframework.web.servlet.handler.UserRoleAuthorizationInterceptor#handleNotAuthorized(request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle a request that is not authorized according to this interceptor.\n\t * Default implementation sends HTTP status code 403 (\"forbidden\").\n\t * <p>This method can be overridden to write a custom message, forward or\n\t * redirect to some error page or login page, or throw a ServletException.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler chosen handler to execute, for type and/or instance evaluation\n\t * @throws jakarta.servlet.ServletException if there is an internal error\n\t * @throws java.io.IOException in case of an I/O error when writing the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "void",
    "signature": "protected void handleNotAuthorized(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tprotected void handleNotAuthorized(HttpServletRequest request, HttpServletResponse response, Object handler)"
  },
  "org.springframework.web.servlet.handler.UserRoleAuthorizationInterceptor#preHandle(request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "boolean",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic final boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)"
  },
  "org.springframework.web.servlet.handler.UserRoleAuthorizationInterceptor#setAuthorizedRoles(authorizedRoles)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the roles that this interceptor should treat as authorized.\n\t * @param authorizedRoles array of role names\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "authorizedRoles"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "return": "void",
    "signature": "public void setAuthorizedRoles(String... authorizedRoles)",
    "source_code": "\tpublic final void setAuthorizedRoles(String... authorizedRoles) {\n\t\tthis.authorizedRoles = authorizedRoles;\n\t}"
  },
  "org.springframework.web.servlet.handler.logger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Logger available to subclasses. */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.web.servlet.i18n.CookieLocaleResolver#determineDefaultLocale(request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the default locale for the given request, called if no locale\n\t * cookie has been found.\n\t * <p>The default implementation returns the configured default locale, if any,\n\t * and otherwise falls back to the request's {@code Accept-Language} header\n\t * locale or the default locale for the server.\n\t * @param request the request to resolve the locale for\n\t * @return the default locale (never {@code null})\n\t * @see #setDefaultLocale\n\t * @see jakarta.servlet.http.HttpServletRequest#getLocale()\n\t * @deprecated as of 6.0, in favor of {@link #setDefaultLocaleFunction(Function)}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "Locale",
    "signature": "protected Locale determineDefaultLocale(HttpServletRequest request)",
    "source_code": "\tprotected Locale determineDefaultLocale(HttpServletRequest request) {\n\t\treturn this.defaultLocaleFunction.apply(request);\n\t}"
  },
  "org.springframework.web.servlet.i18n.CookieLocaleResolver#determineDefaultTimeZone(request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the default time zone for the given request, called if no locale\n\t * cookie has been found.\n\t * <p>The default implementation returns the configured default time zone,\n\t * if any, or {@code null} otherwise.\n\t * @param request the request to resolve the time zone for\n\t * @return the default time zone (or {@code null} if none defined)\n\t * @see #setDefaultTimeZone\n\t * @deprecated as of 6.0, in favor of {@link #setDefaultTimeZoneFunction(Function)}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 446
    },
    "return": "TimeZone",
    "signature": "protected TimeZone determineDefaultTimeZone(HttpServletRequest request)",
    "source_code": "\tprotected TimeZone determineDefaultTimeZone(HttpServletRequest request) {\n\t\treturn this.defaultTimeZoneFunction.apply(request);\n\t}"
  },
  "org.springframework.web.servlet.i18n.CookieLocaleResolver#setCookieName(cookieName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of cookie created by this resolver.\n\t * @param cookieName the cookie name\n\t * @deprecated as of 6.0 in favor of {@link #CookieLocaleResolver(String)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cookieName"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void setCookieName(String cookieName)",
    "source_code": "\tpublic void setCookieName(String cookieName) {\n\t\tAssert.notNull(cookieName, \"cookieName must not be null\");\n\t\tthis.cookie = ResponseCookie.from(cookieName)\n\t\t\t\t.maxAge(this.cookie.getMaxAge())\n\t\t\t\t.domain(this.cookie.getDomain())\n\t\t\t\t.path(this.cookie.getPath())\n\t\t\t\t.secure(this.cookie.isSecure())\n\t\t\t\t.httpOnly(this.cookie.isHttpOnly())\n\t\t\t\t.sameSite(this.cookie.getSameSite())\n\t\t\t\t.build();\n\n\t}"
  },
  "org.springframework.web.servlet.i18n.DEFAULT_PARAM_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Default name of the locale specification parameter: \"locale\".\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public String DEFAULT_PARAM_NAME",
    "source_code": "\tpublic static final String DEFAULT_PARAM_NAME = \"locale\";",
    "type": "String"
  },
  "org.springframework.web.servlet.i18n.LocaleChangeInterceptor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Interceptor that allows for changing the current locale on every request,\n * via a configurable request parameter (default parameter name: \"locale\").\n *\n * @author Juergen Hoeller\n * @author Rossen Stoyanchev\n * @since 20.06.2003\n * @see org.springframework.web.servlet.LocaleResolver\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public class LocaleChangeInterceptor",
    "source_code": "public class LocaleChangeInterceptor implements HandlerInterceptor {\n\n\t/**\n\t * Default name of the locale specification parameter: \"locale\".\n\t */\n\tpublic static final String DEFAULT_PARAM_NAME = \"locale\";\n\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate String paramName = DEFAULT_PARAM_NAME;\n\n\tprivate String @Nullable [] httpMethods;\n\n\tprivate boolean ignoreInvalidLocale = false;\n\n\n\t/**\n\t * Set the name of the parameter that contains a locale specification\n\t * in a locale change request. Default is \"locale\".\n\t */\n\tpublic void setParamName(String paramName) {\n\t\tthis.paramName = paramName;\n\t}\n\n\t/**\n\t * Return the name of the parameter that contains a locale specification\n\t * in a locale change request.\n\t */\n\tpublic String getParamName() {\n\t\treturn this.paramName;\n\t}\n\n\t/**\n\t * Configure the HTTP method(s) over which the locale can be changed.\n\t * @param httpMethods the methods\n\t * @since 4.2\n\t */\n\tpublic void setHttpMethods(String @Nullable ... httpMethods) {\n\t\tthis.httpMethods = httpMethods;\n\t}\n\n\t/**\n\t * Return the configured HTTP methods.\n\t * @since 4.2\n\t */\n\tpublic String @Nullable [] getHttpMethods() {\n\t\treturn this.httpMethods;\n\t}\n\n\t/**\n\t * Set whether to ignore an invalid value for the locale parameter.\n\t * @since 4.2.2\n\t */\n\tpublic void setIgnoreInvalidLocale(boolean ignoreInvalidLocale) {\n\t\tthis.ignoreInvalidLocale = ignoreInvalidLocale;\n\t}\n\n\t/**\n\t * Return whether to ignore an invalid value for the locale parameter.\n\t * @since 4.2.2\n\t */\n\tpublic boolean isIgnoreInvalidLocale() {\n\t\treturn this.ignoreInvalidLocale;\n\t}\n\n\n\t@Override\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows ServletException {\n\n\t\tString newLocale = request.getParameter(getParamName());\n\t\tif (newLocale != null) {\n\t\t\tif (checkHttpMethod(request.getMethod())) {\n\t\t\t\tLocaleResolver localeResolver = RequestContextUtils.getLocaleResolver(request);\n\t\t\t\tif (localeResolver == null) {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"No LocaleResolver found: not in a DispatcherServlet request?\");\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tlocaleResolver.setLocale(request, response, parseLocaleValue(newLocale));\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tif (isIgnoreInvalidLocale()) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Ignoring invalid locale value [\" + newLocale + \"]: \" + ex.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Proceed in any case.\n\t\treturn true;\n\t}\n\n\tprivate boolean checkHttpMethod(String currentMethod) {\n\t\tString[] configuredMethods = getHttpMethods();\n\t\tif (ObjectUtils.isEmpty(configuredMethods)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (String configuredMethod : configuredMethods) {\n\t\t\tif (configuredMethod.equalsIgnoreCase(currentMethod)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Parse the given locale value as coming from a request parameter.\n\t * <p>The default implementation calls {@link StringUtils#parseLocale(String)},\n\t * accepting the {@link Locale#toString} format as well as BCP 47 language tags.\n\t * @param localeValue the locale value to parse\n\t * @return the corresponding {@code Locale} instance\n\t * @since 4.3\n\t */\n\tprotected @Nullable Locale parseLocaleValue(String localeValue) {\n\t\treturn StringUtils.parseLocale(localeValue);\n\t}\n\n}"
  },
  "org.springframework.web.servlet.i18n.LocaleChangeInterceptor#getParamName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the parameter that contains a locale specification\n\t * in a locale change request.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "String",
    "signature": "public String getParamName()",
    "source_code": "\tpublic String getParamName() {\n\t\treturn this.paramName;\n\t}"
  },
  "org.springframework.web.servlet.i18n.LocaleChangeInterceptor#isIgnoreInvalidLocale()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to ignore an invalid value for the locale parameter.\n\t * @since 4.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "boolean",
    "signature": "public boolean isIgnoreInvalidLocale()",
    "source_code": "\tpublic boolean isIgnoreInvalidLocale() {\n\t\treturn this.ignoreInvalidLocale;\n\t}"
  },
  "org.springframework.web.servlet.i18n.LocaleChangeInterceptor#parseLocaleValue(localeValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given locale value as coming from a request parameter.\n\t * <p>The default implementation calls {@link StringUtils#parseLocale(String)},\n\t * accepting the {@link Locale#toString} format as well as BCP 47 language tags.\n\t * @param localeValue the locale value to parse\n\t * @return the corresponding {@code Locale} instance\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "localeValue"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "Locale",
    "signature": "protected Locale parseLocaleValue(String localeValue)",
    "source_code": "\tprotected @Nullable Locale parseLocaleValue(String localeValue) {\n\t\treturn StringUtils.parseLocale(localeValue);\n\t}"
  },
  "org.springframework.web.servlet.i18n.LocaleChangeInterceptor#preHandle(request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "boolean",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)"
  },
  "org.springframework.web.servlet.i18n.LocaleChangeInterceptor#setHttpMethods(httpMethods)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the HTTP method(s) over which the locale can be changed.\n\t * @param httpMethods the methods\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "httpMethods"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "void",
    "signature": "public void setHttpMethods(String @Nullable ... httpMethods)",
    "source_code": "\tpublic void setHttpMethods(String @Nullable ... httpMethods) {\n\t\tthis.httpMethods = httpMethods;\n\t}"
  },
  "org.springframework.web.servlet.i18n.LocaleChangeInterceptor#setIgnoreInvalidLocale(ignoreInvalidLocale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to ignore an invalid value for the locale parameter.\n\t * @since 4.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ignoreInvalidLocale"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "public void setIgnoreInvalidLocale(boolean ignoreInvalidLocale)",
    "source_code": "\tpublic void setIgnoreInvalidLocale(boolean ignoreInvalidLocale) {\n\t\tthis.ignoreInvalidLocale = ignoreInvalidLocale;\n\t}"
  },
  "org.springframework.web.servlet.i18n.LocaleChangeInterceptor#setParamName(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the parameter that contains a locale specification\n\t * in a locale change request. Default is \"locale\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void setParamName(String paramName)",
    "source_code": "\tpublic void setParamName(String paramName) {\n\t\tthis.paramName = paramName;\n\t}"
  },
  "org.springframework.web.servlet.i18n.SessionLocaleResolver#determineDefaultLocale(request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the default locale for the given request, called if no\n\t * {@link Locale} session attribute has been found.\n\t * <p>The default implementation returns the configured\n\t * {@linkplain #setDefaultLocale(Locale) default locale}, if any, and otherwise\n\t * falls back to the request's {@code Accept-Language} header locale or the\n\t * default locale for the server.\n\t * @param request the request to resolve the locale for\n\t * @return the default locale (never {@code null})\n\t * @see #setDefaultLocale\n\t * @see jakarta.servlet.http.HttpServletRequest#getLocale()\n\t * @deprecated as of 6.0, in favor of {@link #setDefaultLocaleFunction(Function)}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "Locale",
    "signature": "protected Locale determineDefaultLocale(HttpServletRequest request)",
    "source_code": "\tprotected Locale determineDefaultLocale(HttpServletRequest request) {\n\t\treturn this.defaultLocaleFunction.apply(request);\n\t}"
  },
  "org.springframework.web.servlet.i18n.SessionLocaleResolver#determineDefaultTimeZone(request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the default time zone for the given request, called if no\n\t * {@link TimeZone} session attribute has been found.\n\t * <p>The default implementation returns the configured default time zone,\n\t * if any, or {@code null} otherwise.\n\t * @param request the request to resolve the time zone for\n\t * @return the default time zone (or {@code null} if none defined)\n\t * @see #setDefaultTimeZone\n\t * @deprecated as of 6.0, in favor of {@link #setDefaultTimeZoneFunction(Function)}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "TimeZone",
    "signature": "protected TimeZone determineDefaultTimeZone(HttpServletRequest request)",
    "source_code": "\tprotected TimeZone determineDefaultTimeZone(HttpServletRequest request) {\n\t\treturn this.defaultTimeZoneFunction.apply(request);\n\t}"
  },
  "org.springframework.web.servlet.i18n.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Adapter to use the plain {@link org.springframework.web.HttpRequestHandler}\n * interface with the generic {@link org.springframework.web.servlet.DispatcherServlet}.\n * Supports handlers that implement the {@link LastModified} interface.\n *\n * <p>This is an SPI class, not used directly by application code.\n *\n * @author Juergen Hoeller\n * @since 2.0\n * @see org.springframework.web.servlet.DispatcherServlet\n * @see org.springframework.web.HttpRequestHandler\n * @see SimpleControllerHandlerAdapter\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class HttpRequestHandlerAdapter",
    "source_code": "public class HttpRequestHandlerAdapter implements HandlerAdapter {\n\n\t@Override\n\tpublic boolean supports(Object handler) {\n\t\treturn (handler instanceof HttpRequestHandler);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\t((HttpRequestHandler) handler).handleRequest(request, response);\n\t\treturn null;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"deprecation\")\n\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\tif (handler instanceof LastModified lastModified) {\n\t\t\treturn lastModified.getLastModified(request);\n\t\t}\n\t\treturn -1L;\n\t}\n\n}"
  },
  "org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter#getLastModified(request,handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\tif (handler instanceof LastModified lastModified) {\n\t\t\treturn lastModified.getLastModified(request);\n\t\t}\n\t\treturn -1L;\n\t}"
  },
  "org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter#handle(request,response,handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)"
  },
  "org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter#supports(handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "boolean",
    "signature": "public boolean supports(Object handler)",
    "source_code": "\tpublic boolean supports(Object handler) {\n\t\treturn (handler instanceof HttpRequestHandler);\n\t}"
  },
  "org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Adapter to use the plain {@link Controller} workflow interface with\n * the generic {@link org.springframework.web.servlet.DispatcherServlet}.\n * Supports handlers that implement the {@link LastModified} interface.\n *\n * <p>This is an SPI class, not used directly by application code.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @see org.springframework.web.servlet.DispatcherServlet\n * @see Controller\n * @see HttpRequestHandlerAdapter\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class SimpleControllerHandlerAdapter",
    "source_code": "public class SimpleControllerHandlerAdapter implements HandlerAdapter {\n\n\t@Override\n\tpublic boolean supports(Object handler) {\n\t\treturn (handler instanceof Controller);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn ((Controller) handler).handleRequest(request, response);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"deprecation\")\n\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\tif (handler instanceof LastModified lastModified) {\n\t\t\treturn lastModified.getLastModified(request);\n\t\t}\n\t\treturn -1L;\n\t}\n\n}"
  },
  "org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter#getLastModified(request,handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\tif (handler instanceof LastModified lastModified) {\n\t\t\treturn lastModified.getLastModified(request);\n\t\t}\n\t\treturn -1L;\n\t}"
  },
  "org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter#handle(request,response,handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)"
  },
  "org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter#supports(handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "return": "boolean",
    "signature": "public boolean supports(Object handler)",
    "source_code": "\tpublic boolean supports(Object handler) {\n\t\treturn (handler instanceof Controller);\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ConsumesRequestCondition": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A logical disjunction (' || ') request condition to match a request's\n * 'Content-Type' header to a list of media type expressions. Two kinds of\n * media type expressions are supported, which are described in\n * {@link RequestMapping#consumes()} and {@link RequestMapping#headers()}\n * where the header name is 'Content-Type'. Regardless of which syntax is\n * used, the semantics are the same.\n *\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class ConsumesRequestCondition",
    "source_code": "public final class ConsumesRequestCondition extends AbstractRequestCondition<ConsumesRequestCondition> {\n\n\tprivate static final ConsumesRequestCondition EMPTY_CONDITION = new ConsumesRequestCondition();\n\n\n\tprivate final List<ConsumeMediaTypeExpression> expressions;\n\n\tprivate boolean bodyRequired = true;\n\n\n\t/**\n\t * Creates a new instance from 0 or more \"consumes\" expressions.\n\t * @param consumes expressions with the syntax described in\n\t * {@link RequestMapping#consumes()}; if 0 expressions are provided,\n\t * the condition will match to every request\n\t */\n\tpublic ConsumesRequestCondition(String... consumes) {\n\t\tthis(consumes, null);\n\t}\n\n\t/**\n\t * Creates a new instance with \"consumes\" and \"header\" expressions.\n\t * \"Header\" expressions where the header name is not 'Content-Type' or have\n\t * no header value defined are ignored. If 0 expressions are provided in\n\t * total, the condition will match to every request\n\t * @param consumes as described in {@link RequestMapping#consumes()}\n\t * @param headers as described in {@link RequestMapping#headers()}\n\t */\n\tpublic ConsumesRequestCondition(String @Nullable [] consumes, String @Nullable [] headers) {\n\t\tthis.expressions = parseExpressions(consumes, headers);\n\t\tif (this.expressions.size() > 1) {\n\t\t\tCollections.sort(this.expressions);\n\t\t}\n\t}\n\n\tprivate static List<ConsumeMediaTypeExpression> parseExpressions(String @Nullable [] consumes, String @Nullable [] headers) {\n\t\tSet<ConsumeMediaTypeExpression> result = null;\n\t\tif (!ObjectUtils.isEmpty(headers)) {\n\t\t\tfor (String header : headers) {\n\t\t\t\tHeaderExpression expr = new HeaderExpression(header);\n\t\t\t\tif (\"Content-Type\".equalsIgnoreCase(expr.name) && expr.value != null) {\n\t\t\t\t\tresult = (result != null ? result : new LinkedHashSet<>());\n\t\t\t\t\tfor (MediaType mediaType : MediaType.parseMediaTypes(expr.value)) {\n\t\t\t\t\t\tresult.add(new ConsumeMediaTypeExpression(mediaType, expr.isNegated));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ObjectUtils.isEmpty(consumes)) {\n\t\t\tresult = (result != null ? result : new LinkedHashSet<>());\n\t\t\tfor (String consume : consumes) {\n\t\t\t\tresult.add(new ConsumeMediaTypeExpression(consume));\n\t\t\t}\n\t\t}\n\t\treturn (result != null ? new ArrayList<>(result) : Collections.emptyList());\n\t}\n\n\t/**\n\t * Private constructor for internal when creating matching conditions.\n\t * Note the expressions List is neither sorted nor deep copied.\n\t */\n\tprivate ConsumesRequestCondition(List<ConsumeMediaTypeExpression> expressions) {\n\t\tthis.expressions = expressions;\n\t}\n\n\n\t/**\n\t * Return the contained MediaType expressions.\n\t */\n\tpublic Set<MediaTypeExpression> getExpressions() {\n\t\treturn new LinkedHashSet<>(this.expressions);\n\t}\n\n\t/**\n\t * Returns the media types for this condition excluding negated expressions.\n\t */\n\tpublic Set<MediaType> getConsumableMediaTypes() {\n\t\tSet<MediaType> result = new LinkedHashSet<>();\n\t\tfor (ConsumeMediaTypeExpression expression : this.expressions) {\n\t\t\tif (!expression.isNegated()) {\n\t\t\t\tresult.add(expression.getMediaType());\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Whether the condition has any media type expressions.\n\t */\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn this.expressions.isEmpty();\n\t}\n\n\t@Override\n\tprotected Collection<ConsumeMediaTypeExpression> getContent() {\n\t\treturn this.expressions;\n\t}\n\n\t@Override\n\tprotected String getToStringInfix() {\n\t\treturn \" || \";\n\t}\n\n\t/**\n\t * Whether this condition should expect requests to have a body.\n\t * <p>By default this is set to {@code true} in which case it is assumed a\n\t * request body is required and this condition matches to the \"Content-Type\"\n\t * header or falls back on \"Content-Type: application/octet-stream\".\n\t * <p>If set to {@code false}, and the request does not have a body, then this\n\t * condition matches automatically, i.e. without checking expressions.\n\t * @param bodyRequired whether requests are expected to have a body\n\t * @since 5.2\n\t */\n\tpublic void setBodyRequired(boolean bodyRequired) {\n\t\tthis.bodyRequired = bodyRequired;\n\t}\n\n\t/**\n\t * Return the setting for {@link #setBodyRequired(boolean)}.\n\t * @since 5.2\n\t */\n\tpublic boolean isBodyRequired() {\n\t\treturn this.bodyRequired;\n\t}\n\n\n\t/**\n\t * Returns the \"other\" instance if it has any expressions; returns \"this\"\n\t * instance otherwise. Practically that means a method-level \"consumes\"\n\t * overrides a type-level \"consumes\" condition.\n\t */\n\t@Override\n\tpublic ConsumesRequestCondition combine(ConsumesRequestCondition other) {\n\t\treturn (!other.expressions.isEmpty() ? other : this);\n\t}\n\n\t/**\n\t * Checks if any of the contained media type expressions match the given\n\t * request 'Content-Type' header and returns an instance that is guaranteed\n\t * to contain matching expressions only. The match is performed via\n\t * {@link MediaType#includes(MediaType)}.\n\t * @param request the current request\n\t * @return the same instance if the condition contains no expressions;\n\t * or a new condition with matching expressions only;\n\t * or {@code null} if no expressions match\n\t */\n\t@Override\n\tpublic @Nullable ConsumesRequestCondition getMatchingCondition(HttpServletRequest request) {\n\t\tif (CorsUtils.isPreFlightRequest(request)) {\n\t\t\treturn EMPTY_CONDITION;\n\t\t}\n\t\tif (isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\t\tif (!hasBody(request) && !this.bodyRequired) {\n\t\t\treturn EMPTY_CONDITION;\n\t\t}\n\n\t\t// Common media types are cached at the level of MimeTypeUtils\n\n\t\tMediaType contentType;\n\t\ttry {\n\t\t\tcontentType = StringUtils.hasLength(request.getContentType()) ?\n\t\t\t\t\tMediaType.parseMediaType(request.getContentType()) :\n\t\t\t\t\tMediaType.APPLICATION_OCTET_STREAM;\n\t\t}\n\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\treturn null;\n\t\t}\n\n\t\tList<ConsumeMediaTypeExpression> result = getMatchingExpressions(contentType);\n\t\treturn !CollectionUtils.isEmpty(result) ? new ConsumesRequestCondition(result) : null;\n\t}\n\n\tprivate boolean hasBody(HttpServletRequest request) {\n\t\tString contentLength = request.getHeader(HttpHeaders.CONTENT_LENGTH);\n\t\tString transferEncoding = request.getHeader(HttpHeaders.TRANSFER_ENCODING);\n\t\treturn StringUtils.hasText(transferEncoding) ||\n\t\t\t\t(StringUtils.hasText(contentLength) && !contentLength.trim().equals(\"0\"));\n\t}\n\n\tprivate @Nullable List<ConsumeMediaTypeExpression> getMatchingExpressions(MediaType contentType) {\n\t\tList<ConsumeMediaTypeExpression> result = null;\n\t\tfor (ConsumeMediaTypeExpression expression : this.expressions) {\n\t\t\tif (expression.match(contentType)) {\n\t\t\t\tresult = result != null ? result : new ArrayList<>();\n\t\t\t\tresult.add(expression);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns:\n\t * <ul>\n\t * <li>0 if the two conditions have the same number of expressions\n\t * <li>Less than 0 if \"this\" has more or more specific media type expressions\n\t * <li>Greater than 0 if \"other\" has more or more specific media type expressions\n\t * </ul>\n\t * <p>It is assumed that both instances have been obtained via\n\t * {@link #getMatchingCondition(HttpServletRequest)} and each instance contains\n\t * the matching consumable media type expression only or is otherwise empty.\n\t */\n\t@Override\n\tpublic int compareTo(ConsumesRequestCondition other, HttpServletRequest request) {\n\t\tif (this.expressions.isEmpty() && other.expressions.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\t\telse if (this.expressions.isEmpty()) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if (other.expressions.isEmpty()) {\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\treturn this.expressions.get(0).compareTo(other.expressions.get(0));\n\t\t}\n\t}\n\n\n\t/**\n\t * Parses and matches a single media type expression to a request's 'Content-Type' header.\n\t */\n\tstatic class ConsumeMediaTypeExpression extends AbstractMediaTypeExpression {\n\n\t\tConsumeMediaTypeExpression(String expression) {\n\t\t\tsuper(expression);\n\t\t}\n\n\t\tConsumeMediaTypeExpression(MediaType mediaType, boolean negated) {\n\t\t\tsuper(mediaType, negated);\n\t\t}\n\n\t\tpublic final boolean match(MediaType contentType) {\n\t\t\tboolean match = (getMediaType().includes(contentType) && matchParameters(contentType));\n\t\t\treturn !isNegated() == match;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.servlet.mvc.condition.ConsumesRequestCondition#combine(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the \"other\" instance if it has any expressions; returns \"this\"\n\t * instance otherwise. Practically that means a method-level \"consumes\"\n\t * overrides a type-level \"consumes\" condition.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "ConsumesRequestCondition",
    "signature": "public ConsumesRequestCondition combine(ConsumesRequestCondition other)",
    "source_code": "\tpublic ConsumesRequestCondition combine(ConsumesRequestCondition other) {\n\t\treturn (!other.expressions.isEmpty() ? other : this);\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ConsumesRequestCondition#compareTo(other,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns:\n\t * <ul>\n\t * <li>0 if the two conditions have the same number of expressions\n\t * <li>Less than 0 if \"this\" has more or more specific media type expressions\n\t * <li>Greater than 0 if \"other\" has more or more specific media type expressions\n\t * </ul>\n\t * <p>It is assumed that both instances have been obtained via\n\t * {@link #getMatchingCondition(HttpServletRequest)} and each instance contains\n\t * the matching consumable media type expression only or is otherwise empty.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "int",
    "signature": "public int compareTo(ConsumesRequestCondition other, HttpServletRequest request)",
    "source_code": "\tpublic int compareTo(ConsumesRequestCondition other, HttpServletRequest request) {\n\t\tif (this.expressions.isEmpty() && other.expressions.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\t\telse if (this.expressions.isEmpty()) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if (other.expressions.isEmpty()) {\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\treturn this.expressions.get(0).compareTo(other.expressions.get(0));\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ConsumesRequestCondition#getConsumableMediaTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the media types for this condition excluding negated expressions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "Set<MediaType>",
    "signature": "public Set<MediaType> getConsumableMediaTypes()",
    "source_code": "\tpublic Set<MediaType> getConsumableMediaTypes() {\n\t\tSet<MediaType> result = new LinkedHashSet<>();\n\t\tfor (ConsumeMediaTypeExpression expression : this.expressions) {\n\t\t\tif (!expression.isNegated()) {\n\t\t\t\tresult.add(expression.getMediaType());\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ConsumesRequestCondition#getContent()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "Collection<ConsumeMediaTypeExpression>",
    "signature": "protected Collection<ConsumeMediaTypeExpression> getContent()",
    "source_code": "\tprotected Collection<ConsumeMediaTypeExpression> getContent() {\n\t\treturn this.expressions;\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ConsumesRequestCondition#getExpressions()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the contained MediaType expressions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "Set<MediaTypeExpression>",
    "signature": "public Set<MediaTypeExpression> getExpressions()",
    "source_code": "\tpublic Set<MediaTypeExpression> getExpressions() {\n\t\treturn new LinkedHashSet<>(this.expressions);\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ConsumesRequestCondition#getMatchingCondition(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Checks if any of the contained media type expressions match the given\n\t * request 'Content-Type' header and returns an instance that is guaranteed\n\t * to contain matching expressions only. The match is performed via\n\t * {@link MediaType#includes(MediaType)}.\n\t * @param request the current request\n\t * @return the same instance if the condition contains no expressions;\n\t * or a new condition with matching expressions only;\n\t * or {@code null} if no expressions match\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "ConsumesRequestCondition",
    "signature": "public ConsumesRequestCondition getMatchingCondition(HttpServletRequest request)",
    "source_code": "\tpublic @Nullable ConsumesRequestCondition getMatchingCondition(HttpServletRequest request) {\n\t\tif (CorsUtils.isPreFlightRequest(request)) {\n\t\t\treturn EMPTY_CONDITION;\n\t\t}\n\t\tif (isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\t\tif (!hasBody(request) && !this.bodyRequired) {\n\t\t\treturn EMPTY_CONDITION;\n\t\t}\n\n\t\t// Common media types are cached at the level of MimeTypeUtils\n\n\t\tMediaType contentType;\n\t\ttry {\n\t\t\tcontentType = StringUtils.hasLength(request.getContentType()) ?\n\t\t\t\t\tMediaType.parseMediaType(request.getContentType()) :\n\t\t\t\t\tMediaType.APPLICATION_OCTET_STREAM;\n\t\t}\n\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\treturn null;\n\t\t}\n\n\t\tList<ConsumeMediaTypeExpression> result = getMatchingExpressions(contentType);\n\t\treturn !CollectionUtils.isEmpty(result) ? new ConsumesRequestCondition(result) : null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ConsumesRequestCondition#getToStringInfix()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "String",
    "signature": "protected String getToStringInfix()",
    "source_code": "\tprotected String getToStringInfix() {\n\t\treturn \" || \";\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ConsumesRequestCondition#isBodyRequired()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the setting for {@link #setBodyRequired(boolean)}.\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "boolean",
    "signature": "public boolean isBodyRequired()",
    "source_code": "\tpublic boolean isBodyRequired() {\n\t\treturn this.bodyRequired;\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ConsumesRequestCondition#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the condition has any media type expressions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn this.expressions.isEmpty();\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ConsumesRequestCondition#match(contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 285
    },
    "return": "boolean",
    "signature": "public boolean match(MediaType contentType)",
    "source_code": "\t\tpublic final boolean match(MediaType contentType) {\n\t\t\tboolean match = (getMediaType().includes(contentType) && matchParameters(contentType));\n\t\t\treturn !isNegated() == match;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ConsumesRequestCondition#setBodyRequired(bodyRequired)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether this condition should expect requests to have a body.\n\t * <p>By default this is set to {@code true} in which case it is assumed a\n\t * request body is required and this condition matches to the \"Content-Type\"\n\t * header or falls back on \"Content-Type: application/octet-stream\".\n\t * <p>If set to {@code false}, and the request does not have a body, then this\n\t * condition matches automatically, i.e. without checking expressions.\n\t * @param bodyRequired whether requests are expected to have a body\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bodyRequired"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "void",
    "signature": "public void setBodyRequired(boolean bodyRequired)",
    "source_code": "\tpublic void setBodyRequired(boolean bodyRequired) {\n\t\tthis.bodyRequired = bodyRequired;\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ProducesRequestCondition": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A logical disjunction (' || ') request condition to match a request's 'Accept' header\n * to a list of media type expressions. Two kinds of media type expressions are\n * supported, which are described in {@link RequestMapping#produces()} and\n * {@link RequestMapping#headers()} where the header name is 'Accept'.\n * Regardless of which syntax is used, the semantics are the same.\n *\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class ProducesRequestCondition",
    "source_code": "public final class ProducesRequestCondition extends AbstractRequestCondition<ProducesRequestCondition> {\n\n\tprivate static final ContentNegotiationManager DEFAULT_CONTENT_NEGOTIATION_MANAGER =\n\t\t\tnew ContentNegotiationManager();\n\n\tprivate static final ProducesRequestCondition EMPTY_CONDITION = new ProducesRequestCondition();\n\n\tprivate static final List<ProduceMediaTypeExpression> MEDIA_TYPE_ALL_LIST =\n\t\t\tCollections.singletonList(new ProduceMediaTypeExpression(MediaType.ALL_VALUE));\n\n\tprivate static final String MEDIA_TYPES_ATTRIBUTE = ProducesRequestCondition.class.getName() + \".MEDIA_TYPES\";\n\n\n\tprivate final List<ProduceMediaTypeExpression> expressions;\n\n\tprivate final ContentNegotiationManager contentNegotiationManager;\n\n\n\t/**\n\t * Creates a new instance from \"produces\" expressions. If 0 expressions\n\t * are provided in total, this condition will match to any request.\n\t * @param produces expressions with syntax defined by {@link RequestMapping#produces()}\n\t */\n\tpublic ProducesRequestCondition(String... produces) {\n\t\tthis(produces, null, null);\n\t}\n\n\t/**\n\t * Creates a new instance with \"produces\" and \"header\" expressions. \"Header\"\n\t * expressions where the header name is not 'Accept' or have no header value\n\t * defined are ignored. If 0 expressions are provided in total, this condition\n\t * will match to any request.\n\t * @param produces expressions with syntax defined by {@link RequestMapping#produces()}\n\t * @param headers expressions with syntax defined by {@link RequestMapping#headers()}\n\t */\n\tpublic ProducesRequestCondition(String @Nullable [] produces, String @Nullable [] headers) {\n\t\tthis(produces, headers, null);\n\t}\n\n\t/**\n\t * Same as {@link #ProducesRequestCondition(String[], String[])} but also\n\t * accepting a {@link ContentNegotiationManager}.\n\t * @param produces expressions with syntax defined by {@link RequestMapping#produces()}\n\t * @param headers expressions with syntax defined by {@link RequestMapping#headers()}\n\t * @param manager used to determine requested media types\n\t */\n\tpublic ProducesRequestCondition(String @Nullable [] produces, String @Nullable [] headers,\n\t\t\t@Nullable ContentNegotiationManager manager) {\n\n\t\tthis.expressions = parseExpressions(produces, headers);\n\t\tif (this.expressions.size() > 1) {\n\t\t\tCollections.sort(this.expressions);\n\t\t}\n\t\tthis.contentNegotiationManager = (manager != null ? manager : DEFAULT_CONTENT_NEGOTIATION_MANAGER);\n\t}\n\n\tprivate List<ProduceMediaTypeExpression> parseExpressions(String @Nullable [] produces, String @Nullable [] headers) {\n\t\tSet<ProduceMediaTypeExpression> result = null;\n\t\tif (!ObjectUtils.isEmpty(headers)) {\n\t\t\tfor (String header : headers) {\n\t\t\t\tHeaderExpression expr = new HeaderExpression(header);\n\t\t\t\tif (\"Accept\".equalsIgnoreCase(expr.name) && expr.value != null) {\n\t\t\t\t\tfor (MediaType mediaType : MediaType.parseMediaTypes(expr.value)) {\n\t\t\t\t\t\tresult = (result != null ? result : new LinkedHashSet<>());\n\t\t\t\t\t\tresult.add(new ProduceMediaTypeExpression(mediaType, expr.isNegated));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ObjectUtils.isEmpty(produces)) {\n\t\t\tfor (String produce : produces) {\n\t\t\t\tresult = (result != null ? result : new LinkedHashSet<>());\n\t\t\t\tresult.add(new ProduceMediaTypeExpression(produce));\n\t\t\t}\n\t\t}\n\t\treturn (result != null ? new ArrayList<>(result) : Collections.emptyList());\n\t}\n\n\t/**\n\t * Private constructor for internal use to create matching conditions.\n\t * Note the expressions List is neither sorted nor deep copied.\n\t */\n\tprivate ProducesRequestCondition(List<ProduceMediaTypeExpression> expressions, ProducesRequestCondition other) {\n\t\tthis.expressions = expressions;\n\t\tthis.contentNegotiationManager = other.contentNegotiationManager;\n\t}\n\n\n\t/**\n\t * Return the contained \"produces\" expressions.\n\t */\n\tpublic Set<MediaTypeExpression> getExpressions() {\n\t\treturn new LinkedHashSet<>(this.expressions);\n\t}\n\n\t/**\n\t * Return the contained producible media types excluding negated expressions.\n\t */\n\tpublic Set<MediaType> getProducibleMediaTypes() {\n\t\tSet<MediaType> result = new LinkedHashSet<>();\n\t\tfor (ProduceMediaTypeExpression expression : this.expressions) {\n\t\t\tif (!expression.isNegated()) {\n\t\t\t\tresult.add(expression.getMediaType());\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Whether the condition has any media type expressions.\n\t */\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn this.expressions.isEmpty();\n\t}\n\n\t@Override\n\tprotected List<ProduceMediaTypeExpression> getContent() {\n\t\treturn this.expressions;\n\t}\n\n\t@Override\n\tprotected String getToStringInfix() {\n\t\treturn \" || \";\n\t}\n\n\t/**\n\t * Returns the \"other\" instance if it has any expressions; returns \"this\"\n\t * instance otherwise. Practically that means a method-level \"produces\"\n\t * overrides a type-level \"produces\" condition.\n\t */\n\t@Override\n\tpublic ProducesRequestCondition combine(ProducesRequestCondition other) {\n\t\treturn (!other.expressions.isEmpty() ? other : this);\n\t}\n\n\t/**\n\t * Checks if any of the contained media type expressions match the given\n\t * request 'Content-Type' header and returns an instance that is guaranteed\n\t * to contain matching expressions only. The match is performed via\n\t * {@link MediaType#isCompatibleWith(MediaType)}.\n\t * @param request the current request\n\t * @return the same instance if there are no expressions;\n\t * or a new condition with matching expressions;\n\t * or {@code null} if no expressions match.\n\t */\n\t@Override\n\tpublic @Nullable ProducesRequestCondition getMatchingCondition(HttpServletRequest request) {\n\t\tif (CorsUtils.isPreFlightRequest(request)) {\n\t\t\treturn EMPTY_CONDITION;\n\t\t}\n\t\tif (isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\t\tList<MediaType> acceptedMediaTypes;\n\t\ttry {\n\t\t\tacceptedMediaTypes = getAcceptedMediaTypes(request);\n\t\t}\n\t\tcatch (HttpMediaTypeException ex) {\n\t\t\treturn null;\n\t\t}\n\t\tList<ProduceMediaTypeExpression> result = getMatchingExpressions(acceptedMediaTypes);\n\t\tif (!CollectionUtils.isEmpty(result)) {\n\t\t\treturn new ProducesRequestCondition(result, this);\n\t\t}\n\t\telse if (MediaType.ALL.isPresentIn(acceptedMediaTypes)) {\n\t\t\treturn EMPTY_CONDITION;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate @Nullable List<ProduceMediaTypeExpression> getMatchingExpressions(List<MediaType> acceptedMediaTypes) {\n\t\tList<ProduceMediaTypeExpression> result = null;\n\t\tfor (ProduceMediaTypeExpression expression : this.expressions) {\n\t\t\tif (expression.match(acceptedMediaTypes)) {\n\t\t\t\tresult = result != null ? result : new ArrayList<>();\n\t\t\t\tresult.add(expression);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Compares this and another \"produces\" condition as follows:\n\t * <ol>\n\t * <li>Sort 'Accept' header media types by quality value via\n\t * {@link org.springframework.util.MimeTypeUtils#sortBySpecificity(List)}\n\t * and iterate the list.\n\t * <li>Get the first index of matching media types in each \"produces\"\n\t * condition first matching with {@link MediaType#equals(Object)} and\n\t * then with {@link MediaType#includes(MediaType)}.\n\t * <li>If a lower index is found, the condition at that index wins.\n\t * <li>If both indexes are equal, the media types at the index are\n\t * compared further with {@link MediaType#isMoreSpecific(MimeType)}.\n\t * </ol>\n\t * <p>It is assumed that both instances have been obtained via\n\t * {@link #getMatchingCondition(HttpServletRequest)} and each instance\n\t * contains the matching producible media type expression only or\n\t * is otherwise empty.\n\t */\n\t@Override\n\tpublic int compareTo(ProducesRequestCondition other, HttpServletRequest request) {\n\t\tif (this.expressions.isEmpty() && other.expressions.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\t\ttry {\n\t\t\tList<MediaType> acceptedMediaTypes = getAcceptedMediaTypes(request);\n\t\t\tfor (MediaType acceptedMediaType : acceptedMediaTypes) {\n\t\t\t\tint thisIndex = this.indexOfEqualMediaType(acceptedMediaType);\n\t\t\t\tint otherIndex = other.indexOfEqualMediaType(acceptedMediaType);\n\t\t\t\tint result = compareMatchingMediaTypes(this, thisIndex, other, otherIndex);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tthisIndex = this.indexOfIncludedMediaType(acceptedMediaType);\n\t\t\t\totherIndex = other.indexOfIncludedMediaType(acceptedMediaType);\n\t\t\t\tresult = compareMatchingMediaTypes(this, thisIndex, other, otherIndex);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tcatch (HttpMediaTypeNotAcceptableException ex) {\n\t\t\t// should never happen\n\t\t\tthrow new IllegalStateException(\"Cannot compare without having any requested media types\", ex);\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate List<MediaType> getAcceptedMediaTypes(HttpServletRequest request)\n\t\t\tthrows HttpMediaTypeNotAcceptableException {\n\n\t\tList<MediaType> result = (List<MediaType>) request.getAttribute(MEDIA_TYPES_ATTRIBUTE);\n\t\tif (result == null) {\n\t\t\tresult = this.contentNegotiationManager.resolveMediaTypes(new ServletWebRequest(request));\n\t\t\trequest.setAttribute(MEDIA_TYPES_ATTRIBUTE, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate int indexOfEqualMediaType(MediaType mediaType) {\n\t\tfor (int i = 0; i < getExpressionsToCompare().size(); i++) {\n\t\t\tMediaType currentMediaType = getExpressionsToCompare().get(i).getMediaType();\n\t\t\tif (mediaType.getType().equalsIgnoreCase(currentMediaType.getType()) &&\n\t\t\t\t\tmediaType.getSubtype().equalsIgnoreCase(currentMediaType.getSubtype())) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate int indexOfIncludedMediaType(MediaType mediaType) {\n\t\tfor (int i = 0; i < getExpressionsToCompare().size(); i++) {\n\t\t\tif (mediaType.includes(getExpressionsToCompare().get(i).getMediaType())) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate int compareMatchingMediaTypes(ProducesRequestCondition condition1, int index1,\n\t\t\tProducesRequestCondition condition2, int index2) {\n\n\t\tint result = 0;\n\t\tif (index1 != index2) {\n\t\t\tresult = index2 - index1;\n\t\t}\n\t\telse if (index1 != -1) {\n\t\t\tProduceMediaTypeExpression expr1 = condition1.getExpressionsToCompare().get(index1);\n\t\t\tProduceMediaTypeExpression expr2 = condition2.getExpressionsToCompare().get(index2);\n\t\t\tresult = expr1.compareTo(expr2);\n\t\t\tresult = (result != 0) ? result : expr1.getMediaType().compareTo(expr2.getMediaType());\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Return the contained \"produces\" expressions or if that's empty, a list\n\t * with a {@value MediaType#ALL_VALUE} expression.\n\t */\n\tprivate List<ProduceMediaTypeExpression> getExpressionsToCompare() {\n\t\treturn (this.expressions.isEmpty() ? MEDIA_TYPE_ALL_LIST : this.expressions);\n\t}\n\n\n\t/**\n\t * Use this to clear {@link #MEDIA_TYPES_ATTRIBUTE} that contains the parsed,\n\t * requested media types.\n\t * @param request the current request\n\t * @since 5.2\n\t */\n\tpublic static void clearMediaTypesAttribute(HttpServletRequest request) {\n\t\trequest.removeAttribute(MEDIA_TYPES_ATTRIBUTE);\n\t}\n\n\n\t/**\n\t * Parses and matches a single media type expression to a request's 'Accept' header.\n\t */\n\tstatic class ProduceMediaTypeExpression extends AbstractMediaTypeExpression {\n\n\t\tProduceMediaTypeExpression(MediaType mediaType, boolean negated) {\n\t\t\tsuper(mediaType, negated);\n\t\t}\n\n\t\tProduceMediaTypeExpression(String expression) {\n\t\t\tsuper(expression);\n\t\t}\n\n\t\tpublic final boolean match(List<MediaType> acceptedMediaTypes) {\n\t\t\tboolean match = matchMediaType(acceptedMediaTypes);\n\t\t\treturn !isNegated() == match;\n\t\t}\n\n\t\tprivate boolean matchMediaType(List<MediaType> acceptedMediaTypes) {\n\t\t\tfor (MediaType acceptedMediaType : acceptedMediaTypes) {\n\t\t\t\tif (getMediaType().isCompatibleWith(acceptedMediaType) && matchParameters(acceptedMediaType)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.servlet.mvc.condition.ProducesRequestCondition#clearMediaTypesAttribute(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Use this to clear {@link #MEDIA_TYPES_ATTRIBUTE} that contains the parsed,\n\t * requested media types.\n\t * @param request the current request\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "void",
    "signature": "public void clearMediaTypesAttribute(HttpServletRequest request)",
    "source_code": "\tpublic static void clearMediaTypesAttribute(HttpServletRequest request) {\n\t\trequest.removeAttribute(MEDIA_TYPES_ATTRIBUTE);\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ProducesRequestCondition#combine(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the \"other\" instance if it has any expressions; returns \"this\"\n\t * instance otherwise. Practically that means a method-level \"produces\"\n\t * overrides a type-level \"produces\" condition.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "ProducesRequestCondition",
    "signature": "public ProducesRequestCondition combine(ProducesRequestCondition other)",
    "source_code": "\tpublic ProducesRequestCondition combine(ProducesRequestCondition other) {\n\t\treturn (!other.expressions.isEmpty() ? other : this);\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ProducesRequestCondition#compareTo(other,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Compares this and another \"produces\" condition as follows:\n\t * <ol>\n\t * <li>Sort 'Accept' header media types by quality value via\n\t * {@link org.springframework.util.MimeTypeUtils#sortBySpecificity(List)}\n\t * and iterate the list.\n\t * <li>Get the first index of matching media types in each \"produces\"\n\t * condition first matching with {@link MediaType#equals(Object)} and\n\t * then with {@link MediaType#includes(MediaType)}.\n\t * <li>If a lower index is found, the condition at that index wins.\n\t * <li>If both indexes are equal, the media types at the index are\n\t * compared further with {@link MediaType#isMoreSpecific(MimeType)}.\n\t * </ol>\n\t * <p>It is assumed that both instances have been obtained via\n\t * {@link #getMatchingCondition(HttpServletRequest)} and each instance\n\t * contains the matching producible media type expression only or\n\t * is otherwise empty.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "int",
    "signature": "public int compareTo(ProducesRequestCondition other, HttpServletRequest request)",
    "source_code": "\tpublic int compareTo(ProducesRequestCondition other, HttpServletRequest request) {\n\t\tif (this.expressions.isEmpty() && other.expressions.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\t\ttry {\n\t\t\tList<MediaType> acceptedMediaTypes = getAcceptedMediaTypes(request);\n\t\t\tfor (MediaType acceptedMediaType : acceptedMediaTypes) {\n\t\t\t\tint thisIndex = this.indexOfEqualMediaType(acceptedMediaType);\n\t\t\t\tint otherIndex = other.indexOfEqualMediaType(acceptedMediaType);\n\t\t\t\tint result = compareMatchingMediaTypes(this, thisIndex, other, otherIndex);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tthisIndex = this.indexOfIncludedMediaType(acceptedMediaType);\n\t\t\t\totherIndex = other.indexOfIncludedMediaType(acceptedMediaType);\n\t\t\t\tresult = compareMatchingMediaTypes(this, thisIndex, other, otherIndex);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tcatch (HttpMediaTypeNotAcceptableException ex) {\n\t\t\t// should never happen\n\t\t\tthrow new IllegalStateException(\"Cannot compare without having any requested media types\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ProducesRequestCondition#getContent()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "List<ProduceMediaTypeExpression>",
    "signature": "protected List<ProduceMediaTypeExpression> getContent()",
    "source_code": "\tprotected List<ProduceMediaTypeExpression> getContent() {\n\t\treturn this.expressions;\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ProducesRequestCondition#getExpressions()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the contained \"produces\" expressions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "Set<MediaTypeExpression>",
    "signature": "public Set<MediaTypeExpression> getExpressions()",
    "source_code": "\tpublic Set<MediaTypeExpression> getExpressions() {\n\t\treturn new LinkedHashSet<>(this.expressions);\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ProducesRequestCondition#getMatchingCondition(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Checks if any of the contained media type expressions match the given\n\t * request 'Content-Type' header and returns an instance that is guaranteed\n\t * to contain matching expressions only. The match is performed via\n\t * {@link MediaType#isCompatibleWith(MediaType)}.\n\t * @param request the current request\n\t * @return the same instance if there are no expressions;\n\t * or a new condition with matching expressions;\n\t * or {@code null} if no expressions match.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "ProducesRequestCondition",
    "signature": "public ProducesRequestCondition getMatchingCondition(HttpServletRequest request)",
    "source_code": "\tpublic @Nullable ProducesRequestCondition getMatchingCondition(HttpServletRequest request) {\n\t\tif (CorsUtils.isPreFlightRequest(request)) {\n\t\t\treturn EMPTY_CONDITION;\n\t\t}\n\t\tif (isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\t\tList<MediaType> acceptedMediaTypes;\n\t\ttry {\n\t\t\tacceptedMediaTypes = getAcceptedMediaTypes(request);\n\t\t}\n\t\tcatch (HttpMediaTypeException ex) {\n\t\t\treturn null;\n\t\t}\n\t\tList<ProduceMediaTypeExpression> result = getMatchingExpressions(acceptedMediaTypes);\n\t\tif (!CollectionUtils.isEmpty(result)) {\n\t\t\treturn new ProducesRequestCondition(result, this);\n\t\t}\n\t\telse if (MediaType.ALL.isPresentIn(acceptedMediaTypes)) {\n\t\t\treturn EMPTY_CONDITION;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ProducesRequestCondition#getProducibleMediaTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the contained producible media types excluding negated expressions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "Set<MediaType>",
    "signature": "public Set<MediaType> getProducibleMediaTypes()",
    "source_code": "\tpublic Set<MediaType> getProducibleMediaTypes() {\n\t\tSet<MediaType> result = new LinkedHashSet<>();\n\t\tfor (ProduceMediaTypeExpression expression : this.expressions) {\n\t\t\tif (!expression.isNegated()) {\n\t\t\t\tresult.add(expression.getMediaType());\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ProducesRequestCondition#getToStringInfix()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "String",
    "signature": "protected String getToStringInfix()",
    "source_code": "\tprotected String getToStringInfix() {\n\t\treturn \" || \";\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ProducesRequestCondition#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the condition has any media type expressions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn this.expressions.isEmpty();\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.ProducesRequestCondition#match(acceptedMediaTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptedMediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "boolean",
    "signature": "public boolean match(List<MediaType> acceptedMediaTypes)",
    "source_code": "\t\tpublic final boolean match(List<MediaType> acceptedMediaTypes) {\n\t\t\tboolean match = matchMediaType(acceptedMediaTypes);\n\t\t\treturn !isNegated() == match;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter#getLastModified(request,handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation expects the handler to be an {@link HandlerMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic final long getLastModified(HttpServletRequest request, Object handler) {\n\t\treturn getLastModifiedInternal(request, (HandlerMethod) handler);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter#getLastModifiedInternal(request,handlerMethod)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Same contract as for {@link jakarta.servlet.http.HttpServlet#getLastModified(HttpServletRequest)}.\n\t * @param request current HTTP request\n\t * @param handlerMethod handler method to use\n\t * @return the lastModified value for the given handler\n\t * @deprecated as of 5.3.9 along with\n\t * {@link org.springframework.web.servlet.mvc.LastModified}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "long",
    "signature": "protected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod)",
    "source_code": "\tprotected abstract long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod);"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfo#getFileExtensions()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return the file extensions to use for suffix pattern matching. If\n\t\t * {@code registeredSuffixPatternMatch=true}, the extensions are obtained\n\t\t * from the configured {@code contentNegotiationManager}.\n\t\t * @deprecated as of 5.2.4. See class-level note in\n\t\t * {@link RequestMappingHandlerMapping} on the deprecation of path\n\t\t * extension config options.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1058
    },
    "return": "List<String>",
    "signature": "public List<String> getFileExtensions()",
    "source_code": "\t\tpublic List<String> getFileExtensions() {\n\t\t\tif (useRegisteredSuffixPatternMatch() && this.contentNegotiationManager != null) {\n\t\t\t\treturn this.contentNegotiationManager.getAllFileExtensions();\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfo#setRegisteredSuffixPatternMatch(registeredSuffixPatternMatch)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Set whether suffix pattern matching should be restricted to registered\n\t\t * file extensions only. Setting this property also sets\n\t\t * {@code suffixPatternMatch=true} and requires that a\n\t\t * {@link #setContentNegotiationManager} is also configured in order to\n\t\t * obtain the registered file extensions.\n\t\t * @deprecated as of 5.2.4. See class-level note in\n\t\t * {@link RequestMappingHandlerMapping} on the deprecation of path\n\t\t * extension config options.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredSuffixPatternMatch"
    ],
    "position": {
      "column": 1,
      "line": 1031
    },
    "return": "void",
    "signature": "public void setRegisteredSuffixPatternMatch(boolean registeredSuffixPatternMatch)",
    "source_code": "\t\tpublic void setRegisteredSuffixPatternMatch(boolean registeredSuffixPatternMatch) {\n\t\t\tthis.registeredSuffixPatternMatch = registeredSuffixPatternMatch;\n\t\t\tthis.suffixPatternMatch = (registeredSuffixPatternMatch || this.suffixPatternMatch);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfo#setSuffixPatternMatch(suffixPatternMatch)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Set whether to apply suffix pattern matching in PatternsRequestCondition.\n\t\t * <p>By default this is set to 'false'.\n\t\t * @see #setRegisteredSuffixPatternMatch(boolean)\n\t\t * @deprecated as of 5.2.4. See deprecation note on\n\t\t * {@link RequestMappingHandlerMapping#setUseSuffixPatternMatch(boolean)}.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "suffixPatternMatch"
    ],
    "position": {
      "column": 1,
      "line": 1006
    },
    "return": "void",
    "signature": "public void setSuffixPatternMatch(boolean suffixPatternMatch)",
    "source_code": "\t\tpublic void setSuffixPatternMatch(boolean suffixPatternMatch) {\n\t\t\tthis.suffixPatternMatch = suffixPatternMatch;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfo#setTrailingSlashMatch(trailingSlashMatch)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Set whether to apply trailing slash matching in PatternsRequestCondition.\n\t\t * <p>The default was changed in 6.0 from {@code true} to {@code false} in\n\t\t * order to support the deprecation of the property.\n\t\t * @deprecated as of 6.0, see\n\t\t * {@link PathPatternParser#setMatchOptionalTrailingSeparator(boolean)}\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "trailingSlashMatch"
    ],
    "position": {
      "column": 1,
      "line": 985
    },
    "return": "void",
    "signature": "public void setTrailingSlashMatch(boolean trailingSlashMatch)",
    "source_code": "\t\tpublic void setTrailingSlashMatch(boolean trailingSlashMatch) {\n\t\t\tthis.trailingSlashMatch = trailingSlashMatch;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfo#useRegisteredSuffixPatternMatch()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return whether suffix pattern matching should be restricted to registered\n\t\t * file extensions only.\n\t\t * @deprecated as of 5.2.4. See class-level note in\n\t\t * {@link RequestMappingHandlerMapping} on the deprecation of path\n\t\t * extension config options.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1044
    },
    "return": "boolean",
    "signature": "public boolean useRegisteredSuffixPatternMatch()",
    "source_code": "\t\tpublic boolean useRegisteredSuffixPatternMatch() {\n\t\t\treturn this.registeredSuffixPatternMatch;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfo#useSuffixPatternMatch()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return whether to apply suffix pattern matching in PatternsRequestCondition.\n\t\t * @deprecated as of 5.2.4. See deprecation note on\n\t\t * {@link RequestMappingHandlerMapping#setUseSuffixPatternMatch(boolean)}.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1016
    },
    "return": "boolean",
    "signature": "public boolean useSuffixPatternMatch()",
    "source_code": "\t\tpublic boolean useSuffixPatternMatch() {\n\t\t\treturn this.suffixPatternMatch;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfo#useTrailingSlashMatch()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return whether to apply trailing slash matching in PatternsRequestCondition.\n\t\t * @deprecated as of 6.0 together with {@link #setTrailingSlashMatch(boolean)}\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 994
    },
    "return": "boolean",
    "signature": "public boolean useTrailingSlashMatch()",
    "source_code": "\t\tpublic boolean useTrailingSlashMatch() {\n\t\t\treturn this.trailingSlashMatch;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping#getMappingPathPatterns(info)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the URL path patterns associated with the supplied {@link RequestMappingInfo}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "info"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "Set<String>",
    "signature": "protected Set<String> getMappingPathPatterns(RequestMappingInfo info)",
    "source_code": "\tprotected Set<String> getMappingPathPatterns(RequestMappingInfo info) {\n\t\treturn info.getPatternValues();\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.DeferredResultMethodReturnValueHandler#onFailure(ex)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void onFailure(Throwable ex)",
    "source_code": "\t\t\tpublic void onFailure(Throwable ex) {\n\t\t\t\tresult.setErrorResult(ex);\n\t\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.DeferredResultMethodReturnValueHandler#onSuccess(value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void onSuccess(@Nullable Object value)",
    "source_code": "\t\t\tpublic void onSuccess(@Nullable Object value) {\n\t\t\t\tresult.setResult(value);\n\t\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ModelAndViewMethodReturnValueHandler#getRedirectPatterns()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured redirect patterns, if any.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "String[]",
    "signature": "public String[] getRedirectPatterns()",
    "source_code": "\tpublic String[] getRedirectPatterns() {\n\t\treturn this.redirectPatterns;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#getLastModifiedInternal(request,handlerMethod)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation always returns -1. An {@code @RequestMapping} method can\n\t * calculate the lastModified value, call {@link WebRequest#checkNotModified(long)},\n\t * and return {@code null} if the result of that call is {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 913
    },
    "return": "long",
    "signature": "protected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod)",
    "source_code": "\tprotected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod) {\n\t\treturn -1;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#setIgnoreDefaultModelOnRedirect(ignoreDefaultModelOnRedirect)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * By default, the content of the \"default\" model is used both during\n\t * rendering and redirect scenarios. Alternatively a controller method\n\t * can declare a {@link RedirectAttributes} argument and use it to provide\n\t * attributes for a redirect.\n\t * <p>Setting this flag to {@code true} guarantees the \"default\" model is\n\t * never used in a redirect scenario even if a RedirectAttributes argument\n\t * is not declared. Setting it to {@code false} means the \"default\" model\n\t * may be used in a redirect if the controller method doesn't declare a\n\t * RedirectAttributes argument.\n\t * <p>As of 6.0, this property is set to {@code true} by default.\n\t * @see RedirectAttributes\n\t * @deprecated as of 6.0 without a replacement; once removed, the default\n\t * model will always be ignored on redirect\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ignoreDefaultModelOnRedirect"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "void",
    "signature": "public void setIgnoreDefaultModelOnRedirect(boolean ignoreDefaultModelOnRedirect)",
    "source_code": "\tpublic void setIgnoreDefaultModelOnRedirect(boolean ignoreDefaultModelOnRedirect) {\n\t\tthis.ignoreDefaultModelOnRedirect = ignoreDefaultModelOnRedirect;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#getFileExtensions()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the file extensions to use for suffix pattern matching.\n\t * @deprecated as of 5.2.4. See class-level note on the deprecation of path\n\t * extension config options.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 278
    },
    "return": "List<String>",
    "signature": "public List<String> getFileExtensions()",
    "source_code": "\tpublic List<String> getFileExtensions() {\n\t\treturn this.config.getFileExtensions();\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#setPatternParser(patternParser)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "patternParser"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void setPatternParser(@Nullable PathPatternParser patternParser)",
    "source_code": "\tpublic void setPatternParser(@Nullable PathPatternParser patternParser) {\n\t\tif (patternParser != null) {\n\t\t\tthis.defaultPatternParser = false;\n\t\t}\n\t\tsuper.setPatternParser(patternParser);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#setUseRegisteredSuffixPatternMatch(useRegisteredSuffixPatternMatch)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether suffix pattern matching should work only against path extensions\n\t * explicitly registered with the {@link ContentNegotiationManager}. This\n\t * is generally recommended to reduce ambiguity and to avoid issues such as\n\t * when a \".\" appears in the path for other reasons.\n\t * <p>By default this is set to \"false\".\n\t * <p><strong>Note:</strong> This property is ignored when\n\t * {@link #setPatternParser(PathPatternParser)} is configured.\n\t * @deprecated as of 5.2.4. See class level note on the deprecation of\n\t * path extension config options.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "useRegisteredSuffixPatternMatch"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void setUseRegisteredSuffixPatternMatch(boolean useRegisteredSuffixPatternMatch)",
    "source_code": "\tpublic void setUseRegisteredSuffixPatternMatch(boolean useRegisteredSuffixPatternMatch) {\n\t\tthis.useRegisteredSuffixPatternMatch = useRegisteredSuffixPatternMatch;\n\t\tthis.useSuffixPatternMatch = (useRegisteredSuffixPatternMatch || this.useSuffixPatternMatch);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#setUseSuffixPatternMatch(useSuffixPatternMatch)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to use suffix pattern match (\".*\") when matching patterns to\n\t * requests. If enabled a method mapped to \"/users\" also matches to \"/users.*\".\n\t * <p>By default value this is set to {@code false}.\n\t * <p>Also see {@link #setUseRegisteredSuffixPatternMatch(boolean)} for\n\t * more fine-grained control over specific suffixes to allow.\n\t * <p><strong>Note:</strong> This property is ignored when\n\t * {@link #setPatternParser(PathPatternParser)} is configured.\n\t * @deprecated as of 5.2.4. See class level note on the deprecation of\n\t * path extension config options. As there is no replacement for this method,\n\t * in 5.2.x it is necessary to set it to {@code false}. In 5.3 the default\n\t * changes to {@code false} and use of this property becomes unnecessary.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "useSuffixPatternMatch"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void setUseSuffixPatternMatch(boolean useSuffixPatternMatch)",
    "source_code": "\tpublic void setUseSuffixPatternMatch(boolean useSuffixPatternMatch) {\n\t\tthis.useSuffixPatternMatch = useSuffixPatternMatch;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#setUseTrailingSlashMatch(useTrailingSlashMatch)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to match to URLs irrespective of the presence of a trailing slash.\n\t * If enabled a method mapped to \"/users\" also matches to \"/users/\".\n\t * <p>The default was changed in 6.0 from {@code true} to {@code false} in\n\t * order to support the deprecation of the property.\n\t * @deprecated as of 6.0, see\n\t * {@link PathPatternParser#setMatchOptionalTrailingSeparator(boolean)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "useTrailingSlashMatch"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch)",
    "source_code": "\tpublic void setUseTrailingSlashMatch(boolean useTrailingSlashMatch) {\n\t\tthis.useTrailingSlashMatch = useTrailingSlashMatch;\n\t\tif (getPatternParser() != null) {\n\t\t\tgetPatternParser().setMatchOptionalTrailingSeparator(useTrailingSlashMatch);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#useRegisteredSuffixPatternMatch()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to use registered suffixes for pattern matching.\n\t * @deprecated as of 5.2.4. See deprecation notice on\n\t * {@link #setUseRegisteredSuffixPatternMatch(boolean)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "boolean",
    "signature": "public boolean useRegisteredSuffixPatternMatch()",
    "source_code": "\tpublic boolean useRegisteredSuffixPatternMatch() {\n\t\treturn this.useRegisteredSuffixPatternMatch;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#useSuffixPatternMatch()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to use registered suffixes for pattern matching.\n\t * @deprecated as of 5.2.4. See deprecation notice on\n\t * {@link #setUseSuffixPatternMatch(boolean)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "boolean",
    "signature": "public boolean useSuffixPatternMatch()",
    "source_code": "\tpublic boolean useSuffixPatternMatch() {\n\t\treturn this.useSuffixPatternMatch;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#useTrailingSlashMatch()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to match to URLs irrespective of the presence of a trailing slash.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "boolean",
    "signature": "public boolean useTrailingSlashMatch()",
    "source_code": "\tpublic boolean useTrailingSlashMatch() {\n\t\treturn this.useTrailingSlashMatch;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ViewNameMethodReturnValueHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Handles return values of types {@code void} and {@code String} interpreting them\n * as view name reference. As of 4.2, it also handles general {@code CharSequence}\n * types, for example, {@code StringBuilder} or Groovy's {@code GString}, as view names.\n *\n * <p>A {@code null} return value, either due to a {@code void} return type or\n * as the actual return value is left as-is allowing the configured\n * {@link RequestToViewNameTranslator} to select a view name by convention.\n *\n * <p>A String return value can be interpreted in more than one way depending on\n * the presence of annotations like {@code @ModelAttribute} or {@code @ResponseBody}.\n * Therefore, this handler should be configured after the handlers that support these\n * annotations.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class ViewNameMethodReturnValueHandler",
    "source_code": "public class ViewNameMethodReturnValueHandler implements HandlerMethodReturnValueHandler {\n\n\tprivate String @Nullable [] redirectPatterns;\n\n\n\t/**\n\t * Configure one more simple patterns (as described in {@link PatternMatchUtils#simpleMatch})\n\t * to use in order to recognize custom redirect prefixes in addition to \"redirect:\".\n\t * <p>Note that simply configuring this property will not make a custom redirect prefix work.\n\t * There must be a custom View that recognizes the prefix as well.\n\t * @since 4.1\n\t */\n\tpublic void setRedirectPatterns(String @Nullable ... redirectPatterns) {\n\t\tthis.redirectPatterns = redirectPatterns;\n\t}\n\n\t/**\n\t * The configured redirect patterns, if any.\n\t */\n\tpublic String @Nullable [] getRedirectPatterns() {\n\t\treturn this.redirectPatterns;\n\t}\n\n\n\t@Override\n\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\tClass<?> paramType = returnType.getParameterType();\n\t\treturn (void.class == paramType || CharSequence.class.isAssignableFrom(paramType));\n\t}\n\n\t@Override\n\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (returnValue instanceof CharSequence) {\n\t\t\tString viewName = returnValue.toString();\n\t\t\tmavContainer.setViewName(viewName);\n\t\t\tif (isRedirectViewName(viewName)) {\n\t\t\t\tmavContainer.setRedirectModelScenario(true);\n\t\t\t}\n\t\t}\n\t\telse if (returnValue != null) {\n\t\t\t// should not happen\n\t\t\tthrow new UnsupportedOperationException(\"Unexpected return type: \" +\n\t\t\t\t\treturnType.getParameterType().getName() + \" in method: \" + returnType.getMethod());\n\t\t}\n\t}\n\n\t/**\n\t * Whether the given view name is a redirect view reference.\n\t * The default implementation checks the configured redirect patterns and\n\t * also if the view name starts with the \"redirect:\" prefix.\n\t * @param viewName the view name to check, never {@code null}\n\t * @return \"true\" if the given view name is recognized as a redirect view\n\t * reference; \"false\" otherwise.\n\t */\n\tprotected boolean isRedirectViewName(String viewName) {\n\t\treturn (PatternMatchUtils.simpleMatch(this.redirectPatterns, viewName) || viewName.startsWith(\"redirect:\"));\n\t}\n\n}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ViewNameMethodReturnValueHandler#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ViewNameMethodReturnValueHandler#isRedirectViewName(viewName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the given view name is a redirect view reference.\n\t * The default implementation checks the configured redirect patterns and\n\t * also if the view name starts with the \"redirect:\" prefix.\n\t * @param viewName the view name to check, never {@code null}\n\t * @return \"true\" if the given view name is recognized as a redirect view\n\t * reference; \"false\" otherwise.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "boolean",
    "signature": "protected boolean isRedirectViewName(String viewName)",
    "source_code": "\tprotected boolean isRedirectViewName(String viewName) {\n\t\treturn (PatternMatchUtils.simpleMatch(this.redirectPatterns, viewName) || viewName.startsWith(\"redirect:\"));\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ViewNameMethodReturnValueHandler#setRedirectPatterns(redirectPatterns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure one more simple patterns (as described in {@link PatternMatchUtils#simpleMatch})\n\t * to use in order to recognize custom redirect prefixes in addition to \"redirect:\".\n\t * <p>Note that simply configuring this property will not make a custom redirect prefix work.\n\t * There must be a custom View that recognizes the prefix as well.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "redirectPatterns"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "void",
    "signature": "public void setRedirectPatterns(String @Nullable ... redirectPatterns)",
    "source_code": "\tpublic void setRedirectPatterns(String @Nullable ... redirectPatterns) {\n\t\tthis.redirectPatterns = redirectPatterns;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ViewNameMethodReturnValueHandler#supportsReturnType(returnType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "boolean",
    "signature": "public boolean supportsReturnType(MethodParameter returnType)",
    "source_code": "\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\tClass<?> paramType = returnType.getParameterType();\n\t\treturn (void.class == paramType || CharSequence.class.isAssignableFrom(paramType));\n\t}"
  },
  "org.springframework.web.servlet.resource.PathResourceResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A simple {@code ResourceResolver} that tries to find a resource under the given\n * locations matching to the request path.\n *\n * <p>This resolver does not delegate to the {@code ResourceResolverChain} and is\n * expected to be configured at the end in a chain of resolvers.\n *\n * @author Jeremy Grelle\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 4.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public class PathResourceResolver",
    "source_code": "public class PathResourceResolver extends AbstractResourceResolver {\n\n\tprivate Resource @Nullable [] allowedLocations;\n\n\tprivate final Map<Resource, Charset> locationCharsets = new HashMap<>(4);\n\n\tprivate @Nullable UrlPathHelper urlPathHelper;\n\n\n\t/**\n\t * By default, when a Resource is found, the path of the resolved resource is\n\t * compared to ensure it's under the input location where it was found.\n\t * However sometimes that may not be the case, for example, when\n\t * {@link org.springframework.web.servlet.resource.CssLinkResourceTransformer}\n\t * resolves public URLs of links it contains, the CSS file is the location\n\t * and the resources being resolved are css files, images, fonts and others\n\t * located in adjacent or parent directories.\n\t * <p>This property allows configuring a complete list of locations under\n\t * which resources must be so that if a resource is not under the location\n\t * relative to which it was found, this list may be checked as well.\n\t * <p>By default {@link ResourceHttpRequestHandler} initializes this property\n\t * to match its list of locations.\n\t * @param locations the list of allowed locations\n\t * @since 4.1.2\n\t * @see ResourceHttpRequestHandler#initAllowedLocations()\n\t */\n\tpublic void setAllowedLocations(Resource @Nullable ... locations) {\n\t\tthis.allowedLocations = locations;\n\t}\n\n\tpublic Resource @Nullable [] getAllowedLocations() {\n\t\treturn this.allowedLocations;\n\t}\n\n\t/**\n\t * Configure charsets associated with locations. If a static resource is found\n\t * under a {@link org.springframework.core.io.UrlResource URL resource}\n\t * location the charset is used to encode the relative path\n\t * <p><strong>Note:</strong> the charset is used only if the\n\t * {@link #setUrlPathHelper urlPathHelper} property is also configured and\n\t * its {@code urlDecode} property is set to true.\n\t * @since 4.3.13\n\t */\n\tpublic void setLocationCharsets(Map<Resource, Charset> locationCharsets) {\n\t\tthis.locationCharsets.clear();\n\t\tthis.locationCharsets.putAll(locationCharsets);\n\t}\n\n\t/**\n\t * Return charsets associated with static resource locations.\n\t * @since 4.3.13\n\t */\n\tpublic Map<Resource, Charset> getLocationCharsets() {\n\t\treturn Collections.unmodifiableMap(this.locationCharsets);\n\t}\n\n\t/**\n\t * Provide a reference to the {@link UrlPathHelper} used to map requests to\n\t * static resources. This helps to derive information about the lookup path\n\t * such as whether it is decoded or not.\n\t * @since 4.3.13\n\t * @deprecated use of {@link PathMatcher} and {@link UrlPathHelper} is deprecated\n\t * for use at runtime in web modules in favor of parsed patterns with\n\t * {@link PathPatternParser}.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic void setUrlPathHelper(@Nullable UrlPathHelper urlPathHelper) {\n\t\tthis.urlPathHelper = urlPathHelper;\n\t}\n\n\t/**\n\t * The configured {@link UrlPathHelper}.\n\t * @since 4.3.13\n\t * @deprecated use of {@link PathMatcher} and {@link UrlPathHelper} is deprecated\n\t * for use at runtime in web modules in favor of parsed patterns with\n\t * {@link PathPatternParser}.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic @Nullable UrlPathHelper getUrlPathHelper() {\n\t\treturn this.urlPathHelper;\n\t}\n\n\n\t@Override\n\tprotected @Nullable Resource resolveResourceInternal(@Nullable HttpServletRequest request, String requestPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\treturn getResource(requestPath, request, locations);\n\t}\n\n\t@Override\n\tprotected @Nullable String resolveUrlPathInternal(String resourcePath, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain) {\n\n\t\treturn (StringUtils.hasText(resourcePath) &&\n\t\t\t\tgetResource(resourcePath, null, locations) != null ? resourcePath : null);\n\t}\n\n\tprivate @Nullable Resource getResource(String resourcePath, @Nullable HttpServletRequest request,\n\t\t\tList<? extends Resource> locations) {\n\n\t\tfor (Resource location : locations) {\n\t\t\ttry {\n\t\t\t\tString pathToUse = encodeOrDecodeIfNecessary(resourcePath, request, location);\n\t\t\t\tResource resource = getResource(pathToUse, location);\n\t\t\t\tif (resource != null) {\n\t\t\t\t\treturn resource;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tString error = \"Skip location [\" + location + \"] due to error\";\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(error, ex);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlogger.debug(error + \": \" + ex.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Find the resource under the given location.\n\t * <p>The default implementation checks if there is a readable\n\t * {@code Resource} for the given path relative to the location.\n\t * @param resourcePath the path to the resource\n\t * @param location the location to check\n\t * @return the resource, or {@code null} if none found\n\t */\n\tprotected @Nullable Resource getResource(String resourcePath, Resource location) throws IOException {\n\t\tResource resource = location.createRelative(resourcePath);\n\t\tif (resource.isReadable()) {\n\t\t\tif (checkResource(resource, location)) {\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\tResource[] allowed = getAllowedLocations();\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Resource path \\\"\" + resourcePath + \"\\\" was successfully resolved \" +\n\t\t\t\t\t\t\t\t\"but resource \\\"\" + resource + \"\\\" is neither under \" +\n\t\t\t\t\t\t\t\t\"the current location \\\"\" + location + \"\\\" nor under any of \" +\n\t\t\t\t\t\t\t\t\"the allowed locations \" + (allowed != null ? Arrays.asList(allowed) : \"[]\"), -1, true));\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Perform additional checks on a resolved resource beyond checking whether the\n\t * resource exists and is readable. The default implementation also verifies\n\t * the resource is either under the location relative to which it was found or\n\t * is under one of the {@linkplain #setAllowedLocations allowed locations}.\n\t * @param resource the resource to check\n\t * @param location the location relative to which the resource was found\n\t * @return \"true\" if resource is in a valid location, \"false\" otherwise\n\t * @since 4.1.2\n\t */\n\tprotected boolean checkResource(Resource resource, Resource location) throws IOException {\n\t\tif (ResourceHandlerUtils.isResourceUnderLocation(location, resource)) {\n\t\t\treturn true;\n\t\t}\n\t\tResource[] allowedLocations = getAllowedLocations();\n\t\tif (allowedLocations != null) {\n\t\t\tfor (Resource current : allowedLocations) {\n\t\t\t\tif (ResourceHandlerUtils.isResourceUnderLocation(current, resource)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate String encodeOrDecodeIfNecessary(String path, @Nullable HttpServletRequest request, Resource location) {\n\t\tif (request != null) {\n\t\t\tboolean usesPathPattern = (\n\t\t\t\t\tServletRequestPathUtils.hasCachedPath(request) &&\n\t\t\t\t\tServletRequestPathUtils.getCachedPath(request) instanceof PathContainer);\n\n\t\t\tif (shouldDecodeRelativePath(location, usesPathPattern)) {\n\t\t\t\treturn UriUtils.decode(path, StandardCharsets.UTF_8);\n\t\t\t}\n\t\t\telse if (shouldEncodeRelativePath(location, usesPathPattern)) {\n\t\t\t\tCharset charset = this.locationCharsets.getOrDefault(location, StandardCharsets.UTF_8);\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tStringTokenizer tokenizer = new StringTokenizer(path, \"/\");\n\t\t\t\twhile (tokenizer.hasMoreTokens()) {\n\t\t\t\t\tString value = UriUtils.encode(tokenizer.nextToken(), charset);\n\t\t\t\t\tsb.append(value);\n\t\t\t\t\tsb.append('/');\n\t\t\t\t}\n\t\t\t\tif (!path.endsWith(\"/\")) {\n\t\t\t\t\tsb.setLength(sb.length() - 1);\n\t\t\t\t}\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t}\n\t\treturn path;\n\t}\n\n\t/**\n\t * When the {@code HandlerMapping} is set to not decode the URL path, the\n\t * path needs to be decoded for non-{@code UrlResource} locations.\n\t */\n\tprivate boolean shouldDecodeRelativePath(Resource location, boolean usesPathPattern) {\n\t\treturn (!(location instanceof UrlResource) &&\n\t\t\t\t(usesPathPattern || (this.urlPathHelper != null && !this.urlPathHelper.isUrlDecode())));\n\t}\n\n\t/**\n\t * When the {@code HandlerMapping} is set to decode the URL path, the path\n\t * needs to be encoded for {@code UrlResource} locations.\n\t */\n\tprivate boolean shouldEncodeRelativePath(Resource location, boolean usesPathPattern) {\n\t\treturn (location instanceof UrlResource && !usesPathPattern &&\n\t\t\t\tthis.urlPathHelper != null && this.urlPathHelper.isUrlDecode());\n\t}\n\n}"
  },
  "org.springframework.web.servlet.resource.PathResourceResolver#checkResource(resource,location)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform additional checks on a resolved resource beyond checking whether the\n\t * resource exists and is readable. The default implementation also verifies\n\t * the resource is either under the location relative to which it was found or\n\t * is under one of the {@linkplain #setAllowedLocations allowed locations}.\n\t * @param resource the resource to check\n\t * @param location the location relative to which the resource was found\n\t * @return \"true\" if resource is in a valid location, \"false\" otherwise\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resource",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "boolean",
    "signature": "protected boolean checkResource(Resource resource, Resource location)",
    "source_code": "\tprotected boolean checkResource(Resource resource, Resource location) throws IOException {\n\t\tif (ResourceHandlerUtils.isResourceUnderLocation(location, resource)) {\n\t\t\treturn true;\n\t\t}\n\t\tResource[] allowedLocations = getAllowedLocations();\n\t\tif (allowedLocations != null) {\n\t\t\tfor (Resource current : allowedLocations) {\n\t\t\t\tif (ResourceHandlerUtils.isResourceUnderLocation(current, resource)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.servlet.resource.PathResourceResolver#getLocationCharsets()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return charsets associated with static resource locations.\n\t * @since 4.3.13\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "Charset>",
    "signature": "public Charset> getLocationCharsets()",
    "source_code": "\tpublic Map<Resource, Charset> getLocationCharsets() {\n\t\treturn Collections.unmodifiableMap(this.locationCharsets);\n\t}"
  },
  "org.springframework.web.servlet.resource.PathResourceResolver#getResource(resourcePath,location)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the resource under the given location.\n\t * <p>The default implementation checks if there is a readable\n\t * {@code Resource} for the given path relative to the location.\n\t * @param resourcePath the path to the resource\n\t * @param location the location to check\n\t * @return the resource, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourcePath",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "Resource",
    "signature": "protected Resource getResource(String resourcePath, Resource location)",
    "source_code": "\tprotected @Nullable Resource getResource(String resourcePath, Resource location) throws IOException {\n\t\tResource resource = location.createRelative(resourcePath);\n\t\tif (resource.isReadable()) {\n\t\t\tif (checkResource(resource, location)) {\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\tResource[] allowed = getAllowedLocations();\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Resource path \\\"\" + resourcePath + \"\\\" was successfully resolved \" +\n\t\t\t\t\t\t\t\t\"but resource \\\"\" + resource + \"\\\" is neither under \" +\n\t\t\t\t\t\t\t\t\"the current location \\\"\" + location + \"\\\" nor under any of \" +\n\t\t\t\t\t\t\t\t\"the allowed locations \" + (allowed != null ? Arrays.asList(allowed) : \"[]\"), -1, true));\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.resource.PathResourceResolver#getUrlPathHelper()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The configured {@link UrlPathHelper}.\n\t * @since 4.3.13\n\t * @deprecated use of {@link PathMatcher} and {@link UrlPathHelper} is deprecated\n\t * for use at runtime in web modules in favor of parsed patterns with\n\t * {@link PathPatternParser}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "UrlPathHelper",
    "signature": "public UrlPathHelper getUrlPathHelper()",
    "source_code": "\tpublic @Nullable UrlPathHelper getUrlPathHelper() {\n\t\treturn this.urlPathHelper;\n\t}"
  },
  "org.springframework.web.servlet.resource.PathResourceResolver#resolveResourceInternal(request,requestPath,locations,chain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "requestPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "Resource",
    "signature": "protected Resource resolveResourceInternal(@Nullable HttpServletRequest request, String requestPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected @Nullable Resource resolveResourceInternal(@Nullable HttpServletRequest request, String requestPath,"
  },
  "org.springframework.web.servlet.resource.PathResourceResolver#resolveUrlPathInternal(resourcePath,locations,chain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourcePath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "String",
    "signature": "protected String resolveUrlPathInternal(String resourcePath, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain)",
    "source_code": "\tprotected @Nullable String resolveUrlPathInternal(String resourcePath, List<? extends Resource> locations,"
  },
  "org.springframework.web.servlet.resource.PathResourceResolver#setAllowedLocations(locations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * By default, when a Resource is found, the path of the resolved resource is\n\t * compared to ensure it's under the input location where it was found.\n\t * However sometimes that may not be the case, for example, when\n\t * {@link org.springframework.web.servlet.resource.CssLinkResourceTransformer}\n\t * resolves public URLs of links it contains, the CSS file is the location\n\t * and the resources being resolved are css files, images, fonts and others\n\t * located in adjacent or parent directories.\n\t * <p>This property allows configuring a complete list of locations under\n\t * which resources must be so that if a resource is not under the location\n\t * relative to which it was found, this list may be checked as well.\n\t * <p>By default {@link ResourceHttpRequestHandler} initializes this property\n\t * to match its list of locations.\n\t * @param locations the list of allowed locations\n\t * @since 4.1.2\n\t * @see ResourceHttpRequestHandler#initAllowedLocations()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "void",
    "signature": "public void setAllowedLocations(Resource @Nullable ... locations)",
    "source_code": "\tpublic void setAllowedLocations(Resource @Nullable ... locations) {\n\t\tthis.allowedLocations = locations;\n\t}"
  },
  "org.springframework.web.servlet.resource.PathResourceResolver#setLocationCharsets(Map<Resource,locationCharsets)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure charsets associated with locations. If a static resource is found\n\t * under a {@link org.springframework.core.io.UrlResource URL resource}\n\t * location the charset is used to encode the relative path\n\t * <p><strong>Note:</strong> the charset is used only if the\n\t * {@link #setUrlPathHelper urlPathHelper} property is also configured and\n\t * its {@code urlDecode} property is set to true.\n\t * @since 4.3.13\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Resource",
      "locationCharsets"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void setLocationCharsets(Map<Resource, Charset> locationCharsets)",
    "source_code": "\tpublic void setLocationCharsets(Map<Resource, Charset> locationCharsets) {\n\t\tthis.locationCharsets.clear();\n\t\tthis.locationCharsets.putAll(locationCharsets);\n\t}"
  },
  "org.springframework.web.servlet.resource.PathResourceResolver#setUrlPathHelper(urlPathHelper)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a reference to the {@link UrlPathHelper} used to map requests to\n\t * static resources. This helps to derive information about the lookup path\n\t * such as whether it is decoded or not.\n\t * @since 4.3.13\n\t * @deprecated use of {@link PathMatcher} and {@link UrlPathHelper} is deprecated\n\t * for use at runtime in web modules in favor of parsed patterns with\n\t * {@link PathPatternParser}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "urlPathHelper"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void setUrlPathHelper(@Nullable UrlPathHelper urlPathHelper)",
    "source_code": "\tpublic void setUrlPathHelper(@Nullable UrlPathHelper urlPathHelper) {\n\t\tthis.urlPathHelper = urlPathHelper;\n\t}"
  },
  "org.springframework.web.servlet.resource.ResourceHttpRequestHandler#getContentNegotiationManager()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured content negotiation manager.\n\t * @since 4.3\n\t * @deprecated as of 5.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "ContentNegotiationManager",
    "signature": "public ContentNegotiationManager getContentNegotiationManager()",
    "source_code": "\tpublic ContentNegotiationManager getContentNegotiationManager() {\n\t\treturn this.contentNegotiationManager;\n\t}"
  },
  "org.springframework.web.servlet.resource.ResourceHttpRequestHandler#setContentNegotiationManager(contentNegotiationManager)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@code ContentNegotiationManager} to help determine the\n\t * media types for resources being served. If the manager contains a path\n\t * extension strategy it will be checked for registered file extension.\n\t * @since 4.3\n\t * @deprecated as of 5.2.4 in favor of using {@link #setMediaTypes(Map)}\n\t * with mappings possibly obtained from\n\t * {@link ContentNegotiationManager#getMediaTypeMappings()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentNegotiationManager"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "void",
    "signature": "public void setContentNegotiationManager(@Nullable ContentNegotiationManager contentNegotiationManager)",
    "source_code": "\tpublic void setContentNegotiationManager(@Nullable ContentNegotiationManager contentNegotiationManager) {\n\t\tthis.contentNegotiationManager = contentNegotiationManager;\n\t}"
  },
  "org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link org.springframework.web.WebApplicationInitializer WebApplicationInitializer}\n * to register a {@code DispatcherServlet} and use Java-based Spring configuration.\n *\n * <p>Implementations are required to implement:\n * <ul>\n * <li>{@link #getRootConfigClasses()} -- for \"root\" application context (non-web\n * infrastructure) configuration.\n * <li>{@link #getServletConfigClasses()} -- for {@code DispatcherServlet}\n * application context (Spring MVC infrastructure) configuration.\n * </ul>\n *\n * <p>If an application context hierarchy is not required, applications may\n * return all configuration via {@link #getRootConfigClasses()} and return\n * {@code null} from {@link #getServletConfigClasses()}.\n *\n * @author Arjen Poutsma\n * @author Chris Beams\n * @since 3.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public class AbstractAnnotationConfigDispatcherServletInitializer",
    "source_code": "public abstract class AbstractAnnotationConfigDispatcherServletInitializer"
  },
  "org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer#createRootApplicationContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>This implementation creates an {@link AnnotationConfigWebApplicationContext},\n\t * providing it the annotated classes returned by {@link #getRootConfigClasses()}.\n\t * Returns {@code null} if {@link #getRootConfigClasses()} returns {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "WebApplicationContext",
    "signature": "protected WebApplicationContext createRootApplicationContext()",
    "source_code": "\tprotected @Nullable WebApplicationContext createRootApplicationContext() {\n\t\tClass<?>[] configClasses = getRootConfigClasses();\n\t\tif (!ObjectUtils.isEmpty(configClasses)) {\n\t\t\tAnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();\n\t\t\tcontext.register(configClasses);\n\t\t\treturn context;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer#createServletApplicationContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>This implementation creates an {@link AnnotationConfigWebApplicationContext},\n\t * providing it the annotated classes returned by {@link #getServletConfigClasses()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "WebApplicationContext",
    "signature": "protected WebApplicationContext createServletApplicationContext()",
    "source_code": "\tprotected WebApplicationContext createServletApplicationContext() {\n\t\tAnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();\n\t\tClass<?>[] configClasses = getServletConfigClasses();\n\t\tif (!ObjectUtils.isEmpty(configClasses)) {\n\t\t\tcontext.register(configClasses);\n\t\t}\n\t\treturn context;\n\t}"
  },
  "org.springframework.web.servlet.support.AbstractDispatcherServletInitializer": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Base class for {@link org.springframework.web.WebApplicationInitializer}\n * implementations that register a {@link DispatcherServlet} in the servlet context.\n *\n * <p>Most applications should consider extending the Spring Java config subclass\n * {@link AbstractAnnotationConfigDispatcherServletInitializer}.\n *\n * @author Arjen Poutsma\n * @author Chris Beams\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @since 3.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "signature": "public class AbstractDispatcherServletInitializer",
    "source_code": "public abstract class AbstractDispatcherServletInitializer extends AbstractContextLoaderInitializer {\n\n\t/**\n\t * The default servlet name. Can be customized by overriding {@link #getServletName}.\n\t */\n\tpublic static final String DEFAULT_SERVLET_NAME = \"dispatcher\";\n\n\n\t@Override\n\tpublic void onStartup(ServletContext servletContext) throws ServletException {\n\t\tsuper.onStartup(servletContext);\n\t\tregisterDispatcherServlet(servletContext);\n\t}\n\n\t/**\n\t * Register a {@link DispatcherServlet} against the given servlet context.\n\t * <p>This method will create a {@code DispatcherServlet} with the name returned by\n\t * {@link #getServletName()}, initializing it with the application context returned\n\t * from {@link #createServletApplicationContext()}, and mapping it to the patterns\n\t * returned from {@link #getServletMappings()}.\n\t * <p>Further customization can be achieved by overriding {@link\n\t * #customizeRegistration(ServletRegistration.Dynamic)} or\n\t * {@link #createDispatcherServlet(WebApplicationContext)}.\n\t * @param servletContext the context to register the servlet against\n\t */\n\tprotected void registerDispatcherServlet(ServletContext servletContext) {\n\t\tString servletName = getServletName();\n\t\tAssert.state(StringUtils.hasLength(servletName), \"getServletName() must not return null or empty\");\n\n\t\tWebApplicationContext servletAppContext = createServletApplicationContext();\n\t\tAssert.state(servletAppContext != null, \"createServletApplicationContext() must not return null\");\n\n\t\tFrameworkServlet dispatcherServlet = createDispatcherServlet(servletAppContext);\n\t\tAssert.state(dispatcherServlet != null, \"createDispatcherServlet(WebApplicationContext) must not return null\");\n\t\tdispatcherServlet.setContextInitializers(getServletApplicationContextInitializers());\n\n\t\tServletRegistration.Dynamic registration = servletContext.addServlet(servletName, dispatcherServlet);\n\t\tif (registration == null) {\n\t\t\tthrow new IllegalStateException(\"Failed to register servlet with name '\" + servletName + \"'. \" +\n\t\t\t\t\t\"Check if there is another servlet registered under the same name.\");\n\t\t}\n\n\t\tregistration.setLoadOnStartup(1);\n\t\tregistration.addMapping(getServletMappings());\n\t\tregistration.setAsyncSupported(isAsyncSupported());\n\n\t\tFilter[] filters = getServletFilters();\n\t\tif (!ObjectUtils.isEmpty(filters)) {\n\t\t\tfor (Filter filter : filters) {\n\t\t\t\tregisterServletFilter(servletContext, filter);\n\t\t\t}\n\t\t}\n\n\t\tcustomizeRegistration(registration);\n\t}\n\n\t/**\n\t * Return the name under which the {@link DispatcherServlet} will be registered.\n\t * Defaults to {@link #DEFAULT_SERVLET_NAME}.\n\t * @see #registerDispatcherServlet(ServletContext)\n\t */\n\tprotected String getServletName() {\n\t\treturn DEFAULT_SERVLET_NAME;\n\t}\n\n\t/**\n\t * Create a servlet application context to be provided to the {@code DispatcherServlet}.\n\t * <p>The returned context is delegated to Spring's\n\t * {@link DispatcherServlet#DispatcherServlet(WebApplicationContext)}. As such,\n\t * it typically contains controllers, view resolvers, locale resolvers, and other\n\t * web-related beans.\n\t * @see #registerDispatcherServlet(ServletContext)\n\t */\n\tprotected abstract WebApplicationContext createServletApplicationContext();\n\n\t/**\n\t * Create a {@link DispatcherServlet} (or other kind of {@link FrameworkServlet}-derived\n\t * dispatcher) with the specified {@link WebApplicationContext}.\n\t * <p>Note: This allows for any {@link FrameworkServlet} subclass as of 4.2.3.\n\t * Previously, it insisted on returning a {@link DispatcherServlet} or subclass thereof.\n\t */\n\tprotected FrameworkServlet createDispatcherServlet(WebApplicationContext servletAppContext) {\n\t\treturn new DispatcherServlet(servletAppContext);\n\t}\n\n\t/**\n\t * Specify application context initializers to be applied to the servlet-specific\n\t * application context that the {@code DispatcherServlet} is being created with.\n\t * @since 4.2\n\t * @see #createServletApplicationContext()\n\t * @see DispatcherServlet#setContextInitializers\n\t * @see #getRootApplicationContextInitializers()\n\t */\n\tprotected ApplicationContextInitializer<?> @Nullable [] getServletApplicationContextInitializers() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Specify the servlet mapping(s) for the {@code DispatcherServlet} &mdash;\n\t * for example {@code \"/\"}, {@code \"/app\"}, etc.\n\t * @see #registerDispatcherServlet(ServletContext)\n\t */\n\tprotected abstract String[] getServletMappings();\n\n\t/**\n\t * Specify filters to add and map to the {@code DispatcherServlet}.\n\t * @return an array of filters or {@code null}\n\t * @see #registerServletFilter(ServletContext, Filter)\n\t */\n\tprotected Filter @Nullable [] getServletFilters() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Add the given filter to the ServletContext and map it to the\n\t * {@code DispatcherServlet} as follows:\n\t * <ul>\n\t * <li>a default filter name is chosen based on its concrete type\n\t * <li>the {@code asyncSupported} flag is set depending on the\n\t * return value of {@link #isAsyncSupported() asyncSupported}\n\t * <li>a filter mapping is created with dispatcher types {@code REQUEST},\n\t * {@code FORWARD}, {@code INCLUDE}, and conditionally {@code ASYNC} depending\n\t * on the return value of {@link #isAsyncSupported() asyncSupported}\n\t * </ul>\n\t * <p>If the above defaults are not suitable or insufficient, override this\n\t * method and register filters directly with the {@code ServletContext}.\n\t * @param servletContext the servlet context to register filters with\n\t * @param filter the filter to be registered\n\t * @return the filter registration\n\t */\n\tprotected FilterRegistration.Dynamic registerServletFilter(ServletContext servletContext, Filter filter) {\n\t\tString filterName = Conventions.getVariableName(filter);\n\t\tDynamic registration = servletContext.addFilter(filterName, filter);\n\n\t\tif (registration == null) {\n\t\t\tint counter = 0;\n\t\t\twhile (registration == null) {\n\t\t\t\tif (counter == 100) {\n\t\t\t\t\tthrow new IllegalStateException(\"Failed to register filter with name '\" + filterName + \"'. \" +\n\t\t\t\t\t\t\t\"Check if there is another filter registered under the same name.\");\n\t\t\t\t}\n\t\t\t\tregistration = servletContext.addFilter(filterName + \"#\" + counter, filter);\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\n\t\tregistration.setAsyncSupported(isAsyncSupported());\n\t\tregistration.addMappingForServletNames(getDispatcherTypes(), false, getServletName());\n\t\treturn registration;\n\t}\n\n\tprivate EnumSet<DispatcherType> getDispatcherTypes() {\n\t\treturn (isAsyncSupported() ?\n\t\t\t\tEnumSet.of(DispatcherType.REQUEST, DispatcherType.FORWARD, DispatcherType.INCLUDE, DispatcherType.ASYNC) :\n\t\t\t\tEnumSet.of(DispatcherType.REQUEST, DispatcherType.FORWARD, DispatcherType.INCLUDE));\n\t}\n\n\t/**\n\t * A single place to control the {@code asyncSupported} flag for the\n\t * {@code DispatcherServlet} and all filters added via {@link #getServletFilters()}.\n\t * <p>The default value is \"true\".\n\t */\n\tprotected boolean isAsyncSupported() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Optionally perform further registration customization once\n\t * {@link #registerDispatcherServlet(ServletContext)} has completed.\n\t * @param registration the {@code DispatcherServlet} registration to be customized\n\t * @see #registerDispatcherServlet(ServletContext)\n\t */\n\tprotected void customizeRegistration(ServletRegistration.Dynamic registration) {\n\t}\n\n}"
  },
  "org.springframework.web.servlet.support.AbstractDispatcherServletInitializer#createDispatcherServlet(servletAppContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link DispatcherServlet} (or other kind of {@link FrameworkServlet}-derived\n\t * dispatcher) with the specified {@link WebApplicationContext}.\n\t * <p>Note: This allows for any {@link FrameworkServlet} subclass as of 4.2.3.\n\t * Previously, it insisted on returning a {@link DispatcherServlet} or subclass thereof.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "servletAppContext"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "FrameworkServlet",
    "signature": "protected FrameworkServlet createDispatcherServlet(WebApplicationContext servletAppContext)",
    "source_code": "\tprotected FrameworkServlet createDispatcherServlet(WebApplicationContext servletAppContext) {\n\t\treturn new DispatcherServlet(servletAppContext);\n\t}"
  },
  "org.springframework.web.servlet.support.AbstractDispatcherServletInitializer#createServletApplicationContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a servlet application context to be provided to the {@code DispatcherServlet}.\n\t * <p>The returned context is delegated to Spring's\n\t * {@link DispatcherServlet#DispatcherServlet(WebApplicationContext)}. As such,\n\t * it typically contains controllers, view resolvers, locale resolvers, and other\n\t * web-related beans.\n\t * @see #registerDispatcherServlet(ServletContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "WebApplicationContext",
    "signature": "protected WebApplicationContext createServletApplicationContext()",
    "source_code": "\tprotected abstract WebApplicationContext createServletApplicationContext();"
  },
  "org.springframework.web.servlet.support.AbstractDispatcherServletInitializer#customizeRegistration(registration)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Optionally perform further registration customization once\n\t * {@link #registerDispatcherServlet(ServletContext)} has completed.\n\t * @param registration the {@code DispatcherServlet} registration to be customized\n\t * @see #registerDispatcherServlet(ServletContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "registration"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "void",
    "signature": "protected void customizeRegistration(ServletRegistration.Dynamic registration)",
    "source_code": "\tprotected void customizeRegistration(ServletRegistration.Dynamic registration) {\n\t}"
  },
  "org.springframework.web.servlet.support.AbstractDispatcherServletInitializer#getServletMappings()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the servlet mapping(s) for the {@code DispatcherServlet} &mdash;\n\t * for example {@code \"/\"}, {@code \"/app\"}, etc.\n\t * @see #registerDispatcherServlet(ServletContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "String[]",
    "signature": "protected String[] getServletMappings()",
    "source_code": "\tprotected abstract String[] getServletMappings();"
  },
  "org.springframework.web.servlet.support.AbstractDispatcherServletInitializer#getServletName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name under which the {@link DispatcherServlet} will be registered.\n\t * Defaults to {@link #DEFAULT_SERVLET_NAME}.\n\t * @see #registerDispatcherServlet(ServletContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "String",
    "signature": "protected String getServletName()",
    "source_code": "\tprotected String getServletName() {\n\t\treturn DEFAULT_SERVLET_NAME;\n\t}"
  },
  "org.springframework.web.servlet.support.AbstractDispatcherServletInitializer#isAsyncSupported()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A single place to control the {@code asyncSupported} flag for the\n\t * {@code DispatcherServlet} and all filters added via {@link #getServletFilters()}.\n\t * <p>The default value is \"true\".\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "boolean",
    "signature": "protected boolean isAsyncSupported()",
    "source_code": "\tprotected boolean isAsyncSupported() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.servlet.support.AbstractDispatcherServletInitializer#onStartup(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "void",
    "signature": "public void onStartup(ServletContext servletContext)",
    "source_code": "\tpublic void onStartup(ServletContext servletContext) throws ServletException {\n\t\tsuper.onStartup(servletContext);\n\t\tregisterDispatcherServlet(servletContext);\n\t}"
  },
  "org.springframework.web.servlet.support.AbstractDispatcherServletInitializer#registerDispatcherServlet(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a {@link DispatcherServlet} against the given servlet context.\n\t * <p>This method will create a {@code DispatcherServlet} with the name returned by\n\t * {@link #getServletName()}, initializing it with the application context returned\n\t * from {@link #createServletApplicationContext()}, and mapping it to the patterns\n\t * returned from {@link #getServletMappings()}.\n\t * <p>Further customization can be achieved by overriding {@link\n\t * #customizeRegistration(ServletRegistration.Dynamic)} or\n\t * {@link #createDispatcherServlet(WebApplicationContext)}.\n\t * @param servletContext the context to register the servlet against\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "protected void registerDispatcherServlet(ServletContext servletContext)",
    "source_code": "\tprotected void registerDispatcherServlet(ServletContext servletContext) {\n\t\tString servletName = getServletName();\n\t\tAssert.state(StringUtils.hasLength(servletName), \"getServletName() must not return null or empty\");\n\n\t\tWebApplicationContext servletAppContext = createServletApplicationContext();\n\t\tAssert.state(servletAppContext != null, \"createServletApplicationContext() must not return null\");\n\n\t\tFrameworkServlet dispatcherServlet = createDispatcherServlet(servletAppContext);\n\t\tAssert.state(dispatcherServlet != null, \"createDispatcherServlet(WebApplicationContext) must not return null\");\n\t\tdispatcherServlet.setContextInitializers(getServletApplicationContextInitializers());\n\n\t\tServletRegistration.Dynamic registration = servletContext.addServlet(servletName, dispatcherServlet);\n\t\tif (registration == null) {\n\t\t\tthrow new IllegalStateException(\"Failed to register servlet with name '\" + servletName + \"'. \" +\n\t\t\t\t\t\"Check if there is another servlet registered under the same name.\");\n\t\t}\n\n\t\tregistration.setLoadOnStartup(1);\n\t\tregistration.addMapping(getServletMappings());\n\t\tregistration.setAsyncSupported(isAsyncSupported());\n\n\t\tFilter[] filters = getServletFilters();\n\t\tif (!ObjectUtils.isEmpty(filters)) {\n\t\t\tfor (Filter filter : filters) {\n\t\t\t\tregisterServletFilter(servletContext, filter);\n\t\t\t}\n\t\t}\n\n\t\tcustomizeRegistration(registration);\n\t}"
  },
  "org.springframework.web.servlet.support.DEFAULT_SERVLET_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The default servlet name. Can be customized by overriding {@link #getServletName}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "signature": "public String DEFAULT_SERVLET_NAME",
    "source_code": "\tpublic static final String DEFAULT_SERVLET_NAME = \"dispatcher\";",
    "type": "String"
  },
  "org.springframework.web.servlet.support.DEFAULT_THEME_NAME": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Default theme name used if the RequestContext cannot find a ThemeResolver.\n\t * Only applies to non-DispatcherServlet requests.\n\t * <p>Same as AbstractThemeResolver's default, but not linked in here to avoid package interdependencies.\n\t * @see org.springframework.web.servlet.theme.AbstractThemeResolver#ORIGINAL_DEFAULT_THEME_NAME\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "signature": "public String DEFAULT_THEME_NAME",
    "source_code": "\tpublic static final String DEFAULT_THEME_NAME = \"theme\";",
    "type": "String"
  },
  "org.springframework.web.servlet.support.HEADER_CACHE_CONTROL": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "signature": "protected String HEADER_CACHE_CONTROL",
    "source_code": "\tprotected static final String HEADER_CACHE_CONTROL = \"Cache-Control\";",
    "type": "String"
  },
  "org.springframework.web.servlet.support.METHOD_GET": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** HTTP method \"GET\". */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "signature": "public String METHOD_GET",
    "source_code": "\tpublic static final String METHOD_GET = \"GET\";",
    "type": "String"
  },
  "org.springframework.web.servlet.support.METHOD_HEAD": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** HTTP method \"HEAD\". */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "signature": "public String METHOD_HEAD",
    "source_code": "\tpublic static final String METHOD_HEAD = \"HEAD\";",
    "type": "String"
  },
  "org.springframework.web.servlet.support.METHOD_POST": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** HTTP method \"POST\". */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "signature": "public String METHOD_POST",
    "source_code": "\tpublic static final String METHOD_POST = \"POST\";",
    "type": "String"
  },
  "org.springframework.web.servlet.support.RequestContext#changeTheme(theme)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Change the current theme to the specified one,\n\t * storing the new theme name through the configured\n\t * {@link org.springframework.web.servlet.ThemeResolver ThemeResolver}.\n\t * @param theme the new theme\n\t * @see org.springframework.web.servlet.ThemeResolver#setThemeName\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "theme"
    ],
    "position": {
      "column": 1,
      "line": 438
    },
    "return": "void",
    "signature": "public void changeTheme(@Nullable org.springframework.ui.context.Theme theme)",
    "source_code": "\tpublic void changeTheme(@Nullable org.springframework.ui.context.Theme theme) {\n\t\torg.springframework.web.servlet.ThemeResolver themeResolver = RequestContextUtils.getThemeResolver(this.request);\n\t\tif (themeResolver == null) {\n\t\t\tthrow new IllegalStateException(\"Cannot change theme if no ThemeResolver configured\");\n\t\t}\n\t\tthemeResolver.setThemeName(this.request, this.response, (theme != null ? theme.getName() : null));\n\t\tthis.theme = theme;\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#changeTheme(themeName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Change the current theme to the specified theme by name,\n\t * storing the new theme name through the configured\n\t * {@link org.springframework.web.servlet.ThemeResolver ThemeResolver}.\n\t * @param themeName the name of the new theme\n\t * @see org.springframework.web.servlet.ThemeResolver#setThemeName\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "themeName"
    ],
    "position": {
      "column": 1,
      "line": 456
    },
    "return": "void",
    "signature": "public void changeTheme(String themeName)",
    "source_code": "\tpublic void changeTheme(String themeName) {\n\t\torg.springframework.web.servlet.ThemeResolver themeResolver = RequestContextUtils.getThemeResolver(this.request);\n\t\tif (themeResolver == null) {\n\t\t\tthrow new IllegalStateException(\"Cannot change theme if no ThemeResolver configured\");\n\t\t}\n\t\tthemeResolver.setThemeName(this.request, this.response, themeName);\n\t\t// Ask for re-resolution on next getTheme call.\n\t\tthis.theme = null;\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getThemeMessage(code)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code"
    ],
    "position": {
      "column": 1,
      "line": 798
    },
    "return": "String",
    "signature": "public String getThemeMessage(String code)",
    "source_code": "\tpublic String getThemeMessage(String code) throws NoSuchMessageException {\n\t\treturn getTheme().getMessageSource().getMessage(code, null, getLocale());\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getThemeMessage(code,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 828
    },
    "return": "String",
    "signature": "public String getThemeMessage(String code, @Nullable List<?> args)",
    "source_code": "\tpublic String getThemeMessage(String code, @Nullable List<?> args) throws NoSuchMessageException {\n\t\treturn getTheme().getMessageSource().getMessage(code, (args != null ? args.toArray() : null), getLocale());\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getThemeMessage(code,args,defaultMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 782
    },
    "return": "String",
    "signature": "public String getThemeMessage(String code, @Nullable List<?> args, String defaultMessage)",
    "source_code": "\tpublic String getThemeMessage(String code, @Nullable List<?> args, String defaultMessage) {\n\t\tString msg = getTheme().getMessageSource().getMessage(code, (args != null ? args.toArray() : null),\n\t\t\t\tdefaultMessage, getLocale());\n\t\treturn (msg != null ? msg : \"\");\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getThemeMessage(code,defaultMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 750
    },
    "return": "String",
    "signature": "public String getThemeMessage(String code, String defaultMessage)",
    "source_code": "\tpublic String getThemeMessage(String code, String defaultMessage) {\n\t\tString msg = getTheme().getMessageSource().getMessage(code, null, defaultMessage, getLocale());\n\t\treturn (msg != null ? msg : \"\");\n\t}"
  },
  "org.springframework.web.servlet.support.RequestContext#getThemeMessage(resolvable)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given MessageSourceResolvable in the current theme.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param resolvable the MessageSourceResolvable\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable"
    ],
    "position": {
      "column": 1,
      "line": 842
    },
    "return": "String",
    "signature": "public String getThemeMessage(MessageSourceResolvable resolvable)",
    "source_code": "\tpublic String getThemeMessage(MessageSourceResolvable resolvable) throws NoSuchMessageException {\n\t\treturn getTheme().getMessageSource().getMessage(resolvable, getLocale());\n\t}"
  },
  "org.springframework.web.servlet.support.WebContentGenerator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Convenient superclass for any kind of web content generator,\n * like {@link org.springframework.web.servlet.mvc.AbstractController}\n * and {@link org.springframework.web.servlet.mvc.WebContentInterceptor}.\n * Can also be used for custom handlers that have their own\n * {@link org.springframework.web.servlet.HandlerAdapter}.\n *\n * <p>Supports HTTP cache control options. The usage of corresponding HTTP\n * headers can be controlled via the {@link #setCacheSeconds \"cacheSeconds\"}\n * and {@link #setCacheControl \"cacheControl\"} properties.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Brian Clozel\n * @author Rossen Stoyanchev\n * @see #setCacheSeconds\n * @see #setCacheControl\n * @see #setRequireSession\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "signature": "public class WebContentGenerator",
    "source_code": "public abstract class WebContentGenerator extends WebApplicationObjectSupport {\n\n\t/** HTTP method \"GET\". */\n\tpublic static final String METHOD_GET = \"GET\";\n\n\t/** HTTP method \"HEAD\". */\n\tpublic static final String METHOD_HEAD = \"HEAD\";\n\n\t/** HTTP method \"POST\". */\n\tpublic static final String METHOD_POST = \"POST\";\n\n\tprotected static final String HEADER_CACHE_CONTROL = \"Cache-Control\";\n\n\n\t/** Set of supported HTTP methods. */\n\tprivate @Nullable Set<String> supportedMethods;\n\n\tprivate @Nullable String allowHeader;\n\n\tprivate boolean requireSession = false;\n\n\tprivate @Nullable CacheControl cacheControl;\n\n\tprivate int cacheSeconds = -1;\n\n\tprivate String @Nullable [] varyByRequestHeaders;\n\n\n\t/**\n\t * Create a new WebContentGenerator which supports\n\t * HTTP methods GET, HEAD and POST by default.\n\t */\n\tpublic WebContentGenerator() {\n\t\tthis(true);\n\t}\n\n\t/**\n\t * Create a new WebContentGenerator.\n\t * @param restrictDefaultSupportedMethods {@code true} if this\n\t * generator should support HTTP methods GET, HEAD and POST by default,\n\t * or {@code false} if it should be unrestricted\n\t */\n\tpublic WebContentGenerator(boolean restrictDefaultSupportedMethods) {\n\t\tif (restrictDefaultSupportedMethods) {\n\t\t\tthis.supportedMethods = CollectionUtils.newLinkedHashSet(3);\n\t\t\tthis.supportedMethods.add(METHOD_GET);\n\t\t\tthis.supportedMethods.add(METHOD_HEAD);\n\t\t\tthis.supportedMethods.add(METHOD_POST);\n\t\t}\n\t\tinitAllowHeader();\n\t}\n\n\t/**\n\t * Create a new WebContentGenerator.\n\t * @param supportedMethods the supported HTTP methods for this content generator\n\t */\n\tpublic WebContentGenerator(String... supportedMethods) {\n\t\tsetSupportedMethods(supportedMethods);\n\t}\n\n\n\t/**\n\t * Set the HTTP methods that this content generator should support.\n\t * <p>Default is GET, HEAD and POST for simple form controller types;\n\t * unrestricted for general controllers and interceptors.\n\t */\n\tpublic final void setSupportedMethods(String @Nullable ... methods) {\n\t\tif (!ObjectUtils.isEmpty(methods)) {\n\t\t\tthis.supportedMethods = new LinkedHashSet<>(Arrays.asList(methods));\n\t\t}\n\t\telse {\n\t\t\tthis.supportedMethods = null;\n\t\t}\n\t\tinitAllowHeader();\n\t}\n\n\t/**\n\t * Return the HTTP methods that this content generator supports.\n\t */\n\tpublic final String @Nullable [] getSupportedMethods() {\n\t\treturn (this.supportedMethods != null ? StringUtils.toStringArray(this.supportedMethods) : null);\n\t}\n\n\tprivate void initAllowHeader() {\n\t\tCollection<String> allowedMethods;\n\t\tif (this.supportedMethods == null) {\n\t\t\tallowedMethods = new ArrayList<>(HttpMethod.values().length - 1);\n\t\t\tfor (HttpMethod method : HttpMethod.values()) {\n\t\t\t\tif (method != HttpMethod.TRACE) {\n\t\t\t\t\tallowedMethods.add(method.name());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (this.supportedMethods.contains(HttpMethod.OPTIONS.name())) {\n\t\t\tallowedMethods = this.supportedMethods;\n\t\t}\n\t\telse {\n\t\t\tallowedMethods = new ArrayList<>(this.supportedMethods);\n\t\t\tallowedMethods.add(HttpMethod.OPTIONS.name());\n\n\t\t}\n\t\tthis.allowHeader = StringUtils.collectionToCommaDelimitedString(allowedMethods);\n\t}\n\n\t/**\n\t * Return the \"Allow\" header value to use in response to an HTTP OPTIONS request\n\t * based on the configured {@link #setSupportedMethods supported methods} also\n\t * automatically adding \"OPTIONS\" to the list even if not present as a supported\n\t * method. This means subclasses don't have to explicitly list \"OPTIONS\" as a\n\t * supported method as long as HTTP OPTIONS requests are handled before making a\n\t * call to {@link #checkRequest(HttpServletRequest)}.\n\t * @since 4.3\n\t */\n\tprotected @Nullable String getAllowHeader() {\n\t\treturn this.allowHeader;\n\t}\n\n\t/**\n\t * Set whether a session should be required to handle requests.\n\t */\n\tpublic final void setRequireSession(boolean requireSession) {\n\t\tthis.requireSession = requireSession;\n\t}\n\n\t/**\n\t * Return whether a session is required to handle requests.\n\t */\n\tpublic final boolean isRequireSession() {\n\t\treturn this.requireSession;\n\t}\n\n\t/**\n\t * Set the {@link org.springframework.http.CacheControl} instance to build\n\t * the Cache-Control HTTP response header.\n\t * @since 4.2\n\t */\n\tpublic final void setCacheControl(@Nullable CacheControl cacheControl) {\n\t\tthis.cacheControl = cacheControl;\n\t}\n\n\t/**\n\t * Get the {@link org.springframework.http.CacheControl} instance\n\t * that builds the Cache-Control HTTP response header.\n\t * @since 4.2\n\t */\n\tpublic final @Nullable CacheControl getCacheControl() {\n\t\treturn this.cacheControl;\n\t}\n\n\t/**\n\t * Cache content for the given number of seconds, by writing\n\t * cache-related HTTP headers to the response:\n\t * <ul>\n\t * <li>seconds == -1 (default value): no generation cache-related headers</li>\n\t * <li>seconds == 0: \"Cache-Control: no-store\" will prevent caching</li>\n\t * <li>seconds &gt; 0: \"Cache-Control: max-age=seconds\" will ask to cache content</li>\n\t * </ul>\n\t * <p>For more specific needs, a custom {@link org.springframework.http.CacheControl}\n\t * should be used.\n\t * @see #setCacheControl\n\t */\n\tpublic final void setCacheSeconds(int seconds) {\n\t\tthis.cacheSeconds = seconds;\n\t}\n\n\t/**\n\t * Return the number of seconds that content is cached.\n\t */\n\tpublic final int getCacheSeconds() {\n\t\treturn this.cacheSeconds;\n\t}\n\n\t/**\n\t * Configure one or more request header names (for example, \"Accept-Language\") to\n\t * add to the \"Vary\" response header to inform clients that the response is\n\t * subject to content negotiation and variances based on the value of the\n\t * given request headers. The configured request header names are added only\n\t * if not already present in the response \"Vary\" header.\n\t * @param varyByRequestHeaders one or more request header names\n\t * @since 4.3\n\t */\n\tpublic final void setVaryByRequestHeaders(String @Nullable ... varyByRequestHeaders) {\n\t\tthis.varyByRequestHeaders = varyByRequestHeaders;\n\t}\n\n\t/**\n\t * Return the configured request header names for the \"Vary\" response header.\n\t * @since 4.3\n\t */\n\tpublic final String @Nullable [] getVaryByRequestHeaders() {\n\t\treturn this.varyByRequestHeaders;\n\t}\n\n\n\t/**\n\t * Check the given request for supported methods and a required session, if any.\n\t * @param request current HTTP request\n\t * @throws ServletException if the request cannot be handled because a check failed\n\t * @since 4.2\n\t */\n\tprotected final void checkRequest(HttpServletRequest request) throws ServletException {\n\t\t// Check whether we should support the request method.\n\t\tString method = request.getMethod();\n\t\tif (this.supportedMethods != null && !this.supportedMethods.contains(method)) {\n\t\t\tthrow new HttpRequestMethodNotSupportedException(method, this.supportedMethods);\n\t\t}\n\n\t\t// Check whether a session is required.\n\t\tif (this.requireSession && request.getSession(false) == null) {\n\t\t\tthrow new HttpSessionRequiredException(\"Pre-existing session required but none found\");\n\t\t}\n\t}\n\n\t/**\n\t * Prepare the given response according to the settings of this generator.\n\t * Applies the number of cache seconds specified for this generator.\n\t * @param response current HTTP response\n\t * @since 4.2\n\t */\n\tprotected final void prepareResponse(HttpServletResponse response) {\n\t\tif (this.cacheControl != null) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Applying default \" + getCacheControl());\n\t\t\t}\n\t\t\tapplyCacheControl(response, this.cacheControl);\n\t\t}\n\t\telse {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Applying default cacheSeconds=\" + this.cacheSeconds);\n\t\t\t}\n\t\t\tapplyCacheSeconds(response, this.cacheSeconds);\n\t\t}\n\t\tif (this.varyByRequestHeaders != null) {\n\t\t\tfor (String value : getVaryRequestHeadersToAdd(response, this.varyByRequestHeaders)) {\n\t\t\t\tresponse.addHeader(\"Vary\", value);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Set the HTTP Cache-Control header according to the given settings.\n\t * @param response current HTTP response\n\t * @param cacheControl the pre-configured cache control settings\n\t * @since 4.2\n\t */\n\tprotected final void applyCacheControl(HttpServletResponse response, CacheControl cacheControl) {\n\t\tString ccValue = cacheControl.getHeaderValue();\n\t\tif (ccValue != null) {\n\t\t\t// Set computed HTTP 1.1 Cache-Control header\n\t\t\tresponse.setHeader(HEADER_CACHE_CONTROL, ccValue);\n\t\t}\n\t}\n\n\t/**\n\t * Apply the given cache seconds and generate corresponding HTTP headers,\n\t * i.e. allow caching for the given number of seconds in case of a positive\n\t * value, prevent caching if given a 0 value, do nothing else.\n\t * Does not tell the browser to revalidate the resource.\n\t * @param response current HTTP response\n\t * @param cacheSeconds positive number of seconds into the future that the\n\t * response should be cacheable for, 0 to prevent caching\n\t */\n\tprotected final void applyCacheSeconds(HttpServletResponse response, int cacheSeconds) {\n\t\tCacheControl cControl;\n\t\tif (cacheSeconds > 0) {\n\t\t\tcControl = CacheControl.maxAge(cacheSeconds, TimeUnit.SECONDS);\n\t\t}\n\t\telse if (cacheSeconds == 0) {\n\t\t\tcControl = CacheControl.noStore();\n\t\t}\n\t\telse {\n\t\t\tcControl = CacheControl.empty();\n\t\t}\n\t\tapplyCacheControl(response, cControl);\n\t}\n\n\tprivate Collection<String> getVaryRequestHeadersToAdd(HttpServletResponse response, String[] varyByRequestHeaders) {\n\t\tif (!response.containsHeader(HttpHeaders.VARY)) {\n\t\t\treturn Arrays.asList(varyByRequestHeaders);\n\t\t}\n\t\tCollection<String> result = new ArrayList<>(varyByRequestHeaders.length);\n\t\tCollections.addAll(result, varyByRequestHeaders);\n\t\tfor (String header : response.getHeaders(HttpHeaders.VARY)) {\n\t\t\tfor (String existing : StringUtils.tokenizeToStringArray(header, \",\")) {\n\t\t\t\tif (\"*\".equals(existing)) {\n\t\t\t\t\treturn Collections.emptyList();\n\t\t\t\t}\n\t\t\t\tfor (String value : varyByRequestHeaders) {\n\t\t\t\t\tif (value.equalsIgnoreCase(existing)) {\n\t\t\t\t\t\tresult.remove(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}"
  },
  "org.springframework.web.servlet.support.WebContentGenerator#applyCacheControl(response,cacheControl)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the HTTP Cache-Control header according to the given settings.\n\t * @param response current HTTP response\n\t * @param cacheControl the pre-configured cache control settings\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "cacheControl"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "void",
    "signature": "protected void applyCacheControl(HttpServletResponse response, CacheControl cacheControl)",
    "source_code": "\tprotected final void applyCacheControl(HttpServletResponse response, CacheControl cacheControl) {\n\t\tString ccValue = cacheControl.getHeaderValue();\n\t\tif (ccValue != null) {\n\t\t\t// Set computed HTTP 1.1 Cache-Control header\n\t\t\tresponse.setHeader(HEADER_CACHE_CONTROL, ccValue);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.support.WebContentGenerator#applyCacheSeconds(response,cacheSeconds)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given cache seconds and generate corresponding HTTP headers,\n\t * i.e. allow caching for the given number of seconds in case of a positive\n\t * value, prevent caching if given a 0 value, do nothing else.\n\t * Does not tell the browser to revalidate the resource.\n\t * @param response current HTTP response\n\t * @param cacheSeconds positive number of seconds into the future that the\n\t * response should be cacheable for, 0 to prevent caching\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "cacheSeconds"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "void",
    "signature": "protected void applyCacheSeconds(HttpServletResponse response, int cacheSeconds)",
    "source_code": "\tprotected final void applyCacheSeconds(HttpServletResponse response, int cacheSeconds) {\n\t\tCacheControl cControl;\n\t\tif (cacheSeconds > 0) {\n\t\t\tcControl = CacheControl.maxAge(cacheSeconds, TimeUnit.SECONDS);\n\t\t}\n\t\telse if (cacheSeconds == 0) {\n\t\t\tcControl = CacheControl.noStore();\n\t\t}\n\t\telse {\n\t\t\tcControl = CacheControl.empty();\n\t\t}\n\t\tapplyCacheControl(response, cControl);\n\t}"
  },
  "org.springframework.web.servlet.support.WebContentGenerator#checkRequest(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check the given request for supported methods and a required session, if any.\n\t * @param request current HTTP request\n\t * @throws ServletException if the request cannot be handled because a check failed\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "void",
    "signature": "protected void checkRequest(HttpServletRequest request)",
    "source_code": "\tprotected final void checkRequest(HttpServletRequest request) throws ServletException {\n\t\t// Check whether we should support the request method.\n\t\tString method = request.getMethod();\n\t\tif (this.supportedMethods != null && !this.supportedMethods.contains(method)) {\n\t\t\tthrow new HttpRequestMethodNotSupportedException(method, this.supportedMethods);\n\t\t}\n\n\t\t// Check whether a session is required.\n\t\tif (this.requireSession && request.getSession(false) == null) {\n\t\t\tthrow new HttpSessionRequiredException(\"Pre-existing session required but none found\");\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.support.WebContentGenerator#getAllowHeader()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the \"Allow\" header value to use in response to an HTTP OPTIONS request\n\t * based on the configured {@link #setSupportedMethods supported methods} also\n\t * automatically adding \"OPTIONS\" to the list even if not present as a supported\n\t * method. This means subclasses don't have to explicitly list \"OPTIONS\" as a\n\t * supported method as long as HTTP OPTIONS requests are handled before making a\n\t * call to {@link #checkRequest(HttpServletRequest)}.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "String",
    "signature": "protected String getAllowHeader()",
    "source_code": "\tprotected @Nullable String getAllowHeader() {\n\t\treturn this.allowHeader;\n\t}"
  },
  "org.springframework.web.servlet.support.WebContentGenerator#getCacheControl()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link org.springframework.http.CacheControl} instance\n\t * that builds the Cache-Control HTTP response header.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "CacheControl",
    "signature": "public CacheControl getCacheControl()",
    "source_code": "\tpublic final @Nullable CacheControl getCacheControl() {\n\t\treturn this.cacheControl;\n\t}"
  },
  "org.springframework.web.servlet.support.WebContentGenerator#getCacheSeconds()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the number of seconds that content is cached.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "int",
    "signature": "public int getCacheSeconds()",
    "source_code": "\tpublic final int getCacheSeconds() {\n\t\treturn this.cacheSeconds;\n\t}"
  },
  "org.springframework.web.servlet.support.WebContentGenerator#isRequireSession()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether a session is required to handle requests.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "boolean",
    "signature": "public boolean isRequireSession()",
    "source_code": "\tpublic final boolean isRequireSession() {\n\t\treturn this.requireSession;\n\t}"
  },
  "org.springframework.web.servlet.support.WebContentGenerator#prepareResponse(response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the given response according to the settings of this generator.\n\t * Applies the number of cache seconds specified for this generator.\n\t * @param response current HTTP response\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "void",
    "signature": "protected void prepareResponse(HttpServletResponse response)",
    "source_code": "\tprotected final void prepareResponse(HttpServletResponse response) {\n\t\tif (this.cacheControl != null) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Applying default \" + getCacheControl());\n\t\t\t}\n\t\t\tapplyCacheControl(response, this.cacheControl);\n\t\t}\n\t\telse {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Applying default cacheSeconds=\" + this.cacheSeconds);\n\t\t\t}\n\t\t\tapplyCacheSeconds(response, this.cacheSeconds);\n\t\t}\n\t\tif (this.varyByRequestHeaders != null) {\n\t\t\tfor (String value : getVaryRequestHeadersToAdd(response, this.varyByRequestHeaders)) {\n\t\t\t\tresponse.addHeader(\"Vary\", value);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.support.WebContentGenerator#setCacheControl(cacheControl)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link org.springframework.http.CacheControl} instance to build\n\t * the Cache-Control HTTP response header.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheControl"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "void",
    "signature": "public void setCacheControl(@Nullable CacheControl cacheControl)",
    "source_code": "\tpublic final void setCacheControl(@Nullable CacheControl cacheControl) {\n\t\tthis.cacheControl = cacheControl;\n\t}"
  },
  "org.springframework.web.servlet.support.WebContentGenerator#setCacheSeconds(seconds)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Cache content for the given number of seconds, by writing\n\t * cache-related HTTP headers to the response:\n\t * <ul>\n\t * <li>seconds == -1 (default value): no generation cache-related headers</li>\n\t * <li>seconds == 0: \"Cache-Control: no-store\" will prevent caching</li>\n\t * <li>seconds &gt; 0: \"Cache-Control: max-age=seconds\" will ask to cache content</li>\n\t * </ul>\n\t * <p>For more specific needs, a custom {@link org.springframework.http.CacheControl}\n\t * should be used.\n\t * @see #setCacheControl\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "seconds"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "void",
    "signature": "public void setCacheSeconds(int seconds)",
    "source_code": "\tpublic final void setCacheSeconds(int seconds) {\n\t\tthis.cacheSeconds = seconds;\n\t}"
  },
  "org.springframework.web.servlet.support.WebContentGenerator#setRequireSession(requireSession)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether a session should be required to handle requests.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requireSession"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "void",
    "signature": "public void setRequireSession(boolean requireSession)",
    "source_code": "\tpublic final void setRequireSession(boolean requireSession) {\n\t\tthis.requireSession = requireSession;\n\t}"
  },
  "org.springframework.web.servlet.support.WebContentGenerator#setSupportedMethods(methods)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the HTTP methods that this content generator should support.\n\t * <p>Default is GET, HEAD and POST for simple form controller types;\n\t * unrestricted for general controllers and interceptors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methods"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void setSupportedMethods(String @Nullable ... methods)",
    "source_code": "\tpublic final void setSupportedMethods(String @Nullable ... methods) {\n\t\tif (!ObjectUtils.isEmpty(methods)) {\n\t\t\tthis.supportedMethods = new LinkedHashSet<>(Arrays.asList(methods));\n\t\t}\n\t\telse {\n\t\t\tthis.supportedMethods = null;\n\t\t}\n\t\tinitAllowHeader();\n\t}"
  },
  "org.springframework.web.servlet.support.WebContentGenerator#setVaryByRequestHeaders(varyByRequestHeaders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure one or more request header names (for example, \"Accept-Language\") to\n\t * add to the \"Vary\" response header to inform clients that the response is\n\t * subject to content negotiation and variances based on the value of the\n\t * given request headers. The configured request header names are added only\n\t * if not already present in the response \"Vary\" header.\n\t * @param varyByRequestHeaders one or more request header names\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "varyByRequestHeaders"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "void",
    "signature": "public void setVaryByRequestHeaders(String @Nullable ... varyByRequestHeaders)",
    "source_code": "\tpublic final void setVaryByRequestHeaders(String @Nullable ... varyByRequestHeaders) {\n\t\tthis.varyByRequestHeaders = varyByRequestHeaders;\n\t}"
  },
  "org.springframework.web.servlet.tags.EvalTag": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * The {@code <eval>} tag evaluates a Spring expression (SpEL) and either prints\n * the result or assigns it to a variable. Supports the standard JSP evaluation\n * context consisting of implicit variables and scoped attributes.\n *\n * <table>\n * <caption>Attribute Summary</caption>\n * <thead>\n * <tr>\n * <th>Attribute</th>\n * <th>Required?</th>\n * <th>Runtime Expression?</th>\n * <th>Description</th>\n * </tr>\n * </thead>\n * <tbody>\n * <tr>\n * <td>expression</td>\n * <td>true</td>\n * <td>true</td>\n * <td>The expression to evaluate.</td>\n * </tr>\n * <tr>\n * <td>htmlEscape</td>\n * <td>false</td>\n * <td>true</td>\n * <td>Set HTML escaping for this tag, as a boolean value.\n * Overrides the default HTML escaping setting for the current page.</td>\n * </tr>\n * <tr>\n * <td>javaScriptEscape</td>\n * <td>false</td>\n * <td>true</td>\n * <td>Set JavaScript escaping for this tag, as a boolean value.\n * Default is {@code false}.</td>\n * </tr>\n * <tr>\n * <td>scope</td>\n * <td>false</td>\n * <td>true</td>\n * <td>The scope for the var. 'application', 'session', 'request' and 'page'\n * scopes are supported. Defaults to page scope. This attribute has no effect\n * unless the var attribute is also defined.</td>\n * </tr>\n * <tr>\n * <td>var</td>\n * <td>false</td>\n * <td>true</td>\n * <td>The name of the variable to export the evaluation result to.\n * If not specified the evaluation result is converted to a String and written\n * as output.</td>\n * </tr>\n * </tbody>\n * </table>\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 3.0.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "signature": "public class EvalTag",
    "source_code": "public class EvalTag extends HtmlEscapingAwareTag {\n\n\t/**\n\t * {@link jakarta.servlet.jsp.PageContext} attribute for the\n\t * page-level {@link EvaluationContext} instance.\n\t */\n\tprivate static final String EVALUATION_CONTEXT_PAGE_ATTRIBUTE =\n\t\t\t\"org.springframework.web.servlet.tags.EVALUATION_CONTEXT\";\n\n\n\tprivate final ExpressionParser expressionParser = new SpelExpressionParser();\n\n\tprivate @Nullable Expression expression;\n\n\tprivate @Nullable String var;\n\n\tprivate int scope = PageContext.PAGE_SCOPE;\n\n\tprivate boolean javaScriptEscape = false;\n\n\n\t/**\n\t * Set the expression to evaluate.\n\t */\n\tpublic void setExpression(String expression) {\n\t\tthis.expression = this.expressionParser.parseExpression(expression);\n\t}\n\n\t/**\n\t * Set the variable name to expose the evaluation result under.\n\t * Defaults to rendering the result to the current JspWriter.\n\t */\n\tpublic void setVar(String var) {\n\t\tthis.var = var;\n\t}\n\n\t/**\n\t * Set the scope to export the evaluation result to.\n\t * This attribute has no meaning unless var is also defined.\n\t */\n\tpublic void setScope(String scope) {\n\t\tthis.scope = TagUtils.getScope(scope);\n\t}\n\n\t/**\n\t * Set JavaScript escaping for this tag, as boolean value.\n\t * Default is \"false\".\n\t */\n\tpublic void setJavaScriptEscape(boolean javaScriptEscape) throws JspException {\n\t\tthis.javaScriptEscape = javaScriptEscape;\n\t}\n\n\n\t@Override\n\tpublic int doStartTagInternal() throws JspException {\n\t\treturn EVAL_BODY_INCLUDE;\n\t}\n\n\t@Override\n\tpublic int doEndTag() throws JspException {\n\t\tEvaluationContext evaluationContext =\n\t\t\t\t(EvaluationContext) this.pageContext.getAttribute(EVALUATION_CONTEXT_PAGE_ATTRIBUTE);\n\t\tif (evaluationContext == null) {\n\t\t\tevaluationContext = createEvaluationContext(this.pageContext);\n\t\t\tthis.pageContext.setAttribute(EVALUATION_CONTEXT_PAGE_ATTRIBUTE, evaluationContext);\n\t\t}\n\t\tif (this.var != null) {\n\t\t\tObject result = (this.expression != null ? this.expression.getValue(evaluationContext) : null);\n\t\t\tthis.pageContext.setAttribute(this.var, result, this.scope);\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tString result = (this.expression != null ?\n\t\t\t\t\t\tthis.expression.getValue(evaluationContext, String.class) : null);\n\t\t\t\tresult = ObjectUtils.getDisplayString(result);\n\t\t\t\tresult = htmlEscape(result);\n\t\t\t\tresult = (this.javaScriptEscape ? JavaScriptUtils.javaScriptEscape(result) : result);\n\t\t\t\tthis.pageContext.getOut().print(result);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new JspException(ex);\n\t\t\t}\n\t\t}\n\t\treturn EVAL_PAGE;\n\t}\n\n\tprivate EvaluationContext createEvaluationContext(PageContext pageContext) {\n\t\tStandardEvaluationContext context = new StandardEvaluationContext();\n\t\tcontext.addPropertyAccessor(new JspPropertyAccessor(pageContext));\n\t\tcontext.addPropertyAccessor(new MapAccessor());\n\t\tcontext.addPropertyAccessor(new EnvironmentAccessor());\n\t\tcontext.setBeanResolver(new BeanFactoryResolver(getRequestContext().getWebApplicationContext()));\n\t\tConversionService conversionService = getConversionService(pageContext);\n\t\tif (conversionService != null) {\n\t\t\tcontext.setTypeConverter(new StandardTypeConverter(conversionService));\n\t\t}\n\t\treturn context;\n\t}\n\n\tprivate @Nullable ConversionService getConversionService(PageContext pageContext) {\n\t\treturn (ConversionService) pageContext.getRequest().getAttribute(ConversionService.class.getName());\n\t}\n\n\n\t@SuppressWarnings(\"deprecation\")\n\tprivate static class JspPropertyAccessor implements PropertyAccessor {\n\n\t\tprivate final PageContext pageContext;\n\n\t\tprivate final @Nullable ELContext elContext;\n\n\n\t\tpublic JspPropertyAccessor(PageContext pageContext) {\n\t\t\tthis.pageContext = pageContext;\n\t\t\tthis.elContext = pageContext.getELContext();\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> @Nullable [] getSpecificTargetClasses() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\t\treturn (target == null &&\n\t\t\t\t\t(resolveImplicitVariable(name) != null || this.pageContext.findAttribute(name) != null));\n\t\t}\n\n\t\t@Override\n\t\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\t\tObject implicitVar = resolveImplicitVariable(name);\n\t\t\tif (implicitVar != null) {\n\t\t\t\treturn new TypedValue(implicitVar);\n\t\t\t}\n\t\t\treturn new TypedValue(this.pageContext.findAttribute(name));\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\tprivate @Nullable Object resolveImplicitVariable(String name) throws AccessException {\n\t\t\tif (this.elContext == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn this.elContext.getELResolver().getValue(this.elContext, null, name);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new AccessException(\n\t\t\t\t\t\t\"Unexpected exception occurred accessing '\" + name + \"' as an implicit variable\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.servlet.tags.EvalTag#canRead(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "boolean",
    "signature": "public boolean canRead(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\t\treturn (target == null &&\n\t\t\t\t\t(resolveImplicitVariable(name) != null || this.pageContext.findAttribute(name) != null));\n\t\t}"
  },
  "org.springframework.web.servlet.tags.EvalTag#canWrite(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "boolean",
    "signature": "public boolean canWrite(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) {\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.servlet.tags.EvalTag#doEndTag()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "int",
    "signature": "public int doEndTag()",
    "source_code": "\tpublic int doEndTag() throws JspException {\n\t\tEvaluationContext evaluationContext =\n\t\t\t\t(EvaluationContext) this.pageContext.getAttribute(EVALUATION_CONTEXT_PAGE_ATTRIBUTE);\n\t\tif (evaluationContext == null) {\n\t\t\tevaluationContext = createEvaluationContext(this.pageContext);\n\t\t\tthis.pageContext.setAttribute(EVALUATION_CONTEXT_PAGE_ATTRIBUTE, evaluationContext);\n\t\t}\n\t\tif (this.var != null) {\n\t\t\tObject result = (this.expression != null ? this.expression.getValue(evaluationContext) : null);\n\t\t\tthis.pageContext.setAttribute(this.var, result, this.scope);\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tString result = (this.expression != null ?\n\t\t\t\t\t\tthis.expression.getValue(evaluationContext, String.class) : null);\n\t\t\t\tresult = ObjectUtils.getDisplayString(result);\n\t\t\t\tresult = htmlEscape(result);\n\t\t\t\tresult = (this.javaScriptEscape ? JavaScriptUtils.javaScriptEscape(result) : result);\n\t\t\t\tthis.pageContext.getOut().print(result);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new JspException(ex);\n\t\t\t}\n\t\t}\n\t\treturn EVAL_PAGE;\n\t}"
  },
  "org.springframework.web.servlet.tags.EvalTag#doStartTagInternal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "int",
    "signature": "public int doStartTagInternal()",
    "source_code": "\tpublic int doStartTagInternal() throws JspException {\n\t\treturn EVAL_BODY_INCLUDE;\n\t}"
  },
  "org.springframework.web.servlet.tags.EvalTag#read(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "TypedValue",
    "signature": "public TypedValue read(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\t\tObject implicitVar = resolveImplicitVariable(name);\n\t\t\tif (implicitVar != null) {\n\t\t\t\treturn new TypedValue(implicitVar);\n\t\t\t}\n\t\t\treturn new TypedValue(this.pageContext.findAttribute(name));\n\t\t}"
  },
  "org.springframework.web.servlet.tags.EvalTag#setExpression(expression)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the expression to evaluate.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "void",
    "signature": "public void setExpression(String expression)",
    "source_code": "\tpublic void setExpression(String expression) {\n\t\tthis.expression = this.expressionParser.parseExpression(expression);\n\t}"
  },
  "org.springframework.web.servlet.tags.EvalTag#setJavaScriptEscape(javaScriptEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set JavaScript escaping for this tag, as boolean value.\n\t * Default is \"false\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "javaScriptEscape"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "void",
    "signature": "public void setJavaScriptEscape(boolean javaScriptEscape)",
    "source_code": "\tpublic void setJavaScriptEscape(boolean javaScriptEscape) throws JspException {\n\t\tthis.javaScriptEscape = javaScriptEscape;\n\t}"
  },
  "org.springframework.web.servlet.tags.EvalTag#setScope(scope)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the scope to export the evaluation result to.\n\t * This attribute has no meaning unless var is also defined.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "void",
    "signature": "public void setScope(String scope)",
    "source_code": "\tpublic void setScope(String scope) {\n\t\tthis.scope = TagUtils.getScope(scope);\n\t}"
  },
  "org.springframework.web.servlet.tags.EvalTag#setVar(var)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the variable name to expose the evaluation result under.\n\t * Defaults to rendering the result to the current JspWriter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "var"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "public void setVar(String var)",
    "source_code": "\tpublic void setVar(String var) {\n\t\tthis.var = var;\n\t}"
  },
  "org.springframework.web.servlet.tags.EvalTag#write(context,target,name,newValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "void",
    "signature": "public void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue)",
    "source_code": "\t\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.tags.MessageTag#resolveArguments(arguments)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given arguments Object into an arguments array.\n\t * @param arguments the specified arguments Object\n\t * @return the resolved arguments as array\n\t * @throws JspException if argument conversion failed\n\t * @see #setArguments\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "Object[]",
    "signature": "protected Object[] resolveArguments(@Nullable Object arguments)",
    "source_code": "\tprotected Object[] resolveArguments(@Nullable Object arguments) throws JspException {\n\t\tif (arguments instanceof String string) {\n\t\t\treturn StringUtils.delimitedListToStringArray(string, this.argumentSeparator);\n\t\t}\n\t\telse if (arguments instanceof Object[] array) {\n\t\t\treturn array;\n\t\t}\n\t\telse if (arguments instanceof Collection<?> collection) {\n\t\t\treturn collection.toArray();\n\t\t}\n\t\telse if (arguments != null) {\n\t\t\t// Assume a single argument object.\n\t\t\treturn new Object[] {arguments};\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.RedirectView#getHosts()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured application hosts.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 278
    },
    "return": "String[]",
    "signature": "public String[] getHosts()",
    "source_code": "\tpublic String[] getHosts() {\n\t\treturn this.hosts;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#getExposedContextBeanNames()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 400
    },
    "return": "String[]",
    "signature": "protected String[] getExposedContextBeanNames()",
    "source_code": "\tprotected String[] getExposedContextBeanNames() {\n\t\treturn this.exposedContextBeanNames;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#getRedirectHosts()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured application hosts for redirect purposes.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 285
    },
    "return": "String[]",
    "signature": "public String[] getRedirectHosts()",
    "source_code": "\tpublic String[] getRedirectHosts() {\n\t\treturn this.redirectHosts;\n\t}"
  },
  "org.springframework.web.servlet.view.UrlBasedViewResolver#getViewNames()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the view names (or name patterns) that can be handled by this\n\t * {@link org.springframework.web.servlet.ViewResolver}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 420
    },
    "return": "String[]",
    "signature": "protected String[] getViewNames()",
    "source_code": "\tprotected String[] getViewNames() {\n\t\treturn this.viewNames;\n\t}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfig": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Interface to be implemented by objects that configure and manage a\n * JSR-223 {@link ScriptEngine} for automatic lookup in a web environment.\n * Detected and used by {@link ScriptTemplateView}.\n *\n * @author Sebastien Deleuze\n * @since 4.2\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public interface ScriptTemplateConfig",
    "source_code": "public interface ScriptTemplateConfig {\n\n\t/**\n\t * Return the {@link ScriptEngine} to use by the views.\n\t */\n\t@Nullable ScriptEngine getEngine();\n\n\t/**\n\t * Return the engine supplier that will be used to instantiate the {@link ScriptEngine}.\n\t * @since 5.2\n\t */\n\t@Nullable Supplier<ScriptEngine> getEngineSupplier();\n\n\t/**\n\t * Return the engine name that will be used to instantiate the {@link ScriptEngine}.\n\t */\n\t@Nullable String getEngineName();\n\n\t/**\n\t * Return whether to use a shared engine for all threads or whether to create\n\t * thread-local engine instances for each thread.\n\t */\n\t@Nullable Boolean isSharedEngine();\n\n\t/**\n\t * Return the scripts to be loaded by the script engine (library or user provided).\n\t */\n\tString @Nullable [] getScripts();\n\n\t/**\n\t * Return the object where the render function belongs (optional).\n\t */\n\t@Nullable String getRenderObject();\n\n\t/**\n\t * Return the render function name (optional). If not specified, the script templates\n\t * will be evaluated with {@link ScriptEngine#eval(String, Bindings)}.\n\t */\n\t@Nullable String getRenderFunction();\n\n\t/**\n\t * Return the content type to use for the response.\n\t * @since 4.2.1\n\t */\n\t@Nullable String getContentType();\n\n\t/**\n\t * Return the charset used to read script and template files.\n\t */\n\t@Nullable Charset getCharset();\n\n\t/**\n\t * Return the resource loader path(s) via a Spring resource location.\n\t */\n\t@Nullable String getResourceLoaderPath();\n\n}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfigurer": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An implementation of Spring MVC's {@link ScriptTemplateConfig} for creating\n * a {@code ScriptEngine} for use in a web application.\n *\n * <pre class=\"code\">\n * // Add the following to an &#64;Configuration class\n * &#64;Bean\n * public ScriptTemplateConfigurer mustacheConfigurer() {\n *    ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();\n *    configurer.setEngineName(\"nashorn\");\n *    configurer.setScripts(\"mustache.js\");\n *    configurer.setRenderObject(\"Mustache\");\n *    configurer.setRenderFunction(\"render\");\n *    return configurer;\n * }\n * </pre>\n *\n * <p><b>NOTE:</b> It is possible to use non thread-safe script engines with\n * templating libraries not designed for concurrency, like Handlebars or React running on\n * Nashorn, by setting the {@link #setSharedEngine sharedEngine} property to {@code false}.\n *\n * @author Sebastien Deleuze\n * @since 4.2\n * @see ScriptTemplateView\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public class ScriptTemplateConfigurer",
    "source_code": "public class ScriptTemplateConfigurer implements ScriptTemplateConfig {\n\n\tprivate @Nullable ScriptEngine engine;\n\n\tprivate @Nullable Supplier<ScriptEngine> engineSupplier;\n\n\tprivate @Nullable String engineName;\n\n\tprivate @Nullable Boolean sharedEngine;\n\n\tprivate String @Nullable [] scripts;\n\n\tprivate @Nullable String renderObject;\n\n\tprivate @Nullable String renderFunction;\n\n\tprivate @Nullable String contentType;\n\n\tprivate @Nullable Charset charset;\n\n\tprivate @Nullable String resourceLoaderPath;\n\n\n\t/**\n\t * Default constructor.\n\t */\n\tpublic ScriptTemplateConfigurer() {\n\t}\n\n\t/**\n\t * Create a new ScriptTemplateConfigurer using the given engine name.\n\t */\n\tpublic ScriptTemplateConfigurer(String engineName) {\n\t\tthis.engineName = engineName;\n\t}\n\n\n\t/**\n\t * Set the {@link ScriptEngine} to use by the view.\n\t * If {@code renderFunction} is specified, the script engine must implement {@code Invocable}.\n\t * You must define {@code engine} or {@code engineName}, not both.\n\t * <p>When the {@code sharedEngine} flag is set to {@code false}, you should not specify\n\t * the script engine with this setter, but with {@link #setEngineName(String)}\n\t * or {@link #setEngineSupplier(Supplier)} since it implies multiple lazy\n\t * instantiations of the script engine.\n\t * @see #setEngineName(String)\n\t * @see #setEngineSupplier(Supplier)\n\t */\n\tpublic void setEngine(@Nullable ScriptEngine engine) {\n\t\tthis.engine = engine;\n\t}\n\n\t@Override\n\tpublic @Nullable ScriptEngine getEngine() {\n\t\treturn this.engine;\n\t}\n\n\t/**\n\t * Set the {@link ScriptEngine} supplier to use by the view, usually used with\n\t * {@link #setSharedEngine(Boolean)} set to {@code false}.\n\t * If {@code renderFunction} is specified, the script engine must implement {@code Invocable}.\n\t * You must either define {@code engineSupplier}, {@code engine} or {@code engineName}.\n\t * @since 5.2\n\t * @see #setEngine(ScriptEngine)\n\t * @see #setEngineName(String)\n\t */\n\tpublic void setEngineSupplier(@Nullable Supplier<ScriptEngine> engineSupplier) {\n\t\tthis.engineSupplier = engineSupplier;\n\t}\n\n\t@Override\n\tpublic @Nullable Supplier<ScriptEngine> getEngineSupplier() {\n\t\treturn this.engineSupplier;\n\t}\n\n\t/**\n\t * Set the engine name that will be used to instantiate the {@link ScriptEngine}.\n\t * If {@code renderFunction} is specified, the script engine must implement {@code Invocable}.\n\t * You must define {@code engine} or {@code engineName}, not both.\n\t * @see #setEngine(ScriptEngine)\n\t * @see #setEngineSupplier(Supplier)\n\t */\n\tpublic void setEngineName(@Nullable String engineName) {\n\t\tthis.engineName = engineName;\n\t}\n\n\t@Override\n\tpublic @Nullable String getEngineName() {\n\t\treturn this.engineName;\n\t}\n\n\t/**\n\t * When set to {@code false}, use thread-local {@link ScriptEngine} instances instead\n\t * of one single shared instance. This flag should be set to {@code false} for those\n\t * using non thread-safe script engines with templating libraries not designed for\n\t * concurrency, like Handlebars or React running on Nashorn for example.\n\t * <p>When this flag is set to {@code false}, the script engine must be specified using\n\t * {@link #setEngineName(String)} or {@link #setEngineSupplier(Supplier)}.\n\t * Using {@link #setEngine(ScriptEngine)} is not possible because multiple instances\n\t * of the script engine need to be created lazily (one per thread).\n\t * @see <a href=\"https://docs.oracle.com/javase/8/docs/api/javax/script/ScriptEngineFactory.html#getParameter-java.lang.String-\">THREADING ScriptEngine parameter</a>\n\t */\n\tpublic void setSharedEngine(@Nullable Boolean sharedEngine) {\n\t\tthis.sharedEngine = sharedEngine;\n\t}\n\n\t@Override\n\tpublic @Nullable Boolean isSharedEngine() {\n\t\treturn this.sharedEngine;\n\t}\n\n\t/**\n\t * Set the scripts to be loaded by the script engine (library or user provided).\n\t * Since {@code resourceLoaderPath} default value is \"classpath:\", you can load easily\n\t * any script available on the classpath.\n\t * <p>For example, in order to use a JavaScript library available as a WebJars dependency\n\t * and a custom \"render.js\" file, you should call\n\t * {@code configurer.setScripts(\"/META-INF/resources/webjars/library/version/library.js\",\n\t * \"com/myproject/script/render.js\");}.\n\t * @see #setResourceLoaderPath\n\t * @see <a href=\"https://www.webjars.org\">WebJars</a>\n\t */\n\tpublic void setScripts(String @Nullable ... scriptNames) {\n\t\tthis.scripts = scriptNames;\n\t}\n\n\t@Override\n\tpublic String @Nullable [] getScripts() {\n\t\treturn this.scripts;\n\t}\n\n\t/**\n\t * Set the object where the render function belongs (optional).\n\t * For example, in order to call {@code Mustache.render()}, {@code renderObject}\n\t * should be set to {@code \"Mustache\"} and {@code renderFunction} to {@code \"render\"}.\n\t */\n\tpublic void setRenderObject(@Nullable String renderObject) {\n\t\tthis.renderObject = renderObject;\n\t}\n\n\t@Override\n\tpublic @Nullable String getRenderObject() {\n\t\treturn this.renderObject;\n\t}\n\n\t/**\n\t * Set the render function name (optional). If not specified, the script templates\n\t * will be evaluated with {@link ScriptEngine#eval(String, Bindings)}.\n\t * <p>This function will be called with the following parameters:\n\t * <ol>\n\t * <li>{@code String template}: the template content</li>\n\t * <li>{@code Map model}: the view model</li>\n\t * <li>{@code RenderingContext context}: the rendering context (since 5.0)</li>\n\t * </ol>\n\t * @see RenderingContext\n\t */\n\tpublic void setRenderFunction(@Nullable String renderFunction) {\n\t\tthis.renderFunction = renderFunction;\n\t}\n\n\t@Override\n\tpublic @Nullable String getRenderFunction() {\n\t\treturn this.renderFunction;\n\t}\n\n\t/**\n\t * Set the content type to use for the response.\n\t * ({@code text/html} by default).\n\t * @since 4.2.1\n\t */\n\tpublic void setContentType(@Nullable String contentType) {\n\t\tthis.contentType = contentType;\n\t}\n\n\t/**\n\t * Return the content type to use for the response.\n\t * @since 4.2.1\n\t */\n\t@Override\n\tpublic @Nullable String getContentType() {\n\t\treturn this.contentType;\n\t}\n\n\t/**\n\t * Set the charset used to read script and template files.\n\t * ({@code UTF-8} by default).\n\t */\n\tpublic void setCharset(@Nullable Charset charset) {\n\t\tthis.charset = charset;\n\t}\n\n\t@Override\n\tpublic @Nullable Charset getCharset() {\n\t\treturn this.charset;\n\t}\n\n\t/**\n\t * Set the resource loader path(s) via a Spring resource location.\n\t * Accepts multiple locations as a comma-separated list of paths.\n\t * Standard URLs like \"file:\" and \"classpath:\" and pseudo URLs are supported\n\t * as understood by Spring's {@link org.springframework.core.io.ResourceLoader}.\n\t * Relative paths are allowed when running in an ApplicationContext.\n\t * <p>Default is \"classpath:\".\n\t */\n\tpublic void setResourceLoaderPath(@Nullable String resourceLoaderPath) {\n\t\tthis.resourceLoaderPath = resourceLoaderPath;\n\t}\n\n\t@Override\n\tpublic @Nullable String getResourceLoaderPath() {\n\t\treturn this.resourceLoaderPath;\n\t}\n\n}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfigurer#getCharset()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "Charset",
    "signature": "public Charset getCharset()",
    "source_code": "\tpublic @Nullable Charset getCharset() {\n\t\treturn this.charset;\n\t}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfigurer#getContentType()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the content type to use for the response.\n\t * @since 4.2.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "String",
    "signature": "public String getContentType()",
    "source_code": "\tpublic @Nullable String getContentType() {\n\t\treturn this.contentType;\n\t}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfigurer#getEngine()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "ScriptEngine",
    "signature": "public ScriptEngine getEngine()",
    "source_code": "\tpublic @Nullable ScriptEngine getEngine() {\n\t\treturn this.engine;\n\t}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfigurer#getEngineName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "String",
    "signature": "public String getEngineName()",
    "source_code": "\tpublic @Nullable String getEngineName() {\n\t\treturn this.engineName;\n\t}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfigurer#getEngineSupplier()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "Supplier<ScriptEngine>",
    "signature": "public Supplier<ScriptEngine> getEngineSupplier()",
    "source_code": "\tpublic @Nullable Supplier<ScriptEngine> getEngineSupplier() {\n\t\treturn this.engineSupplier;\n\t}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfigurer#getRenderFunction()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "String",
    "signature": "public String getRenderFunction()",
    "source_code": "\tpublic @Nullable String getRenderFunction() {\n\t\treturn this.renderFunction;\n\t}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfigurer#getRenderObject()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "String",
    "signature": "public String getRenderObject()",
    "source_code": "\tpublic @Nullable String getRenderObject() {\n\t\treturn this.renderObject;\n\t}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfigurer#getResourceLoaderPath()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "String",
    "signature": "public String getResourceLoaderPath()",
    "source_code": "\tpublic @Nullable String getResourceLoaderPath() {\n\t\treturn this.resourceLoaderPath;\n\t}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfigurer#isSharedEngine()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "Boolean",
    "signature": "public Boolean isSharedEngine()",
    "source_code": "\tpublic @Nullable Boolean isSharedEngine() {\n\t\treturn this.sharedEngine;\n\t}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfigurer#setCharset(charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the charset used to read script and template files.\n\t * ({@code UTF-8} by default).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "void",
    "signature": "public void setCharset(@Nullable Charset charset)",
    "source_code": "\tpublic void setCharset(@Nullable Charset charset) {\n\t\tthis.charset = charset;\n\t}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfigurer#setContentType(contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the content type to use for the response.\n\t * ({@code text/html} by default).\n\t * @since 4.2.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "void",
    "signature": "public void setContentType(@Nullable String contentType)",
    "source_code": "\tpublic void setContentType(@Nullable String contentType) {\n\t\tthis.contentType = contentType;\n\t}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfigurer#setEngine(engine)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link ScriptEngine} to use by the view.\n\t * If {@code renderFunction} is specified, the script engine must implement {@code Invocable}.\n\t * You must define {@code engine} or {@code engineName}, not both.\n\t * <p>When the {@code sharedEngine} flag is set to {@code false}, you should not specify\n\t * the script engine with this setter, but with {@link #setEngineName(String)}\n\t * or {@link #setEngineSupplier(Supplier)} since it implies multiple lazy\n\t * instantiations of the script engine.\n\t * @see #setEngineName(String)\n\t * @see #setEngineSupplier(Supplier)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "engine"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void setEngine(@Nullable ScriptEngine engine)",
    "source_code": "\tpublic void setEngine(@Nullable ScriptEngine engine) {\n\t\tthis.engine = engine;\n\t}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfigurer#setEngineName(engineName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the engine name that will be used to instantiate the {@link ScriptEngine}.\n\t * If {@code renderFunction} is specified, the script engine must implement {@code Invocable}.\n\t * You must define {@code engine} or {@code engineName}, not both.\n\t * @see #setEngine(ScriptEngine)\n\t * @see #setEngineSupplier(Supplier)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "engineName"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void setEngineName(@Nullable String engineName)",
    "source_code": "\tpublic void setEngineName(@Nullable String engineName) {\n\t\tthis.engineName = engineName;\n\t}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfigurer#setEngineSupplier(engineSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link ScriptEngine} supplier to use by the view, usually used with\n\t * {@link #setSharedEngine(Boolean)} set to {@code false}.\n\t * If {@code renderFunction} is specified, the script engine must implement {@code Invocable}.\n\t * You must either define {@code engineSupplier}, {@code engine} or {@code engineName}.\n\t * @since 5.2\n\t * @see #setEngine(ScriptEngine)\n\t * @see #setEngineName(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "engineSupplier"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "void",
    "signature": "public void setEngineSupplier(@Nullable Supplier<ScriptEngine> engineSupplier)",
    "source_code": "\tpublic void setEngineSupplier(@Nullable Supplier<ScriptEngine> engineSupplier) {\n\t\tthis.engineSupplier = engineSupplier;\n\t}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfigurer#setRenderFunction(renderFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the render function name (optional). If not specified, the script templates\n\t * will be evaluated with {@link ScriptEngine#eval(String, Bindings)}.\n\t * <p>This function will be called with the following parameters:\n\t * <ol>\n\t * <li>{@code String template}: the template content</li>\n\t * <li>{@code Map model}: the view model</li>\n\t * <li>{@code RenderingContext context}: the rendering context (since 5.0)</li>\n\t * </ol>\n\t * @see RenderingContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "renderFunction"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "void",
    "signature": "public void setRenderFunction(@Nullable String renderFunction)",
    "source_code": "\tpublic void setRenderFunction(@Nullable String renderFunction) {\n\t\tthis.renderFunction = renderFunction;\n\t}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfigurer#setRenderObject(renderObject)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the object where the render function belongs (optional).\n\t * For example, in order to call {@code Mustache.render()}, {@code renderObject}\n\t * should be set to {@code \"Mustache\"} and {@code renderFunction} to {@code \"render\"}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "renderObject"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "void",
    "signature": "public void setRenderObject(@Nullable String renderObject)",
    "source_code": "\tpublic void setRenderObject(@Nullable String renderObject) {\n\t\tthis.renderObject = renderObject;\n\t}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfigurer#setResourceLoaderPath(resourceLoaderPath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the resource loader path(s) via a Spring resource location.\n\t * Accepts multiple locations as a comma-separated list of paths.\n\t * Standard URLs like \"file:\" and \"classpath:\" and pseudo URLs are supported\n\t * as understood by Spring's {@link org.springframework.core.io.ResourceLoader}.\n\t * Relative paths are allowed when running in an ApplicationContext.\n\t * <p>Default is \"classpath:\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLoaderPath"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "void",
    "signature": "public void setResourceLoaderPath(@Nullable String resourceLoaderPath)",
    "source_code": "\tpublic void setResourceLoaderPath(@Nullable String resourceLoaderPath) {\n\t\tthis.resourceLoaderPath = resourceLoaderPath;\n\t}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfigurer#setScripts(scriptNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the scripts to be loaded by the script engine (library or user provided).\n\t * Since {@code resourceLoaderPath} default value is \"classpath:\", you can load easily\n\t * any script available on the classpath.\n\t * <p>For example, in order to use a JavaScript library available as a WebJars dependency\n\t * and a custom \"render.js\" file, you should call\n\t * {@code configurer.setScripts(\"/META-INF/resources/webjars/library/version/library.js\",\n\t * \"com/myproject/script/render.js\");}.\n\t * @see #setResourceLoaderPath\n\t * @see <a href=\"https://www.webjars.org\">WebJars</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptNames"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "void",
    "signature": "public void setScripts(String @Nullable ... scriptNames)",
    "source_code": "\tpublic void setScripts(String @Nullable ... scriptNames) {\n\t\tthis.scripts = scriptNames;\n\t}"
  },
  "org.springframework.web.servlet.view.script.ScriptTemplateConfigurer#setSharedEngine(sharedEngine)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * When set to {@code false}, use thread-local {@link ScriptEngine} instances instead\n\t * of one single shared instance. This flag should be set to {@code false} for those\n\t * using non thread-safe script engines with templating libraries not designed for\n\t * concurrency, like Handlebars or React running on Nashorn for example.\n\t * <p>When this flag is set to {@code false}, the script engine must be specified using\n\t * {@link #setEngineName(String)} or {@link #setEngineSupplier(Supplier)}.\n\t * Using {@link #setEngine(ScriptEngine)} is not possible because multiple instances\n\t * of the script engine need to be created lazily (one per thread).\n\t * @see <a href=\"https://docs.oracle.com/javase/8/docs/api/javax/script/ScriptEngineFactory.html#getParameter-java.lang.String-\">THREADING ScriptEngine parameter</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sharedEngine"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "public void setSharedEngine(@Nullable Boolean sharedEngine)",
    "source_code": "\tpublic void setSharedEngine(@Nullable Boolean sharedEngine) {\n\t\tthis.sharedEngine = sharedEngine;\n\t}"
  },
  "org.springframework.web.socket.TextMessage": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A text WebSocket message.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 29
    },
    "signature": "public class TextMessage",
    "source_code": "public final class TextMessage extends AbstractWebSocketMessage<String> {\n\n\tprivate final byte @Nullable [] bytes;\n\n\n\t/**\n\t * Create a new text WebSocket message from the given CharSequence payload.\n\t * @param payload the non-null payload\n\t */\n\tpublic TextMessage(CharSequence payload) {\n\t\tsuper(payload.toString(), true);\n\t\tthis.bytes = null;\n\t}\n\n\t/**\n\t * Create a new text WebSocket message from the given byte[]. It is assumed\n\t * the byte array can be encoded into an UTF-8 String.\n\t * @param payload the non-null payload\n\t */\n\tpublic TextMessage(byte[] payload) {\n\t\tsuper(new String(payload, StandardCharsets.UTF_8));\n\t\tthis.bytes = payload;\n\t}\n\n\t/**\n\t * Create a new text WebSocket message with the given payload representing the\n\t * full or partial message content. When the {@code isLast} boolean flag is set\n\t * to {@code false} the message is sent as partial content and more partial\n\t * messages will be expected until the boolean flag is set to {@code true}.\n\t * @param payload the non-null payload\n\t * @param isLast whether this the last part of a series of partial messages\n\t */\n\tpublic TextMessage(CharSequence payload, boolean isLast) {\n\t\tsuper(payload.toString(), isLast);\n\t\tthis.bytes = null;\n\t}\n\n\n\t@Override\n\tpublic int getPayloadLength() {\n\t\treturn asBytes().length;\n\t}\n\n\tpublic byte[] asBytes() {\n\t\treturn (this.bytes != null ? this.bytes : getPayload().getBytes(StandardCharsets.UTF_8));\n\t}\n\n\t@Override\n\tprotected String toStringPayload() {\n\t\tString payload = getPayload();\n\t\treturn (payload.length() > 10 ? payload.substring(0, 10) + \"..\" : payload);\n\t}\n\n}"
  },
  "org.springframework.web.socket.TextMessage#asBytes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "byte[]",
    "signature": "public byte[] asBytes()",
    "source_code": "\tpublic byte[] asBytes() {\n\t\treturn (this.bytes != null ? this.bytes : getPayload().getBytes(StandardCharsets.UTF_8));\n\t}"
  },
  "org.springframework.web.socket.TextMessage#getPayloadLength()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "int",
    "signature": "public int getPayloadLength()",
    "source_code": "\tpublic int getPayloadLength() {\n\t\treturn asBytes().length;\n\t}"
  },
  "org.springframework.web.socket.TextMessage#toStringPayload()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "String",
    "signature": "protected String toStringPayload()",
    "source_code": "\tprotected String toStringPayload() {\n\t\tString payload = getPayload();\n\t\treturn (payload.length() > 10 ? payload.substring(0, 10) + \"..\" : payload);\n\t}"
  },
  "org.springframework.web.socket.WebSocketHttpHeaders#containsHeader(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "boolean",
    "signature": "public boolean containsHeader(String key)",
    "source_code": "\tpublic boolean containsHeader(String key) {\n\t\treturn this.headers.containsHeader(key);\n\t}"
  },
  "org.springframework.web.socket.WebSocketHttpHeaders#containsKey(key)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn this.headers.containsKey(key);\n\t}"
  },
  "org.springframework.web.socket.WebSocketHttpHeaders#containsValue(value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn this.headers.containsValue(value);\n\t}"
  },
  "org.springframework.web.socket.WebSocketHttpHeaders#entrySet()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> entrySet()",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn this.headers.entrySet();\n\t}"
  },
  "org.springframework.web.socket.WebSocketHttpHeaders#get(headerName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "List<String>",
    "signature": "public List<String> get(String headerName)",
    "source_code": "\tpublic @Nullable List<String> get(String headerName) {\n\t\treturn this.headers.get(headerName);\n\t}"
  },
  "org.springframework.web.socket.WebSocketHttpHeaders#get(key)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "List<String>",
    "signature": "public List<String> get(Object key)",
    "source_code": "\tpublic List<String> get(Object key) {\n\t\treturn this.headers.get(key);\n\t}"
  },
  "org.springframework.web.socket.WebSocketHttpHeaders#headerNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "Set<String>",
    "signature": "public Set<String> headerNames()",
    "source_code": "\tpublic Set<String> headerNames() {\n\t\treturn this.headers.headerNames();\n\t}"
  },
  "org.springframework.web.socket.WebSocketHttpHeaders#keySet()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\tpublic Set<String> keySet() {\n\t\treturn this.headers.keySet();\n\t}"
  },
  "org.springframework.web.socket.WebSocketHttpHeaders#putAll(headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "void",
    "signature": "public void putAll(HttpHeaders headers)",
    "source_code": "\tpublic void putAll(HttpHeaders headers) {\n\t\tthis.headers.putAll(headers);\n\t}"
  },
  "org.springframework.web.socket.WebSocketHttpHeaders#putIfAbsent(headerName,headerValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "List<String>",
    "signature": "public List<String> putIfAbsent(String headerName, List<String> headerValues)",
    "source_code": "\tpublic @Nullable List<String> putIfAbsent(String headerName, List<String> headerValues) {\n\t\treturn this.headers.putIfAbsent(headerName, headerValues);\n\t}"
  },
  "org.springframework.web.socket.WebSocketHttpHeaders#putIfAbsent(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "List<String>",
    "signature": "public List<String> putIfAbsent(String key, List<String> value)",
    "source_code": "\tpublic List<String> putIfAbsent(String key, List<String> value) {\n\t\treturn this.headers.putIfAbsent(key, value);\n\t}"
  },
  "org.springframework.web.socket.WebSocketHttpHeaders#values()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "Collection<List<String>>",
    "signature": "public Collection<List<String>> values()",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.values();\n\t}"
  },
  "org.springframework.web.socket.adapter.NativeWebSocketSession": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@link WebSocketSession} that exposes the underlying, native WebSocketSession\n * through a getter.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 30
    },
    "signature": "public interface NativeWebSocketSession",
    "source_code": "public interface NativeWebSocketSession extends WebSocketSession {\n\n\t/**\n\t * Return the underlying native WebSocketSession.\n\t */\n\tObject getNativeSession();\n\n\t/**\n\t * Return the underlying native WebSocketSession, if available.\n\t * @param requiredType the required type of the session\n\t * @return the native session of the required type,\n\t * or {@code null} if not available\n\t */\n\t<T> @Nullable T getNativeSession(@Nullable Class<T> requiredType);\n\n}"
  },
  "org.springframework.web.socket.config.WebSocketMessageBrokerStats#getStompBrokerRelayStatsInfo()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get stats about STOMP broker relay (when using a full-featured STOMP broker).\n\t * @deprecated as of 6.2 in favor of {@link #getStompBrokerRelayStats()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "String",
    "signature": "public String getStompBrokerRelayStatsInfo()",
    "source_code": "\tpublic String getStompBrokerRelayStatsInfo() {\n\t\treturn (this.stompBrokerRelay != null ? this.stompBrokerRelay.getStatsInfo() : \"null\");\n\t}"
  },
  "org.springframework.web.socket.config.WebSocketMessageBrokerStats#getStompSubProtocolStatsInfo()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get stats about STOMP-related WebSocket message processing.\n\t * @deprecated as of 6.2 in favor of {@link #getStompSubProtocolStats()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "String",
    "signature": "public String getStompSubProtocolStatsInfo()",
    "source_code": "\tpublic String getStompSubProtocolStatsInfo() {\n\t\treturn (this.stompSubProtocolHandler != null ? this.stompSubProtocolHandler.getStatsInfo() : \"null\");\n\t}"
  },
  "org.springframework.web.socket.config.WebSocketMessageBrokerStats#getWebSocketSessionStatsInfo()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get stats about WebSocket sessions.\n\t * @deprecated as of 6.2 in favor of {@link #getWebSocketSessionStats()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "String",
    "signature": "public String getWebSocketSessionStatsInfo()",
    "source_code": "\tpublic String getWebSocketSessionStatsInfo() {\n\t\treturn (this.webSocketHandler != null ? this.webSocketHandler.getStatsInfo() : \"null\");\n\t}"
  },
  "org.springframework.web.socket.server.standard.WebLogicRequestUpgradeStrategy": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * A WebSocket {@code RequestUpgradeStrategy} for Oracle's WebLogic.\n * Supports 12.1.3 as well as 12.2.1, as of Spring Framework 4.2.3.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class WebLogicRequestUpgradeStrategy",
    "source_code": "public class WebLogicRequestUpgradeStrategy extends AbstractTyrusRequestUpgradeStrategy {\n\n\tprivate static final TyrusMuxableWebSocketHelper webSocketHelper = new TyrusMuxableWebSocketHelper();\n\n\tprivate static final WebLogicServletWriterHelper servletWriterHelper = new WebLogicServletWriterHelper();\n\n\tprivate static final Connection.CloseListener noOpCloseListener = (reason -> {});\n\n\n\t@Override\n\tprotected void handleSuccess(HttpServletRequest request, HttpServletResponse response,\n\t\t\tUpgradeInfo upgradeInfo, TyrusUpgradeResponse upgradeResponse) throws IOException, ServletException {\n\n\t\tresponse.setStatus(upgradeResponse.getStatus());\n\t\tupgradeResponse.getHeaders().forEach((key, value) -> response.addHeader(key, Utils.getHeaderFromList(value)));\n\n\t\tAsyncContext asyncContext = request.startAsync();\n\t\tasyncContext.setTimeout(-1L);\n\n\t\tObject nativeRequest = getNativeRequest(request);\n\t\tBeanWrapper beanWrapper = new BeanWrapperImpl(nativeRequest);\n\t\tObject httpSocket = beanWrapper.getPropertyValue(\"connection.connectionHandler.rawConnection\");\n\t\tObject webSocket = webSocketHelper.newInstance(request, httpSocket);\n\t\twebSocketHelper.upgrade(webSocket, httpSocket, request.getServletContext());\n\n\t\tresponse.flushBuffer();\n\n\t\tboolean isProtected = request.getUserPrincipal() != null;\n\t\tWriter servletWriter = servletWriterHelper.newInstance(webSocket, isProtected);\n\t\tConnection connection = upgradeInfo.createConnection(servletWriter, noOpCloseListener);\n\t\tnew BeanWrapperImpl(webSocket).setPropertyValue(\"connection\", connection);\n\t\tnew BeanWrapperImpl(servletWriter).setPropertyValue(\"connection\", connection);\n\t\twebSocketHelper.registerForReadEvent(webSocket);\n\t}\n\n\n\tprivate static Class<?> type(String className) throws ClassNotFoundException {\n\t\treturn WebLogicRequestUpgradeStrategy.class.getClassLoader().loadClass(className);\n\t}\n\n\tprivate static Method method(String className, String method, Class<?>... paramTypes)\n\t\t\tthrows ClassNotFoundException, NoSuchMethodException {\n\n\t\treturn type(className).getDeclaredMethod(method, paramTypes);\n\t}\n\n\tprivate static Object getNativeRequest(ServletRequest request) {\n\t\twhile (request instanceof ServletRequestWrapper wrapper) {\n\t\t\trequest = wrapper.getRequest();\n\t\t}\n\t\treturn request;\n\t}\n\n\n\t/**\n\t * Helps to create and invoke {@code weblogic.servlet.internal.MuxableSocketHTTP}.\n\t */\n\tprivate static class TyrusMuxableWebSocketHelper {\n\n\t\tprivate static final Class<?> type;\n\n\t\tprivate static final Constructor<?> constructor;\n\n\t\tprivate static final SubjectHelper subjectHelper;\n\n\t\tprivate static final Method upgradeMethod;\n\n\t\tprivate static final Method readEventMethod;\n\n\t\tstatic {\n\t\t\ttry {\n\t\t\t\ttype = type(\"weblogic.websocket.tyrus.TyrusMuxableWebSocket\");\n\n\t\t\t\tconstructor = type.getDeclaredConstructor(\n\t\t\t\t\t\ttype(\"weblogic.servlet.internal.MuxableSocketHTTP\"),\n\t\t\t\t\t\ttype(\"weblogic.websocket.tyrus.CoherenceServletFilterService\"),\n\t\t\t\t\t\ttype(\"weblogic.servlet.spi.SubjectHandle\"));\n\t\t\t\tsubjectHelper = new SubjectHelper();\n\n\t\t\t\tupgradeMethod = type.getMethod(\"upgrade\", type(\"weblogic.socket.MuxableSocket\"), ServletContext.class);\n\t\t\t\treadEventMethod = type.getMethod(\"registerForReadEvent\");\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(\"No compatible WebSocket version found\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate Object newInstance(HttpServletRequest request, @Nullable Object httpSocket) {\n\t\t\ttry {\n\t\t\t\tObject[] args = new Object[] {httpSocket, null, subjectHelper.getSubject(request)};\n\t\t\t\treturn constructor.newInstance(args);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new HandshakeFailureException(\"Failed to create TyrusMuxableWebSocket\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void upgrade(Object webSocket, @Nullable Object httpSocket, ServletContext servletContext) {\n\t\t\ttry {\n\t\t\t\tupgradeMethod.invoke(webSocket, httpSocket, servletContext);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new HandshakeFailureException(\"Failed to upgrade TyrusMuxableWebSocket\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void registerForReadEvent(Object webSocket) {\n\t\t\ttry {\n\t\t\t\treadEventMethod.invoke(webSocket);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new HandshakeFailureException(\"Failed to register WebSocket for read event\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static class SubjectHelper {\n\n\t\tprivate final Method securityContextMethod;\n\n\t\tprivate final Method currentUserMethod;\n\n\t\tprivate final Method providerMethod;\n\n\t\tprivate final Method anonymousSubjectMethod;\n\n\t\tpublic SubjectHelper() {\n\t\t\ttry {\n\t\t\t\tString className = \"weblogic.servlet.internal.WebAppServletContext\";\n\t\t\t\tthis.securityContextMethod = method(className, \"getSecurityContext\");\n\n\t\t\t\tclassName = \"weblogic.servlet.security.internal.SecurityModule\";\n\t\t\t\tthis.currentUserMethod = method(className, \"getCurrentUser\",\n\t\t\t\t\t\ttype(\"weblogic.servlet.security.internal.ServletSecurityContext\"),\n\t\t\t\t\t\tHttpServletRequest.class);\n\n\t\t\t\tclassName = \"weblogic.servlet.security.internal.WebAppSecurity\";\n\t\t\t\tthis.providerMethod = method(className, \"getProvider\");\n\t\t\t\tthis.anonymousSubjectMethod = this.providerMethod.getReturnType().getDeclaredMethod(\"getAnonymousSubject\");\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(\"No compatible WebSocket version found\", ex);\n\t\t\t}\n\t\t}\n\n\t\tpublic Object getSubject(HttpServletRequest request) {\n\t\t\ttry {\n\t\t\t\tServletContext servletContext = request.getServletContext();\n\t\t\t\tObject securityContext = this.securityContextMethod.invoke(servletContext);\n\t\t\t\tObject subject = this.currentUserMethod.invoke(null, securityContext, request);\n\t\t\t\tif (subject == null) {\n\t\t\t\t\tObject securityProvider = this.providerMethod.invoke(null);\n\t\t\t\t\tsubject = this.anonymousSubjectMethod.invoke(securityProvider);\n\t\t\t\t}\n\t\t\t\treturn subject;\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new HandshakeFailureException(\"Failed to obtain SubjectHandle\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Helps to create and invoke {@code weblogic.websocket.tyrus.TyrusServletWriter}.\n\t */\n\tprivate static class WebLogicServletWriterHelper {\n\n\t\tprivate static final Constructor<?> constructor;\n\n\t\tstatic {\n\t\t\ttry {\n\t\t\t\tClass<?> writerType = type(\"weblogic.websocket.tyrus.TyrusServletWriter\");\n\t\t\t\tClass<?> listenerType = type(\"weblogic.websocket.tyrus.TyrusServletWriter$CloseListener\");\n\t\t\t\tClass<?> webSocketType = TyrusMuxableWebSocketHelper.type;\n\t\t\t\tconstructor = writerType.getDeclaredConstructor(webSocketType, listenerType, boolean.class);\n\t\t\t\tReflectionUtils.makeAccessible(constructor);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(\"No compatible WebSocket version found\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate Writer newInstance(Object webSocket, boolean isProtected) {\n\t\t\ttry {\n\t\t\t\treturn (Writer) constructor.newInstance(webSocket, null, isProtected);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new HandshakeFailureException(\"Failed to create TyrusServletWriter\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.socket.server.standard.WebLogicRequestUpgradeStrategy#getSubject(request)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "Object",
    "signature": "public Object getSubject(HttpServletRequest request)",
    "source_code": "\t\tpublic Object getSubject(HttpServletRequest request) {\n\t\t\ttry {\n\t\t\t\tServletContext servletContext = request.getServletContext();\n\t\t\t\tObject securityContext = this.securityContextMethod.invoke(servletContext);\n\t\t\t\tObject subject = this.currentUserMethod.invoke(null, securityContext, request);\n\t\t\t\tif (subject == null) {\n\t\t\t\t\tObject securityProvider = this.providerMethod.invoke(null);\n\t\t\t\t\tsubject = this.anonymousSubjectMethod.invoke(securityProvider);\n\t\t\t\t}\n\t\t\t\treturn subject;\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new HandshakeFailureException(\"Failed to obtain SubjectHandle\", ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.socket.server.standard.WebLogicRequestUpgradeStrategy#handleSuccess(request,response,upgradeInfo,upgradeResponse)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "upgradeInfo",
      "upgradeResponse"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "void",
    "signature": "protected void handleSuccess(HttpServletRequest request, HttpServletResponse response,\n\t\t\tUpgradeInfo upgradeInfo, TyrusUpgradeResponse upgradeResponse)",
    "source_code": "\tprotected void handleSuccess(HttpServletRequest request, HttpServletResponse response,"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#forGlassFish()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "RequestUpgradeStrategy",
    "signature": "public RequestUpgradeStrategy forGlassFish()",
    "source_code": "\t\tpublic static RequestUpgradeStrategy forGlassFish() {\n\t\t\treturn new GlassFishRequestUpgradeStrategy();\n\t\t}"
  },
  "org.springframework.web.socket.server.support.AbstractHandshakeHandler#forWebLogic()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 433
    },
    "return": "RequestUpgradeStrategy",
    "signature": "public RequestUpgradeStrategy forWebLogic()",
    "source_code": "\t\tpublic static RequestUpgradeStrategy forWebLogic() {\n\t\t\treturn new WebLogicRequestUpgradeStrategy();\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.client.SockJsClient#getHttpHeaderNames()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * The configured HTTP header names to be copied from the handshake\n\t * headers and also included in other HTTP requests.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "String[]",
    "signature": "public String[] getHttpHeaderNames()",
    "source_code": "\tpublic String[] getHttpHeaderNames() {\n\t\treturn this.httpHeaderNames;\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketClientSockJsSession": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An extension of {@link AbstractClientSockJsSession} wrapping and delegating\n * to an actual WebSocket session.\n *\n * @author Rossen Stoyanchev\n * @since 4.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public class WebSocketClientSockJsSession",
    "source_code": "public class WebSocketClientSockJsSession extends AbstractClientSockJsSession implements NativeWebSocketSession {\n\n\tprivate @Nullable WebSocketSession webSocketSession;\n\n\n\tpublic WebSocketClientSockJsSession(TransportRequest request, WebSocketHandler handler,\n\t\t\tCompletableFuture<WebSocketSession> connectFuture) {\n\n\t\tsuper(request, handler, connectFuture);\n\t}\n\n\n\t@Override\n\tpublic Object getNativeSession() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T> @Nullable T getNativeSession(@Nullable Class<T> requiredType) {\n\t\treturn (requiredType == null || requiredType.isInstance(this.webSocketSession) ? (T) this.webSocketSession : null);\n\t}\n\n\t@Override\n\tpublic @Nullable InetSocketAddress getLocalAddress() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getLocalAddress();\n\t}\n\n\t@Override\n\tpublic @Nullable InetSocketAddress getRemoteAddress() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getRemoteAddress();\n\t}\n\n\t@Override\n\tpublic @Nullable String getAcceptedProtocol() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getAcceptedProtocol();\n\t}\n\n\t@Override\n\tpublic void setTextMessageSizeLimit(int messageSizeLimit) {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\tthis.webSocketSession.setTextMessageSizeLimit(messageSizeLimit);\n\t}\n\n\t@Override\n\tpublic int getTextMessageSizeLimit() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getTextMessageSizeLimit();\n\t}\n\n\t@Override\n\tpublic void setBinaryMessageSizeLimit(int messageSizeLimit) {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\tthis.webSocketSession.setBinaryMessageSizeLimit(messageSizeLimit);\n\t}\n\n\t@Override\n\tpublic int getBinaryMessageSizeLimit() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getBinaryMessageSizeLimit();\n\t}\n\n\t@Override\n\tpublic List<WebSocketExtension> getExtensions() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getExtensions();\n\t}\n\n\tpublic void initializeDelegateSession(WebSocketSession session) {\n\t\tthis.webSocketSession = session;\n\t}\n\n\t@Override\n\tprotected void sendInternal(TextMessage textMessage) throws IOException {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\tthis.webSocketSession.sendMessage(textMessage);\n\t}\n\n\t@Override\n\tprotected void disconnect(CloseStatus status) throws IOException {\n\t\tif (this.webSocketSession != null) {\n\t\t\tthis.webSocketSession.close(status);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketClientSockJsSession#disconnect(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "void",
    "signature": "protected void disconnect(CloseStatus status)",
    "source_code": "\tprotected void disconnect(CloseStatus status) throws IOException {\n\t\tif (this.webSocketSession != null) {\n\t\t\tthis.webSocketSession.close(status);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketClientSockJsSession#getAcceptedProtocol()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "String",
    "signature": "public String getAcceptedProtocol()",
    "source_code": "\tpublic @Nullable String getAcceptedProtocol() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getAcceptedProtocol();\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketClientSockJsSession#getBinaryMessageSizeLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "int",
    "signature": "public int getBinaryMessageSizeLimit()",
    "source_code": "\tpublic int getBinaryMessageSizeLimit() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getBinaryMessageSizeLimit();\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketClientSockJsSession#getExtensions()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "List<WebSocketExtension>",
    "signature": "public List<WebSocketExtension> getExtensions()",
    "source_code": "\tpublic List<WebSocketExtension> getExtensions() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getExtensions();\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketClientSockJsSession#getLocalAddress()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress getLocalAddress()",
    "source_code": "\tpublic @Nullable InetSocketAddress getLocalAddress() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getLocalAddress();\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketClientSockJsSession#getNativeSession()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "Object",
    "signature": "public Object getNativeSession()",
    "source_code": "\tpublic Object getNativeSession() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession;\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketClientSockJsSession#getNativeSession(requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "T",
    "signature": "public T getNativeSession(@Nullable Class<T> requiredType)",
    "source_code": "\tpublic <T> @Nullable T getNativeSession(@Nullable Class<T> requiredType) {\n\t\treturn (requiredType == null || requiredType.isInstance(this.webSocketSession) ? (T) this.webSocketSession : null);\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketClientSockJsSession#getRemoteAddress()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress getRemoteAddress()",
    "source_code": "\tpublic @Nullable InetSocketAddress getRemoteAddress() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getRemoteAddress();\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketClientSockJsSession#getTextMessageSizeLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "int",
    "signature": "public int getTextMessageSizeLimit()",
    "source_code": "\tpublic int getTextMessageSizeLimit() {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\treturn this.webSocketSession.getTextMessageSizeLimit();\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketClientSockJsSession#initializeDelegateSession(session)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void initializeDelegateSession(WebSocketSession session)",
    "source_code": "\tpublic void initializeDelegateSession(WebSocketSession session) {\n\t\tthis.webSocketSession = session;\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketClientSockJsSession#sendInternal(textMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "textMessage"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "void",
    "signature": "protected void sendInternal(TextMessage textMessage)",
    "source_code": "\tprotected void sendInternal(TextMessage textMessage) throws IOException {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\tthis.webSocketSession.sendMessage(textMessage);\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketClientSockJsSession#setBinaryMessageSizeLimit(messageSizeLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSizeLimit"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void setBinaryMessageSizeLimit(int messageSizeLimit)",
    "source_code": "\tpublic void setBinaryMessageSizeLimit(int messageSizeLimit) {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\tthis.webSocketSession.setBinaryMessageSizeLimit(messageSizeLimit);\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.WebSocketClientSockJsSession#setTextMessageSizeLimit(messageSizeLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSizeLimit"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void setTextMessageSizeLimit(int messageSizeLimit)",
    "source_code": "\tpublic void setTextMessageSizeLimit(int messageSizeLimit) {\n\t\tAssert.state(this.webSocketSession != null, \"WebSocketSession not yet initialized\");\n\t\tthis.webSocketSession.setTextMessageSizeLimit(messageSizeLimit);\n\t}"
  },
  "org.springframework.web.socket.sockjs.frame.Jackson2SockJsMessageCodec": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A Jackson 2.x codec for encoding and decoding SockJS messages.\n *\n * <p>It customizes Jackson's default properties with the following ones:\n * <ul>\n * <li>{@link MapperFeature#DEFAULT_VIEW_INCLUSION} is disabled</li>\n * <li>{@link DeserializationFeature#FAIL_ON_UNKNOWN_PROPERTIES} is disabled</li>\n * </ul>\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public class Jackson2SockJsMessageCodec",
    "source_code": "public class Jackson2SockJsMessageCodec extends AbstractSockJsMessageCodec {\n\n\tprivate final ObjectMapper objectMapper;\n\n\n\tpublic Jackson2SockJsMessageCodec() {\n\t\tthis.objectMapper = Jackson2ObjectMapperBuilder.json().build();\n\t}\n\n\tpublic Jackson2SockJsMessageCodec(ObjectMapper objectMapper) {\n\t\tAssert.notNull(objectMapper, \"ObjectMapper must not be null\");\n\t\tthis.objectMapper = objectMapper;\n\t}\n\n\n\t@Override\n\tpublic String @Nullable [] decode(String content) throws IOException {\n\t\treturn this.objectMapper.readValue(content, String[].class);\n\t}\n\n\t@Override\n\tpublic String @Nullable [] decodeInputStream(InputStream content) throws IOException {\n\t\treturn this.objectMapper.readValue(content, String[].class);\n\t}\n\n\t@Override\n\tprotected char[] applyJsonQuoting(String content) {\n\t\treturn JsonStringEncoder.getInstance().quoteAsString(content);\n\t}\n\n}"
  },
  "org.springframework.web.socket.sockjs.frame.Jackson2SockJsMessageCodec#applyJsonQuoting(content)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "content"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "char[]",
    "signature": "protected char[] applyJsonQuoting(String content)",
    "source_code": "\tprotected char[] applyJsonQuoting(String content) {\n\t\treturn JsonStringEncoder.getInstance().quoteAsString(content);\n\t}"
  },
  "org.springframework.web.socket.sockjs.frame.SockJsMessageCodec": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Encode and decode messages to and from a SockJS message frame,\n * essentially an array of JSON-encoded messages. For example:\n *\n * <pre class=\"code\">\n * a[\"message1\",\"message2\"]\n * </pre>\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public interface SockJsMessageCodec",
    "source_code": "public interface SockJsMessageCodec {\n\n\t/**\n\t * Encode the given messages as a SockJS message frame. Aside from applying standard\n\t * JSON quoting to each message, there are some additional JSON Unicode escaping\n\t * rules. See the \"JSON Unicode Encoding\" section of SockJS protocol (i.e. the\n\t * protocol test suite).\n\t * @param messages the messages to encode\n\t * @return the content for a SockJS message frame (never {@code null})\n\t */\n\tString encode(String... messages);\n\n\t/**\n\t * Decode the given SockJS message frame.\n\t * @param content the SockJS message frame\n\t * @return an array of messages, or {@code null} if none\n\t * @throws IOException if the content could not be parsed\n\t */\n\tString @Nullable [] decode(String content) throws IOException;\n\n\t/**\n\t * Decode the given SockJS message frame.\n\t * @param content the SockJS message frame\n\t * @return an array of messages, or {@code null} if none\n\t * @throws IOException if the content could not be parsed\n\t */\n\tString @Nullable [] decodeInputStream(InputStream content) throws IOException;\n\n}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.AbstractHttpReceivingTransportHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Base class for HTTP transport handlers that receive messages via HTTP POST.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class AbstractHttpReceivingTransportHandler",
    "source_code": "public abstract class AbstractHttpReceivingTransportHandler extends AbstractTransportHandler {\n\n\t@Override\n\tpublic boolean checkSessionType(SockJsSession session) {\n\t\treturn (session instanceof AbstractHttpSockJsSession);\n\t}\n\n\t@Override\n\tpublic final void handleRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, SockJsSession wsSession) throws SockJsException {\n\n\t\tAssert.notNull(wsSession, \"No session\");\n\t\tAbstractHttpSockJsSession sockJsSession = (AbstractHttpSockJsSession) wsSession;\n\n\t\thandleRequestInternal(request, response, wsHandler, sockJsSession);\n\t}\n\n\tprotected void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, AbstractHttpSockJsSession sockJsSession) throws SockJsException {\n\n\t\tString[] messages;\n\t\ttry {\n\t\t\tmessages = readMessages(request);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tlogger.error(\"Failed to read message\", ex);\n\t\t\tif (ex.getClass().getName().contains(\"Mapping\")) {\n\t\t\t\t// for example, Jackson's JsonMappingException, indicating an incomplete payload\n\t\t\t\thandleReadError(response, \"Payload expected.\", sockJsSession.getId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\thandleReadError(response, \"Broken JSON encoding.\", sockJsSession.getId());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tlogger.error(\"Failed to read message\", ex);\n\t\t\thandleReadError(response, \"Failed to read message(s)\", sockJsSession.getId());\n\t\t\treturn;\n\t\t}\n\t\tif (messages == null) {\n\t\t\thandleReadError(response, \"Payload expected.\", sockJsSession.getId());\n\t\t\treturn;\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Received message(s): \" + Arrays.toString(messages));\n\t\t}\n\t\tresponse.setStatusCode(getResponseStatus());\n\t\tresponse.getHeaders().setContentType(new MediaType(\"text\", \"plain\", StandardCharsets.UTF_8));\n\n\t\tsockJsSession.delegateMessages(messages);\n\t}\n\n\tprivate void handleReadError(ServerHttpResponse response, String error, String sessionId) {\n\t\ttry {\n\t\t\tresponse.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);\n\t\t\tresponse.getBody().write(error.getBytes(StandardCharsets.UTF_8));\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new SockJsException(\"Failed to send error: \" + error, sessionId, ex);\n\t\t}\n\t}\n\n\n\tprotected abstract String @Nullable [] readMessages(ServerHttpRequest request) throws IOException;\n\n\tprotected abstract HttpStatusCode getResponseStatus();\n\n}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.AbstractHttpReceivingTransportHandler#checkSessionType(session)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "return": "boolean",
    "signature": "public boolean checkSessionType(SockJsSession session)",
    "source_code": "\tpublic boolean checkSessionType(SockJsSession session) {\n\t\treturn (session instanceof AbstractHttpSockJsSession);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.AbstractHttpReceivingTransportHandler#getResponseStatus()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "HttpStatusCode",
    "signature": "protected HttpStatusCode getResponseStatus()",
    "source_code": "\tprotected abstract HttpStatusCode getResponseStatus();"
  },
  "org.springframework.web.socket.sockjs.transport.handler.AbstractHttpReceivingTransportHandler#handleRequest(request,response,wsHandler,wsSession)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "wsHandler",
      "wsSession"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "return": "void",
    "signature": "public void handleRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, SockJsSession wsSession)",
    "source_code": "\tpublic final void handleRequest(ServerHttpRequest request, ServerHttpResponse response,"
  },
  "org.springframework.web.socket.sockjs.transport.handler.AbstractHttpReceivingTransportHandler#handleRequestInternal(request,response,wsHandler,sockJsSession)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "wsHandler",
      "sockJsSession"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "protected void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, AbstractHttpSockJsSession sockJsSession)",
    "source_code": "\tprotected void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,"
  },
  "org.springframework.web.socket.sockjs.transport.handler.XhrReceivingTransportHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@link TransportHandler} that receives messages over HTTP.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class XhrReceivingTransportHandler",
    "source_code": "public class XhrReceivingTransportHandler extends AbstractHttpReceivingTransportHandler {\n\n\t@Override\n\tpublic TransportType getTransportType() {\n\t\treturn TransportType.XHR_SEND;\n\t}\n\n\t@Override\n\tprotected String @Nullable [] readMessages(ServerHttpRequest request) throws IOException {\n\t\treturn getServiceConfig().getMessageCodec().decodeInputStream(request.getBody());\n\t}\n\n\t@Override\n\tprotected HttpStatusCode getResponseStatus() {\n\t\treturn HttpStatus.NO_CONTENT;\n\t}\n\n}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.XhrReceivingTransportHandler#getResponseStatus()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "HttpStatusCode",
    "signature": "protected HttpStatusCode getResponseStatus()",
    "source_code": "\tprotected HttpStatusCode getResponseStatus() {\n\t\treturn HttpStatus.NO_CONTENT;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.XhrReceivingTransportHandler#getTransportType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 38
    },
    "return": "TransportType",
    "signature": "public TransportType getTransportType()",
    "source_code": "\tpublic TransportType getTransportType() {\n\t\treturn TransportType.XHR_SEND;\n\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code UriBuilderFactory} that relies on {@link UriComponentsBuilder} for\n * the actual building of the URI.\n *\n * <p>Provides options to create {@link UriBuilder} instances with a common\n * base URI, alternative encoding mode strategies, among others.\n *\n * @author Rossen Stoyanchev\n * @since 5.0\n * @see UriComponentsBuilder\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class DefaultUriBuilderFactory",
    "source_code": "public class DefaultUriBuilderFactory implements UriBuilderFactory {\n\n\tprivate final @Nullable UriComponentsBuilder baseUri;\n\n\tprivate UriComponentsBuilder.@Nullable ParserType parserType;\n\n\tprivate EncodingMode encodingMode = EncodingMode.TEMPLATE_AND_VALUES;\n\n\tprivate @Nullable Map<String, @Nullable Object> defaultUriVariables;\n\n\tprivate boolean parsePath = true;\n\n\n\t/**\n\t * Default constructor without a base URI.\n\t * <p>The target address must be specified on each UriBuilder.\n\t */\n\tpublic DefaultUriBuilderFactory() {\n\t\tthis.baseUri = null;\n\t}\n\n\t/**\n\t * Constructor with a base URI.\n\t * <p>The given URI template is parsed via\n\t * {@link UriComponentsBuilder#fromUriString} and then applied as a base URI\n\t * to every UriBuilder via {@link UriComponentsBuilder#uriComponents} unless\n\t * the UriBuilder itself was created with a URI template that already has a\n\t * target address.\n\t * @param baseUriTemplate the URI template to use a base URL\n\t */\n\tpublic DefaultUriBuilderFactory(String baseUriTemplate) {\n\t\tthis.baseUri = UriComponentsBuilder.fromUriString(baseUriTemplate);\n\t}\n\n\t/**\n\t * Variant of {@link #DefaultUriBuilderFactory(String)} with a\n\t * {@code UriComponentsBuilder}.\n\t */\n\tpublic DefaultUriBuilderFactory(UriComponentsBuilder baseUri) {\n\t\tthis.baseUri = baseUri;\n\t}\n\n\n\t/**\n\t * Determine whether this factory has been configured with a base URI.\n\t * @since 6.1.4\n\t * @see #DefaultUriBuilderFactory()\n\t */\n\tpublic final boolean hasBaseUri() {\n\t\treturn (this.baseUri != null);\n\t}\n\n\t/**\n\t * Set the {@link UriComponentsBuilder.ParserType} to use.\n\t * <p>By default, {@link UriComponentsBuilder} uses the\n\t * {@link UriComponentsBuilder.ParserType#RFC parser type}.\n\t * @param parserType the parser type\n\t * @since 6.2\n\t * @see UriComponentsBuilder.ParserType\n\t * @see UriComponentsBuilder#fromUriString(String, UriComponentsBuilder.ParserType)\n\t */\n\tpublic void setParserType(UriComponentsBuilder.ParserType parserType) {\n\t\tthis.parserType = parserType;\n\t}\n\n\t/**\n\t * Return the configured parser type.\n\t * @since 6.2\n\t */\n\tpublic UriComponentsBuilder.@Nullable ParserType getParserType() {\n\t\treturn this.parserType;\n\t}\n\n\t/**\n\t * Set the {@link EncodingMode encoding mode} to use.\n\t * <p>By default this is set to {@link EncodingMode#TEMPLATE_AND_VALUES\n\t * EncodingMode.TEMPLATE_AND_VALUES}.\n\t * <p><strong>Note:</strong> Prior to 5.1 the default was\n\t * {@link EncodingMode#URI_COMPONENT EncodingMode.URI_COMPONENT}\n\t * therefore the {@code WebClient} {@code RestTemplate} have switched their\n\t * default behavior.\n\t * @param encodingMode the encoding mode to use\n\t */\n\tpublic void setEncodingMode(EncodingMode encodingMode) {\n\t\tthis.encodingMode = encodingMode;\n\t}\n\n\t/**\n\t * Return the configured encoding mode.\n\t */\n\tpublic EncodingMode getEncodingMode() {\n\t\treturn this.encodingMode;\n\t}\n\n\t/**\n\t * Provide default URI variable values to use when expanding URI templates\n\t * with a Map of variables.\n\t * @param defaultUriVariables default URI variable values\n\t */\n\t@SuppressWarnings(\"NullAway\") // https://github.com/uber/NullAway/issues/1126\n\tpublic void setDefaultUriVariables(@Nullable Map<String, ? extends @Nullable Object> defaultUriVariables) {\n\t\tif (defaultUriVariables != null) {\n\t\t\tif (this.defaultUriVariables == null) {\n\t\t\t\tthis.defaultUriVariables = new HashMap<>(defaultUriVariables);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.defaultUriVariables.putAll(defaultUriVariables);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (this.defaultUriVariables != null) {\n\t\t\t\tthis.defaultUriVariables.clear();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return the configured default URI variable values.\n\t */\n\tpublic Map<String, ?> getDefaultUriVariables() {\n\t\tif (this.defaultUriVariables != null) {\n\t\t\treturn Collections.unmodifiableMap(this.defaultUriVariables);\n\t\t}\n\t\telse {\n\t\t\treturn Collections.emptyMap();\n\t\t}\n\t}\n\n\t/**\n\t * Whether to parse the input path into path segments if the encoding mode\n\t * is set to {@link EncodingMode#URI_COMPONENT EncodingMode.URI_COMPONENT},\n\t * which ensures that URI variables in the path are encoded according to\n\t * path segment rules and for example a '/' is encoded.\n\t * <p>By default this is set to {@code true}.\n\t * @param parsePath whether to parse the path into path segments\n\t */\n\tpublic void setParsePath(boolean parsePath) {\n\t\tthis.parsePath = parsePath;\n\t}\n\n\t/**\n\t * Whether to parse the path into path segments if the encoding mode is set\n\t * to {@link EncodingMode#URI_COMPONENT EncodingMode.URI_COMPONENT}.\n\t */\n\tpublic boolean shouldParsePath() {\n\t\treturn this.parsePath;\n\t}\n\n\n\t// UriTemplateHandler\n\n\t@Override\n\tpublic URI expand(String uriTemplate, Map<String, ? extends @Nullable Object> uriVars) {\n\t\treturn uriString(uriTemplate).build(uriVars);\n\t}\n\n\t@Override\n\tpublic URI expand(String uriTemplate, @Nullable Object... uriVars) {\n\t\treturn uriString(uriTemplate).build(uriVars);\n\t}\n\n\t// UriBuilderFactory\n\n\t@Override\n\tpublic UriBuilder uriString(String uriTemplate) {\n\t\treturn new DefaultUriBuilder(uriTemplate);\n\t}\n\n\t@Override\n\tpublic UriBuilder builder() {\n\t\treturn new DefaultUriBuilder(\"\");\n\t}\n\n\n\t/**\n\t * Enum to represent multiple URI encoding strategies. The following are\n\t * available:\n\t * <ul>\n\t * <li>{@link #TEMPLATE_AND_VALUES}\n\t * <li>{@link #VALUES_ONLY}\n\t * <li>{@link #URI_COMPONENT}\n\t * <li>{@link #NONE}\n\t * </ul>\n\t * @see #setEncodingMode\n\t */\n\tpublic enum EncodingMode {\n\n\t\t/**\n\t\t * Pre-encode the URI template first, then strictly encode URI variables\n\t\t * when expanded, with the following rules:\n\t\t * <ul>\n\t\t * <li>For the URI template replace <em>only</em> non-ASCII and illegal\n\t\t * (within a given URI component type) characters with escaped octets.\n\t\t * <li>For URI variables do the same and also replace characters with\n\t\t * reserved meaning.\n\t\t * </ul>\n\t\t * <p>For most cases, this mode is most likely to give the expected\n\t\t * result because in treats URI variables as opaque data to be fully\n\t\t * encoded, while {@link #URI_COMPONENT} by comparison is useful only\n\t\t * if intentionally expanding URI variables with reserved characters.\n\t\t * @since 5.0.8\n\t\t * @see UriComponentsBuilder#encode()\n\t\t */\n\t\tTEMPLATE_AND_VALUES,\n\n\t\t/**\n\t\t * Does not encode the URI template and instead applies strict encoding\n\t\t * to URI variables via {@link UriUtils#encodeUriVariables} prior to\n\t\t * expanding them into the template.\n\t\t * @see UriUtils#encodeUriVariables(Object...)\n\t\t * @see UriUtils#encodeUriVariables(Map)\n\t\t */\n\t\tVALUES_ONLY,\n\n\t\t/**\n\t\t * Expand URI variables first, and then encode the resulting URI\n\t\t * component values, replacing <em>only</em> non-ASCII and illegal\n\t\t * (within a given URI component type) characters, but not characters\n\t\t * with reserved meaning.\n\t\t * @see UriComponents#encode()\n\t\t */\n\t\tURI_COMPONENT,\n\n\t\t/**\n\t\t * No encoding should be applied.\n\t\t */\n\t\tNONE\n\t}\n\n\n\t/**\n\t * {@link DefaultUriBuilderFactory} specific implementation of UriBuilder.\n\t */\n\tprivate class DefaultUriBuilder implements UriBuilder {\n\n\t\tprivate final UriComponentsBuilder uriComponentsBuilder;\n\n\t\tpublic DefaultUriBuilder(String uriTemplate) {\n\t\t\tthis.uriComponentsBuilder = initUriComponentsBuilder(uriTemplate);\n\t\t}\n\n\t\tprivate UriComponentsBuilder initUriComponentsBuilder(String uriTemplate) {\n\t\t\tUriComponentsBuilder result;\n\t\t\tif (!StringUtils.hasLength(uriTemplate)) {\n\t\t\t\tresult = (baseUri != null ? baseUri.cloneBuilder() : UriComponentsBuilder.newInstance());\n\t\t\t}\n\t\t\telse if (baseUri != null) {\n\t\t\t\tUriComponentsBuilder builder = parseUri(uriTemplate);\n\t\t\t\tUriComponents uri = builder.build();\n\t\t\t\tresult = (uri.getHost() == null ? baseUri.cloneBuilder().uriComponents(uri) : builder);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = parseUri(uriTemplate);\n\t\t\t}\n\t\t\tif (encodingMode.equals(EncodingMode.TEMPLATE_AND_VALUES)) {\n\t\t\t\tresult.encode();\n\t\t\t}\n\t\t\tparsePathIfNecessary(result);\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate UriComponentsBuilder parseUri(String uriTemplate) {\n\t\t\treturn (getParserType() != null ?\n\t\t\t\t\tUriComponentsBuilder.fromUriString(uriTemplate, getParserType()) :\n\t\t\t\t\tUriComponentsBuilder.fromUriString(uriTemplate));\n\t\t}\n\n\t\tprivate void parsePathIfNecessary(UriComponentsBuilder result) {\n\t\t\tif (parsePath && encodingMode.equals(EncodingMode.URI_COMPONENT)) {\n\t\t\t\tUriComponents uric = result.build();\n\t\t\t\tString path = uric.getPath();\n\t\t\t\tresult.replacePath(null);\n\t\t\t\tfor (String segment : uric.getPathSegments()) {\n\t\t\t\t\tresult.pathSegment(segment);\n\t\t\t\t}\n\t\t\t\tif (path != null && path.endsWith(\"/\")) {\n\t\t\t\t\tresult.path(\"/\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t@Override\n\t\tpublic DefaultUriBuilder scheme(@Nullable String scheme) {\n\t\t\tthis.uriComponentsBuilder.scheme(scheme);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultUriBuilder userInfo(@Nullable String userInfo) {\n\t\t\tthis.uriComponentsBuilder.userInfo(userInfo);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultUriBuilder host(@Nullable String host) {\n\t\t\tthis.uriComponentsBuilder.host(host);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultUriBuilder port(int port) {\n\t\t\tthis.uriComponentsBuilder.port(port);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultUriBuilder port(@Nullable String port) {\n\t\t\tthis.uriComponentsBuilder.port(port);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultUriBuilder path(String path) {\n\t\t\tthis.uriComponentsBuilder.path(path);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultUriBuilder replacePath(@Nullable String path) {\n\t\t\tthis.uriComponentsBuilder.replacePath(path);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultUriBuilder pathSegment(String... pathSegments) {\n\t\t\tthis.uriComponentsBuilder.pathSegment(pathSegments);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultUriBuilder query(String query) {\n\t\t\tthis.uriComponentsBuilder.query(query);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultUriBuilder replaceQuery(@Nullable String query) {\n\t\t\tthis.uriComponentsBuilder.replaceQuery(query);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultUriBuilder queryParam(String name, Object... values) {\n\t\t\tthis.uriComponentsBuilder.queryParam(name, values);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultUriBuilder queryParam(String name, @Nullable Collection<?> values) {\n\t\t\tthis.uriComponentsBuilder.queryParam(name, values);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultUriBuilder queryParamIfPresent(String name, Optional<?> value) {\n\t\t\tthis.uriComponentsBuilder.queryParamIfPresent(name, value);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultUriBuilder queryParams(MultiValueMap<String, String> params) {\n\t\t\tthis.uriComponentsBuilder.queryParams(params);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultUriBuilder replaceQueryParam(String name, Object... values) {\n\t\t\tthis.uriComponentsBuilder.replaceQueryParam(name, values);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultUriBuilder replaceQueryParam(String name, @Nullable Collection<?> values) {\n\t\t\tthis.uriComponentsBuilder.replaceQueryParam(name, values);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultUriBuilder replaceQueryParams(MultiValueMap<String, String> params) {\n\t\t\tthis.uriComponentsBuilder.replaceQueryParams(params);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultUriBuilder fragment(@Nullable String fragment) {\n\t\t\tthis.uriComponentsBuilder.fragment(fragment);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings(\"NullAway\") // https://github.com/uber/NullAway/issues/1126\n\t\tpublic URI build(Map<String, ?> uriVars) {\n\t\t\tif (!CollectionUtils.isEmpty(defaultUriVariables)) {\n\t\t\t\tMap<String, Object> map = new HashMap<>(defaultUriVariables.size() + uriVars.size());\n\t\t\t\tmap.putAll(defaultUriVariables);\n\t\t\t\tmap.putAll(uriVars);\n\t\t\t\turiVars = map;\n\t\t\t}\n\t\t\tif (encodingMode.equals(EncodingMode.VALUES_ONLY)) {\n\t\t\t\turiVars = UriUtils.encodeUriVariables(uriVars);\n\t\t\t}\n\t\t\tUriComponents uric = this.uriComponentsBuilder.build().expand(uriVars);\n\t\t\treturn createUri(uric);\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings(\"NullAway\") // https://github.com/uber/NullAway/issues/1126\n\t\tpublic URI build(@Nullable Object... uriVars) {\n\t\t\tif (ObjectUtils.isEmpty(uriVars) && !CollectionUtils.isEmpty(defaultUriVariables)) {\n\t\t\t\treturn build(Collections.emptyMap());\n\t\t\t}\n\t\t\tif (encodingMode.equals(EncodingMode.VALUES_ONLY)) {\n\t\t\t\turiVars = UriUtils.encodeUriVariables(uriVars);\n\t\t\t}\n\t\t\tUriComponents uric = this.uriComponentsBuilder.build().expand(uriVars);\n\t\t\treturn createUri(uric);\n\t\t}\n\n\t\tprivate URI createUri(UriComponents uric) {\n\t\t\tif (encodingMode.equals(EncodingMode.URI_COMPONENT)) {\n\t\t\t\turic = uric.encode();\n\t\t\t}\n\t\t\treturn URI.create(uric.toString());\n\t\t}\n\n\t\t@Override\n\t\tpublic String toUriString() {\n\t\t\treturn this.uriComponentsBuilder.build().toUriString();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#build(Map<String,uriVars)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVars"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "URI",
    "signature": "public URI build(Map<String, ?> uriVars)",
    "source_code": "\t\tpublic URI build(Map<String, ?> uriVars) {\n\t\t\tif (!CollectionUtils.isEmpty(defaultUriVariables)) {\n\t\t\t\tMap<String, Object> map = new HashMap<>(defaultUriVariables.size() + uriVars.size());\n\t\t\t\tmap.putAll(defaultUriVariables);\n\t\t\t\tmap.putAll(uriVars);\n\t\t\t\turiVars = map;\n\t\t\t}\n\t\t\tif (encodingMode.equals(EncodingMode.VALUES_ONLY)) {\n\t\t\t\turiVars = UriUtils.encodeUriVariables(uriVars);\n\t\t\t}\n\t\t\tUriComponents uric = this.uriComponentsBuilder.build().expand(uriVars);\n\t\t\treturn createUri(uric);\n\t\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#build(uriVars)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriVars"
    ],
    "position": {
      "column": 1,
      "line": 452
    },
    "return": "URI",
    "signature": "public URI build(@Nullable Object... uriVars)",
    "source_code": "\t\tpublic URI build(@Nullable Object... uriVars) {\n\t\t\tif (ObjectUtils.isEmpty(uriVars) && !CollectionUtils.isEmpty(defaultUriVariables)) {\n\t\t\t\treturn build(Collections.emptyMap());\n\t\t\t}\n\t\t\tif (encodingMode.equals(EncodingMode.VALUES_ONLY)) {\n\t\t\t\turiVars = UriUtils.encodeUriVariables(uriVars);\n\t\t\t}\n\t\t\tUriComponents uric = this.uriComponentsBuilder.build().expand(uriVars);\n\t\t\treturn createUri(uric);\n\t\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#builder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "UriBuilder",
    "signature": "public UriBuilder builder()",
    "source_code": "\tpublic UriBuilder builder() {\n\t\treturn new DefaultUriBuilder(\"\");\n\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#expand(uriTemplate,Map<String,uriVars)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Map<String",
      "uriVars"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "URI",
    "signature": "public URI expand(String uriTemplate, Map<String, ? extends @Nullable Object> uriVars)",
    "source_code": "\tpublic URI expand(String uriTemplate, Map<String, ? extends @Nullable Object> uriVars) {\n\t\treturn uriString(uriTemplate).build(uriVars);\n\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#expand(uriTemplate,uriVars)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVars"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "URI",
    "signature": "public URI expand(String uriTemplate, @Nullable Object... uriVars)",
    "source_code": "\tpublic URI expand(String uriTemplate, @Nullable Object... uriVars) {\n\t\treturn uriString(uriTemplate).build(uriVars);\n\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#fragment(fragment)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fragment"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "DefaultUriBuilder",
    "signature": "public DefaultUriBuilder fragment(@Nullable String fragment)",
    "source_code": "\t\tpublic DefaultUriBuilder fragment(@Nullable String fragment) {\n\t\t\tthis.uriComponentsBuilder.fragment(fragment);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#getEncodingMode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured encoding mode.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "EncodingMode",
    "signature": "public EncodingMode getEncodingMode()",
    "source_code": "\tpublic EncodingMode getEncodingMode() {\n\t\treturn this.encodingMode;\n\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#hasBaseUri()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether this factory has been configured with a base URI.\n\t * @since 6.1.4\n\t * @see #DefaultUriBuilderFactory()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "boolean",
    "signature": "public boolean hasBaseUri()",
    "source_code": "\tpublic final boolean hasBaseUri() {\n\t\treturn (this.baseUri != null);\n\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#host(host)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "host"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "DefaultUriBuilder",
    "signature": "public DefaultUriBuilder host(@Nullable String host)",
    "source_code": "\t\tpublic DefaultUriBuilder host(@Nullable String host) {\n\t\t\tthis.uriComponentsBuilder.host(host);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#path(path)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "DefaultUriBuilder",
    "signature": "public DefaultUriBuilder path(String path)",
    "source_code": "\t\tpublic DefaultUriBuilder path(String path) {\n\t\t\tthis.uriComponentsBuilder.path(path);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#pathSegment(pathSegments)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathSegments"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "DefaultUriBuilder",
    "signature": "public DefaultUriBuilder pathSegment(String... pathSegments)",
    "source_code": "\t\tpublic DefaultUriBuilder pathSegment(String... pathSegments) {\n\t\t\tthis.uriComponentsBuilder.pathSegment(pathSegments);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#port(port)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "port"
    ],
    "position": {
      "column": 1,
      "line": 351
    },
    "return": "DefaultUriBuilder",
    "signature": "public DefaultUriBuilder port(@Nullable String port)",
    "source_code": "\t\tpublic DefaultUriBuilder port(@Nullable String port) {\n\t\t\tthis.uriComponentsBuilder.port(port);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#query(query)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "query"
    ],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "DefaultUriBuilder",
    "signature": "public DefaultUriBuilder query(String query)",
    "source_code": "\t\tpublic DefaultUriBuilder query(String query) {\n\t\t\tthis.uriComponentsBuilder.query(query);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#queryParam(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 393
    },
    "return": "DefaultUriBuilder",
    "signature": "public DefaultUriBuilder queryParam(String name, @Nullable Collection<?> values)",
    "source_code": "\t\tpublic DefaultUriBuilder queryParam(String name, @Nullable Collection<?> values) {\n\t\t\tthis.uriComponentsBuilder.queryParam(name, values);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#queryParamIfPresent(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 399
    },
    "return": "DefaultUriBuilder",
    "signature": "public DefaultUriBuilder queryParamIfPresent(String name, Optional<?> value)",
    "source_code": "\t\tpublic DefaultUriBuilder queryParamIfPresent(String name, Optional<?> value) {\n\t\t\tthis.uriComponentsBuilder.queryParamIfPresent(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#queryParams(MultiValueMap<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 405
    },
    "return": "DefaultUriBuilder",
    "signature": "public DefaultUriBuilder queryParams(MultiValueMap<String, String> params)",
    "source_code": "\t\tpublic DefaultUriBuilder queryParams(MultiValueMap<String, String> params) {\n\t\t\tthis.uriComponentsBuilder.queryParams(params);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#replacePath(path)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "DefaultUriBuilder",
    "signature": "public DefaultUriBuilder replacePath(@Nullable String path)",
    "source_code": "\t\tpublic DefaultUriBuilder replacePath(@Nullable String path) {\n\t\t\tthis.uriComponentsBuilder.replacePath(path);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#replaceQuery(query)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "query"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "DefaultUriBuilder",
    "signature": "public DefaultUriBuilder replaceQuery(@Nullable String query)",
    "source_code": "\t\tpublic DefaultUriBuilder replaceQuery(@Nullable String query) {\n\t\t\tthis.uriComponentsBuilder.replaceQuery(query);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#replaceQueryParam(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "DefaultUriBuilder",
    "signature": "public DefaultUriBuilder replaceQueryParam(String name, @Nullable Collection<?> values)",
    "source_code": "\t\tpublic DefaultUriBuilder replaceQueryParam(String name, @Nullable Collection<?> values) {\n\t\t\tthis.uriComponentsBuilder.replaceQueryParam(name, values);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#replaceQueryParams(MultiValueMap<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 423
    },
    "return": "DefaultUriBuilder",
    "signature": "public DefaultUriBuilder replaceQueryParams(MultiValueMap<String, String> params)",
    "source_code": "\t\tpublic DefaultUriBuilder replaceQueryParams(MultiValueMap<String, String> params) {\n\t\t\tthis.uriComponentsBuilder.replaceQueryParams(params);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#scheme(scheme)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scheme"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "DefaultUriBuilder",
    "signature": "public DefaultUriBuilder scheme(@Nullable String scheme)",
    "source_code": "\t\tpublic DefaultUriBuilder scheme(@Nullable String scheme) {\n\t\t\tthis.uriComponentsBuilder.scheme(scheme);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#setDefaultUriVariables(Map<String,defaultUriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide default URI variable values to use when expanding URI templates\n\t * with a Map of variables.\n\t * @param defaultUriVariables default URI variable values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "defaultUriVariables"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "void",
    "signature": "public void setDefaultUriVariables(@Nullable Map<String, ? extends @Nullable Object> defaultUriVariables)",
    "source_code": "\tpublic void setDefaultUriVariables(@Nullable Map<String, ? extends @Nullable Object> defaultUriVariables) {\n\t\tif (defaultUriVariables != null) {\n\t\t\tif (this.defaultUriVariables == null) {\n\t\t\t\tthis.defaultUriVariables = new HashMap<>(defaultUriVariables);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.defaultUriVariables.putAll(defaultUriVariables);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (this.defaultUriVariables != null) {\n\t\t\t\tthis.defaultUriVariables.clear();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#setEncodingMode(encodingMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link EncodingMode encoding mode} to use.\n\t * <p>By default this is set to {@link EncodingMode#TEMPLATE_AND_VALUES\n\t * EncodingMode.TEMPLATE_AND_VALUES}.\n\t * <p><strong>Note:</strong> Prior to 5.1 the default was\n\t * {@link EncodingMode#URI_COMPONENT EncodingMode.URI_COMPONENT}\n\t * therefore the {@code WebClient} {@code RestTemplate} have switched their\n\t * default behavior.\n\t * @param encodingMode the encoding mode to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encodingMode"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void setEncodingMode(EncodingMode encodingMode)",
    "source_code": "\tpublic void setEncodingMode(EncodingMode encodingMode) {\n\t\tthis.encodingMode = encodingMode;\n\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#setParsePath(parsePath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to parse the input path into path segments if the encoding mode\n\t * is set to {@link EncodingMode#URI_COMPONENT EncodingMode.URI_COMPONENT},\n\t * which ensures that URI variables in the path are encoded according to\n\t * path segment rules and for example a '/' is encoded.\n\t * <p>By default this is set to {@code true}.\n\t * @param parsePath whether to parse the path into path segments\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parsePath"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "void",
    "signature": "public void setParsePath(boolean parsePath)",
    "source_code": "\tpublic void setParsePath(boolean parsePath) {\n\t\tthis.parsePath = parsePath;\n\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#setParserType(parserType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link UriComponentsBuilder.ParserType} to use.\n\t * <p>By default, {@link UriComponentsBuilder} uses the\n\t * {@link UriComponentsBuilder.ParserType#RFC parser type}.\n\t * @param parserType the parser type\n\t * @since 6.2\n\t * @see UriComponentsBuilder.ParserType\n\t * @see UriComponentsBuilder#fromUriString(String, UriComponentsBuilder.ParserType)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parserType"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void setParserType(UriComponentsBuilder.ParserType parserType)",
    "source_code": "\tpublic void setParserType(UriComponentsBuilder.ParserType parserType) {\n\t\tthis.parserType = parserType;\n\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#shouldParsePath()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to parse the path into path segments if the encoding mode is set\n\t * to {@link EncodingMode#URI_COMPONENT EncodingMode.URI_COMPONENT}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "boolean",
    "signature": "public boolean shouldParsePath()",
    "source_code": "\tpublic boolean shouldParsePath() {\n\t\treturn this.parsePath;\n\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#toUriString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "String",
    "signature": "public String toUriString()",
    "source_code": "\t\tpublic String toUriString() {\n\t\t\treturn this.uriComponentsBuilder.build().toUriString();\n\t\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#uriString(uriTemplate)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "UriBuilder",
    "signature": "public UriBuilder uriString(String uriTemplate)",
    "source_code": "\tpublic UriBuilder uriString(String uriTemplate) {\n\t\treturn new DefaultUriBuilder(uriTemplate);\n\t}"
  },
  "org.springframework.web.util.DefaultUriBuilderFactory#userInfo(userInfo)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userInfo"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "DefaultUriBuilder",
    "signature": "public DefaultUriBuilder userInfo(@Nullable String userInfo)",
    "source_code": "\t\tpublic DefaultUriBuilder userInfo(@Nullable String userInfo) {\n\t\t\tthis.uriComponentsBuilder.userInfo(userInfo);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.util.EncodingMode": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Enum to represent multiple URI encoding strategies. The following are\n\t * available:\n\t * <ul>\n\t * <li>{@link #TEMPLATE_AND_VALUES}\n\t * <li>{@link #VALUES_ONLY}\n\t * <li>{@link #URI_COMPONENT}\n\t * <li>{@link #NONE}\n\t * </ul>\n\t * @see #setEncodingMode\n\t */",
    "kind": "enum",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "signature": "public enum EncodingMode",
    "source_code": "\tpublic enum EncodingMode {\n\n\t\t/**\n\t\t * Pre-encode the URI template first, then strictly encode URI variables\n\t\t * when expanded, with the following rules:\n\t\t * <ul>\n\t\t * <li>For the URI template replace <em>only</em> non-ASCII and illegal\n\t\t * (within a given URI component type) characters with escaped octets.\n\t\t * <li>For URI variables do the same and also replace characters with\n\t\t * reserved meaning.\n\t\t * </ul>\n\t\t * <p>For most cases, this mode is most likely to give the expected\n\t\t * result because in treats URI variables as opaque data to be fully\n\t\t * encoded, while {@link #URI_COMPONENT} by comparison is useful only\n\t\t * if intentionally expanding URI variables with reserved characters.\n\t\t * @since 5.0.8\n\t\t * @see UriComponentsBuilder#encode()\n\t\t */\n\t\tTEMPLATE_AND_VALUES,\n\n\t\t/**\n\t\t * Does not encode the URI template and instead applies strict encoding\n\t\t * to URI variables via {@link UriUtils#encodeUriVariables} prior to\n\t\t * expanding them into the template.\n\t\t * @see UriUtils#encodeUriVariables(Object...)\n\t\t * @see UriUtils#encodeUriVariables(Map)\n\t\t */\n\t\tVALUES_ONLY,\n\n\t\t/**\n\t\t * Expand URI variables first, and then encode the resulting URI\n\t\t * component values, replacing <em>only</em> non-ASCII and illegal\n\t\t * (within a given URI component type) characters, but not characters\n\t\t * with reserved meaning.\n\t\t * @see UriComponents#encode()\n\t\t */\n\t\tURI_COMPONENT,\n\n\t\t/**\n\t\t * No encoding should be applied.\n\t\t */\n\t\tNONE\n\t}"
  },
  "org.springframework.web.util.UriBuilder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Builder-style methods to prepare and expand a URI template with variables.\n *\n * <p>Effectively a generalization of {@link UriComponentsBuilder} but with\n * shortcuts to expand directly into {@link URI} rather than\n * {@link UriComponents} and also leaving common concerns such as encoding\n * preferences, a base URI, and others as implementation concerns.\n *\n * <p>Typically obtained via {@link UriBuilderFactory} which serves as a central\n * component configured once and used to create many URLs.\n *\n * @author Rossen Stoyanchev\n * @since 5.0\n * @see UriBuilderFactory\n * @see UriComponentsBuilder\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public interface UriBuilder",
    "source_code": "public interface UriBuilder {\n\n\t/**\n\t * Set the URI scheme which may contain URI template variables,\n\t * and may also be {@code null} to clear the scheme of this builder.\n\t * @param scheme the URI scheme\n\t */\n\tUriBuilder scheme(@Nullable String scheme);\n\n\t/**\n\t * Set the URI user info which may contain URI template variables, and\n\t * may also be {@code null} to clear the user info of this builder.\n\t * @param userInfo the URI user info\n\t */\n\tUriBuilder userInfo(@Nullable String userInfo);\n\n\t/**\n\t * Set the URI host which may contain URI template variables, and may also\n\t * be {@code null} to clear the host of this builder.\n\t * @param host the URI host\n\t */\n\tUriBuilder host(@Nullable String host);\n\n\t/**\n\t * Set the URI port. Passing {@code -1} will clear the port of this builder.\n\t * @param port the URI port\n\t */\n\tUriBuilder port(int port);\n\n\t/**\n\t * Set the URI port. Use this method only when the port needs to be\n\t * parameterized with a URI variable. Otherwise use {@link #port(int)}.\n\t * Passing {@code null} will clear the port of this builder.\n\t * @param port the URI port\n\t */\n\tUriBuilder port(@Nullable String port);\n\n\t/**\n\t * Append to the path of this builder.\n\t * <p>The given value is appended as-is to previous {@link #path(String) path}\n\t * values without inserting any additional slashes. For example:\n\t * <pre class=\"code\">\n\t *\n\t * builder.path(\"/first-\").path(\"value/\").path(\"/{id}\").build(\"123\")\n\t *\n\t * // Results is \"/first-value/123\"\n\t * </pre>\n\t * <p>By contrast {@link #pathSegment(String...) pathSegment} does insert\n\t * slashes between individual path segments. For example:\n\t * <pre class=\"code\">\n\t *\n\t * builder.pathSegment(\"first-value\", \"second-value\").path(\"/\")\n\t *\n\t * // Results is \"/first-value/second-value/\"\n\t * </pre>\n\t * <p>The resulting full path is normalized to eliminate duplicate slashes.\n\t * <p><strong>Note:</strong> When inserting a URI variable value that\n\t * contains slashes in a {@link #path(String) path}, whether those are\n\t * encoded depends on the configured encoding mode. For more details, see\n\t * {@link UriComponentsBuilder#encode()}, or otherwise if building URIs\n\t * indirectly via {@code WebClient} or {@code RestTemplate}, see its\n\t * {@link DefaultUriBuilderFactory#setEncodingMode encodingMode}.\n\t * Also see the <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#web-uri-encoding\">\n\t * URI Encoding</a> section of the reference docs.\n\t * @param path the URI path\n\t */\n\tUriBuilder path(String path);\n\n\t/**\n\t * Override the current path.\n\t * @param path the URI path, or {@code null} for an empty path\n\t */\n\tUriBuilder replacePath(@Nullable String path);\n\n\t/**\n\t * Append to the path using path segments. For example:\n\t * <pre class=\"code\">\n\t *\n\t * builder.pathSegment(\"first-value\", \"second-value\", \"{id}\").build(\"123\")\n\t *\n\t * // Results is \"/first-value/second-value/123\"\n\t * </pre>\n\t * <p>If slashes are present in a path segment, they are encoded:\n\t * <pre class=\"code\">\n\t *\n\t * builder.pathSegment(\"ba/z\", \"{id}\").build(\"a/b\")\n\t *\n\t * // Results is \"/ba%2Fz/a%2Fb\"\n\t * </pre>\n\t * To insert a trailing slash, use the {@link #path} builder method:\n\t * <pre class=\"code\">\n\t *\n\t * builder.pathSegment(\"first-value\", \"second-value\").path(\"/\")\n\t *\n\t * // Results is \"/first-value/second-value/\"\n\t * </pre>\n\t * <p>Empty path segments are ignored and therefore duplicate slashes do not\n\t * appear in the resulting full path.\n\t * @param pathSegments the URI path segments\n\t */\n\tUriBuilder pathSegment(String... pathSegments) throws IllegalArgumentException;\n\n\t/**\n\t * Parse the given query string into query parameters where parameters are\n\t * separated with {@code '&'} and their values, if any, with {@code '='}.\n\t * The query may contain URI template variables.\n\t * <p><strong>Note: </strong> please, review the Javadoc of\n\t * {@link #queryParam(String, Object...)} for further notes on the treatment\n\t * and encoding of individual query parameters.\n\t * @param query the query string\n\t */\n\tUriBuilder query(String query);\n\n\t/**\n\t * Clear existing query parameters and then delegate to {@link #query(String)}.\n\t * <p><strong>Note: </strong> please, review the Javadoc of\n\t * {@link #queryParam(String, Object...)} for further notes on the treatment\n\t * and encoding of individual query parameters.\n\t * @param query the query string; a {@code null} value removes all query parameters.\n\t */\n\tUriBuilder replaceQuery(@Nullable String query);\n\n\t/**\n\t * Append the given query parameter. Both the parameter name and values may\n\t * contain URI template variables to be expanded later from values. If no\n\t * values are given, the resulting URI will contain the query parameter name\n\t * only, for example, {@code \"?foo\"} instead of {@code \"?foo=bar\"}.\n\t * <p><strong>Note:</strong> encoding, if applied, will only encode characters\n\t * that are illegal in a query parameter name or value such as {@code \"=\"}\n\t * or {@code \"&\"}. All others that are legal as per syntax rules in\n\t * <a href=\"https://tools.ietf.org/html/rfc3986\">RFC 3986</a> are not\n\t * encoded. This includes {@code \"+\"} which sometimes needs to be encoded\n\t * to avoid its interpretation as an encoded space. Stricter encoding may\n\t * be applied by using a URI template variable along with stricter encoding\n\t * on variable values. For more details please read the\n\t * <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#web-uri-encoding\">\"URI Encoding\"</a>\n\t * section of the Spring Framework reference.\n\t * @param name the query parameter name\n\t * @param values the query parameter values\n\t * @see #queryParam(String, Collection)\n\t */\n\tUriBuilder queryParam(String name, Object... values);\n\n\t/**\n\t * Variant of {@link #queryParam(String, Object...)} with a Collection.\n\t * <p><strong>Note: </strong> please, review the Javadoc of\n\t * {@link #queryParam(String, Object...)} for further notes on the treatment\n\t * and encoding of individual query parameters.\n\t * @param name the query parameter name\n\t * @param values the query parameter values\n\t * @since 5.2\n\t * @see #queryParam(String, Object...)\n\t */\n\tUriBuilder queryParam(String name, @Nullable Collection<?> values);\n\n\t/**\n\t * Delegates to either {@link #queryParam(String, Object...)} or\n\t * {@link #queryParam(String, Collection)} if the given {@link Optional} has\n\t * a value, or else if it is empty, no query parameter is added at all.\n\t * @param name the query parameter name\n\t * @param value an Optional, either empty or holding the query parameter value.\n\t * @since 5.3\n\t */\n\tUriBuilder queryParamIfPresent(String name, Optional<?> value);\n\n\t/**\n\t * Add multiple query parameters and values.\n\t * <p><strong>Note: </strong> please, review the Javadoc of\n\t * {@link #queryParam(String, Object...)} for further notes on the treatment\n\t * and encoding of individual query parameters.\n\t * @param params the params\n\t */\n\tUriBuilder queryParams(MultiValueMap<String, String> params);\n\n\t/**\n\t * Set the query parameter values replacing existing values, or if no\n\t * values are given, the query parameter is removed.\n\t * <p><strong>Note: </strong> please, review the Javadoc of\n\t * {@link #queryParam(String, Object...)} for further notes on the treatment\n\t * and encoding of individual query parameters.\n\t * @param name the query parameter name\n\t * @param values the query parameter values\n\t * @see #replaceQueryParam(String, Collection)\n\t */\n\tUriBuilder replaceQueryParam(String name, Object... values);\n\n\t/**\n\t * Variant of {@link #replaceQueryParam(String, Object...)} with a Collection.\n\t * <p><strong>Note: </strong> please, review the Javadoc of\n\t * {@link #queryParam(String, Object...)} for further notes on the treatment\n\t * and encoding of individual query parameters.\n\t * @param name the query parameter name\n\t * @param values the query parameter values\n\t * @since 5.2\n\t * @see #replaceQueryParam(String, Object...)\n\t */\n\tUriBuilder replaceQueryParam(String name, @Nullable Collection<?> values);\n\n\t/**\n\t * Set the query parameter values after removing all existing ones.\n\t * <p><strong>Note: </strong> please, review the Javadoc of\n\t * {@link #queryParam(String, Object...)} for further notes on the treatment\n\t * and encoding of individual query parameters.\n\t * @param params the query parameter name\n\t */\n\tUriBuilder replaceQueryParams(MultiValueMap<String, String> params);\n\n\t/**\n\t * Set the URI fragment. The given fragment may contain URI template variables,\n\t * and may also be {@code null} to clear the fragment of this builder.\n\t * @param fragment the URI fragment\n\t */\n\tUriBuilder fragment(@Nullable String fragment);\n\n\t/**\n\t * Build a {@link URI} instance and replaces URI template variables\n\t * with the values from an array.\n\t * @param uriVariables the map of URI variables\n\t * @return the URI\n\t */\n\tURI build(@Nullable Object... uriVariables);\n\n\t/**\n\t * Build a {@link URI} instance and replaces URI template variables\n\t * with the values from a map.\n\t * @param uriVariables the map of URI variables\n\t * @return the URI\n\t */\n\tURI build(Map<String, ? extends @Nullable Object> uriVariables);\n\n\t/**\n\t * Return a String representation of the URI by concatenating all URI\n\t * component values into the fully formed URI String. Implementing classes\n\t * should perform simple String concatenation of current URI component\n\t * values to preserve URI template placeholders.\n\t * @since 6.1.2\n\t */\n\tString toUriString();\n\n}"
  },
  "org.springframework.web.util.UriComponents": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Represents an immutable collection of URI components, mapping component type to\n * String values. Contains convenience getters for all components. Effectively similar\n * to {@link java.net.URI}, but with more powerful encoding options and support for\n * URI template variables.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @author Rossen Stoyanchev\n * @since 3.1\n * @see UriComponentsBuilder\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class UriComponents",
    "source_code": "public abstract class UriComponents implements Serializable {\n\n\t/** Captures URI template variable names. */\n\tprivate static final Pattern NAMES_PATTERN = Pattern.compile(\"\\\\{([^/]+?)\\\\}\");\n\n\n\tprivate final @Nullable String scheme;\n\n\tprivate final @Nullable String fragment;\n\n\n\tprotected UriComponents(@Nullable String scheme, @Nullable String fragment) {\n\t\tthis.scheme = scheme;\n\t\tthis.fragment = fragment;\n\t}\n\n\n\t// Component getters\n\n\t/**\n\t * Return the scheme. Can be {@code null}.\n\t */\n\tpublic final @Nullable String getScheme() {\n\t\treturn this.scheme;\n\t}\n\n\t/**\n\t * Return the fragment. Can be {@code null}.\n\t */\n\tpublic final @Nullable String getFragment() {\n\t\treturn this.fragment;\n\t}\n\n\t/**\n\t * Return the scheme specific part. Can be {@code null}.\n\t */\n\tpublic abstract @Nullable String getSchemeSpecificPart();\n\n\t/**\n\t * Return the user info. Can be {@code null}.\n\t */\n\tpublic abstract @Nullable String getUserInfo();\n\n\t/**\n\t * Return the host. Can be {@code null}.\n\t */\n\tpublic abstract @Nullable String getHost();\n\n\t/**\n\t * Return the port. {@code -1} if no port has been set.\n\t */\n\tpublic abstract int getPort();\n\n\t/**\n\t * Return the path. Can be {@code null}.\n\t */\n\tpublic abstract @Nullable String getPath();\n\n\t/**\n\t * Return the list of path segments. Empty if no path has been set.\n\t */\n\tpublic abstract List<String> getPathSegments();\n\n\t/**\n\t * Return the query. Can be {@code null}.\n\t */\n\tpublic abstract @Nullable String getQuery();\n\n\t/**\n\t * Return the map of query parameters. Empty if no query has been set.\n\t */\n\tpublic abstract MultiValueMap<String, String> getQueryParams();\n\n\n\t/**\n\t * Invoke this <em>after</em> expanding URI variables to encode the\n\t * resulting URI component values.\n\t * <p>In comparison to {@link UriComponentsBuilder#encode()}, this method\n\t * <em>only</em> replaces non-ASCII and illegal (within a given URI\n\t * component type) characters, but not characters with reserved meaning.\n\t * For most cases, {@link UriComponentsBuilder#encode()} is more likely\n\t * to give the expected result.\n\t * @see UriComponentsBuilder#encode()\n\t */\n\tpublic final UriComponents encode() {\n\t\treturn encode(StandardCharsets.UTF_8);\n\t}\n\n\t/**\n\t * A variant of {@link #encode()} with a charset other than \"UTF-8\".\n\t * @param charset the charset to use for encoding\n\t * @see UriComponentsBuilder#encode(Charset)\n\t */\n\tpublic abstract UriComponents encode(Charset charset);\n\n\t/**\n\t * Replace all URI template variables with the values from a given map.\n\t * <p>The given map keys represent variable names; the corresponding values\n\t * represent variable values. The order of variables is not significant.\n\t * @param uriVariables the map of URI variables\n\t * @return the expanded URI components\n\t */\n\tpublic final UriComponents expand(Map<String, ? extends @Nullable Object> uriVariables) {\n\t\tAssert.notNull(uriVariables, \"'uriVariables' must not be null\");\n\t\treturn expandInternal(new MapTemplateVariables(uriVariables));\n\t}\n\n\t/**\n\t * Replace all URI template variables with the values from a given array.\n\t * <p>The given array represents variable values. The order of variables is significant.\n\t * @param uriVariableValues the URI variable values\n\t * @return the expanded URI components\n\t */\n\tpublic final UriComponents expand(@Nullable Object... uriVariableValues) {\n\t\tAssert.notNull(uriVariableValues, \"'uriVariableValues' must not be null\");\n\t\treturn expandInternal(new VarArgsTemplateVariables(uriVariableValues));\n\t}\n\n\t/**\n\t * Replace all URI template variables with the values from the given\n\t * {@link UriTemplateVariables}.\n\t * @param uriVariables the URI template values\n\t * @return the expanded URI components\n\t */\n\tpublic final UriComponents expand(UriTemplateVariables uriVariables) {\n\t\tAssert.notNull(uriVariables, \"'uriVariables' must not be null\");\n\t\treturn expandInternal(uriVariables);\n\t}\n\n\t/**\n\t * Replace all URI template variables with the values from the given {@link\n\t * UriTemplateVariables}.\n\t * @param uriVariables the URI template values\n\t * @return the expanded URI components\n\t */\n\tabstract UriComponents expandInternal(UriTemplateVariables uriVariables);\n\n\t/**\n\t * Normalize the path removing sequences like \"path/..\". Note that\n\t * normalization is applied to the full path, and not to individual path\n\t * segments.\n\t * @see org.springframework.util.StringUtils#cleanPath(String)\n\t */\n\tpublic abstract UriComponents normalize();\n\n\t/**\n\t * Concatenate all URI components to return the fully formed URI String.\n\t * <p>This method amounts to simple String concatenation of the current\n\t * URI component values and as such the result may contain illegal URI\n\t * characters, for example if URI variables have not been expanded or if\n\t * encoding has not been applied via {@link UriComponentsBuilder#encode()}\n\t * or {@link #encode()}.\n\t */\n\tpublic abstract String toUriString();\n\n\t/**\n\t * Create a {@link URI} from this instance as follows:\n\t * <p>If the current instance is {@link #encode() encoded}, form the full\n\t * URI String via {@link #toUriString()}, and then pass it to the single\n\t * argument {@link URI} constructor which preserves percent encoding.\n\t * <p>If not yet encoded, pass individual URI component values to the\n\t * multi-argument {@link URI} constructor which quotes illegal characters\n\t * that cannot appear in their respective URI component.\n\t */\n\tpublic abstract URI toUri();\n\n\t/**\n\t * A simple pass-through to {@link #toUriString()}.\n\t */\n\t@Override\n\tpublic final String toString() {\n\t\treturn toUriString();\n\t}\n\n\t/**\n\t * Set all components of the given UriComponentsBuilder.\n\t * @since 4.2\n\t */\n\tprotected abstract void copyToUriComponentsBuilder(UriComponentsBuilder builder);\n\n\n\t// Static expansion helpers\n\n\tstatic @Nullable String expandUriComponent(@Nullable String source, UriTemplateVariables uriVariables) {\n\t\treturn expandUriComponent(source, uriVariables, null);\n\t}\n\n\tstatic @Nullable String expandUriComponent(@Nullable String source, UriTemplateVariables uriVariables,\n\t\t\t@Nullable UnaryOperator<String> encoder) {\n\n\t\tif (source == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (source.indexOf('{') == -1) {\n\t\t\treturn source;\n\t\t}\n\t\tif (source.indexOf(':') != -1) {\n\t\t\tsource = sanitizeSource(source);\n\t\t}\n\t\tMatcher matcher = NAMES_PATTERN.matcher(source);\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (matcher.find()) {\n\t\t\tString match = matcher.group(1);\n\t\t\tString varName = getVariableName(match);\n\t\t\tObject varValue = uriVariables.getValue(varName);\n\t\t\tif (UriTemplateVariables.SKIP_VALUE.equals(varValue)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString formatted = getVariableValueAsString(varValue);\n\t\t\tformatted = encoder != null ? encoder.apply(formatted) : Matcher.quoteReplacement(formatted);\n\t\t\tmatcher.appendReplacement(sb, formatted);\n\t\t}\n\t\tmatcher.appendTail(sb);\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * Remove nested \"{}\" such as in URI vars with regular expressions.\n\t */\n\tprivate static String sanitizeSource(String source) {\n\t\tint level = 0;\n\t\tint lastCharIndex = 0;\n\t\tchar[] chars = new char[source.length()];\n\t\tfor (int i = 0; i < source.length(); i++) {\n\t\t\tchar c = source.charAt(i);\n\t\t\tif (c == '{') {\n\t\t\t\tlevel++;\n\t\t\t}\n\t\t\tif (c == '}') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level > 1 || (level == 1 && c == '}')) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchars[lastCharIndex++] = c;\n\t\t}\n\t\treturn new String(chars, 0, lastCharIndex);\n\t}\n\n\tprivate static String getVariableName(String match) {\n\t\tint colonIdx = match.indexOf(':');\n\t\treturn (colonIdx != -1 ? match.substring(0, colonIdx) : match);\n\t}\n\n\tprivate static String getVariableValueAsString(@Nullable Object variableValue) {\n\t\treturn (variableValue != null ? variableValue.toString() : \"\");\n\t}\n\n\n\t/**\n\t * Defines the contract for URI Template variables.\n\t * @see HierarchicalUriComponents#expand\n\t */\n\tpublic interface UriTemplateVariables {\n\n\t\t/**\n\t\t * Constant for a value that indicates a URI variable name should be\n\t\t * ignored and left as is. This is useful for partial expanding of some\n\t\t * but not all URI variables.\n\t\t */\n\t\tObject SKIP_VALUE = UriTemplateVariables.class;\n\n\t\t/**\n\t\t * Get the value for the given URI variable name.\n\t\t * If the value is {@code null}, an empty String is expanded.\n\t\t * If the value is {@link #SKIP_VALUE}, the URI variable is not expanded.\n\t\t * @param name the variable name\n\t\t * @return the variable value, possibly {@code null} or {@link #SKIP_VALUE}\n\t\t */\n\t\t@Nullable Object getValue(@Nullable String name);\n\t}\n\n\n\t/**\n\t * URI template variables backed by a map.\n\t */\n\tprivate static class MapTemplateVariables implements UriTemplateVariables {\n\n\t\tprivate final Map<String, ? extends @Nullable Object> uriVariables;\n\n\t\tpublic MapTemplateVariables(Map<String, ? extends @Nullable Object> uriVariables) {\n\t\t\tthis.uriVariables = uriVariables;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable Object getValue(@Nullable String name) {\n\t\t\tif (!this.uriVariables.containsKey(name)) {\n\t\t\t\tthrow new IllegalArgumentException(\"Map has no value for '\" + name + \"'\");\n\t\t\t}\n\t\t\treturn this.uriVariables.get(name);\n\t\t}\n\t}\n\n\n\t/**\n\t * URI template variables backed by a variable argument array.\n\t */\n\tprivate static class VarArgsTemplateVariables implements UriTemplateVariables {\n\n\t\tprivate final Iterator<Object> valueIterator;\n\n\t\tpublic VarArgsTemplateVariables(@Nullable Object... uriVariableValues) {\n\t\t\tthis.valueIterator = Arrays.asList(uriVariableValues).iterator();\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable Object getValue(@Nullable String name) {\n\t\t\tif (!this.valueIterator.hasNext()) {\n\t\t\t\tthrow new IllegalArgumentException(\"Not enough variable values available to expand '\" + name + \"'\");\n\t\t\t}\n\t\t\treturn this.valueIterator.next();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.util.UriComponents#copyToUriComponentsBuilder(builder)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set all components of the given UriComponentsBuilder.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "void",
    "signature": "protected void copyToUriComponentsBuilder(UriComponentsBuilder builder)",
    "source_code": "\tprotected abstract void copyToUriComponentsBuilder(UriComponentsBuilder builder);"
  },
  "org.springframework.web.util.UriComponents#encode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke this <em>after</em> expanding URI variables to encode the\n\t * resulting URI component values.\n\t * <p>In comparison to {@link UriComponentsBuilder#encode()}, this method\n\t * <em>only</em> replaces non-ASCII and illegal (within a given URI\n\t * component type) characters, but not characters with reserved meaning.\n\t * For most cases, {@link UriComponentsBuilder#encode()} is more likely\n\t * to give the expected result.\n\t * @see UriComponentsBuilder#encode()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "UriComponents",
    "signature": "public UriComponents encode()",
    "source_code": "\tpublic final UriComponents encode() {\n\t\treturn encode(StandardCharsets.UTF_8);\n\t}"
  },
  "org.springframework.web.util.UriComponents#encode(charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A variant of {@link #encode()} with a charset other than \"UTF-8\".\n\t * @param charset the charset to use for encoding\n\t * @see UriComponentsBuilder#encode(Charset)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "UriComponents",
    "signature": "public UriComponents encode(Charset charset)",
    "source_code": "\tpublic abstract UriComponents encode(Charset charset);"
  },
  "org.springframework.web.util.UriComponents#expand(Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace all URI template variables with the values from a given map.\n\t * <p>The given map keys represent variable names; the corresponding values\n\t * represent variable values. The order of variables is not significant.\n\t * @param uriVariables the map of URI variables\n\t * @return the expanded URI components\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "UriComponents",
    "signature": "public UriComponents expand(Map<String, ? extends @Nullable Object> uriVariables)",
    "source_code": "\tpublic final UriComponents expand(Map<String, ? extends @Nullable Object> uriVariables) {\n\t\tAssert.notNull(uriVariables, \"'uriVariables' must not be null\");\n\t\treturn expandInternal(new MapTemplateVariables(uriVariables));\n\t}"
  },
  "org.springframework.web.util.UriComponents#expand(uriVariableValues)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace all URI template variables with the values from a given array.\n\t * <p>The given array represents variable values. The order of variables is significant.\n\t * @param uriVariableValues the URI variable values\n\t * @return the expanded URI components\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriVariableValues"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "UriComponents",
    "signature": "public UriComponents expand(@Nullable Object... uriVariableValues)",
    "source_code": "\tpublic final UriComponents expand(@Nullable Object... uriVariableValues) {\n\t\tAssert.notNull(uriVariableValues, \"'uriVariableValues' must not be null\");\n\t\treturn expandInternal(new VarArgsTemplateVariables(uriVariableValues));\n\t}"
  },
  "org.springframework.web.util.UriComponents#expand(uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace all URI template variables with the values from the given\n\t * {@link UriTemplateVariables}.\n\t * @param uriVariables the URI template values\n\t * @return the expanded URI components\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "UriComponents",
    "signature": "public UriComponents expand(UriTemplateVariables uriVariables)",
    "source_code": "\tpublic final UriComponents expand(UriTemplateVariables uriVariables) {\n\t\tAssert.notNull(uriVariables, \"'uriVariables' must not be null\");\n\t\treturn expandInternal(uriVariables);\n\t}"
  },
  "org.springframework.web.util.UriComponents#getFragment()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the fragment. Can be {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "String",
    "signature": "public String getFragment()",
    "source_code": "\tpublic final @Nullable String getFragment() {\n\t\treturn this.fragment;\n\t}"
  },
  "org.springframework.web.util.UriComponents#getHost()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the host. Can be {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "String",
    "signature": "public String getHost()",
    "source_code": "\tpublic abstract @Nullable String getHost();"
  },
  "org.springframework.web.util.UriComponents#getPath()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the path. Can be {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "String",
    "signature": "public String getPath()",
    "source_code": "\tpublic abstract @Nullable String getPath();"
  },
  "org.springframework.web.util.UriComponents#getPathSegments()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the list of path segments. Empty if no path has been set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "List<String>",
    "signature": "public List<String> getPathSegments()",
    "source_code": "\tpublic abstract List<String> getPathSegments();"
  },
  "org.springframework.web.util.UriComponents#getPort()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the port. {@code -1} if no port has been set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "int",
    "signature": "public int getPort()",
    "source_code": "\tpublic abstract int getPort();"
  },
  "org.springframework.web.util.UriComponents#getQuery()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the query. Can be {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "String",
    "signature": "public String getQuery()",
    "source_code": "\tpublic abstract @Nullable String getQuery();"
  },
  "org.springframework.web.util.UriComponents#getQueryParams()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the map of query parameters. Empty if no query has been set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "String>",
    "signature": "public String> getQueryParams()",
    "source_code": "\tpublic abstract MultiValueMap<String, String> getQueryParams();"
  },
  "org.springframework.web.util.UriComponents#getScheme()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the scheme. Can be {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "String",
    "signature": "public String getScheme()",
    "source_code": "\tpublic final @Nullable String getScheme() {\n\t\treturn this.scheme;\n\t}"
  },
  "org.springframework.web.util.UriComponents#getSchemeSpecificPart()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the scheme specific part. Can be {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "String",
    "signature": "public String getSchemeSpecificPart()",
    "source_code": "\tpublic abstract @Nullable String getSchemeSpecificPart();"
  },
  "org.springframework.web.util.UriComponents#getUserInfo()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the user info. Can be {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "String",
    "signature": "public String getUserInfo()",
    "source_code": "\tpublic abstract @Nullable String getUserInfo();"
  },
  "org.springframework.web.util.UriComponents#getValue(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "Object",
    "signature": "public Object getValue(@Nullable String name)",
    "source_code": "\t\tpublic @Nullable Object getValue(@Nullable String name) {\n\t\t\tif (!this.valueIterator.hasNext()) {\n\t\t\t\tthrow new IllegalArgumentException(\"Not enough variable values available to expand '\" + name + \"'\");\n\t\t\t}\n\t\t\treturn this.valueIterator.next();\n\t\t}"
  },
  "org.springframework.web.util.UriComponents#normalize()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Normalize the path removing sequences like \"path/..\". Note that\n\t * normalization is applied to the full path, and not to individual path\n\t * segments.\n\t * @see org.springframework.util.StringUtils#cleanPath(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "UriComponents",
    "signature": "public UriComponents normalize()",
    "source_code": "\tpublic abstract UriComponents normalize();"
  },
  "org.springframework.web.util.UriComponents#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A simple pass-through to {@link #toUriString()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic final String toString() {\n\t\treturn toUriString();\n\t}"
  },
  "org.springframework.web.util.UriComponents#toUri()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link URI} from this instance as follows:\n\t * <p>If the current instance is {@link #encode() encoded}, form the full\n\t * URI String via {@link #toUriString()}, and then pass it to the single\n\t * argument {@link URI} constructor which preserves percent encoding.\n\t * <p>If not yet encoded, pass individual URI component values to the\n\t * multi-argument {@link URI} constructor which quotes illegal characters\n\t * that cannot appear in their respective URI component.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "URI",
    "signature": "public URI toUri()",
    "source_code": "\tpublic abstract URI toUri();"
  },
  "org.springframework.web.util.UriComponents#toUriString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Concatenate all URI components to return the fully formed URI String.\n\t * <p>This method amounts to simple String concatenation of the current\n\t * URI component values and as such the result may contain illegal URI\n\t * characters, for example if URI variables have not been expanded or if\n\t * encoding has not been applied via {@link UriComponentsBuilder#encode()}\n\t * or {@link #encode()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "String",
    "signature": "public String toUriString()",
    "source_code": "\tpublic abstract String toUriString();"
  },
  "org.springframework.web.util.UriComponentsBuilder#fromHttpRequest(request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@code UriComponents} object from the URI associated with\n\t * the given HttpRequest while also overlaying with values from the headers\n\t * \"Forwarded\" (<a href=\"https://tools.ietf.org/html/rfc7239\">RFC 7239</a>),\n\t * or \"X-Forwarded-Host\", \"X-Forwarded-Port\", and \"X-Forwarded-Proto\" if\n\t * \"Forwarded\" is not found.\n\t * @param request the source request\n\t * @return the URI components of the URI\n\t * @since 4.1.5\n\t * @deprecated in favor of {@link ForwardedHeaderUtils#adaptFromForwardedHeaders};\n\t * to be removed in 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromHttpRequest(HttpRequest request)",
    "source_code": "\tpublic static UriComponentsBuilder fromHttpRequest(HttpRequest request) {\n\t\treturn ForwardedHeaderUtils.adaptFromForwardedHeaders(request.getURI(), request.getHeaders());\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#fromHttpUrl(httpUrl)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a URI components builder from the given HTTP URL String.\n\t * <p><strong>Note:</strong> The presence of reserved characters can prevent\n\t * correct parsing of the URI string. For example if a query parameter\n\t * contains {@code '='} or {@code '&'} characters, the query string cannot\n\t * be parsed unambiguously. Such values should be substituted for URI\n\t * variables to enable correct parsing:\n\t * <pre class=\"code\">\n\t * String urlString = &quot;https://example.com/hotels/42?filter={value}&quot;;\n\t * UriComponentsBuilder.fromHttpUrl(urlString).buildAndExpand(&quot;hot&amp;cold&quot;);\n\t * </pre>\n\t * @param httpUrl the source URI\n\t * @return the URI components of the URI\n\t * @deprecated as of 6.2, in favor of {@link #fromUriString(String)};\n\t * scheduled for removal in 7.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "httpUrl"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromHttpUrl(String httpUrl)",
    "source_code": "\tpublic static UriComponentsBuilder fromHttpUrl(String httpUrl) throws InvalidUrlException {\n\t\treturn fromUriString(httpUrl);\n\t}"
  },
  "org.springframework.web.util.UriComponentsBuilder#fromOriginHeader(origin)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance by parsing the \"Origin\" header of an HTTP request.\n\t * @see <a href=\"https://tools.ietf.org/html/rfc6454\">RFC 6454</a>\n\t * @deprecated in favor of {@link UriComponentsBuilder#fromUriString(String)};\n\t * to be removed in 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "origin"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromOriginHeader(String origin)",
    "source_code": "\tpublic static UriComponentsBuilder fromOriginHeader(String origin) {\n\t\treturn fromUriString(origin);\n\t}"
  },
  "org.springframework.web.util.UriTemplateHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Defines methods for expanding a URI template with variables.\n *\n * @author Rossen Stoyanchev\n * @since 4.2\n * @see org.springframework.web.client.RestTemplate#setUriTemplateHandler(UriTemplateHandler)\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 31
    },
    "signature": "public interface UriTemplateHandler",
    "source_code": "public interface UriTemplateHandler {\n\n\t/**\n\t * Expand the given URI template with a map of URI variables.\n\t * @param uriTemplate the URI template\n\t * @param uriVariables variable values\n\t * @return the created URI instance\n\t */\n\tURI expand(String uriTemplate, Map<String, ? extends @Nullable Object> uriVariables);\n\n\t/**\n\t * Expand the given URI template with an array of URI variables.\n\t * @param uriTemplate the URI template\n\t * @param uriVariables variable values\n\t * @return the created URI instance\n\t */\n\tURI expand(String uriTemplate, @Nullable Object... uriVariables);\n\n}"
  },
  "org.springframework.web.util.UriTemplateVariables": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Defines the contract for URI Template variables.\n\t * @see HierarchicalUriComponents#expand\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "signature": "public interface UriTemplateVariables",
    "source_code": "\tpublic interface UriTemplateVariables {\n\n\t\t/**\n\t\t * Constant for a value that indicates a URI variable name should be\n\t\t * ignored and left as is. This is useful for partial expanding of some\n\t\t * but not all URI variables.\n\t\t */\n\t\tObject SKIP_VALUE = UriTemplateVariables.class;\n\n\t\t/**\n\t\t * Get the value for the given URI variable name.\n\t\t * If the value is {@code null}, an empty String is expanded.\n\t\t * If the value is {@link #SKIP_VALUE}, the URI variable is not expanded.\n\t\t * @param name the variable name\n\t\t * @return the variable value, possibly {@code null} or {@link #SKIP_VALUE}\n\t\t */\n\t\t@Nullable Object getValue(@Nullable String name);\n\t}"
  },
  "org.springframework.web.util.UriUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility methods for URI encoding and decoding based on RFC 3986.\n *\n * <p>There are two types of encode methods:\n * <ul>\n * <li>{@code \"encodeXyz\"} -- these encode a specific URI component (for example, path,\n * query) by percent encoding illegal characters, which includes non-US-ASCII\n * characters, and also characters that are otherwise illegal within the given\n * URI component type, as defined in RFC 3986. The effect of this method, with\n * regards to encoding, is comparable to using the multi-argument constructor\n * of {@link URI}.\n * <li>{@code \"encode\"} and {@code \"encodeUriVariables\"} -- these can be used\n * to encode URI variable values by percent encoding all characters that are\n * either illegal, or have any reserved meaning, anywhere within a URI.\n * </ul>\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @author Rossen Stoyanchev\n * @since 3.0\n * @see <a href=\"https://www.ietf.org/rfc/rfc3986.txt\">RFC 3986</a>\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public class UriUtils",
    "source_code": "public abstract class UriUtils {\n\n\t/**\n\t * Encode the given URI scheme with the given encoding.\n\t * @param scheme the scheme to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded scheme\n\t */\n\tpublic static String encodeScheme(String scheme, String encoding) {\n\t\treturn encode(scheme, encoding, HierarchicalUriComponents.Type.SCHEME);\n\t}\n\n\t/**\n\t * Encode the given URI scheme with the given encoding.\n\t * @param scheme the scheme to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded scheme\n\t * @since 5.0\n\t */\n\tpublic static String encodeScheme(String scheme, Charset charset) {\n\t\treturn encode(scheme, charset, HierarchicalUriComponents.Type.SCHEME);\n\t}\n\n\t/**\n\t * Encode the given URI authority with the given encoding.\n\t * @param authority the authority to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded authority\n\t */\n\tpublic static String encodeAuthority(String authority, String encoding) {\n\t\treturn encode(authority, encoding, HierarchicalUriComponents.Type.AUTHORITY);\n\t}\n\n\t/**\n\t * Encode the given URI authority with the given encoding.\n\t * @param authority the authority to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded authority\n\t * @since 5.0\n\t */\n\tpublic static String encodeAuthority(String authority, Charset charset) {\n\t\treturn encode(authority, charset, HierarchicalUriComponents.Type.AUTHORITY);\n\t}\n\n\t/**\n\t * Encode the given URI user info with the given encoding.\n\t * @param userInfo the user info to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded user info\n\t */\n\tpublic static String encodeUserInfo(String userInfo, String encoding) {\n\t\treturn encode(userInfo, encoding, HierarchicalUriComponents.Type.USER_INFO);\n\t}\n\n\t/**\n\t * Encode the given URI user info with the given encoding.\n\t * @param userInfo the user info to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded user info\n\t * @since 5.0\n\t */\n\tpublic static String encodeUserInfo(String userInfo, Charset charset) {\n\t\treturn encode(userInfo, charset, HierarchicalUriComponents.Type.USER_INFO);\n\t}\n\n\t/**\n\t * Encode the given URI host with the given encoding.\n\t * @param host the host to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded host\n\t */\n\tpublic static String encodeHost(String host, String encoding) {\n\t\treturn encode(host, encoding, HierarchicalUriComponents.Type.HOST_IPV4);\n\t}\n\n\t/**\n\t * Encode the given URI host with the given encoding.\n\t * @param host the host to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded host\n\t * @since 5.0\n\t */\n\tpublic static String encodeHost(String host, Charset charset) {\n\t\treturn encode(host, charset, HierarchicalUriComponents.Type.HOST_IPV4);\n\t}\n\n\t/**\n\t * Encode the given URI port with the given encoding.\n\t * @param port the port to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded port\n\t */\n\tpublic static String encodePort(String port, String encoding) {\n\t\treturn encode(port, encoding, HierarchicalUriComponents.Type.PORT);\n\t}\n\n\t/**\n\t * Encode the given URI port with the given encoding.\n\t * @param port the port to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded port\n\t * @since 5.0\n\t */\n\tpublic static String encodePort(String port, Charset charset) {\n\t\treturn encode(port, charset, HierarchicalUriComponents.Type.PORT);\n\t}\n\n\t/**\n\t * Encode the given URI path with the given encoding.\n\t * @param path the path to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded path\n\t */\n\tpublic static String encodePath(String path, String encoding) {\n\t\treturn encode(path, encoding, HierarchicalUriComponents.Type.PATH);\n\t}\n\n\t/**\n\t * Encode the given URI path with the given encoding.\n\t * @param path the path to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded path\n\t * @since 5.0\n\t */\n\tpublic static String encodePath(String path, Charset charset) {\n\t\treturn encode(path, charset, HierarchicalUriComponents.Type.PATH);\n\t}\n\n\t/**\n\t * Encode the given URI path segment with the given encoding.\n\t * @param segment the segment to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded segment\n\t */\n\tpublic static String encodePathSegment(String segment, String encoding) {\n\t\treturn encode(segment, encoding, HierarchicalUriComponents.Type.PATH_SEGMENT);\n\t}\n\n\t/**\n\t * Encode the given URI path segment with the given encoding.\n\t * @param segment the segment to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded segment\n\t * @since 5.0\n\t */\n\tpublic static String encodePathSegment(String segment, Charset charset) {\n\t\treturn encode(segment, charset, HierarchicalUriComponents.Type.PATH_SEGMENT);\n\t}\n\n\t/**\n\t * Encode the given URI query with the given encoding.\n\t * @param query the query to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded query\n\t */\n\tpublic static String encodeQuery(String query, String encoding) {\n\t\treturn encode(query, encoding, HierarchicalUriComponents.Type.QUERY);\n\t}\n\n\t/**\n\t * Encode the given URI query with the given encoding.\n\t * @param query the query to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded query\n\t * @since 5.0\n\t */\n\tpublic static String encodeQuery(String query, Charset charset) {\n\t\treturn encode(query, charset, HierarchicalUriComponents.Type.QUERY);\n\t}\n\n\t/**\n\t * Encode the given URI query parameter with the given encoding.\n\t * @param queryParam the query parameter to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded query parameter\n\t */\n\tpublic static String encodeQueryParam(String queryParam, String encoding) {\n\t\treturn encode(queryParam, encoding, HierarchicalUriComponents.Type.QUERY_PARAM);\n\t}\n\n\t/**\n\t * Encode the given URI query parameter with the given encoding.\n\t * @param queryParam the query parameter to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded query parameter\n\t * @since 5.0\n\t */\n\tpublic static String encodeQueryParam(String queryParam, Charset charset) {\n\t\treturn encode(queryParam, charset, HierarchicalUriComponents.Type.QUERY_PARAM);\n\t}\n\n\t/**\n\t * Encode the query parameters from the given {@code MultiValueMap} with UTF-8.\n\t * <p>This can be used with {@link UriComponentsBuilder#queryParams(MultiValueMap)}\n\t * when building a URI from an already encoded template.\n\t * <pre class=\"code\">{@code\n\t * MultiValueMap<String, String> params = new LinkedMultiValueMap<>(2);\n\t * // add to params...\n\t *\n\t * ServletUriComponentsBuilder.fromCurrentRequest()\n\t *         .queryParams(UriUtils.encodeQueryParams(params))\n\t *         .build(true)\n\t *         .toUriString();\n\t * }</pre>\n\t * @param params the parameters to encode\n\t * @return a new {@code MultiValueMap} with the encoded names and values\n\t * @since 5.2.3\n\t */\n\tpublic static MultiValueMap<String, String> encodeQueryParams(MultiValueMap<String, String> params) {\n\t\tCharset charset = StandardCharsets.UTF_8;\n\t\tMultiValueMap<String, String> result = new LinkedMultiValueMap<>(params.size());\n\t\tfor (Map.Entry<String, List<String>> entry : params.entrySet()) {\n\t\t\tfor (String value : entry.getValue()) {\n\t\t\t\tresult.add(encodeQueryParam(entry.getKey(), charset), encodeQueryParam(value, charset));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Encode the given URI fragment with the given encoding.\n\t * @param fragment the fragment to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded fragment\n\t */\n\tpublic static String encodeFragment(String fragment, String encoding) {\n\t\treturn encode(fragment, encoding, HierarchicalUriComponents.Type.FRAGMENT);\n\t}\n\n\t/**\n\t * Encode the given URI fragment with the given encoding.\n\t * @param fragment the fragment to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded fragment\n\t * @since 5.0\n\t */\n\tpublic static String encodeFragment(String fragment, Charset charset) {\n\t\treturn encode(fragment, charset, HierarchicalUriComponents.Type.FRAGMENT);\n\t}\n\n\n\t/**\n\t * Variant of {@link #encode(String, Charset)} with a String charset.\n\t * @param source the String to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded String\n\t */\n\tpublic static String encode(String source, String encoding) {\n\t\treturn encode(source, encoding, HierarchicalUriComponents.Type.URI);\n\t}\n\n\t/**\n\t * Encode all characters that are either illegal, or have any reserved\n\t * meaning, anywhere within a URI, as defined in\n\t * <a href=\"https://tools.ietf.org/html/rfc3986\">RFC 3986</a>.\n\t * This is useful to ensure that the given String will be preserved as-is\n\t * and will not have any impact on the structure or meaning of the URI.\n\t * @param source the String to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded String\n\t * @since 5.0\n\t */\n\tpublic static String encode(String source, Charset charset) {\n\t\treturn encode(source, charset, HierarchicalUriComponents.Type.URI);\n\t}\n\n\t/**\n\t * Convenience method to apply {@link #encode(String, Charset)} to all\n\t * given URI variable values.\n\t * @param uriVariables the URI variable values to be encoded\n\t * @return the encoded String\n\t * @since 5.0\n\t */\n\tpublic static Map<String, String> encodeUriVariables(Map<String, ? extends @Nullable Object> uriVariables) {\n\t\tMap<String, String> result = CollectionUtils.newLinkedHashMap(uriVariables.size());\n\t\turiVariables.forEach((key, value) -> {\n\t\t\tString stringValue = (value != null ? value.toString() : \"\");\n\t\t\tresult.put(key, encode(stringValue, StandardCharsets.UTF_8));\n\t\t});\n\t\treturn result;\n\t}\n\n\t/**\n\t * Convenience method to apply {@link #encode(String, Charset)} to all\n\t * given URI variable values.\n\t * @param uriVariables the URI variable values to be encoded\n\t * @return the encoded String\n\t * @since 5.0\n\t */\n\tpublic static Object[] encodeUriVariables(@Nullable Object... uriVariables) {\n\t\treturn Arrays.stream(uriVariables)\n\t\t\t\t.map(value -> {\n\t\t\t\t\tString stringValue = (value != null ? value.toString() : \"\");\n\t\t\t\t\treturn encode(stringValue, StandardCharsets.UTF_8);\n\t\t\t\t})\n\t\t\t\t.toArray();\n\t}\n\n\tprivate static String encode(String scheme, String encoding, HierarchicalUriComponents.Type type) {\n\t\treturn HierarchicalUriComponents.encodeUriComponent(scheme, encoding, type);\n\t}\n\n\tprivate static String encode(String scheme, Charset charset, HierarchicalUriComponents.Type type) {\n\t\treturn HierarchicalUriComponents.encodeUriComponent(scheme, charset, type);\n\t}\n\n\n\t/**\n\t * Decode the given encoded URI component.\n\t * <p>See {@link StringUtils#uriDecode(String, Charset)} for the decoding rules.\n\t * @param source the encoded String\n\t * @param encoding the character encoding to use\n\t * @return the decoded value\n\t * @throws IllegalArgumentException when the given source contains invalid encoded sequences\n\t * @see StringUtils#uriDecode(String, Charset)\n\t * @see java.net.URLDecoder#decode(String, String)\n\t */\n\tpublic static String decode(String source, String encoding) {\n\t\treturn StringUtils.uriDecode(source, Charset.forName(encoding));\n\t}\n\n\t/**\n\t * Decode the given encoded URI component.\n\t * <p>See {@link StringUtils#uriDecode(String, Charset)} for the decoding rules.\n\t * @param source the encoded String\n\t * @param charset the character encoding to use\n\t * @return the decoded value\n\t * @throws IllegalArgumentException when the given source contains invalid encoded sequences\n\t * @since 5.0\n\t * @see StringUtils#uriDecode(String, Charset)\n\t * @see java.net.URLDecoder#decode(String, String)\n\t */\n\tpublic static String decode(String source, Charset charset) {\n\t\treturn StringUtils.uriDecode(source, charset);\n\t}\n\n\t/**\n\t * Extract the file extension from the given URI path.\n\t * @param path the URI path (for example, \"/products/index.html\")\n\t * @return the extracted file extension (for example, \"html\")\n\t * @since 4.3.2\n\t */\n\tpublic static @Nullable String extractFileExtension(String path) {\n\t\tint end = path.indexOf('?');\n\t\tint fragmentIndex = path.indexOf('#');\n\t\tif (fragmentIndex != -1 && (end == -1 || fragmentIndex < end)) {\n\t\t\tend = fragmentIndex;\n\t\t}\n\t\tif (end == -1) {\n\t\t\tend = path.length();\n\t\t}\n\t\tint begin = path.lastIndexOf('/', end) + 1;\n\t\tint paramIndex = path.indexOf(';', begin);\n\t\tend = (paramIndex != -1 && paramIndex < end ? paramIndex : end);\n\t\tint extIndex = path.lastIndexOf('.', end);\n\t\tif (extIndex != -1 && extIndex >= begin) {\n\t\t\treturn path.substring(extIndex + 1, end);\n\t\t}\n\t\treturn null;\n\t}\n\n}"
  },
  "org.springframework.web.util.UriUtils#decode(source,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Decode the given encoded URI component.\n\t * <p>See {@link StringUtils#uriDecode(String, Charset)} for the decoding rules.\n\t * @param source the encoded String\n\t * @param charset the character encoding to use\n\t * @return the decoded value\n\t * @throws IllegalArgumentException when the given source contains invalid encoded sequences\n\t * @since 5.0\n\t * @see StringUtils#uriDecode(String, Charset)\n\t * @see java.net.URLDecoder#decode(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 387
    },
    "return": "String",
    "signature": "public String decode(String source, Charset charset)",
    "source_code": "\tpublic static String decode(String source, Charset charset) {\n\t\treturn StringUtils.uriDecode(source, charset);\n\t}"
  },
  "org.springframework.web.util.UriUtils#decode(source,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Decode the given encoded URI component.\n\t * <p>See {@link StringUtils#uriDecode(String, Charset)} for the decoding rules.\n\t * @param source the encoded String\n\t * @param encoding the character encoding to use\n\t * @return the decoded value\n\t * @throws IllegalArgumentException when the given source contains invalid encoded sequences\n\t * @see StringUtils#uriDecode(String, Charset)\n\t * @see java.net.URLDecoder#decode(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "String",
    "signature": "public String decode(String source, String encoding)",
    "source_code": "\tpublic static String decode(String source, String encoding) {\n\t\treturn StringUtils.uriDecode(source, Charset.forName(encoding));\n\t}"
  },
  "org.springframework.web.util.UriUtils#encode(source,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode all characters that are either illegal, or have any reserved\n\t * meaning, anywhere within a URI, as defined in\n\t * <a href=\"https://tools.ietf.org/html/rfc3986\">RFC 3986</a>.\n\t * This is useful to ensure that the given String will be preserved as-is\n\t * and will not have any impact on the structure or meaning of the URI.\n\t * @param source the String to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded String\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "String",
    "signature": "public String encode(String source, Charset charset)",
    "source_code": "\tpublic static String encode(String source, Charset charset) {\n\t\treturn encode(source, charset, HierarchicalUriComponents.Type.URI);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encode(source,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #encode(String, Charset)} with a String charset.\n\t * @param source the String to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded String\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "String",
    "signature": "public String encode(String source, String encoding)",
    "source_code": "\tpublic static String encode(String source, String encoding) {\n\t\treturn encode(source, encoding, HierarchicalUriComponents.Type.URI);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodeAuthority(authority,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI authority with the given encoding.\n\t * @param authority the authority to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded authority\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "authority",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "String",
    "signature": "public String encodeAuthority(String authority, Charset charset)",
    "source_code": "\tpublic static String encodeAuthority(String authority, Charset charset) {\n\t\treturn encode(authority, charset, HierarchicalUriComponents.Type.AUTHORITY);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodeAuthority(authority,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI authority with the given encoding.\n\t * @param authority the authority to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded authority\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "authority",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "String",
    "signature": "public String encodeAuthority(String authority, String encoding)",
    "source_code": "\tpublic static String encodeAuthority(String authority, String encoding) {\n\t\treturn encode(authority, encoding, HierarchicalUriComponents.Type.AUTHORITY);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodeFragment(fragment,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI fragment with the given encoding.\n\t * @param fragment the fragment to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded fragment\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fragment",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "String",
    "signature": "public String encodeFragment(String fragment, Charset charset)",
    "source_code": "\tpublic static String encodeFragment(String fragment, Charset charset) {\n\t\treturn encode(fragment, charset, HierarchicalUriComponents.Type.FRAGMENT);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodeFragment(fragment,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI fragment with the given encoding.\n\t * @param fragment the fragment to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded fragment\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fragment",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "String",
    "signature": "public String encodeFragment(String fragment, String encoding)",
    "source_code": "\tpublic static String encodeFragment(String fragment, String encoding) {\n\t\treturn encode(fragment, encoding, HierarchicalUriComponents.Type.FRAGMENT);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodeHost(host,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI host with the given encoding.\n\t * @param host the host to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded host\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "host",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "String",
    "signature": "public String encodeHost(String host, Charset charset)",
    "source_code": "\tpublic static String encodeHost(String host, Charset charset) {\n\t\treturn encode(host, charset, HierarchicalUriComponents.Type.HOST_IPV4);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodeHost(host,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI host with the given encoding.\n\t * @param host the host to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded host\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "host",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "String",
    "signature": "public String encodeHost(String host, String encoding)",
    "source_code": "\tpublic static String encodeHost(String host, String encoding) {\n\t\treturn encode(host, encoding, HierarchicalUriComponents.Type.HOST_IPV4);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodePath(path,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI path with the given encoding.\n\t * @param path the path to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded path\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "String",
    "signature": "public String encodePath(String path, Charset charset)",
    "source_code": "\tpublic static String encodePath(String path, Charset charset) {\n\t\treturn encode(path, charset, HierarchicalUriComponents.Type.PATH);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodePath(path,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI path with the given encoding.\n\t * @param path the path to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded path\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "String",
    "signature": "public String encodePath(String path, String encoding)",
    "source_code": "\tpublic static String encodePath(String path, String encoding) {\n\t\treturn encode(path, encoding, HierarchicalUriComponents.Type.PATH);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodePathSegment(segment,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI path segment with the given encoding.\n\t * @param segment the segment to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded segment\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "segment",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "String",
    "signature": "public String encodePathSegment(String segment, Charset charset)",
    "source_code": "\tpublic static String encodePathSegment(String segment, Charset charset) {\n\t\treturn encode(segment, charset, HierarchicalUriComponents.Type.PATH_SEGMENT);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodePathSegment(segment,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI path segment with the given encoding.\n\t * @param segment the segment to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded segment\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "segment",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "String",
    "signature": "public String encodePathSegment(String segment, String encoding)",
    "source_code": "\tpublic static String encodePathSegment(String segment, String encoding) {\n\t\treturn encode(segment, encoding, HierarchicalUriComponents.Type.PATH_SEGMENT);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodePort(port,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI port with the given encoding.\n\t * @param port the port to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded port\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "port",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "String",
    "signature": "public String encodePort(String port, Charset charset)",
    "source_code": "\tpublic static String encodePort(String port, Charset charset) {\n\t\treturn encode(port, charset, HierarchicalUriComponents.Type.PORT);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodePort(port,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI port with the given encoding.\n\t * @param port the port to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded port\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "port",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "String",
    "signature": "public String encodePort(String port, String encoding)",
    "source_code": "\tpublic static String encodePort(String port, String encoding) {\n\t\treturn encode(port, encoding, HierarchicalUriComponents.Type.PORT);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodeQuery(query,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI query with the given encoding.\n\t * @param query the query to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded query\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "query",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "String",
    "signature": "public String encodeQuery(String query, Charset charset)",
    "source_code": "\tpublic static String encodeQuery(String query, Charset charset) {\n\t\treturn encode(query, charset, HierarchicalUriComponents.Type.QUERY);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodeQuery(query,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI query with the given encoding.\n\t * @param query the query to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded query\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "query",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "String",
    "signature": "public String encodeQuery(String query, String encoding)",
    "source_code": "\tpublic static String encodeQuery(String query, String encoding) {\n\t\treturn encode(query, encoding, HierarchicalUriComponents.Type.QUERY);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodeQueryParam(queryParam,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI query parameter with the given encoding.\n\t * @param queryParam the query parameter to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded query parameter\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queryParam",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "String",
    "signature": "public String encodeQueryParam(String queryParam, Charset charset)",
    "source_code": "\tpublic static String encodeQueryParam(String queryParam, Charset charset) {\n\t\treturn encode(queryParam, charset, HierarchicalUriComponents.Type.QUERY_PARAM);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodeQueryParam(queryParam,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI query parameter with the given encoding.\n\t * @param queryParam the query parameter to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded query parameter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queryParam",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "String",
    "signature": "public String encodeQueryParam(String queryParam, String encoding)",
    "source_code": "\tpublic static String encodeQueryParam(String queryParam, String encoding) {\n\t\treturn encode(queryParam, encoding, HierarchicalUriComponents.Type.QUERY_PARAM);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodeQueryParams(MultiValueMap<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the query parameters from the given {@code MultiValueMap} with UTF-8.\n\t * <p>This can be used with {@link UriComponentsBuilder#queryParams(MultiValueMap)}\n\t * when building a URI from an already encoded template.\n\t * <pre class=\"code\">{@code\n\t * MultiValueMap<String, String> params = new LinkedMultiValueMap<>(2);\n\t * // add to params...\n\t *\n\t * ServletUriComponentsBuilder.fromCurrentRequest()\n\t *         .queryParams(UriUtils.encodeQueryParams(params))\n\t *         .build(true)\n\t *         .toUriString();\n\t * }</pre>\n\t * @param params the parameters to encode\n\t * @return a new {@code MultiValueMap} with the encoded names and values\n\t * @since 5.2.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "String>",
    "signature": "public String> encodeQueryParams(MultiValueMap<String, String> params)",
    "source_code": "\tpublic static MultiValueMap<String, String> encodeQueryParams(MultiValueMap<String, String> params) {\n\t\tCharset charset = StandardCharsets.UTF_8;\n\t\tMultiValueMap<String, String> result = new LinkedMultiValueMap<>(params.size());\n\t\tfor (Map.Entry<String, List<String>> entry : params.entrySet()) {\n\t\t\tfor (String value : entry.getValue()) {\n\t\t\t\tresult.add(encodeQueryParam(entry.getKey(), charset), encodeQueryParam(value, charset));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodeScheme(scheme,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI scheme with the given encoding.\n\t * @param scheme the scheme to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded scheme\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scheme",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "String",
    "signature": "public String encodeScheme(String scheme, Charset charset)",
    "source_code": "\tpublic static String encodeScheme(String scheme, Charset charset) {\n\t\treturn encode(scheme, charset, HierarchicalUriComponents.Type.SCHEME);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodeScheme(scheme,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI scheme with the given encoding.\n\t * @param scheme the scheme to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded scheme\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scheme",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "String",
    "signature": "public String encodeScheme(String scheme, String encoding)",
    "source_code": "\tpublic static String encodeScheme(String scheme, String encoding) {\n\t\treturn encode(scheme, encoding, HierarchicalUriComponents.Type.SCHEME);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodeUriVariables(Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method to apply {@link #encode(String, Charset)} to all\n\t * given URI variable values.\n\t * @param uriVariables the URI variable values to be encoded\n\t * @return the encoded String\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "String>",
    "signature": "public String> encodeUriVariables(Map<String, ? extends @Nullable Object> uriVariables)",
    "source_code": "\tpublic static Map<String, String> encodeUriVariables(Map<String, ? extends @Nullable Object> uriVariables) {\n\t\tMap<String, String> result = CollectionUtils.newLinkedHashMap(uriVariables.size());\n\t\turiVariables.forEach((key, value) -> {\n\t\t\tString stringValue = (value != null ? value.toString() : \"\");\n\t\t\tresult.put(key, encode(stringValue, StandardCharsets.UTF_8));\n\t\t});\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodeUriVariables(uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method to apply {@link #encode(String, Charset)} to all\n\t * given URI variable values.\n\t * @param uriVariables the URI variable values to be encoded\n\t * @return the encoded String\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 344
    },
    "return": "Object[]",
    "signature": "public Object[] encodeUriVariables(@Nullable Object... uriVariables)",
    "source_code": "\tpublic static Object[] encodeUriVariables(@Nullable Object... uriVariables) {\n\t\treturn Arrays.stream(uriVariables)\n\t\t\t\t.map(value -> {\n\t\t\t\t\tString stringValue = (value != null ? value.toString() : \"\");\n\t\t\t\t\treturn encode(stringValue, StandardCharsets.UTF_8);\n\t\t\t\t})\n\t\t\t\t.toArray();\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodeUserInfo(userInfo,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI user info with the given encoding.\n\t * @param userInfo the user info to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded user info\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userInfo",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "String",
    "signature": "public String encodeUserInfo(String userInfo, Charset charset)",
    "source_code": "\tpublic static String encodeUserInfo(String userInfo, Charset charset) {\n\t\treturn encode(userInfo, charset, HierarchicalUriComponents.Type.USER_INFO);\n\t}"
  },
  "org.springframework.web.util.UriUtils#encodeUserInfo(userInfo,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI user info with the given encoding.\n\t * @param userInfo the user info to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded user info\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userInfo",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "String",
    "signature": "public String encodeUserInfo(String userInfo, String encoding)",
    "source_code": "\tpublic static String encodeUserInfo(String userInfo, String encoding) {\n\t\treturn encode(userInfo, encoding, HierarchicalUriComponents.Type.USER_INFO);\n\t}"
  },
  "org.springframework.web.util.UriUtils#extractFileExtension(path)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract the file extension from the given URI path.\n\t * @param path the URI path (for example, \"/products/index.html\")\n\t * @return the extracted file extension (for example, \"html\")\n\t * @since 4.3.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "String",
    "signature": "public String extractFileExtension(String path)",
    "source_code": "\tpublic static @Nullable String extractFileExtension(String path) {\n\t\tint end = path.indexOf('?');\n\t\tint fragmentIndex = path.indexOf('#');\n\t\tif (fragmentIndex != -1 && (end == -1 || fragmentIndex < end)) {\n\t\t\tend = fragmentIndex;\n\t\t}\n\t\tif (end == -1) {\n\t\t\tend = path.length();\n\t\t}\n\t\tint begin = path.lastIndexOf('/', end) + 1;\n\t\tint paramIndex = path.indexOf(';', begin);\n\t\tend = (paramIndex != -1 && paramIndex < end ? paramIndex : end);\n\t\tint extIndex = path.lastIndexOf('.', end);\n\t\tif (extIndex != -1 && extIndex >= begin) {\n\t\t\treturn path.substring(extIndex + 1, end);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.util.pattern.PathPattern#isMatchOptionalTrailingSeparator()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 684
    },
    "return": "boolean",
    "signature": "public boolean isMatchOptionalTrailingSeparator()",
    "source_code": "\t\tpublic boolean isMatchOptionalTrailingSeparator() {\n\t\t\treturn matchOptionalTrailingSeparator;\n\t\t}"
  }
}