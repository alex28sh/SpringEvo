{
  "org.springframework.beans.factory.config.ConstructorArgumentValues#containsNamedArgument()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether at least one argument value refers to a name.\n\t * @since 6.0.3\n\t * @see ValueHolder#getName()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 368
    },
    "return": "boolean",
    "signature": "public boolean containsNamedArgument()",
    "source_code": "\tpublic boolean containsNamedArgument() {\n\t\tfor (ValueHolder valueHolder : this.indexedArgumentValues.values()) {\n\t\t\tif (valueHolder.getName() != null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tfor (ValueHolder valueHolder : this.genericArgumentValues) {\n\t\t\tif (valueHolder.getName() != null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.cglib.beans.Generator": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "signature": "public class Generator",
    "source_code": "    public static class Generator extends AbstractClassGenerator {\n        private static final Source SOURCE = new Source(BeanMap.class.getName());\n\n        private static final BeanMapKey KEY_FACTORY =\n          (BeanMapKey)KeyFactory.create(BeanMapKey.class, KeyFactory.CLASS_BY_NAME);\n\n        interface BeanMapKey {\n            public Object newInstance(Class type, int require);\n        }\n\n        private Object bean;\n        private Class beanClass;\n        private int require;\n\n        public Generator() {\n            super(SOURCE);\n        }\n\n        /**\n         * Set the bean that the generated map should reflect. The bean may be swapped\n         * out for another bean of the same type using {@link #setBean}.\n         * Calling this method overrides any value previously set using {@link #setBeanClass}.\n         * You must call either this method or {@link #setBeanClass} before {@link #create}.\n         * @param bean the initial bean\n         */\n        public void setBean(Object bean) {\n            this.bean = bean;\n            if (bean != null) {\n\t\t\t\tbeanClass = bean.getClass();\n\t\t\t\t// SPRING PATCH BEGIN\n\t\t\t\tsetContextClass(beanClass);\n\t\t\t\t// SPRING PATCH END\n\t\t\t}\n        }\n\n        /**\n         * Set the class of the bean that the generated map should support.\n         * You must call either this method or {@link #setBeanClass} before {@link #create}.\n         * @param beanClass the class of the bean\n         */\n        public void setBeanClass(Class beanClass) {\n            this.beanClass = beanClass;\n        }\n\n        /**\n         * Limit the properties reflected by the generated map.\n         * @param require any combination of {@link #REQUIRE_GETTER} and\n         * {@link #REQUIRE_SETTER}; default is zero (any property allowed)\n         */\n        public void setRequire(int require) {\n            this.require = require;\n        }\n\n        @Override\n\t\tprotected ClassLoader getDefaultClassLoader() {\n            return beanClass.getClassLoader();\n        }\n\n        @Override\n\t\tprotected ProtectionDomain getProtectionDomain() {\n        \treturn ReflectUtils.getProtectionDomain(beanClass);\n        }\n\n        /**\n         * Create a new instance of the <code>BeanMap</code>. An existing\n         * generated class will be reused if possible.\n         */\n        public BeanMap create() {\n            if (beanClass == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Class of bean unknown\");\n\t\t\t}\n            setNamePrefix(beanClass.getName());\n            return (BeanMap)super.create(KEY_FACTORY.newInstance(beanClass, require));\n        }\n\n        @Override\n\t\tpublic void generateClass(ClassVisitor v) throws Exception {\n            new BeanMapEmitter(v, getClassName(), beanClass, require);\n        }\n\n        @Override\n\t\tprotected Object firstInstance(Class type) {\n            return ((BeanMap)ReflectUtils.newInstance(type)).newInstance(bean);\n        }\n\n        @Override\n\t\tprotected Object nextInstance(Object instance) {\n            return ((BeanMap)instance).newInstance(bean);\n        }\n    }"
  },
  "org.springframework.cglib.beans.Generator#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n        throw new UnsupportedOperationException();\n    }"
  },
  "org.springframework.cglib.beans.Generator#containsKey(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n        return keySet().contains(key);\n    }"
  },
  "org.springframework.cglib.beans.Generator#containsValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n        for (Iterator it = keySet().iterator(); it.hasNext();) {\n            Object v = get(it.next());\n            if (((value == null) && (v == null)) || (value != null && value.equals(v))) {\n\t\t\t\treturn true;\n\t\t\t}\n        }\n        return false;\n    }"
  },
  "org.springframework.cglib.beans.Generator#create()": {
    "change": "added",
    "deprecated": false,
    "doc": "        /**\n         * Create a new instance of the <code>BeanMap</code>. An existing\n         * generated class will be reused if possible.\n         */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "BeanMap",
    "signature": "public BeanMap create()",
    "source_code": "        public BeanMap create() {\n            if (beanClass == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Class of bean unknown\");\n\t\t\t}\n            setNamePrefix(beanClass.getName());\n            return (BeanMap)super.create(KEY_FACTORY.newInstance(beanClass, require));\n        }"
  },
  "org.springframework.cglib.beans.Generator#create(bean)": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n     * Helper method to create a new <code>BeanMap</code>.  For finer\n     * control over the generated instance, use a new instance of\n     * <code>BeanMap.Generator</code> instead of this static method.\n     * @param bean the JavaBean underlying the map\n     * @return a new <code>BeanMap</code> instance\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "BeanMap",
    "signature": "public BeanMap create(Object bean)",
    "source_code": "    public static BeanMap create(Object bean) {\n        Generator gen = new Generator();\n        gen.setBean(bean);\n        return gen.create();\n    }"
  },
  "org.springframework.cglib.beans.Generator#entrySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "Set",
    "signature": "public Set entrySet()",
    "source_code": "\tpublic Set entrySet() {\n        HashMap copy = new HashMap();\n        for (Object key : keySet()) {\n            copy.put(key, get(key));\n        }\n        return Collections.unmodifiableMap(copy).entrySet();\n    }"
  },
  "org.springframework.cglib.beans.Generator#equals(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 278
    },
    "return": "boolean",
    "signature": "public boolean equals(Object o)",
    "source_code": "\tpublic boolean equals(Object o) {\n        if (o == null || !(o instanceof Map other)) {\n            return false;\n        }\n        if (size() != other.size()) {\n            return false;\n        }\n        for (Object key : keySet()) {\n            if (!other.containsKey(key)) {\n                return false;\n            }\n            Object v1 = get(key);\n            Object v2 = other.get(key);\n            if (!((v1 == null) ? v2 == null : v1.equals(v2))) {\n                return false;\n            }\n        }\n        return true;\n    }"
  },
  "org.springframework.cglib.beans.Generator#firstInstance(type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "Object",
    "signature": "protected Object firstInstance(Class type)",
    "source_code": "\t\tprotected Object firstInstance(Class type) {\n            return ((BeanMap)ReflectUtils.newInstance(type)).newInstance(bean);\n        }"
  },
  "org.springframework.cglib.beans.Generator#generateClass(v)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "v"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void generateClass(ClassVisitor v)",
    "source_code": "\t\tpublic void generateClass(ClassVisitor v) throws Exception {\n            new BeanMapEmitter(v, getClassName(), beanClass, require);\n        }"
  },
  "org.springframework.cglib.beans.Generator#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "Object",
    "signature": "public Object get(Object key)",
    "source_code": "\tpublic Object get(Object key) {\n        return get(bean, key);\n    }"
  },
  "org.springframework.cglib.beans.Generator#getBean()": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n     * Return the bean currently in use by this map.\n     * @return the current JavaBean\n     * @see #setBean\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "Object",
    "signature": "public Object getBean()",
    "source_code": "    public Object getBean() {\n        return bean;\n    }"
  },
  "org.springframework.cglib.beans.Generator#getDefaultClassLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "ClassLoader",
    "signature": "protected ClassLoader getDefaultClassLoader()",
    "source_code": "\t\tprotected ClassLoader getDefaultClassLoader() {\n            return beanClass.getClassLoader();\n        }"
  },
  "org.springframework.cglib.beans.Generator#getProtectionDomain()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "ProtectionDomain",
    "signature": "protected ProtectionDomain getProtectionDomain()",
    "source_code": "\t\tprotected ProtectionDomain getProtectionDomain() {\n        \treturn ReflectUtils.getProtectionDomain(beanClass);\n        }"
  },
  "org.springframework.cglib.beans.Generator#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n        int code = 0;\n        for (Object key : keySet()) {\n            Object value = get(key);\n            code += ((key == null) ? 0 : key.hashCode()) ^\n                ((value == null) ? 0 : value.hashCode());\n        }\n        return code;\n    }"
  },
  "org.springframework.cglib.beans.Generator#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n        return size() == 0;\n    }"
  },
  "org.springframework.cglib.beans.Generator#newInstance(type,require)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "require"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "Object",
    "signature": "public Object newInstance(Class type, int require)",
    "source_code": "            public Object newInstance(Class type, int require);"
  },
  "org.springframework.cglib.beans.Generator#nextInstance(instance)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "instance"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "Object",
    "signature": "protected Object nextInstance(Object instance)",
    "source_code": "\t\tprotected Object nextInstance(Object instance) {\n            return ((BeanMap)instance).newInstance(bean);\n        }"
  },
  "org.springframework.cglib.beans.Generator#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "Object",
    "signature": "public Object put(Object key, Object value)",
    "source_code": "\tpublic Object put(Object key, Object value) {\n        return put(bean, key, value);\n    }"
  },
  "org.springframework.cglib.beans.Generator#putAll(t)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "void",
    "signature": "public void putAll(Map t)",
    "source_code": "\tpublic void putAll(Map t) {\n        for (Object key : t.keySet()) {\n            put(key, t.get(key));\n        }\n    }"
  },
  "org.springframework.cglib.beans.Generator#remove(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "Object",
    "signature": "public Object remove(Object key)",
    "source_code": "\tpublic Object remove(Object key) {\n        throw new UnsupportedOperationException();\n    }"
  },
  "org.springframework.cglib.beans.Generator#setBean(bean)": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n     * Change the underlying bean this map should use.\n     * @param bean the new JavaBean\n     * @see #getBean\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void setBean(Object bean)",
    "source_code": "    public void setBean(Object bean) {\n        this.bean = bean;\n    }"
  },
  "org.springframework.cglib.beans.Generator#setBeanClass(beanClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "        /**\n         * Set the class of the bean that the generated map should support.\n         * You must call either this method or {@link #setBeanClass} before {@link #create}.\n         * @param beanClass the class of the bean\n         */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void setBeanClass(Class beanClass)",
    "source_code": "        public void setBeanClass(Class beanClass) {\n            this.beanClass = beanClass;\n        }"
  },
  "org.springframework.cglib.beans.Generator#setRequire(require)": {
    "change": "added",
    "deprecated": false,
    "doc": "        /**\n         * Limit the properties reflected by the generated map.\n         * @param require any combination of {@link #REQUIRE_GETTER} and\n         * {@link #REQUIRE_SETTER}; default is zero (any property allowed)\n         */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "require"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "void",
    "signature": "public void setRequire(int require)",
    "source_code": "        public void setRequire(int require) {\n            this.require = require;\n        }"
  },
  "org.springframework.cglib.beans.Generator#size()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\tpublic int size() {\n        return keySet().size();\n    }"
  },
  "org.springframework.cglib.beans.Generator#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n     * Return the bean currently in use by this map.\n     * @return the current JavaBean\n     * @see #setBean\n     */\n    public Object getBean() {\n        return bean;\n    }\n\n    @Override\n\tpublic void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n\tpublic boolean containsKey(Object key) {\n        return keySet().contains(key);\n    }\n\n    @Override\n\tpublic boolean containsValue(Object value) {\n        for (Iterator it = keySet().iterator(); it.hasNext();) {\n            Object v = get(it.next());\n            if (((value == null) && (v == null)) || (value != null && value.equals(v))) {\n\t\t\t\treturn true;\n\t\t\t}\n        }\n        return false;\n    }\n\n    @Override\n\tpublic int size() {\n        return keySet().size();\n    }\n\n    @Override\n\tpublic boolean isEmpty() {\n        return size() == 0;\n    }\n\n    @Override\n\tpublic Object remove(Object key) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n\tpublic void putAll(Map t) {\n        for (Object key : t.keySet()) {\n            put(key, t.get(key));\n        }\n    }\n\n    @Override\n\tpublic boolean equals(Object o) {\n        if (o == null || !(o instanceof Map other)) {\n            return false;\n        }\n        if (size() != other.size()) {\n            return false;\n        }\n        for (Object key : keySet()) {\n            if (!other.containsKey(key)) {\n                return false;\n            }\n            Object v1 = get(key);\n            Object v2 = other.get(key);\n            if (!((v1 == null) ? v2 == null : v1.equals(v2))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @Override\n\tpublic int hashCode() {\n        int code = 0;\n        for (Object key : keySet()) {\n            Object value = get(key);\n            code += ((key == null) ? 0 : key.hashCode()) ^\n                ((value == null) ? 0 : value.hashCode());\n        }\n        return code;\n    }\n\n    // TODO: optimize\n    @Override\n\tpublic Set entrySet() {\n        HashMap copy = new HashMap();\n        for (Object key : keySet()) {\n            copy.put(key, get(key));\n        }\n        return Collections.unmodifiableMap(copy).entrySet();\n    }\n\n    @Override\n\tpublic Collection values() {\n        Set keys = keySet();\n        List values = new ArrayList(keys.size());\n        for (Iterator it = keys.iterator(); it.hasNext();) {\n            values.add(get(it.next()));\n        }\n        return Collections.unmodifiableCollection(values);\n    }\n\n    /*\n     * @see java.util.AbstractMap#toString\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString()"
  },
  "org.springframework.cglib.beans.Generator#values()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "Collection",
    "signature": "public Collection values()",
    "source_code": "\tpublic Collection values() {\n        Set keys = keySet();\n        List values = new ArrayList(keys.size());\n        for (Iterator it = keys.iterator(); it.hasNext();) {\n            values.add(get(it.next()));\n        }\n        return Collections.unmodifiableCollection(values);\n    }"
  },
  "org.springframework.cglib.beans.REQUIRE_GETTER": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n     * Limit the properties reflected in the key set of the map\n     * to readable properties.\n     * @see BeanMap.Generator#setRequire\n     */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public int REQUIRE_GETTER",
    "source_code": "    public static final int REQUIRE_GETTER = 1;",
    "type": "int"
  },
  "org.springframework.cglib.beans.REQUIRE_SETTER": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n     * Limit the properties reflected in the key set of the map\n     * to writable properties.\n     * @see BeanMap.Generator#setRequire\n     */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "signature": "public int REQUIRE_SETTER",
    "source_code": "    public static final int REQUIRE_SETTER = 2;",
    "type": "int"
  },
  "org.springframework.cglib.beans.bean": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "signature": "protected Object bean",
    "source_code": "    protected Object bean;",
    "type": "Object"
  },
  "org.springframework.cglib.core.<unknown>#equals(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 32
    },
    "return": "boolean",
    "signature": "public boolean equals(Object o)",
    "source_code": "\tpublic boolean equals(Object o) {\n\t\tif (o == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(o instanceof MethodInfo other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn getSignature().equals(other.getSignature());\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn getSignature().hashCode();\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\t// TODO: include modifiers, exceptions\n\t\treturn getSignature().toString();\n\t}"
  },
  "org.springframework.cglib.core.ClassEmitter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * @author Juozas Baliuka, Chris Nokleberg\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 30
    },
    "signature": "public class ClassEmitter",
    "source_code": "public class ClassEmitter extends ClassTransformer {\n    private ClassInfo classInfo;\n    private Map fieldInfo;\n\n    private static int hookCounter;\n    private MethodVisitor rawStaticInit;\n    private CodeEmitter staticInit;\n    private CodeEmitter staticHook;\n    private Signature staticHookSig;\n\n    public ClassEmitter(ClassVisitor cv) {\n        setTarget(cv);\n    }\n\n    public ClassEmitter() {\n        super(Constants.ASM_API);\n    }\n\n    @Override\n\tpublic void setTarget(ClassVisitor cv) {\n        this.cv = cv;\n        fieldInfo = new HashMap();\n\n        // just to be safe\n        staticInit = staticHook = null;\n        staticHookSig = null;\n    }\n\n    synchronized private static int getNextHook() {\n        return ++hookCounter;\n    }\n\n    public ClassInfo getClassInfo() {\n        return classInfo;\n    }\n\n    public void begin_class(int version, final int access, String className, final Type superType, final Type[] interfaces, String source) {\n        final Type classType = Type.getType(\"L\" + className.replace('.', '/') + \";\");\n        classInfo = new ClassInfo() {\n            @Override\n\t\t\tpublic Type getType() {\n                return classType;\n            }\n            @Override\n\t\t\tpublic Type getSuperType() {\n                return (superType != null) ? superType : Constants.TYPE_OBJECT;\n            }\n            @Override\n\t\t\tpublic Type[] getInterfaces() {\n                return interfaces;\n            }\n            @Override\n\t\t\tpublic int getModifiers() {\n                return access;\n            }\n        };\n        cv.visit(version,\n                 access,\n                 classInfo.getType().getInternalName(),\n                 null,\n                 classInfo.getSuperType().getInternalName(),\n                 TypeUtils.toInternalNames(interfaces));\n        if (source != null) {\n\t\t\tcv.visitSource(source, null);\n\t\t}\n        init();\n    }\n\n    public CodeEmitter getStaticHook() {\n         if (TypeUtils.isInterface(getAccess())) {\n             throw new IllegalStateException(\"static hook is invalid for this class\");\n         }\n         if (staticHook == null) {\n             staticHookSig = new Signature(\"CGLIB$STATICHOOK\" + getNextHook(), \"()V\");\n             staticHook = begin_method(Constants.ACC_STATIC,\n                                       staticHookSig,\n                                       null);\n             if (staticInit != null) {\n                 staticInit.invoke_static_this(staticHookSig);\n             }\n         }\n         return staticHook;\n    }\n\n    protected void init() {\n    }\n\n    public int getAccess() {\n        return classInfo.getModifiers();\n    }\n\n    public Type getClassType() {\n        return classInfo.getType();\n    }\n\n    public Type getSuperType() {\n        return classInfo.getSuperType();\n    }\n\n    public void end_class() {\n        if (staticHook != null && staticInit == null) {\n            // force creation of static init\n            begin_static();\n        }\n        if (staticInit != null) {\n            staticHook.return_value();\n            staticHook.end_method();\n            rawStaticInit.visitInsn(Constants.RETURN);\n            rawStaticInit.visitMaxs(0, 0);\n            staticInit = staticHook = null;\n            staticHookSig = null;\n        }\n        cv.visitEnd();\n    }\n\n    public CodeEmitter begin_method(int access, Signature sig, Type[] exceptions) {\n        if (classInfo == null) {\n\t\t\tthrow new IllegalStateException(\"classInfo is null! \" + this);\n\t\t}\n        MethodVisitor v = cv.visitMethod(access,\n                                         sig.getName(),\n                                         sig.getDescriptor(),\n                                         null,\n                                         TypeUtils.toInternalNames(exceptions));\n        if (sig.equals(Constants.SIG_STATIC) && !TypeUtils.isInterface(getAccess())) {\n            rawStaticInit = v;\n            MethodVisitor wrapped = new MethodVisitor(Constants.ASM_API, v) {\n                @Override\n\t\t\t\tpublic void visitMaxs(int maxStack, int maxLocals) {\n                    // ignore\n                }\n                @Override\n\t\t\t\tpublic void visitInsn(int insn) {\n                    if (insn != Constants.RETURN) {\n                        super.visitInsn(insn);\n                    }\n                }\n            };\n            staticInit = new CodeEmitter(this, wrapped, access, sig, exceptions);\n            if (staticHook == null) {\n                // force static hook creation\n                getStaticHook();\n            } else {\n                staticInit.invoke_static_this(staticHookSig);\n            }\n            return staticInit;\n        } else if (sig.equals(staticHookSig)) {\n            return new CodeEmitter(this, v, access, sig, exceptions) {\n                @Override\n\t\t\t\tpublic boolean isStaticHook() {\n                    return true;\n                }\n            };\n        } else {\n            return new CodeEmitter(this, v, access, sig, exceptions);\n        }\n    }\n\n    public CodeEmitter begin_static() {\n        return begin_method(Constants.ACC_STATIC, Constants.SIG_STATIC, null);\n    }\n\n    public void declare_field(int access, String name, Type type, Object value) {\n        FieldInfo existing = (FieldInfo)fieldInfo.get(name);\n        FieldInfo info = new FieldInfo(access, name, type, value);\n        if (existing != null) {\n            if (!info.equals(existing)) {\n                throw new IllegalArgumentException(\"Field \\\"\" + name + \"\\\" has been declared differently\");\n            }\n        } else {\n            fieldInfo.put(name, info);\n            cv.visitField(access, name, type.getDescriptor(), null, value);\n        }\n    }\n\n    // TODO: make public?\n    boolean isFieldDeclared(String name) {\n        return fieldInfo.get(name) != null;\n    }\n\n    FieldInfo getFieldInfo(String name) {\n        FieldInfo field = (FieldInfo)fieldInfo.get(name);\n        if (field == null) {\n            throw new IllegalArgumentException(\"Field \" + name + \" is not declared in \" + getClassType().getClassName());\n        }\n        return field;\n    }\n\n    static class FieldInfo {\n        int access;\n        String name;\n        Type type;\n        Object value;\n\n        public FieldInfo(int access, String name, Type type, Object value) {\n            this.access = access;\n            this.name = name;\n            this.type = type;\n            this.value = value;\n        }\n\n        @Override\n\t\tpublic boolean equals(Object o) {\n            if (o == null) {\n\t\t\t\treturn false;\n\t\t\t}\n            if (!(o instanceof FieldInfo other)) {\n\t\t\t\treturn false;\n\t\t\t}\n            if (access != other.access ||\n                !name.equals(other.name) ||\n                !type.equals(other.type)) {\n                return false;\n            }\n            if ((value == null) ^ (other.value == null)) {\n\t\t\t\treturn false;\n\t\t\t}\n            if (value != null && !value.equals(other.value)) {\n\t\t\t\treturn false;\n\t\t\t}\n            return true;\n        }\n\n        @Override\n\t\tpublic int hashCode() {\n            return access ^ name.hashCode() ^ type.hashCode() ^ ((value == null) ? 0 : value.hashCode());\n        }\n    }\n\n    @Override\n\tpublic void visit(int version,\n                      int access,\n                      String name,\n                      String signature,\n                      String superName,\n                      String[] interfaces) {\n        begin_class(version,\n                    access,\n                    name.replace('/', '.'),\n                    TypeUtils.fromInternalName(superName),\n                    TypeUtils.fromInternalNames(interfaces),\n                    null); // TODO\n    }\n\n    @Override\n\tpublic void visitEnd() {\n        end_class();\n    }\n\n    @Override\n\tpublic FieldVisitor visitField(int access,\n                                   String name,\n                                   String desc,\n                                   String signature,\n                                   Object value) {\n        declare_field(access, name, Type.getType(desc), value);\n        return null; // TODO\n    }\n\n    @Override\n\tpublic MethodVisitor visitMethod(int access,\n                                     String name,\n                                     String desc,\n                                     String signature,\n                                     String[] exceptions) {\n        return begin_method(access,\n                            new Signature(name, desc),\n                            TypeUtils.fromInternalNames(exceptions));\n    }\n}"
  },
  "org.springframework.cglib.core.ClassEmitter#begin_class(version,access,className,superType,interfaces,source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "version",
      "access",
      "className",
      "superType",
      "interfaces",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void begin_class(int version, final int access, String className, final Type superType, final Type[] interfaces, String source)",
    "source_code": "    public void begin_class(int version, final int access, String className, final Type superType, final Type[] interfaces, String source) {\n        final Type classType = Type.getType(\"L\" + className.replace('.', '/') + \";\");\n        classInfo = new ClassInfo() {\n            @Override\n\t\t\tpublic Type getType() {\n                return classType;\n            }\n            @Override\n\t\t\tpublic Type getSuperType() {\n                return (superType != null) ? superType : Constants.TYPE_OBJECT;\n            }\n            @Override\n\t\t\tpublic Type[] getInterfaces() {\n                return interfaces;\n            }\n            @Override\n\t\t\tpublic int getModifiers() {\n                return access;\n            }\n        };\n        cv.visit(version,\n                 access,\n                 classInfo.getType().getInternalName(),\n                 null,\n                 classInfo.getSuperType().getInternalName(),\n                 TypeUtils.toInternalNames(interfaces));\n        if (source != null) {\n\t\t\tcv.visitSource(source, null);\n\t\t}\n        init();\n    }"
  },
  "org.springframework.cglib.core.ClassEmitter#begin_method(access,sig,exceptions)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "access",
      "sig",
      "exceptions"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "CodeEmitter",
    "signature": "public CodeEmitter begin_method(int access, Signature sig, Type[] exceptions)",
    "source_code": "    public CodeEmitter begin_method(int access, Signature sig, Type[] exceptions) {\n        if (classInfo == null) {\n\t\t\tthrow new IllegalStateException(\"classInfo is null! \" + this);\n\t\t}\n        MethodVisitor v = cv.visitMethod(access,\n                                         sig.getName(),\n                                         sig.getDescriptor(),\n                                         null,\n                                         TypeUtils.toInternalNames(exceptions));\n        if (sig.equals(Constants.SIG_STATIC) && !TypeUtils.isInterface(getAccess())) {\n            rawStaticInit = v;\n            MethodVisitor wrapped = new MethodVisitor(Constants.ASM_API, v) {\n                @Override\n\t\t\t\tpublic void visitMaxs(int maxStack, int maxLocals) {\n                    // ignore\n                }\n                @Override\n\t\t\t\tpublic void visitInsn(int insn) {\n                    if (insn != Constants.RETURN) {\n                        super.visitInsn(insn);\n                    }\n                }\n            };\n            staticInit = new CodeEmitter(this, wrapped, access, sig, exceptions);\n            if (staticHook == null) {\n                // force static hook creation\n                getStaticHook();\n            } else {\n                staticInit.invoke_static_this(staticHookSig);\n            }\n            return staticInit;\n        } else if (sig.equals(staticHookSig)) {\n            return new CodeEmitter(this, v, access, sig, exceptions) {\n                @Override\n\t\t\t\tpublic boolean isStaticHook() {\n                    return true;\n                }\n            };\n        } else {\n            return new CodeEmitter(this, v, access, sig, exceptions);\n        }\n    }"
  },
  "org.springframework.cglib.core.ClassEmitter#begin_static()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "CodeEmitter",
    "signature": "public CodeEmitter begin_static()",
    "source_code": "    public CodeEmitter begin_static() {\n        return begin_method(Constants.ACC_STATIC, Constants.SIG_STATIC, null);\n    }"
  },
  "org.springframework.cglib.core.ClassEmitter#declare_field(access,name,type,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "access",
      "name",
      "type",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "public void declare_field(int access, String name, Type type, Object value)",
    "source_code": "    public void declare_field(int access, String name, Type type, Object value) {\n        FieldInfo existing = (FieldInfo)fieldInfo.get(name);\n        FieldInfo info = new FieldInfo(access, name, type, value);\n        if (existing != null) {\n            if (!info.equals(existing)) {\n                throw new IllegalArgumentException(\"Field \\\"\" + name + \"\\\" has been declared differently\");\n            }\n        } else {\n            fieldInfo.put(name, info);\n            cv.visitField(access, name, type.getDescriptor(), null, value);\n        }\n    }"
  },
  "org.springframework.cglib.core.ClassEmitter#end_class()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "void",
    "signature": "public void end_class()",
    "source_code": "    public void end_class() {\n        if (staticHook != null && staticInit == null) {\n            // force creation of static init\n            begin_static();\n        }\n        if (staticInit != null) {\n            staticHook.return_value();\n            staticHook.end_method();\n            rawStaticInit.visitInsn(Constants.RETURN);\n            rawStaticInit.visitMaxs(0, 0);\n            staticInit = staticHook = null;\n            staticHookSig = null;\n        }\n        cv.visitEnd();\n    }"
  },
  "org.springframework.cglib.core.ClassEmitter#equals(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "boolean",
    "signature": "public boolean equals(Object o)",
    "source_code": "\t\tpublic boolean equals(Object o) {\n            if (o == null) {\n\t\t\t\treturn false;\n\t\t\t}\n            if (!(o instanceof FieldInfo other)) {\n\t\t\t\treturn false;\n\t\t\t}\n            if (access != other.access ||\n                !name.equals(other.name) ||\n                !type.equals(other.type)) {\n                return false;\n            }\n            if ((value == null) ^ (other.value == null)) {\n\t\t\t\treturn false;\n\t\t\t}\n            if (value != null && !value.equals(other.value)) {\n\t\t\t\treturn false;\n\t\t\t}\n            return true;\n        }"
  },
  "org.springframework.cglib.core.ClassEmitter#getAccess()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "int",
    "signature": "public int getAccess()",
    "source_code": "    public int getAccess() {\n        return classInfo.getModifiers();\n    }"
  },
  "org.springframework.cglib.core.ClassEmitter#getClassInfo()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "ClassInfo",
    "signature": "public ClassInfo getClassInfo()",
    "source_code": "    public ClassInfo getClassInfo() {\n        return classInfo;\n    }"
  },
  "org.springframework.cglib.core.ClassEmitter#getClassType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "Type",
    "signature": "public Type getClassType()",
    "source_code": "    public Type getClassType() {\n        return classInfo.getType();\n    }"
  },
  "org.springframework.cglib.core.ClassEmitter#getInterfaces()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "Type[]",
    "signature": "public Type[] getInterfaces()",
    "source_code": "\t\t\tpublic Type[] getInterfaces() {\n                return interfaces;\n            }"
  },
  "org.springframework.cglib.core.ClassEmitter#getModifiers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "int",
    "signature": "public int getModifiers()",
    "source_code": "\t\t\tpublic int getModifiers() {\n                return access;\n            }"
  },
  "org.springframework.cglib.core.ClassEmitter#getStaticHook()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "CodeEmitter",
    "signature": "public CodeEmitter getStaticHook()",
    "source_code": "    public CodeEmitter getStaticHook() {\n         if (TypeUtils.isInterface(getAccess())) {\n             throw new IllegalStateException(\"static hook is invalid for this class\");\n         }\n         if (staticHook == null) {\n             staticHookSig = new Signature(\"CGLIB$STATICHOOK\" + getNextHook(), \"()V\");\n             staticHook = begin_method(Constants.ACC_STATIC,\n                                       staticHookSig,\n                                       null);\n             if (staticInit != null) {\n                 staticInit.invoke_static_this(staticHookSig);\n             }\n         }\n         return staticHook;\n    }"
  },
  "org.springframework.cglib.core.ClassEmitter#getSuperType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "Type",
    "signature": "public Type getSuperType()",
    "source_code": "    public Type getSuperType() {\n        return classInfo.getSuperType();\n    }"
  },
  "org.springframework.cglib.core.ClassEmitter#getType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "Type",
    "signature": "public Type getType()",
    "source_code": "\t\t\tpublic Type getType() {\n                return classType;\n            }"
  },
  "org.springframework.cglib.core.ClassEmitter#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n            return access ^ name.hashCode() ^ type.hashCode() ^ ((value == null) ? 0 : value.hashCode());\n        }"
  },
  "org.springframework.cglib.core.ClassEmitter#init()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "void",
    "signature": "protected void init()",
    "source_code": "    protected void init() {\n    }"
  },
  "org.springframework.cglib.core.ClassEmitter#isStaticHook()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "boolean",
    "signature": "public boolean isStaticHook()",
    "source_code": "\t\t\t\tpublic boolean isStaticHook() {\n                    return true;\n                }"
  },
  "org.springframework.cglib.core.ClassEmitter#setTarget(cv)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cv"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "void",
    "signature": "public void setTarget(ClassVisitor cv)",
    "source_code": "\tpublic void setTarget(ClassVisitor cv) {\n        this.cv = cv;\n        fieldInfo = new HashMap();\n\n        // just to be safe\n        staticInit = staticHook = null;\n        staticHookSig = null;\n    }"
  },
  "org.springframework.cglib.core.ClassEmitter#visit(version,access,name,signature,superName,interfaces)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "version",
      "access",
      "name",
      "signature",
      "superName",
      "interfaces"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "void",
    "signature": "public void visit(int version,\n                      int access,\n                      String name,\n                      String signature,\n                      String superName,\n                      String[] interfaces)",
    "source_code": "\tpublic void visit(int version,"
  },
  "org.springframework.cglib.core.ClassEmitter#visitEnd()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "void",
    "signature": "public void visitEnd()",
    "source_code": "\tpublic void visitEnd() {\n        end_class();\n    }"
  },
  "org.springframework.cglib.core.ClassEmitter#visitField(access,name,desc,signature,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "access",
      "name",
      "desc",
      "signature",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "FieldVisitor",
    "signature": "public FieldVisitor visitField(int access,\n                                   String name,\n                                   String desc,\n                                   String signature,\n                                   Object value)",
    "source_code": "\tpublic FieldVisitor visitField(int access,"
  },
  "org.springframework.cglib.core.ClassEmitter#visitInsn(insn)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "insn"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void visitInsn(int insn)",
    "source_code": "\t\t\t\tpublic void visitInsn(int insn) {\n                    if (insn != Constants.RETURN) {\n                        super.visitInsn(insn);\n                    }\n                }"
  },
  "org.springframework.cglib.core.ClassEmitter#visitMaxs(maxStack,maxLocals)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "maxStack",
      "maxLocals"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "public void visitMaxs(int maxStack, int maxLocals)",
    "source_code": "\t\t\t\tpublic void visitMaxs(int maxStack, int maxLocals) {\n                    // ignore\n                }"
  },
  "org.springframework.cglib.core.ClassEmitter#visitMethod(access,name,desc,signature,exceptions)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "access",
      "name",
      "desc",
      "signature",
      "exceptions"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "MethodVisitor",
    "signature": "public MethodVisitor visitMethod(int access,\n                                     String name,\n                                     String desc,\n                                     String signature,\n                                     String[] exceptions)",
    "source_code": "\tpublic MethodVisitor visitMethod(int access,"
  },
  "org.springframework.cglib.core.ClassLoaderData": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "signature": "protected class ClassLoaderData",
    "source_code": "\tprotected static class ClassLoaderData {\n\n\t\tprivate final Set<String> reservedClassNames = new HashSet<>();\n\n\t\t/**\n\t\t * {@link AbstractClassGenerator} here holds \"cache key\" (e.g. {@link org.springframework.cglib.proxy.Enhancer}\n\t\t * configuration), and the value is the generated class plus some additional values\n\t\t * (see {@link #unwrapCachedValue(Object)}.\n\t\t * <p>The generated classes can be reused as long as their classloader is reachable.</p>\n\t\t * <p>Note: the only way to access a class is to find it through generatedClasses cache, thus\n\t\t * the key should not expire as long as the class itself is alive (its classloader is alive).</p>\n\t\t */\n\t\tprivate final LoadingCache<AbstractClassGenerator, Object, Object> generatedClasses;\n\n\t\t/**\n\t\t * Note: ClassLoaderData object is stored as a value of {@code WeakHashMap<ClassLoader, ...>} thus\n\t\t * this classLoader reference should be weak otherwise it would make classLoader strongly reachable\n\t\t * and alive forever.\n\t\t * Reference queue is not required since the cleanup is handled by {@link WeakHashMap}.\n\t\t */\n\t\tprivate final WeakReference<ClassLoader> classLoader;\n\n\t\tprivate final Predicate uniqueNamePredicate = this.reservedClassNames::contains;\n\n\t\tprivate static final Function<AbstractClassGenerator, Object> GET_KEY = gen -> gen.key;\n\n\t\tpublic ClassLoaderData(ClassLoader classLoader) {\n\t\t\tif (classLoader == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"classLoader == null is not yet supported\");\n\t\t\t}\n\t\t\tthis.classLoader = new WeakReference<>(classLoader);\n\t\t\tFunction<AbstractClassGenerator, Object> load = gen -> {\n\t\t\t\tClass klass = gen.generate(ClassLoaderData.this);\n\t\t\t\treturn gen.wrapCachedClass(klass);\n\t\t\t};\n\t\t\tgeneratedClasses = new LoadingCache<>(GET_KEY, load);\n\t\t}\n\n\t\tpublic ClassLoader getClassLoader() {\n\t\t\treturn classLoader.get();\n\t\t}\n\n\t\tpublic void reserveName(String name) {\n\t\t\treservedClassNames.add(name);\n\t\t}\n\n\t\tpublic Predicate getUniqueNamePredicate() {\n\t\t\treturn uniqueNamePredicate;\n\t\t}\n\n\t\tpublic Object get(AbstractClassGenerator gen, boolean useCache) {\n\t\t\tif (!useCache) {\n\t\t\t\treturn gen.generate(ClassLoaderData.this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject cachedValue = generatedClasses.get(gen);\n\t\t\t\treturn gen.unwrapCachedValue(cachedValue);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#create(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "Object",
    "signature": "protected Object create(Object key)",
    "source_code": "\tprotected Object create(Object key) {\n\t\ttry {\n\t\t\tClassLoader loader = getClassLoader();\n\t\t\tMap<ClassLoader, ClassLoaderData> cache = CACHE;\n\t\t\tClassLoaderData data = cache.get(loader);\n\t\t\tif (data == null) {\n\t\t\t\tsynchronized (AbstractClassGenerator.class) {\n\t\t\t\t\tcache = CACHE;\n\t\t\t\t\tdata = cache.get(loader);\n\t\t\t\t\tif (data == null) {\n\t\t\t\t\t\tMap<ClassLoader, ClassLoaderData> newCache = new WeakHashMap<>(cache);\n\t\t\t\t\t\tdata = new ClassLoaderData(loader);\n\t\t\t\t\t\tnewCache.put(loader, data);\n\t\t\t\t\t\tCACHE = newCache;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.key = key;\n\t\t\tObject obj = data.get(this, getUseCache());\n\t\t\tif (obj instanceof Class<?> clazz) {\n\t\t\t\treturn firstInstance(clazz);\n\t\t\t}\n\t\t\treturn nextInstance(obj);\n\t\t}\n\t\tcatch (RuntimeException | Error ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new CodeGenerationException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#generate(data)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "data"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "Class",
    "signature": "protected Class generate(ClassLoaderData data)",
    "source_code": "\tprotected Class generate(ClassLoaderData data) {\n\t\tClass gen;\n\t\tObject save = CURRENT.get();\n\t\tCURRENT.set(this);\n\t\ttry {\n\t\t\tClassLoader classLoader = data.getClassLoader();\n\t\t\tif (classLoader == null) {\n\t\t\t\tthrow new IllegalStateException(\"ClassLoader is null while trying to define class \" +\n\t\t\t\t\t\tgetClassName() + \". It seems that the loader has been expired from a weak reference somehow. \" +\n\t\t\t\t\t\t\"Please file an issue at cglib's issue tracker.\");\n\t\t\t}\n\t\t\tsynchronized (classLoader) {\n\t\t\t\tString name = generateClassName(data.getUniqueNamePredicate());\n\t\t\t\tdata.reserveName(name);\n\t\t\t\tthis.setClassName(name);\n\t\t\t}\n\t\t\tif (attemptLoad) {\n\t\t\t\ttry {\n\t\t\t\t\t// SPRING PATCH BEGIN\n\t\t\t\t\tsynchronized (classLoader) { // just in case\n\t\t\t\t\t\tgen = ReflectUtils.loadClass(getClassName(), classLoader);\n\t\t\t\t\t}\n\t\t\t\t\t// SPRING PATCH END\n\t\t\t\t\treturn gen;\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException e) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\t// SPRING PATCH BEGIN\n\t\t\tif (imageCode) {\n\t\t\t\tthrow new UnsupportedOperationException(\"CGLIB runtime enhancement not supported on native image. \" +\n\t\t\t\t\t\t\"Make sure to include a pre-generated class on the classpath instead: \" + getClassName());\n\t\t\t}\n\t\t\t// SPRING PATCH END\n\t\t\tbyte[] b = strategy.generate(this);\n\t\t\tString className = ClassNameReader.getClassName(new ClassReader(b));\n\t\t\tProtectionDomain protectionDomain = getProtectionDomain();\n\t\t\tsynchronized (classLoader) { // just in case\n\t\t\t\t// SPRING PATCH BEGIN\n\t\t\t\tgen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain, contextClass);\n\t\t\t\t// SPRING PATCH END\n\t\t\t}\n\t\t\treturn gen;\n\t\t}\n\t\tcatch (RuntimeException | Error ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new CodeGenerationException(ex);\n\t\t}\n\t\tfinally {\n\t\t\tCURRENT.set(save);\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#get(gen,useCache)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "gen",
      "useCache"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "Object",
    "signature": "public Object get(AbstractClassGenerator gen, boolean useCache)",
    "source_code": "\t\tpublic Object get(AbstractClassGenerator gen, boolean useCache) {\n\t\t\tif (!useCache) {\n\t\t\t\treturn gen.generate(ClassLoaderData.this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject cachedValue = generatedClasses.get(gen);\n\t\t\t\treturn gen.unwrapCachedValue(cachedValue);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#getAttemptLoad()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "boolean",
    "signature": "public boolean getAttemptLoad()",
    "source_code": "\tpublic boolean getAttemptLoad() {\n\t\treturn attemptLoad;\n\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#getClassLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "ClassLoader",
    "signature": "public ClassLoader getClassLoader()",
    "source_code": "\tpublic ClassLoader getClassLoader() {\n\t\tClassLoader t = classLoader;\n\t\tif (t == null) {\n\t\t\tt = getDefaultClassLoader();\n\t\t}\n\t\tif (t == null) {\n\t\t\tt = getClass().getClassLoader();\n\t\t}\n\t\tif (t == null) {\n\t\t\tt = Thread.currentThread().getContextClassLoader();\n\t\t}\n\t\tif (t == null) {\n\t\t\tthrow new IllegalStateException(\"Cannot determine classloader\");\n\t\t}\n\t\treturn t;\n\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#getCurrent()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Used internally by CGLIB. Returns the <code>AbstractClassGenerator</code>\n\t * that is being used to generate a class in the current thread.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "AbstractClassGenerator",
    "signature": "public AbstractClassGenerator getCurrent()",
    "source_code": "\tpublic static AbstractClassGenerator getCurrent() {\n\t\treturn (AbstractClassGenerator) CURRENT.get();\n\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#getNamingPolicy()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see #setNamingPolicy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "NamingPolicy",
    "signature": "public NamingPolicy getNamingPolicy()",
    "source_code": "\tpublic NamingPolicy getNamingPolicy() {\n\t\treturn namingPolicy;\n\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#getProtectionDomain()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the protection domain to use when defining the class.\n\t * <p>\n\t * Default implementation returns <code>null</code> for using a default protection domain. Sub-classes may\n\t * override to use a more specific protection domain.\n\t * </p>\n\t * @return the protection domain (<code>null</code> for using a default)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "ProtectionDomain",
    "signature": "protected ProtectionDomain getProtectionDomain()",
    "source_code": "\tprotected ProtectionDomain getProtectionDomain() {\n\t\treturn null;\n\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#getStrategy()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see #setStrategy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "GeneratorStrategy",
    "signature": "public GeneratorStrategy getStrategy()",
    "source_code": "\tpublic GeneratorStrategy getStrategy() {\n\t\treturn strategy;\n\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#getUniqueNamePredicate()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "Predicate",
    "signature": "public Predicate getUniqueNamePredicate()",
    "source_code": "\t\tpublic Predicate getUniqueNamePredicate() {\n\t\t\treturn uniqueNamePredicate;\n\t\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#getUseCache()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see #setUseCache\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "boolean",
    "signature": "public boolean getUseCache()",
    "source_code": "\tpublic boolean getUseCache() {\n\t\treturn useCache;\n\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#reserveName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void reserveName(String name)",
    "source_code": "\t\tpublic void reserveName(String name) {\n\t\t\treservedClassNames.add(name);\n\t\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#setAttemptLoad(attemptLoad)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * If set, CGLIB will attempt to load classes from the specified\n\t * <code>ClassLoader</code> before generating them. Because generated\n\t * class names are not guaranteed to be unique, the default is <code>false</code>.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attemptLoad"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "void",
    "signature": "public void setAttemptLoad(boolean attemptLoad)",
    "source_code": "\tpublic void setAttemptLoad(boolean attemptLoad) {\n\t\tthis.attemptLoad = attemptLoad;\n\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#setClassLoader(classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the <code>ClassLoader</code> in which the class will be generated.\n\t * Concrete subclasses of <code>AbstractClassGenerator</code> (such as <code>Enhancer</code>)\n\t * will try to choose an appropriate default if this is unset.\n\t * <p>\n\t * Classes are cached per-<code>ClassLoader</code> using a <code>WeakHashMap</code>, to allow\n\t * the generated classes to be removed when the associated loader is garbage collected.\n\t * @param classLoader the loader to generate the new class with, or null to use the default\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "void",
    "signature": "public void setClassLoader(ClassLoader classLoader)",
    "source_code": "\tpublic void setClassLoader(ClassLoader classLoader) {\n\t\tthis.classLoader = classLoader;\n\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#setContextClass(contextClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contextClass"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "void",
    "signature": "public void setContextClass(Class contextClass)",
    "source_code": "\tpublic void setContextClass(Class contextClass) {\n\t\tthis.contextClass = contextClass;\n\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#setNamePrefix(namePrefix)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "namePrefix"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "void",
    "signature": "protected void setNamePrefix(String namePrefix)",
    "source_code": "\tprotected void setNamePrefix(String namePrefix) {\n\t\tthis.namePrefix = namePrefix;\n\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#setNamingPolicy(namingPolicy)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Override the default naming policy.\n\t * @param namingPolicy the custom policy, or null to use the default\n\t * @see DefaultNamingPolicy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "namingPolicy"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "void",
    "signature": "public void setNamingPolicy(NamingPolicy namingPolicy)",
    "source_code": "\tpublic void setNamingPolicy(NamingPolicy namingPolicy) {\n\t\tif (namingPolicy == null) {\n\t\t\tnamingPolicy = DefaultNamingPolicy.INSTANCE;\n\t\t}\n\t\tthis.namingPolicy = namingPolicy;\n\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#setStrategy(strategy)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the strategy to use to create the bytecode from this generator.\n\t * By default an instance of {@link DefaultGeneratorStrategy} is used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "strategy"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "void",
    "signature": "public void setStrategy(GeneratorStrategy strategy)",
    "source_code": "\tpublic void setStrategy(GeneratorStrategy strategy) {\n\t\tif (strategy == null) {\n\t\t\tstrategy = DefaultGeneratorStrategy.INSTANCE;\n\t\t}\n\t\tthis.strategy = strategy;\n\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#setUseCache(useCache)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether use and update the static cache of generated classes\n\t * for a class with the same properties. Default is <code>true</code>.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "useCache"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "void",
    "signature": "public void setUseCache(boolean useCache)",
    "source_code": "\tpublic void setUseCache(boolean useCache) {\n\t\tthis.useCache = useCache;\n\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#unwrapCachedValue(cached)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cached"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "Object",
    "signature": "protected Object unwrapCachedValue(T cached)",
    "source_code": "\tprotected Object unwrapCachedValue(T cached) {\n\t\treturn ((WeakReference) cached).get();\n\t}"
  },
  "org.springframework.cglib.core.ClassLoaderData#wrapCachedClass(klass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "klass"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "T",
    "signature": "protected T wrapCachedClass(Class klass)",
    "source_code": "\tprotected T wrapCachedClass(Class klass) {\n\t\treturn (T) new WeakReference(klass);\n\t}"
  },
  "org.springframework.cglib.core.LocalVariablesSorter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@link MethodVisitor} that renumbers local variables in their order of\n * appearance. This adapter allows one to easily add new local variables to a\n * method.\n *\n * @author Chris Nokleberg\n * @author Eric Bruneton\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public class LocalVariablesSorter",
    "source_code": "public class LocalVariablesSorter extends MethodVisitor {\n\n    /**\n     * Mapping from old to new local variable indexes. A local variable at index\n     * i of size 1 is remapped to 'mapping[2*i]', while a local variable at\n     * index i of size 2 is remapped to 'mapping[2*i+1]'.\n     */\n    private static class State\n    {\n        int[] mapping = new int[40];\n        int nextLocal;\n    }\n\n    protected final int firstLocal;\n    private final State state;\n\n    public LocalVariablesSorter(\n        final int access,\n        final String desc,\n        final MethodVisitor mv)\n    {\n        super(Constants.ASM_API, mv);\n        state = new State();\n        Type[] args = Type.getArgumentTypes(desc);\n        state.nextLocal = ((Opcodes.ACC_STATIC & access) != 0) ? 0 : 1;\n        for (Type arg : args) {\n            state.nextLocal += arg.getSize();\n        }\n        firstLocal = state.nextLocal;\n    }\n\n    public LocalVariablesSorter(LocalVariablesSorter lvs) {\n        super(Constants.ASM_API, lvs.mv);\n        state = lvs.state;\n        firstLocal = lvs.firstLocal;\n    }\n\n    @Override\n\tpublic void visitVarInsn(final int opcode, final int var) {\n        int size = switch (opcode) {\n\t\t\tcase Opcodes.LLOAD, Opcodes.LSTORE, Opcodes.DLOAD, Opcodes.DSTORE -> 2;\n\t\t\tdefault -> 1;\n\t\t};\n        mv.visitVarInsn(opcode, remap(var, size));\n    }\n\n    @Override\n\tpublic void visitIincInsn(final int var, final int increment) {\n        mv.visitIincInsn(remap(var, 1), increment);\n    }\n\n    @Override\n\tpublic void visitMaxs(final int maxStack, final int maxLocals) {\n        mv.visitMaxs(maxStack, state.nextLocal);\n    }\n\n    @Override\n\tpublic void visitLocalVariable(\n        final String name,\n        final String desc,\n        final String signature,\n        final Label start,\n        final Label end,\n        final int index)\n    {\n        mv.visitLocalVariable(name, desc, signature, start, end, remap(index));\n    }\n\n    // -------------\n\n    protected int newLocal(final int size) {\n        int var = state.nextLocal;\n        state.nextLocal += size;\n        return var;\n    }\n\n    private int remap(final int var, final int size) {\n        if (var < firstLocal) {\n            return var;\n        }\n        int key = 2 * var + size - 1;\n        int length = state.mapping.length;\n        if (key >= length) {\n            int[] newMapping = new int[Math.max(2 * length, key + 1)];\n            System.arraycopy(state.mapping, 0, newMapping, 0, length);\n            state.mapping = newMapping;\n        }\n        int value = state.mapping[key];\n        if (value == 0) {\n            value = state.nextLocal + 1;\n            state.mapping[key] = value;\n            state.nextLocal += size;\n        }\n        return value - 1;\n    }\n\n    private int remap(final int var) {\n        if (var < firstLocal) {\n            return var;\n        }\n        int key = 2 * var;\n        int value = key < state.mapping.length ? state.mapping[key] : 0;\n        if (value == 0) {\n            value = key + 1 < state.mapping.length ? state.mapping[key + 1] : 0;\n        }\n        if (value == 0) {\n            throw new IllegalStateException(\"Unknown local variable \" + var);\n        }\n        return value - 1;\n    }\n}"
  },
  "org.springframework.cglib.core.LocalVariablesSorter#newLocal(size)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "size"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "int",
    "signature": "protected int newLocal(final int size)",
    "source_code": "    protected int newLocal(final int size) {\n        int var = state.nextLocal;\n        state.nextLocal += size;\n        return var;\n    }"
  },
  "org.springframework.cglib.core.LocalVariablesSorter#visitIincInsn(var,increment)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "var",
      "increment"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "void",
    "signature": "public void visitIincInsn(final int var, final int increment)",
    "source_code": "\tpublic void visitIincInsn(final int var, final int increment) {\n        mv.visitIincInsn(remap(var, 1), increment);\n    }"
  },
  "org.springframework.cglib.core.LocalVariablesSorter#visitLocalVariable(name,desc,signature,start,end,index)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "desc",
      "signature",
      "start",
      "end",
      "index"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void visitLocalVariable(final String name,\n        final String desc,\n        final String signature,\n        final Label start,\n        final Label end,\n        final int index)",
    "source_code": "\tpublic void visitLocalVariable("
  },
  "org.springframework.cglib.core.LocalVariablesSorter#visitMaxs(maxStack,maxLocals)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "maxStack",
      "maxLocals"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "public void visitMaxs(final int maxStack, final int maxLocals)",
    "source_code": "\tpublic void visitMaxs(final int maxStack, final int maxLocals) {\n        mv.visitMaxs(maxStack, state.nextLocal);\n    }"
  },
  "org.springframework.cglib.core.LocalVariablesSorter#visitVarInsn(opcode,var)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "opcode",
      "var"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void visitVarInsn(final int opcode, final int var)",
    "source_code": "\tpublic void visitVarInsn(final int opcode, final int var) {\n        int size = switch (opcode) {\n\t\t\tcase Opcodes.LLOAD, Opcodes.LSTORE, Opcodes.DLOAD, Opcodes.DSTORE -> 2;\n\t\t\tdefault -> 1;\n\t\t};\n        mv.visitVarInsn(opcode, remap(var, size));\n    }"
  },
  "org.springframework.cglib.core.ReflectUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * @version $Id: ReflectUtils.java,v 1.30 2009/01/11 19:47:49 herbyderby Exp $\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class ReflectUtils",
    "source_code": "public class ReflectUtils {\n\n\tprivate ReflectUtils() {\n\t}\n\n\tprivate static final Map primitives = new HashMap(8);\n\n\tprivate static final Map transforms = new HashMap(8);\n\n\tprivate static final ClassLoader defaultLoader = ReflectUtils.class.getClassLoader();\n\n\tprivate static final Method classLoaderDefineClassMethod;\n\n\tprivate static final Throwable THROWABLE;\n\n\tprivate static final ProtectionDomain PROTECTION_DOMAIN;\n\n\tprivate static final List<Method> OBJECT_METHODS = new ArrayList<>();\n\n\tprivate static BiConsumer<String, byte[]> generatedClassHandler;\n\n\tprivate static Consumer<Class<?>> loadedClassHandler;\n\n\t// SPRING PATCH BEGIN\n\tstatic {\n\t\t// Resolve protected ClassLoader.defineClass method for fallback use\n\t\t// (even if JDK 9+ Lookup.defineClass is preferably used below)\n\t\tMethod classLoaderDefineClass;\n\t\tThrowable throwable = null;\n\t\ttry {\n\t\t\tclassLoaderDefineClass = ClassLoader.class.getDeclaredMethod(\"defineClass\",\n\t\t\t\t\t\t\tString.class, byte[].class, Integer.TYPE, Integer.TYPE, ProtectionDomain.class);\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tclassLoaderDefineClass = null;\n\t\t\tthrowable = t;\n\t\t}\n\n\t\tclassLoaderDefineClassMethod = classLoaderDefineClass;\n\t\tTHROWABLE = throwable;\n\t\tPROTECTION_DOMAIN = getProtectionDomain(ReflectUtils.class);\n\n\t\tfor (Method method : Object.class.getDeclaredMethods()) {\n\t\t\tif (\"finalize\".equals(method.getName())\n\t\t\t\t\t|| (method.getModifiers() & (Modifier.FINAL | Modifier.STATIC)) > 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tOBJECT_METHODS.add(method);\n\t\t}\n\t}\n\t// SPRING PATCH END\n\n\tprivate static final String[] CGLIB_PACKAGES = {\"java.lang\"};\n\n\tstatic {\n\t\tprimitives.put(\"byte\", Byte.TYPE);\n\t\tprimitives.put(\"char\", Character.TYPE);\n\t\tprimitives.put(\"double\", Double.TYPE);\n\t\tprimitives.put(\"float\", Float.TYPE);\n\t\tprimitives.put(\"int\", Integer.TYPE);\n\t\tprimitives.put(\"long\", Long.TYPE);\n\t\tprimitives.put(\"short\", Short.TYPE);\n\t\tprimitives.put(\"boolean\", Boolean.TYPE);\n\n\t\ttransforms.put(\"byte\", \"B\");\n\t\ttransforms.put(\"char\", \"C\");\n\t\ttransforms.put(\"double\", \"D\");\n\t\ttransforms.put(\"float\", \"F\");\n\t\ttransforms.put(\"int\", \"I\");\n\t\ttransforms.put(\"long\", \"J\");\n\t\ttransforms.put(\"short\", \"S\");\n\t\ttransforms.put(\"boolean\", \"Z\");\n\t}\n\n\tpublic static ProtectionDomain getProtectionDomain(final Class source) {\n\t\tif (source == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn source.getProtectionDomain();\n\t}\n\n\tpublic static Type[] getExceptionTypes(Member member) {\n\t\tif (member instanceof Method method) {\n\t\t\treturn TypeUtils.getTypes(method.getExceptionTypes());\n\t\t}\n\t\telse if (member instanceof Constructor<?> constructor) {\n\t\t\treturn TypeUtils.getTypes(constructor.getExceptionTypes());\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Cannot get exception types of a field\");\n\t\t}\n\t}\n\n\tpublic static Signature getSignature(Member member) {\n\t\tif (member instanceof Method method) {\n\t\t\treturn new Signature(member.getName(), Type.getMethodDescriptor(method));\n\t\t}\n\t\telse if (member instanceof Constructor<?> constructor) {\n\t\t\tType[] types = TypeUtils.getTypes(constructor.getParameterTypes());\n\t\t\treturn new Signature(Constants.CONSTRUCTOR_NAME,\n\t\t\t\t\tType.getMethodDescriptor(Type.VOID_TYPE, types));\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Cannot get signature of a field\");\n\t\t}\n\t}\n\n\tpublic static Constructor findConstructor(String desc) {\n\t\treturn findConstructor(desc, defaultLoader);\n\t}\n\n\tpublic static Constructor findConstructor(String desc, ClassLoader loader) {\n\t\ttry {\n\t\t\tint lparen = desc.indexOf('(');\n\t\t\tString className = desc.substring(0, lparen).trim();\n\t\t\treturn getClass(className, loader).getConstructor(parseTypes(desc, loader));\n\t\t}\n\t\tcatch (ClassNotFoundException | NoSuchMethodException ex) {\n\t\t\tthrow new CodeGenerationException(ex);\n\t\t}\n\t}\n\n\tpublic static Method findMethod(String desc) {\n\t\treturn findMethod(desc, defaultLoader);\n\t}\n\n\tpublic static Method findMethod(String desc, ClassLoader loader) {\n\t\ttry {\n\t\t\tint lparen = desc.indexOf('(');\n\t\t\tint dot = desc.lastIndexOf('.', lparen);\n\t\t\tString className = desc.substring(0, dot).trim();\n\t\t\tString methodName = desc.substring(dot + 1, lparen).trim();\n\t\t\treturn getClass(className, loader).getDeclaredMethod(methodName, parseTypes(desc, loader));\n\t\t}\n\t\tcatch (ClassNotFoundException | NoSuchMethodException ex) {\n\t\t\tthrow new CodeGenerationException(ex);\n\t\t}\n\t}\n\n\tprivate static Class[] parseTypes(String desc, ClassLoader loader) throws ClassNotFoundException {\n\t\tint lparen = desc.indexOf('(');\n\t\tint rparen = desc.indexOf(')', lparen);\n\t\tList params = new ArrayList();\n\t\tint start = lparen + 1;\n\t\tfor (; ; ) {\n\t\t\tint comma = desc.indexOf(',', start);\n\t\t\tif (comma < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tparams.add(desc.substring(start, comma).trim());\n\t\t\tstart = comma + 1;\n\t\t}\n\t\tif (start < rparen) {\n\t\t\tparams.add(desc.substring(start, rparen).trim());\n\t\t}\n\t\tClass[] types = new Class[params.size()];\n\t\tfor (int i = 0; i < types.length; i++) {\n\t\t\ttypes[i] = getClass((String) params.get(i), loader);\n\t\t}\n\t\treturn types;\n\t}\n\n\tprivate static Class getClass(String className, ClassLoader loader) throws ClassNotFoundException {\n\t\treturn getClass(className, loader, CGLIB_PACKAGES);\n\t}\n\n\tprivate static Class getClass(String className, ClassLoader loader, String[] packages) throws ClassNotFoundException {\n\t\tString save = className;\n\t\tint dimensions = 0;\n\t\tint index = 0;\n\t\twhile ((index = className.indexOf(\"[]\", index) + 1) > 0) {\n\t\t\tdimensions++;\n\t\t}\n\t\tStringBuilder brackets = new StringBuilder(className.length() - dimensions);\n\t\tfor (int i = 0; i < dimensions; i++) {\n\t\t\tbrackets.append('[');\n\t\t}\n\t\tclassName = className.substring(0, className.length() - 2 * dimensions);\n\n\t\tString prefix = (dimensions > 0) ? brackets + \"L\" : \"\";\n\t\tString suffix = (dimensions > 0) ? \";\" : \"\";\n\t\ttry {\n\t\t\treturn Class.forName(prefix + className + suffix, false, loader);\n\t\t}\n\t\tcatch (ClassNotFoundException ignore) {\n\t\t}\n\t\tfor (String pkg : packages) {\n\t\t\ttry {\n\t\t\t\treturn Class.forName(prefix + pkg + '.' + className + suffix, false, loader);\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ignore) {\n\t\t\t}\n\t\t}\n\t\tif (dimensions == 0) {\n\t\t\tClass c = (Class) primitives.get(className);\n\t\t\tif (c != null) {\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString transform = (String) transforms.get(className);\n\t\t\tif (transform != null) {\n\t\t\t\ttry {\n\t\t\t\t\treturn Class.forName(brackets + transform, false, loader);\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ignore) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new ClassNotFoundException(save);\n\t}\n\n\tpublic static Object newInstance(Class type) {\n\t\treturn newInstance(type, Constants.EMPTY_CLASS_ARRAY, null);\n\t}\n\n\tpublic static Object newInstance(Class type, Class[] parameterTypes, Object[] args) {\n\t\treturn newInstance(getConstructor(type, parameterTypes), args);\n\t}\n\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static Object newInstance(final Constructor cstruct, final Object[] args) {\n\t\tboolean flag = cstruct.isAccessible();\n\t\ttry {\n\t\t\tif (!flag) {\n\t\t\t\tcstruct.setAccessible(true);\n\t\t\t}\n\t\t\tObject result = cstruct.newInstance(args);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (InstantiationException | IllegalAccessException e) {\n\t\t\tthrow new CodeGenerationException(e);\n\t\t}\n\t\tcatch (InvocationTargetException e) {\n\t\t\tthrow new CodeGenerationException(e.getTargetException());\n\t\t}\n\t\tfinally {\n\t\t\tif (!flag) {\n\t\t\t\tcstruct.setAccessible(flag);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static Constructor getConstructor(Class type, Class[] parameterTypes) {\n\t\ttry {\n\t\t\tConstructor constructor = type.getDeclaredConstructor(parameterTypes);\n\t\t\tconstructor.setAccessible(true);\n\t\t\treturn constructor;\n\t\t}\n\t\tcatch (NoSuchMethodException e) {\n\t\t\tthrow new CodeGenerationException(e);\n\t\t}\n\t}\n\n\tpublic static String[] getNames(Class[] classes) {\n\t\tif (classes == null) {\n\t\t\treturn null;\n\t\t}\n\t\tString[] names = new String[classes.length];\n\t\tfor (int i = 0; i < names.length; i++) {\n\t\t\tnames[i] = classes[i].getName();\n\t\t}\n\t\treturn names;\n\t}\n\n\tpublic static Class[] getClasses(Object[] objects) {\n\t\tClass[] classes = new Class[objects.length];\n\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\tclasses[i] = objects[i].getClass();\n\t\t}\n\t\treturn classes;\n\t}\n\n\tpublic static Method findNewInstance(Class iface) {\n\t\tMethod m = findInterfaceMethod(iface);\n\t\tif (!m.getName().equals(\"newInstance\")) {\n\t\t\tthrow new IllegalArgumentException(iface + \" missing newInstance method\");\n\t\t}\n\t\treturn m;\n\t}\n\n\tpublic static Method[] getPropertyMethods(PropertyDescriptor[] properties, boolean read, boolean write) {\n\t\tSet methods = new HashSet();\n\t\tfor (PropertyDescriptor pd : properties) {\n\t\t\tif (read) {\n\t\t\t\tmethods.add(pd.getReadMethod());\n\t\t\t}\n\t\t\tif (write) {\n\t\t\t\tmethods.add(pd.getWriteMethod());\n\t\t\t}\n\t\t}\n\t\tmethods.remove(null);\n\t\treturn (Method[]) methods.toArray(new Method[methods.size()]);\n\t}\n\n\tpublic static PropertyDescriptor[] getBeanProperties(Class type) {\n\t\treturn getPropertiesHelper(type, true, true);\n\t}\n\n\tpublic static PropertyDescriptor[] getBeanGetters(Class type) {\n\t\treturn getPropertiesHelper(type, true, false);\n\t}\n\n\tpublic static PropertyDescriptor[] getBeanSetters(Class type) {\n\t\treturn getPropertiesHelper(type, false, true);\n\t}\n\n\tprivate static PropertyDescriptor[] getPropertiesHelper(Class type, boolean read, boolean write) {\n\t\ttry {\n\t\t\tBeanInfo info = Introspector.getBeanInfo(type, Object.class);\n\t\t\tPropertyDescriptor[] all = info.getPropertyDescriptors();\n\t\t\tif (read && write) {\n\t\t\t\treturn all;\n\t\t\t}\n\t\t\tList properties = new ArrayList(all.length);\n\t\t\tfor (PropertyDescriptor pd : all) {\n\t\t\t\tif ((read && pd.getReadMethod() != null) ||\n\t\t\t\t\t\t(write && pd.getWriteMethod() != null)) {\n\t\t\t\t\tproperties.add(pd);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (PropertyDescriptor[]) properties.toArray(new PropertyDescriptor[properties.size()]);\n\t\t}\n\t\tcatch (IntrospectionException e) {\n\t\t\tthrow new CodeGenerationException(e);\n\t\t}\n\t}\n\n\tpublic static Method findDeclaredMethod(final Class type,\n\t\t\tfinal String methodName, final Class[] parameterTypes)\n\t\t\tthrows NoSuchMethodException {\n\n\t\tClass cl = type;\n\t\twhile (cl != null) {\n\t\t\ttry {\n\t\t\t\treturn cl.getDeclaredMethod(methodName, parameterTypes);\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException e) {\n\t\t\t\tcl = cl.getSuperclass();\n\t\t\t}\n\t\t}\n\t\tthrow new NoSuchMethodException(methodName);\n\t}\n\n\tpublic static List addAllMethods(final Class type, final List list) {\n\t\tif (type == Object.class) {\n\t\t\tlist.addAll(OBJECT_METHODS);\n\t\t}\n\t\telse {\n\t\t\tlist.addAll(java.util.Arrays.asList(type.getDeclaredMethods()));\n\t\t}\n\n\t\tClass superclass = type.getSuperclass();\n\t\tif (superclass != null) {\n\t\t\taddAllMethods(superclass, list);\n\t\t}\n\t\tClass[] interfaces = type.getInterfaces();\n\t\tfor (Class element : interfaces) {\n\t\t\taddAllMethods(element, list);\n\t\t}\n\n\t\treturn list;\n\t}\n\n\tpublic static List addAllInterfaces(Class type, List list) {\n\t\tClass superclass = type.getSuperclass();\n\t\tif (superclass != null) {\n\t\t\tlist.addAll(Arrays.asList(type.getInterfaces()));\n\t\t\taddAllInterfaces(superclass, list);\n\t\t}\n\t\treturn list;\n\t}\n\n\n\tpublic static Method findInterfaceMethod(Class iface) {\n\t\tif (!iface.isInterface()) {\n\t\t\tthrow new IllegalArgumentException(iface + \" is not an interface\");\n\t\t}\n\t\tMethod[] methods = iface.getDeclaredMethods();\n\t\tif (methods.length != 1) {\n\t\t\tthrow new IllegalArgumentException(\"expecting exactly 1 method in \" + iface);\n\t\t}\n\t\treturn methods[0];\n\t}\n\n\t// SPRING PATCH BEGIN\n\tpublic static void setGeneratedClassHandler(BiConsumer<String, byte[]> handler) {\n\t\tgeneratedClassHandler = handler;\n\t}\n\n\tpublic static Class defineClass(String className, byte[] b, ClassLoader loader) throws Exception {\n\t\treturn defineClass(className, b, loader, null, null);\n\t}\n\n\tpublic static Class defineClass(String className, byte[] b, ClassLoader loader,\n\t\t\tProtectionDomain protectionDomain) throws Exception {\n\n\t\treturn defineClass(className, b, loader, protectionDomain, null);\n\t}\n\n\t@SuppressWarnings({\"deprecation\", \"serial\"})\n\tpublic static Class defineClass(String className, byte[] b, ClassLoader loader,\n\t\t\tProtectionDomain protectionDomain, Class<?> contextClass) throws Exception {\n\n\t\tClass c = null;\n\t\tThrowable t = THROWABLE;\n\n\t\tBiConsumer<String, byte[]> handlerToUse = generatedClassHandler;\n\t\tif (handlerToUse != null) {\n\t\t\thandlerToUse.accept(className, b);\n\t\t}\n\n\t\t// Preferred option: JDK 9+ Lookup.defineClass API if ClassLoader matches\n\t\tif (contextClass != null && contextClass.getClassLoader() == loader) {\n\t\t\ttry {\n\t\t\t\tMethodHandles.Lookup lookup = MethodHandles.privateLookupIn(contextClass, MethodHandles.lookup());\n\t\t\t\tc = lookup.defineClass(b);\n\t\t\t}\n\t\t\tcatch (LinkageError | IllegalArgumentException ex) {\n\t\t\t\t// in case of plain LinkageError (class already defined)\n\t\t\t\t// or IllegalArgumentException (class in different package):\n\t\t\t\t// fall through to traditional ClassLoader.defineClass below\n\t\t\t\tt = ex;\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new CodeGenerationException(ex);\n\t\t\t}\n\t\t}\n\n\t\t// Direct defineClass attempt on the target Classloader\n\t\tif (c == null) {\n\t\t\tif (protectionDomain == null) {\n\t\t\t\tprotectionDomain = PROTECTION_DOMAIN;\n\t\t\t}\n\n\t\t\t// Look for publicDefineClass(String name, byte[] b, ProtectionDomain protectionDomain)\n\t\t\ttry {\n\t\t\t\tMethod publicDefineClass = loader.getClass().getMethod(\n\t\t\t\t\t\t\"publicDefineClass\", String.class, byte[].class, ProtectionDomain.class);\n\t\t\t\tc = (Class) publicDefineClass.invoke(loader, className, b, protectionDomain);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tif (!(ex.getTargetException() instanceof UnsupportedOperationException)) {\n\t\t\t\t\tthrow new CodeGenerationException(ex.getTargetException());\n\t\t\t\t}\n\t\t\t\t// in case of UnsupportedOperationException, fall through\n\t\t\t\tt = ex.getTargetException();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// publicDefineClass method not available -> fall through\n\t\t\t\tt = ex;\n\t\t\t}\n\n\t\t\t// Classic option: protected ClassLoader.defineClass method\n\t\t\tif (c == null && classLoaderDefineClassMethod != null) {\n\t\t\t\tObject[] args = new Object[]{className, b, 0, b.length, protectionDomain};\n\t\t\t\ttry {\n\t\t\t\t\tif (!classLoaderDefineClassMethod.isAccessible()) {\n\t\t\t\t\t\tclassLoaderDefineClassMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t\tc = (Class) classLoaderDefineClassMethod.invoke(loader, args);\n\t\t\t\t}\n\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\tthrow new CodeGenerationException(ex.getTargetException());\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t// Fall through if setAccessible fails with InaccessibleObjectException on JDK 9+\n\t\t\t\t\t// (on the module path and/or with a JVM bootstrapped with --illegal-access=deny)\n\t\t\t\t\tif (!ex.getClass().getName().endsWith(\"InaccessibleObjectException\")) {\n\t\t\t\t\t\tthrow new CodeGenerationException(ex);\n\t\t\t\t\t}\n\t\t\t\t\tt = ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Fallback option: JDK 9+ Lookup.defineClass API even if ClassLoader does not match\n\t\tif (c == null && contextClass != null && contextClass.getClassLoader() != loader) {\n\t\t\ttry {\n\t\t\t\tMethodHandles.Lookup lookup = MethodHandles.privateLookupIn(contextClass, MethodHandles.lookup());\n\t\t\t\tc = lookup.defineClass(b);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new CodeGenerationException(ex) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String getMessage() {\n\t\t\t\t\t\treturn \"ClassLoader mismatch for [\" + contextClass.getName() +\n\t\t\t\t\t\t\t\t\"]: JVM should be started with --add-opens=java.base/java.lang=ALL-UNNAMED \" +\n\t\t\t\t\t\t\t\t\"for ClassLoader.defineClass to be accessible on \" + loader.getClass().getName();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new CodeGenerationException(ex);\n\t\t\t}\n\t\t}\n\n\t\t// No defineClass variant available at all?\n\t\tif (c == null) {\n\t\t\tthrow new CodeGenerationException(t);\n\t\t}\n\n\t\t// Force static initializers to run.\n\t\tClass.forName(className, true, loader);\n\t\treturn c;\n\t}\n\n\tpublic static void setLoadedClassHandler(Consumer<Class<?>> loadedClassHandler) {\n\t\tReflectUtils.loadedClassHandler = loadedClassHandler;\n\t}\n\n\tpublic static Class<?> loadClass(String className, ClassLoader classLoader) throws ClassNotFoundException {\n\t\t// Force static initializers to run.\n\t\tClass<?> clazz = Class.forName(className, true, classLoader);\n\t\tConsumer<Class<?>> handlerToUse = loadedClassHandler;\n\t\tif (handlerToUse != null) {\n\t\t\thandlerToUse.accept(clazz);\n\t\t}\n\t\treturn clazz;\n\t}\n\n\t// SPRING PATCH END\n\n\tpublic static int findPackageProtected(Class[] classes) {\n\t\tfor (int i = 0; i < classes.length; i++) {\n\t\t\tif (!Modifier.isPublic(classes[i].getModifiers())) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic static MethodInfo getMethodInfo(final Member member, final int modifiers) {\n\t\tfinal Signature sig = getSignature(member);\n\t\treturn new MethodInfo() {\n\t\t\tprivate ClassInfo ci;\n\n\t\t\t@Override\n\t\t\tpublic ClassInfo getClassInfo() {\n\t\t\t\tif (ci == null) {\n\t\t\t\t\tci = ReflectUtils.getClassInfo(member.getDeclaringClass());\n\t\t\t\t}\n\t\t\t\treturn ci;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int getModifiers() {\n\t\t\t\treturn modifiers;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Signature getSignature() {\n\t\t\t\treturn sig;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Type[] getExceptionTypes() {\n\t\t\t\treturn ReflectUtils.getExceptionTypes(member);\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static MethodInfo getMethodInfo(Member member) {\n\t\treturn getMethodInfo(member, member.getModifiers());\n\t}\n\n\tpublic static ClassInfo getClassInfo(final Class clazz) {\n\t\tfinal Type type = Type.getType(clazz);\n\t\tfinal Type sc = (clazz.getSuperclass() == null) ? null : Type.getType(clazz.getSuperclass());\n\t\treturn new ClassInfo() {\n\t\t\t@Override\n\t\t\tpublic Type getType() {\n\t\t\t\treturn type;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Type getSuperType() {\n\t\t\t\treturn sc;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Type[] getInterfaces() {\n\t\t\t\treturn TypeUtils.getTypes(clazz.getInterfaces());\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int getModifiers() {\n\t\t\t\treturn clazz.getModifiers();\n\t\t\t}\n\t\t};\n\t}\n\n\t// used by MethodInterceptorGenerated generated code\n\tpublic static Method[] findMethods(String[] namesAndDescriptors, Method[] methods) {\n\t\tMap map = new HashMap();\n\t\tfor (Method method : methods) {\n\t\t\tmap.put(method.getName() + Type.getMethodDescriptor(method), method);\n\t\t}\n\t\tMethod[] result = new Method[namesAndDescriptors.length / 2];\n\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\tresult[i] = (Method) map.get(namesAndDescriptors[i * 2] + namesAndDescriptors[i * 2 + 1]);\n\t\t\tif (result[i] == null) {\n\t\t\t\t// TODO: error?\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}"
  },
  "org.springframework.cglib.core.ReflectUtils#addAllInterfaces(type,list)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "list"
    ],
    "position": {
      "column": 1,
      "line": 410
    },
    "return": "List",
    "signature": "public List addAllInterfaces(Class type, List list)",
    "source_code": "\tpublic static List addAllInterfaces(Class type, List list) {\n\t\tClass superclass = type.getSuperclass();\n\t\tif (superclass != null) {\n\t\t\tlist.addAll(Arrays.asList(type.getInterfaces()));\n\t\t\taddAllInterfaces(superclass, list);\n\t\t}\n\t\treturn list;\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#addAllMethods(type,list)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "list"
    ],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "List",
    "signature": "public List addAllMethods(final Class type, final List list)",
    "source_code": "\tpublic static List addAllMethods(final Class type, final List list) {\n\t\tif (type == Object.class) {\n\t\t\tlist.addAll(OBJECT_METHODS);\n\t\t}\n\t\telse {\n\t\t\tlist.addAll(java.util.Arrays.asList(type.getDeclaredMethods()));\n\t\t}\n\n\t\tClass superclass = type.getSuperclass();\n\t\tif (superclass != null) {\n\t\t\taddAllMethods(superclass, list);\n\t\t}\n\t\tClass[] interfaces = type.getInterfaces();\n\t\tfor (Class element : interfaces) {\n\t\t\taddAllMethods(element, list);\n\t\t}\n\n\t\treturn list;\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#defineClass(className,b,loader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "className",
      "b",
      "loader"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "Class",
    "signature": "public Class defineClass(String className, byte[] b, ClassLoader loader)",
    "source_code": "\tpublic static Class defineClass(String className, byte[] b, ClassLoader loader) throws Exception {\n\t\treturn defineClass(className, b, loader, null, null);\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#defineClass(className,b,loader,protectionDomain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "className",
      "b",
      "loader",
      "protectionDomain"
    ],
    "position": {
      "column": 1,
      "line": 440
    },
    "return": "Class",
    "signature": "public Class defineClass(String className, byte[] b, ClassLoader loader,\n\t\t\tProtectionDomain protectionDomain)",
    "source_code": "\tpublic static Class defineClass(String className, byte[] b, ClassLoader loader,"
  },
  "org.springframework.cglib.core.ReflectUtils#defineClass(className,b,loader,protectionDomain,contextClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "className",
      "b",
      "loader",
      "protectionDomain",
      "contextClass"
    ],
    "position": {
      "column": 1,
      "line": 447
    },
    "return": "Class",
    "signature": "public Class defineClass(String className, byte[] b, ClassLoader loader,\n\t\t\tProtectionDomain protectionDomain, Class<?> contextClass)",
    "source_code": "\tpublic static Class defineClass(String className, byte[] b, ClassLoader loader,"
  },
  "org.springframework.cglib.core.ReflectUtils#findConstructor(desc)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "desc"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Constructor",
    "signature": "public Constructor findConstructor(String desc)",
    "source_code": "\tpublic static Constructor findConstructor(String desc) {\n\t\treturn findConstructor(desc, defaultLoader);\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#findConstructor(desc,loader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "desc",
      "loader"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "Constructor",
    "signature": "public Constructor findConstructor(String desc, ClassLoader loader)",
    "source_code": "\tpublic static Constructor findConstructor(String desc, ClassLoader loader) {\n\t\ttry {\n\t\t\tint lparen = desc.indexOf('(');\n\t\t\tString className = desc.substring(0, lparen).trim();\n\t\t\treturn getClass(className, loader).getConstructor(parseTypes(desc, loader));\n\t\t}\n\t\tcatch (ClassNotFoundException | NoSuchMethodException ex) {\n\t\t\tthrow new CodeGenerationException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#findDeclaredMethod(type,methodName,parameterTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "methodName",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 374
    },
    "return": "Method",
    "signature": "public Method findDeclaredMethod(final Class type,\n\t\t\tfinal String methodName, final Class[] parameterTypes)",
    "source_code": "\tpublic static Method findDeclaredMethod(final Class type,"
  },
  "org.springframework.cglib.core.ReflectUtils#findInterfaceMethod(iface)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "iface"
    ],
    "position": {
      "column": 1,
      "line": 420
    },
    "return": "Method",
    "signature": "public Method findInterfaceMethod(Class iface)",
    "source_code": "\tpublic static Method findInterfaceMethod(Class iface) {\n\t\tif (!iface.isInterface()) {\n\t\t\tthrow new IllegalArgumentException(iface + \" is not an interface\");\n\t\t}\n\t\tMethod[] methods = iface.getDeclaredMethods();\n\t\tif (methods.length != 1) {\n\t\t\tthrow new IllegalArgumentException(\"expecting exactly 1 method in \" + iface);\n\t\t}\n\t\treturn methods[0];\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#findMethod(desc)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "desc"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "Method",
    "signature": "public Method findMethod(String desc)",
    "source_code": "\tpublic static Method findMethod(String desc) {\n\t\treturn findMethod(desc, defaultLoader);\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#findMethod(desc,loader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "desc",
      "loader"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "Method",
    "signature": "public Method findMethod(String desc, ClassLoader loader)",
    "source_code": "\tpublic static Method findMethod(String desc, ClassLoader loader) {\n\t\ttry {\n\t\t\tint lparen = desc.indexOf('(');\n\t\t\tint dot = desc.lastIndexOf('.', lparen);\n\t\t\tString className = desc.substring(0, dot).trim();\n\t\t\tString methodName = desc.substring(dot + 1, lparen).trim();\n\t\t\treturn getClass(className, loader).getDeclaredMethod(methodName, parseTypes(desc, loader));\n\t\t}\n\t\tcatch (ClassNotFoundException | NoSuchMethodException ex) {\n\t\t\tthrow new CodeGenerationException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#findMethods(namesAndDescriptors,methods)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "namesAndDescriptors",
      "methods"
    ],
    "position": {
      "column": 1,
      "line": 636
    },
    "return": "Method[]",
    "signature": "public Method[] findMethods(String[] namesAndDescriptors, Method[] methods)",
    "source_code": "\tpublic static Method[] findMethods(String[] namesAndDescriptors, Method[] methods) {\n\t\tMap map = new HashMap();\n\t\tfor (Method method : methods) {\n\t\t\tmap.put(method.getName() + Type.getMethodDescriptor(method), method);\n\t\t}\n\t\tMethod[] result = new Method[namesAndDescriptors.length / 2];\n\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\tresult[i] = (Method) map.get(namesAndDescriptors[i * 2] + namesAndDescriptors[i * 2 + 1]);\n\t\t\tif (result[i] == null) {\n\t\t\t\t// TODO: error?\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#findNewInstance(iface)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "iface"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "Method",
    "signature": "public Method findNewInstance(Class iface)",
    "source_code": "\tpublic static Method findNewInstance(Class iface) {\n\t\tMethod m = findInterfaceMethod(iface);\n\t\tif (!m.getName().equals(\"newInstance\")) {\n\t\t\tthrow new IllegalArgumentException(iface + \" missing newInstance method\");\n\t\t}\n\t\treturn m;\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#findPackageProtected(classes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classes"
    ],
    "position": {
      "column": 1,
      "line": 569
    },
    "return": "int",
    "signature": "public int findPackageProtected(Class[] classes)",
    "source_code": "\tpublic static int findPackageProtected(Class[] classes) {\n\t\tfor (int i = 0; i < classes.length; i++) {\n\t\t\tif (!Modifier.isPublic(classes[i].getModifiers())) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getBeanGetters(type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "PropertyDescriptor[]",
    "signature": "public PropertyDescriptor[] getBeanGetters(Class type)",
    "source_code": "\tpublic static PropertyDescriptor[] getBeanGetters(Class type) {\n\t\treturn getPropertiesHelper(type, true, false);\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getBeanProperties(type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "PropertyDescriptor[]",
    "signature": "public PropertyDescriptor[] getBeanProperties(Class type)",
    "source_code": "\tpublic static PropertyDescriptor[] getBeanProperties(Class type) {\n\t\treturn getPropertiesHelper(type, true, true);\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getBeanSetters(type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "PropertyDescriptor[]",
    "signature": "public PropertyDescriptor[] getBeanSetters(Class type)",
    "source_code": "\tpublic static PropertyDescriptor[] getBeanSetters(Class type) {\n\t\treturn getPropertiesHelper(type, false, true);\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getClassInfo()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 584
    },
    "return": "ClassInfo",
    "signature": "public ClassInfo getClassInfo()",
    "source_code": "\t\t\tpublic ClassInfo getClassInfo() {\n\t\t\t\tif (ci == null) {\n\t\t\t\t\tci = ReflectUtils.getClassInfo(member.getDeclaringClass());\n\t\t\t\t}\n\t\t\t\treturn ci;\n\t\t\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getClassInfo(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 612
    },
    "return": "ClassInfo",
    "signature": "public ClassInfo getClassInfo(final Class clazz)",
    "source_code": "\tpublic static ClassInfo getClassInfo(final Class clazz) {\n\t\tfinal Type type = Type.getType(clazz);\n\t\tfinal Type sc = (clazz.getSuperclass() == null) ? null : Type.getType(clazz.getSuperclass());\n\t\treturn new ClassInfo() {\n\t\t\t@Override\n\t\t\tpublic Type getType() {\n\t\t\t\treturn type;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Type getSuperType() {\n\t\t\t\treturn sc;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Type[] getInterfaces() {\n\t\t\t\treturn TypeUtils.getTypes(clazz.getInterfaces());\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int getModifiers() {\n\t\t\t\treturn clazz.getModifiers();\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getClasses(objects)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "objects"
    ],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "Class[]",
    "signature": "public Class[] getClasses(Object[] objects)",
    "source_code": "\tpublic static Class[] getClasses(Object[] objects) {\n\t\tClass[] classes = new Class[objects.length];\n\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\tclasses[i] = objects[i].getClass();\n\t\t}\n\t\treturn classes;\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getConstructor(type,parameterTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "Constructor",
    "signature": "public Constructor getConstructor(Class type, Class[] parameterTypes)",
    "source_code": "\tpublic static Constructor getConstructor(Class type, Class[] parameterTypes) {\n\t\ttry {\n\t\t\tConstructor constructor = type.getDeclaredConstructor(parameterTypes);\n\t\t\tconstructor.setAccessible(true);\n\t\t\treturn constructor;\n\t\t}\n\t\tcatch (NoSuchMethodException e) {\n\t\t\tthrow new CodeGenerationException(e);\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getExceptionTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 602
    },
    "return": "Type[]",
    "signature": "public Type[] getExceptionTypes()",
    "source_code": "\t\t\tpublic Type[] getExceptionTypes() {\n\t\t\t\treturn ReflectUtils.getExceptionTypes(member);\n\t\t\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getExceptionTypes(member)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "member"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "Type[]",
    "signature": "public Type[] getExceptionTypes(Member member)",
    "source_code": "\tpublic static Type[] getExceptionTypes(Member member) {\n\t\tif (member instanceof Method method) {\n\t\t\treturn TypeUtils.getTypes(method.getExceptionTypes());\n\t\t}\n\t\telse if (member instanceof Constructor<?> constructor) {\n\t\t\treturn TypeUtils.getTypes(constructor.getExceptionTypes());\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Cannot get exception types of a field\");\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getInterfaces()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 625
    },
    "return": "Type[]",
    "signature": "public Type[] getInterfaces()",
    "source_code": "\t\t\tpublic Type[] getInterfaces() {\n\t\t\t\treturn TypeUtils.getTypes(clazz.getInterfaces());\n\t\t\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getMessage()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 531
    },
    "return": "String",
    "signature": "public String getMessage()",
    "source_code": "\t\t\t\t\tpublic String getMessage() {\n\t\t\t\t\t\treturn \"ClassLoader mismatch for [\" + contextClass.getName() +\n\t\t\t\t\t\t\t\t\"]: JVM should be started with --add-opens=java.base/java.lang=ALL-UNNAMED \" +\n\t\t\t\t\t\t\t\t\"for ClassLoader.defineClass to be accessible on \" + loader.getClass().getName();\n\t\t\t\t\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getMethodInfo(member)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "member"
    ],
    "position": {
      "column": 1,
      "line": 608
    },
    "return": "MethodInfo",
    "signature": "public MethodInfo getMethodInfo(Member member)",
    "source_code": "\tpublic static MethodInfo getMethodInfo(Member member) {\n\t\treturn getMethodInfo(member, member.getModifiers());\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getMethodInfo(member,modifiers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "member",
      "modifiers"
    ],
    "position": {
      "column": 1,
      "line": 578
    },
    "return": "MethodInfo",
    "signature": "public MethodInfo getMethodInfo(final Member member, final int modifiers)",
    "source_code": "\tpublic static MethodInfo getMethodInfo(final Member member, final int modifiers) {\n\t\tfinal Signature sig = getSignature(member);\n\t\treturn new MethodInfo() {\n\t\t\tprivate ClassInfo ci;\n\n\t\t\t@Override\n\t\t\tpublic ClassInfo getClassInfo() {\n\t\t\t\tif (ci == null) {\n\t\t\t\t\tci = ReflectUtils.getClassInfo(member.getDeclaringClass());\n\t\t\t\t}\n\t\t\t\treturn ci;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int getModifiers() {\n\t\t\t\treturn modifiers;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Signature getSignature() {\n\t\t\t\treturn sig;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Type[] getExceptionTypes() {\n\t\t\t\treturn ReflectUtils.getExceptionTypes(member);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getModifiers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 629
    },
    "return": "int",
    "signature": "public int getModifiers()",
    "source_code": "\t\t\tpublic int getModifiers() {\n\t\t\t\treturn clazz.getModifiers();\n\t\t\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getNames(classes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classes"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "String[]",
    "signature": "public String[] getNames(Class[] classes)",
    "source_code": "\tpublic static String[] getNames(Class[] classes) {\n\t\tif (classes == null) {\n\t\t\treturn null;\n\t\t}\n\t\tString[] names = new String[classes.length];\n\t\tfor (int i = 0; i < names.length; i++) {\n\t\t\tnames[i] = classes[i].getName();\n\t\t}\n\t\treturn names;\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getPropertyMethods(properties,read,write)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "properties",
      "read",
      "write"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "Method[]",
    "signature": "public Method[] getPropertyMethods(PropertyDescriptor[] properties, boolean read, boolean write)",
    "source_code": "\tpublic static Method[] getPropertyMethods(PropertyDescriptor[] properties, boolean read, boolean write) {\n\t\tSet methods = new HashSet();\n\t\tfor (PropertyDescriptor pd : properties) {\n\t\t\tif (read) {\n\t\t\t\tmethods.add(pd.getReadMethod());\n\t\t\t}\n\t\t\tif (write) {\n\t\t\t\tmethods.add(pd.getWriteMethod());\n\t\t\t}\n\t\t}\n\t\tmethods.remove(null);\n\t\treturn (Method[]) methods.toArray(new Method[methods.size()]);\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getProtectionDomain(source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "ProtectionDomain",
    "signature": "public ProtectionDomain getProtectionDomain(final Class source)",
    "source_code": "\tpublic static ProtectionDomain getProtectionDomain(final Class source) {\n\t\tif (source == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn source.getProtectionDomain();\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getSignature()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 597
    },
    "return": "Signature",
    "signature": "public Signature getSignature()",
    "source_code": "\t\t\tpublic Signature getSignature() {\n\t\t\t\treturn sig;\n\t\t\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getSignature(member)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "member"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "Signature",
    "signature": "public Signature getSignature(Member member)",
    "source_code": "\tpublic static Signature getSignature(Member member) {\n\t\tif (member instanceof Method method) {\n\t\t\treturn new Signature(member.getName(), Type.getMethodDescriptor(method));\n\t\t}\n\t\telse if (member instanceof Constructor<?> constructor) {\n\t\t\tType[] types = TypeUtils.getTypes(constructor.getParameterTypes());\n\t\t\treturn new Signature(Constants.CONSTRUCTOR_NAME,\n\t\t\t\t\tType.getMethodDescriptor(Type.VOID_TYPE, types));\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Cannot get signature of a field\");\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getSuperType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 621
    },
    "return": "Type",
    "signature": "public Type getSuperType()",
    "source_code": "\t\t\tpublic Type getSuperType() {\n\t\t\t\treturn sc;\n\t\t\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#getType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 617
    },
    "return": "Type",
    "signature": "public Type getType()",
    "source_code": "\t\t\tpublic Type getType() {\n\t\t\t\treturn type;\n\t\t\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#newInstance(cstruct,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cstruct",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "Object",
    "signature": "public Object newInstance(final Constructor cstruct, final Object[] args)",
    "source_code": "\tpublic static Object newInstance(final Constructor cstruct, final Object[] args) {\n\t\tboolean flag = cstruct.isAccessible();\n\t\ttry {\n\t\t\tif (!flag) {\n\t\t\t\tcstruct.setAccessible(true);\n\t\t\t}\n\t\t\tObject result = cstruct.newInstance(args);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (InstantiationException | IllegalAccessException e) {\n\t\t\tthrow new CodeGenerationException(e);\n\t\t}\n\t\tcatch (InvocationTargetException e) {\n\t\t\tthrow new CodeGenerationException(e.getTargetException());\n\t\t}\n\t\tfinally {\n\t\t\tif (!flag) {\n\t\t\t\tcstruct.setAccessible(flag);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#newInstance(type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "Object",
    "signature": "public Object newInstance(Class type)",
    "source_code": "\tpublic static Object newInstance(Class type) {\n\t\treturn newInstance(type, Constants.EMPTY_CLASS_ARRAY, null);\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#newInstance(type,parameterTypes,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "parameterTypes",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "Object",
    "signature": "public Object newInstance(Class type, Class[] parameterTypes, Object[] args)",
    "source_code": "\tpublic static Object newInstance(Class type, Class[] parameterTypes, Object[] args) {\n\t\treturn newInstance(getConstructor(type, parameterTypes), args);\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#setGeneratedClassHandler(BiConsumer<String,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiConsumer<String",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "void",
    "signature": "public void setGeneratedClassHandler(BiConsumer<String, byte[]> handler)",
    "source_code": "\tpublic static void setGeneratedClassHandler(BiConsumer<String, byte[]> handler) {\n\t\tgeneratedClassHandler = handler;\n\t}"
  },
  "org.springframework.cglib.core.ReflectUtils#setLoadedClassHandler(loadedClassHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "loadedClassHandler"
    ],
    "position": {
      "column": 1,
      "line": 553
    },
    "return": "void",
    "signature": "public void setLoadedClassHandler(Consumer<Class<?>> loadedClassHandler)",
    "source_code": "\tpublic static void setLoadedClassHandler(Consumer<Class<?>> loadedClassHandler) {\n\t\tReflectUtils.loadedClassHandler = loadedClassHandler;\n\t}"
  },
  "org.springframework.cglib.core.Signature": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A representation of a method signature, containing the method name,\n * return type, and parameter types.\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 24
    },
    "signature": "public class Signature",
    "source_code": "public class Signature {\n    private String name;\n    private String desc;\n\n    public Signature(String name, String desc) {\n        // TODO: better error checking\n        if (name.indexOf('(') >= 0) {\n            throw new IllegalArgumentException(\"Name '\" + name + \"' is invalid\");\n        }\n        this.name = name;\n        this.desc = desc;\n    }\n\n    public Signature(String name, Type returnType, Type[] argumentTypes) {\n        this(name, Type.getMethodDescriptor(returnType, argumentTypes));\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDescriptor() {\n        return desc;\n    }\n\n    public Type getReturnType() {\n        return Type.getReturnType(desc);\n    }\n\n    public Type[] getArgumentTypes() {\n        return Type.getArgumentTypes(desc);\n    }\n\n    @Override\n\tpublic String toString() {\n        return name + desc;\n    }\n\n    @Override\n\tpublic boolean equals(Object o) {\n        if (o == null) {\n\t\t\treturn false;\n\t\t}\n        if (!(o instanceof Signature other)) {\n\t\t\treturn false;\n\t\t}\n        return name.equals(other.name) && desc.equals(other.desc);\n    }\n\n    @Override\n\tpublic int hashCode() {\n        return name.hashCode() ^ desc.hashCode();\n    }\n}"
  },
  "org.springframework.cglib.core.Signature#equals(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "boolean",
    "signature": "public boolean equals(Object o)",
    "source_code": "\tpublic boolean equals(Object o) {\n        if (o == null) {\n\t\t\treturn false;\n\t\t}\n        if (!(o instanceof Signature other)) {\n\t\t\treturn false;\n\t\t}\n        return name.equals(other.name) && desc.equals(other.desc);\n    }"
  },
  "org.springframework.cglib.core.Signature#getArgumentTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "Type[]",
    "signature": "public Type[] getArgumentTypes()",
    "source_code": "    public Type[] getArgumentTypes() {\n        return Type.getArgumentTypes(desc);\n    }"
  },
  "org.springframework.cglib.core.Signature#getDescriptor()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 45
    },
    "return": "String",
    "signature": "public String getDescriptor()",
    "source_code": "    public String getDescriptor() {\n        return desc;\n    }"
  },
  "org.springframework.cglib.core.Signature#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 41
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "    public String getName() {\n        return name;\n    }"
  },
  "org.springframework.cglib.core.Signature#getReturnType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "Type",
    "signature": "public Type getReturnType()",
    "source_code": "    public Type getReturnType() {\n        return Type.getReturnType(desc);\n    }"
  },
  "org.springframework.cglib.core.Signature#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n        return name.hashCode() ^ desc.hashCode();\n    }"
  },
  "org.springframework.cglib.core.Signature#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n        return name + desc;\n    }"
  },
  "org.springframework.cglib.core.Source": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "signature": "protected class Source",
    "source_code": "\tprotected static class Source {\n\n\t\tString name;\n\n\t\tpublic Source(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.firstLocal": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "signature": "protected int firstLocal",
    "source_code": "    protected final int firstLocal;",
    "type": "int"
  },
  "org.springframework.cglib.proxy.<unknown>#accept(method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "int",
    "signature": "public int accept(Method method)",
    "source_code": "    public int accept(Method method) {\n        return ((Integer)methodMap.get(method)).intValue();\n    }"
  },
  "org.springframework.cglib.proxy.<unknown>#equals(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "boolean",
    "signature": "public boolean equals(Object o)",
    "source_code": "    public boolean equals(Object o) {\n        if (o == null) {\n            return false;\n        }\n        if (!(o instanceof CallbackHelper other)) {\n            return false;\n        }\n        return this.methodMap.equals(other.methodMap);\n    }"
  },
  "org.springframework.cglib.proxy.<unknown>#getCallbackTypes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "Class[]",
    "signature": "public Class[] getCallbackTypes()",
    "source_code": "    public Class[] getCallbackTypes() {\n        if (callbacks.size() == 0) {\n            return new Class[0];\n        }\n        if (callbacks.get(0) instanceof Callback) {\n            return ReflectUtils.getClasses(getCallbacks());\n        }\n        else {\n            return (Class[])callbacks.toArray(new Class[callbacks.size()]);\n        }\n    }"
  },
  "org.springframework.cglib.proxy.<unknown>#getCallbacks()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "Callback[]",
    "signature": "public Callback[] getCallbacks()",
    "source_code": "    public Callback[] getCallbacks() {\n        if (callbacks.size() == 0) {\n            return new Callback[0];\n        }\n        if (callbacks.get(0) instanceof Callback) {\n            return (Callback[])callbacks.toArray(new Callback[callbacks.size()]);\n        }\n        else {\n            throw new IllegalStateException(\"getCallback returned classes, not callbacks; call getCallbackTypes instead\");\n        }\n    }"
  },
  "org.springframework.cglib.proxy.<unknown>#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "    public int hashCode() {\n        return methodMap.hashCode();\n    }"
  },
  "org.springframework.cglib.reflect.<unknown>#equals(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "boolean",
    "signature": "public boolean equals(Object o)",
    "source_code": "    public boolean equals(Object o) {\n        if (o == null || !(o instanceof FastMember other)) {\n            return false;\n        }\n        return member.equals(other.member);\n    }"
  },
  "org.springframework.cglib.reflect.<unknown>#getDeclaringClass()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 44
    },
    "return": "Class",
    "signature": "public Class getDeclaringClass()",
    "source_code": "    public Class getDeclaringClass() {\n        return fc.getJavaClass();\n    }"
  },
  "org.springframework.cglib.reflect.<unknown>#getIndex()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 36
    },
    "return": "int",
    "signature": "public int getIndex()",
    "source_code": "    public int getIndex() {\n        return index;\n    }"
  },
  "org.springframework.cglib.reflect.<unknown>#getModifiers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "int",
    "signature": "public int getModifiers()",
    "source_code": "    public int getModifiers() {\n        return member.getModifiers();\n    }"
  },
  "org.springframework.cglib.reflect.<unknown>#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 40
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "    public String getName() {\n        return member.getName();\n    }"
  },
  "org.springframework.cglib.reflect.<unknown>#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "    public int hashCode() {\n        return member.hashCode();\n    }"
  },
  "org.springframework.cglib.reflect.<unknown>#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "    public String toString() {\n        return member.toString();\n    }"
  },
  "org.springframework.cglib.reflect.fc": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 23
    },
    "signature": "protected FastClass fc",
    "source_code": "    protected FastClass fc;",
    "type": "FastClass"
  },
  "org.springframework.cglib.reflect.index": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 25
    },
    "signature": "protected int index",
    "source_code": "    protected int index;",
    "type": "int"
  },
  "org.springframework.cglib.reflect.member": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 24
    },
    "signature": "protected Member member",
    "source_code": "    protected Member member;",
    "type": "Member"
  },
  "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A component provider that provides candidate components from a base package. Can\n * use {@link CandidateComponentsIndex the index} if it is available of scans the\n * classpath otherwise. Candidate components are identified by applying exclude and\n * include filters. {@link AnnotationTypeFilter}, {@link AssignableTypeFilter} include\n * filters on an annotation/superclass that are annotated with {@link Indexed} are\n * supported: if any other include filter is specified, the index is ignored and\n * classpath scanning is used instead.\n *\n * <p>This implementation is based on Spring's\n * {@link org.springframework.core.type.classreading.MetadataReader MetadataReader}\n * facility, backed by an ASM {@link org.springframework.asm.ClassReader ClassReader}.\n *\n * @author Mark Fisher\n * @author Juergen Hoeller\n * @author Ramnivas Laddad\n * @author Chris Beams\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @since 2.5\n * @see org.springframework.core.type.classreading.MetadataReaderFactory\n * @see org.springframework.core.type.AnnotationMetadata\n * @see ScannedGenericBeanDefinition\n * @see CandidateComponentsIndex\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "signature": "public class ClassPathScanningCandidateComponentProvider",
    "source_code": "public class ClassPathScanningCandidateComponentProvider implements EnvironmentCapable, ResourceLoaderAware {\n\n\tstatic final String DEFAULT_RESOURCE_PATTERN = \"**/*.class\";\n\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate String resourcePattern = DEFAULT_RESOURCE_PATTERN;\n\n\tprivate final List<TypeFilter> includeFilters = new ArrayList<>();\n\n\tprivate final List<TypeFilter> excludeFilters = new ArrayList<>();\n\n\t@Nullable\n\tprivate Environment environment;\n\n\t@Nullable\n\tprivate ConditionEvaluator conditionEvaluator;\n\n\t@Nullable\n\tprivate ResourcePatternResolver resourcePatternResolver;\n\n\t@Nullable\n\tprivate MetadataReaderFactory metadataReaderFactory;\n\n\t@Nullable\n\tprivate CandidateComponentsIndex componentsIndex;\n\n\n\t/**\n\t * Protected constructor for flexible subclass initialization.\n\t * @since 4.3.6\n\t */\n\tprotected ClassPathScanningCandidateComponentProvider() {\n\t}\n\n\t/**\n\t * Create a ClassPathScanningCandidateComponentProvider with a {@link StandardEnvironment}.\n\t * @param useDefaultFilters whether to register the default filters for the\n\t * {@link Component @Component}, {@link Repository @Repository},\n\t * {@link Service @Service}, and {@link Controller @Controller}\n\t * stereotype annotations\n\t * @see #registerDefaultFilters()\n\t */\n\tpublic ClassPathScanningCandidateComponentProvider(boolean useDefaultFilters) {\n\t\tthis(useDefaultFilters, new StandardEnvironment());\n\t}\n\n\t/**\n\t * Create a ClassPathScanningCandidateComponentProvider with the given {@link Environment}.\n\t * @param useDefaultFilters whether to register the default filters for the\n\t * {@link Component @Component}, {@link Repository @Repository},\n\t * {@link Service @Service}, and {@link Controller @Controller}\n\t * stereotype annotations\n\t * @param environment the Environment to use\n\t * @see #registerDefaultFilters()\n\t */\n\tpublic ClassPathScanningCandidateComponentProvider(boolean useDefaultFilters, Environment environment) {\n\t\tif (useDefaultFilters) {\n\t\t\tregisterDefaultFilters();\n\t\t}\n\t\tsetEnvironment(environment);\n\t\tsetResourceLoader(null);\n\t}\n\n\n\t/**\n\t * Set the resource pattern to use when scanning the classpath.\n\t * This value will be appended to each base package name.\n\t * @see #findCandidateComponents(String)\n\t * @see #DEFAULT_RESOURCE_PATTERN\n\t */\n\tpublic void setResourcePattern(String resourcePattern) {\n\t\tAssert.notNull(resourcePattern, \"'resourcePattern' must not be null\");\n\t\tthis.resourcePattern = resourcePattern;\n\t}\n\n\t/**\n\t * Add an include type filter to the <i>end</i> of the inclusion list.\n\t */\n\tpublic void addIncludeFilter(TypeFilter includeFilter) {\n\t\tthis.includeFilters.add(includeFilter);\n\t}\n\n\t/**\n\t * Add an exclude type filter to the <i>front</i> of the exclusion list.\n\t */\n\tpublic void addExcludeFilter(TypeFilter excludeFilter) {\n\t\tthis.excludeFilters.add(0, excludeFilter);\n\t}\n\n\t/**\n\t * Reset the configured type filters.\n\t * @param useDefaultFilters whether to re-register the default filters for\n\t * the {@link Component @Component}, {@link Repository @Repository},\n\t * {@link Service @Service}, and {@link Controller @Controller}\n\t * stereotype annotations\n\t * @see #registerDefaultFilters()\n\t */\n\tpublic void resetFilters(boolean useDefaultFilters) {\n\t\tthis.includeFilters.clear();\n\t\tthis.excludeFilters.clear();\n\t\tif (useDefaultFilters) {\n\t\t\tregisterDefaultFilters();\n\t\t}\n\t}\n\n\t/**\n\t * Register the default filter for {@link Component @Component}.\n\t * <p>This will implicitly register all annotations that have the\n\t * {@link Component @Component} meta-annotation including the\n\t * {@link Repository @Repository}, {@link Service @Service}, and\n\t * {@link Controller @Controller} stereotype annotations.\n\t * <p>Also supports Jakarta EE's {@link jakarta.annotation.ManagedBean} and\n\t * JSR-330's {@link jakarta.inject.Named} annotations, if available.\n\t *\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected void registerDefaultFilters() {\n\t\tthis.includeFilters.add(new AnnotationTypeFilter(Component.class));\n\t\tClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();\n\t\ttry {\n\t\t\tthis.includeFilters.add(new AnnotationTypeFilter(\n\t\t\t\t\t((Class<? extends Annotation>) ClassUtils.forName(\"jakarta.annotation.ManagedBean\", cl)), false));\n\t\t\tlogger.trace(\"JSR-250 'jakarta.annotation.ManagedBean' found and supported for component scanning\");\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t// JSR-250 1.1 API (as included in Jakarta EE) not available - simply skip.\n\t\t}\n\t\ttry {\n\t\t\tthis.includeFilters.add(new AnnotationTypeFilter(\n\t\t\t\t\t((Class<? extends Annotation>) ClassUtils.forName(\"jakarta.inject.Named\", cl)), false));\n\t\t\tlogger.trace(\"JSR-330 'jakarta.inject.Named' annotation found and supported for component scanning\");\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t// JSR-330 API not available - simply skip.\n\t\t}\n\t}\n\n\t/**\n\t * Set the Environment to use when resolving placeholders and evaluating\n\t * {@link Conditional @Conditional}-annotated component classes.\n\t * <p>The default is a {@link StandardEnvironment}.\n\t * @param environment the Environment to use\n\t */\n\tpublic void setEnvironment(Environment environment) {\n\t\tAssert.notNull(environment, \"Environment must not be null\");\n\t\tthis.environment = environment;\n\t\tthis.conditionEvaluator = null;\n\t}\n\n\t@Override\n\tpublic final Environment getEnvironment() {\n\t\tif (this.environment == null) {\n\t\t\tthis.environment = new StandardEnvironment();\n\t\t}\n\t\treturn this.environment;\n\t}\n\n\t/**\n\t * Return the {@link BeanDefinitionRegistry} used by this scanner, if any.\n\t */\n\t@Nullable\n\tprotected BeanDefinitionRegistry getRegistry() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Set the {@link ResourceLoader} to use for resource locations.\n\t * This will typically be a {@link ResourcePatternResolver} implementation.\n\t * <p>Default is a {@code PathMatchingResourcePatternResolver}, also capable of\n\t * resource pattern resolving through the {@code ResourcePatternResolver} interface.\n\t * @see org.springframework.core.io.support.ResourcePatternResolver\n\t * @see org.springframework.core.io.support.PathMatchingResourcePatternResolver\n\t */\n\t@Override\n\tpublic void setResourceLoader(@Nullable ResourceLoader resourceLoader) {\n\t\tthis.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader);\n\t\tthis.metadataReaderFactory = new CachingMetadataReaderFactory(resourceLoader);\n\t\tthis.componentsIndex = CandidateComponentsIndexLoader.loadIndex(this.resourcePatternResolver.getClassLoader());\n\t}\n\n\t/**\n\t * Return the ResourceLoader that this component provider uses.\n\t */\n\tpublic final ResourceLoader getResourceLoader() {\n\t\treturn getResourcePatternResolver();\n\t}\n\n\tprivate ResourcePatternResolver getResourcePatternResolver() {\n\t\tif (this.resourcePatternResolver == null) {\n\t\t\tthis.resourcePatternResolver = new PathMatchingResourcePatternResolver();\n\t\t}\n\t\treturn this.resourcePatternResolver;\n\t}\n\n\t/**\n\t * Set the {@link MetadataReaderFactory} to use.\n\t * <p>Default is a {@link CachingMetadataReaderFactory} for the specified\n\t * {@linkplain #setResourceLoader resource loader}.\n\t * <p>Call this setter method <i>after</i> {@link #setResourceLoader} in order\n\t * for the given MetadataReaderFactory to override the default factory.\n\t */\n\tpublic void setMetadataReaderFactory(MetadataReaderFactory metadataReaderFactory) {\n\t\tthis.metadataReaderFactory = metadataReaderFactory;\n\t}\n\n\t/**\n\t * Return the MetadataReaderFactory used by this component provider.\n\t */\n\tpublic final MetadataReaderFactory getMetadataReaderFactory() {\n\t\tif (this.metadataReaderFactory == null) {\n\t\t\tthis.metadataReaderFactory = new CachingMetadataReaderFactory();\n\t\t}\n\t\treturn this.metadataReaderFactory;\n\t}\n\n\n\t/**\n\t * Scan the class path for candidate components.\n\t * @param basePackage the package to check for annotated classes\n\t * @return a corresponding Set of autodetected bean definitions\n\t */\n\tpublic Set<BeanDefinition> findCandidateComponents(String basePackage) {\n\t\tif (this.componentsIndex != null && indexSupportsIncludeFilters()) {\n\t\t\treturn addCandidateComponentsFromIndex(this.componentsIndex, basePackage);\n\t\t}\n\t\telse {\n\t\t\treturn scanCandidateComponents(basePackage);\n\t\t}\n\t}\n\n\t/**\n\t * Determine if the index can be used by this instance.\n\t * @return {@code true} if the index is available and the configuration of this\n\t * instance is supported by it, {@code false} otherwise\n\t * @since 5.0\n\t */\n\tprivate boolean indexSupportsIncludeFilters() {\n\t\tfor (TypeFilter includeFilter : this.includeFilters) {\n\t\t\tif (!indexSupportsIncludeFilter(includeFilter)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Determine if the specified include {@link TypeFilter} is supported by the index.\n\t * @param filter the filter to check\n\t * @return whether the index supports this include filter\n\t * @since 5.0\n\t * @see #extractStereotype(TypeFilter)\n\t */\n\tprivate boolean indexSupportsIncludeFilter(TypeFilter filter) {\n\t\tif (filter instanceof AnnotationTypeFilter annotationTypeFilter) {\n\t\t\tClass<? extends Annotation> annotationType = annotationTypeFilter.getAnnotationType();\n\t\t\treturn (AnnotationUtils.isAnnotationDeclaredLocally(Indexed.class, annotationType) ||\n\t\t\t\t\tannotationType.getName().startsWith(\"jakarta.\"));\n\t\t}\n\t\tif (filter instanceof AssignableTypeFilter assignableTypeFilter) {\n\t\t\tClass<?> target = assignableTypeFilter.getTargetType();\n\t\t\treturn AnnotationUtils.isAnnotationDeclaredLocally(Indexed.class, target);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Extract the stereotype to use for the specified compatible filter.\n\t * @param filter the filter to handle\n\t * @return the stereotype in the index matching this filter\n\t * @since 5.0\n\t * @see #indexSupportsIncludeFilter(TypeFilter)\n\t */\n\t@Nullable\n\tprivate String extractStereotype(TypeFilter filter) {\n\t\tif (filter instanceof AnnotationTypeFilter annotationTypeFilter) {\n\t\t\treturn annotationTypeFilter.getAnnotationType().getName();\n\t\t}\n\t\tif (filter instanceof AssignableTypeFilter assignableTypeFilter) {\n\t\t\treturn assignableTypeFilter.getTargetType().getName();\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate Set<BeanDefinition> addCandidateComponentsFromIndex(CandidateComponentsIndex index, String basePackage) {\n\t\tSet<BeanDefinition> candidates = new LinkedHashSet<>();\n\t\ttry {\n\t\t\tSet<String> types = new HashSet<>();\n\t\t\tfor (TypeFilter filter : this.includeFilters) {\n\t\t\t\tString stereotype = extractStereotype(filter);\n\t\t\t\tif (stereotype == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Failed to extract stereotype from \" + filter);\n\t\t\t\t}\n\t\t\t\ttypes.addAll(index.getCandidateTypes(basePackage, stereotype));\n\t\t\t}\n\t\t\tboolean traceEnabled = logger.isTraceEnabled();\n\t\t\tboolean debugEnabled = logger.isDebugEnabled();\n\t\t\tfor (String type : types) {\n\t\t\t\tMetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(type);\n\t\t\t\tif (isCandidateComponent(metadataReader)) {\n\t\t\t\t\tScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);\n\t\t\t\t\tsbd.setSource(metadataReader.getResource());\n\t\t\t\t\tif (isCandidateComponent(sbd)) {\n\t\t\t\t\t\tif (debugEnabled) {\n\t\t\t\t\t\t\tlogger.debug(\"Using candidate component class from index: \" + type);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcandidates.add(sbd);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (debugEnabled) {\n\t\t\t\t\t\t\tlogger.debug(\"Ignored because not a concrete top-level class: \" + type);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (traceEnabled) {\n\t\t\t\t\t\tlogger.trace(\"Ignored because matching an exclude filter: \" + type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(\"I/O failure during classpath scanning\", ex);\n\t\t}\n\t\treturn candidates;\n\t}\n\n\tprivate Set<BeanDefinition> scanCandidateComponents(String basePackage) {\n\t\tSet<BeanDefinition> candidates = new LinkedHashSet<>();\n\t\ttry {\n\t\t\tString packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +\n\t\t\t\t\tresolveBasePackage(basePackage) + '/' + this.resourcePattern;\n\t\t\tResource[] resources = getResourcePatternResolver().getResources(packageSearchPath);\n\t\t\tboolean traceEnabled = logger.isTraceEnabled();\n\t\t\tboolean debugEnabled = logger.isDebugEnabled();\n\t\t\tfor (Resource resource : resources) {\n\t\t\t\tString filename = resource.getFilename();\n\t\t\t\tif (filename != null && filename.contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) {\n\t\t\t\t\t// Ignore CGLIB-generated classes in the classpath\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (traceEnabled) {\n\t\t\t\t\tlogger.trace(\"Scanning \" + resource);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tMetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);\n\t\t\t\t\tif (isCandidateComponent(metadataReader)) {\n\t\t\t\t\t\tScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);\n\t\t\t\t\t\tsbd.setSource(resource);\n\t\t\t\t\t\tif (isCandidateComponent(sbd)) {\n\t\t\t\t\t\t\tif (debugEnabled) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Identified candidate component class: \" + resource);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcandidates.add(sbd);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (debugEnabled) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Ignored because not a concrete top-level class: \" + resource);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (traceEnabled) {\n\t\t\t\t\t\t\tlogger.trace(\"Ignored because not matching any filter: \" + resource);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (FileNotFoundException ex) {\n\t\t\t\t\tif (traceEnabled) {\n\t\t\t\t\t\tlogger.trace(\"Ignored non-readable \" + resource + \": \" + ex.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\t\t\"Failed to read candidate component class: \" + resource, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(\"I/O failure during classpath scanning\", ex);\n\t\t}\n\t\treturn candidates;\n\t}\n\n\n\t/**\n\t * Resolve the specified base package into a pattern specification for\n\t * the package search path.\n\t * <p>The default implementation resolves placeholders against system properties,\n\t * and converts a \".\"-based package path to a \"/\"-based resource path.\n\t * @param basePackage the base package as specified by the user\n\t * @return the pattern specification to be used for package searching\n\t */\n\tprotected String resolveBasePackage(String basePackage) {\n\t\treturn ClassUtils.convertClassNameToResourcePath(getEnvironment().resolveRequiredPlaceholders(basePackage));\n\t}\n\n\t/**\n\t * Determine whether the given class does not match any exclude filter\n\t * and does match at least one include filter.\n\t * @param metadataReader the ASM ClassReader for the class\n\t * @return whether the class qualifies as a candidate component\n\t */\n\tprotected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {\n\t\tfor (TypeFilter tf : this.excludeFilters) {\n\t\t\tif (tf.match(metadataReader, getMetadataReaderFactory())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (TypeFilter tf : this.includeFilters) {\n\t\t\tif (tf.match(metadataReader, getMetadataReaderFactory())) {\n\t\t\t\treturn isConditionMatch(metadataReader);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine whether the given class is a candidate component based on any\n\t * {@code @Conditional} annotations.\n\t * @param metadataReader the ASM ClassReader for the class\n\t * @return whether the class qualifies as a candidate component\n\t */\n\tprivate boolean isConditionMatch(MetadataReader metadataReader) {\n\t\tif (this.conditionEvaluator == null) {\n\t\t\tthis.conditionEvaluator =\n\t\t\t\t\tnew ConditionEvaluator(getRegistry(), this.environment, this.resourcePatternResolver);\n\t\t}\n\t\treturn !this.conditionEvaluator.shouldSkip(metadataReader.getAnnotationMetadata());\n\t}\n\n\t/**\n\t * Determine whether the given bean definition qualifies as candidate.\n\t * <p>The default implementation checks whether the class is not an interface\n\t * and not dependent on an enclosing class.\n\t * <p>Can be overridden in subclasses.\n\t * @param beanDefinition the bean definition to check\n\t * @return whether the bean definition qualifies as a candidate component\n\t */\n\tprotected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {\n\t\tAnnotationMetadata metadata = beanDefinition.getMetadata();\n\t\treturn (metadata.isIndependent() && (metadata.isConcrete() ||\n\t\t\t\t(metadata.isAbstract() && metadata.hasAnnotatedMethods(Lookup.class.getName()))));\n\t}\n\n\n\t/**\n\t * Clear the local metadata cache, if any, removing all cached class metadata.\n\t */\n\tpublic void clearCache() {\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory cmrf) {\n\t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n\t\t\t// for a shared cache since it'll be cleared by the ApplicationContext.\n\t\t\tcmrf.clearCache();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#addExcludeFilter(excludeFilter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an exclude type filter to the <i>front</i> of the exclusion list.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "excludeFilter"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "void",
    "signature": "public void addExcludeFilter(TypeFilter excludeFilter)",
    "source_code": "\tpublic void addExcludeFilter(TypeFilter excludeFilter) {\n\t\tthis.excludeFilters.add(0, excludeFilter);\n\t}"
  },
  "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#addIncludeFilter(includeFilter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an include type filter to the <i>end</i> of the inclusion list.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "includeFilter"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "void",
    "signature": "public void addIncludeFilter(TypeFilter includeFilter)",
    "source_code": "\tpublic void addIncludeFilter(TypeFilter includeFilter) {\n\t\tthis.includeFilters.add(includeFilter);\n\t}"
  },
  "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#clearCache()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Clear the local metadata cache, if any, removing all cached class metadata.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 539
    },
    "return": "void",
    "signature": "public void clearCache()",
    "source_code": "\tpublic void clearCache() {\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory cmrf) {\n\t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n\t\t\t// for a shared cache since it'll be cleared by the ApplicationContext.\n\t\t\tcmrf.clearCache();\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#findCandidateComponents(basePackage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Scan the class path for candidate components.\n\t * @param basePackage the package to check for annotated classes\n\t * @return a corresponding Set of autodetected bean definitions\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "basePackage"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "Set<BeanDefinition>",
    "signature": "public Set<BeanDefinition> findCandidateComponents(String basePackage)",
    "source_code": "\tpublic Set<BeanDefinition> findCandidateComponents(String basePackage) {\n\t\tif (this.componentsIndex != null && indexSupportsIncludeFilters()) {\n\t\t\treturn addCandidateComponentsFromIndex(this.componentsIndex, basePackage);\n\t\t}\n\t\telse {\n\t\t\treturn scanCandidateComponents(basePackage);\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#getEnvironment()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "Environment",
    "signature": "public Environment getEnvironment()",
    "source_code": "\tpublic final Environment getEnvironment() {\n\t\tif (this.environment == null) {\n\t\t\tthis.environment = new StandardEnvironment();\n\t\t}\n\t\treturn this.environment;\n\t}"
  },
  "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#getMetadataReaderFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the MetadataReaderFactory used by this component provider.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "MetadataReaderFactory",
    "signature": "public MetadataReaderFactory getMetadataReaderFactory()",
    "source_code": "\tpublic final MetadataReaderFactory getMetadataReaderFactory() {\n\t\tif (this.metadataReaderFactory == null) {\n\t\t\tthis.metadataReaderFactory = new CachingMetadataReaderFactory();\n\t\t}\n\t\treturn this.metadataReaderFactory;\n\t}"
  },
  "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#getRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link BeanDefinitionRegistry} used by this scanner, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "BeanDefinitionRegistry",
    "signature": "protected BeanDefinitionRegistry getRegistry()",
    "source_code": "\tprotected BeanDefinitionRegistry getRegistry() {\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#getResourceLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the ResourceLoader that this component provider uses.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "ResourceLoader",
    "signature": "public ResourceLoader getResourceLoader()",
    "source_code": "\tpublic final ResourceLoader getResourceLoader() {\n\t\treturn getResourcePatternResolver();\n\t}"
  },
  "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#isCandidateComponent(beanDefinition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given bean definition qualifies as candidate.\n\t * <p>The default implementation checks whether the class is not an interface\n\t * and not dependent on an enclosing class.\n\t * <p>Can be overridden in subclasses.\n\t * @param beanDefinition the bean definition to check\n\t * @return whether the bean definition qualifies as a candidate component\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 529
    },
    "return": "boolean",
    "signature": "protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition)",
    "source_code": "\tprotected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {\n\t\tAnnotationMetadata metadata = beanDefinition.getMetadata();\n\t\treturn (metadata.isIndependent() && (metadata.isConcrete() ||\n\t\t\t\t(metadata.isAbstract() && metadata.hasAnnotatedMethods(Lookup.class.getName()))));\n\t}"
  },
  "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#isCandidateComponent(metadataReader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class does not match any exclude filter\n\t * and does match at least one include filter.\n\t * @param metadataReader the ASM ClassReader for the class\n\t * @return whether the class qualifies as a candidate component\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "metadataReader"
    ],
    "position": {
      "column": 1,
      "line": 493
    },
    "return": "boolean",
    "signature": "protected boolean isCandidateComponent(MetadataReader metadataReader)",
    "source_code": "\tprotected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {\n\t\tfor (TypeFilter tf : this.excludeFilters) {\n\t\t\tif (tf.match(metadataReader, getMetadataReaderFactory())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (TypeFilter tf : this.includeFilters) {\n\t\t\tif (tf.match(metadataReader, getMetadataReaderFactory())) {\n\t\t\t\treturn isConditionMatch(metadataReader);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#registerDefaultFilters()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the default filter for {@link Component @Component}.\n\t * <p>This will implicitly register all annotations that have the\n\t * {@link Component @Component} meta-annotation including the\n\t * {@link Repository @Repository}, {@link Service @Service}, and\n\t * {@link Controller @Controller} stereotype annotations.\n\t * <p>Also supports Jakarta EE's {@link jakarta.annotation.ManagedBean} and\n\t * JSR-330's {@link jakarta.inject.Named} annotations, if available.\n\t *\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "protected void registerDefaultFilters()",
    "source_code": "\tprotected void registerDefaultFilters() {\n\t\tthis.includeFilters.add(new AnnotationTypeFilter(Component.class));\n\t\tClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();\n\t\ttry {\n\t\t\tthis.includeFilters.add(new AnnotationTypeFilter(\n\t\t\t\t\t((Class<? extends Annotation>) ClassUtils.forName(\"jakarta.annotation.ManagedBean\", cl)), false));\n\t\t\tlogger.trace(\"JSR-250 'jakarta.annotation.ManagedBean' found and supported for component scanning\");\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t// JSR-250 1.1 API (as included in Jakarta EE) not available - simply skip.\n\t\t}\n\t\ttry {\n\t\t\tthis.includeFilters.add(new AnnotationTypeFilter(\n\t\t\t\t\t((Class<? extends Annotation>) ClassUtils.forName(\"jakarta.inject.Named\", cl)), false));\n\t\t\tlogger.trace(\"JSR-330 'jakarta.inject.Named' annotation found and supported for component scanning\");\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t// JSR-330 API not available - simply skip.\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#resetFilters(useDefaultFilters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset the configured type filters.\n\t * @param useDefaultFilters whether to re-register the default filters for\n\t * the {@link Component @Component}, {@link Repository @Repository},\n\t * {@link Service @Service}, and {@link Controller @Controller}\n\t * stereotype annotations\n\t * @see #registerDefaultFilters()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "useDefaultFilters"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "void",
    "signature": "public void resetFilters(boolean useDefaultFilters)",
    "source_code": "\tpublic void resetFilters(boolean useDefaultFilters) {\n\t\tthis.includeFilters.clear();\n\t\tthis.excludeFilters.clear();\n\t\tif (useDefaultFilters) {\n\t\t\tregisterDefaultFilters();\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#resolveBasePackage(basePackage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the specified base package into a pattern specification for\n\t * the package search path.\n\t * <p>The default implementation resolves placeholders against system properties,\n\t * and converts a \".\"-based package path to a \"/\"-based resource path.\n\t * @param basePackage the base package as specified by the user\n\t * @return the pattern specification to be used for package searching\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "basePackage"
    ],
    "position": {
      "column": 1,
      "line": 483
    },
    "return": "String",
    "signature": "protected String resolveBasePackage(String basePackage)",
    "source_code": "\tprotected String resolveBasePackage(String basePackage) {\n\t\treturn ClassUtils.convertClassNameToResourcePath(getEnvironment().resolveRequiredPlaceholders(basePackage));\n\t}"
  },
  "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#setEnvironment(environment)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Environment to use when resolving placeholders and evaluating\n\t * {@link Conditional @Conditional}-annotated component classes.\n\t * <p>The default is a {@link StandardEnvironment}.\n\t * @param environment the Environment to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "void",
    "signature": "public void setEnvironment(Environment environment)",
    "source_code": "\tpublic void setEnvironment(Environment environment) {\n\t\tAssert.notNull(environment, \"Environment must not be null\");\n\t\tthis.environment = environment;\n\t\tthis.conditionEvaluator = null;\n\t}"
  },
  "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#setMetadataReaderFactory(metadataReaderFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link MetadataReaderFactory} to use.\n\t * <p>Default is a {@link CachingMetadataReaderFactory} for the specified\n\t * {@linkplain #setResourceLoader resource loader}.\n\t * <p>Call this setter method <i>after</i> {@link #setResourceLoader} in order\n\t * for the given MetadataReaderFactory to override the default factory.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadataReaderFactory"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "void",
    "signature": "public void setMetadataReaderFactory(MetadataReaderFactory metadataReaderFactory)",
    "source_code": "\tpublic void setMetadataReaderFactory(MetadataReaderFactory metadataReaderFactory) {\n\t\tthis.metadataReaderFactory = metadataReaderFactory;\n\t}"
  },
  "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#setResourceLoader(resourceLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link ResourceLoader} to use for resource locations.\n\t * This will typically be a {@link ResourcePatternResolver} implementation.\n\t * <p>Default is a {@code PathMatchingResourcePatternResolver}, also capable of\n\t * resource pattern resolving through the {@code ResourcePatternResolver} interface.\n\t * @see org.springframework.core.io.support.ResourcePatternResolver\n\t * @see org.springframework.core.io.support.PathMatchingResourcePatternResolver\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLoader"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "void",
    "signature": "public void setResourceLoader(@Nullable ResourceLoader resourceLoader)",
    "source_code": "\tpublic void setResourceLoader(@Nullable ResourceLoader resourceLoader) {\n\t\tthis.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader);\n\t\tthis.metadataReaderFactory = new CachingMetadataReaderFactory(resourceLoader);\n\t\tthis.componentsIndex = CandidateComponentsIndexLoader.loadIndex(this.resourcePatternResolver.getClassLoader());\n\t}"
  },
  "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#setResourcePattern(resourcePattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the resource pattern to use when scanning the classpath.\n\t * This value will be appended to each base package name.\n\t * @see #findCandidateComponents(String)\n\t * @see #DEFAULT_RESOURCE_PATTERN\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourcePattern"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void setResourcePattern(String resourcePattern)",
    "source_code": "\tpublic void setResourcePattern(String resourcePattern) {\n\t\tAssert.notNull(resourcePattern, \"'resourcePattern' must not be null\");\n\t\tthis.resourcePattern = resourcePattern;\n\t}"
  },
  "org.springframework.context.annotation.logger": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A component provider that provides candidate components from a base package. Can\n * use {@link CandidateComponentsIndex the index} if it is available of scans the\n * classpath otherwise. Candidate components are identified by applying exclude and\n * include filters. {@link AnnotationTypeFilter}, {@link AssignableTypeFilter} include\n * filters on an annotation/superclass that are annotated with {@link Indexed} are\n * supported: if any other include filter is specified, the index is ignored and\n * classpath scanning is used instead.\n *\n * <p>This implementation is based on Spring's\n * {@link org.springframework.core.type.classreading.MetadataReader MetadataReader}\n * facility, backed by an ASM {@link org.springframework.asm.ClassReader ClassReader}.\n *\n * @author Mark Fisher\n * @author Juergen Hoeller\n * @author Ramnivas Laddad\n * @author Chris Beams\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @since 2.5\n * @see org.springframework.core.type.classreading.MetadataReaderFactory\n * @see org.springframework.core.type.AnnotationMetadata\n * @see ScannedGenericBeanDefinition\n * @see CandidateComponentsIndex\n */\npublic class ClassPathScanningCandidateComponentProvider implements EnvironmentCapable, ResourceLoaderAware {\n\n\tstatic final String DEFAULT_RESOURCE_PATTERN = \"**/*.class\";",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.core.io.support.PropertySourceProcessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Contribute {@link PropertySource property sources} to the {@link Environment}.\n *\n * <p>This class is stateful and merge descriptors with the same name in a\n * single {@link PropertySource} rather than creating dedicated ones.\n *\n * @author Stephane Nicoll\n * @since 6.0\n * @see PropertySourceDescriptor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class PropertySourceProcessor",
    "source_code": "public class PropertySourceProcessor {\n\n\tprivate static final PropertySourceFactory DEFAULT_PROPERTY_SOURCE_FACTORY = new DefaultPropertySourceFactory();\n\n\tprivate static final Log logger = LogFactory.getLog(PropertySourceProcessor.class);\n\n\tprivate final ConfigurableEnvironment environment;\n\n\tprivate final ResourceLoader resourceLoader;\n\n\tprivate final List<String> propertySourceNames;\n\n\tpublic PropertySourceProcessor(ConfigurableEnvironment environment, ResourceLoader resourceLoader) {\n\t\tthis.environment = environment;\n\t\tthis.resourceLoader = resourceLoader;\n\t\tthis.propertySourceNames = new ArrayList<>();\n\t}\n\n\t/**\n\t * Process the specified {@link PropertySourceDescriptor} against the\n\t * environment managed by this instance.\n\t * @param descriptor the descriptor to process\n\t * @throws IOException if loading the properties failed\n\t */\n\tpublic void processPropertySource(PropertySourceDescriptor descriptor) throws IOException {\n\t\tString name = descriptor.name();\n\t\tString encoding = descriptor.encoding();\n\t\tList<String> locations = descriptor.locations();\n\t\tAssert.isTrue(locations.size() > 0, \"At least one @PropertySource(value) location is required\");\n\t\tboolean ignoreResourceNotFound = descriptor.ignoreResourceNotFound();\n\t\tPropertySourceFactory factory = (descriptor.propertySourceFactory() != null ?\n\t\t\t\tinstantiateClass(descriptor.propertySourceFactory()) : DEFAULT_PROPERTY_SOURCE_FACTORY);\n\n\t\tfor (String location : locations) {\n\t\t\ttry {\n\t\t\t\tString resolvedLocation = this.environment.resolveRequiredPlaceholders(location);\n\t\t\t\tResource resource = this.resourceLoader.getResource(resolvedLocation);\n\t\t\t\taddPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)));\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException | FileNotFoundException | UnknownHostException | SocketException ex) {\n\t\t\t\t// Placeholders not resolvable or resource not found when trying to open it\n\t\t\t\tif (ignoreResourceNotFound) {\n\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\tlogger.info(\"Properties location [\" + location + \"] not resolvable: \" + ex.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void addPropertySource(org.springframework.core.env.PropertySource<?> propertySource) {\n\t\tString name = propertySource.getName();\n\t\tMutablePropertySources propertySources = this.environment.getPropertySources();\n\n\t\tif (this.propertySourceNames.contains(name)) {\n\t\t\t// We've already added a version, we need to extend it\n\t\t\torg.springframework.core.env.PropertySource<?> existing = propertySources.get(name);\n\t\t\tif (existing != null) {\n\t\t\t\tPropertySource<?> newSource = (propertySource instanceof ResourcePropertySource rps ?\n\t\t\t\t\t\trps.withResourceName() : propertySource);\n\t\t\t\tif (existing instanceof CompositePropertySource cps) {\n\t\t\t\t\tcps.addFirstPropertySource(newSource);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (existing instanceof ResourcePropertySource rps) {\n\t\t\t\t\t\texisting = rps.withResourceName();\n\t\t\t\t\t}\n\t\t\t\t\tCompositePropertySource composite = new CompositePropertySource(name);\n\t\t\t\t\tcomposite.addPropertySource(newSource);\n\t\t\t\t\tcomposite.addPropertySource(existing);\n\t\t\t\t\tpropertySources.replace(name, composite);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (this.propertySourceNames.isEmpty()) {\n\t\t\tpropertySources.addLast(propertySource);\n\t\t}\n\t\telse {\n\t\t\tString firstProcessed = this.propertySourceNames.get(this.propertySourceNames.size() - 1);\n\t\t\tpropertySources.addBefore(firstProcessed, propertySource);\n\t\t}\n\t\tthis.propertySourceNames.add(name);\n\t}\n\n\tprivate PropertySourceFactory instantiateClass(Class<? extends PropertySourceFactory> type) {\n\t\ttry {\n\t\t\tConstructor<? extends PropertySourceFactory> constructor = type.getDeclaredConstructor();\n\t\t\tReflectionUtils.makeAccessible(constructor);\n\t\t\treturn constructor.newInstance();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new IllegalStateException(\"Failed to instantiate \" + type, ex);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.core.io.support.PropertySourceProcessor#processPropertySource(descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the specified {@link PropertySourceDescriptor} against the\n\t * environment managed by this instance.\n\t * @param descriptor the descriptor to process\n\t * @throws IOException if loading the properties failed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void processPropertySource(PropertySourceDescriptor descriptor)",
    "source_code": "\tpublic void processPropertySource(PropertySourceDescriptor descriptor) throws IOException {\n\t\tString name = descriptor.name();\n\t\tString encoding = descriptor.encoding();\n\t\tList<String> locations = descriptor.locations();\n\t\tAssert.isTrue(locations.size() > 0, \"At least one @PropertySource(value) location is required\");\n\t\tboolean ignoreResourceNotFound = descriptor.ignoreResourceNotFound();\n\t\tPropertySourceFactory factory = (descriptor.propertySourceFactory() != null ?\n\t\t\t\tinstantiateClass(descriptor.propertySourceFactory()) : DEFAULT_PROPERTY_SOURCE_FACTORY);\n\n\t\tfor (String location : locations) {\n\t\t\ttry {\n\t\t\t\tString resolvedLocation = this.environment.resolveRequiredPlaceholders(location);\n\t\t\t\tResource resource = this.resourceLoader.getResource(resolvedLocation);\n\t\t\t\taddPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)));\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException | FileNotFoundException | UnknownHostException | SocketException ex) {\n\t\t\t\t// Placeholders not resolvable or resource not found when trying to open it\n\t\t\t\tif (ignoreResourceNotFound) {\n\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\tlogger.info(\"Properties location [\" + location + \"] not resolvable: \" + ex.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.docs.integration.observability.config.conventions.ServerRequestObservationFilter": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 26
    },
    "signature": "public class ServerRequestObservationFilter",
    "source_code": "public class ServerRequestObservationFilter implements ObservationFilter {\n\n\t@Override\n\tpublic Observation.Context map(Observation.Context context) {\n\t\tif (context instanceof ServerRequestObservationContext serverContext) {\n\t\t\tcontext.setName(\"custom.observation.name\");\n\t\t\tcontext.addLowCardinalityKeyValue(KeyValue.of(\"project\", \"spring\"));\n\t\t\tString customAttribute = (String) serverContext.getCarrier().getAttribute(\"customAttribute\");\n\t\t\tcontext.addLowCardinalityKeyValue(KeyValue.of(\"custom.attribute\", customAttribute));\n\t\t}\n\t\treturn context;\n\t}\n}"
  },
  "org.springframework.expression.spel.ast.FunctionReference": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A function reference is of the form \"#someFunction(a,b,c)\". Functions may be defined\n * in the context prior to the expression being evaluated. Functions may also be static\n * Java methods, registered in the context prior to invocation of the expression.\n *\n * <p>Functions are very simplistic. The arguments are not part of the definition\n * (right now), so the names must be unique.\n *\n * @author Andy Clement\n * @author Juergen Hoeller\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class FunctionReference",
    "source_code": "public class FunctionReference extends SpelNodeImpl {\n\n\tprivate final String name;\n\n\t// Captures the most recently used method for the function invocation *if* the method\n\t// can safely be used for compilation (i.e. no argument conversion is going on)\n\t@Nullable\n\tprivate volatile Method method;\n\n\n\tpublic FunctionReference(String functionName, int startPos, int endPos, SpelNodeImpl... arguments) {\n\t\tsuper(startPos, endPos, arguments);\n\t\tthis.name = functionName;\n\t}\n\n\n\t@Override\n\tpublic TypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\tTypedValue value = state.lookupVariable(this.name);\n\t\tif (value == TypedValue.NULL) {\n\t\t\tthrow new SpelEvaluationException(getStartPosition(), SpelMessage.FUNCTION_NOT_DEFINED, this.name);\n\t\t}\n\t\tif (!(value.getValue() instanceof Method function)) {\n\t\t\t// Possibly a static Java method registered as a function\n\t\t\tthrow new SpelEvaluationException(\n\t\t\t\t\tSpelMessage.FUNCTION_REFERENCE_CANNOT_BE_INVOKED, this.name, value.getClass());\n\t\t}\n\n\t\ttry {\n\t\t\treturn executeFunctionJLRMethod(state, function);\n\t\t}\n\t\tcatch (SpelEvaluationException ex) {\n\t\t\tex.setPosition(getStartPosition());\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\t/**\n\t * Execute a function represented as a {@code java.lang.reflect.Method}.\n\t * @param state the expression evaluation state\n\t * @param method the method to invoke\n\t * @return the return value of the invoked Java method\n\t * @throws EvaluationException if there is any problem invoking the method\n\t */\n\tprivate TypedValue executeFunctionJLRMethod(ExpressionState state, Method method) throws EvaluationException {\n\t\tObject[] functionArgs = getArguments(state);\n\n\t\tif (!method.isVarArgs()) {\n\t\t\tint declaredParamCount = method.getParameterCount();\n\t\t\tif (declaredParamCount != functionArgs.length) {\n\t\t\t\tthrow new SpelEvaluationException(SpelMessage.INCORRECT_NUMBER_OF_ARGUMENTS_TO_FUNCTION,\n\t\t\t\t\t\tfunctionArgs.length, declaredParamCount);\n\t\t\t}\n\t\t}\n\t\tif (!Modifier.isStatic(method.getModifiers())) {\n\t\t\tthrow new SpelEvaluationException(getStartPosition(),\n\t\t\t\t\tSpelMessage.FUNCTION_MUST_BE_STATIC, ClassUtils.getQualifiedMethodName(method), this.name);\n\t\t}\n\n\t\t// Convert arguments if necessary and remap them for varargs if required\n\t\tTypeConverter converter = state.getEvaluationContext().getTypeConverter();\n\t\tboolean argumentConversionOccurred = ReflectionHelper.convertAllArguments(converter, functionArgs, method);\n\t\tif (method.isVarArgs()) {\n\t\t\tfunctionArgs = ReflectionHelper.setupArgumentsForVarargsInvocation(\n\t\t\t\t\tmethod.getParameterTypes(), functionArgs);\n\t\t}\n\t\tboolean compilable = false;\n\n\t\ttry {\n\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\tObject result = method.invoke(method.getClass(), functionArgs);\n\t\t\tcompilable = !argumentConversionOccurred;\n\t\t\treturn new TypedValue(result, new TypeDescriptor(new MethodParameter(method, -1)).narrow(result));\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new SpelEvaluationException(getStartPosition(), ex, SpelMessage.EXCEPTION_DURING_FUNCTION_CALL,\n\t\t\t\t\tthis.name, ex.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (compilable) {\n\t\t\t\tthis.exitTypeDescriptor = CodeFlow.toDescriptor(method.getReturnType());\n\t\t\t\tthis.method = method;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.exitTypeDescriptor = null;\n\t\t\t\tthis.method = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toStringAST() {\n\t\tStringJoiner sj = new StringJoiner(\",\", \"(\", \")\");\n\t\tfor (int i = 0; i < getChildCount(); i++) {\n\t\t\tsj.add(getChild(i).toStringAST());\n\t\t}\n\t\treturn '#' + this.name + sj.toString();\n\t}\n\n\t/**\n\t * Compute the arguments to the function, they are the children of this expression node.\n\t * @return an array of argument values for the function call\n\t */\n\tprivate Object[] getArguments(ExpressionState state) throws EvaluationException {\n\t\t// Compute arguments to the function\n\t\tObject[] arguments = new Object[getChildCount()];\n\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\targuments[i] = this.children[i].getValueInternal(state).getValue();\n\t\t}\n\t\treturn arguments;\n\t}\n\n\t@Override\n\tpublic boolean isCompilable() {\n\t\tMethod method = this.method;\n\t\tif (method == null) {\n\t\t\treturn false;\n\t\t}\n\t\tint methodModifiers = method.getModifiers();\n\t\tif (!Modifier.isStatic(methodModifiers) || !Modifier.isPublic(methodModifiers) ||\n\t\t\t\t!Modifier.isPublic(method.getDeclaringClass().getModifiers())) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (SpelNodeImpl child : this.children) {\n\t\t\tif (!child.isCompilable()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tMethod method = this.method;\n\t\tAssert.state(method != null, \"No method handle\");\n\t\tString classDesc = method.getDeclaringClass().getName().replace('.', '/');\n\t\tgenerateCodeForArguments(mv, cf, method, this.children);\n\t\tmv.visitMethodInsn(INVOKESTATIC, classDesc, method.getName(),\n\t\t\t\tCodeFlow.createSignatureDescriptor(method), false);\n\t\tcf.pushDescriptor(this.exitTypeDescriptor);\n\t}\n\n}"
  },
  "org.springframework.expression.spel.ast.FunctionReference#generateCode(mv,cf)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void generateCode(MethodVisitor mv, CodeFlow cf)",
    "source_code": "\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tMethod method = this.method;\n\t\tAssert.state(method != null, \"No method handle\");\n\t\tString classDesc = method.getDeclaringClass().getName().replace('.', '/');\n\t\tgenerateCodeForArguments(mv, cf, method, this.children);\n\t\tmv.visitMethodInsn(INVOKESTATIC, classDesc, method.getName(),\n\t\t\t\tCodeFlow.createSignatureDescriptor(method), false);\n\t\tcf.pushDescriptor(this.exitTypeDescriptor);\n\t}"
  },
  "org.springframework.expression.spel.ast.FunctionReference#getValueInternal(state)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "state"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "TypedValue",
    "signature": "public TypedValue getValueInternal(ExpressionState state)",
    "source_code": "\tpublic TypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\tTypedValue value = state.lookupVariable(this.name);\n\t\tif (value == TypedValue.NULL) {\n\t\t\tthrow new SpelEvaluationException(getStartPosition(), SpelMessage.FUNCTION_NOT_DEFINED, this.name);\n\t\t}\n\t\tif (!(value.getValue() instanceof Method function)) {\n\t\t\t// Possibly a static Java method registered as a function\n\t\t\tthrow new SpelEvaluationException(\n\t\t\t\t\tSpelMessage.FUNCTION_REFERENCE_CANNOT_BE_INVOKED, this.name, value.getClass());\n\t\t}\n\n\t\ttry {\n\t\t\treturn executeFunctionJLRMethod(state, function);\n\t\t}\n\t\tcatch (SpelEvaluationException ex) {\n\t\t\tex.setPosition(getStartPosition());\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.ast.FunctionReference#isCompilable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "boolean",
    "signature": "public boolean isCompilable()",
    "source_code": "\tpublic boolean isCompilable() {\n\t\tMethod method = this.method;\n\t\tif (method == null) {\n\t\t\treturn false;\n\t\t}\n\t\tint methodModifiers = method.getModifiers();\n\t\tif (!Modifier.isStatic(methodModifiers) || !Modifier.isPublic(methodModifiers) ||\n\t\t\t\t!Modifier.isPublic(method.getDeclaringClass().getModifiers())) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (SpelNodeImpl child : this.children) {\n\t\t\tif (!child.isCompilable()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.expression.spel.ast.FunctionReference#toStringAST()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "String",
    "signature": "public String toStringAST()",
    "source_code": "\tpublic String toStringAST() {\n\t\tStringJoiner sj = new StringJoiner(\",\", \"(\", \")\");\n\t\tfor (int i = 0; i < getChildCount(); i++) {\n\t\t\tsj.add(getChild(i).toStringAST());\n\t\t}\n\t\treturn '#' + this.name + sj.toString();\n\t}"
  },
  "org.springframework.expression.spel.ast.MethodReference": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Expression language AST node that represents a method reference.\n *\n * @author Andy Clement\n * @author Juergen Hoeller\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public class MethodReference",
    "source_code": "public class MethodReference extends SpelNodeImpl {\n\n\tprivate final String name;\n\n\tprivate final boolean nullSafe;\n\n\t@Nullable\n\tprivate String originalPrimitiveExitTypeDescriptor;\n\n\t@Nullable\n\tprivate volatile CachedMethodExecutor cachedExecutor;\n\n\n\tpublic MethodReference(boolean nullSafe, String methodName, int startPos, int endPos, SpelNodeImpl... arguments) {\n\t\tsuper(startPos, endPos, arguments);\n\t\tthis.name = methodName;\n\t\tthis.nullSafe = nullSafe;\n\t}\n\n\n\tpublic final String getName() {\n\t\treturn this.name;\n\t}\n\n\t@Override\n\tprotected ValueRef getValueRef(ExpressionState state) throws EvaluationException {\n\t\tObject[] arguments = getArguments(state);\n\t\tif (state.getActiveContextObject().getValue() == null) {\n\t\t\tthrowIfNotNullSafe(getArgumentTypes(arguments));\n\t\t\treturn ValueRef.NullValueRef.INSTANCE;\n\t\t}\n\t\treturn new MethodValueRef(state, arguments);\n\t}\n\n\t@Override\n\tpublic TypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\tEvaluationContext evaluationContext = state.getEvaluationContext();\n\t\tObject value = state.getActiveContextObject().getValue();\n\t\tTypeDescriptor targetType = state.getActiveContextObject().getTypeDescriptor();\n\t\tObject[] arguments = getArguments(state);\n\t\tTypedValue result = getValueInternal(evaluationContext, value, targetType, arguments);\n\t\tupdateExitTypeDescriptor();\n\t\treturn result;\n\t}\n\n\tprivate TypedValue getValueInternal(EvaluationContext evaluationContext,\n\t\t\t@Nullable Object value, @Nullable TypeDescriptor targetType, Object[] arguments) {\n\n\t\tList<TypeDescriptor> argumentTypes = getArgumentTypes(arguments);\n\t\tif (value == null) {\n\t\t\tthrowIfNotNullSafe(argumentTypes);\n\t\t\treturn TypedValue.NULL;\n\t\t}\n\n\t\tMethodExecutor executorToUse = getCachedExecutor(evaluationContext, value, targetType, argumentTypes);\n\t\tif (executorToUse != null) {\n\t\t\ttry {\n\t\t\t\treturn executorToUse.execute(evaluationContext, value, arguments);\n\t\t\t}\n\t\t\tcatch (AccessException ex) {\n\t\t\t\t// Two reasons this can occur:\n\t\t\t\t// 1. the method invoked actually threw a real exception\n\t\t\t\t// 2. the method invoked was not passed the arguments it expected and\n\t\t\t\t//    has become 'stale'\n\n\t\t\t\t// In the first case we should not retry, in the second case we should see\n\t\t\t\t// if there is a better suited method.\n\n\t\t\t\t// To determine the situation, the AccessException will contain a cause.\n\t\t\t\t// If the cause is an InvocationTargetException, a user exception was\n\t\t\t\t// thrown inside the method. Otherwise the method could not be invoked.\n\t\t\t\tthrowSimpleExceptionIfPossible(value, ex);\n\n\t\t\t\t// At this point we know it wasn't a user problem so worth a retry if a\n\t\t\t\t// better candidate can be found.\n\t\t\t\tthis.cachedExecutor = null;\n\t\t\t}\n\t\t}\n\n\t\t// either there was no accessor or it no longer existed\n\t\texecutorToUse = findAccessorForMethod(argumentTypes, value, evaluationContext);\n\t\tthis.cachedExecutor = new CachedMethodExecutor(\n\t\t\t\texecutorToUse, (value instanceof Class<?> clazz ? clazz : null), targetType, argumentTypes);\n\t\ttry {\n\t\t\treturn executorToUse.execute(evaluationContext, value, arguments);\n\t\t}\n\t\tcatch (AccessException ex) {\n\t\t\t// Same unwrapping exception handling as above in above catch block\n\t\t\tthrowSimpleExceptionIfPossible(value, ex);\n\t\t\tthrow new SpelEvaluationException(getStartPosition(), ex,\n\t\t\t\t\tSpelMessage.EXCEPTION_DURING_METHOD_INVOCATION, this.name,\n\t\t\t\t\tvalue.getClass().getName(), ex.getMessage());\n\t\t}\n\t}\n\n\tprivate void throwIfNotNullSafe(List<TypeDescriptor> argumentTypes) {\n\t\tif (!this.nullSafe) {\n\t\t\tthrow new SpelEvaluationException(getStartPosition(),\n\t\t\t\t\tSpelMessage.METHOD_CALL_ON_NULL_OBJECT_NOT_ALLOWED,\n\t\t\t\t\tFormatHelper.formatMethodForMessage(this.name, argumentTypes));\n\t\t}\n\t}\n\n\tprivate Object[] getArguments(ExpressionState state) {\n\t\tObject[] arguments = new Object[getChildCount()];\n\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t// Make the root object the active context again for evaluating the parameter expressions\n\t\t\ttry {\n\t\t\t\tstate.pushActiveContextObject(state.getScopeRootContextObject());\n\t\t\t\targuments[i] = this.children[i].getValueInternal(state).getValue();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tstate.popActiveContextObject();\n\t\t\t}\n\t\t}\n\t\treturn arguments;\n\t}\n\n\tprivate List<TypeDescriptor> getArgumentTypes(Object... arguments) {\n\t\tList<TypeDescriptor> descriptors = new ArrayList<>(arguments.length);\n\t\tfor (Object argument : arguments) {\n\t\t\tdescriptors.add(TypeDescriptor.forObject(argument));\n\t\t}\n\t\treturn Collections.unmodifiableList(descriptors);\n\t}\n\n\t@Nullable\n\tprivate MethodExecutor getCachedExecutor(EvaluationContext evaluationContext, Object value,\n\t\t\t@Nullable TypeDescriptor target, List<TypeDescriptor> argumentTypes) {\n\n\t\tList<MethodResolver> methodResolvers = evaluationContext.getMethodResolvers();\n\t\tif (methodResolvers.size() != 1 || !(methodResolvers.get(0) instanceof ReflectiveMethodResolver)) {\n\t\t\t// Not a default ReflectiveMethodResolver - don't know whether caching is valid\n\t\t\treturn null;\n\t\t}\n\n\t\tCachedMethodExecutor executorToCheck = this.cachedExecutor;\n\t\tif (executorToCheck != null && executorToCheck.isSuitable(value, target, argumentTypes)) {\n\t\t\treturn executorToCheck.get();\n\t\t}\n\t\tthis.cachedExecutor = null;\n\t\treturn null;\n\t}\n\n\tprivate MethodExecutor findAccessorForMethod(List<TypeDescriptor> argumentTypes, Object targetObject,\n\t\t\tEvaluationContext evaluationContext) throws SpelEvaluationException {\n\n\t\tAccessException accessException = null;\n\t\tfor (MethodResolver methodResolver : evaluationContext.getMethodResolvers()) {\n\t\t\ttry {\n\t\t\t\tMethodExecutor methodExecutor = methodResolver.resolve(\n\t\t\t\t\t\tevaluationContext, targetObject, this.name, argumentTypes);\n\t\t\t\tif (methodExecutor != null) {\n\t\t\t\t\treturn methodExecutor;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (AccessException ex) {\n\t\t\t\taccessException = ex;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tString method = FormatHelper.formatMethodForMessage(this.name, argumentTypes);\n\t\tString className = FormatHelper.formatClassNameForMessage(\n\t\t\t\ttargetObject instanceof Class<?> clazz ? clazz : targetObject.getClass());\n\t\tif (accessException != null) {\n\t\t\tthrow new SpelEvaluationException(\n\t\t\t\t\tgetStartPosition(), accessException, SpelMessage.PROBLEM_LOCATING_METHOD, method, className);\n\t\t}\n\t\telse {\n\t\t\tthrow new SpelEvaluationException(getStartPosition(), SpelMessage.METHOD_NOT_FOUND, method, className);\n\t\t}\n\t}\n\n\t/**\n\t * Decode the AccessException, throwing a lightweight evaluation exception or,\n\t * if the cause was a RuntimeException, throw the RuntimeException directly.\n\t */\n\tprivate void throwSimpleExceptionIfPossible(Object value, AccessException ex) {\n\t\tif (ex.getCause() instanceof InvocationTargetException) {\n\t\t\tThrowable rootCause = ex.getCause().getCause();\n\t\t\tif (rootCause instanceof RuntimeException runtimeException) {\n\t\t\t\tthrow runtimeException;\n\t\t\t}\n\t\t\tthrow new ExpressionInvocationTargetException(getStartPosition(),\n\t\t\t\t\t\"A problem occurred when trying to execute method '\" + this.name +\n\t\t\t\t\t\"' on object of type [\" + value.getClass().getName() + \"]\", rootCause);\n\t\t}\n\t}\n\n\tprivate void updateExitTypeDescriptor() {\n\t\tCachedMethodExecutor executorToCheck = this.cachedExecutor;\n\t\tif (executorToCheck != null && executorToCheck.get() instanceof ReflectiveMethodExecutor reflectiveMethodExecutor) {\n\t\t\tMethod method = reflectiveMethodExecutor.getMethod();\n\t\t\tString descriptor = CodeFlow.toDescriptor(method.getReturnType());\n\t\t\tif (this.nullSafe && CodeFlow.isPrimitive(descriptor)) {\n\t\t\t\tthis.originalPrimitiveExitTypeDescriptor = descriptor;\n\t\t\t\tthis.exitTypeDescriptor = CodeFlow.toBoxedDescriptor(descriptor);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.exitTypeDescriptor = descriptor;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toStringAST() {\n\t\tStringJoiner sj = new StringJoiner(\",\", \"(\", \")\");\n\t\tfor (int i = 0; i < getChildCount(); i++) {\n\t\t\tsj.add(getChild(i).toStringAST());\n\t\t}\n\t\treturn this.name + sj.toString();\n\t}\n\n\t/**\n\t * A method reference is compilable if it has been resolved to a reflectively accessible method\n\t * and the child nodes (arguments to the method) are also compilable.\n\t */\n\t@Override\n\tpublic boolean isCompilable() {\n\t\tCachedMethodExecutor executorToCheck = this.cachedExecutor;\n\t\tif (executorToCheck == null || executorToCheck.hasProxyTarget() ||\n\t\t\t\t!(executorToCheck.get() instanceof ReflectiveMethodExecutor)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (SpelNodeImpl child : this.children) {\n\t\t\tif (!child.isCompilable()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tReflectiveMethodExecutor executor = (ReflectiveMethodExecutor) executorToCheck.get();\n\t\tif (executor.didArgumentConversionOccur()) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?> clazz = executor.getMethod().getDeclaringClass();\n\t\tif (!Modifier.isPublic(clazz.getModifiers()) && executor.getPublicDeclaringClass() == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tCachedMethodExecutor executorToCheck = this.cachedExecutor;\n\t\tif (executorToCheck == null || !(executorToCheck.get() instanceof ReflectiveMethodExecutor)) {\n\t\t\tthrow new IllegalStateException(\"No applicable cached executor found: \" + executorToCheck);\n\t\t}\n\n\t\tReflectiveMethodExecutor methodExecutor = (ReflectiveMethodExecutor) executorToCheck.get();\n\t\tMethod method = methodExecutor.getMethod();\n\t\tboolean isStaticMethod = Modifier.isStatic(method.getModifiers());\n\t\tString descriptor = cf.lastDescriptor();\n\n\t\tLabel skipIfNull = null;\n\t\tif (descriptor == null && !isStaticMethod) {\n\t\t\t// Nothing on the stack but something is needed\n\t\t\tcf.loadTarget(mv);\n\t\t}\n\t\tif ((descriptor != null || !isStaticMethod) && this.nullSafe) {\n\t\t\tmv.visitInsn(DUP);\n\t\t\tskipIfNull = new Label();\n\t\t\tLabel continueLabel = new Label();\n\t\t\tmv.visitJumpInsn(IFNONNULL, continueLabel);\n\t\t\tCodeFlow.insertCheckCast(mv, this.exitTypeDescriptor);\n\t\t\tmv.visitJumpInsn(GOTO, skipIfNull);\n\t\t\tmv.visitLabel(continueLabel);\n\t\t}\n\t\tif (descriptor != null && isStaticMethod) {\n\t\t\t// Something on the stack when nothing is needed\n\t\t\tmv.visitInsn(POP);\n\t\t}\n\n\t\tif (CodeFlow.isPrimitive(descriptor)) {\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, descriptor.charAt(0));\n\t\t}\n\n\t\tString classDesc;\n\t\tif (Modifier.isPublic(method.getDeclaringClass().getModifiers())) {\n\t\t\tclassDesc = method.getDeclaringClass().getName().replace('.', '/');\n\t\t}\n\t\telse {\n\t\t\tClass<?> publicDeclaringClass = methodExecutor.getPublicDeclaringClass();\n\t\t\tAssert.state(publicDeclaringClass != null, \"No public declaring class\");\n\t\t\tclassDesc = publicDeclaringClass.getName().replace('.', '/');\n\t\t}\n\n\t\tif (!isStaticMethod && (descriptor == null || !descriptor.substring(1).equals(classDesc))) {\n\t\t\tCodeFlow.insertCheckCast(mv, \"L\" + classDesc);\n\t\t}\n\n\t\tgenerateCodeForArguments(mv, cf, method, this.children);\n\t\tmv.visitMethodInsn((isStaticMethod ? INVOKESTATIC : (method.isDefault() ? INVOKEINTERFACE : INVOKEVIRTUAL)),\n\t\t\t\tclassDesc, method.getName(), CodeFlow.createSignatureDescriptor(method),\n\t\t\t\tmethod.getDeclaringClass().isInterface());\n\t\tcf.pushDescriptor(this.exitTypeDescriptor);\n\n\t\tif (this.originalPrimitiveExitTypeDescriptor != null) {\n\t\t\t// The output of the accessor will be a primitive but from the block above it might be null,\n\t\t\t// so to have a 'common stack' element at skipIfNull target we need to box the primitive\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, this.originalPrimitiveExitTypeDescriptor);\n\t\t}\n\t\tif (skipIfNull != null) {\n\t\t\tmv.visitLabel(skipIfNull);\n\t\t}\n\t}\n\n\n\tprivate class MethodValueRef implements ValueRef {\n\n\t\tprivate final EvaluationContext evaluationContext;\n\n\t\t@Nullable\n\t\tprivate final Object value;\n\n\t\t@Nullable\n\t\tprivate final TypeDescriptor targetType;\n\n\t\tprivate final Object[] arguments;\n\n\t\tpublic MethodValueRef(ExpressionState state, Object[] arguments) {\n\t\t\tthis.evaluationContext = state.getEvaluationContext();\n\t\t\tthis.value = state.getActiveContextObject().getValue();\n\t\t\tthis.targetType = state.getActiveContextObject().getTypeDescriptor();\n\t\t\tthis.arguments = arguments;\n\t\t}\n\n\t\t@Override\n\t\tpublic TypedValue getValue() {\n\t\t\tTypedValue result = MethodReference.this.getValueInternal(\n\t\t\t\t\tthis.evaluationContext, this.value, this.targetType, this.arguments);\n\t\t\tupdateExitTypeDescriptor();\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic void setValue(@Nullable Object newValue) {\n\t\t\tthrow new IllegalAccessError();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isWritable() {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\tprivate static class CachedMethodExecutor {\n\n\t\tprivate final MethodExecutor methodExecutor;\n\n\t\t@Nullable\n\t\tprivate final Class<?> staticClass;\n\n\t\t@Nullable\n\t\tprivate final TypeDescriptor target;\n\n\t\tprivate final List<TypeDescriptor> argumentTypes;\n\n\t\tpublic CachedMethodExecutor(MethodExecutor methodExecutor, @Nullable Class<?> staticClass,\n\t\t\t\t@Nullable TypeDescriptor target, List<TypeDescriptor> argumentTypes) {\n\n\t\t\tthis.methodExecutor = methodExecutor;\n\t\t\tthis.staticClass = staticClass;\n\t\t\tthis.target = target;\n\t\t\tthis.argumentTypes = argumentTypes;\n\t\t}\n\n\t\tpublic boolean isSuitable(Object value, @Nullable TypeDescriptor target, List<TypeDescriptor> argumentTypes) {\n\t\t\treturn ((this.staticClass == null || this.staticClass == value) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.target, target) && this.argumentTypes.equals(argumentTypes));\n\t\t}\n\n\t\tpublic boolean hasProxyTarget() {\n\t\t\treturn (this.target != null && Proxy.isProxyClass(this.target.getType()));\n\t\t}\n\n\t\tpublic MethodExecutor get() {\n\t\t\treturn this.methodExecutor;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.expression.spel.ast.MethodReference#generateCode(mv,cf)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "void",
    "signature": "public void generateCode(MethodVisitor mv, CodeFlow cf)",
    "source_code": "\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tCachedMethodExecutor executorToCheck = this.cachedExecutor;\n\t\tif (executorToCheck == null || !(executorToCheck.get() instanceof ReflectiveMethodExecutor)) {\n\t\t\tthrow new IllegalStateException(\"No applicable cached executor found: \" + executorToCheck);\n\t\t}\n\n\t\tReflectiveMethodExecutor methodExecutor = (ReflectiveMethodExecutor) executorToCheck.get();\n\t\tMethod method = methodExecutor.getMethod();\n\t\tboolean isStaticMethod = Modifier.isStatic(method.getModifiers());\n\t\tString descriptor = cf.lastDescriptor();\n\n\t\tLabel skipIfNull = null;\n\t\tif (descriptor == null && !isStaticMethod) {\n\t\t\t// Nothing on the stack but something is needed\n\t\t\tcf.loadTarget(mv);\n\t\t}\n\t\tif ((descriptor != null || !isStaticMethod) && this.nullSafe) {\n\t\t\tmv.visitInsn(DUP);\n\t\t\tskipIfNull = new Label();\n\t\t\tLabel continueLabel = new Label();\n\t\t\tmv.visitJumpInsn(IFNONNULL, continueLabel);\n\t\t\tCodeFlow.insertCheckCast(mv, this.exitTypeDescriptor);\n\t\t\tmv.visitJumpInsn(GOTO, skipIfNull);\n\t\t\tmv.visitLabel(continueLabel);\n\t\t}\n\t\tif (descriptor != null && isStaticMethod) {\n\t\t\t// Something on the stack when nothing is needed\n\t\t\tmv.visitInsn(POP);\n\t\t}\n\n\t\tif (CodeFlow.isPrimitive(descriptor)) {\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, descriptor.charAt(0));\n\t\t}\n\n\t\tString classDesc;\n\t\tif (Modifier.isPublic(method.getDeclaringClass().getModifiers())) {\n\t\t\tclassDesc = method.getDeclaringClass().getName().replace('.', '/');\n\t\t}\n\t\telse {\n\t\t\tClass<?> publicDeclaringClass = methodExecutor.getPublicDeclaringClass();\n\t\t\tAssert.state(publicDeclaringClass != null, \"No public declaring class\");\n\t\t\tclassDesc = publicDeclaringClass.getName().replace('.', '/');\n\t\t}\n\n\t\tif (!isStaticMethod && (descriptor == null || !descriptor.substring(1).equals(classDesc))) {\n\t\t\tCodeFlow.insertCheckCast(mv, \"L\" + classDesc);\n\t\t}\n\n\t\tgenerateCodeForArguments(mv, cf, method, this.children);\n\t\tmv.visitMethodInsn((isStaticMethod ? INVOKESTATIC : (method.isDefault() ? INVOKEINTERFACE : INVOKEVIRTUAL)),\n\t\t\t\tclassDesc, method.getName(), CodeFlow.createSignatureDescriptor(method),\n\t\t\t\tmethod.getDeclaringClass().isInterface());\n\t\tcf.pushDescriptor(this.exitTypeDescriptor);\n\n\t\tif (this.originalPrimitiveExitTypeDescriptor != null) {\n\t\t\t// The output of the accessor will be a primitive but from the block above it might be null,\n\t\t\t// so to have a 'common stack' element at skipIfNull target we need to box the primitive\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, this.originalPrimitiveExitTypeDescriptor);\n\t\t}\n\t\tif (skipIfNull != null) {\n\t\t\tmv.visitLabel(skipIfNull);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.ast.MethodReference#get()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 434
    },
    "return": "MethodExecutor",
    "signature": "public MethodExecutor get()",
    "source_code": "\t\tpublic MethodExecutor get() {\n\t\t\treturn this.methodExecutor;\n\t\t}"
  },
  "org.springframework.expression.spel.ast.MethodReference#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "\tpublic final String getName() {\n\t\treturn this.name;\n\t}"
  },
  "org.springframework.expression.spel.ast.MethodReference#getValue()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "TypedValue",
    "signature": "public TypedValue getValue()",
    "source_code": "\t\tpublic TypedValue getValue() {\n\t\t\tTypedValue result = MethodReference.this.getValueInternal(\n\t\t\t\t\tthis.evaluationContext, this.value, this.targetType, this.arguments);\n\t\t\tupdateExitTypeDescriptor();\n\t\t\treturn result;\n\t\t}"
  },
  "org.springframework.expression.spel.ast.MethodReference#getValueInternal(state)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "state"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "TypedValue",
    "signature": "public TypedValue getValueInternal(ExpressionState state)",
    "source_code": "\tpublic TypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\tEvaluationContext evaluationContext = state.getEvaluationContext();\n\t\tObject value = state.getActiveContextObject().getValue();\n\t\tTypeDescriptor targetType = state.getActiveContextObject().getTypeDescriptor();\n\t\tObject[] arguments = getArguments(state);\n\t\tTypedValue result = getValueInternal(evaluationContext, value, targetType, arguments);\n\t\tupdateExitTypeDescriptor();\n\t\treturn result;\n\t}"
  },
  "org.springframework.expression.spel.ast.MethodReference#getValueRef(state)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "state"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "ValueRef",
    "signature": "protected ValueRef getValueRef(ExpressionState state)",
    "source_code": "\tprotected ValueRef getValueRef(ExpressionState state) throws EvaluationException {\n\t\tObject[] arguments = getArguments(state);\n\t\tif (state.getActiveContextObject().getValue() == null) {\n\t\t\tthrowIfNotNullSafe(getArgumentTypes(arguments));\n\t\t\treturn ValueRef.NullValueRef.INSTANCE;\n\t\t}\n\t\treturn new MethodValueRef(state, arguments);\n\t}"
  },
  "org.springframework.expression.spel.ast.MethodReference#hasProxyTarget()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "boolean",
    "signature": "public boolean hasProxyTarget()",
    "source_code": "\t\tpublic boolean hasProxyTarget() {\n\t\t\treturn (this.target != null && Proxy.isProxyClass(this.target.getType()));\n\t\t}"
  },
  "org.springframework.expression.spel.ast.MethodReference#isCompilable()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A method reference is compilable if it has been resolved to a reflectively accessible method\n\t * and the child nodes (arguments to the method) are also compilable.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "boolean",
    "signature": "public boolean isCompilable()",
    "source_code": "\tpublic boolean isCompilable() {\n\t\tCachedMethodExecutor executorToCheck = this.cachedExecutor;\n\t\tif (executorToCheck == null || executorToCheck.hasProxyTarget() ||\n\t\t\t\t!(executorToCheck.get() instanceof ReflectiveMethodExecutor)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (SpelNodeImpl child : this.children) {\n\t\t\tif (!child.isCompilable()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tReflectiveMethodExecutor executor = (ReflectiveMethodExecutor) executorToCheck.get();\n\t\tif (executor.didArgumentConversionOccur()) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?> clazz = executor.getMethod().getDeclaringClass();\n\t\tif (!Modifier.isPublic(clazz.getModifiers()) && executor.getPublicDeclaringClass() == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}"
  },
  "org.springframework.expression.spel.ast.MethodReference#isSuitable(value,target,argumentTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "target",
      "argumentTypes"
    ],
    "position": {
      "column": 1,
      "line": 425
    },
    "return": "boolean",
    "signature": "public boolean isSuitable(Object value, @Nullable TypeDescriptor target, List<TypeDescriptor> argumentTypes)",
    "source_code": "\t\tpublic boolean isSuitable(Object value, @Nullable TypeDescriptor target, List<TypeDescriptor> argumentTypes) {\n\t\t\treturn ((this.staticClass == null || this.staticClass == value) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.target, target) && this.argumentTypes.equals(argumentTypes));\n\t\t}"
  },
  "org.springframework.expression.spel.ast.MethodReference#isWritable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "boolean",
    "signature": "public boolean isWritable()",
    "source_code": "\t\tpublic boolean isWritable() {\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.expression.spel.ast.MethodReference#setValue(newValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 393
    },
    "return": "void",
    "signature": "public void setValue(@Nullable Object newValue)",
    "source_code": "\t\tpublic void setValue(@Nullable Object newValue) {\n\t\t\tthrow new IllegalAccessError();\n\t\t}"
  },
  "org.springframework.expression.spel.ast.MethodReference#toStringAST()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "String",
    "signature": "public String toStringAST()",
    "source_code": "\tpublic String toStringAST() {\n\t\tStringJoiner sj = new StringJoiner(\",\", \"(\", \")\");\n\t\tfor (int i = 0; i < getChildCount(); i++) {\n\t\t\tsj.add(getChild(i).toStringAST());\n\t\t}\n\t\treturn this.name + sj.toString();\n\t}"
  },
  "org.springframework.expression.spel.ast.OperatorBetween": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Represents the between operator. The left operand to between must be a single value and\n * the right operand must be a list - this operator returns true if the left operand is\n * between (using the registered comparator) the two elements in the list. The definition\n * of between being inclusive follows the SQL BETWEEN definition.\n *\n * @author Andy Clement\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class OperatorBetween",
    "source_code": "public class OperatorBetween extends Operator {\n\n\tpublic OperatorBetween(int startPos, int endPos, SpelNodeImpl... operands) {\n\t\tsuper(\"between\", startPos, endPos, operands);\n\t}\n\n\n\t/**\n\t * Returns a boolean based on whether a value is in the range expressed. The first\n\t * operand is any value whilst the second is a list of two values - those two values\n\t * being the bounds allowed for the first operand (inclusive).\n\t * @param state the expression state\n\t * @return true if the left operand is in the range specified, false otherwise\n\t * @throws EvaluationException if there is a problem evaluating the expression\n\t */\n\t@Override\n\tpublic BooleanTypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\tObject left = getLeftOperand().getValueInternal(state).getValue();\n\t\tObject right = getRightOperand().getValueInternal(state).getValue();\n\t\tif (!(right instanceof List<?> list) || list.size() != 2) {\n\t\t\tthrow new SpelEvaluationException(getRightOperand().getStartPosition(),\n\t\t\t\t\tSpelMessage.BETWEEN_RIGHT_OPERAND_MUST_BE_TWO_ELEMENT_LIST);\n\t\t}\n\n\t\tObject low = list.get(0);\n\t\tObject high = list.get(1);\n\t\tTypeComparator comp = state.getTypeComparator();\n\t\ttry {\n\t\t\treturn BooleanTypedValue.forValue(comp.compare(left, low) >= 0 && comp.compare(left, high) <= 0);\n\t\t}\n\t\tcatch (SpelEvaluationException ex) {\n\t\t\tex.setPosition(getStartPosition());\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.expression.spel.ast.OperatorBetween#getValueInternal(state)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns a boolean based on whether a value is in the range expressed. The first\n\t * operand is any value whilst the second is a list of two values - those two values\n\t * being the bounds allowed for the first operand (inclusive).\n\t * @param state the expression state\n\t * @return true if the left operand is in the range specified, false otherwise\n\t * @throws EvaluationException if there is a problem evaluating the expression\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "state"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "BooleanTypedValue",
    "signature": "public BooleanTypedValue getValueInternal(ExpressionState state)",
    "source_code": "\tpublic BooleanTypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\tObject left = getLeftOperand().getValueInternal(state).getValue();\n\t\tObject right = getRightOperand().getValueInternal(state).getValue();\n\t\tif (!(right instanceof List<?> list) || list.size() != 2) {\n\t\t\tthrow new SpelEvaluationException(getRightOperand().getStartPosition(),\n\t\t\t\t\tSpelMessage.BETWEEN_RIGHT_OPERAND_MUST_BE_TWO_ELEMENT_LIST);\n\t\t}\n\n\t\tObject low = list.get(0);\n\t\tObject high = list.get(1);\n\t\tTypeComparator comp = state.getTypeComparator();\n\t\ttry {\n\t\t\treturn BooleanTypedValue.forValue(comp.compare(left, low) >= 0 && comp.compare(left, high) <= 0);\n\t\t}\n\t\tcatch (SpelEvaluationException ex) {\n\t\t\tex.setPosition(getStartPosition());\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.ast.OperatorInstanceof": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * The operator 'instanceof' checks if an object is of the class specified in the\n * right-hand operand, in the same way that {@code instanceof} does in Java.\n *\n * @author Andy Clement\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class OperatorInstanceof",
    "source_code": "public class OperatorInstanceof extends Operator {\n\n\t@Nullable\n\tprivate Class<?> type;\n\n\n\tpublic OperatorInstanceof(int startPos, int endPos, SpelNodeImpl... operands) {\n\t\tsuper(\"instanceof\", startPos, endPos, operands);\n\t}\n\n\n\t/**\n\t * Compare the left operand to see it is an instance of the type specified as the\n\t * right operand. The right operand must be a class.\n\t * @param state the expression state\n\t * @return {@code true} if the left operand is an instanceof of the right operand,\n\t * otherwise {@code false}\n\t * @throws EvaluationException if there is a problem evaluating the expression\n\t */\n\t@Override\n\tpublic BooleanTypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\tSpelNodeImpl rightOperand = getRightOperand();\n\t\tTypedValue left = getLeftOperand().getValueInternal(state);\n\t\tTypedValue right = rightOperand.getValueInternal(state);\n\t\tObject leftValue = left.getValue();\n\t\tObject rightValue = right.getValue();\n\t\tBooleanTypedValue result;\n\t\tif (!(rightValue instanceof Class<?> rightClass)) {\n\t\t\tthrow new SpelEvaluationException(getRightOperand().getStartPosition(),\n\t\t\t\t\tSpelMessage.INSTANCEOF_OPERATOR_NEEDS_CLASS_OPERAND,\n\t\t\t\t\t(rightValue == null ? \"null\" : rightValue.getClass().getName()));\n\t\t}\n\t\tif (leftValue == null) {\n\t\t\tresult = BooleanTypedValue.FALSE;  // null is not an instanceof anything\n\t\t}\n\t\telse {\n\t\t\tresult = BooleanTypedValue.forValue(rightClass.isAssignableFrom(leftValue.getClass()));\n\t\t}\n\t\tthis.type = rightClass;\n\t\tif (rightOperand instanceof TypeReference) {\n\t\t\t// Can only generate bytecode where the right operand is a direct type reference,\n\t\t\t// not if it is indirect (for example when right operand is a variable reference)\n\t\t\tthis.exitTypeDescriptor = \"Z\";\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean isCompilable() {\n\t\treturn (this.exitTypeDescriptor != null && getLeftOperand().isCompilable());\n\t}\n\n\t@Override\n\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tgetLeftOperand().generateCode(mv, cf);\n\t\tCodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor());\n\t\tAssert.state(this.type != null, \"No type available\");\n\t\tif (this.type.isPrimitive()) {\n\t\t\t// always false - but left operand code always driven\n\t\t\t// in case it had side effects\n\t\t\tmv.visitInsn(POP);\n\t\t\tmv.visitInsn(ICONST_0); // value of false\n\t\t}\n\t\telse {\n\t\t\tmv.visitTypeInsn(INSTANCEOF, Type.getInternalName(this.type));\n\t\t}\n\t\tcf.pushDescriptor(this.exitTypeDescriptor);\n\t}\n\n}"
  },
  "org.springframework.expression.spel.ast.OperatorInstanceof#generateCode(mv,cf)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void generateCode(MethodVisitor mv, CodeFlow cf)",
    "source_code": "\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tgetLeftOperand().generateCode(mv, cf);\n\t\tCodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor());\n\t\tAssert.state(this.type != null, \"No type available\");\n\t\tif (this.type.isPrimitive()) {\n\t\t\t// always false - but left operand code always driven\n\t\t\t// in case it had side effects\n\t\t\tmv.visitInsn(POP);\n\t\t\tmv.visitInsn(ICONST_0); // value of false\n\t\t}\n\t\telse {\n\t\t\tmv.visitTypeInsn(INSTANCEOF, Type.getInternalName(this.type));\n\t\t}\n\t\tcf.pushDescriptor(this.exitTypeDescriptor);\n\t}"
  },
  "org.springframework.expression.spel.ast.OperatorInstanceof#getValueInternal(state)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Compare the left operand to see it is an instance of the type specified as the\n\t * right operand. The right operand must be a class.\n\t * @param state the expression state\n\t * @return {@code true} if the left operand is an instanceof of the right operand,\n\t * otherwise {@code false}\n\t * @throws EvaluationException if there is a problem evaluating the expression\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "state"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "BooleanTypedValue",
    "signature": "public BooleanTypedValue getValueInternal(ExpressionState state)",
    "source_code": "\tpublic BooleanTypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\tSpelNodeImpl rightOperand = getRightOperand();\n\t\tTypedValue left = getLeftOperand().getValueInternal(state);\n\t\tTypedValue right = rightOperand.getValueInternal(state);\n\t\tObject leftValue = left.getValue();\n\t\tObject rightValue = right.getValue();\n\t\tBooleanTypedValue result;\n\t\tif (!(rightValue instanceof Class<?> rightClass)) {\n\t\t\tthrow new SpelEvaluationException(getRightOperand().getStartPosition(),\n\t\t\t\t\tSpelMessage.INSTANCEOF_OPERATOR_NEEDS_CLASS_OPERAND,\n\t\t\t\t\t(rightValue == null ? \"null\" : rightValue.getClass().getName()));\n\t\t}\n\t\tif (leftValue == null) {\n\t\t\tresult = BooleanTypedValue.FALSE;  // null is not an instanceof anything\n\t\t}\n\t\telse {\n\t\t\tresult = BooleanTypedValue.forValue(rightClass.isAssignableFrom(leftValue.getClass()));\n\t\t}\n\t\tthis.type = rightClass;\n\t\tif (rightOperand instanceof TypeReference) {\n\t\t\t// Can only generate bytecode where the right operand is a direct type reference,\n\t\t\t// not if it is indirect (for example when right operand is a variable reference)\n\t\t\tthis.exitTypeDescriptor = \"Z\";\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.expression.spel.ast.OperatorInstanceof#isCompilable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "boolean",
    "signature": "public boolean isCompilable()",
    "source_code": "\tpublic boolean isCompilable() {\n\t\treturn (this.exitTypeDescriptor != null && getLeftOperand().isCompilable());\n\t}"
  },
  "org.springframework.expression.spel.ast.Projection": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Represents projection, where a given operation is performed on all elements in some\n * input sequence, returning a new sequence of the same size. For example:\n * \"{1,2,3,4,5,6,7,8,9,10}.!{#isEven(#this)}\" returns \"[n, y, n, y, n, y, n, y, n, y]\"\n *\n * @author Andy Clement\n * @author Mark Fisher\n * @author Juergen Hoeller\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class Projection",
    "source_code": "public class Projection extends SpelNodeImpl {\n\n\tprivate final boolean nullSafe;\n\n\n\tpublic Projection(boolean nullSafe, int startPos, int endPos, SpelNodeImpl expression) {\n\t\tsuper(startPos, endPos, expression);\n\t\tthis.nullSafe = nullSafe;\n\t}\n\n\n\t@Override\n\tpublic TypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\treturn getValueRef(state).getValue();\n\t}\n\n\t@Override\n\tprotected ValueRef getValueRef(ExpressionState state) throws EvaluationException {\n\t\tTypedValue op = state.getActiveContextObject();\n\n\t\tObject operand = op.getValue();\n\t\tboolean operandIsArray = ObjectUtils.isArray(operand);\n\t\t// TypeDescriptor operandTypeDescriptor = op.getTypeDescriptor();\n\n\t\t// When the input is a map, we push a special context object on the stack\n\t\t// before calling the specified operation. This special context object\n\t\t// has two fields 'key' and 'value' that refer to the map entries key\n\t\t// and value, and they can be referenced in the operation\n\t\t// eg. {'a':'y','b':'n'}.![value=='y'?key:null]\" == ['a', null]\n\t\tif (operand instanceof Map<?, ?> mapData) {\n\t\t\tList<Object> result = new ArrayList<>();\n\t\t\tfor (Map.Entry<?, ?> entry : mapData.entrySet()) {\n\t\t\t\ttry {\n\t\t\t\t\tstate.pushActiveContextObject(new TypedValue(entry));\n\t\t\t\t\tstate.enterScope();\n\t\t\t\t\tresult.add(this.children[0].getValueInternal(state).getValue());\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tstate.popActiveContextObject();\n\t\t\t\t\tstate.exitScope();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new ValueRef.TypedValueHolderValueRef(new TypedValue(result), this);  // TODO unable to build correct type descriptor\n\t\t}\n\n\t\tif (operand instanceof Iterable || operandIsArray) {\n\t\t\tIterable<?> data = (operand instanceof Iterable<?> iterable ?\n\t\t\t\t\titerable : Arrays.asList(ObjectUtils.toObjectArray(operand)));\n\n\t\t\tList<Object> result = new ArrayList<>();\n\t\t\tClass<?> arrayElementType = null;\n\t\t\tfor (Object element : data) {\n\t\t\t\ttry {\n\t\t\t\t\tstate.pushActiveContextObject(new TypedValue(element));\n\t\t\t\t\tstate.enterScope(\"index\", result.size());\n\t\t\t\t\tObject value = this.children[0].getValueInternal(state).getValue();\n\t\t\t\t\tif (value != null && operandIsArray) {\n\t\t\t\t\t\tarrayElementType = determineCommonType(arrayElementType, value.getClass());\n\t\t\t\t\t}\n\t\t\t\t\tresult.add(value);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tstate.exitScope();\n\t\t\t\t\tstate.popActiveContextObject();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operandIsArray) {\n\t\t\t\tif (arrayElementType == null) {\n\t\t\t\t\tarrayElementType = Object.class;\n\t\t\t\t}\n\t\t\t\tObject resultArray = Array.newInstance(arrayElementType, result.size());\n\t\t\t\tSystem.arraycopy(result.toArray(), 0, resultArray, 0, result.size());\n\t\t\t\treturn new ValueRef.TypedValueHolderValueRef(new TypedValue(resultArray),this);\n\t\t\t}\n\n\t\t\treturn new ValueRef.TypedValueHolderValueRef(new TypedValue(result),this);\n\t\t}\n\n\t\tif (operand == null) {\n\t\t\tif (this.nullSafe) {\n\t\t\t\treturn ValueRef.NullValueRef.INSTANCE;\n\t\t\t}\n\t\t\tthrow new SpelEvaluationException(getStartPosition(), SpelMessage.PROJECTION_NOT_SUPPORTED_ON_TYPE, \"null\");\n\t\t}\n\n\t\tthrow new SpelEvaluationException(getStartPosition(), SpelMessage.PROJECTION_NOT_SUPPORTED_ON_TYPE,\n\t\t\t\toperand.getClass().getName());\n\t}\n\n\t@Override\n\tpublic String toStringAST() {\n\t\treturn \"![\" + getChild(0).toStringAST() + \"]\";\n\t}\n\n\tprivate Class<?> determineCommonType(@Nullable Class<?> oldType, Class<?> newType) {\n\t\tif (oldType == null) {\n\t\t\treturn newType;\n\t\t}\n\t\tif (oldType.isAssignableFrom(newType)) {\n\t\t\treturn oldType;\n\t\t}\n\t\tClass<?> nextType = newType;\n\t\twhile (nextType != Object.class) {\n\t\t\tif (nextType.isAssignableFrom(oldType)) {\n\t\t\t\treturn nextType;\n\t\t\t}\n\t\t\tnextType = nextType.getSuperclass();\n\t\t}\n\t\tfor (Class<?> nextInterface : ClassUtils.getAllInterfacesForClassAsSet(newType)) {\n\t\t\tif (nextInterface.isAssignableFrom(oldType)) {\n\t\t\t\treturn nextInterface;\n\t\t\t}\n\t\t}\n\t\treturn Object.class;\n\t}\n\n}"
  },
  "org.springframework.expression.spel.ast.Projection#getValueInternal(state)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "state"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "TypedValue",
    "signature": "public TypedValue getValueInternal(ExpressionState state)",
    "source_code": "\tpublic TypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\treturn getValueRef(state).getValue();\n\t}"
  },
  "org.springframework.expression.spel.ast.Projection#getValueRef(state)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "state"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "ValueRef",
    "signature": "protected ValueRef getValueRef(ExpressionState state)",
    "source_code": "\tprotected ValueRef getValueRef(ExpressionState state) throws EvaluationException {\n\t\tTypedValue op = state.getActiveContextObject();\n\n\t\tObject operand = op.getValue();\n\t\tboolean operandIsArray = ObjectUtils.isArray(operand);\n\t\t// TypeDescriptor operandTypeDescriptor = op.getTypeDescriptor();\n\n\t\t// When the input is a map, we push a special context object on the stack\n\t\t// before calling the specified operation. This special context object\n\t\t// has two fields 'key' and 'value' that refer to the map entries key\n\t\t// and value, and they can be referenced in the operation\n\t\t// eg. {'a':'y','b':'n'}.![value=='y'?key:null]\" == ['a', null]\n\t\tif (operand instanceof Map<?, ?> mapData) {\n\t\t\tList<Object> result = new ArrayList<>();\n\t\t\tfor (Map.Entry<?, ?> entry : mapData.entrySet()) {\n\t\t\t\ttry {\n\t\t\t\t\tstate.pushActiveContextObject(new TypedValue(entry));\n\t\t\t\t\tstate.enterScope();\n\t\t\t\t\tresult.add(this.children[0].getValueInternal(state).getValue());\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tstate.popActiveContextObject();\n\t\t\t\t\tstate.exitScope();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new ValueRef.TypedValueHolderValueRef(new TypedValue(result), this);  // TODO unable to build correct type descriptor\n\t\t}\n\n\t\tif (operand instanceof Iterable || operandIsArray) {\n\t\t\tIterable<?> data = (operand instanceof Iterable<?> iterable ?\n\t\t\t\t\titerable : Arrays.asList(ObjectUtils.toObjectArray(operand)));\n\n\t\t\tList<Object> result = new ArrayList<>();\n\t\t\tClass<?> arrayElementType = null;\n\t\t\tfor (Object element : data) {\n\t\t\t\ttry {\n\t\t\t\t\tstate.pushActiveContextObject(new TypedValue(element));\n\t\t\t\t\tstate.enterScope(\"index\", result.size());\n\t\t\t\t\tObject value = this.children[0].getValueInternal(state).getValue();\n\t\t\t\t\tif (value != null && operandIsArray) {\n\t\t\t\t\t\tarrayElementType = determineCommonType(arrayElementType, value.getClass());\n\t\t\t\t\t}\n\t\t\t\t\tresult.add(value);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tstate.exitScope();\n\t\t\t\t\tstate.popActiveContextObject();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (operandIsArray) {\n\t\t\t\tif (arrayElementType == null) {\n\t\t\t\t\tarrayElementType = Object.class;\n\t\t\t\t}\n\t\t\t\tObject resultArray = Array.newInstance(arrayElementType, result.size());\n\t\t\t\tSystem.arraycopy(result.toArray(), 0, resultArray, 0, result.size());\n\t\t\t\treturn new ValueRef.TypedValueHolderValueRef(new TypedValue(resultArray),this);\n\t\t\t}\n\n\t\t\treturn new ValueRef.TypedValueHolderValueRef(new TypedValue(result),this);\n\t\t}\n\n\t\tif (operand == null) {\n\t\t\tif (this.nullSafe) {\n\t\t\t\treturn ValueRef.NullValueRef.INSTANCE;\n\t\t\t}\n\t\t\tthrow new SpelEvaluationException(getStartPosition(), SpelMessage.PROJECTION_NOT_SUPPORTED_ON_TYPE, \"null\");\n\t\t}\n\n\t\tthrow new SpelEvaluationException(getStartPosition(), SpelMessage.PROJECTION_NOT_SUPPORTED_ON_TYPE,\n\t\t\t\toperand.getClass().getName());\n\t}"
  },
  "org.springframework.expression.spel.ast.Projection#toStringAST()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "String",
    "signature": "public String toStringAST()",
    "source_code": "\tpublic String toStringAST() {\n\t\treturn \"![\" + getChild(0).toStringAST() + \"]\";\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * The common supertype of all AST nodes in a parsed Spring Expression Language\n * format expression.\n *\n * @author Andy Clement\n * @author Juergen Hoeller\n * @since 3.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public class SpelNodeImpl",
    "source_code": "public abstract class SpelNodeImpl implements SpelNode, Opcodes {\n\n\tprivate static final SpelNodeImpl[] NO_CHILDREN = new SpelNodeImpl[0];\n\n\n\tprivate final int startPos;\n\n\tprivate final int endPos;\n\n\tprotected SpelNodeImpl[] children = SpelNodeImpl.NO_CHILDREN;\n\n\t@Nullable\n\tprivate SpelNodeImpl parent;\n\n\t/**\n\t * Indicates the type descriptor for the result of this expression node.\n\t * This is set as soon as it is known. For a literal node it is known immediately.\n\t * For a property access or method invocation it is known after one evaluation of\n\t * that node.\n\t * <p>The descriptor is like the bytecode form but is slightly easier to work with.\n\t * It does not include the trailing semicolon (for non array reference types).\n\t * Some examples: Ljava/lang/String, I, [I\n     */\n\t@Nullable\n\tprotected volatile String exitTypeDescriptor;\n\n\n\tpublic SpelNodeImpl(int startPos, int endPos, SpelNodeImpl... operands) {\n\t\tthis.startPos = startPos;\n\t\tthis.endPos = endPos;\n\t\tif (!ObjectUtils.isEmpty(operands)) {\n\t\t\tthis.children = operands;\n\t\t\tfor (SpelNodeImpl operand : operands) {\n\t\t\t\tAssert.notNull(operand, \"Operand must not be null\");\n\t\t\t\toperand.parent = this;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n     * Return {@code true} if the next child is one of the specified classes.\n     */\n\tprotected boolean nextChildIs(Class<?>... classes) {\n\t\tif (this.parent != null) {\n\t\t\tSpelNodeImpl[] peers = this.parent.children;\n\t\t\tfor (int i = 0, max = peers.length; i < max; i++) {\n\t\t\t\tif (this == peers[i]) {\n\t\t\t\t\tif (i + 1 >= max) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tClass<?> peerClass = peers[i + 1].getClass();\n\t\t\t\t\tfor (Class<?> desiredClass : classes) {\n\t\t\t\t\t\tif (peerClass == desiredClass) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic final Object getValue(ExpressionState expressionState) throws EvaluationException {\n\t\treturn getValueInternal(expressionState).getValue();\n\t}\n\n\t@Override\n\tpublic final TypedValue getTypedValue(ExpressionState expressionState) throws EvaluationException {\n\t\treturn getValueInternal(expressionState);\n\t}\n\n\t// by default Ast nodes are not writable\n\t@Override\n\tpublic boolean isWritable(ExpressionState expressionState) throws EvaluationException {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void setValue(ExpressionState expressionState, @Nullable Object newValue) throws EvaluationException {\n\t\tthrow new SpelEvaluationException(getStartPosition(), SpelMessage.SETVALUE_NOT_SUPPORTED, getClass());\n\t}\n\n\t@Override\n\tpublic SpelNode getChild(int index) {\n\t\treturn this.children[index];\n\t}\n\n\t@Override\n\tpublic int getChildCount() {\n\t\treturn this.children.length;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Class<?> getObjectClass(@Nullable Object obj) {\n\t\tif (obj == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn (obj instanceof Class<?> clazz ? clazz : obj.getClass());\n\t}\n\n\t@Override\n\tpublic int getStartPosition() {\n\t\treturn this.startPos;\n\t}\n\n\t@Override\n\tpublic int getEndPosition() {\n\t\treturn this.endPos;\n\t}\n\n\t/**\n\t * Check whether a node can be compiled to bytecode. The reasoning in each node may\n\t * be different but will typically involve checking whether the exit type descriptor\n\t * of the node is known and any relevant child nodes are compilable.\n\t * @return {@code true} if this node can be compiled to bytecode\n\t */\n\tpublic boolean isCompilable() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Generate the bytecode for this node into the supplied visitor. Context info about\n\t * the current expression being compiled is available in the codeflow object, e.g.\n\t * including information about the type of the object currently on the stack.\n\t * @param mv the ASM MethodVisitor into which code should be generated\n\t * @param cf a context object with info about what is on the stack\n\t */\n\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tthrow new IllegalStateException(getClass().getName() +\" has no generateCode(..) method\");\n\t}\n\n\t@Nullable\n\tpublic String getExitDescriptor() {\n\t\treturn this.exitTypeDescriptor;\n\t}\n\n\t@Nullable\n\tprotected final <T> T getValue(ExpressionState state, Class<T> desiredReturnType) throws EvaluationException {\n\t\treturn ExpressionUtils.convertTypedValue(state.getEvaluationContext(), getValueInternal(state), desiredReturnType);\n\t}\n\n\tprotected ValueRef getValueRef(ExpressionState state) throws EvaluationException {\n\t\tthrow new SpelEvaluationException(getStartPosition(), SpelMessage.NOT_ASSIGNABLE, toStringAST());\n\t}\n\n\tpublic abstract TypedValue getValueInternal(ExpressionState expressionState) throws EvaluationException;\n\n\n\t/**\n\t * Generate code that handles building the argument values for the specified method.\n\t * This method will take account of whether the invoked method is a varargs method\n\t * and if it is then the argument values will be appropriately packaged into an array.\n\t * @param mv the method visitor where code should be generated\n\t * @param cf the current codeflow\n\t * @param member the method or constructor for which arguments are being setup\n\t * @param arguments the expression nodes for the expression supplied argument values\n\t */\n\tprotected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {\n\t\tString[] paramDescriptors = null;\n\t\tboolean isVarargs = false;\n\t\tif (member instanceof Constructor<?> ctor) {\n\t\t\tparamDescriptors = CodeFlow.toDescriptors(ctor.getParameterTypes());\n\t\t\tisVarargs = ctor.isVarArgs();\n\t\t}\n\t\telse { // Method\n\t\t\tMethod method = (Method)member;\n\t\t\tparamDescriptors = CodeFlow.toDescriptors(method.getParameterTypes());\n\t\t\tisVarargs = method.isVarArgs();\n\t\t}\n\t\tif (isVarargs) {\n\t\t\t// The final parameter may or may not need packaging into an array, or nothing may\n\t\t\t// have been passed to satisfy the varargs and so something needs to be built.\n\t\t\tint p = 0; // Current supplied argument being processed\n\t\t\tint childCount = arguments.length;\n\n\t\t\t// Fulfill all the parameter requirements except the last one\n\t\t\tfor (p = 0; p < paramDescriptors.length - 1; p++) {\n\t\t\t\tgenerateCodeForArgument(mv, cf, arguments[p], paramDescriptors[p]);\n\t\t\t}\n\n\t\t\tSpelNodeImpl lastChild = (childCount == 0 ? null : arguments[childCount - 1]);\n\t\t\tString arrayType = paramDescriptors[paramDescriptors.length - 1];\n\t\t\t// Determine if the final passed argument is already suitably packaged in array\n\t\t\t// form to be passed to the method\n\t\t\tif (lastChild != null && arrayType.equals(lastChild.getExitDescriptor())) {\n\t\t\t\tgenerateCodeForArgument(mv, cf, lastChild, paramDescriptors[p]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tarrayType = arrayType.substring(1); // trim the leading '[', may leave other '['\n\t\t\t\t// build array big enough to hold remaining arguments\n\t\t\t\tCodeFlow.insertNewArrayCode(mv, childCount - p, arrayType);\n\t\t\t\t// Package up the remaining arguments into the array\n\t\t\t\tint arrayindex = 0;\n\t\t\t\twhile (p < childCount) {\n\t\t\t\t\tSpelNodeImpl child = arguments[p];\n\t\t\t\t\tmv.visitInsn(DUP);\n\t\t\t\t\tCodeFlow.insertOptimalLoad(mv, arrayindex++);\n\t\t\t\t\tgenerateCodeForArgument(mv, cf, child, arrayType);\n\t\t\t\t\tCodeFlow.insertArrayStore(mv, arrayType);\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < paramDescriptors.length;i++) {\n\t\t\t\tgenerateCodeForArgument(mv, cf, arguments[i], paramDescriptors[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Ask an argument to generate its bytecode and then follow it up\n\t * with any boxing/unboxing/checkcasting to ensure it matches the expected parameter descriptor.\n\t */\n\tprotected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc) {\n\t\tcf.enterCompilationScope();\n\t\targument.generateCode(mv, cf);\n\t\tString lastDesc = cf.lastDescriptor();\n\t\tAssert.state(lastDesc != null, \"No last descriptor\");\n\t\tboolean primitiveOnStack = CodeFlow.isPrimitive(lastDesc);\n\t\t// Check if need to box it for the method reference?\n\t\tif (primitiveOnStack && paramDesc.charAt(0) == 'L') {\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, lastDesc.charAt(0));\n\t\t}\n\t\telse if (paramDesc.length() == 1 && !primitiveOnStack) {\n\t\t\tCodeFlow.insertUnboxInsns(mv, paramDesc.charAt(0), lastDesc);\n\t\t}\n\t\telse if (!paramDesc.equals(lastDesc)) {\n\t\t\t// This would be unnecessary in the case of subtyping (e.g. method takes Number but Integer passed in)\n\t\t\tCodeFlow.insertCheckCast(mv, paramDesc);\n\t\t}\n\t\tcf.exitCompilationScope();\n\t}\n\n}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#generateCode(mv,cf)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate the bytecode for this node into the supplied visitor. Context info about\n\t * the current expression being compiled is available in the codeflow object, e.g.\n\t * including information about the type of the object currently on the stack.\n\t * @param mv the ASM MethodVisitor into which code should be generated\n\t * @param cf a context object with info about what is on the stack\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "void",
    "signature": "public void generateCode(MethodVisitor mv, CodeFlow cf)",
    "source_code": "\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tthrow new IllegalStateException(getClass().getName() +\" has no generateCode(..) method\");\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#generateCodeForArgument(mv,cf,argument,paramDesc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Ask an argument to generate its bytecode and then follow it up\n\t * with any boxing/unboxing/checkcasting to ensure it matches the expected parameter descriptor.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "cf",
      "argument",
      "paramDesc"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "void",
    "signature": "protected void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc)",
    "source_code": "\tprotected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc) {\n\t\tcf.enterCompilationScope();\n\t\targument.generateCode(mv, cf);\n\t\tString lastDesc = cf.lastDescriptor();\n\t\tAssert.state(lastDesc != null, \"No last descriptor\");\n\t\tboolean primitiveOnStack = CodeFlow.isPrimitive(lastDesc);\n\t\t// Check if need to box it for the method reference?\n\t\tif (primitiveOnStack && paramDesc.charAt(0) == 'L') {\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, lastDesc.charAt(0));\n\t\t}\n\t\telse if (paramDesc.length() == 1 && !primitiveOnStack) {\n\t\t\tCodeFlow.insertUnboxInsns(mv, paramDesc.charAt(0), lastDesc);\n\t\t}\n\t\telse if (!paramDesc.equals(lastDesc)) {\n\t\t\t// This would be unnecessary in the case of subtyping (e.g. method takes Number but Integer passed in)\n\t\t\tCodeFlow.insertCheckCast(mv, paramDesc);\n\t\t}\n\t\tcf.exitCompilationScope();\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#generateCodeForArguments(mv,cf,member,arguments)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate code that handles building the argument values for the specified method.\n\t * This method will take account of whether the invoked method is a varargs method\n\t * and if it is then the argument values will be appropriately packaged into an array.\n\t * @param mv the method visitor where code should be generated\n\t * @param cf the current codeflow\n\t * @param member the method or constructor for which arguments are being setup\n\t * @param arguments the expression nodes for the expression supplied argument values\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "cf",
      "member",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "protected void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments)",
    "source_code": "\tprotected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {\n\t\tString[] paramDescriptors = null;\n\t\tboolean isVarargs = false;\n\t\tif (member instanceof Constructor<?> ctor) {\n\t\t\tparamDescriptors = CodeFlow.toDescriptors(ctor.getParameterTypes());\n\t\t\tisVarargs = ctor.isVarArgs();\n\t\t}\n\t\telse { // Method\n\t\t\tMethod method = (Method)member;\n\t\t\tparamDescriptors = CodeFlow.toDescriptors(method.getParameterTypes());\n\t\t\tisVarargs = method.isVarArgs();\n\t\t}\n\t\tif (isVarargs) {\n\t\t\t// The final parameter may or may not need packaging into an array, or nothing may\n\t\t\t// have been passed to satisfy the varargs and so something needs to be built.\n\t\t\tint p = 0; // Current supplied argument being processed\n\t\t\tint childCount = arguments.length;\n\n\t\t\t// Fulfill all the parameter requirements except the last one\n\t\t\tfor (p = 0; p < paramDescriptors.length - 1; p++) {\n\t\t\t\tgenerateCodeForArgument(mv, cf, arguments[p], paramDescriptors[p]);\n\t\t\t}\n\n\t\t\tSpelNodeImpl lastChild = (childCount == 0 ? null : arguments[childCount - 1]);\n\t\t\tString arrayType = paramDescriptors[paramDescriptors.length - 1];\n\t\t\t// Determine if the final passed argument is already suitably packaged in array\n\t\t\t// form to be passed to the method\n\t\t\tif (lastChild != null && arrayType.equals(lastChild.getExitDescriptor())) {\n\t\t\t\tgenerateCodeForArgument(mv, cf, lastChild, paramDescriptors[p]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tarrayType = arrayType.substring(1); // trim the leading '[', may leave other '['\n\t\t\t\t// build array big enough to hold remaining arguments\n\t\t\t\tCodeFlow.insertNewArrayCode(mv, childCount - p, arrayType);\n\t\t\t\t// Package up the remaining arguments into the array\n\t\t\t\tint arrayindex = 0;\n\t\t\t\twhile (p < childCount) {\n\t\t\t\t\tSpelNodeImpl child = arguments[p];\n\t\t\t\t\tmv.visitInsn(DUP);\n\t\t\t\t\tCodeFlow.insertOptimalLoad(mv, arrayindex++);\n\t\t\t\t\tgenerateCodeForArgument(mv, cf, child, arrayType);\n\t\t\t\t\tCodeFlow.insertArrayStore(mv, arrayType);\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < paramDescriptors.length;i++) {\n\t\t\t\tgenerateCodeForArgument(mv, cf, arguments[i], paramDescriptors[i]);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#getChild(index)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "SpelNode",
    "signature": "public SpelNode getChild(int index)",
    "source_code": "\tpublic SpelNode getChild(int index) {\n\t\treturn this.children[index];\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#getChildCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "int",
    "signature": "public int getChildCount()",
    "source_code": "\tpublic int getChildCount() {\n\t\treturn this.children.length;\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#getEndPosition()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "int",
    "signature": "public int getEndPosition()",
    "source_code": "\tpublic int getEndPosition() {\n\t\treturn this.endPos;\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#getExitDescriptor()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "String",
    "signature": "public String getExitDescriptor()",
    "source_code": "\tpublic String getExitDescriptor() {\n\t\treturn this.exitTypeDescriptor;\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#getStartPosition()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "int",
    "signature": "public int getStartPosition()",
    "source_code": "\tpublic int getStartPosition() {\n\t\treturn this.startPos;\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#getTypedValue(expressionState)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expressionState"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "TypedValue",
    "signature": "public TypedValue getTypedValue(ExpressionState expressionState)",
    "source_code": "\tpublic final TypedValue getTypedValue(ExpressionState expressionState) throws EvaluationException {\n\t\treturn getValueInternal(expressionState);\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#getValue(expressionState)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expressionState"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "Object",
    "signature": "public Object getValue(ExpressionState expressionState)",
    "source_code": "\tpublic final Object getValue(ExpressionState expressionState) throws EvaluationException {\n\t\treturn getValueInternal(expressionState).getValue();\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#getValue(state,desiredReturnType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "state",
      "desiredReturnType"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "T",
    "signature": "protected T getValue(ExpressionState state, Class<T> desiredReturnType)",
    "source_code": "\tprotected final <T> T getValue(ExpressionState state, Class<T> desiredReturnType) throws EvaluationException {\n\t\treturn ExpressionUtils.convertTypedValue(state.getEvaluationContext(), getValueInternal(state), desiredReturnType);\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#getValueInternal(expressionState)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expressionState"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "TypedValue",
    "signature": "public TypedValue getValueInternal(ExpressionState expressionState)",
    "source_code": "\tpublic abstract TypedValue getValueInternal(ExpressionState expressionState) throws EvaluationException;"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#getValueRef(state)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "state"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "ValueRef",
    "signature": "protected ValueRef getValueRef(ExpressionState state)",
    "source_code": "\tprotected ValueRef getValueRef(ExpressionState state) throws EvaluationException {\n\t\tthrow new SpelEvaluationException(getStartPosition(), SpelMessage.NOT_ASSIGNABLE, toStringAST());\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#isCompilable()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether a node can be compiled to bytecode. The reasoning in each node may\n\t * be different but will typically involve checking whether the exit type descriptor\n\t * of the node is known and any relevant child nodes are compilable.\n\t * @return {@code true} if this node can be compiled to bytecode\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "boolean",
    "signature": "public boolean isCompilable()",
    "source_code": "\tpublic boolean isCompilable() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#isWritable(expressionState)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expressionState"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "boolean",
    "signature": "public boolean isWritable(ExpressionState expressionState)",
    "source_code": "\tpublic boolean isWritable(ExpressionState expressionState) throws EvaluationException {\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#nextChildIs(classes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n     * Return {@code true} if the next child is one of the specified classes.\n     */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "classes"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "boolean",
    "signature": "protected boolean nextChildIs(Class<?>... classes)",
    "source_code": "\tprotected boolean nextChildIs(Class<?>... classes) {\n\t\tif (this.parent != null) {\n\t\t\tSpelNodeImpl[] peers = this.parent.children;\n\t\t\tfor (int i = 0, max = peers.length; i < max; i++) {\n\t\t\t\tif (this == peers[i]) {\n\t\t\t\t\tif (i + 1 >= max) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tClass<?> peerClass = peers[i + 1].getClass();\n\t\t\t\t\tfor (Class<?> desiredClass : classes) {\n\t\t\t\t\t\tif (peerClass == desiredClass) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.ast.SpelNodeImpl#setValue(expressionState,newValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expressionState",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void setValue(ExpressionState expressionState, @Nullable Object newValue)",
    "source_code": "\tpublic void setValue(ExpressionState expressionState, @Nullable Object newValue) throws EvaluationException {\n\t\tthrow new SpelEvaluationException(getStartPosition(), SpelMessage.SETVALUE_NOT_SUPPORTED, getClass());\n\t}"
  },
  "org.springframework.expression.spel.ast.children": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "signature": "protected SpelNodeImpl[] children",
    "source_code": "\tprotected SpelNodeImpl[] children = SpelNodeImpl.NO_CHILDREN;",
    "type": "SpelNodeImpl[]"
  },
  "org.springframework.expression.spel.ast.exitTypeDescriptor": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicates the type descriptor for the result of this expression node.\n\t * This is set as soon as it is known. For a literal node it is known immediately.\n\t * For a property access or method invocation it is known after one evaluation of\n\t * that node.\n\t * <p>The descriptor is like the bytecode form but is slightly easier to work with.\n\t * It does not include the trailing semicolon (for non array reference types).\n\t * Some examples: Ljava/lang/String, I, [I\n     */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "signature": "protected String exitTypeDescriptor",
    "source_code": "\tprotected volatile String exitTypeDescriptor;",
    "type": "String"
  },
  "org.springframework.expression.spel.standard.SpelCompiler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A SpelCompiler will take a regular parsed expression and create (and load) a class\n * containing byte code that does the same thing as that expression. The compiled form of\n * an expression will evaluate far faster than the interpreted form.\n *\n * <p>The SpelCompiler is not currently handling all expression types but covers many of\n * the common cases. The framework is extensible to cover more cases in the future. For\n * absolute maximum speed there is *no checking* in the compiled code. The compiled\n * version of the expression uses information learned during interpreted runs of the\n * expression when it generates the byte code. For example if it knows that a particular\n * property dereference always seems to return a Map then it will generate byte code that\n * expects the result of the property dereference to be a Map. This ensures maximal\n * performance but should the dereference result in something other than a map, the\n * compiled expression will fail - like a ClassCastException would occur if passing data\n * of an unexpected type in a regular Java program.\n *\n * <p>Due to the lack of checking there are likely some expressions that should never be\n * compiled, for example if an expression is continuously dealing with different types of\n * data. Due to these cases the compiler is something that must be selectively turned on\n * for an associated SpelExpressionParser (through the {@link SpelParserConfiguration}\n * object), it is not on by default.\n *\n * <p>Individual expressions can be compiled by calling {@code SpelCompiler.compile(expression)}.\n *\n * @author Andy Clement\n * @author Juergen Hoeller\n * @since 4.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "signature": "public class SpelCompiler",
    "source_code": "public final class SpelCompiler implements Opcodes {\n\n\tprivate static final int CLASSES_DEFINED_LIMIT = 100;\n\n\tprivate static final Log logger = LogFactory.getLog(SpelCompiler.class);\n\n\t// A compiler is created for each classloader, it manages a child class loader of that\n\t// classloader and the child is used to load the compiled expressions.\n\tprivate static final Map<ClassLoader, SpelCompiler> compilers = new ConcurrentReferenceHashMap<>();\n\n\n\t// The child ClassLoader used to load the compiled expression classes\n\tprivate volatile ChildClassLoader childClassLoader;\n\n\t// Counter suffix for generated classes within this SpelCompiler instance\n\tprivate final AtomicInteger suffixId = new AtomicInteger(1);\n\n\n\tprivate SpelCompiler(@Nullable ClassLoader classloader) {\n\t\tthis.childClassLoader = new ChildClassLoader(classloader);\n\t}\n\n\n\t/**\n\t * Attempt compilation of the supplied expression. A check is made to see\n\t * if it is compilable before compilation proceeds. The check involves\n\t * visiting all the nodes in the expression AST and ensuring enough state\n\t * is known about them that bytecode can be generated for them.\n\t * @param expression the expression to compile\n\t * @return an instance of the class implementing the compiled expression,\n\t * or {@code null} if compilation is not possible\n\t */\n\t@Nullable\n\tpublic CompiledExpression compile(SpelNodeImpl expression) {\n\t\tif (expression.isCompilable()) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"SpEL: compiling \" + expression.toStringAST());\n\t\t\t}\n\t\t\tClass<? extends CompiledExpression> clazz = createExpressionClass(expression);\n\t\t\tif (clazz != null) {\n\t\t\t\ttry {\n\t\t\t\t\treturn ReflectionUtils.accessibleConstructor(clazz).newInstance();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new IllegalStateException(\"Failed to instantiate CompiledExpression for expression: \" +\n\t\t\t\t\t\t\texpression.toStringAST(), ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"SpEL: unable to compile \" + expression.toStringAST());\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate int getNextSuffix() {\n\t\treturn this.suffixId.incrementAndGet();\n\t}\n\n\t/**\n\t * Generate the class that encapsulates the compiled expression and define it.\n\t * The generated class will be a subtype of CompiledExpression.\n\t * @param expressionToCompile the expression to be compiled\n\t * @return the expression call, or {@code null} if the decision was to opt out of\n\t * compilation during code generation\n\t */\n\t@Nullable\n\tprivate Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {\n\t\t// Create class outline 'spel/ExNNN extends org.springframework.expression.spel.CompiledExpression'\n\t\tString className = \"spel/Ex\" + getNextSuffix();\n\t\tString evaluationContextClass = \"org/springframework/expression/EvaluationContext\";\n\t\tClassWriter cw = new ExpressionClassWriter();\n\t\tcw.visit(V1_8, ACC_PUBLIC, className, null, \"org/springframework/expression/spel/CompiledExpression\", null);\n\n\t\t// Create default constructor\n\t\tMethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n\t\tmv.visitCode();\n\t\tmv.visitVarInsn(ALOAD, 0);\n\t\tmv.visitMethodInsn(INVOKESPECIAL, \"org/springframework/expression/spel/CompiledExpression\",\n\t\t\t\t\"<init>\", \"()V\", false);\n\t\tmv.visitInsn(RETURN);\n\t\tmv.visitMaxs(1, 1);\n\t\tmv.visitEnd();\n\n\t\t// Create getValue() method\n\t\tmv = cw.visitMethod(ACC_PUBLIC, \"getValue\",\n\t\t\t\t\"(Ljava/lang/Object;L\" + evaluationContextClass + \";)Ljava/lang/Object;\", null,\n\t\t\t\tnew String[] {\"org/springframework/expression/EvaluationException\"});\n\t\tmv.visitCode();\n\n\t\tCodeFlow cf = new CodeFlow(className, cw);\n\n\t\t// Ask the expression AST to generate the body of the method\n\t\ttry {\n\t\t\texpressionToCompile.generateCode(mv, cf);\n\t\t}\n\t\tcatch (IllegalStateException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(expressionToCompile.getClass().getSimpleName() +\n\t\t\t\t\t\t\".generateCode opted out of compilation: \" + ex.getMessage());\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tCodeFlow.insertBoxIfNecessary(mv, cf.lastDescriptor());\n\t\tif (\"V\".equals(cf.lastDescriptor())) {\n\t\t\tmv.visitInsn(ACONST_NULL);\n\t\t}\n\t\tmv.visitInsn(ARETURN);\n\n\t\tmv.visitMaxs(0, 0);  // not supplied due to COMPUTE_MAXS\n\t\tmv.visitEnd();\n\t\tcw.visitEnd();\n\n\t\tcf.finish();\n\n\t\tbyte[] data = cw.toByteArray();\n\t\t// TODO need to make this conditionally occur based on a debug flag\n\t\t// dump(expressionToCompile.toStringAST(), clazzName, data);\n\t\treturn loadClass(StringUtils.replace(className, \"/\", \".\"), data);\n\t}\n\n\t/**\n\t * Load a compiled expression class. Makes sure the classloaders aren't used too much\n\t * because they anchor compiled classes in memory and prevent GC. If you have expressions\n\t * continually recompiling over time then by replacing the classloader periodically\n\t * at least some of the older variants can be garbage collected.\n\t * @param name the name of the class\n\t * @param bytes the bytecode for the class\n\t * @return the Class object for the compiled expression\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprivate Class<? extends CompiledExpression> loadClass(String name, byte[] bytes) {\n\t\tChildClassLoader ccl = this.childClassLoader;\n\t\tif (ccl.getClassesDefinedCount() >= CLASSES_DEFINED_LIMIT) {\n\t\t\tsynchronized (this) {\n\t\t\t\tChildClassLoader currentCcl = this.childClassLoader;\n\t\t\t\tif (ccl == currentCcl) {\n\t\t\t\t\t// Still the same ClassLoader that needs to be replaced...\n\t\t\t\t\tccl = new ChildClassLoader(ccl.getParent());\n\t\t\t\t\tthis.childClassLoader = ccl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Already replaced by some other thread, let's pick it up.\n\t\t\t\t\tccl = currentCcl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (Class<? extends CompiledExpression>) ccl.defineClass(name, bytes);\n\t}\n\n\n\t/**\n\t * Factory method for compiler instances. The returned SpelCompiler will\n\t * attach a class loader as the child of the given class loader and this\n\t * child will be used to load compiled expressions.\n\t * @param classLoader the ClassLoader to use as the basis for compilation\n\t * @return a corresponding SpelCompiler instance\n\t */\n\tpublic static SpelCompiler getCompiler(@Nullable ClassLoader classLoader) {\n\t\tClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());\n\t\t// Quick check for existing compiler without lock contention\n\t\tSpelCompiler compiler = compilers.get(clToUse);\n\t\tif (compiler == null) {\n\t\t\t// Full lock now since we're creating a child ClassLoader\n\t\t\tsynchronized (compilers) {\n\t\t\t\tcompiler = compilers.get(clToUse);\n\t\t\t\tif (compiler == null) {\n\t\t\t\t\tcompiler = new SpelCompiler(clToUse);\n\t\t\t\t\tcompilers.put(clToUse, compiler);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn compiler;\n\t}\n\n\t/**\n\t * Request that an attempt is made to compile the specified expression.\n\t * It may fail if components of the expression are not suitable for compilation\n\t * or the data types involved are not suitable for compilation. Used for testing.\n\t * @param expression the expression to compile\n\t * @return {@code true} if the expression was successfully compiled,\n\t * {@code false} otherwise\n\t */\n\tpublic static boolean compile(Expression expression) {\n\t\treturn (expression instanceof SpelExpression spelExpression && spelExpression.compileExpression());\n\t}\n\n\t/**\n\t * Request to revert to the interpreter for expression evaluation.\n\t * Any compiled form is discarded but can be recreated by later recompiling again.\n\t * @param expression the expression\n\t */\n\tpublic static void revertToInterpreted(Expression expression) {\n\t\tif (expression instanceof SpelExpression spelExpression) {\n\t\t\tspelExpression.revertToInterpreted();\n\t\t}\n\t}\n\n\n\t/**\n\t * A ChildClassLoader will load the generated compiled expression classes.\n\t */\n\tprivate static class ChildClassLoader extends URLClassLoader {\n\n\t\tprivate static final URL[] NO_URLS = new URL[0];\n\n\t\tprivate final AtomicInteger classesDefinedCount = new AtomicInteger();\n\n\t\tpublic ChildClassLoader(@Nullable ClassLoader classLoader) {\n\t\t\tsuper(NO_URLS, classLoader);\n\t\t}\n\n\t\tpublic Class<?> defineClass(String name, byte[] bytes) {\n\t\t\tClass<?> clazz = super.defineClass(name, bytes, 0, bytes.length);\n\t\t\tthis.classesDefinedCount.incrementAndGet();\n\t\t\treturn clazz;\n\t\t}\n\n\t\tpublic int getClassesDefinedCount() {\n\t\t\treturn this.classesDefinedCount.get();\n\t\t}\n\t}\n\n\n\t/**\n\t * An ASM ClassWriter extension bound to the SpelCompiler's ClassLoader.\n\t */\n\tprivate class ExpressionClassWriter extends ClassWriter {\n\n\t\tpublic ExpressionClassWriter() {\n\t\t\tsuper(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);\n\t\t}\n\n\t\t@Override\n\t\tprotected ClassLoader getClassLoader() {\n\t\t\treturn childClassLoader;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.expression.spel.standard.SpelCompiler#compile(expression)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Request that an attempt is made to compile the specified expression.\n\t * It may fail if components of the expression are not suitable for compilation\n\t * or the data types involved are not suitable for compilation. Used for testing.\n\t * @param expression the expression to compile\n\t * @return {@code true} if the expression was successfully compiled,\n\t * {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "boolean",
    "signature": "public boolean compile(Expression expression)",
    "source_code": "\tpublic static boolean compile(Expression expression) {\n\t\treturn (expression instanceof SpelExpression spelExpression && spelExpression.compileExpression());\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelCompiler#getClassLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "ClassLoader",
    "signature": "protected ClassLoader getClassLoader()",
    "source_code": "\t\tprotected ClassLoader getClassLoader() {\n\t\t\treturn childClassLoader;\n\t\t}"
  },
  "org.springframework.expression.spel.standard.SpelCompiler#getClassesDefinedCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "int",
    "signature": "public int getClassesDefinedCount()",
    "source_code": "\t\tpublic int getClassesDefinedCount() {\n\t\t\treturn this.classesDefinedCount.get();\n\t\t}"
  },
  "org.springframework.expression.spel.standard.SpelCompiler#getCompiler(classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Factory method for compiler instances. The returned SpelCompiler will\n\t * attach a class loader as the child of the given class loader and this\n\t * child will be used to load compiled expressions.\n\t * @param classLoader the ClassLoader to use as the basis for compilation\n\t * @return a corresponding SpelCompiler instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "SpelCompiler",
    "signature": "public SpelCompiler getCompiler(@Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static SpelCompiler getCompiler(@Nullable ClassLoader classLoader) {\n\t\tClassLoader clToUse = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());\n\t\t// Quick check for existing compiler without lock contention\n\t\tSpelCompiler compiler = compilers.get(clToUse);\n\t\tif (compiler == null) {\n\t\t\t// Full lock now since we're creating a child ClassLoader\n\t\t\tsynchronized (compilers) {\n\t\t\t\tcompiler = compilers.get(clToUse);\n\t\t\t\tif (compiler == null) {\n\t\t\t\t\tcompiler = new SpelCompiler(clToUse);\n\t\t\t\t\tcompilers.put(clToUse, compiler);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn compiler;\n\t}"
  },
  "org.springframework.expression.spel.standard.SpelCompiler#revertToInterpreted(expression)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Request to revert to the interpreter for expression evaluation.\n\t * Any compiled form is discarded but can be recreated by later recompiling again.\n\t * @param expression the expression\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "void",
    "signature": "public void revertToInterpreted(Expression expression)",
    "source_code": "\tpublic static void revertToInterpreted(Expression expression) {\n\t\tif (expression instanceof SpelExpression spelExpression) {\n\t\t\tspelExpression.revertToInterpreted();\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.support.ReflectiveMethodResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Reflection-based {@link MethodResolver} used by default in {@link StandardEvaluationContext}\n * unless explicit method resolvers have been specified.\n *\n * @author Andy Clement\n * @author Juergen Hoeller\n * @author Chris Beams\n * @since 3.0\n * @see StandardEvaluationContext#addMethodResolver(MethodResolver)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "signature": "public class ReflectiveMethodResolver",
    "source_code": "public class ReflectiveMethodResolver implements MethodResolver {\n\n\t// Using distance will ensure a more accurate match is discovered,\n\t// more closely following the Java rules.\n\tprivate final boolean useDistance;\n\n\t@Nullable\n\tprivate Map<Class<?>, MethodFilter> filters;\n\n\n\tpublic ReflectiveMethodResolver() {\n\t\tthis.useDistance = true;\n\t}\n\n\t/**\n\t * This constructor allows the ReflectiveMethodResolver to be configured such that it\n\t * will use a distance computation to check which is the better of two close matches\n\t * (when there are multiple matches). Using the distance computation is intended to\n\t * ensure matches are more closely representative of what a Java compiler would do\n\t * when taking into account boxing/unboxing and whether the method candidates are\n\t * declared to handle a supertype of the type (of the argument) being passed in.\n\t * @param useDistance {@code true} if distance computation should be used when\n\t * calculating matches; {@code false} otherwise\n\t */\n\tpublic ReflectiveMethodResolver(boolean useDistance) {\n\t\tthis.useDistance = useDistance;\n\t}\n\n\n\t/**\n\t * Register a filter for methods on the given type.\n\t * @param type the type to filter on\n\t * @param filter the corresponding method filter,\n\t * or {@code null} to clear any filter for the given type\n\t */\n\tpublic void registerMethodFilter(Class<?> type, @Nullable MethodFilter filter) {\n\t\tif (this.filters == null) {\n\t\t\tthis.filters = new HashMap<>();\n\t\t}\n\t\tif (filter != null) {\n\t\t\tthis.filters.put(type, filter);\n\t\t}\n\t\telse {\n\t\t\tthis.filters.remove(type);\n\t\t}\n\t}\n\n\t/**\n\t * Locate a method on a type. There are three kinds of match that might occur:\n\t * <ol>\n\t * <li>an exact match where the types of the arguments match the types of the constructor\n\t * <li>an in-exact match where the types we are looking for are subtypes of those defined on the constructor\n\t * <li>a match where we are able to convert the arguments into those expected by the constructor,\n\t * according to the registered type converter\n\t * </ol>\n\t */\n\t@Override\n\t@Nullable\n\tpublic MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,\n\t\t\tList<TypeDescriptor> argumentTypes) throws AccessException {\n\n\t\ttry {\n\t\t\tTypeConverter typeConverter = context.getTypeConverter();\n\t\t\tClass<?> type = (targetObject instanceof Class<?> clazz ? clazz : targetObject.getClass());\n\t\t\tArrayList<Method> methods = new ArrayList<>(getMethods(type, targetObject));\n\n\t\t\t// If a filter is registered for this type, call it\n\t\t\tMethodFilter filter = (this.filters != null ? this.filters.get(type) : null);\n\t\t\tif (filter != null) {\n\t\t\t\tList<Method> filtered = filter.filter(methods);\n\t\t\t\tmethods = (filtered instanceof ArrayList ? (ArrayList<Method>) filtered : new ArrayList<>(filtered));\n\t\t\t}\n\n\t\t\t// Sort methods into a sensible order\n\t\t\tif (methods.size() > 1) {\n\t\t\t\tmethods.sort((m1, m2) -> {\n\t\t\t\t\tint m1pl = m1.getParameterCount();\n\t\t\t\t\tint m2pl = m2.getParameterCount();\n\t\t\t\t\t// vararg methods go last\n\t\t\t\t\tif (m1pl == m2pl) {\n\t\t\t\t\t\tif (!m1.isVarArgs() && m2.isVarArgs()) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (m1.isVarArgs() && !m2.isVarArgs()) {\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn Integer.compare(m1pl, m2pl);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Resolve any bridge methods\n\t\t\tfor (int i = 0; i < methods.size(); i++) {\n\t\t\t\tmethods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)));\n\t\t\t}\n\n\t\t\t// Remove duplicate methods (possible due to resolved bridge methods)\n\t\t\tSet<Method> methodsToIterate = new LinkedHashSet<>(methods);\n\n\t\t\tMethod closeMatch = null;\n\t\t\tint closeMatchDistance = Integer.MAX_VALUE;\n\t\t\tMethod matchRequiringConversion = null;\n\t\t\tboolean multipleOptions = false;\n\n\t\t\tfor (Method method : methodsToIterate) {\n\t\t\t\tif (method.getName().equals(name)) {\n\t\t\t\t\tint paramCount = method.getParameterCount();\n\t\t\t\t\tList<TypeDescriptor> paramDescriptors = new ArrayList<>(paramCount);\n\t\t\t\t\tfor (int i = 0; i < paramCount; i++) {\n\t\t\t\t\t\tparamDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)));\n\t\t\t\t\t}\n\t\t\t\t\tReflectionHelper.ArgumentsMatchInfo matchInfo = null;\n\t\t\t\t\tif (method.isVarArgs() && argumentTypes.size() >= (paramCount - 1)) {\n\t\t\t\t\t\t// *sigh* complicated\n\t\t\t\t\t\tmatchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter);\n\t\t\t\t\t}\n\t\t\t\t\telse if (paramCount == argumentTypes.size()) {\n\t\t\t\t\t\t// Name and parameter number match, check the arguments\n\t\t\t\t\t\tmatchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter);\n\t\t\t\t\t}\n\t\t\t\t\tif (matchInfo != null) {\n\t\t\t\t\t\tif (matchInfo.isExactMatch()) {\n\t\t\t\t\t\t\treturn new ReflectiveMethodExecutor(method, type);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (matchInfo.isCloseMatch()) {\n\t\t\t\t\t\t\tif (this.useDistance) {\n\t\t\t\t\t\t\t\tint matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes);\n\t\t\t\t\t\t\t\tif (closeMatch == null || matchDistance < closeMatchDistance) {\n\t\t\t\t\t\t\t\t\t// This is a better match...\n\t\t\t\t\t\t\t\t\tcloseMatch = method;\n\t\t\t\t\t\t\t\t\tcloseMatchDistance = matchDistance;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Take this as a close match if there isn't one already\n\t\t\t\t\t\t\t\tif (closeMatch == null) {\n\t\t\t\t\t\t\t\t\tcloseMatch = method;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (matchInfo.isMatchRequiringConversion()) {\n\t\t\t\t\t\t\tif (matchRequiringConversion != null) {\n\t\t\t\t\t\t\t\tmultipleOptions = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmatchRequiringConversion = method;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (closeMatch != null) {\n\t\t\t\treturn new ReflectiveMethodExecutor(closeMatch, type);\n\t\t\t}\n\t\t\telse if (matchRequiringConversion != null) {\n\t\t\t\tif (multipleOptions) {\n\t\t\t\t\tthrow new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name);\n\t\t\t\t}\n\t\t\t\treturn new ReflectiveMethodExecutor(matchRequiringConversion, type);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (EvaluationException ex) {\n\t\t\tthrow new AccessException(\"Failed to resolve method\", ex);\n\t\t}\n\t}\n\n\tprivate Set<Method> getMethods(Class<?> type, Object targetObject) {\n\t\tif (targetObject instanceof Class) {\n\t\t\tSet<Method> result = new LinkedHashSet<>();\n\t\t\t// Add these so that static methods are invocable on the type: e.g. Float.valueOf(..)\n\t\t\tMethod[] methods = getMethods(type);\n\t\t\tfor (Method method : methods) {\n\t\t\t\tif (Modifier.isStatic(method.getModifiers())) {\n\t\t\t\t\tresult.add(method);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Also expose methods from java.lang.Class itself\n\t\t\tCollections.addAll(result, getMethods(Class.class));\n\t\t\treturn result;\n\t\t}\n\t\telse if (Proxy.isProxyClass(type)) {\n\t\t\tSet<Method> result = new LinkedHashSet<>();\n\t\t\t// Expose interface methods (not proxy-declared overrides) for proper vararg introspection\n\t\t\tfor (Class<?> ifc : type.getInterfaces()) {\n\t\t\t\tMethod[] methods = getMethods(ifc);\n\t\t\t\tfor (Method method : methods) {\n\t\t\t\t\tif (isCandidateForInvocation(method, type)) {\n\t\t\t\t\t\tresult.add(method);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\telse {\n\t\t\tSet<Method> result = new LinkedHashSet<>();\n\t\t\tMethod[] methods = getMethods(type);\n\t\t\tfor (Method method : methods) {\n\t\t\t\tif (isCandidateForInvocation(method, type)) {\n\t\t\t\t\tresult.add(method);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/**\n\t * Return the set of methods for this type. The default implementation returns the\n\t * result of {@link Class#getMethods()} for the given {@code type}, but subclasses\n\t * may override in order to alter the results, e.g. specifying static methods\n\t * declared elsewhere.\n\t * @param type the class for which to return the methods\n\t * @since 3.1.1\n\t */\n\tprotected Method[] getMethods(Class<?> type) {\n\t\treturn type.getMethods();\n\t}\n\n\t/**\n\t * Determine whether the given {@code Method} is a candidate for method resolution\n\t * on an instance of the given target class.\n\t * <p>The default implementation considers any method as a candidate, even for\n\t * static methods sand non-user-declared methods on the {@link Object} base class.\n\t * @param method the Method to evaluate\n\t * @param targetClass the concrete target class that is being introspected\n\t * @since 4.3.15\n\t */\n\tprotected boolean isCandidateForInvocation(Method method, Class<?> targetClass) {\n\t\treturn true;\n\t}\n\n}"
  },
  "org.springframework.expression.spel.support.ReflectiveMethodResolver#getMethods(type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the set of methods for this type. The default implementation returns the\n\t * result of {@link Class#getMethods()} for the given {@code type}, but subclasses\n\t * may override in order to alter the results, e.g. specifying static methods\n\t * declared elsewhere.\n\t * @param type the class for which to return the methods\n\t * @since 3.1.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "Method[]",
    "signature": "protected Method[] getMethods(Class<?> type)",
    "source_code": "\tprotected Method[] getMethods(Class<?> type) {\n\t\treturn type.getMethods();\n\t}"
  },
  "org.springframework.expression.spel.support.ReflectiveMethodResolver#isCandidateForInvocation(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given {@code Method} is a candidate for method resolution\n\t * on an instance of the given target class.\n\t * <p>The default implementation considers any method as a candidate, even for\n\t * static methods sand non-user-declared methods on the {@link Object} base class.\n\t * @param method the Method to evaluate\n\t * @param targetClass the concrete target class that is being introspected\n\t * @since 4.3.15\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "boolean",
    "signature": "protected boolean isCandidateForInvocation(Method method, Class<?> targetClass)",
    "source_code": "\tprotected boolean isCandidateForInvocation(Method method, Class<?> targetClass) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.expression.spel.support.ReflectiveMethodResolver#registerMethodFilter(type,filter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a filter for methods on the given type.\n\t * @param type the type to filter on\n\t * @param filter the corresponding method filter,\n\t * or {@code null} to clear any filter for the given type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "filter"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void registerMethodFilter(Class<?> type, @Nullable MethodFilter filter)",
    "source_code": "\tpublic void registerMethodFilter(Class<?> type, @Nullable MethodFilter filter) {\n\t\tif (this.filters == null) {\n\t\t\tthis.filters = new HashMap<>();\n\t\t}\n\t\tif (filter != null) {\n\t\t\tthis.filters.put(type, filter);\n\t\t}\n\t\telse {\n\t\t\tthis.filters.remove(type);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.support.ReflectiveMethodResolver#resolve(context,targetObject,name,argumentTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Locate a method on a type. There are three kinds of match that might occur:\n\t * <ol>\n\t * <li>an exact match where the types of the arguments match the types of the constructor\n\t * <li>an in-exact match where the types we are looking for are subtypes of those defined on the constructor\n\t * <li>a match where we are able to convert the arguments into those expected by the constructor,\n\t * according to the registered type converter\n\t * </ol>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "targetObject",
      "name",
      "argumentTypes"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "MethodExecutor",
    "signature": "public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,\n\t\t\tList<TypeDescriptor> argumentTypes)",
    "source_code": "\tpublic MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,"
  },
  "org.springframework.http.APPLICATION_GRAPHQL_RESPONSE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Public constant media type for {@code application/graphql-response+json}.\n\t * @since 6.0.3\n\t * @see <a href=\"https://github.com/graphql/graphql-over-http\">GraphQL over HTTP spec</a>\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "signature": "public MediaType APPLICATION_GRAPHQL_RESPONSE",
    "source_code": "\tpublic static final MediaType APPLICATION_GRAPHQL_RESPONSE;",
    "type": "MediaType"
  },
  "org.springframework.http.APPLICATION_GRAPHQL_RESPONSE_VALUE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A String equivalent of {@link MediaType#APPLICATION_GRAPHQL_RESPONSE}.\n\t * @since 6.0.3\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "signature": "public String APPLICATION_GRAPHQL_RESPONSE_VALUE",
    "source_code": "\tpublic static final String APPLICATION_GRAPHQL_RESPONSE_VALUE = \"application/graphql-response+json\";",
    "type": "String"
  },
  "org.springframework.http.ProblemDetail": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Representation for an RFC 7807 problem detail. Includes spec-defined\n * properties, and a {@link #getProperties() properties} map for additional,\n * non-standard properties.\n *\n * <p>For an extended response, an application can add to the\n * {@link #getProperties() properties} map. When using the Jackson library, the\n * {@code properties} map is expanded as top level JSON properties through the\n * {@link org.springframework.http.converter.json.ProblemDetailJacksonMixin}.\n *\n * <p>For an extended response, an application can also create a subclass with\n * additional properties. Subclasses can use the protected copy constructor to\n * re-create an existing {@code ProblemDetail} instance as the subclass, e.g.\n * from an {@code @ControllerAdvice} such as\n * {@link org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 6.0\n * @see <a href=\"https://datatracker.ietf.org/doc/html/rfc7807\">RFC 7807</a>\n * @see org.springframework.web.ErrorResponse\n * @see org.springframework.web.ErrorResponseException\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class ProblemDetail",
    "source_code": "public class ProblemDetail {\n\n\tprivate static final URI BLANK_TYPE = URI.create(\"about:blank\");\n\n\n\tprivate URI type = BLANK_TYPE;\n\n\t@Nullable\n\tprivate String title;\n\n\tprivate int status;\n\n\t@Nullable\n\tprivate String detail;\n\n\t@Nullable\n\tprivate URI instance;\n\n\t@Nullable\n\tprivate Map<String, Object> properties;\n\n\n\t/**\n\t * Protected constructor for subclasses.\n\t * <p>To create a {@link ProblemDetail} instance, use static factory methods,\n\t * {@link #forStatus(HttpStatusCode)} or {@link #forStatus(int)}.\n\t * @param rawStatusCode the response status to use\n\t */\n\tprotected ProblemDetail(int rawStatusCode) {\n\t\tthis.status = rawStatusCode;\n\t}\n\n\t/**\n\t * Copy constructor that a subclass can use to re-create and extend a\n\t * {@code ProblemDetail} with additional properties.\n\t */\n\tprotected ProblemDetail(ProblemDetail other) {\n\t\tthis.type = other.type;\n\t\tthis.title = other.title;\n\t\tthis.status = other.status;\n\t\tthis.detail = other.detail;\n\t\tthis.instance = other.instance;\n\t\tthis.properties = (other.properties != null ? new LinkedHashMap<>(other.properties) : null);\n\t}\n\n\t/**\n\t * No-arg constructor, for deserialization.\n\t */\n\tprotected ProblemDetail() {\n\t}\n\n\n\t/**\n\t * Setter for the {@link #getType() problem type}.\n\t * <p>By default, this is {@link #BLANK_TYPE}.\n\t * @param type the problem type\n\t */\n\tpublic void setType(URI type) {\n\t\tAssert.notNull(type, \"'type' is required\");\n\t\tthis.type = type;\n\t}\n\n\t/**\n\t * Return the configured {@link #setType(URI) problem type}.\n\t */\n\tpublic URI getType() {\n\t\treturn this.type;\n\t}\n\n\t/**\n\t * Setter for the {@link #getTitle() problem title}.\n\t * <p>By default, if not explicitly set and the status is well-known, this\n\t * is sourced from the {@link HttpStatus#getReasonPhrase()}.\n\t * @param title the problem title\n\t */\n\tpublic void setTitle(@Nullable String title) {\n\t\tthis.title = title;\n\t}\n\n\t/**\n\t * Return the configured {@link #setTitle(String) problem title}.\n\t */\n\t@Nullable\n\tpublic String getTitle() {\n\t\tif (this.title == null) {\n\t\t\tHttpStatus httpStatus = HttpStatus.resolve(this.status);\n\t\t\tif (httpStatus != null) {\n\t\t\t\treturn httpStatus.getReasonPhrase();\n\t\t\t}\n\t\t}\n\t\treturn this.title;\n\t}\n\n\t/**\n\t * Setter for the {@link #getStatus() problem status}.\n\t * @param httpStatus the problem status\n\t */\n\tpublic void setStatus(HttpStatus httpStatus) {\n\t\tthis.status = httpStatus.value();\n\t}\n\n\t/**\n\t * Setter for the {@link #getStatus() problem status}.\n\t * @param status the problem status\n\t */\n\tpublic void setStatus(int status) {\n\t\tthis.status = status;\n\t}\n\n\t/**\n\t * Return the status associated with the problem, provided either to the\n\t * constructor or configured via {@link #setStatus(int)}.\n\t */\n\tpublic int getStatus() {\n\t\treturn this.status;\n\t}\n\n\t/**\n\t * Setter for the {@link #getDetail() problem detail}.\n\t * <p>By default, this is not set.\n\t * @param detail the problem detail\n\t */\n\tpublic void setDetail(@Nullable String detail) {\n\t\tthis.detail = detail;\n\t}\n\n\t/**\n\t * Return the configured {@link #setDetail(String) problem detail}.\n\t */\n\t@Nullable\n\tpublic String getDetail() {\n\t\treturn this.detail;\n\t}\n\n\t/**\n\t * Setter for the {@link #getInstance() problem instance}.\n\t * <p>By default, when {@code ProblemDetail} is returned from an\n\t * {@code @ExceptionHandler} method, this is initialized to the request path.\n\t * @param instance the problem instance\n\t */\n\tpublic void setInstance(@Nullable URI instance) {\n\t\tthis.instance = instance;\n\t}\n\n\t/**\n\t * Return the configured {@link #setInstance(URI) problem instance}.\n\t */\n\t@Nullable\n\tpublic URI getInstance() {\n\t\treturn this.instance;\n\t}\n\n\t/**\n\t * Set a \"dynamic\" property to be added to a generic {@link #getProperties()\n\t * properties map}.\n\t * <p>When Jackson JSON is present on the classpath, any properties set here\n\t * are rendered as top level key-value pairs in the output JSON. Otherwise,\n\t * they are rendered as a {@code \"properties\"} sub-map.\n\t * @param name the property name\n\t * @param value the property value\n\t * @see org.springframework.http.converter.json.ProblemDetailJacksonMixin\n\t */\n\tpublic void setProperty(String name, Object value) {\n\t\tthis.properties = (this.properties != null ? this.properties : new LinkedHashMap<>());\n\t\tthis.properties.put(name, value);\n\t}\n\n\t/**\n\t * Return a generic map of properties that are not known ahead of time,\n\t * possibly {@code null} if no properties have been added. To add a property,\n\t * use {@link #setProperty(String, Object)}.\n\t * <p>When Jackson JSON is present on the classpath, the content of this map\n\t * is unwrapped and rendered as top level key-value pairs in the output JSON.\n\t * Otherwise, they are rendered as a {@code \"properties\"} sub-map.\n\t * @see org.springframework.http.converter.json.ProblemDetailJacksonMixin\n\t */\n\t@Nullable\n\tpublic Map<String, Object> getProperties() {\n\t\treturn this.properties;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(other instanceof ProblemDetail otherDetail)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (this.type.equals(otherDetail.type) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.title, otherDetail.title) &&\n\t\t\t\tthis.status == otherDetail.status &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.detail, otherDetail.detail) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.instance, otherDetail.instance) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.properties, otherDetail.properties));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint result = this.type.hashCode();\n\t\tresult = 31 * result + ObjectUtils.nullSafeHashCode(this.title);\n\t\tresult = 31 * result + this.status;\n\t\tresult = 31 * result + ObjectUtils.nullSafeHashCode(this.detail);\n\t\tresult = 31 * result + ObjectUtils.nullSafeHashCode(this.instance);\n\t\tresult = 31 * result + ObjectUtils.nullSafeHashCode(this.properties);\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \"[\" + initToStringContent() + \"]\";\n\t}\n\n\t/**\n\t * Return a String representation of the {@code ProblemDetail} fields.\n\t * Subclasses can override this to append additional fields.\n\t */\n\tprotected String initToStringContent() {\n\t\treturn \"type='\" + getType() + \"'\" +\n\t\t\t\t\", title='\" + getTitle() + \"'\" +\n\t\t\t\t\", status=\" + getStatus() +\n\t\t\t\t\", detail='\" + getDetail() + \"'\" +\n\t\t\t\t\", instance='\" + getInstance() + \"'\" +\n\t\t\t\t\", properties='\" + getProperties() + \"'\";\n\t}\n\n\n\t// Static factory methods\n\n\t/**\n\t * Create a {@code ProblemDetail} instance with the given status code.\n\t */\n\tpublic static ProblemDetail forStatus(HttpStatusCode status) {\n\t\tAssert.notNull(status, \"HttpStatusCode is required\");\n\t\treturn forStatus(status.value());\n\t}\n\n\t/**\n\t * Create a {@code ProblemDetail} instance with the given status value.\n\t */\n\tpublic static ProblemDetail forStatus(int status) {\n\t\treturn new ProblemDetail(status);\n\t}\n\n\t/**\n\t * Create a {@code ProblemDetail} instance with the given status and detail.\n\t */\n\tpublic static ProblemDetail forStatusAndDetail(HttpStatusCode status, String detail) {\n\t\tAssert.notNull(status, \"HttpStatusCode is required\");\n\t\tProblemDetail problemDetail = forStatus(status.value());\n\t\tproblemDetail.setDetail(detail);\n\t\treturn problemDetail;\n\t}\n\n}"
  },
  "org.springframework.http.ProblemDetail#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(other instanceof ProblemDetail otherDetail)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (this.type.equals(otherDetail.type) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.title, otherDetail.title) &&\n\t\t\t\tthis.status == otherDetail.status &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.detail, otherDetail.detail) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.instance, otherDetail.instance) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.properties, otherDetail.properties));\n\t}"
  },
  "org.springframework.http.ProblemDetail#forStatus(status)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@code ProblemDetail} instance with the given status value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "ProblemDetail",
    "signature": "public ProblemDetail forStatus(int status)",
    "source_code": "\tpublic static ProblemDetail forStatus(int status) {\n\t\treturn new ProblemDetail(status);\n\t}"
  },
  "org.springframework.http.ProblemDetail#forStatusAndDetail(status,detail)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@code ProblemDetail} instance with the given status and detail.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status",
      "detail"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "ProblemDetail",
    "signature": "public ProblemDetail forStatusAndDetail(HttpStatusCode status, String detail)",
    "source_code": "\tpublic static ProblemDetail forStatusAndDetail(HttpStatusCode status, String detail) {\n\t\tAssert.notNull(status, \"HttpStatusCode is required\");\n\t\tProblemDetail problemDetail = forStatus(status.value());\n\t\tproblemDetail.setDetail(detail);\n\t\treturn problemDetail;\n\t}"
  },
  "org.springframework.http.ProblemDetail#getDetail()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link #setDetail(String) problem detail}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "String",
    "signature": "public String getDetail()",
    "source_code": "\tpublic String getDetail() {\n\t\treturn this.detail;\n\t}"
  },
  "org.springframework.http.ProblemDetail#getInstance()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link #setInstance(URI) problem instance}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "URI",
    "signature": "public URI getInstance()",
    "source_code": "\tpublic URI getInstance() {\n\t\treturn this.instance;\n\t}"
  },
  "org.springframework.http.ProblemDetail#getProperties()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a generic map of properties that are not known ahead of time,\n\t * possibly {@code null} if no properties have been added. To add a property,\n\t * use {@link #setProperty(String, Object)}.\n\t * <p>When Jackson JSON is present on the classpath, the content of this map\n\t * is unwrapped and rendered as top level key-value pairs in the output JSON.\n\t * Otherwise, they are rendered as a {@code \"properties\"} sub-map.\n\t * @see org.springframework.http.converter.json.ProblemDetailJacksonMixin\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "Object>",
    "signature": "public Object> getProperties()",
    "source_code": "\tpublic Map<String, Object> getProperties() {\n\t\treturn this.properties;\n\t}"
  },
  "org.springframework.http.ProblemDetail#getStatus()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the status associated with the problem, provided either to the\n\t * constructor or configured via {@link #setStatus(int)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "int",
    "signature": "public int getStatus()",
    "source_code": "\tpublic int getStatus() {\n\t\treturn this.status;\n\t}"
  },
  "org.springframework.http.ProblemDetail#getTitle()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link #setTitle(String) problem title}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "String",
    "signature": "public String getTitle()",
    "source_code": "\tpublic String getTitle() {\n\t\tif (this.title == null) {\n\t\t\tHttpStatus httpStatus = HttpStatus.resolve(this.status);\n\t\t\tif (httpStatus != null) {\n\t\t\t\treturn httpStatus.getReasonPhrase();\n\t\t\t}\n\t\t}\n\t\treturn this.title;\n\t}"
  },
  "org.springframework.http.ProblemDetail#getType()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link #setType(URI) problem type}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "URI",
    "signature": "public URI getType()",
    "source_code": "\tpublic URI getType() {\n\t\treturn this.type;\n\t}"
  },
  "org.springframework.http.ProblemDetail#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\tint result = this.type.hashCode();\n\t\tresult = 31 * result + ObjectUtils.nullSafeHashCode(this.title);\n\t\tresult = 31 * result + this.status;\n\t\tresult = 31 * result + ObjectUtils.nullSafeHashCode(this.detail);\n\t\tresult = 31 * result + ObjectUtils.nullSafeHashCode(this.instance);\n\t\tresult = 31 * result + ObjectUtils.nullSafeHashCode(this.properties);\n\t\treturn result;\n\t}"
  },
  "org.springframework.http.ProblemDetail#initToStringContent()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a String representation of the {@code ProblemDetail} fields.\n\t * Subclasses can override this to append additional fields.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "String",
    "signature": "protected String initToStringContent()",
    "source_code": "\tprotected String initToStringContent() {\n\t\treturn \"type='\" + getType() + \"'\" +\n\t\t\t\t\", title='\" + getTitle() + \"'\" +\n\t\t\t\t\", status=\" + getStatus() +\n\t\t\t\t\", detail='\" + getDetail() + \"'\" +\n\t\t\t\t\", instance='\" + getInstance() + \"'\" +\n\t\t\t\t\", properties='\" + getProperties() + \"'\";\n\t}"
  },
  "org.springframework.http.ProblemDetail#setDetail(detail)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Setter for the {@link #getDetail() problem detail}.\n\t * <p>By default, this is not set.\n\t * @param detail the problem detail\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "detail"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "void",
    "signature": "public void setDetail(@Nullable String detail)",
    "source_code": "\tpublic void setDetail(@Nullable String detail) {\n\t\tthis.detail = detail;\n\t}"
  },
  "org.springframework.http.ProblemDetail#setInstance(instance)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Setter for the {@link #getInstance() problem instance}.\n\t * <p>By default, when {@code ProblemDetail} is returned from an\n\t * {@code @ExceptionHandler} method, this is initialized to the request path.\n\t * @param instance the problem instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "instance"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "void",
    "signature": "public void setInstance(@Nullable URI instance)",
    "source_code": "\tpublic void setInstance(@Nullable URI instance) {\n\t\tthis.instance = instance;\n\t}"
  },
  "org.springframework.http.ProblemDetail#setProperty(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a \"dynamic\" property to be added to a generic {@link #getProperties()\n\t * properties map}.\n\t * <p>When Jackson JSON is present on the classpath, any properties set here\n\t * are rendered as top level key-value pairs in the output JSON. Otherwise,\n\t * they are rendered as a {@code \"properties\"} sub-map.\n\t * @param name the property name\n\t * @param value the property value\n\t * @see org.springframework.http.converter.json.ProblemDetailJacksonMixin\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "void",
    "signature": "public void setProperty(String name, Object value)",
    "source_code": "\tpublic void setProperty(String name, Object value) {\n\t\tthis.properties = (this.properties != null ? this.properties : new LinkedHashMap<>());\n\t\tthis.properties.put(name, value);\n\t}"
  },
  "org.springframework.http.ProblemDetail#setStatus(httpStatus)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Setter for the {@link #getStatus() problem status}.\n\t * @param httpStatus the problem status\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "httpStatus"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void setStatus(HttpStatus httpStatus)",
    "source_code": "\tpublic void setStatus(HttpStatus httpStatus) {\n\t\tthis.status = httpStatus.value();\n\t}"
  },
  "org.springframework.http.ProblemDetail#setStatus(status)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Setter for the {@link #getStatus() problem status}.\n\t * @param status the problem status\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "void",
    "signature": "public void setStatus(int status)",
    "source_code": "\tpublic void setStatus(int status) {\n\t\tthis.status = status;\n\t}"
  },
  "org.springframework.http.ProblemDetail#setTitle(title)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Setter for the {@link #getTitle() problem title}.\n\t * <p>By default, if not explicitly set and the status is well-known, this\n\t * is sourced from the {@link HttpStatus#getReasonPhrase()}.\n\t * @param title the problem title\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "title"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void setTitle(@Nullable String title)",
    "source_code": "\tpublic void setTitle(@Nullable String title) {\n\t\tthis.title = title;\n\t}"
  },
  "org.springframework.http.ProblemDetail#setType(type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Setter for the {@link #getType() problem type}.\n\t * <p>By default, this is {@link #BLANK_TYPE}.\n\t * @param type the problem type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void setType(URI type)",
    "source_code": "\tpublic void setType(URI type) {\n\t\tAssert.notNull(type, \"'type' is required\");\n\t\tthis.type = type;\n\t}"
  },
  "org.springframework.http.ProblemDetail#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \"[\" + initToStringContent() + \"]\";\n\t}"
  },
  "org.springframework.http.codec.multipart.PartHttpMessageWriter#canWrite(elementType,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "boolean",
    "signature": "public boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\tif (Part.class.isAssignableFrom(elementType.toClass())) {\n\t\t\tif (mediaType == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (MediaType supportedMediaType : getWritableMediaTypes()) {\n\t\t\t\tif (supportedMediaType.isCompatibleWith(mediaType)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#addCodec(codecs,codec)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize a codec and add it to the List.\n\t * @since 5.1.13\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "codecs",
      "codec"
    ],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "void",
    "signature": "protected void addCodec(List<T> codecs, T codec)",
    "source_code": "\tprotected <T> void addCodec(List<T> codecs, T codec) {\n\t\tinitCodec(codec);\n\t\tcodecs.add(codec);\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#configureDefaultCodec(codecConsumer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codecConsumer"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "void",
    "signature": "public void configureDefaultCodec(Consumer<Object> codecConsumer)",
    "source_code": "\tpublic void configureDefaultCodec(Consumer<Object> codecConsumer) {\n\t\tthis.codecConsumer = (this.codecConsumer != null ?\n\t\t\t\tthis.codecConsumer.andThen(codecConsumer) : codecConsumer);\n\t\tinitReaders();\n\t\tinitWriters();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#enableLoggingRequestDetails(enable)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enable"
    ],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "void",
    "signature": "public void enableLoggingRequestDetails(boolean enable)",
    "source_code": "\tpublic void enableLoggingRequestDetails(boolean enable) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.enableLoggingRequestDetails, enable)) {\n\t\t\tthis.enableLoggingRequestDetails = enable;\n\t\t\tinitReaders();\n\t\t\tinitWriters();\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#extendObjectReaders(objectReaders)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for client or server specific Object readers.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "objectReaders"
    ],
    "position": {
      "column": 1,
      "line": 586
    },
    "return": "void",
    "signature": "protected void extendObjectReaders(List<HttpMessageReader<?>> objectReaders)",
    "source_code": "\tprotected void extendObjectReaders(List<HttpMessageReader<?>> objectReaders) {\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#extendObjectWriters(objectWriters)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for client or server specific Object writers.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "objectWriters"
    ],
    "position": {
      "column": 1,
      "line": 708
    },
    "return": "void",
    "signature": "protected void extendObjectWriters(List<HttpMessageWriter<?>> objectWriters)",
    "source_code": "\tprotected void extendObjectWriters(List<HttpMessageWriter<?>> objectWriters) {\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#extendTypedReaders(typedReaders)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for client or server specific typed readers.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "typedReaders"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "void",
    "signature": "protected void extendTypedReaders(List<HttpMessageReader<?>> typedReaders)",
    "source_code": "\tprotected void extendTypedReaders(List<HttpMessageReader<?>> typedReaders) {\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#extendTypedWriters(typedWriters)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for client or server specific typed writers.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "typedWriters"
    ],
    "position": {
      "column": 1,
      "line": 650
    },
    "return": "void",
    "signature": "protected void extendTypedWriters(List<HttpMessageWriter<?>> typedWriters)",
    "source_code": "\tprotected void extendTypedWriters(List<HttpMessageWriter<?>> typedWriters) {\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#initObjectReaders()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset and initialize object readers.\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 548
    },
    "return": "void",
    "signature": "protected void initObjectReaders()",
    "source_code": "\tprotected void initObjectReaders() {\n\t\tthis.objectReaders.clear();\n\t\tif (!this.registerDefaults) {\n\t\t\treturn;\n\t\t}\n\t\tif (kotlinSerializationCborPresent) {\n\t\t\taddCodec(this.objectReaders, new DecoderHttpMessageReader<>(this.kotlinSerializationCborDecoder != null ?\n\t\t\t\t\t(KotlinSerializationCborDecoder) this.kotlinSerializationCborDecoder :\n\t\t\t\t\tnew KotlinSerializationCborDecoder()));\n\t\t}\n\t\tif (kotlinSerializationJsonPresent) {\n\t\t\taddCodec(this.objectReaders, new DecoderHttpMessageReader<>(getKotlinSerializationJsonDecoder()));\n\t\t}\n\t\tif (kotlinSerializationProtobufPresent) {\n\t\t\taddCodec(this.objectReaders,\n\t\t\t\t\tnew DecoderHttpMessageReader<>(this.kotlinSerializationProtobufDecoder != null ?\n\t\t\t\t\t\t\t(KotlinSerializationProtobufDecoder) this.kotlinSerializationProtobufDecoder :\n\t\t\t\t\t\t\tnew KotlinSerializationProtobufDecoder()));\n\t\t}\n\t\tif (jackson2Present) {\n\t\t\taddCodec(this.objectReaders, new DecoderHttpMessageReader<>(getJackson2JsonDecoder()));\n\t\t}\n\t\tif (jackson2SmilePresent) {\n\t\t\taddCodec(this.objectReaders, new DecoderHttpMessageReader<>(this.jackson2SmileDecoder != null ?\n\t\t\t\t\t(Jackson2SmileDecoder) this.jackson2SmileDecoder : new Jackson2SmileDecoder()));\n\t\t}\n\t\tif (jaxb2Present) {\n\t\t\taddCodec(this.objectReaders, new DecoderHttpMessageReader<>(this.jaxb2Decoder != null ?\n\t\t\t\t\t(Jaxb2XmlDecoder) this.jaxb2Decoder : new Jaxb2XmlDecoder()));\n\t\t}\n\n\t\t// client vs server..\n\t\textendObjectReaders(this.objectReaders);\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#initObjectWriters()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset and initialize object writers.\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 664
    },
    "return": "void",
    "signature": "protected void initObjectWriters()",
    "source_code": "\tprotected void initObjectWriters() {\n\t\tthis.objectWriters.clear();\n\t\tif (!this.registerDefaults) {\n\t\t\treturn;\n\t\t}\n\t\tthis.objectWriters.addAll(getBaseObjectWriters());\n\t\textendObjectWriters(this.objectWriters);\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#initReaders()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset and initialize typed readers and object readers.\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "void",
    "signature": "protected void initReaders()",
    "source_code": "\tprotected void initReaders() {\n\t\tinitTypedReaders();\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#initTypedReaders()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset and initialize typed readers.\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 383
    },
    "return": "void",
    "signature": "protected void initTypedReaders()",
    "source_code": "\tprotected void initTypedReaders() {\n\t\tthis.typedReaders.clear();\n\t\tif (!this.registerDefaults) {\n\t\t\treturn;\n\t\t}\n\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(new ByteArrayDecoder()));\n\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(new ByteBufferDecoder()));\n\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(new DataBufferDecoder()));\n\t\tif (nettyByteBufPresent) {\n\t\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(new NettyByteBufDecoder()));\n\t\t}\n\t\tif (netty5BufferPresent) {\n\t\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(new Netty5BufferDecoder()));\n\t\t}\n\t\taddCodec(this.typedReaders, new ResourceHttpMessageReader(new ResourceDecoder()));\n\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(StringDecoder.textPlainOnly()));\n\t\tif (protobufPresent) {\n\t\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(this.protobufDecoder != null ?\n\t\t\t\t\t(ProtobufDecoder) this.protobufDecoder : new ProtobufDecoder()));\n\t\t}\n\t\telse if (kotlinSerializationProtobufPresent) {\n\t\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(this.kotlinSerializationProtobufDecoder != null ?\n\t\t\t\t\t(KotlinSerializationProtobufDecoder) this.kotlinSerializationProtobufDecoder : new KotlinSerializationProtobufDecoder()));\n\t\t}\n\t\taddCodec(this.typedReaders, new FormHttpMessageReader());\n\n\t\t// client vs server..\n\t\textendTypedReaders(this.typedReaders);\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#initTypedWriters()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset and initialize typed writers.\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 612
    },
    "return": "void",
    "signature": "protected void initTypedWriters()",
    "source_code": "\tprotected void initTypedWriters() {\n\t\tthis.typedWriters.clear();\n\t\tif (!this.registerDefaults) {\n\t\t\treturn;\n\t\t}\n\t\tthis.typedWriters.addAll(getBaseTypedWriters());\n\t\textendTypedWriters(this.typedWriters);\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#initWriters()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset and initialize typed writers and object writers.\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "void",
    "signature": "protected void initWriters()",
    "source_code": "\tprotected void initWriters() {\n\t\tinitTypedWriters();\n\t\tinitObjectWriters();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#isEnableLoggingRequestDetails()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "Boolean",
    "signature": "public Boolean isEnableLoggingRequestDetails()",
    "source_code": "\tpublic Boolean isEnableLoggingRequestDetails() {\n\t\treturn this.enableLoggingRequestDetails;\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#jackson2JsonDecoder(decoder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "void",
    "signature": "public void jackson2JsonDecoder(Decoder<?> decoder)",
    "source_code": "\tpublic void jackson2JsonDecoder(Decoder<?> decoder) {\n\t\tthis.jackson2JsonDecoder = decoder;\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#jackson2JsonEncoder(encoder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "void",
    "signature": "public void jackson2JsonEncoder(Encoder<?> encoder)",
    "source_code": "\tpublic void jackson2JsonEncoder(Encoder<?> encoder) {\n\t\tthis.jackson2JsonEncoder = encoder;\n\t\tinitObjectWriters();\n\t\tinitTypedWriters();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#jackson2SmileDecoder(decoder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "void",
    "signature": "public void jackson2SmileDecoder(Decoder<?> decoder)",
    "source_code": "\tpublic void jackson2SmileDecoder(Decoder<?> decoder) {\n\t\tthis.jackson2SmileDecoder = decoder;\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#jackson2SmileEncoder(encoder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "void",
    "signature": "public void jackson2SmileEncoder(Encoder<?> encoder)",
    "source_code": "\tpublic void jackson2SmileEncoder(Encoder<?> encoder) {\n\t\tthis.jackson2SmileEncoder = encoder;\n\t\tinitObjectWriters();\n\t\tinitTypedWriters();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#jaxb2Decoder(decoder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "void",
    "signature": "public void jaxb2Decoder(Decoder<?> decoder)",
    "source_code": "\tpublic void jaxb2Decoder(Decoder<?> decoder) {\n\t\tthis.jaxb2Decoder = decoder;\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#jaxb2Encoder(encoder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "void",
    "signature": "public void jaxb2Encoder(Encoder<?> encoder)",
    "source_code": "\tpublic void jaxb2Encoder(Encoder<?> encoder) {\n\t\tthis.jaxb2Encoder = encoder;\n\t\tinitObjectWriters();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#kotlinSerializationCborDecoder(decoder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "void",
    "signature": "public void kotlinSerializationCborDecoder(Decoder<?> decoder)",
    "source_code": "\tpublic void kotlinSerializationCborDecoder(Decoder<?> decoder) {\n\t\tthis.kotlinSerializationCborDecoder = decoder;\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#kotlinSerializationCborEncoder(encoder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "void",
    "signature": "public void kotlinSerializationCborEncoder(Encoder<?> encoder)",
    "source_code": "\tpublic void kotlinSerializationCborEncoder(Encoder<?> encoder) {\n\t\tthis.kotlinSerializationCborEncoder = encoder;\n\t\tinitObjectWriters();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#kotlinSerializationJsonDecoder(decoder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "void",
    "signature": "public void kotlinSerializationJsonDecoder(Decoder<?> decoder)",
    "source_code": "\tpublic void kotlinSerializationJsonDecoder(Decoder<?> decoder) {\n\t\tthis.kotlinSerializationJsonDecoder = decoder;\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#kotlinSerializationJsonEncoder(encoder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "void",
    "signature": "public void kotlinSerializationJsonEncoder(Encoder<?> encoder)",
    "source_code": "\tpublic void kotlinSerializationJsonEncoder(Encoder<?> encoder) {\n\t\tthis.kotlinSerializationJsonEncoder = encoder;\n\t\tinitObjectWriters();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#kotlinSerializationProtobufDecoder(decoder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "void",
    "signature": "public void kotlinSerializationProtobufDecoder(Decoder<?> decoder)",
    "source_code": "\tpublic void kotlinSerializationProtobufDecoder(Decoder<?> decoder) {\n\t\tthis.kotlinSerializationProtobufDecoder = decoder;\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#kotlinSerializationProtobufEncoder(encoder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "void",
    "signature": "public void kotlinSerializationProtobufEncoder(Encoder<?> encoder)",
    "source_code": "\tpublic void kotlinSerializationProtobufEncoder(Encoder<?> encoder) {\n\t\tthis.kotlinSerializationProtobufEncoder = encoder;\n\t\tinitObjectWriters();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#maxInMemorySize()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "Integer",
    "signature": "public Integer maxInMemorySize()",
    "source_code": "\tpublic Integer maxInMemorySize() {\n\t\treturn this.maxInMemorySize;\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#maxInMemorySize(byteCount)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "byteCount"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "void",
    "signature": "public void maxInMemorySize(int byteCount)",
    "source_code": "\tpublic void maxInMemorySize(int byteCount) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.maxInMemorySize, byteCount)) {\n\t\t\tthis.maxInMemorySize = byteCount;\n\t\t\tinitReaders();\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#protobufDecoder(decoder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "void",
    "signature": "public void protobufDecoder(Decoder<?> decoder)",
    "source_code": "\tpublic void protobufDecoder(Decoder<?> decoder) {\n\t\tthis.protobufDecoder = decoder;\n\t\tinitTypedReaders();\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#protobufEncoder(encoder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "void",
    "signature": "public void protobufEncoder(Encoder<?> encoder)",
    "source_code": "\tpublic void protobufEncoder(Encoder<?> encoder) {\n\t\tthis.protobufEncoder = encoder;\n\t\tinitTypedWriters();\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Default implementation of {@link CodecConfigurer.MultipartCodecs}.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 838
    },
    "signature": "protected class DefaultMultipartCodecs",
    "source_code": "\tprotected class DefaultMultipartCodecs implements CodecConfigurer.MultipartCodecs {\n\n\t\tprivate final List<HttpMessageWriter<?>> writers = new ArrayList<>();\n\n\n\t\tDefaultMultipartCodecs() {\n\t\t}\n\n\t\tDefaultMultipartCodecs(DefaultMultipartCodecs other) {\n\t\t\tthis.writers.addAll(other.writers);\n\t\t}\n\n\n\t\t@Override\n\t\tpublic CodecConfigurer.MultipartCodecs encoder(Encoder<?> encoder) {\n\t\t\twriter(new EncoderHttpMessageWriter<>(encoder));\n\t\t\tinitTypedWriters();\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic CodecConfigurer.MultipartCodecs writer(HttpMessageWriter<?> writer) {\n\t\t\tthis.writers.add(writer);\n\t\t\tinitTypedWriters();\n\t\t\treturn this;\n\t\t}\n\n\t\tList<HttpMessageWriter<?>> getWriters() {\n\t\t\treturn this.writers;\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#addCodec(codecs,codec)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize a codec and add it to the List.\n\t * @since 5.1.13\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "codecs",
      "codec"
    ],
    "position": {
      "column": 1,
      "line": 466
    },
    "return": "void",
    "signature": "protected void addCodec(List<T> codecs, T codec)",
    "source_code": "\tprotected <T> void addCodec(List<T> codecs, T codec) {\n\t\tinitCodec(codec);\n\t\tcodecs.add(codec);\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#configureDefaultCodec(codecConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codecConsumer"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "void",
    "signature": "public void configureDefaultCodec(Consumer<Object> codecConsumer)",
    "source_code": "\tpublic void configureDefaultCodec(Consumer<Object> codecConsumer) {\n\t\tthis.codecConsumer = (this.codecConsumer != null ?\n\t\t\t\tthis.codecConsumer.andThen(codecConsumer) : codecConsumer);\n\t\tinitReaders();\n\t\tinitWriters();\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#enableLoggingRequestDetails(enable)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enable"
    ],
    "position": {
      "column": 1,
      "line": 361
    },
    "return": "void",
    "signature": "public void enableLoggingRequestDetails(boolean enable)",
    "source_code": "\tpublic void enableLoggingRequestDetails(boolean enable) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.enableLoggingRequestDetails, enable)) {\n\t\t\tthis.enableLoggingRequestDetails = enable;\n\t\t\tinitReaders();\n\t\t\tinitWriters();\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#extendObjectReaders(objectReaders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for client or server specific Object readers.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "objectReaders"
    ],
    "position": {
      "column": 1,
      "line": 635
    },
    "return": "void",
    "signature": "protected void extendObjectReaders(List<HttpMessageReader<?>> objectReaders)",
    "source_code": "\tprotected void extendObjectReaders(List<HttpMessageReader<?>> objectReaders) {\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#extendObjectWriters(objectWriters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for client or server specific Object writers.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "objectWriters"
    ],
    "position": {
      "column": 1,
      "line": 773
    },
    "return": "void",
    "signature": "protected void extendObjectWriters(List<HttpMessageWriter<?>> objectWriters)",
    "source_code": "\tprotected void extendObjectWriters(List<HttpMessageWriter<?>> objectWriters) {\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#extendTypedReaders(typedReaders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for client or server specific typed readers.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "typedReaders"
    ],
    "position": {
      "column": 1,
      "line": 583
    },
    "return": "void",
    "signature": "protected void extendTypedReaders(List<HttpMessageReader<?>> typedReaders)",
    "source_code": "\tprotected void extendTypedReaders(List<HttpMessageReader<?>> typedReaders) {\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#extendTypedWriters(typedWriters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for client or server specific typed writers.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "typedWriters"
    ],
    "position": {
      "column": 1,
      "line": 715
    },
    "return": "void",
    "signature": "protected void extendTypedWriters(List<HttpMessageWriter<?>> typedWriters)",
    "source_code": "\tprotected void extendTypedWriters(List<HttpMessageWriter<?>> typedWriters) {\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#initObjectReaders()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset and initialize object readers.\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 597
    },
    "return": "void",
    "signature": "protected void initObjectReaders()",
    "source_code": "\tprotected void initObjectReaders() {\n\t\tthis.objectReaders.clear();\n\t\tif (!this.registerDefaults) {\n\t\t\treturn;\n\t\t}\n\t\tif (kotlinSerializationCborPresent) {\n\t\t\taddCodec(this.objectReaders, new DecoderHttpMessageReader<>(this.kotlinSerializationCborDecoder != null ?\n\t\t\t\t\t(KotlinSerializationCborDecoder) this.kotlinSerializationCborDecoder :\n\t\t\t\t\tnew KotlinSerializationCborDecoder()));\n\t\t}\n\t\tif (kotlinSerializationJsonPresent) {\n\t\t\taddCodec(this.objectReaders, new DecoderHttpMessageReader<>(getKotlinSerializationJsonDecoder()));\n\t\t}\n\t\tif (kotlinSerializationProtobufPresent) {\n\t\t\taddCodec(this.objectReaders,\n\t\t\t\t\tnew DecoderHttpMessageReader<>(this.kotlinSerializationProtobufDecoder != null ?\n\t\t\t\t\t\t\t(KotlinSerializationProtobufDecoder) this.kotlinSerializationProtobufDecoder :\n\t\t\t\t\t\t\tnew KotlinSerializationProtobufDecoder()));\n\t\t}\n\t\tif (jackson2Present) {\n\t\t\taddCodec(this.objectReaders, new DecoderHttpMessageReader<>(getJackson2JsonDecoder()));\n\t\t}\n\t\tif (jackson2SmilePresent) {\n\t\t\taddCodec(this.objectReaders, new DecoderHttpMessageReader<>(this.jackson2SmileDecoder != null ?\n\t\t\t\t\t(Jackson2SmileDecoder) this.jackson2SmileDecoder : new Jackson2SmileDecoder()));\n\t\t}\n\t\tif (jaxb2Present) {\n\t\t\taddCodec(this.objectReaders, new DecoderHttpMessageReader<>(this.jaxb2Decoder != null ?\n\t\t\t\t\t(Jaxb2XmlDecoder) this.jaxb2Decoder : new Jaxb2XmlDecoder()));\n\t\t}\n\n\t\t// client vs server..\n\t\textendObjectReaders(this.objectReaders);\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#initObjectWriters()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset and initialize object writers.\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 729
    },
    "return": "void",
    "signature": "protected void initObjectWriters()",
    "source_code": "\tprotected void initObjectWriters() {\n\t\tthis.objectWriters.clear();\n\t\tif (!this.registerDefaults) {\n\t\t\treturn;\n\t\t}\n\t\tthis.objectWriters.addAll(getBaseObjectWriters());\n\t\textendObjectWriters(this.objectWriters);\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#initReaders()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset and initialize typed readers and object readers.\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "protected void initReaders()",
    "source_code": "\tprotected void initReaders() {\n\t\tinitTypedReaders();\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#initTypedReaders()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset and initialize typed readers.\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 423
    },
    "return": "void",
    "signature": "protected void initTypedReaders()",
    "source_code": "\tprotected void initTypedReaders() {\n\t\tthis.typedReaders.clear();\n\t\tif (!this.registerDefaults) {\n\t\t\treturn;\n\t\t}\n\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(new ByteArrayDecoder()));\n\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(new ByteBufferDecoder()));\n\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(new DataBufferDecoder()));\n\t\tif (nettyByteBufPresent) {\n\t\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(new NettyByteBufDecoder()));\n\t\t}\n\t\tif (netty5BufferPresent) {\n\t\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(new Netty5BufferDecoder()));\n\t\t}\n\t\taddCodec(this.typedReaders, new ResourceHttpMessageReader(new ResourceDecoder()));\n\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(StringDecoder.textPlainOnly()));\n\t\tif (protobufPresent) {\n\t\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(this.protobufDecoder != null ?\n\t\t\t\t\t(ProtobufDecoder) this.protobufDecoder : new ProtobufDecoder()));\n\t\t}\n\t\telse if (kotlinSerializationProtobufPresent) {\n\t\t\taddCodec(this.typedReaders, new DecoderHttpMessageReader<>(this.kotlinSerializationProtobufDecoder != null ?\n\t\t\t\t\t(KotlinSerializationProtobufDecoder) this.kotlinSerializationProtobufDecoder : new KotlinSerializationProtobufDecoder()));\n\t\t}\n\t\taddCodec(this.typedReaders, new FormHttpMessageReader());\n\t\tif (this.multipartReader != null) {\n\t\t\taddCodec(this.typedReaders, this.multipartReader);\n\t\t}\n\t\telse {\n\t\t\tDefaultPartHttpMessageReader partReader = new DefaultPartHttpMessageReader();\n\t\t\taddCodec(this.typedReaders, partReader);\n\t\t\taddCodec(this.typedReaders, new MultipartHttpMessageReader(partReader));\n\t\t}\n\t\taddCodec(this.typedReaders, new PartEventHttpMessageReader());\n\n\t\t// client vs server..\n\t\textendTypedReaders(this.typedReaders);\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#initTypedWriters()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset and initialize typed writers.\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 661
    },
    "return": "void",
    "signature": "protected void initTypedWriters()",
    "source_code": "\tprotected void initTypedWriters() {\n\t\tthis.typedWriters.clear();\n\t\tif (!this.registerDefaults) {\n\t\t\treturn;\n\t\t}\n\t\tthis.typedWriters.addAll(getBaseTypedWriters());\n\t\textendTypedWriters(this.typedWriters);\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#initWriters()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset and initialize typed writers and object writers.\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "void",
    "signature": "protected void initWriters()",
    "source_code": "\tprotected void initWriters() {\n\t\tinitTypedWriters();\n\t\tinitObjectWriters();\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#isEnableLoggingRequestDetails()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 396
    },
    "return": "Boolean",
    "signature": "public Boolean isEnableLoggingRequestDetails()",
    "source_code": "\tpublic Boolean isEnableLoggingRequestDetails() {\n\t\treturn this.enableLoggingRequestDetails;\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#jackson2JsonDecoder(decoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 253
    },
    "return": "void",
    "signature": "public void jackson2JsonDecoder(Decoder<?> decoder)",
    "source_code": "\tpublic void jackson2JsonDecoder(Decoder<?> decoder) {\n\t\tthis.jackson2JsonDecoder = decoder;\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#jackson2JsonEncoder(encoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "void",
    "signature": "public void jackson2JsonEncoder(Encoder<?> encoder)",
    "source_code": "\tpublic void jackson2JsonEncoder(Encoder<?> encoder) {\n\t\tthis.jackson2JsonEncoder = encoder;\n\t\tinitObjectWriters();\n\t\tinitTypedWriters();\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#jackson2SmileDecoder(decoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "void",
    "signature": "public void jackson2SmileDecoder(Decoder<?> decoder)",
    "source_code": "\tpublic void jackson2SmileDecoder(Decoder<?> decoder) {\n\t\tthis.jackson2SmileDecoder = decoder;\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#jackson2SmileEncoder(encoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "public void jackson2SmileEncoder(Encoder<?> encoder)",
    "source_code": "\tpublic void jackson2SmileEncoder(Encoder<?> encoder) {\n\t\tthis.jackson2SmileEncoder = encoder;\n\t\tinitObjectWriters();\n\t\tinitTypedWriters();\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#jaxb2Decoder(decoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "void",
    "signature": "public void jaxb2Decoder(Decoder<?> decoder)",
    "source_code": "\tpublic void jaxb2Decoder(Decoder<?> decoder) {\n\t\tthis.jaxb2Decoder = decoder;\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#jaxb2Encoder(encoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "void",
    "signature": "public void jaxb2Encoder(Encoder<?> encoder)",
    "source_code": "\tpublic void jaxb2Encoder(Encoder<?> encoder) {\n\t\tthis.jaxb2Encoder = encoder;\n\t\tinitObjectWriters();\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#kotlinSerializationCborDecoder(decoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "void",
    "signature": "public void kotlinSerializationCborDecoder(Decoder<?> decoder)",
    "source_code": "\tpublic void kotlinSerializationCborDecoder(Decoder<?> decoder) {\n\t\tthis.kotlinSerializationCborDecoder = decoder;\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#kotlinSerializationCborEncoder(encoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "void",
    "signature": "public void kotlinSerializationCborEncoder(Encoder<?> encoder)",
    "source_code": "\tpublic void kotlinSerializationCborEncoder(Encoder<?> encoder) {\n\t\tthis.kotlinSerializationCborEncoder = encoder;\n\t\tinitObjectWriters();\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#kotlinSerializationJsonDecoder(decoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "void",
    "signature": "public void kotlinSerializationJsonDecoder(Decoder<?> decoder)",
    "source_code": "\tpublic void kotlinSerializationJsonDecoder(Decoder<?> decoder) {\n\t\tthis.kotlinSerializationJsonDecoder = decoder;\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#kotlinSerializationJsonEncoder(encoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "void",
    "signature": "public void kotlinSerializationJsonEncoder(Encoder<?> encoder)",
    "source_code": "\tpublic void kotlinSerializationJsonEncoder(Encoder<?> encoder) {\n\t\tthis.kotlinSerializationJsonEncoder = encoder;\n\t\tinitObjectWriters();\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#kotlinSerializationProtobufDecoder(decoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "void",
    "signature": "public void kotlinSerializationProtobufDecoder(Decoder<?> decoder)",
    "source_code": "\tpublic void kotlinSerializationProtobufDecoder(Decoder<?> decoder) {\n\t\tthis.kotlinSerializationProtobufDecoder = decoder;\n\t\tinitObjectReaders();\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#kotlinSerializationProtobufEncoder(encoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "void",
    "signature": "public void kotlinSerializationProtobufEncoder(Encoder<?> encoder)",
    "source_code": "\tpublic void kotlinSerializationProtobufEncoder(Encoder<?> encoder) {\n\t\tthis.kotlinSerializationProtobufEncoder = encoder;\n\t\tinitObjectWriters();\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#maxInMemorySize()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "Integer",
    "signature": "public Integer maxInMemorySize()",
    "source_code": "\tpublic Integer maxInMemorySize() {\n\t\treturn this.maxInMemorySize;\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#maxInMemorySize(byteCount)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "byteCount"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "void",
    "signature": "public void maxInMemorySize(int byteCount)",
    "source_code": "\tpublic void maxInMemorySize(int byteCount) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.maxInMemorySize, byteCount)) {\n\t\t\tthis.maxInMemorySize = byteCount;\n\t\t\tinitReaders();\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#multipartReader(multipartReader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "multipartReader"
    ],
    "position": {
      "column": 1,
      "line": 378
    },
    "return": "void",
    "signature": "public void multipartReader(HttpMessageReader<?> multipartReader)",
    "source_code": "\tpublic void multipartReader(HttpMessageReader<?> multipartReader) {\n\t\tthis.multipartReader = multipartReader;\n\t\tinitTypedReaders();\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#protobufDecoder(decoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "void",
    "signature": "public void protobufDecoder(Decoder<?> decoder)",
    "source_code": "\tpublic void protobufDecoder(Decoder<?> decoder) {\n\t\tthis.protobufDecoder = decoder;\n\t\tinitTypedReaders();\n\t}"
  },
  "org.springframework.http.codec.support.DefaultMultipartCodecs#protobufEncoder(encoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 285
    },
    "return": "void",
    "signature": "public void protobufEncoder(Encoder<?> encoder)",
    "source_code": "\tpublic void protobufEncoder(Encoder<?> encoder) {\n\t\tthis.protobufEncoder = encoder;\n\t\tinitTypedWriters();\n\t}"
  },
  "org.springframework.jdbc.core.SingleColumnRowMapper": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link RowMapper} implementation that converts a single column into a single\n * result value per row. Expects to operate on a {@code java.sql.ResultSet}\n * that just contains a single column.\n *\n * <p>The type of the result value for each row can be specified. The value\n * for the single column will be extracted from the {@code ResultSet}\n * and converted into the specified target type.\n *\n * @author Juergen Hoeller\n * @author Kazuki Shimizu\n * @since 1.2\n * @param <T> the result type\n * @see JdbcTemplate#queryForList(String, Class)\n * @see JdbcTemplate#queryForObject(String, Class)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class SingleColumnRowMapper",
    "source_code": "public class SingleColumnRowMapper<T> implements RowMapper<T> {\n\n\t@Nullable\n\tprivate Class<?> requiredType;\n\n\t@Nullable\n\tprivate ConversionService conversionService = DefaultConversionService.getSharedInstance();\n\n\t/**\n\t * Create a new {@code SingleColumnRowMapper} for bean-style configuration.\n\t * @see #setRequiredType\n\t */\n\tpublic SingleColumnRowMapper() {\n\t}\n\n\t/**\n\t * Create a new {@code SingleColumnRowMapper}.\n\t * @param requiredType the type that each result object is expected to match\n\t */\n\tpublic SingleColumnRowMapper(Class<T> requiredType) {\n\t\tsetRequiredType(requiredType);\n\t}\n\n\n\t/**\n\t * Set the type that each result object is expected to match.\n\t * <p>If not specified, the column value will be exposed as\n\t * returned by the JDBC driver.\n\t */\n\tpublic void setRequiredType(Class<T> requiredType) {\n\t\tthis.requiredType = ClassUtils.resolvePrimitiveIfNecessary(requiredType);\n\t}\n\n\t/**\n\t * Set a {@link ConversionService} for converting a fetched value.\n\t * <p>Default is the {@link DefaultConversionService}.\n\t * @since 5.0.4\n\t * @see DefaultConversionService#getSharedInstance\n\t */\n\tpublic void setConversionService(@Nullable ConversionService conversionService) {\n\t\tthis.conversionService = conversionService;\n\t}\n\n\t/**\n\t * Extract a value for the single column in the current row.\n\t * <p>Validates that there is only one column selected,\n\t * then delegates to {@code getColumnValue()} and also\n\t * {@code convertValueToRequiredType}, if necessary.\n\t * @see java.sql.ResultSetMetaData#getColumnCount()\n\t * @see #getColumnValue(java.sql.ResultSet, int, Class)\n\t * @see #convertValueToRequiredType(Object, Class)\n\t */\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\t@Nullable\n\tpublic T mapRow(ResultSet rs, int rowNum) throws SQLException {\n\t\t// Validate column count.\n\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\tint nrOfColumns = rsmd.getColumnCount();\n\t\tif (nrOfColumns != 1) {\n\t\t\tthrow new IncorrectResultSetColumnCountException(1, nrOfColumns);\n\t\t}\n\n\t\t// Extract column value from JDBC ResultSet.\n\t\tObject result = getColumnValue(rs, 1, this.requiredType);\n\t\tif (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {\n\t\t\t// Extracted value does not match already: try to convert it.\n\t\t\ttry {\n\t\t\t\treturn (T) convertValueToRequiredType(result, this.requiredType);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tthrow new TypeMismatchDataAccessException(\n\t\t\t\t\t\t\"Type mismatch affecting row number \" + rowNum + \" and column type '\" +\n\t\t\t\t\t\trsmd.getColumnTypeName(1) + \"': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn (T) result;\n\t}\n\n\t/**\n\t * Retrieve a JDBC object value for the specified column.\n\t * <p>The default implementation calls\n\t * {@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}.\n\t * If no required type has been specified, this method delegates to\n\t * {@code getColumnValue(rs, index)}, which basically calls\n\t * {@code ResultSet.getObject(index)} but applies some additional\n\t * default conversion to appropriate value types.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @param requiredType the type that each result object is expected to match\n\t * (or {@code null} if none specified)\n\t * @return the Object value\n\t * @throws SQLException in case of extraction failure\n\t * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)\n\t * @see #getColumnValue(java.sql.ResultSet, int)\n\t */\n\t@Nullable\n\tprotected Object getColumnValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {\n\t\tif (requiredType != null) {\n\t\t\treturn JdbcUtils.getResultSetValue(rs, index, requiredType);\n\t\t}\n\t\telse {\n\t\t\t// No required type specified -> perform default extraction.\n\t\t\treturn getColumnValue(rs, index);\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve a JDBC object value for the specified column, using the most\n\t * appropriate value type. Called if no required type has been specified.\n\t * <p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},\n\t * which uses the {@code ResultSet.getObject(index)} method. Additionally,\n\t * it includes a \"hack\" to get around Oracle returning a non-standard object for\n\t * their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}\n\t * javadoc for details.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @return the Object value\n\t * @throws SQLException in case of extraction failure\n\t * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int)\n\t */\n\t@Nullable\n\tprotected Object getColumnValue(ResultSet rs, int index) throws SQLException {\n\t\treturn JdbcUtils.getResultSetValue(rs, index);\n\t}\n\n\t/**\n\t * Convert the given column value to the specified required type.\n\t * Only called if the extracted column value does not match already.\n\t * <p>If the required type is String, the value will simply get stringified\n\t * via {@code toString()}. In case of a Number, the value will be\n\t * converted into a Number, either through number conversion or through\n\t * String parsing (depending on the value type). Otherwise, the value will\n\t * be converted to a required type using the {@link ConversionService}.\n\t * @param value the column value as extracted from {@code getColumnValue()}\n\t * (never {@code null})\n\t * @param requiredType the type that each result object is expected to match\n\t * (never {@code null})\n\t * @return the converted value\n\t * @see #getColumnValue(java.sql.ResultSet, int, Class)\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Nullable\n\tprotected Object convertValueToRequiredType(Object value, Class<?> requiredType) {\n\t\tif (String.class == requiredType) {\n\t\t\treturn value.toString();\n\t\t}\n\t\telse if (Number.class.isAssignableFrom(requiredType)) {\n\t\t\tif (value instanceof Number number) {\n\t\t\t\t// Convert original Number to target Number class.\n\t\t\t\treturn NumberUtils.convertNumberToTargetClass(number, (Class<Number>) requiredType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Convert stringified value to target Number class.\n\t\t\t\treturn NumberUtils.parseNumber(value.toString(),(Class<Number>) requiredType);\n\t\t\t}\n\t\t}\n\t\telse if (this.conversionService != null && this.conversionService.canConvert(value.getClass(), requiredType)) {\n\t\t\treturn this.conversionService.convert(value, requiredType);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Value [\" + value + \"] is of type [\" + value.getClass().getName() +\n\t\t\t\t\t\"] and cannot be converted to required type [\" + requiredType.getName() + \"]\");\n\t\t}\n\t}\n\n\n\t/**\n\t * Static factory method to create a new {@code SingleColumnRowMapper}.\n\t * @param requiredType the type that each result object is expected to match\n\t * @since 4.1\n\t * @see #newInstance(Class, ConversionService)\n\t */\n\tpublic static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType) {\n\t\treturn new SingleColumnRowMapper<>(requiredType);\n\t}\n\n\t/**\n\t * Static factory method to create a new {@code SingleColumnRowMapper}.\n\t * @param requiredType the type that each result object is expected to match\n\t * @param conversionService the {@link ConversionService} for converting a\n\t * fetched value, or {@code null} for none\n\t * @since 5.0.4\n\t * @see #newInstance(Class)\n\t * @see #setConversionService\n\t */\n\tpublic static <T> SingleColumnRowMapper<T> newInstance(\n\t\t\tClass<T> requiredType, @Nullable ConversionService conversionService) {\n\n\t\tSingleColumnRowMapper<T> rowMapper = newInstance(requiredType);\n\t\trowMapper.setConversionService(conversionService);\n\t\treturn rowMapper;\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.SingleColumnRowMapper#convertValueToRequiredType(value,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given column value to the specified required type.\n\t * Only called if the extracted column value does not match already.\n\t * <p>If the required type is String, the value will simply get stringified\n\t * via {@code toString()}. In case of a Number, the value will be\n\t * converted into a Number, either through number conversion or through\n\t * String parsing (depending on the value type). Otherwise, the value will\n\t * be converted to a required type using the {@link ConversionService}.\n\t * @param value the column value as extracted from {@code getColumnValue()}\n\t * (never {@code null})\n\t * @param requiredType the type that each result object is expected to match\n\t * (never {@code null})\n\t * @return the converted value\n\t * @see #getColumnValue(java.sql.ResultSet, int, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "Object",
    "signature": "protected Object convertValueToRequiredType(Object value, Class<?> requiredType)",
    "source_code": "\tprotected Object convertValueToRequiredType(Object value, Class<?> requiredType) {\n\t\tif (String.class == requiredType) {\n\t\t\treturn value.toString();\n\t\t}\n\t\telse if (Number.class.isAssignableFrom(requiredType)) {\n\t\t\tif (value instanceof Number number) {\n\t\t\t\t// Convert original Number to target Number class.\n\t\t\t\treturn NumberUtils.convertNumberToTargetClass(number, (Class<Number>) requiredType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Convert stringified value to target Number class.\n\t\t\t\treturn NumberUtils.parseNumber(value.toString(),(Class<Number>) requiredType);\n\t\t\t}\n\t\t}\n\t\telse if (this.conversionService != null && this.conversionService.canConvert(value.getClass(), requiredType)) {\n\t\t\treturn this.conversionService.convert(value, requiredType);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Value [\" + value + \"] is of type [\" + value.getClass().getName() +\n\t\t\t\t\t\"] and cannot be converted to required type [\" + requiredType.getName() + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.SingleColumnRowMapper#getColumnValue(rs,index)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC object value for the specified column, using the most\n\t * appropriate value type. Called if no required type has been specified.\n\t * <p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},\n\t * which uses the {@code ResultSet.getObject(index)} method. Additionally,\n\t * it includes a \"hack\" to get around Oracle returning a non-standard object for\n\t * their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}\n\t * javadoc for details.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @return the Object value\n\t * @throws SQLException in case of extraction failure\n\t * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "index"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "Object",
    "signature": "protected Object getColumnValue(ResultSet rs, int index)",
    "source_code": "\tprotected Object getColumnValue(ResultSet rs, int index) throws SQLException {\n\t\treturn JdbcUtils.getResultSetValue(rs, index);\n\t}"
  },
  "org.springframework.jdbc.core.SingleColumnRowMapper#getColumnValue(rs,index,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC object value for the specified column.\n\t * <p>The default implementation calls\n\t * {@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}.\n\t * If no required type has been specified, this method delegates to\n\t * {@code getColumnValue(rs, index)}, which basically calls\n\t * {@code ResultSet.getObject(index)} but applies some additional\n\t * default conversion to appropriate value types.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @param requiredType the type that each result object is expected to match\n\t * (or {@code null} if none specified)\n\t * @return the Object value\n\t * @throws SQLException in case of extraction failure\n\t * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)\n\t * @see #getColumnValue(java.sql.ResultSet, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "index",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "Object",
    "signature": "protected Object getColumnValue(ResultSet rs, int index, @Nullable Class<?> requiredType)",
    "source_code": "\tprotected Object getColumnValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {\n\t\tif (requiredType != null) {\n\t\t\treturn JdbcUtils.getResultSetValue(rs, index, requiredType);\n\t\t}\n\t\telse {\n\t\t\t// No required type specified -> perform default extraction.\n\t\t\treturn getColumnValue(rs, index);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.SingleColumnRowMapper#mapRow(rs,rowNum)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract a value for the single column in the current row.\n\t * <p>Validates that there is only one column selected,\n\t * then delegates to {@code getColumnValue()} and also\n\t * {@code convertValueToRequiredType}, if necessary.\n\t * @see java.sql.ResultSetMetaData#getColumnCount()\n\t * @see #getColumnValue(java.sql.ResultSet, int, Class)\n\t * @see #convertValueToRequiredType(Object, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "rowNum"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "T",
    "signature": "public T mapRow(ResultSet rs, int rowNum)",
    "source_code": "\tpublic T mapRow(ResultSet rs, int rowNum) throws SQLException {\n\t\t// Validate column count.\n\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\tint nrOfColumns = rsmd.getColumnCount();\n\t\tif (nrOfColumns != 1) {\n\t\t\tthrow new IncorrectResultSetColumnCountException(1, nrOfColumns);\n\t\t}\n\n\t\t// Extract column value from JDBC ResultSet.\n\t\tObject result = getColumnValue(rs, 1, this.requiredType);\n\t\tif (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {\n\t\t\t// Extracted value does not match already: try to convert it.\n\t\t\ttry {\n\t\t\t\treturn (T) convertValueToRequiredType(result, this.requiredType);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tthrow new TypeMismatchDataAccessException(\n\t\t\t\t\t\t\"Type mismatch affecting row number \" + rowNum + \" and column type '\" +\n\t\t\t\t\t\trsmd.getColumnTypeName(1) + \"': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn (T) result;\n\t}"
  },
  "org.springframework.jdbc.core.SingleColumnRowMapper#newInstance(requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new {@code SingleColumnRowMapper}.\n\t * @param requiredType the type that each result object is expected to match\n\t * @since 4.1\n\t * @see #newInstance(Class, ConversionService)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "SingleColumnRowMapper<T>",
    "signature": "public SingleColumnRowMapper<T> newInstance(Class<T> requiredType)",
    "source_code": "\tpublic static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType) {\n\t\treturn new SingleColumnRowMapper<>(requiredType);\n\t}"
  },
  "org.springframework.jdbc.core.SingleColumnRowMapper#newInstance(requiredType,conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new {@code SingleColumnRowMapper}.\n\t * @param requiredType the type that each result object is expected to match\n\t * @param conversionService the {@link ConversionService} for converting a\n\t * fetched value, or {@code null} for none\n\t * @since 5.0.4\n\t * @see #newInstance(Class)\n\t * @see #setConversionService\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "SingleColumnRowMapper<T>",
    "signature": "public SingleColumnRowMapper<T> newInstance(Class<T> requiredType, @Nullable ConversionService conversionService)",
    "source_code": "\tpublic static <T> SingleColumnRowMapper<T> newInstance("
  },
  "org.springframework.jdbc.core.SingleColumnRowMapper#setConversionService(conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a {@link ConversionService} for converting a fetched value.\n\t * <p>Default is the {@link DefaultConversionService}.\n\t * @since 5.0.4\n\t * @see DefaultConversionService#getSharedInstance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void setConversionService(@Nullable ConversionService conversionService)",
    "source_code": "\tpublic void setConversionService(@Nullable ConversionService conversionService) {\n\t\tthis.conversionService = conversionService;\n\t}"
  },
  "org.springframework.jdbc.core.SingleColumnRowMapper#setRequiredType(requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the type that each result object is expected to match.\n\t * <p>If not specified, the column value will be exposed as\n\t * returned by the JDBC driver.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void setRequiredType(Class<T> requiredType)",
    "source_code": "\tpublic void setRequiredType(Class<T> requiredType) {\n\t\tthis.requiredType = ClassUtils.resolvePrimitiveIfNecessary(requiredType);\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Class to manage context meta-data used for the configuration\n * and execution of a stored procedure call.\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @author Kiril Nugmanov\n * @since 2.5\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "signature": "public class CallMetaDataContext",
    "source_code": "public class CallMetaDataContext {\n\n\t// Logger available to subclasses\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t// Name of procedure to call\n\t@Nullable\n\tprivate String procedureName;\n\n\t// Name of catalog for call\n\t@Nullable\n\tprivate String catalogName;\n\n\t// Name of schema for call\n\t@Nullable\n\tprivate String schemaName;\n\n\t// List of SqlParameter objects to be used in call execution\n\tprivate List<SqlParameter> callParameters = new ArrayList<>();\n\n\t// Actual name to use for the return value in the output map\n\t@Nullable\n\tprivate String actualFunctionReturnName;\n\n\t// Set of in parameter names to exclude use for any not listed\n\tprivate Set<String> limitedInParameterNames = new HashSet<>();\n\n\t// List of SqlParameter names for out parameters\n\tprivate List<String> outParameterNames = new ArrayList<>();\n\n\t// Indicates whether this is a procedure or a function\n\tprivate boolean function = false;\n\n\t// Indicates whether this procedure's return value should be included\n\tprivate boolean returnValueRequired = false;\n\n\t// Should we access call parameter meta-data info or not\n\tprivate boolean accessCallParameterMetaData = true;\n\n\t// Should we bind parameter by name\n\tprivate boolean namedBinding;\n\n\t// The provider of call meta-data\n\t@Nullable\n\tprivate CallMetaDataProvider metaDataProvider;\n\n\n\t/**\n\t * Specify the name used for the return value of the function.\n\t */\n\tpublic void setFunctionReturnName(String functionReturnName) {\n\t\tthis.actualFunctionReturnName = functionReturnName;\n\t}\n\n\t/**\n\t * Get the name used for the return value of the function.\n\t */\n\tpublic String getFunctionReturnName() {\n\t\treturn (this.actualFunctionReturnName != null ? this.actualFunctionReturnName : \"return\");\n\t}\n\n\t/**\n\t * Specify a limited set of in parameters to be used.\n\t */\n\tpublic void setLimitedInParameterNames(Set<String> limitedInParameterNames) {\n\t\tthis.limitedInParameterNames = limitedInParameterNames;\n\t}\n\n\t/**\n\t * Get a limited set of in parameters to be used.\n\t */\n\tpublic Set<String> getLimitedInParameterNames() {\n\t\treturn this.limitedInParameterNames;\n\t}\n\n\t/**\n\t * Specify the names of the out parameters.\n\t */\n\tpublic void setOutParameterNames(List<String> outParameterNames) {\n\t\tthis.outParameterNames = outParameterNames;\n\t}\n\n\t/**\n\t * Get a list of the out parameter names.\n\t */\n\tpublic List<String> getOutParameterNames() {\n\t\treturn this.outParameterNames;\n\t}\n\n\t/**\n\t * Specify the name of the procedure.\n\t */\n\tpublic void setProcedureName(@Nullable String procedureName) {\n\t\tthis.procedureName = procedureName;\n\t}\n\n\t/**\n\t * Get the name of the procedure.\n\t */\n\t@Nullable\n\tpublic String getProcedureName() {\n\t\treturn this.procedureName;\n\t}\n\n\t/**\n\t * Specify the name of the catalog.\n\t */\n\tpublic void setCatalogName(@Nullable String catalogName) {\n\t\tthis.catalogName = catalogName;\n\t}\n\n\t/**\n\t * Get the name of the catalog.\n\t */\n\t@Nullable\n\tpublic String getCatalogName() {\n\t\treturn this.catalogName;\n\t}\n\n\t/**\n\t * Specify the name of the schema.\n\t */\n\tpublic void setSchemaName(@Nullable String schemaName) {\n\t\tthis.schemaName = schemaName;\n\t}\n\n\t/**\n\t * Get the name of the schema.\n\t */\n\t@Nullable\n\tpublic String getSchemaName() {\n\t\treturn this.schemaName;\n\t}\n\n\t/**\n\t * Specify whether this call is a function call.\n\t */\n\tpublic void setFunction(boolean function) {\n\t\tthis.function = function;\n\t}\n\n\t/**\n\t * Check whether this call is a function call.\n\t */\n\tpublic boolean isFunction() {\n\t\treturn this.function;\n\t}\n\n\t/**\n\t * Specify whether a return value is required.\n\t */\n\tpublic void setReturnValueRequired(boolean returnValueRequired) {\n\t\tthis.returnValueRequired = returnValueRequired;\n\t}\n\n\t/**\n\t * Check whether a return value is required.\n\t */\n\tpublic boolean isReturnValueRequired() {\n\t\treturn this.returnValueRequired;\n\t}\n\n\t/**\n\t * Specify whether call parameter meta-data should be accessed.\n\t */\n\tpublic void setAccessCallParameterMetaData(boolean accessCallParameterMetaData) {\n\t\tthis.accessCallParameterMetaData = accessCallParameterMetaData;\n\t}\n\n\t/**\n\t * Check whether call parameter meta-data should be accessed.\n\t */\n\tpublic boolean isAccessCallParameterMetaData() {\n\t\treturn this.accessCallParameterMetaData;\n\t}\n\n\t/**\n\t * Specify whether parameters should be bound by name.\n\t * @since 4.2\n\t */\n\tpublic void setNamedBinding(boolean namedBinding) {\n\t\tthis.namedBinding = namedBinding;\n\t}\n\n\t/**\n\t * Check whether parameters should be bound by name.\n\t * @since 4.2\n\t */\n\tpublic boolean isNamedBinding() {\n\t\treturn this.namedBinding;\n\t}\n\n\n\t/**\n\t * Initialize this class with meta-data from the database.\n\t * @param dataSource the DataSource used to retrieve meta-data\n\t */\n\tpublic void initializeMetaData(DataSource dataSource) {\n\t\tthis.metaDataProvider = CallMetaDataProviderFactory.createMetaDataProvider(dataSource, this);\n\t}\n\n\tprivate CallMetaDataProvider obtainMetaDataProvider() {\n\t\tAssert.state(this.metaDataProvider != null, \"No CallMetaDataProvider - call initializeMetaData first\");\n\t\treturn this.metaDataProvider;\n\t}\n\n\t/**\n\t * Create a ReturnResultSetParameter/SqlOutParameter depending on the support provided\n\t * by the JDBC driver used for the database in use.\n\t * @param parameterName the name of the parameter (also used as the name of the List returned in the output)\n\t * @param rowMapper a RowMapper implementation used to map the data returned in the result set\n\t * @return the appropriate SqlParameter\n\t */\n\tpublic SqlParameter createReturnResultSetParameter(String parameterName, RowMapper<?> rowMapper) {\n\t\tCallMetaDataProvider provider = obtainMetaDataProvider();\n\t\tif (provider.isReturnResultSetSupported()) {\n\t\t\treturn new SqlReturnResultSet(parameterName, rowMapper);\n\t\t}\n\t\telse {\n\t\t\tif (provider.isRefCursorSupported()) {\n\t\t\t\treturn new SqlOutParameter(parameterName, provider.getRefCursorSqlType(), rowMapper);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\"Return of a ResultSet from a stored procedure is not supported\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the name of the single out parameter for this call.\n\t * If there are multiple parameters, the name of the first one will be returned.\n\t */\n\t@Nullable\n\tpublic String getScalarOutParameterName() {\n\t\tif (isFunction()) {\n\t\t\treturn getFunctionReturnName();\n\t\t}\n\t\telse {\n\t\t\tif (this.outParameterNames.size() > 1) {\n\t\t\t\tlogger.info(\"Accessing single output value when procedure has more than one output parameter\");\n\t\t\t}\n\t\t\treturn (!this.outParameterNames.isEmpty() ? this.outParameterNames.get(0) : null);\n\t\t}\n\t}\n\n\t/**\n\t * Get the List of SqlParameter objects to be used in call execution.\n\t */\n\tpublic List<SqlParameter> getCallParameters() {\n\t\treturn this.callParameters;\n\t}\n\n\t/**\n\t * Process the list of parameters provided, and if procedure column meta-data is used,\n\t * the parameters will be matched against the meta-data information and any missing\n\t * ones will be automatically included.\n\t * @param parameters the list of parameters to use as a base\n\t */\n\tpublic void processParameters(List<SqlParameter> parameters) {\n\t\tthis.callParameters = reconcileParameters(parameters);\n\t}\n\n\t/**\n\t * Reconcile the provided parameters with available meta-data and add new ones where appropriate.\n\t */\n\tprotected List<SqlParameter> reconcileParameters(List<SqlParameter> parameters) {\n\t\tCallMetaDataProvider provider = obtainMetaDataProvider();\n\n\t\tfinal List<SqlParameter> declaredReturnParams = new ArrayList<>();\n\t\tfinal Map<String, SqlParameter> declaredParams = new LinkedHashMap<>();\n\t\tboolean returnDeclared = false;\n\t\tList<String> outParamNames = new ArrayList<>();\n\t\tList<String> metaDataParamNames = new ArrayList<>();\n\n\t\t// Get the names of the meta-data parameters\n\t\tfor (CallParameterMetaData meta : provider.getCallParameterMetaData()) {\n\t\t\tif (!meta.isReturnParameter()) {\n\t\t\t\tmetaDataParamNames.add(lowerCase(meta.getParameterName()));\n\t\t\t}\n\t\t}\n\n\t\t// Separate implicit return parameters from explicit parameters...\n\t\tfor (SqlParameter param : parameters) {\n\t\t\tif (param.isResultsParameter()) {\n\t\t\t\tdeclaredReturnParams.add(param);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString paramName = param.getName();\n\t\t\t\tif (paramName == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Anonymous parameters not supported for calls - \" +\n\t\t\t\t\t\t\t\"please specify a name for the parameter of SQL type \" + param.getSqlType());\n\t\t\t\t}\n\t\t\t\tString paramNameToMatch = lowerCase(provider.parameterNameToUse(paramName));\n\t\t\t\tdeclaredParams.put(paramNameToMatch, param);\n\t\t\t\tif (param instanceof SqlOutParameter) {\n\t\t\t\t\toutParamNames.add(paramName);\n\t\t\t\t\tif (isFunction() && !metaDataParamNames.contains(paramNameToMatch) && !returnDeclared) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Using declared out parameter '\" + paramName +\n\t\t\t\t\t\t\t\t\t\"' for function return value\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.actualFunctionReturnName = paramName;\n\t\t\t\t\t\treturnDeclared = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsetOutParameterNames(outParamNames);\n\n\t\tList<SqlParameter> workParams = new ArrayList<>(declaredReturnParams);\n\t\tif (!provider.isProcedureColumnMetaDataUsed()) {\n\t\t\tworkParams.addAll(declaredParams.values());\n\t\t\treturn workParams;\n\t\t}\n\n\t\tMap<String, String> limitedInParamNamesMap = CollectionUtils.newHashMap(this.limitedInParameterNames.size());\n\t\tfor (String limitedParamName : this.limitedInParameterNames) {\n\t\t\tlimitedInParamNamesMap.put(lowerCase(provider.parameterNameToUse(limitedParamName)), limitedParamName);\n\t\t}\n\n\t\tfor (CallParameterMetaData meta : provider.getCallParameterMetaData()) {\n\t\t\tString paramName = meta.getParameterName();\n\t\t\tString paramNameToCheck = null;\n\t\t\tif (paramName != null) {\n\t\t\t\tparamNameToCheck = lowerCase(provider.parameterNameToUse(paramName));\n\t\t\t}\n\t\t\tString paramNameToUse = provider.parameterNameToUse(paramName);\n\t\t\tif (declaredParams.containsKey(paramNameToCheck) || (meta.isReturnParameter() && returnDeclared)) {\n\t\t\t\tSqlParameter param;\n\t\t\t\tif (meta.isReturnParameter()) {\n\t\t\t\t\tparam = declaredParams.get(getFunctionReturnName());\n\t\t\t\t\tif (param == null && !getOutParameterNames().isEmpty()) {\n\t\t\t\t\t\tparam = declaredParams.get(getOutParameterNames().get(0).toLowerCase());\n\t\t\t\t\t}\n\t\t\t\t\tif (param == null) {\n\t\t\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\t\t\"Unable to locate declared parameter for function return value - \" +\n\t\t\t\t\t\t\t\t\" add an SqlOutParameter with name '\" + getFunctionReturnName() + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.actualFunctionReturnName = param.getName();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparam = declaredParams.get(paramNameToCheck);\n\t\t\t\t}\n\t\t\t\tif (param != null) {\n\t\t\t\t\tworkParams.add(param);\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Using declared parameter for '\" +\n\t\t\t\t\t\t\t\t(paramNameToUse != null ? paramNameToUse : getFunctionReturnName()) + \"'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (meta.isReturnParameter()) {\n\t\t\t\t\t// DatabaseMetaData.procedureColumnReturn or possibly procedureColumnResult\n\t\t\t\t\tif (!isFunction() && !isReturnValueRequired() && paramName != null &&\n\t\t\t\t\t\t\tprovider.byPassReturnParameter(paramName)) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Bypassing meta-data return parameter for '\" + paramName + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tString returnNameToUse =\n\t\t\t\t\t\t\t\t(StringUtils.hasLength(paramNameToUse) ? paramNameToUse : getFunctionReturnName());\n\t\t\t\t\t\tworkParams.add(provider.createDefaultOutParameter(returnNameToUse, meta));\n\t\t\t\t\t\tif (isFunction()) {\n\t\t\t\t\t\t\tthis.actualFunctionReturnName = returnNameToUse;\n\t\t\t\t\t\t\toutParamNames.add(returnNameToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Added meta-data return parameter for '\" + returnNameToUse + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (paramNameToUse == null) {\n\t\t\t\t\t\tparamNameToUse = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tif (meta.getParameterType() == DatabaseMetaData.procedureColumnOut) {\n\t\t\t\t\t\tworkParams.add(provider.createDefaultOutParameter(paramNameToUse, meta));\n\t\t\t\t\t\toutParamNames.add(paramNameToUse);\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Added meta-data out parameter for '\" + paramNameToUse + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (meta.getParameterType() == DatabaseMetaData.procedureColumnInOut) {\n\t\t\t\t\t\tworkParams.add(provider.createDefaultInOutParameter(paramNameToUse, meta));\n\t\t\t\t\t\toutParamNames.add(paramNameToUse);\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Added meta-data in-out parameter for '\" + paramNameToUse + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// DatabaseMetaData.procedureColumnIn or possibly procedureColumnUnknown\n\t\t\t\t\t\tif (this.limitedInParameterNames.isEmpty() ||\n\t\t\t\t\t\t\t\tlimitedInParamNamesMap.containsKey(lowerCase(paramNameToUse))) {\n\t\t\t\t\t\t\tworkParams.add(provider.createDefaultInParameter(paramNameToUse, meta));\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Added meta-data in parameter for '\" + paramNameToUse + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Limited set of parameters \" + limitedInParamNamesMap.keySet() +\n\t\t\t\t\t\t\t\t\t\t\" skipped parameter for '\" + paramNameToUse + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn workParams;\n\t}\n\n\t/**\n\t * Match input parameter values with the parameters declared to be used in the call.\n\t * @param parameterSource the input values\n\t * @return a Map containing the matched parameter names with the value taken from the input\n\t */\n\tpublic Map<String, Object> matchInParameterValuesWithCallParameters(SqlParameterSource parameterSource) {\n\t\t// For parameter source lookups we need to provide case-insensitive lookup support\n\t\t// since the database meta-data is not necessarily providing case-sensitive parameter names.\n\t\tMap<String, String> caseInsensitiveParameterNames =\n\t\t\t\tSqlParameterSourceUtils.extractCaseInsensitiveParameterNames(parameterSource);\n\n\t\tMap<String, String> callParameterNames = CollectionUtils.newHashMap(this.callParameters.size());\n\t\tMap<String, Object> matchedParameters = CollectionUtils.newHashMap(this.callParameters.size());\n\t\tfor (SqlParameter parameter : this.callParameters) {\n\t\t\tif (parameter.isInputValueProvided()) {\n\t\t\t\tString parameterName = parameter.getName();\n\t\t\t\tString parameterNameToMatch = obtainMetaDataProvider().parameterNameToUse(parameterName);\n\t\t\t\tif (parameterNameToMatch != null) {\n\t\t\t\t\tcallParameterNames.put(parameterNameToMatch.toLowerCase(), parameterName);\n\t\t\t\t}\n\t\t\t\tif (parameterName != null) {\n\t\t\t\t\tif (parameterSource.hasValue(parameterName)) {\n\t\t\t\t\t\tmatchedParameters.put(parameterName,\n\t\t\t\t\t\t\t\tSqlParameterSourceUtils.getTypedValue(parameterSource, parameterName));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tString lowerCaseName = parameterName.toLowerCase();\n\t\t\t\t\t\tif (parameterSource.hasValue(lowerCaseName)) {\n\t\t\t\t\t\t\tmatchedParameters.put(parameterName,\n\t\t\t\t\t\t\t\t\tSqlParameterSourceUtils.getTypedValue(parameterSource, lowerCaseName));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tString englishLowerCaseName = parameterName.toLowerCase(Locale.ENGLISH);\n\t\t\t\t\t\t\tif (parameterSource.hasValue(englishLowerCaseName)) {\n\t\t\t\t\t\t\t\tmatchedParameters.put(parameterName,\n\t\t\t\t\t\t\t\t\t\tSqlParameterSourceUtils.getTypedValue(parameterSource, englishLowerCaseName));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tString propertyName = JdbcUtils.convertUnderscoreNameToPropertyName(parameterName);\n\t\t\t\t\t\t\t\tif (parameterSource.hasValue(propertyName)) {\n\t\t\t\t\t\t\t\t\tmatchedParameters.put(parameterName,\n\t\t\t\t\t\t\t\t\t\t\tSqlParameterSourceUtils.getTypedValue(parameterSource, propertyName));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tif (caseInsensitiveParameterNames.containsKey(lowerCaseName)) {\n\t\t\t\t\t\t\t\t\t\tString sourceName = caseInsensitiveParameterNames.get(lowerCaseName);\n\t\t\t\t\t\t\t\t\t\tmatchedParameters.put(parameterName,\n\t\t\t\t\t\t\t\t\t\t\t\tSqlParameterSourceUtils.getTypedValue(parameterSource, sourceName));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (logger.isInfoEnabled()) {\n\t\t\t\t\t\t\t\t\t\tlogger.info(\"Unable to locate the corresponding parameter value for '\" +\n\t\t\t\t\t\t\t\t\t\t\t\tparameterName + \"' within the parameter values provided: \" +\n\t\t\t\t\t\t\t\t\t\t\t\tcaseInsensitiveParameterNames.values());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Matching \" + caseInsensitiveParameterNames.values() + \" with \" + callParameterNames.values());\n\t\t\tlogger.debug(\"Found match for \" + matchedParameters.keySet());\n\t\t}\n\t\treturn matchedParameters;\n\t}\n\n\t/**\n\t * Match input parameter values with the parameters declared to be used in the call.\n\t * @param inParameters the input values\n\t * @return a Map containing the matched parameter names with the value taken from the input\n\t */\n\tpublic Map<String, ?> matchInParameterValuesWithCallParameters(Map<String, ?> inParameters) {\n\t\tCallMetaDataProvider provider = obtainMetaDataProvider();\n\t\tif (!provider.isProcedureColumnMetaDataUsed()) {\n\t\t\treturn inParameters;\n\t\t}\n\n\t\tMap<String, String> callParameterNames = CollectionUtils.newHashMap(this.callParameters.size());\n\t\tfor (SqlParameter parameter : this.callParameters) {\n\t\t\tif (parameter.isInputValueProvided()) {\n\t\t\t\tString parameterName =  parameter.getName();\n\t\t\t\tString parameterNameToMatch = provider.parameterNameToUse(parameterName);\n\t\t\t\tif (parameterNameToMatch != null) {\n\t\t\t\t\tcallParameterNames.put(parameterNameToMatch.toLowerCase(), parameterName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tMap<String, Object> matchedParameters = CollectionUtils.newHashMap(inParameters.size());\n\t\tinParameters.forEach((parameterName, parameterValue) -> {\n\t\t\tString parameterNameToMatch = provider.parameterNameToUse(parameterName);\n\t\t\tString callParameterName = callParameterNames.get(lowerCase(parameterNameToMatch));\n\t\t\tif (callParameterName == null) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tObject value = parameterValue;\n\t\t\t\t\tif (value instanceof SqlParameterValue sqlParameterValue) {\n\t\t\t\t\t\tvalue = sqlParameterValue.getValue();\n\t\t\t\t\t}\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\tlogger.debug(\"Unable to locate the corresponding IN or IN-OUT parameter for \\\"\" +\n\t\t\t\t\t\t\t\tparameterName + \"\\\" in the parameters used: \" + callParameterNames.keySet());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmatchedParameters.put(callParameterName, parameterValue);\n\t\t\t}\n\t\t});\n\n\t\tif (matchedParameters.size() < callParameterNames.size()) {\n\t\t\tfor (String parameterName : callParameterNames.keySet()) {\n\t\t\t\tString parameterNameToMatch = provider.parameterNameToUse(parameterName);\n\t\t\t\tString callParameterName = callParameterNames.get(lowerCase(parameterNameToMatch));\n\t\t\t\tif (!matchedParameters.containsKey(callParameterName) && logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"Unable to locate the corresponding parameter value for '\" + parameterName +\n\t\t\t\t\t\t\t\"' within the parameter values provided: \" + inParameters.keySet());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Matching \" + inParameters.keySet() + \" with \" + callParameterNames.values());\n\t\t\tlogger.debug(\"Found match for \" + matchedParameters.keySet());\n\t\t}\n\t\treturn matchedParameters;\n\t}\n\n\tpublic Map<String, ?> matchInParameterValuesWithCallParameters(Object[] parameterValues) {\n\t\tMap<String, Object> matchedParameters = CollectionUtils.newHashMap(parameterValues.length);\n\t\tint i = 0;\n\t\tfor (SqlParameter parameter : this.callParameters) {\n\t\t\tif (parameter.isInputValueProvided()) {\n\t\t\t\tString parameterName =  parameter.getName();\n\t\t\t\tmatchedParameters.put(parameterName, parameterValues[i++]);\n\t\t\t}\n\t\t}\n\t\treturn matchedParameters;\n\t}\n\n\t/**\n\t * Build the call string based on configuration and meta-data information.\n\t * @return the call string to be used\n\t */\n\tpublic String createCallString() {\n\t\tAssert.state(this.metaDataProvider != null, \"No CallMetaDataProvider available\");\n\n\t\tStringBuilder callString;\n\t\tint parameterCount = 0;\n\t\tString catalogNameToUse;\n\t\tString schemaNameToUse;\n\n\t\t// For Oracle where catalogs are not supported we need to reverse the schema name\n\t\t// and the catalog name since the catalog is used for the package name\n\t\tif (this.metaDataProvider.isSupportsSchemasInProcedureCalls() &&\n\t\t\t\t!this.metaDataProvider.isSupportsCatalogsInProcedureCalls()) {\n\t\t\tschemaNameToUse = this.metaDataProvider.catalogNameToUse(getCatalogName());\n\t\t\tcatalogNameToUse = this.metaDataProvider.schemaNameToUse(getSchemaName());\n\t\t}\n\t\telse {\n\t\t\tcatalogNameToUse = this.metaDataProvider.catalogNameToUse(getCatalogName());\n\t\t\tschemaNameToUse = this.metaDataProvider.schemaNameToUse(getSchemaName());\n\t\t}\n\n\t\tif (isFunction() || isReturnValueRequired()) {\n\t\t\tcallString = new StringBuilder(\"{? = call \");\n\t\t\tparameterCount = -1;\n\t\t}\n\t\telse {\n\t\t\tcallString = new StringBuilder(\"{call \");\n\t\t}\n\n\t\tif (StringUtils.hasLength(catalogNameToUse)) {\n\t\t\tcallString.append(catalogNameToUse).append('.');\n\t\t}\n\t\tif (StringUtils.hasLength(schemaNameToUse)) {\n\t\t\tcallString.append(schemaNameToUse).append('.');\n\t\t}\n\t\tcallString.append(this.metaDataProvider.procedureNameToUse(getProcedureName()));\n\t\tcallString.append('(');\n\n\t\tfor (SqlParameter parameter : this.callParameters) {\n\t\t\tif (!parameter.isResultsParameter()) {\n\t\t\t\tif (parameterCount > 0) {\n\t\t\t\t\tcallString.append(\", \");\n\t\t\t\t}\n\t\t\t\tif (parameterCount >= 0) {\n\t\t\t\t\tcallString.append(createParameterBinding(parameter));\n\t\t\t\t}\n\t\t\t\tparameterCount++;\n\t\t\t}\n\t\t}\n\t\tcallString.append(\")}\");\n\n\t\treturn callString.toString();\n\t}\n\n\t/**\n\t * Build the parameter binding fragment.\n\t * @param parameter call parameter\n\t * @return parameter binding fragment\n\t * @since 4.2\n\t */\n\tprotected String createParameterBinding(SqlParameter parameter) {\n\t\treturn (isNamedBinding() ? parameter.getName() + \" => ?\" : \"?\");\n\t}\n\n\tprivate static String lowerCase(@Nullable String paramName) {\n\t\treturn (paramName != null ? paramName.toLowerCase() : \"\");\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#createCallString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build the call string based on configuration and meta-data information.\n\t * @return the call string to be used\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 620
    },
    "return": "String",
    "signature": "public String createCallString()",
    "source_code": "\tpublic String createCallString() {\n\t\tAssert.state(this.metaDataProvider != null, \"No CallMetaDataProvider available\");\n\n\t\tStringBuilder callString;\n\t\tint parameterCount = 0;\n\t\tString catalogNameToUse;\n\t\tString schemaNameToUse;\n\n\t\t// For Oracle where catalogs are not supported we need to reverse the schema name\n\t\t// and the catalog name since the catalog is used for the package name\n\t\tif (this.metaDataProvider.isSupportsSchemasInProcedureCalls() &&\n\t\t\t\t!this.metaDataProvider.isSupportsCatalogsInProcedureCalls()) {\n\t\t\tschemaNameToUse = this.metaDataProvider.catalogNameToUse(getCatalogName());\n\t\t\tcatalogNameToUse = this.metaDataProvider.schemaNameToUse(getSchemaName());\n\t\t}\n\t\telse {\n\t\t\tcatalogNameToUse = this.metaDataProvider.catalogNameToUse(getCatalogName());\n\t\t\tschemaNameToUse = this.metaDataProvider.schemaNameToUse(getSchemaName());\n\t\t}\n\n\t\tif (isFunction() || isReturnValueRequired()) {\n\t\t\tcallString = new StringBuilder(\"{? = call \");\n\t\t\tparameterCount = -1;\n\t\t}\n\t\telse {\n\t\t\tcallString = new StringBuilder(\"{call \");\n\t\t}\n\n\t\tif (StringUtils.hasLength(catalogNameToUse)) {\n\t\t\tcallString.append(catalogNameToUse).append('.');\n\t\t}\n\t\tif (StringUtils.hasLength(schemaNameToUse)) {\n\t\t\tcallString.append(schemaNameToUse).append('.');\n\t\t}\n\t\tcallString.append(this.metaDataProvider.procedureNameToUse(getProcedureName()));\n\t\tcallString.append('(');\n\n\t\tfor (SqlParameter parameter : this.callParameters) {\n\t\t\tif (!parameter.isResultsParameter()) {\n\t\t\t\tif (parameterCount > 0) {\n\t\t\t\t\tcallString.append(\", \");\n\t\t\t\t}\n\t\t\t\tif (parameterCount >= 0) {\n\t\t\t\t\tcallString.append(createParameterBinding(parameter));\n\t\t\t\t}\n\t\t\t\tparameterCount++;\n\t\t\t}\n\t\t}\n\t\tcallString.append(\")}\");\n\n\t\treturn callString.toString();\n\t}\n\n\t/**\n\t * Build the parameter binding fragment.\n\t * @param parameter call parameter\n\t * @return parameter binding fragment\n\t * @since 4.2\n\t */\n\tprotected String createParameterBinding(SqlParameter parameter) {\n\t\treturn (isNamedBinding() ? parameter.getName() + \" => ?\" : \"?\");\n\t}\n\n\tprivate static String lowerCase(@Nullable String paramName) {\n\t\treturn (paramName != null ? paramName.toLowerCase() : \"\");\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#createParameterBinding(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build the parameter binding fragment.\n\t * @param parameter call parameter\n\t * @return parameter binding fragment\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 679
    },
    "return": "String",
    "signature": "protected String createParameterBinding(SqlParameter parameter)",
    "source_code": "\tprotected String createParameterBinding(SqlParameter parameter) {\n\t\treturn (isNamedBinding() ? parameter.getName() + \" => ?\" : \"?\");\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#createReturnResultSetParameter(parameterName,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a ReturnResultSetParameter/SqlOutParameter depending on the support provided\n\t * by the JDBC driver used for the database in use.\n\t * @param parameterName the name of the parameter (also used as the name of the List returned in the output)\n\t * @param rowMapper a RowMapper implementation used to map the data returned in the result set\n\t * @return the appropriate SqlParameter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterName",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "SqlParameter",
    "signature": "public SqlParameter createReturnResultSetParameter(String parameterName, RowMapper<?> rowMapper)",
    "source_code": "\tpublic SqlParameter createReturnResultSetParameter(String parameterName, RowMapper<?> rowMapper) {\n\t\tCallMetaDataProvider provider = obtainMetaDataProvider();\n\t\tif (provider.isReturnResultSetSupported()) {\n\t\t\treturn new SqlReturnResultSet(parameterName, rowMapper);\n\t\t}\n\t\telse {\n\t\t\tif (provider.isRefCursorSupported()) {\n\t\t\t\treturn new SqlOutParameter(parameterName, provider.getRefCursorSqlType(), rowMapper);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\"Return of a ResultSet from a stored procedure is not supported\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#getCallParameters()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the List of SqlParameter objects to be used in call execution.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "List<SqlParameter>",
    "signature": "public List<SqlParameter> getCallParameters()",
    "source_code": "\tpublic List<SqlParameter> getCallParameters() {\n\t\treturn this.callParameters;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#getCatalogName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the name of the catalog.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "String",
    "signature": "public String getCatalogName()",
    "source_code": "\tpublic String getCatalogName() {\n\t\treturn this.catalogName;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#getFunctionReturnName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the name used for the return value of the function.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "String",
    "signature": "public String getFunctionReturnName()",
    "source_code": "\tpublic String getFunctionReturnName() {\n\t\treturn (this.actualFunctionReturnName != null ? this.actualFunctionReturnName : \"return\");\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#getLimitedInParameterNames()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get a limited set of in parameters to be used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "Set<String>",
    "signature": "public Set<String> getLimitedInParameterNames()",
    "source_code": "\tpublic Set<String> getLimitedInParameterNames() {\n\t\treturn this.limitedInParameterNames;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#getOutParameterNames()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get a list of the out parameter names.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "List<String>",
    "signature": "public List<String> getOutParameterNames()",
    "source_code": "\tpublic List<String> getOutParameterNames() {\n\t\treturn this.outParameterNames;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#getProcedureName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the name of the procedure.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "String",
    "signature": "public String getProcedureName()",
    "source_code": "\tpublic String getProcedureName() {\n\t\treturn this.procedureName;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#getScalarOutParameterName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the name of the single out parameter for this call.\n\t * If there are multiple parameters, the name of the first one will be returned.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "String",
    "signature": "public String getScalarOutParameterName()",
    "source_code": "\tpublic String getScalarOutParameterName() {\n\t\tif (isFunction()) {\n\t\t\treturn getFunctionReturnName();\n\t\t}\n\t\telse {\n\t\t\tif (this.outParameterNames.size() > 1) {\n\t\t\t\tlogger.info(\"Accessing single output value when procedure has more than one output parameter\");\n\t\t\t}\n\t\t\treturn (!this.outParameterNames.isEmpty() ? this.outParameterNames.get(0) : null);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#getSchemaName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the name of the schema.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "String",
    "signature": "public String getSchemaName()",
    "source_code": "\tpublic String getSchemaName() {\n\t\treturn this.schemaName;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#initializeMetaData(dataSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize this class with meta-data from the database.\n\t * @param dataSource the DataSource used to retrieve meta-data\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 253
    },
    "return": "void",
    "signature": "public void initializeMetaData(DataSource dataSource)",
    "source_code": "\tpublic void initializeMetaData(DataSource dataSource) {\n\t\tthis.metaDataProvider = CallMetaDataProviderFactory.createMetaDataProvider(dataSource, this);\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#isAccessCallParameterMetaData()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether call parameter meta-data should be accessed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "boolean",
    "signature": "public boolean isAccessCallParameterMetaData()",
    "source_code": "\tpublic boolean isAccessCallParameterMetaData() {\n\t\treturn this.accessCallParameterMetaData;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#isFunction()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether this call is a function call.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "boolean",
    "signature": "public boolean isFunction()",
    "source_code": "\tpublic boolean isFunction() {\n\t\treturn this.function;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#isNamedBinding()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether parameters should be bound by name.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "boolean",
    "signature": "public boolean isNamedBinding()",
    "source_code": "\tpublic boolean isNamedBinding() {\n\t\treturn this.namedBinding;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#isReturnValueRequired()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether a return value is required.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "boolean",
    "signature": "public boolean isReturnValueRequired()",
    "source_code": "\tpublic boolean isReturnValueRequired() {\n\t\treturn this.returnValueRequired;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#matchInParameterValuesWithCallParameters(parameterSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Match input parameter values with the parameters declared to be used in the call.\n\t * @param parameterSource the input values\n\t * @return a Map containing the matched parameter names with the value taken from the input\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterSource"
    ],
    "position": {
      "column": 1,
      "line": 479
    },
    "return": "Object>",
    "signature": "public Object> matchInParameterValuesWithCallParameters(SqlParameterSource parameterSource)",
    "source_code": "\tpublic Map<String, Object> matchInParameterValuesWithCallParameters(SqlParameterSource parameterSource) {\n\t\t// For parameter source lookups we need to provide case-insensitive lookup support\n\t\t// since the database meta-data is not necessarily providing case-sensitive parameter names.\n\t\tMap<String, String> caseInsensitiveParameterNames =\n\t\t\t\tSqlParameterSourceUtils.extractCaseInsensitiveParameterNames(parameterSource);\n\n\t\tMap<String, String> callParameterNames = CollectionUtils.newHashMap(this.callParameters.size());\n\t\tMap<String, Object> matchedParameters = CollectionUtils.newHashMap(this.callParameters.size());\n\t\tfor (SqlParameter parameter : this.callParameters) {\n\t\t\tif (parameter.isInputValueProvided()) {\n\t\t\t\tString parameterName = parameter.getName();\n\t\t\t\tString parameterNameToMatch = obtainMetaDataProvider().parameterNameToUse(parameterName);\n\t\t\t\tif (parameterNameToMatch != null) {\n\t\t\t\t\tcallParameterNames.put(parameterNameToMatch.toLowerCase(), parameterName);\n\t\t\t\t}\n\t\t\t\tif (parameterName != null) {\n\t\t\t\t\tif (parameterSource.hasValue(parameterName)) {\n\t\t\t\t\t\tmatchedParameters.put(parameterName,\n\t\t\t\t\t\t\t\tSqlParameterSourceUtils.getTypedValue(parameterSource, parameterName));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tString lowerCaseName = parameterName.toLowerCase();\n\t\t\t\t\t\tif (parameterSource.hasValue(lowerCaseName)) {\n\t\t\t\t\t\t\tmatchedParameters.put(parameterName,\n\t\t\t\t\t\t\t\t\tSqlParameterSourceUtils.getTypedValue(parameterSource, lowerCaseName));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tString englishLowerCaseName = parameterName.toLowerCase(Locale.ENGLISH);\n\t\t\t\t\t\t\tif (parameterSource.hasValue(englishLowerCaseName)) {\n\t\t\t\t\t\t\t\tmatchedParameters.put(parameterName,\n\t\t\t\t\t\t\t\t\t\tSqlParameterSourceUtils.getTypedValue(parameterSource, englishLowerCaseName));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tString propertyName = JdbcUtils.convertUnderscoreNameToPropertyName(parameterName);\n\t\t\t\t\t\t\t\tif (parameterSource.hasValue(propertyName)) {\n\t\t\t\t\t\t\t\t\tmatchedParameters.put(parameterName,\n\t\t\t\t\t\t\t\t\t\t\tSqlParameterSourceUtils.getTypedValue(parameterSource, propertyName));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tif (caseInsensitiveParameterNames.containsKey(lowerCaseName)) {\n\t\t\t\t\t\t\t\t\t\tString sourceName = caseInsensitiveParameterNames.get(lowerCaseName);\n\t\t\t\t\t\t\t\t\t\tmatchedParameters.put(parameterName,\n\t\t\t\t\t\t\t\t\t\t\t\tSqlParameterSourceUtils.getTypedValue(parameterSource, sourceName));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (logger.isInfoEnabled()) {\n\t\t\t\t\t\t\t\t\t\tlogger.info(\"Unable to locate the corresponding parameter value for '\" +\n\t\t\t\t\t\t\t\t\t\t\t\tparameterName + \"' within the parameter values provided: \" +\n\t\t\t\t\t\t\t\t\t\t\t\tcaseInsensitiveParameterNames.values());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Matching \" + caseInsensitiveParameterNames.values() + \" with \" + callParameterNames.values());\n\t\t\tlogger.debug(\"Found match for \" + matchedParameters.keySet());\n\t\t}\n\t\treturn matchedParameters;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#processParameters(parameters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the list of parameters provided, and if procedure column meta-data is used,\n\t * the parameters will be matched against the meta-data information and any missing\n\t * ones will be automatically included.\n\t * @param parameters the list of parameters to use as a base\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "void",
    "signature": "public void processParameters(List<SqlParameter> parameters)",
    "source_code": "\tpublic void processParameters(List<SqlParameter> parameters) {\n\t\tthis.callParameters = reconcileParameters(parameters);\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#reconcileParameters(parameters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reconcile the provided parameters with available meta-data and add new ones where appropriate.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "List<SqlParameter>",
    "signature": "protected List<SqlParameter> reconcileParameters(List<SqlParameter> parameters)",
    "source_code": "\tprotected List<SqlParameter> reconcileParameters(List<SqlParameter> parameters) {\n\t\tCallMetaDataProvider provider = obtainMetaDataProvider();\n\n\t\tfinal List<SqlParameter> declaredReturnParams = new ArrayList<>();\n\t\tfinal Map<String, SqlParameter> declaredParams = new LinkedHashMap<>();\n\t\tboolean returnDeclared = false;\n\t\tList<String> outParamNames = new ArrayList<>();\n\t\tList<String> metaDataParamNames = new ArrayList<>();\n\n\t\t// Get the names of the meta-data parameters\n\t\tfor (CallParameterMetaData meta : provider.getCallParameterMetaData()) {\n\t\t\tif (!meta.isReturnParameter()) {\n\t\t\t\tmetaDataParamNames.add(lowerCase(meta.getParameterName()));\n\t\t\t}\n\t\t}\n\n\t\t// Separate implicit return parameters from explicit parameters...\n\t\tfor (SqlParameter param : parameters) {\n\t\t\tif (param.isResultsParameter()) {\n\t\t\t\tdeclaredReturnParams.add(param);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString paramName = param.getName();\n\t\t\t\tif (paramName == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Anonymous parameters not supported for calls - \" +\n\t\t\t\t\t\t\t\"please specify a name for the parameter of SQL type \" + param.getSqlType());\n\t\t\t\t}\n\t\t\t\tString paramNameToMatch = lowerCase(provider.parameterNameToUse(paramName));\n\t\t\t\tdeclaredParams.put(paramNameToMatch, param);\n\t\t\t\tif (param instanceof SqlOutParameter) {\n\t\t\t\t\toutParamNames.add(paramName);\n\t\t\t\t\tif (isFunction() && !metaDataParamNames.contains(paramNameToMatch) && !returnDeclared) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Using declared out parameter '\" + paramName +\n\t\t\t\t\t\t\t\t\t\"' for function return value\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.actualFunctionReturnName = paramName;\n\t\t\t\t\t\treturnDeclared = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsetOutParameterNames(outParamNames);\n\n\t\tList<SqlParameter> workParams = new ArrayList<>(declaredReturnParams);\n\t\tif (!provider.isProcedureColumnMetaDataUsed()) {\n\t\t\tworkParams.addAll(declaredParams.values());\n\t\t\treturn workParams;\n\t\t}\n\n\t\tMap<String, String> limitedInParamNamesMap = CollectionUtils.newHashMap(this.limitedInParameterNames.size());\n\t\tfor (String limitedParamName : this.limitedInParameterNames) {\n\t\t\tlimitedInParamNamesMap.put(lowerCase(provider.parameterNameToUse(limitedParamName)), limitedParamName);\n\t\t}\n\n\t\tfor (CallParameterMetaData meta : provider.getCallParameterMetaData()) {\n\t\t\tString paramName = meta.getParameterName();\n\t\t\tString paramNameToCheck = null;\n\t\t\tif (paramName != null) {\n\t\t\t\tparamNameToCheck = lowerCase(provider.parameterNameToUse(paramName));\n\t\t\t}\n\t\t\tString paramNameToUse = provider.parameterNameToUse(paramName);\n\t\t\tif (declaredParams.containsKey(paramNameToCheck) || (meta.isReturnParameter() && returnDeclared)) {\n\t\t\t\tSqlParameter param;\n\t\t\t\tif (meta.isReturnParameter()) {\n\t\t\t\t\tparam = declaredParams.get(getFunctionReturnName());\n\t\t\t\t\tif (param == null && !getOutParameterNames().isEmpty()) {\n\t\t\t\t\t\tparam = declaredParams.get(getOutParameterNames().get(0).toLowerCase());\n\t\t\t\t\t}\n\t\t\t\t\tif (param == null) {\n\t\t\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\t\t\"Unable to locate declared parameter for function return value - \" +\n\t\t\t\t\t\t\t\t\" add an SqlOutParameter with name '\" + getFunctionReturnName() + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.actualFunctionReturnName = param.getName();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparam = declaredParams.get(paramNameToCheck);\n\t\t\t\t}\n\t\t\t\tif (param != null) {\n\t\t\t\t\tworkParams.add(param);\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Using declared parameter for '\" +\n\t\t\t\t\t\t\t\t(paramNameToUse != null ? paramNameToUse : getFunctionReturnName()) + \"'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (meta.isReturnParameter()) {\n\t\t\t\t\t// DatabaseMetaData.procedureColumnReturn or possibly procedureColumnResult\n\t\t\t\t\tif (!isFunction() && !isReturnValueRequired() && paramName != null &&\n\t\t\t\t\t\t\tprovider.byPassReturnParameter(paramName)) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Bypassing meta-data return parameter for '\" + paramName + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tString returnNameToUse =\n\t\t\t\t\t\t\t\t(StringUtils.hasLength(paramNameToUse) ? paramNameToUse : getFunctionReturnName());\n\t\t\t\t\t\tworkParams.add(provider.createDefaultOutParameter(returnNameToUse, meta));\n\t\t\t\t\t\tif (isFunction()) {\n\t\t\t\t\t\t\tthis.actualFunctionReturnName = returnNameToUse;\n\t\t\t\t\t\t\toutParamNames.add(returnNameToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Added meta-data return parameter for '\" + returnNameToUse + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (paramNameToUse == null) {\n\t\t\t\t\t\tparamNameToUse = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tif (meta.getParameterType() == DatabaseMetaData.procedureColumnOut) {\n\t\t\t\t\t\tworkParams.add(provider.createDefaultOutParameter(paramNameToUse, meta));\n\t\t\t\t\t\toutParamNames.add(paramNameToUse);\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Added meta-data out parameter for '\" + paramNameToUse + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (meta.getParameterType() == DatabaseMetaData.procedureColumnInOut) {\n\t\t\t\t\t\tworkParams.add(provider.createDefaultInOutParameter(paramNameToUse, meta));\n\t\t\t\t\t\toutParamNames.add(paramNameToUse);\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Added meta-data in-out parameter for '\" + paramNameToUse + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// DatabaseMetaData.procedureColumnIn or possibly procedureColumnUnknown\n\t\t\t\t\t\tif (this.limitedInParameterNames.isEmpty() ||\n\t\t\t\t\t\t\t\tlimitedInParamNamesMap.containsKey(lowerCase(paramNameToUse))) {\n\t\t\t\t\t\t\tworkParams.add(provider.createDefaultInParameter(paramNameToUse, meta));\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Added meta-data in parameter for '\" + paramNameToUse + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Limited set of parameters \" + limitedInParamNamesMap.keySet() +\n\t\t\t\t\t\t\t\t\t\t\" skipped parameter for '\" + paramNameToUse + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn workParams;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#setAccessCallParameterMetaData(accessCallParameterMetaData)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether call parameter meta-data should be accessed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "accessCallParameterMetaData"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void setAccessCallParameterMetaData(boolean accessCallParameterMetaData)",
    "source_code": "\tpublic void setAccessCallParameterMetaData(boolean accessCallParameterMetaData) {\n\t\tthis.accessCallParameterMetaData = accessCallParameterMetaData;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#setCatalogName(catalogName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the name of the catalog.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "catalogName"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "public void setCatalogName(@Nullable String catalogName)",
    "source_code": "\tpublic void setCatalogName(@Nullable String catalogName) {\n\t\tthis.catalogName = catalogName;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#setFunction(function)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether this call is a function call.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "function"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "void",
    "signature": "public void setFunction(boolean function)",
    "source_code": "\tpublic void setFunction(boolean function) {\n\t\tthis.function = function;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#setFunctionReturnName(functionReturnName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the name used for the return value of the function.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "functionReturnName"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "void",
    "signature": "public void setFunctionReturnName(String functionReturnName)",
    "source_code": "\tpublic void setFunctionReturnName(String functionReturnName) {\n\t\tthis.actualFunctionReturnName = functionReturnName;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#setLimitedInParameterNames(limitedInParameterNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a limited set of in parameters to be used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "limitedInParameterNames"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "void",
    "signature": "public void setLimitedInParameterNames(Set<String> limitedInParameterNames)",
    "source_code": "\tpublic void setLimitedInParameterNames(Set<String> limitedInParameterNames) {\n\t\tthis.limitedInParameterNames = limitedInParameterNames;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#setNamedBinding(namedBinding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether parameters should be bound by name.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "namedBinding"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "void",
    "signature": "public void setNamedBinding(boolean namedBinding)",
    "source_code": "\tpublic void setNamedBinding(boolean namedBinding) {\n\t\tthis.namedBinding = namedBinding;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#setOutParameterNames(outParameterNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the names of the out parameters.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outParameterNames"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void setOutParameterNames(List<String> outParameterNames)",
    "source_code": "\tpublic void setOutParameterNames(List<String> outParameterNames) {\n\t\tthis.outParameterNames = outParameterNames;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#setProcedureName(procedureName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the name of the procedure.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "procedureName"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void setProcedureName(@Nullable String procedureName)",
    "source_code": "\tpublic void setProcedureName(@Nullable String procedureName) {\n\t\tthis.procedureName = procedureName;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#setReturnValueRequired(returnValueRequired)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether a return value is required.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValueRequired"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void setReturnValueRequired(boolean returnValueRequired)",
    "source_code": "\tpublic void setReturnValueRequired(boolean returnValueRequired) {\n\t\tthis.returnValueRequired = returnValueRequired;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataContext#setSchemaName(schemaName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the name of the schema.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "schemaName"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "void",
    "signature": "public void setSchemaName(@Nullable String schemaName)",
    "source_code": "\tpublic void setSchemaName(@Nullable String schemaName) {\n\t\tthis.schemaName = schemaName;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.jdbc.core.namedparam.AbstractSqlParameterSource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for {@link SqlParameterSource} implementations.\n * Provides registration of SQL types per parameter and a friendly\n * {@link #toString() toString} representation enumerating all parameters for\n * a {@code SqlParameterSource} implementing {@link #getParameterNames()}.\n * Concrete subclasses must implement {@link #hasValue} and {@link #getValue}.\n *\n * @author Juergen Hoeller\n * @author Jens Schauder\n * @since 2.0\n * @see #hasValue(String)\n * @see #getValue(String)\n * @see #getParameterNames()\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class AbstractSqlParameterSource",
    "source_code": "public abstract class AbstractSqlParameterSource implements SqlParameterSource {\n\n\tprivate final Map<String, Integer> sqlTypes = new HashMap<>();\n\n\tprivate final Map<String, String> typeNames = new HashMap<>();\n\n\n\t/**\n\t * Register an SQL type for the given parameter.\n\t * @param paramName the name of the parameter\n\t * @param sqlType the SQL type of the parameter\n\t */\n\tpublic void registerSqlType(String paramName, int sqlType) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.sqlTypes.put(paramName, sqlType);\n\t}\n\n\t/**\n\t * Register an SQL type for the given parameter.\n\t * @param paramName the name of the parameter\n\t * @param typeName the type name of the parameter\n\t */\n\tpublic void registerTypeName(String paramName, String typeName) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.typeNames.put(paramName, typeName);\n\t}\n\n\t/**\n\t * Return the SQL type for the given parameter, if registered.\n\t * @param paramName the name of the parameter\n\t * @return the SQL type of the parameter,\n\t * or {@code TYPE_UNKNOWN} if not registered\n\t */\n\t@Override\n\tpublic int getSqlType(String paramName) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\treturn this.sqlTypes.getOrDefault(paramName, TYPE_UNKNOWN);\n\t}\n\n\t/**\n\t * Return the type name for the given parameter, if registered.\n\t * @param paramName the name of the parameter\n\t * @return the type name of the parameter,\n\t * or {@code null} if not registered\n\t */\n\t@Override\n\t@Nullable\n\tpublic String getTypeName(String paramName) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\treturn this.typeNames.get(paramName);\n\t}\n\n\n\t/**\n\t * Enumerate the parameter names and values with their corresponding SQL type if available,\n\t * or just return the simple {@code SqlParameterSource} implementation class name otherwise.\n\t * @since 5.2\n\t * @see #getParameterNames()\n\t */\n\t@Override\n\tpublic String toString() {\n\t\tString[] parameterNames = getParameterNames();\n\t\tif (parameterNames != null) {\n\t\t\tStringJoiner result = new StringJoiner(\", \", getClass().getSimpleName() + \" {\", \"}\");\n\t\t\tfor (String parameterName : parameterNames) {\n\t\t\t\tObject value = getValue(parameterName);\n\t\t\t\tif (value instanceof SqlParameterValue sqlParameterValue) {\n\t\t\t\t\tvalue = sqlParameterValue.getValue();\n\t\t\t\t}\n\t\t\t\tString typeName = getTypeName(parameterName);\n\t\t\t\tif (typeName == null) {\n\t\t\t\t\tint sqlType = getSqlType(parameterName);\n\t\t\t\t\tif (sqlType != TYPE_UNKNOWN) {\n\t\t\t\t\t\ttypeName = JdbcUtils.resolveTypeName(sqlType);\n\t\t\t\t\t\tif (typeName == null) {\n\t\t\t\t\t\t\ttypeName = String.valueOf(sqlType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder entry = new StringBuilder();\n\t\t\t\tentry.append(parameterName).append('=').append(value);\n\t\t\t\tif (typeName != null) {\n\t\t\t\t\tentry.append(\" (type:\").append(typeName).append(')');\n\t\t\t\t}\n\t\t\t\tresult.add(entry);\n\t\t\t}\n\t\t\treturn result.toString();\n\t\t}\n\t\telse {\n\t\t\treturn getClass().getSimpleName();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.namedparam.AbstractSqlParameterSource#getSqlType(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the SQL type for the given parameter, if registered.\n\t * @param paramName the name of the parameter\n\t * @return the SQL type of the parameter,\n\t * or {@code TYPE_UNKNOWN} if not registered\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "int",
    "signature": "public int getSqlType(String paramName)",
    "source_code": "\tpublic int getSqlType(String paramName) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\treturn this.sqlTypes.getOrDefault(paramName, TYPE_UNKNOWN);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.AbstractSqlParameterSource#getTypeName(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the type name for the given parameter, if registered.\n\t * @param paramName the name of the parameter\n\t * @return the type name of the parameter,\n\t * or {@code null} if not registered\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "String",
    "signature": "public String getTypeName(String paramName)",
    "source_code": "\tpublic String getTypeName(String paramName) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\treturn this.typeNames.get(paramName);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.AbstractSqlParameterSource#registerSqlType(paramName,sqlType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register an SQL type for the given parameter.\n\t * @param paramName the name of the parameter\n\t * @param sqlType the SQL type of the parameter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "sqlType"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "void",
    "signature": "public void registerSqlType(String paramName, int sqlType)",
    "source_code": "\tpublic void registerSqlType(String paramName, int sqlType) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.sqlTypes.put(paramName, sqlType);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.AbstractSqlParameterSource#registerTypeName(paramName,typeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register an SQL type for the given parameter.\n\t * @param paramName the name of the parameter\n\t * @param typeName the type name of the parameter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "typeName"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void registerTypeName(String paramName, String typeName)",
    "source_code": "\tpublic void registerTypeName(String paramName, String typeName) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.typeNames.put(paramName, typeName);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.AbstractSqlParameterSource#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Enumerate the parameter names and values with their corresponding SQL type if available,\n\t * or just return the simple {@code SqlParameterSource} implementation class name otherwise.\n\t * @since 5.2\n\t * @see #getParameterNames()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\tString[] parameterNames = getParameterNames();\n\t\tif (parameterNames != null) {\n\t\t\tStringJoiner result = new StringJoiner(\", \", getClass().getSimpleName() + \" {\", \"}\");\n\t\t\tfor (String parameterName : parameterNames) {\n\t\t\t\tObject value = getValue(parameterName);\n\t\t\t\tif (value instanceof SqlParameterValue sqlParameterValue) {\n\t\t\t\t\tvalue = sqlParameterValue.getValue();\n\t\t\t\t}\n\t\t\t\tString typeName = getTypeName(parameterName);\n\t\t\t\tif (typeName == null) {\n\t\t\t\t\tint sqlType = getSqlType(parameterName);\n\t\t\t\t\tif (sqlType != TYPE_UNKNOWN) {\n\t\t\t\t\t\ttypeName = JdbcUtils.resolveTypeName(sqlType);\n\t\t\t\t\t\tif (typeName == null) {\n\t\t\t\t\t\t\ttypeName = String.valueOf(sqlType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder entry = new StringBuilder();\n\t\t\t\tentry.append(parameterName).append('=').append(value);\n\t\t\t\tif (typeName != null) {\n\t\t\t\t\tentry.append(\" (type:\").append(typeName).append(')');\n\t\t\t\t}\n\t\t\t\tresult.add(entry);\n\t\t\t}\n\t\t\treturn result.toString();\n\t\t}\n\t\telse {\n\t\t\treturn getClass().getSimpleName();\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.support.SqlLobValue": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Object to represent an SQL BLOB/CLOB value parameter. BLOBs can either be an\n * InputStream or a byte array. CLOBs can be in the form of a Reader, InputStream,\n * or String. Each CLOB/BLOB value will be stored together with its length.\n * The type is based on which constructor is used. Instances of this class are\n * stateful and immutable: use them and discard them.\n *\n * <p>This class holds a reference to a {@link LobCreator} that must be closed after\n * the update has completed. This is done via a call to the {@link #cleanup()} method.\n * All handling of the {@code LobCreator} is done by the framework classes that use it -\n * no need to set or close the {@code LobCreator} for end users of this class.\n *\n * <p>A usage example:\n *\n * <pre class=\"code\">JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);  // reusable object\n * LobHandler lobHandler = new DefaultLobHandler();  // reusable object\n *\n * jdbcTemplate.update(\n *     \"INSERT INTO imagedb (image_name, content, description) VALUES (?, ?, ?)\",\n *     new Object[] {\n *       name,\n *       new SqlLobValue(contentStream, contentLength, lobHandler),\n *       new SqlLobValue(description, lobHandler)\n *     },\n *     new int[] {Types.VARCHAR, Types.BLOB, Types.CLOB});\n * </pre>\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @since 1.1\n * @see org.springframework.jdbc.support.lob.LobHandler\n * @see org.springframework.jdbc.support.lob.LobCreator\n * @see org.springframework.jdbc.core.JdbcTemplate#update(String, Object[], int[])\n * @see org.springframework.jdbc.object.SqlUpdate#update(Object[])\n * @see org.springframework.jdbc.object.StoredProcedure#execute(java.util.Map)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "signature": "public class SqlLobValue",
    "source_code": "public class SqlLobValue implements DisposableSqlTypeValue {\n\n\t@Nullable\n\tprivate final Object content;\n\n\tprivate final int length;\n\n\t/**\n\t * Reference to the LobCreator - so we can close it once the update is done.\n\t */\n\tprivate final LobCreator lobCreator;\n\n\n\t/**\n\t * Create a new BLOB value with the given byte array,\n\t * using a DefaultLobHandler.\n\t * @param bytes the byte array containing the BLOB value\n\t * @see org.springframework.jdbc.support.lob.DefaultLobHandler\n\t */\n\tpublic SqlLobValue(@Nullable byte[] bytes) {\n\t\tthis(bytes, new DefaultLobHandler());\n\t}\n\n\t/**\n\t * Create a new BLOB value with the given byte array.\n\t * @param bytes the byte array containing the BLOB value\n\t * @param lobHandler the LobHandler to be used\n\t */\n\tpublic SqlLobValue(@Nullable byte[] bytes, LobHandler lobHandler) {\n\t\tthis.content = bytes;\n\t\tthis.length = (bytes != null ? bytes.length : 0);\n\t\tthis.lobCreator = lobHandler.getLobCreator();\n\t}\n\n\t/**\n\t * Create a new CLOB value with the given content string,\n\t * using a DefaultLobHandler.\n\t * @param content the String containing the CLOB value\n\t * @see org.springframework.jdbc.support.lob.DefaultLobHandler\n\t */\n\tpublic SqlLobValue(@Nullable String content) {\n\t\tthis(content, new DefaultLobHandler());\n\t}\n\n\t/**\n\t * Create a new CLOB value with the given content string.\n\t * @param content the String containing the CLOB value\n\t * @param lobHandler the LobHandler to be used\n\t */\n\tpublic SqlLobValue(@Nullable String content, LobHandler lobHandler) {\n\t\tthis.content = content;\n\t\tthis.length = (content != null ? content.length() : 0);\n\t\tthis.lobCreator = lobHandler.getLobCreator();\n\t}\n\n\t/**\n\t * Create a new BLOB/CLOB value with the given stream,\n\t * using a DefaultLobHandler.\n\t * @param stream the stream containing the LOB value\n\t * @param length the length of the LOB value\n\t * @see org.springframework.jdbc.support.lob.DefaultLobHandler\n\t */\n\tpublic SqlLobValue(InputStream stream, int length) {\n\t\tthis(stream, length, new DefaultLobHandler());\n\t}\n\n\t/**\n\t * Create a new BLOB/CLOB value with the given stream.\n\t * @param stream the stream containing the LOB value\n\t * @param length the length of the LOB value\n\t * @param lobHandler the LobHandler to be used\n\t */\n\tpublic SqlLobValue(InputStream stream, int length, LobHandler lobHandler) {\n\t\tthis.content = stream;\n\t\tthis.length = length;\n\t\tthis.lobCreator = lobHandler.getLobCreator();\n\t}\n\n\t/**\n\t * Create a new CLOB value with the given character stream,\n\t * using a DefaultLobHandler.\n\t * @param reader the character stream containing the CLOB value\n\t * @param length the length of the CLOB value\n\t * @see org.springframework.jdbc.support.lob.DefaultLobHandler\n\t */\n\tpublic SqlLobValue(Reader reader, int length) {\n\t\tthis(reader, length, new DefaultLobHandler());\n\t}\n\n\t/**\n\t * Create a new CLOB value with the given character stream.\n\t * @param reader the character stream containing the CLOB value\n\t * @param length the length of the CLOB value\n\t * @param lobHandler the LobHandler to be used\n\t */\n\tpublic SqlLobValue(Reader reader, int length, LobHandler lobHandler) {\n\t\tthis.content = reader;\n\t\tthis.length = length;\n\t\tthis.lobCreator = lobHandler.getLobCreator();\n\t}\n\n\n\t/**\n\t * Set the specified content via the LobCreator.\n\t */\n\t@Override\n\tpublic void setTypeValue(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)\n\t\t\tthrows SQLException {\n\n\t\tif (sqlType == Types.BLOB) {\n\t\t\tif (this.content instanceof byte[] || this.content == null) {\n\t\t\t\tthis.lobCreator.setBlobAsBytes(ps, paramIndex, (byte[]) this.content);\n\t\t\t}\n\t\t\telse if (this.content instanceof String string) {\n\t\t\t\tthis.lobCreator.setBlobAsBytes(ps, paramIndex, string.getBytes());\n\t\t\t}\n\t\t\telse if (this.content instanceof InputStream inputStream) {\n\t\t\t\tthis.lobCreator.setBlobAsBinaryStream(ps, paramIndex, inputStream, this.length);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Content type [\" + this.content.getClass().getName() + \"] not supported for BLOB columns\");\n\t\t\t}\n\t\t}\n\t\telse if (sqlType == Types.CLOB) {\n\t\t\tif (this.content instanceof String || this.content == null) {\n\t\t\t\tthis.lobCreator.setClobAsString(ps, paramIndex, (String) this.content);\n\t\t\t}\n\t\t\telse if (this.content instanceof InputStream inputStream) {\n\t\t\t\tthis.lobCreator.setClobAsAsciiStream(ps, paramIndex, inputStream, this.length);\n\t\t\t}\n\t\t\telse if (this.content instanceof Reader reader) {\n\t\t\t\tthis.lobCreator.setClobAsCharacterStream(ps, paramIndex, reader, this.length);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Content type [\" + this.content.getClass().getName() + \"] not supported for CLOB columns\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"SqlLobValue only supports SQL types BLOB and CLOB\");\n\t\t}\n\t}\n\n\t/**\n\t * Close the LobCreator, if any.\n\t */\n\t@Override\n\tpublic void cleanup() {\n\t\tthis.lobCreator.close();\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.support.SqlLobValue#cleanup()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close the LobCreator, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "public void cleanup()",
    "source_code": "\tpublic void cleanup() {\n\t\tthis.lobCreator.close();\n\t}"
  },
  "org.springframework.jdbc.core.support.SqlLobValue#setTypeValue(ps,paramIndex,sqlType,typeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the specified content via the LobCreator.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "sqlType",
      "typeName"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "public void setTypeValue(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)",
    "source_code": "\tpublic void setTypeValue(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link org.springframework.transaction.PlatformTransactionManager}\n * implementation for a single JDBC {@link javax.sql.DataSource}. This class is\n * capable of working in any environment with any JDBC driver, as long as the setup\n * uses a {@code javax.sql.DataSource} as its {@code Connection} factory mechanism.\n * Binds a JDBC Connection from the specified DataSource to the current thread,\n * potentially allowing for one thread-bound Connection per DataSource.\n *\n * <p><b>Note: The DataSource that this transaction manager operates on needs\n * to return independent Connections.</b> The Connections may come from a pool\n * (the typical case), but the DataSource must not return thread-scoped /\n * request-scoped Connections or the like. This transaction manager will\n * associate Connections with thread-bound transactions itself, according\n * to the specified propagation behavior. It assumes that a separate,\n * independent Connection can be obtained even during an ongoing transaction.\n *\n * <p>Application code is required to retrieve the JDBC Connection via\n * {@link DataSourceUtils#getConnection(DataSource)} instead of a standard\n * Jakarta EE-style {@link DataSource#getConnection()} call. Spring classes such as\n * {@link org.springframework.jdbc.core.JdbcTemplate} use this strategy implicitly.\n * If not used in combination with this transaction manager, the\n * {@link DataSourceUtils} lookup strategy behaves exactly like the native\n * DataSource lookup; it can thus be used in a portable fashion.\n *\n * <p>Alternatively, you can allow application code to work with the standard\n * Jakarta EE-style lookup pattern {@link DataSource#getConnection()}, for example for\n * legacy code that is not aware of Spring at all. In that case, define a\n * {@link TransactionAwareDataSourceProxy} for your target DataSource, and pass\n * that proxy DataSource to your DAOs, which will automatically participate in\n * Spring-managed transactions when accessing it.\n *\n * <p>Supports custom isolation levels, and timeouts which get applied as\n * appropriate JDBC statement timeouts. To support the latter, application code\n * must either use {@link org.springframework.jdbc.core.JdbcTemplate}, call\n * {@link DataSourceUtils#applyTransactionTimeout} for each created JDBC Statement,\n * or go through a {@link TransactionAwareDataSourceProxy} which will create\n * timeout-aware JDBC Connections and Statements automatically.\n *\n * <p>Consider defining a {@link LazyConnectionDataSourceProxy} for your target\n * DataSource, pointing both this transaction manager and your DAOs to it.\n * This will lead to optimized handling of \"empty\" transactions, i.e. of transactions\n * without any JDBC statements executed. A LazyConnectionDataSourceProxy will not fetch\n * an actual JDBC Connection from the target DataSource until a Statement gets executed,\n * lazily applying the specified transaction settings to the target Connection.\n *\n * <p>This transaction manager supports nested transactions via the JDBC 3.0\n * {@link java.sql.Savepoint} mechanism. The\n * {@link #setNestedTransactionAllowed \"nestedTransactionAllowed\"} flag defaults\n * to \"true\", since nested transactions will work without restrictions on JDBC\n * drivers that support savepoints (such as the Oracle JDBC driver).\n *\n * <p>This transaction manager can be used as a replacement for the\n * {@link org.springframework.transaction.jta.JtaTransactionManager} in the single\n * resource case, as it does not require a container that supports JTA, typically\n * in combination with a locally defined JDBC DataSource (e.g. an Apache Commons\n * DBCP connection pool). Switching between this local strategy and a JTA\n * environment is just a matter of configuration!\n *\n * <p>As of 4.3.4, this transaction manager triggers flush callbacks on registered\n * transaction synchronizations (if synchronization is generally active), assuming\n * resources operating on the underlying JDBC {@code Connection}. This allows for\n * setup analogous to {@code JtaTransactionManager}, in particular with respect to\n * lazily registered ORM resources (e.g. a Hibernate {@code Session}).\n *\n * <p><b>NOTE: As of 5.3, {@link org.springframework.jdbc.support.JdbcTransactionManager}\n * is available as an extended subclass which includes commit/rollback exception\n * translation, aligned with {@link org.springframework.jdbc.core.JdbcTemplate}.</b>\n *\n * @author Juergen Hoeller\n * @since 02.05.2003\n * @see #setNestedTransactionAllowed\n * @see java.sql.Savepoint\n * @see DataSourceUtils#getConnection(javax.sql.DataSource)\n * @see DataSourceUtils#applyTransactionTimeout\n * @see DataSourceUtils#releaseConnection\n * @see TransactionAwareDataSourceProxy\n * @see LazyConnectionDataSourceProxy\n * @see org.springframework.jdbc.core.JdbcTemplate\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "signature": "public class DataSourceTransactionManager",
    "source_code": "public class DataSourceTransactionManager extends AbstractPlatformTransactionManager"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tif (getDataSource() == null) {\n\t\t\tthrow new IllegalArgumentException(\"Property 'dataSource' is required\");\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#doBegin(transaction,definition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "void",
    "signature": "protected void doBegin(Object transaction, TransactionDefinition definition)",
    "source_code": "\tprotected void doBegin(Object transaction, TransactionDefinition definition) {\n\t\tDataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;\n\t\tConnection con = null;\n\n\t\ttry {\n\t\t\tif (!txObject.hasConnectionHolder() ||\n\t\t\t\t\ttxObject.getConnectionHolder().isSynchronizedWithTransaction()) {\n\t\t\t\tConnection newCon = obtainDataSource().getConnection();\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Acquired Connection [\" + newCon + \"] for JDBC transaction\");\n\t\t\t\t}\n\t\t\t\ttxObject.setConnectionHolder(new ConnectionHolder(newCon), true);\n\t\t\t}\n\n\t\t\ttxObject.getConnectionHolder().setSynchronizedWithTransaction(true);\n\t\t\tcon = txObject.getConnectionHolder().getConnection();\n\n\t\t\tInteger previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);\n\t\t\ttxObject.setPreviousIsolationLevel(previousIsolationLevel);\n\t\t\ttxObject.setReadOnly(definition.isReadOnly());\n\n\t\t\t// Switch to manual commit if necessary. This is very expensive in some JDBC drivers,\n\t\t\t// so we don't want to do it unnecessarily (for example if we've explicitly\n\t\t\t// configured the connection pool to set it already).\n\t\t\tif (con.getAutoCommit()) {\n\t\t\t\ttxObject.setMustRestoreAutoCommit(true);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Switching JDBC Connection [\" + con + \"] to manual commit\");\n\t\t\t\t}\n\t\t\t\tcon.setAutoCommit(false);\n\t\t\t}\n\n\t\t\tprepareTransactionalConnection(con, definition);\n\t\t\ttxObject.getConnectionHolder().setTransactionActive(true);\n\n\t\t\tint timeout = determineTimeout(definition);\n\t\t\tif (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\t\ttxObject.getConnectionHolder().setTimeoutInSeconds(timeout);\n\t\t\t}\n\n\t\t\t// Bind the connection holder to the thread.\n\t\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\t\tTransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());\n\t\t\t}\n\t\t}\n\n\t\tcatch (Throwable ex) {\n\t\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\t\tDataSourceUtils.releaseConnection(con, obtainDataSource());\n\t\t\t\ttxObject.setConnectionHolder(null, false);\n\t\t\t}\n\t\t\tthrow new CannotCreateTransactionException(\"Could not open JDBC Connection for transaction\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#doCleanupAfterCompletion(transaction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "void",
    "signature": "protected void doCleanupAfterCompletion(Object transaction)",
    "source_code": "\tprotected void doCleanupAfterCompletion(Object transaction) {\n\t\tDataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;\n\n\t\t// Remove the connection holder from the thread, if exposed.\n\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\tTransactionSynchronizationManager.unbindResource(obtainDataSource());\n\t\t}\n\n\t\t// Reset connection.\n\t\tConnection con = txObject.getConnectionHolder().getConnection();\n\t\ttry {\n\t\t\tif (txObject.isMustRestoreAutoCommit()) {\n\t\t\t\tcon.setAutoCommit(true);\n\t\t\t}\n\t\t\tDataSourceUtils.resetConnectionAfterTransaction(\n\t\t\t\t\tcon, txObject.getPreviousIsolationLevel(), txObject.isReadOnly());\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.debug(\"Could not reset JDBC Connection after transaction\", ex);\n\t\t}\n\n\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Releasing JDBC Connection [\" + con + \"] after transaction\");\n\t\t\t}\n\t\t\tDataSourceUtils.releaseConnection(con, this.dataSource);\n\t\t}\n\n\t\ttxObject.getConnectionHolder().clear();\n\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#doCommit(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "void",
    "signature": "protected void doCommit(DefaultTransactionStatus status)",
    "source_code": "\tprotected void doCommit(DefaultTransactionStatus status) {\n\t\tDataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();\n\t\tConnection con = txObject.getConnectionHolder().getConnection();\n\t\tif (status.isDebug()) {\n\t\t\tlogger.debug(\"Committing JDBC transaction on Connection [\" + con + \"]\");\n\t\t}\n\t\ttry {\n\t\t\tcon.commit();\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tthrow translateException(\"JDBC commit\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#doGetTransaction()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "Object",
    "signature": "protected Object doGetTransaction()",
    "source_code": "\tprotected Object doGetTransaction() {\n\t\tDataSourceTransactionObject txObject = new DataSourceTransactionObject();\n\t\ttxObject.setSavepointAllowed(isNestedTransactionAllowed());\n\t\tConnectionHolder conHolder =\n\t\t\t\t(ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());\n\t\ttxObject.setConnectionHolder(conHolder, false);\n\t\treturn txObject;\n\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#doResume(transaction,suspendedResources)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "void",
    "signature": "protected void doResume(@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected void doResume(@Nullable Object transaction, Object suspendedResources) {\n\t\tTransactionSynchronizationManager.bindResource(obtainDataSource(), suspendedResources);\n\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#doRollback(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "void",
    "signature": "protected void doRollback(DefaultTransactionStatus status)",
    "source_code": "\tprotected void doRollback(DefaultTransactionStatus status) {\n\t\tDataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();\n\t\tConnection con = txObject.getConnectionHolder().getConnection();\n\t\tif (status.isDebug()) {\n\t\t\tlogger.debug(\"Rolling back JDBC transaction on Connection [\" + con + \"]\");\n\t\t}\n\t\ttry {\n\t\t\tcon.rollback();\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tthrow translateException(\"JDBC rollback\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#doSetRollbackOnly(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "void",
    "signature": "protected void doSetRollbackOnly(DefaultTransactionStatus status)",
    "source_code": "\tprotected void doSetRollbackOnly(DefaultTransactionStatus status) {\n\t\tDataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();\n\t\tif (status.isDebug()) {\n\t\t\tlogger.debug(\"Setting JDBC transaction [\" + txObject.getConnectionHolder().getConnection() +\n\t\t\t\t\t\"] rollback-only\");\n\t\t}\n\t\ttxObject.setRollbackOnly();\n\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#doSuspend(transaction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction"
    ],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "Object",
    "signature": "protected Object doSuspend(Object transaction)",
    "source_code": "\tprotected Object doSuspend(Object transaction) {\n\t\tDataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;\n\t\ttxObject.setConnectionHolder(null);\n\t\treturn TransactionSynchronizationManager.unbindResource(obtainDataSource());\n\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#flush()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 476
    },
    "return": "void",
    "signature": "public void flush()",
    "source_code": "\t\tpublic void flush() {\n\t\t\tif (TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\t\tTransactionSynchronizationUtils.triggerFlush();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#getDataSource()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JDBC DataSource that this instance manages transactions for.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "DataSource",
    "signature": "public DataSource getDataSource()",
    "source_code": "\tpublic DataSource getDataSource() {\n\t\treturn this.dataSource;\n\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#getResourceFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "Object",
    "signature": "public Object getResourceFactory()",
    "source_code": "\tpublic Object getResourceFactory() {\n\t\treturn obtainDataSource();\n\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#isEnforceReadOnly()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to enforce the read-only nature of a transaction\n\t * through an explicit statement on the transactional connection.\n\t * @since 4.3.7\n\t * @see #setEnforceReadOnly\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "boolean",
    "signature": "public boolean isEnforceReadOnly()",
    "source_code": "\tpublic boolean isEnforceReadOnly() {\n\t\treturn this.enforceReadOnly;\n\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#isExistingTransaction(transaction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "boolean",
    "signature": "protected boolean isExistingTransaction(Object transaction)",
    "source_code": "\tprotected boolean isExistingTransaction(Object transaction) {\n\t\tDataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;\n\t\treturn (txObject.hasConnectionHolder() && txObject.getConnectionHolder().isTransactionActive());\n\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#isMustRestoreAutoCommit()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 462
    },
    "return": "boolean",
    "signature": "public boolean isMustRestoreAutoCommit()",
    "source_code": "\t\tpublic boolean isMustRestoreAutoCommit() {\n\t\t\treturn this.mustRestoreAutoCommit;\n\t\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#isNewConnectionHolder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "boolean",
    "signature": "public boolean isNewConnectionHolder()",
    "source_code": "\t\tpublic boolean isNewConnectionHolder() {\n\t\t\treturn this.newConnectionHolder;\n\t\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#isRollbackOnly()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "boolean",
    "signature": "public boolean isRollbackOnly()",
    "source_code": "\t\tpublic boolean isRollbackOnly() {\n\t\t\treturn getConnectionHolder().isRollbackOnly();\n\t\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#obtainDataSource()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the DataSource for actual use.\n\t * @return the DataSource (never {@code null})\n\t * @throws IllegalStateException in case of no DataSource set\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "DataSource",
    "signature": "protected DataSource obtainDataSource()",
    "source_code": "\tprotected DataSource obtainDataSource() {\n\t\tDataSource dataSource = getDataSource();\n\t\tAssert.state(dataSource != null, \"No DataSource set\");\n\t\treturn dataSource;\n\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#prepareTransactionalConnection(con,definition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the transactional {@code Connection} right after transaction begin.\n\t * <p>The default implementation executes a \"SET TRANSACTION READ ONLY\" statement\n\t * if the {@link #setEnforceReadOnly \"enforceReadOnly\"} flag is set to {@code true}\n\t * and the transaction definition indicates a read-only transaction.\n\t * <p>The \"SET TRANSACTION READ ONLY\" is understood by Oracle, MySQL and Postgres\n\t * and may work with other databases as well. If you'd like to adapt this treatment,\n\t * override this method accordingly.\n\t * @param con the transactional JDBC Connection\n\t * @param definition the current transaction definition\n\t * @throws SQLException if thrown by JDBC API\n\t * @since 4.3.7\n\t * @see #setEnforceReadOnly\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "void",
    "signature": "protected void prepareTransactionalConnection(Connection con, TransactionDefinition definition)",
    "source_code": "\tprotected void prepareTransactionalConnection(Connection con, TransactionDefinition definition)"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#setConnectionHolder(connectionHolder,newConnectionHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connectionHolder",
      "newConnectionHolder"
    ],
    "position": {
      "column": 1,
      "line": 449
    },
    "return": "void",
    "signature": "public void setConnectionHolder(@Nullable ConnectionHolder connectionHolder, boolean newConnectionHolder)",
    "source_code": "\t\tpublic void setConnectionHolder(@Nullable ConnectionHolder connectionHolder, boolean newConnectionHolder) {\n\t\t\tsuper.setConnectionHolder(connectionHolder);\n\t\t\tthis.newConnectionHolder = newConnectionHolder;\n\t\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#setDataSource(dataSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JDBC DataSource that this instance should manage transactions for.\n\t * <p>This will typically be a locally defined DataSource, for example an\n\t * Apache Commons DBCP connection pool. Alternatively, you can also drive\n\t * transactions for a non-XA J2EE DataSource fetched from JNDI. For an XA\n\t * DataSource, use JtaTransactionManager.\n\t * <p>The DataSource specified here should be the target DataSource to manage\n\t * transactions for, not a TransactionAwareDataSourceProxy. Only data access\n\t * code may work with TransactionAwareDataSourceProxy, while the transaction\n\t * manager needs to work on the underlying target DataSource. If there's\n\t * nevertheless a TransactionAwareDataSourceProxy passed in, it will be\n\t * unwrapped to extract its target DataSource.\n\t * <p><b>The DataSource passed in here needs to return independent Connections.</b>\n\t * The Connections may come from a pool (the typical case), but the DataSource\n\t * must not return thread-scoped / request-scoped Connections or the like.\n\t * @see TransactionAwareDataSourceProxy\n\t * @see org.springframework.transaction.jta.JtaTransactionManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void setDataSource(@Nullable DataSource dataSource)",
    "source_code": "\tpublic void setDataSource(@Nullable DataSource dataSource) {\n\t\tif (dataSource instanceof TransactionAwareDataSourceProxy tadsp) {\n\t\t\t// If we got a TransactionAwareDataSourceProxy, we need to perform transactions\n\t\t\t// for its underlying target DataSource, else data access code won't see\n\t\t\t// properly exposed transactions (i.e. transactions for the target DataSource).\n\t\t\tthis.dataSource = tadsp.getTargetDataSource();\n\t\t}\n\t\telse {\n\t\t\tthis.dataSource = dataSource;\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#setEnforceReadOnly(enforceReadOnly)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to enforce the read-only nature of a transaction\n\t * (as indicated by {@link TransactionDefinition#isReadOnly()})\n\t * through an explicit statement on the transactional connection:\n\t * \"SET TRANSACTION READ ONLY\" as understood by Oracle, MySQL and Postgres.\n\t * <p>The exact treatment, including any SQL statement executed on the connection,\n\t * can be customized through {@link #prepareTransactionalConnection}.\n\t * <p>This mode of read-only handling goes beyond the {@link Connection#setReadOnly}\n\t * hint that Spring applies by default. In contrast to that standard JDBC hint,\n\t * \"SET TRANSACTION READ ONLY\" enforces an isolation-level-like connection mode\n\t * where data manipulation statements are strictly disallowed. Also, on Oracle,\n\t * this read-only mode provides read consistency for the entire transaction.\n\t * <p>Note that older Oracle JDBC drivers (9i, 10g) used to enforce this read-only\n\t * mode even for {@code Connection.setReadOnly(true}. However, with recent drivers,\n\t * this strong enforcement needs to be applied explicitly, e.g. through this flag.\n\t * @since 4.3.7\n\t * @see #prepareTransactionalConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enforceReadOnly"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "void",
    "signature": "public void setEnforceReadOnly(boolean enforceReadOnly)",
    "source_code": "\tpublic void setEnforceReadOnly(boolean enforceReadOnly) {\n\t\tthis.enforceReadOnly = enforceReadOnly;\n\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#setMustRestoreAutoCommit(mustRestoreAutoCommit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mustRestoreAutoCommit"
    ],
    "position": {
      "column": 1,
      "line": 458
    },
    "return": "void",
    "signature": "public void setMustRestoreAutoCommit(boolean mustRestoreAutoCommit)",
    "source_code": "\t\tpublic void setMustRestoreAutoCommit(boolean mustRestoreAutoCommit) {\n\t\t\tthis.mustRestoreAutoCommit = mustRestoreAutoCommit;\n\t\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#setRollbackOnly()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 466
    },
    "return": "void",
    "signature": "public void setRollbackOnly()",
    "source_code": "\t\tpublic void setRollbackOnly() {\n\t\t\tgetConnectionHolder().setRollbackOnly();\n\t\t}"
  },
  "org.springframework.jdbc.datasource.DataSourceTransactionManager#translateException(task,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Translate the given JDBC commit/rollback exception to a common Spring\n\t * exception to propagate from the {@link #commit}/{@link #rollback} call.\n\t * <p>The default implementation throws a {@link TransactionSystemException}.\n\t * Subclasses may specifically identify concurrency failures etc.\n\t * @param task the task description (commit or rollback)\n\t * @param ex the SQLException thrown from commit/rollback\n\t * @return the translated exception to throw, either a\n\t * {@link org.springframework.dao.DataAccessException} or a\n\t * {@link org.springframework.transaction.TransactionException}\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 434
    },
    "return": "RuntimeException",
    "signature": "protected RuntimeException translateException(String task, SQLException ex)",
    "source_code": "\tprotected RuntimeException translateException(String task, SQLException ex) {\n\t\treturn new TransactionSystemException(task + \" failed\", ex);\n\t}"
  },
  "org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Proxy for a target JDBC {@link javax.sql.DataSource}, adding awareness of\n * Spring-managed transactions. Similar to a transactional JNDI DataSource\n * as provided by a Jakarta EE server.\n *\n * <p>Data access code that should remain unaware of Spring's data access support\n * can work with this proxy to seamlessly participate in Spring-managed transactions.\n * Note that the transaction manager, for example {@link DataSourceTransactionManager},\n * still needs to work with the underlying DataSource, <i>not</i> with this proxy.\n *\n * <p><b>Make sure that TransactionAwareDataSourceProxy is the outermost DataSource\n * of a chain of DataSource proxies/adapters.</b> TransactionAwareDataSourceProxy\n * can delegate either directly to the target connection pool or to some\n * intermediary proxy/adapter like {@link LazyConnectionDataSourceProxy} or\n * {@link UserCredentialsDataSourceAdapter}.\n *\n * <p>Delegates to {@link DataSourceUtils} for automatically participating in\n * thread-bound transactions, for example managed by {@link DataSourceTransactionManager}.\n * {@code getConnection} calls and {@code close} calls on returned Connections\n * will behave properly within a transaction, i.e. always operate on the transactional\n * Connection. If not within a transaction, normal DataSource behavior applies.\n *\n * <p>This proxy allows data access code to work with the plain JDBC API and still\n * participate in Spring-managed transactions, similar to JDBC code in a Jakarta EE/JTA\n * environment. However, if possible, use Spring's DataSourceUtils, JdbcTemplate or\n * JDBC operation objects to get transaction participation even without a proxy for\n * the target DataSource, avoiding the need to define such a proxy in the first place.\n *\n * <p>As a further effect, using a transaction-aware DataSource will apply remaining\n * transaction timeouts to all created JDBC (Prepared/Callable)Statement. This means\n * that all operations performed through standard JDBC will automatically participate\n * in Spring-managed transaction timeouts.\n *\n * <p><b>NOTE:</b> This DataSource proxy needs to return wrapped Connections (which\n * implement the {@link ConnectionProxy} interface) in order to handle close calls\n * properly. Use {@link Connection#unwrap} to retrieve the native JDBC Connection.\n *\n * @author Juergen Hoeller\n * @since 1.1\n * @see javax.sql.DataSource#getConnection()\n * @see java.sql.Connection#close()\n * @see DataSourceUtils#doGetConnection\n * @see DataSourceUtils#applyTransactionTimeout\n * @see DataSourceUtils#doReleaseConnection\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "signature": "public class TransactionAwareDataSourceProxy",
    "source_code": "public class TransactionAwareDataSourceProxy extends DelegatingDataSource {\n\n\tprivate boolean reobtainTransactionalConnections = false;\n\n\n\t/**\n\t * Create a new TransactionAwareDataSourceProxy.\n\t * @see #setTargetDataSource\n\t */\n\tpublic TransactionAwareDataSourceProxy() {\n\t}\n\n\t/**\n\t * Create a new TransactionAwareDataSourceProxy.\n\t * @param targetDataSource the target DataSource\n\t */\n\tpublic TransactionAwareDataSourceProxy(DataSource targetDataSource) {\n\t\tsuper(targetDataSource);\n\t}\n\n\t/**\n\t * Specify whether to reobtain the target Connection for each operation\n\t * performed within a transaction.\n\t * <p>The default is \"false\". Specify \"true\" to reobtain transactional\n\t * Connections for every call on the Connection proxy; this is advisable\n\t * on JBoss if you hold on to a Connection handle across transaction boundaries.\n\t * <p>The effect of this setting is similar to the\n\t * \"hibernate.connection.release_mode\" value \"after_statement\".\n\t */\n\tpublic void setReobtainTransactionalConnections(boolean reobtainTransactionalConnections) {\n\t\tthis.reobtainTransactionalConnections = reobtainTransactionalConnections;\n\t}\n\n\n\t/**\n\t * Delegates to DataSourceUtils for automatically participating in Spring-managed\n\t * transactions. Throws the original SQLException, if any.\n\t * <p>The returned Connection handle implements the ConnectionProxy interface,\n\t * allowing to retrieve the underlying target Connection.\n\t * @return a transactional Connection if any, a new one else\n\t * @see DataSourceUtils#doGetConnection\n\t * @see ConnectionProxy#getTargetConnection\n\t */\n\t@Override\n\tpublic Connection getConnection() throws SQLException {\n\t\treturn getTransactionAwareConnectionProxy(obtainTargetDataSource());\n\t}\n\n\t/**\n\t * Wraps the given Connection with a proxy that delegates every method call to it\n\t * but delegates {@code close()} calls to DataSourceUtils.\n\t * @param targetDataSource the DataSource that the Connection came from\n\t * @return the wrapped Connection\n\t * @see java.sql.Connection#close()\n\t * @see DataSourceUtils#doReleaseConnection\n\t */\n\tprotected Connection getTransactionAwareConnectionProxy(DataSource targetDataSource) {\n\t\treturn (Connection) Proxy.newProxyInstance(\n\t\t\t\tConnectionProxy.class.getClassLoader(),\n\t\t\t\tnew Class<?>[] {ConnectionProxy.class},\n\t\t\t\tnew TransactionAwareInvocationHandler(targetDataSource));\n\t}\n\n\t/**\n\t * Determine whether to obtain a fixed target Connection for the proxy\n\t * or to reobtain the target Connection for each operation.\n\t * <p>The default implementation returns {@code true} for all\n\t * standard cases. This can be overridden through the\n\t * {@link #setReobtainTransactionalConnections \"reobtainTransactionalConnections\"}\n\t * flag, which enforces a non-fixed target Connection within an active transaction.\n\t * Note that non-transactional access will always use a fixed Connection.\n\t * @param targetDataSource the target DataSource\n\t */\n\tprotected boolean shouldObtainFixedConnection(DataSource targetDataSource) {\n\t\treturn (!TransactionSynchronizationManager.isSynchronizationActive() ||\n\t\t\t\t!this.reobtainTransactionalConnections);\n\t}\n\n\n\t/**\n\t * Invocation handler that delegates close calls on JDBC Connections\n\t * to DataSourceUtils for being aware of thread-bound transactions.\n\t */\n\tprivate class TransactionAwareInvocationHandler implements InvocationHandler {\n\n\t\tprivate final DataSource targetDataSource;\n\n\t\t@Nullable\n\t\tprivate Connection target;\n\n\t\tprivate boolean closed = false;\n\n\t\tpublic TransactionAwareInvocationHandler(DataSource targetDataSource) {\n\t\t\tthis.targetDataSource = targetDataSource;\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on ConnectionProxy interface coming in...\n\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\t// Only considered as equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of Connection proxy.\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\tcase \"toString\":\n\t\t\t\t\t// Allow for differentiating between the proxy and the raw Connection.\n\t\t\t\t\tStringBuilder sb = new StringBuilder(\"Transaction-aware proxy for target Connection \");\n\t\t\t\t\tif (this.target != null) {\n\t\t\t\t\t\tsb.append('[').append(this.target.toString()).append(']');\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsb.append(\" from DataSource [\").append(this.targetDataSource).append(']');\n\t\t\t\t\t}\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tcase \"close\":\n\t\t\t\t\t// Handle close method: only close if not within a transaction.\n\t\t\t\t\tDataSourceUtils.doReleaseConnection(this.target, this.targetDataSource);\n\t\t\t\t\tthis.closed = true;\n\t\t\t\t\treturn null;\n\t\t\t\tcase \"isClosed\":\n\t\t\t\t\treturn this.closed;\n\t\t\t\tcase \"unwrap\":\n\t\t\t\t\tif (((Class<?>) args[0]).isInstance(proxy)) {\n\t\t\t\t\t\treturn proxy;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"isWrapperFor\":\n\t\t\t\t\tif (((Class<?>) args[0]).isInstance(proxy)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (this.target == null) {\n\t\t\t\tif (method.getName().equals(\"getWarnings\") || method.getName().equals(\"clearWarnings\")) {\n\t\t\t\t\t// Avoid creation of target Connection on pre-close cleanup (e.g. Hibernate Session)\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (this.closed) {\n\t\t\t\t\tthrow new SQLException(\"Connection handle already closed\");\n\t\t\t\t}\n\t\t\t\tif (shouldObtainFixedConnection(this.targetDataSource)) {\n\t\t\t\t\tthis.target = DataSourceUtils.doGetConnection(this.targetDataSource);\n\t\t\t\t}\n\t\t\t}\n\t\t\tConnection actualTarget = this.target;\n\t\t\tif (actualTarget == null) {\n\t\t\t\tactualTarget = DataSourceUtils.doGetConnection(this.targetDataSource);\n\t\t\t}\n\n\t\t\tif (method.getName().equals(\"getTargetConnection\")) {\n\t\t\t\t// Handle getTargetConnection method: return underlying Connection.\n\t\t\t\treturn actualTarget;\n\t\t\t}\n\n\t\t\t// Invoke method on target Connection.\n\t\t\ttry {\n\t\t\t\tObject retVal = method.invoke(actualTarget, args);\n\n\t\t\t\t// If return value is a Statement, apply transaction timeout.\n\t\t\t\t// Applies to createStatement, prepareStatement, prepareCall.\n\t\t\t\tif (retVal instanceof Statement statement) {\n\t\t\t\t\tDataSourceUtils.applyTransactionTimeout(statement, this.targetDataSource);\n\t\t\t\t}\n\n\t\t\t\treturn retVal;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (actualTarget != this.target) {\n\t\t\t\t\tDataSourceUtils.doReleaseConnection(actualTarget, this.targetDataSource);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy#getConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to DataSourceUtils for automatically participating in Spring-managed\n\t * transactions. Throws the original SQLException, if any.\n\t * <p>The returned Connection handle implements the ConnectionProxy interface,\n\t * allowing to retrieve the underlying target Connection.\n\t * @return a transactional Connection if any, a new one else\n\t * @see DataSourceUtils#doGetConnection\n\t * @see ConnectionProxy#getTargetConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "Connection",
    "signature": "public Connection getConnection()",
    "source_code": "\tpublic Connection getConnection() throws SQLException {\n\t\treturn getTransactionAwareConnectionProxy(obtainTargetDataSource());\n\t}"
  },
  "org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy#getTransactionAwareConnectionProxy(targetDataSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Wraps the given Connection with a proxy that delegates every method call to it\n\t * but delegates {@code close()} calls to DataSourceUtils.\n\t * @param targetDataSource the DataSource that the Connection came from\n\t * @return the wrapped Connection\n\t * @see java.sql.Connection#close()\n\t * @see DataSourceUtils#doReleaseConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetDataSource"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "Connection",
    "signature": "protected Connection getTransactionAwareConnectionProxy(DataSource targetDataSource)",
    "source_code": "\tprotected Connection getTransactionAwareConnectionProxy(DataSource targetDataSource) {\n\t\treturn (Connection) Proxy.newProxyInstance(\n\t\t\t\tConnectionProxy.class.getClassLoader(),\n\t\t\t\tnew Class<?>[] {ConnectionProxy.class},\n\t\t\t\tnew TransactionAwareInvocationHandler(targetDataSource));\n\t}"
  },
  "org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on ConnectionProxy interface coming in...\n\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\t// Only considered as equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of Connection proxy.\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\tcase \"toString\":\n\t\t\t\t\t// Allow for differentiating between the proxy and the raw Connection.\n\t\t\t\t\tStringBuilder sb = new StringBuilder(\"Transaction-aware proxy for target Connection \");\n\t\t\t\t\tif (this.target != null) {\n\t\t\t\t\t\tsb.append('[').append(this.target.toString()).append(']');\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsb.append(\" from DataSource [\").append(this.targetDataSource).append(']');\n\t\t\t\t\t}\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tcase \"close\":\n\t\t\t\t\t// Handle close method: only close if not within a transaction.\n\t\t\t\t\tDataSourceUtils.doReleaseConnection(this.target, this.targetDataSource);\n\t\t\t\t\tthis.closed = true;\n\t\t\t\t\treturn null;\n\t\t\t\tcase \"isClosed\":\n\t\t\t\t\treturn this.closed;\n\t\t\t\tcase \"unwrap\":\n\t\t\t\t\tif (((Class<?>) args[0]).isInstance(proxy)) {\n\t\t\t\t\t\treturn proxy;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"isWrapperFor\":\n\t\t\t\t\tif (((Class<?>) args[0]).isInstance(proxy)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (this.target == null) {\n\t\t\t\tif (method.getName().equals(\"getWarnings\") || method.getName().equals(\"clearWarnings\")) {\n\t\t\t\t\t// Avoid creation of target Connection on pre-close cleanup (e.g. Hibernate Session)\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (this.closed) {\n\t\t\t\t\tthrow new SQLException(\"Connection handle already closed\");\n\t\t\t\t}\n\t\t\t\tif (shouldObtainFixedConnection(this.targetDataSource)) {\n\t\t\t\t\tthis.target = DataSourceUtils.doGetConnection(this.targetDataSource);\n\t\t\t\t}\n\t\t\t}\n\t\t\tConnection actualTarget = this.target;\n\t\t\tif (actualTarget == null) {\n\t\t\t\tactualTarget = DataSourceUtils.doGetConnection(this.targetDataSource);\n\t\t\t}\n\n\t\t\tif (method.getName().equals(\"getTargetConnection\")) {\n\t\t\t\t// Handle getTargetConnection method: return underlying Connection.\n\t\t\t\treturn actualTarget;\n\t\t\t}\n\n\t\t\t// Invoke method on target Connection.\n\t\t\ttry {\n\t\t\t\tObject retVal = method.invoke(actualTarget, args);\n\n\t\t\t\t// If return value is a Statement, apply transaction timeout.\n\t\t\t\t// Applies to createStatement, prepareStatement, prepareCall.\n\t\t\t\tif (retVal instanceof Statement statement) {\n\t\t\t\t\tDataSourceUtils.applyTransactionTimeout(statement, this.targetDataSource);\n\t\t\t\t}\n\n\t\t\t\treturn retVal;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (actualTarget != this.target) {\n\t\t\t\t\tDataSourceUtils.doReleaseConnection(actualTarget, this.targetDataSource);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy#setReobtainTransactionalConnections(reobtainTransactionalConnections)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to reobtain the target Connection for each operation\n\t * performed within a transaction.\n\t * <p>The default is \"false\". Specify \"true\" to reobtain transactional\n\t * Connections for every call on the Connection proxy; this is advisable\n\t * on JBoss if you hold on to a Connection handle across transaction boundaries.\n\t * <p>The effect of this setting is similar to the\n\t * \"hibernate.connection.release_mode\" value \"after_statement\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reobtainTransactionalConnections"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "void",
    "signature": "public void setReobtainTransactionalConnections(boolean reobtainTransactionalConnections)",
    "source_code": "\tpublic void setReobtainTransactionalConnections(boolean reobtainTransactionalConnections) {\n\t\tthis.reobtainTransactionalConnections = reobtainTransactionalConnections;\n\t}"
  },
  "org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy#shouldObtainFixedConnection(targetDataSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether to obtain a fixed target Connection for the proxy\n\t * or to reobtain the target Connection for each operation.\n\t * <p>The default implementation returns {@code true} for all\n\t * standard cases. This can be overridden through the\n\t * {@link #setReobtainTransactionalConnections \"reobtainTransactionalConnections\"}\n\t * flag, which enforces a non-fixed target Connection within an active transaction.\n\t * Note that non-transactional access will always use a fixed Connection.\n\t * @param targetDataSource the target DataSource\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetDataSource"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "boolean",
    "signature": "protected boolean shouldObtainFixedConnection(DataSource targetDataSource)",
    "source_code": "\tprotected boolean shouldObtainFixedConnection(DataSource targetDataSource) {\n\t\treturn (!TransactionSynchronizationManager.isSynchronizationActive() ||\n\t\t\t\t!this.reobtainTransactionalConnections);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.DEFAULT_BLOCK_COMMENT_END_DELIMITER": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Default end delimiter for block comments within SQL scripts: <code>\"*&#47;\"</code>.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "signature": "public String DEFAULT_BLOCK_COMMENT_END_DELIMITER",
    "source_code": "\tpublic static final String DEFAULT_BLOCK_COMMENT_END_DELIMITER = \"*/\";",
    "type": "String"
  },
  "org.springframework.jdbc.datasource.init.DEFAULT_BLOCK_COMMENT_START_DELIMITER": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Default start delimiter for block comments within SQL scripts: {@code \"/*\"}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "signature": "public String DEFAULT_BLOCK_COMMENT_START_DELIMITER",
    "source_code": "\tpublic static final String DEFAULT_BLOCK_COMMENT_START_DELIMITER = \"/*\";",
    "type": "String"
  },
  "org.springframework.jdbc.datasource.init.DEFAULT_COMMENT_PREFIX": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Default prefix for single-line comments within SQL scripts: {@code \"--\"}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "signature": "public String DEFAULT_COMMENT_PREFIX",
    "source_code": "\tpublic static final String DEFAULT_COMMENT_PREFIX = \"--\";",
    "type": "String"
  },
  "org.springframework.jdbc.datasource.init.DEFAULT_COMMENT_PREFIXES": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Default prefixes for single-line comments within SQL scripts: {@code [\"--\"]}.\n\t * @since 5.2\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "signature": "public String[] DEFAULT_COMMENT_PREFIXES",
    "source_code": "\tpublic static final String[] DEFAULT_COMMENT_PREFIXES = {DEFAULT_COMMENT_PREFIX};",
    "type": "String[]"
  },
  "org.springframework.jdbc.datasource.init.DEFAULT_STATEMENT_SEPARATOR": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Default statement separator within SQL scripts: {@code \";\"}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public String DEFAULT_STATEMENT_SEPARATOR",
    "source_code": "\tpublic static final String DEFAULT_STATEMENT_SEPARATOR = \";\";",
    "type": "String"
  },
  "org.springframework.jdbc.datasource.init.EOF_STATEMENT_SEPARATOR": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * End of file (EOF) SQL statement separator: {@code \"^^^ END OF SCRIPT ^^^\"}.\n\t * <p>This value may be supplied as the {@code separator} to {@link\n\t * #executeSqlScript(Connection, EncodedResource, boolean, boolean, String, String, String, String)}\n\t * to denote that an SQL script contains a single statement (potentially\n\t * spanning multiple lines) with no explicit statement separator. Note that\n\t * such a script should not actually contain this value; it is merely a\n\t * <em>virtual</em> statement separator.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public String EOF_STATEMENT_SEPARATOR",
    "source_code": "\tpublic static final String EOF_STATEMENT_SEPARATOR = \"^^^ END OF SCRIPT ^^^\";",
    "type": "String"
  },
  "org.springframework.jdbc.datasource.init.FALLBACK_STATEMENT_SEPARATOR": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Fallback statement separator within SQL scripts: {@code \"\\n\"}.\n\t * <p>Used if neither a custom separator nor the\n\t * {@link #DEFAULT_STATEMENT_SEPARATOR} is present in a given script.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "signature": "public String FALLBACK_STATEMENT_SEPARATOR",
    "source_code": "\tpublic static final String FALLBACK_STATEMENT_SEPARATOR = \"\\n\";",
    "type": "String"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Generic utility methods for working with SQL scripts in conjunction with JDBC.\n *\n * <p>Mainly for internal use within the framework.\n *\n * @author Thomas Risberg\n * @author Sam Brannen\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Dave Syer\n * @author Chris Beams\n * @author Oliver Gierke\n * @author Chris Baldwin\n * @author Nicolas Debeissat\n * @author Phillip Webb\n * @since 4.0.3\n * @see org.springframework.r2dbc.connection.init.ScriptUtils\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public class ScriptUtils",
    "source_code": "public abstract class ScriptUtils {\n\n\t/**\n\t * Default statement separator within SQL scripts: {@code \";\"}.\n\t */\n\tpublic static final String DEFAULT_STATEMENT_SEPARATOR = \";\";\n\n\t/**\n\t * Fallback statement separator within SQL scripts: {@code \"\\n\"}.\n\t * <p>Used if neither a custom separator nor the\n\t * {@link #DEFAULT_STATEMENT_SEPARATOR} is present in a given script.\n\t */\n\tpublic static final String FALLBACK_STATEMENT_SEPARATOR = \"\\n\";\n\n\t/**\n\t * End of file (EOF) SQL statement separator: {@code \"^^^ END OF SCRIPT ^^^\"}.\n\t * <p>This value may be supplied as the {@code separator} to {@link\n\t * #executeSqlScript(Connection, EncodedResource, boolean, boolean, String, String, String, String)}\n\t * to denote that an SQL script contains a single statement (potentially\n\t * spanning multiple lines) with no explicit statement separator. Note that\n\t * such a script should not actually contain this value; it is merely a\n\t * <em>virtual</em> statement separator.\n\t */\n\tpublic static final String EOF_STATEMENT_SEPARATOR = \"^^^ END OF SCRIPT ^^^\";\n\n\t/**\n\t * Default prefix for single-line comments within SQL scripts: {@code \"--\"}.\n\t */\n\tpublic static final String DEFAULT_COMMENT_PREFIX = \"--\";\n\n\t/**\n\t * Default prefixes for single-line comments within SQL scripts: {@code [\"--\"]}.\n\t * @since 5.2\n\t */\n\tpublic static final String[] DEFAULT_COMMENT_PREFIXES = {DEFAULT_COMMENT_PREFIX};\n\n\t/**\n\t * Default start delimiter for block comments within SQL scripts: {@code \"/*\"}.\n\t */\n\tpublic static final String DEFAULT_BLOCK_COMMENT_START_DELIMITER = \"/*\";\n\n\t/**\n\t * Default end delimiter for block comments within SQL scripts: <code>\"*&#47;\"</code>.\n\t */\n\tpublic static final String DEFAULT_BLOCK_COMMENT_END_DELIMITER = \"*/\";\n\n\n\tprivate static final Log logger = LogFactory.getLog(ScriptUtils.class);\n\n\n\t/**\n\t * Execute the given SQL script using default settings for statement\n\t * separators, comment delimiters, and exception handling flags.\n\t * <p>Statement separators and comments will be removed before executing\n\t * individual statements within the supplied script.\n\t * <p><strong>Warning</strong>: this method does <em>not</em> release the\n\t * provided {@link Connection}.\n\t * @param connection the JDBC connection to use to execute the script; already\n\t * configured and ready to use\n\t * @param resource the resource to load the SQL script from; encoded with the\n\t * current platform's default encoding\n\t * @throws ScriptException if an error occurred while executing the SQL script\n\t * @see #executeSqlScript(Connection, EncodedResource, boolean, boolean, String, String, String, String)\n\t * @see #DEFAULT_STATEMENT_SEPARATOR\n\t * @see #DEFAULT_COMMENT_PREFIX\n\t * @see #DEFAULT_BLOCK_COMMENT_START_DELIMITER\n\t * @see #DEFAULT_BLOCK_COMMENT_END_DELIMITER\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#getConnection\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#releaseConnection\n\t */\n\tpublic static void executeSqlScript(Connection connection, Resource resource) throws ScriptException {\n\t\texecuteSqlScript(connection, new EncodedResource(resource));\n\t}\n\n\t/**\n\t * Execute the given SQL script using default settings for statement\n\t * separators, comment delimiters, and exception handling flags.\n\t * <p>Statement separators and comments will be removed before executing\n\t * individual statements within the supplied script.\n\t * <p><strong>Warning</strong>: this method does <em>not</em> release the\n\t * provided {@link Connection}.\n\t * @param connection the JDBC connection to use to execute the script; already\n\t * configured and ready to use\n\t * @param resource the resource (potentially associated with a specific encoding)\n\t * to load the SQL script from\n\t * @throws ScriptException if an error occurred while executing the SQL script\n\t * @see #executeSqlScript(Connection, EncodedResource, boolean, boolean, String, String, String, String)\n\t * @see #DEFAULT_STATEMENT_SEPARATOR\n\t * @see #DEFAULT_COMMENT_PREFIX\n\t * @see #DEFAULT_BLOCK_COMMENT_START_DELIMITER\n\t * @see #DEFAULT_BLOCK_COMMENT_END_DELIMITER\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#getConnection\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#releaseConnection\n\t */\n\tpublic static void executeSqlScript(Connection connection, EncodedResource resource) throws ScriptException {\n\t\texecuteSqlScript(connection, resource, false, false, DEFAULT_COMMENT_PREFIX, DEFAULT_STATEMENT_SEPARATOR,\n\t\t\t\tDEFAULT_BLOCK_COMMENT_START_DELIMITER, DEFAULT_BLOCK_COMMENT_END_DELIMITER);\n\t}\n\n\t/**\n\t * Execute the given SQL script.\n\t * <p>Statement separators and comments will be removed before executing\n\t * individual statements within the supplied script.\n\t * <p><strong>Warning</strong>: this method does <em>not</em> release the\n\t * provided {@link Connection}.\n\t * @param connection the JDBC connection to use to execute the script; already\n\t * configured and ready to use\n\t * @param resource the resource (potentially associated with a specific encoding)\n\t * to load the SQL script from\n\t * @param continueOnError whether to continue without throwing an exception\n\t * in the event of an error\n\t * @param ignoreFailedDrops whether to continue in the event of specifically\n\t * an error on a {@code DROP} statement\n\t * @param commentPrefix the prefix that identifies single-line comments in the\n\t * SQL script (typically \"--\")\n\t * @param separator the script statement separator; defaults to\n\t * {@value #DEFAULT_STATEMENT_SEPARATOR} if not specified and falls back to\n\t * {@value #FALLBACK_STATEMENT_SEPARATOR} as a last resort; may be set to\n\t * {@value #EOF_STATEMENT_SEPARATOR} to signal that the script contains a\n\t * single statement without a separator\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @throws ScriptException if an error occurred while executing the SQL script\n\t * @see #DEFAULT_STATEMENT_SEPARATOR\n\t * @see #FALLBACK_STATEMENT_SEPARATOR\n\t * @see #EOF_STATEMENT_SEPARATOR\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#getConnection\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#releaseConnection\n\t */\n\tpublic static void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError,\n\t\t\tboolean ignoreFailedDrops, String commentPrefix, @Nullable String separator,\n\t\t\tString blockCommentStartDelimiter, String blockCommentEndDelimiter) throws ScriptException {\n\n\t\texecuteSqlScript(connection, resource, continueOnError, ignoreFailedDrops,\n\t\t\t\tnew String[] { commentPrefix }, separator, blockCommentStartDelimiter,\n\t\t\t\tblockCommentEndDelimiter);\n\t}\n\n\t/**\n\t * Execute the given SQL script.\n\t * <p>Statement separators and comments will be removed before executing\n\t * individual statements within the supplied script.\n\t * <p><strong>Warning</strong>: this method does <em>not</em> release the\n\t * provided {@link Connection}.\n\t * @param connection the JDBC connection to use to execute the script; already\n\t * configured and ready to use\n\t * @param resource the resource (potentially associated with a specific encoding)\n\t * to load the SQL script from\n\t * @param continueOnError whether to continue without throwing an exception\n\t * in the event of an error\n\t * @param ignoreFailedDrops whether to continue in the event of specifically\n\t * an error on a {@code DROP} statement\n\t * @param commentPrefixes the prefixes that identify single-line comments in the\n\t * SQL script (typically \"--\")\n\t * @param separator the script statement separator; defaults to\n\t * {@value #DEFAULT_STATEMENT_SEPARATOR} if not specified and falls back to\n\t * {@value #FALLBACK_STATEMENT_SEPARATOR} as a last resort; may be set to\n\t * {@value #EOF_STATEMENT_SEPARATOR} to signal that the script contains a\n\t * single statement without a separator\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @throws ScriptException if an error occurred while executing the SQL script\n\t * @since 5.2\n\t * @see #DEFAULT_STATEMENT_SEPARATOR\n\t * @see #FALLBACK_STATEMENT_SEPARATOR\n\t * @see #EOF_STATEMENT_SEPARATOR\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#getConnection\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#releaseConnection\n\t */\n\tpublic static void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError,\n\t\t\tboolean ignoreFailedDrops, String[] commentPrefixes, @Nullable String separator,\n\t\t\tString blockCommentStartDelimiter, String blockCommentEndDelimiter) throws ScriptException {\n\n\t\ttry {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Executing SQL script from \" + resource);\n\t\t\t}\n\t\t\tlong startTime = System.currentTimeMillis();\n\n\t\t\tString script;\n\t\t\ttry {\n\t\t\t\tscript = readScript(resource, separator, commentPrefixes, blockCommentEndDelimiter);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new CannotReadScriptException(resource, ex);\n\t\t\t}\n\n\t\t\tif (separator == null) {\n\t\t\t\tseparator = DEFAULT_STATEMENT_SEPARATOR;\n\t\t\t}\n\t\t\tif (!EOF_STATEMENT_SEPARATOR.equals(separator) &&\n\t\t\t\t\t!containsStatementSeparator(resource, script, separator, commentPrefixes,\n\t\t\t\t\t\tblockCommentStartDelimiter, blockCommentEndDelimiter)) {\n\t\t\t\tseparator = FALLBACK_STATEMENT_SEPARATOR;\n\t\t\t}\n\n\t\t\tList<String> statements = new ArrayList<>();\n\t\t\tsplitSqlScript(resource, script, separator, commentPrefixes, blockCommentStartDelimiter,\n\t\t\t\t\tblockCommentEndDelimiter, statements);\n\n\t\t\tint stmtNumber = 0;\n\t\t\tStatement stmt = connection.createStatement();\n\t\t\ttry {\n\t\t\t\tfor (String statement : statements) {\n\t\t\t\t\tstmtNumber++;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tstmt.execute(statement);\n\t\t\t\t\t\tint rowsAffected = stmt.getUpdateCount();\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(rowsAffected + \" returned as update count for SQL: \" + statement);\n\t\t\t\t\t\t\tSQLWarning warningToLog = stmt.getWarnings();\n\t\t\t\t\t\t\twhile (warningToLog != null) {\n\t\t\t\t\t\t\t\tlogger.debug(\"SQLWarning ignored: SQL state '\" + warningToLog.getSQLState() +\n\t\t\t\t\t\t\t\t\t\t\"', error code '\" + warningToLog.getErrorCode() +\n\t\t\t\t\t\t\t\t\t\t\"', message [\" + warningToLog.getMessage() + \"]\");\n\t\t\t\t\t\t\t\twarningToLog = warningToLog.getNextWarning();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException ex) {\n\t\t\t\t\t\tboolean dropStatement = StringUtils.startsWithIgnoreCase(statement.trim(), \"drop\");\n\t\t\t\t\t\tif (continueOnError || (dropStatement && ignoreFailedDrops)) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(ScriptStatementFailedException.buildErrorMessage(statement, stmtNumber, resource), ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new ScriptStatementFailedException(statement, stmtNumber, resource, ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttry {\n\t\t\t\t\tstmt.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tlogger.trace(\"Could not close JDBC Statement\", ex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong elapsedTime = System.currentTimeMillis() - startTime;\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Executed SQL script from \" + resource + \" in \" + elapsedTime + \" ms.\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (ex instanceof ScriptException scriptException) {\n\t\t\t\tthrow scriptException;\n\t\t\t}\n\t\t\tthrow new UncategorizedScriptException(\n\t\t\t\t\"Failed to execute database script from resource [\" + resource + \"]\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Read a script from the provided resource, using the supplied comment prefixes\n\t * and statement separator, and build a {@code String} containing the lines.\n\t * <p>Lines <em>beginning</em> with one of the comment prefixes are excluded\n\t * from the results; however, line comments anywhere else &mdash; for example,\n\t * within a statement &mdash; will be included in the results.\n\t * @param resource the {@code EncodedResource} containing the script\n\t * to be processed\n\t * @param separator the statement separator in the SQL script (typically \";\")\n\t * @param commentPrefixes the prefixes that identify comments in the SQL script\n\t * (typically \"--\")\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @return a {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t */\n\tstatic String readScript(EncodedResource resource, @Nullable String separator,\n\t\t\tString[] commentPrefixes, String blockCommentEndDelimiter) throws IOException {\n\n\t\ttry (LineNumberReader lnr = new LineNumberReader(resource.getReader())) {\n\t\t\treturn readScript(lnr, commentPrefixes, separator, blockCommentEndDelimiter);\n\t\t}\n\t}\n\n\t/**\n\t * Read a script from the provided {@code LineNumberReader}, using the supplied\n\t * comment prefix and statement separator, and build a {@code String} containing\n\t * the lines.\n\t * <p>Lines <em>beginning</em> with the comment prefix are excluded from the\n\t * results; however, line comments anywhere else &mdash; for example, within\n\t * a statement &mdash; will be included in the results.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @param commentPrefix the prefix that identifies comments in the SQL script\n\t * (typically \"--\")\n\t * @param separator the statement separator in the SQL script (typically \";\")\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @return a {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */\n\t@Deprecated\n\tpublic static String readScript(LineNumberReader lineNumberReader, @Nullable String commentPrefix,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter) throws IOException {\n\n\t\tString[] commentPrefixes = (commentPrefix != null) ? new String[] { commentPrefix } : null;\n\t\treturn readScript(lineNumberReader, commentPrefixes, separator, blockCommentEndDelimiter);\n\t}\n\n\t/**\n\t * Read a script from the provided {@code LineNumberReader}, using the supplied\n\t * comment prefixes and statement separator, and build a {@code String} containing\n\t * the lines.\n\t * <p>Lines <em>beginning</em> with one of the comment prefixes are excluded\n\t * from the results; however, line comments anywhere else &mdash; for example,\n\t * within a statement &mdash; will be included in the results.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @param commentPrefixes the prefixes that identify comments in the SQL script\n\t * (typically \"--\")\n\t * @param separator the statement separator in the SQL script (typically \";\")\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @return a {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t * @since 5.2\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */\n\t@Deprecated\n\tpublic static String readScript(LineNumberReader lineNumberReader, @Nullable String[] commentPrefixes,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter) throws IOException {\n\n\t\tString currentStatement = lineNumberReader.readLine();\n\t\tStringBuilder scriptBuilder = new StringBuilder();\n\t\twhile (currentStatement != null) {\n\t\t\tif ((blockCommentEndDelimiter != null && currentStatement.contains(blockCommentEndDelimiter)) ||\n\t\t\t\t(commentPrefixes != null && !startsWithAny(currentStatement, commentPrefixes, 0))) {\n\t\t\t\tif (scriptBuilder.length() > 0) {\n\t\t\t\t\tscriptBuilder.append('\\n');\n\t\t\t\t}\n\t\t\t\tscriptBuilder.append(currentStatement);\n\t\t\t}\n\t\t\tcurrentStatement = lineNumberReader.readLine();\n\t\t}\n\t\tappendSeparatorToScriptIfNecessary(scriptBuilder, separator);\n\t\treturn scriptBuilder.toString();\n\t}\n\n\tprivate static void appendSeparatorToScriptIfNecessary(StringBuilder scriptBuilder, @Nullable String separator) {\n\t\tif (separator == null) {\n\t\t\treturn;\n\t\t}\n\t\tString trimmed = separator.trim();\n\t\tif (trimmed.length() == separator.length()) {\n\t\t\treturn;\n\t\t}\n\t\t// separator ends in whitespace, so we might want to see if the script is trying\n\t\t// to end the same way\n\t\tif (scriptBuilder.lastIndexOf(trimmed) == scriptBuilder.length() - trimmed.length()) {\n\t\t\tscriptBuilder.append(separator.substring(trimmed.length()));\n\t\t}\n\t}\n\n\t/**\n\t * Determine if the provided SQL script contains the specified delimiter.\n\t * <p>This method is intended to be used to find the string delimiting each\n\t * SQL statement &mdash; for example, a ';' character.\n\t * <p>Any occurrence of the delimiter within the script will be ignored if it\n\t * is within a <em>literal</em> block of text enclosed in single quotes\n\t * ({@code '}) or double quotes ({@code \"}), if it is escaped with a backslash\n\t * ({@code \\}), or if it is within a single-line comment or block comment.\n\t * @param script the SQL script to search within\n\t * @param delimiter the statement delimiter to search for\n\t * @see #DEFAULT_COMMENT_PREFIXES\n\t * @see #DEFAULT_BLOCK_COMMENT_START_DELIMITER\n\t * @see #DEFAULT_BLOCK_COMMENT_END_DELIMITER\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */\n\t@Deprecated\n\tpublic static boolean containsSqlScriptDelimiters(String script, String delimiter) {\n\t\treturn containsStatementSeparator(null, script, delimiter, DEFAULT_COMMENT_PREFIXES,\n\t\t\tDEFAULT_BLOCK_COMMENT_START_DELIMITER, DEFAULT_BLOCK_COMMENT_END_DELIMITER);\n\t}\n\n\t/**\n\t * Determine if the provided SQL script contains the specified statement separator.\n\t * <p>This method is intended to be used to find the string separating each\n\t * SQL statement &mdash; for example, a ';' character.\n\t * <p>Any occurrence of the separator within the script will be ignored if it\n\t * is within a <em>literal</em> block of text enclosed in single quotes\n\t * ({@code '}) or double quotes ({@code \"}), if it is escaped with a backslash\n\t * ({@code \\}), or if it is within a single-line comment or block comment.\n\t * @param resource the resource from which the script was read, or {@code null}\n\t * if unknown\n\t * @param script the SQL script to search within\n\t * @param separator the statement separator to search for\n\t * @param commentPrefixes the prefixes that identify single-line comments\n\t * (typically {@code \"--\"})\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter\n\t * (typically {@code \"/*\"})\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * (typically <code>\"*&#47;\"</code>)\n\t * @since 5.2.16\n\t */\n\tprivate static boolean containsStatementSeparator(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String[] commentPrefixes, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter) throws ScriptException {\n\n\t\tboolean inSingleQuote = false;\n\t\tboolean inDoubleQuote = false;\n\t\tboolean inEscape = false;\n\n\t\tfor (int i = 0; i < script.length(); i++) {\n\t\t\tchar c = script.charAt(i);\n\t\t\tif (inEscape) {\n\t\t\t\tinEscape = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// MySQL style escapes\n\t\t\tif (c == '\\\\') {\n\t\t\t\tinEscape = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!inDoubleQuote && (c == '\\'')) {\n\t\t\t\tinSingleQuote = !inSingleQuote;\n\t\t\t}\n\t\t\telse if (!inSingleQuote && (c == '\"')) {\n\t\t\t\tinDoubleQuote = !inDoubleQuote;\n\t\t\t}\n\t\t\tif (!inSingleQuote && !inDoubleQuote) {\n\t\t\t\tif (script.startsWith(separator, i)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (startsWithAny(script, commentPrefixes, i)) {\n\t\t\t\t\t// Skip over any content from the start of the comment to the EOL\n\t\t\t\t\tint indexOfNextNewline = script.indexOf('\\n', i);\n\t\t\t\t\tif (indexOfNextNewline > i) {\n\t\t\t\t\t\ti = indexOfNextNewline;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// If there's no EOL, we must be at the end of the script, so stop here.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (script.startsWith(blockCommentStartDelimiter, i)) {\n\t\t\t\t\t// Skip over any block comments\n\t\t\t\t\tint indexOfCommentEnd = script.indexOf(blockCommentEndDelimiter, i);\n\t\t\t\t\tif (indexOfCommentEnd > i) {\n\t\t\t\t\t\ti = indexOfCommentEnd + blockCommentEndDelimiter.length() - 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new ScriptParseException(\n\t\t\t\t\t\t\t\t\"Missing block comment end delimiter: \" + blockCommentEndDelimiter, resource);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator character. Each individual statement will be added to the\n\t * provided {@code List}.\n\t * <p>Within the script, {@value #DEFAULT_COMMENT_PREFIX} will be used as the\n\t * comment prefix; any text beginning with the comment prefix and extending to\n\t * the end of the line will be omitted from the output. Similarly,\n\t * {@value #DEFAULT_BLOCK_COMMENT_START_DELIMITER} and\n\t * {@value #DEFAULT_BLOCK_COMMENT_END_DELIMITER} will be used as the\n\t * <em>start</em> and <em>end</em> block comment delimiters: any text enclosed\n\t * in a block comment will be omitted from the output. In addition, multiple\n\t * adjacent whitespace characters will be collapsed into a single space.\n\t * @param script the SQL script\n\t * @param separator character separating each statement (typically a ';')\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @see #splitSqlScript(String, String, List)\n\t * @see #splitSqlScript(EncodedResource, String, String, String, String, String, List)\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */\n\t@Deprecated\n\tpublic static void splitSqlScript(String script, char separator, List<String> statements) throws ScriptException {\n\t\tsplitSqlScript(script, String.valueOf(separator), statements);\n\t}\n\n\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the\n\t * provided {@code List}.\n\t * <p>Within the script, {@value #DEFAULT_COMMENT_PREFIX} will be used as the\n\t * comment prefix; any text beginning with the comment prefix and extending to\n\t * the end of the line will be omitted from the output. Similarly,\n\t * {@value #DEFAULT_BLOCK_COMMENT_START_DELIMITER} and\n\t * {@value #DEFAULT_BLOCK_COMMENT_END_DELIMITER} will be used as the\n\t * <em>start</em> and <em>end</em> block comment delimiters: any text enclosed\n\t * in a block comment will be omitted from the output. In addition, multiple\n\t * adjacent whitespace characters will be collapsed into a single space.\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @see #splitSqlScript(String, char, List)\n\t * @see #splitSqlScript(EncodedResource, String, String, String, String, String, List)\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */\n\t@Deprecated\n\tpublic static void splitSqlScript(String script, String separator, List<String> statements) throws ScriptException {\n\t\tsplitSqlScript(null, script, separator, DEFAULT_COMMENT_PREFIX, DEFAULT_BLOCK_COMMENT_START_DELIMITER,\n\t\t\t\tDEFAULT_BLOCK_COMMENT_END_DELIMITER, statements);\n\t}\n\n\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within the script, the provided {@code commentPrefix} will be honored:\n\t * any text beginning with the comment prefix and extending to the end of the\n\t * line will be omitted from the output. Similarly, the provided\n\t * {@code blockCommentStartDelimiter} and {@code blockCommentEndDelimiter}\n\t * delimiters will be honored: any text enclosed in a block comment will be\n\t * omitted from the output. In addition, multiple adjacent whitespace characters\n\t * will be collapsed into a single space.\n\t * @param resource the resource from which the script was read\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param commentPrefix the prefix that identifies SQL line comments\n\t * (typically \"--\")\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */\n\t@Deprecated\n\tpublic static void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String commentPrefix, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements) throws ScriptException {\n\n\t\tAssert.hasText(commentPrefix, \"'commentPrefix' must not be null or empty\");\n\t\tsplitSqlScript(resource, script, separator, new String[] { commentPrefix },\n\t\t\t\tblockCommentStartDelimiter, blockCommentEndDelimiter, statements);\n\t}\n\n\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within the script, the provided {@code commentPrefixes} will be honored:\n\t * any text beginning with one of the comment prefixes and extending to the\n\t * end of the line will be omitted from the output. Similarly, the provided\n\t * {@code blockCommentStartDelimiter} and {@code blockCommentEndDelimiter}\n\t * delimiters will be honored: any text enclosed in a block comment will be\n\t * omitted from the output. In addition, multiple adjacent whitespace characters\n\t * will be collapsed into a single space.\n\t * @param resource the resource from which the script was read\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param commentPrefixes the prefixes that identify SQL line comments\n\t * (typically \"--\")\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @since 5.2\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */\n\t@Deprecated\n\tpublic static void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String[] commentPrefixes, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements) throws ScriptException {\n\n\t\tAssert.hasText(script, \"'script' must not be null or empty\");\n\t\tAssert.notNull(separator, \"'separator' must not be null\");\n\t\tAssert.notEmpty(commentPrefixes, \"'commentPrefixes' must not be null or empty\");\n\t\tfor (String commentPrefix : commentPrefixes) {\n\t\t\tAssert.hasText(commentPrefix, \"'commentPrefixes' must not contain null or empty elements\");\n\t\t}\n\t\tAssert.hasText(blockCommentStartDelimiter, \"'blockCommentStartDelimiter' must not be null or empty\");\n\t\tAssert.hasText(blockCommentEndDelimiter, \"'blockCommentEndDelimiter' must not be null or empty\");\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean inSingleQuote = false;\n\t\tboolean inDoubleQuote = false;\n\t\tboolean inEscape = false;\n\n\t\tfor (int i = 0; i < script.length(); i++) {\n\t\t\tchar c = script.charAt(i);\n\t\t\tif (inEscape) {\n\t\t\t\tinEscape = false;\n\t\t\t\tsb.append(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// MySQL style escapes\n\t\t\tif (c == '\\\\') {\n\t\t\t\tinEscape = true;\n\t\t\t\tsb.append(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!inDoubleQuote && (c == '\\'')) {\n\t\t\t\tinSingleQuote = !inSingleQuote;\n\t\t\t}\n\t\t\telse if (!inSingleQuote && (c == '\"')) {\n\t\t\t\tinDoubleQuote = !inDoubleQuote;\n\t\t\t}\n\t\t\tif (!inSingleQuote && !inDoubleQuote) {\n\t\t\t\tif (script.startsWith(separator, i)) {\n\t\t\t\t\t// We've reached the end of the current statement\n\t\t\t\t\tif (sb.length() > 0) {\n\t\t\t\t\t\tstatements.add(sb.toString());\n\t\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t\t}\n\t\t\t\t\ti += separator.length() - 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (startsWithAny(script, commentPrefixes, i)) {\n\t\t\t\t\t// Skip over any content from the start of the comment to the EOL\n\t\t\t\t\tint indexOfNextNewline = script.indexOf('\\n', i);\n\t\t\t\t\tif (indexOfNextNewline > i) {\n\t\t\t\t\t\ti = indexOfNextNewline;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// If there's no EOL, we must be at the end of the script, so stop here.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (script.startsWith(blockCommentStartDelimiter, i)) {\n\t\t\t\t\t// Skip over any block comments\n\t\t\t\t\tint indexOfCommentEnd = script.indexOf(blockCommentEndDelimiter, i);\n\t\t\t\t\tif (indexOfCommentEnd > i) {\n\t\t\t\t\t\ti = indexOfCommentEnd + blockCommentEndDelimiter.length() - 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new ScriptParseException(\n\t\t\t\t\t\t\t\t\"Missing block comment end delimiter: \" + blockCommentEndDelimiter, resource);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (c == ' ' || c == '\\r' || c == '\\n' || c == '\\t') {\n\t\t\t\t\t// Avoid multiple adjacent whitespace characters\n\t\t\t\t\tif (sb.length() > 0 && sb.charAt(sb.length() - 1) != ' ') {\n\t\t\t\t\t\tc = ' ';\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(c);\n\t\t}\n\n\t\tif (StringUtils.hasText(sb)) {\n\t\t\tstatements.add(sb.toString());\n\t\t}\n\t}\n\n\tprivate static boolean startsWithAny(String script, String[] prefixes, int offset) {\n\t\tfor (String prefix : prefixes) {\n\t\t\tif (script.startsWith(prefix, offset)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#containsSqlScriptDelimiters(script,delimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the provided SQL script contains the specified delimiter.\n\t * <p>This method is intended to be used to find the string delimiting each\n\t * SQL statement &mdash; for example, a ';' character.\n\t * <p>Any occurrence of the delimiter within the script will be ignored if it\n\t * is within a <em>literal</em> block of text enclosed in single quotes\n\t * ({@code '}) or double quotes ({@code \"}), if it is escaped with a backslash\n\t * ({@code \\}), or if it is within a single-line comment or block comment.\n\t * @param script the SQL script to search within\n\t * @param delimiter the statement delimiter to search for\n\t * @see #DEFAULT_COMMENT_PREFIXES\n\t * @see #DEFAULT_BLOCK_COMMENT_START_DELIMITER\n\t * @see #DEFAULT_BLOCK_COMMENT_END_DELIMITER\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "boolean",
    "signature": "public boolean containsSqlScriptDelimiters(String script, String delimiter)",
    "source_code": "\tpublic static boolean containsSqlScriptDelimiters(String script, String delimiter) {\n\t\treturn containsStatementSeparator(null, script, delimiter, DEFAULT_COMMENT_PREFIXES,\n\t\t\tDEFAULT_BLOCK_COMMENT_START_DELIMITER, DEFAULT_BLOCK_COMMENT_END_DELIMITER);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript(connection,resource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the given SQL script using default settings for statement\n\t * separators, comment delimiters, and exception handling flags.\n\t * <p>Statement separators and comments will be removed before executing\n\t * individual statements within the supplied script.\n\t * <p><strong>Warning</strong>: this method does <em>not</em> release the\n\t * provided {@link Connection}.\n\t * @param connection the JDBC connection to use to execute the script; already\n\t * configured and ready to use\n\t * @param resource the resource (potentially associated with a specific encoding)\n\t * to load the SQL script from\n\t * @throws ScriptException if an error occurred while executing the SQL script\n\t * @see #executeSqlScript(Connection, EncodedResource, boolean, boolean, String, String, String, String)\n\t * @see #DEFAULT_STATEMENT_SEPARATOR\n\t * @see #DEFAULT_COMMENT_PREFIX\n\t * @see #DEFAULT_BLOCK_COMMENT_START_DELIMITER\n\t * @see #DEFAULT_BLOCK_COMMENT_END_DELIMITER\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#getConnection\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#releaseConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connection",
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void executeSqlScript(Connection connection, EncodedResource resource)",
    "source_code": "\tpublic static void executeSqlScript(Connection connection, EncodedResource resource) throws ScriptException {\n\t\texecuteSqlScript(connection, resource, false, false, DEFAULT_COMMENT_PREFIX, DEFAULT_STATEMENT_SEPARATOR,\n\t\t\t\tDEFAULT_BLOCK_COMMENT_START_DELIMITER, DEFAULT_BLOCK_COMMENT_END_DELIMITER);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript(connection,resource,continueOnError,ignoreFailedDrops,commentPrefix,separator,blockCommentStartDelimiter,blockCommentEndDelimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the given SQL script.\n\t * <p>Statement separators and comments will be removed before executing\n\t * individual statements within the supplied script.\n\t * <p><strong>Warning</strong>: this method does <em>not</em> release the\n\t * provided {@link Connection}.\n\t * @param connection the JDBC connection to use to execute the script; already\n\t * configured and ready to use\n\t * @param resource the resource (potentially associated with a specific encoding)\n\t * to load the SQL script from\n\t * @param continueOnError whether to continue without throwing an exception\n\t * in the event of an error\n\t * @param ignoreFailedDrops whether to continue in the event of specifically\n\t * an error on a {@code DROP} statement\n\t * @param commentPrefix the prefix that identifies single-line comments in the\n\t * SQL script (typically \"--\")\n\t * @param separator the script statement separator; defaults to\n\t * {@value #DEFAULT_STATEMENT_SEPARATOR} if not specified and falls back to\n\t * {@value #FALLBACK_STATEMENT_SEPARATOR} as a last resort; may be set to\n\t * {@value #EOF_STATEMENT_SEPARATOR} to signal that the script contains a\n\t * single statement without a separator\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @throws ScriptException if an error occurred while executing the SQL script\n\t * @see #DEFAULT_STATEMENT_SEPARATOR\n\t * @see #FALLBACK_STATEMENT_SEPARATOR\n\t * @see #EOF_STATEMENT_SEPARATOR\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#getConnection\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#releaseConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connection",
      "resource",
      "continueOnError",
      "ignoreFailedDrops",
      "commentPrefix",
      "separator",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError,\n\t\t\tboolean ignoreFailedDrops, String commentPrefix, @Nullable String separator,\n\t\t\tString blockCommentStartDelimiter, String blockCommentEndDelimiter)",
    "source_code": "\tpublic static void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript(connection,resource,continueOnError,ignoreFailedDrops,commentPrefixes,separator,blockCommentStartDelimiter,blockCommentEndDelimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the given SQL script.\n\t * <p>Statement separators and comments will be removed before executing\n\t * individual statements within the supplied script.\n\t * <p><strong>Warning</strong>: this method does <em>not</em> release the\n\t * provided {@link Connection}.\n\t * @param connection the JDBC connection to use to execute the script; already\n\t * configured and ready to use\n\t * @param resource the resource (potentially associated with a specific encoding)\n\t * to load the SQL script from\n\t * @param continueOnError whether to continue without throwing an exception\n\t * in the event of an error\n\t * @param ignoreFailedDrops whether to continue in the event of specifically\n\t * an error on a {@code DROP} statement\n\t * @param commentPrefixes the prefixes that identify single-line comments in the\n\t * SQL script (typically \"--\")\n\t * @param separator the script statement separator; defaults to\n\t * {@value #DEFAULT_STATEMENT_SEPARATOR} if not specified and falls back to\n\t * {@value #FALLBACK_STATEMENT_SEPARATOR} as a last resort; may be set to\n\t * {@value #EOF_STATEMENT_SEPARATOR} to signal that the script contains a\n\t * single statement without a separator\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @throws ScriptException if an error occurred while executing the SQL script\n\t * @since 5.2\n\t * @see #DEFAULT_STATEMENT_SEPARATOR\n\t * @see #FALLBACK_STATEMENT_SEPARATOR\n\t * @see #EOF_STATEMENT_SEPARATOR\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#getConnection\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#releaseConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connection",
      "resource",
      "continueOnError",
      "ignoreFailedDrops",
      "commentPrefixes",
      "separator",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "void",
    "signature": "public void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError,\n\t\t\tboolean ignoreFailedDrops, String[] commentPrefixes, @Nullable String separator,\n\t\t\tString blockCommentStartDelimiter, String blockCommentEndDelimiter)",
    "source_code": "\tpublic static void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#readScript(lineNumberReader,commentPrefix,separator,blockCommentEndDelimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Read a script from the provided {@code LineNumberReader}, using the supplied\n\t * comment prefix and statement separator, and build a {@code String} containing\n\t * the lines.\n\t * <p>Lines <em>beginning</em> with the comment prefix are excluded from the\n\t * results; however, line comments anywhere else &mdash; for example, within\n\t * a statement &mdash; will be included in the results.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @param commentPrefix the prefix that identifies comments in the SQL script\n\t * (typically \"--\")\n\t * @param separator the statement separator in the SQL script (typically \";\")\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @return a {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lineNumberReader",
      "commentPrefix",
      "separator",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "String",
    "signature": "public String readScript(LineNumberReader lineNumberReader, @Nullable String commentPrefix,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter)",
    "source_code": "\tpublic static String readScript(LineNumberReader lineNumberReader, @Nullable String commentPrefix,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#readScript(lineNumberReader,commentPrefixes,separator,blockCommentEndDelimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Read a script from the provided {@code LineNumberReader}, using the supplied\n\t * comment prefixes and statement separator, and build a {@code String} containing\n\t * the lines.\n\t * <p>Lines <em>beginning</em> with one of the comment prefixes are excluded\n\t * from the results; however, line comments anywhere else &mdash; for example,\n\t * within a statement &mdash; will be included in the results.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @param commentPrefixes the prefixes that identify comments in the SQL script\n\t * (typically \"--\")\n\t * @param separator the statement separator in the SQL script (typically \";\")\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @return a {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t * @since 5.2\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lineNumberReader",
      "commentPrefixes",
      "separator",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "String",
    "signature": "public String readScript(LineNumberReader lineNumberReader, @Nullable String[] commentPrefixes,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter)",
    "source_code": "\tpublic static String readScript(LineNumberReader lineNumberReader, @Nullable String[] commentPrefixes,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(resource,script,separator,commentPrefix,blockCommentStartDelimiter,blockCommentEndDelimiter,statements)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within the script, the provided {@code commentPrefix} will be honored:\n\t * any text beginning with the comment prefix and extending to the end of the\n\t * line will be omitted from the output. Similarly, the provided\n\t * {@code blockCommentStartDelimiter} and {@code blockCommentEndDelimiter}\n\t * delimiters will be honored: any text enclosed in a block comment will be\n\t * omitted from the output. In addition, multiple adjacent whitespace characters\n\t * will be collapsed into a single space.\n\t * @param resource the resource from which the script was read\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param commentPrefix the prefix that identifies SQL line comments\n\t * (typically \"--\")\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "script",
      "separator",
      "commentPrefix",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 595
    },
    "return": "void",
    "signature": "public void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String commentPrefix, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(@Nullable EncodedResource resource, String script,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(resource,script,separator,commentPrefixes,blockCommentStartDelimiter,blockCommentEndDelimiter,statements)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within the script, the provided {@code commentPrefixes} will be honored:\n\t * any text beginning with one of the comment prefixes and extending to the\n\t * end of the line will be omitted from the output. Similarly, the provided\n\t * {@code blockCommentStartDelimiter} and {@code blockCommentEndDelimiter}\n\t * delimiters will be honored: any text enclosed in a block comment will be\n\t * omitted from the output. In addition, multiple adjacent whitespace characters\n\t * will be collapsed into a single space.\n\t * @param resource the resource from which the script was read\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param commentPrefixes the prefixes that identify SQL line comments\n\t * (typically \"--\")\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @since 5.2\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "script",
      "separator",
      "commentPrefixes",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "void",
    "signature": "public void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String[] commentPrefixes, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(@Nullable EncodedResource resource, String script,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(script,separator,statements)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the\n\t * provided {@code List}.\n\t * <p>Within the script, {@value #DEFAULT_COMMENT_PREFIX} will be used as the\n\t * comment prefix; any text beginning with the comment prefix and extending to\n\t * the end of the line will be omitted from the output. Similarly,\n\t * {@value #DEFAULT_BLOCK_COMMENT_START_DELIMITER} and\n\t * {@value #DEFAULT_BLOCK_COMMENT_END_DELIMITER} will be used as the\n\t * <em>start</em> and <em>end</em> block comment delimiters: any text enclosed\n\t * in a block comment will be omitted from the output. In addition, multiple\n\t * adjacent whitespace characters will be collapsed into a single space.\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @see #splitSqlScript(String, char, List)\n\t * @see #splitSqlScript(EncodedResource, String, String, String, String, String, List)\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "separator",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "void",
    "signature": "public void splitSqlScript(String script, String separator, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(String script, String separator, List<String> statements) throws ScriptException {\n\t\tsplitSqlScript(null, script, separator, DEFAULT_COMMENT_PREFIX, DEFAULT_BLOCK_COMMENT_START_DELIMITER,\n\t\t\t\tDEFAULT_BLOCK_COMMENT_END_DELIMITER, statements);\n\t}"
  },
  "org.springframework.jdbc.object.SqlFunction": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * SQL \"function\" wrapper for a query that returns a single row of results.\n * The default behavior is to return an int, but that can be overridden by\n * using the constructor with an extra return type parameter.\n *\n * <p>Intended to use to call SQL functions that return a single result using a\n * query like \"select user()\" or \"select sysdate from dual\". It is not intended\n * for calling more complex stored functions or for using a CallableStatement to\n * invoke a stored procedure or stored function. Use StoredProcedure or SqlCall\n * for this type of processing.\n *\n * <p>This is a concrete class, which there is often no need to subclass.\n * Code using this package can create an object of this type, declaring SQL\n * and parameters, and then invoke the appropriate {@code run} method\n * repeatedly to execute the function. Subclasses are only supposed to add\n * specialized {@code run} methods for specific parameter and return types.\n *\n * <p>Like all RdbmsOperation objects, SqlFunction objects are thread-safe.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Jean-Pierre Pawlak\n * @param <T> the result type\n * @see StoredProcedure\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "signature": "public class SqlFunction",
    "source_code": "public class SqlFunction<T> extends MappingSqlQuery<T> {\n\n\tprivate final SingleColumnRowMapper<T> rowMapper = new SingleColumnRowMapper<>();\n\n\n\t/**\n\t * Constructor to allow use as a JavaBean.\n\t * A DataSource, SQL and any parameters must be supplied before\n\t * invoking the {@code compile} method and using this object.\n\t * @see #setDataSource\n\t * @see #setSql\n\t * @see #compile\n\t */\n\tpublic SqlFunction() {\n\t\tsetRowsExpected(1);\n\t}\n\n\t/**\n\t * Create a new SqlFunction object with SQL, but without parameters.\n\t * Must add parameters or settle with none.\n\t * @param ds the DataSource to obtain connections from\n\t * @param sql the SQL to execute\n\t */\n\tpublic SqlFunction(DataSource ds, String sql) {\n\t\tsetRowsExpected(1);\n\t\tsetDataSource(ds);\n\t\tsetSql(sql);\n\t}\n\n\t/**\n\t * Create a new SqlFunction object with SQL and parameters.\n\t * @param ds the DataSource to obtain connections from\n\t * @param sql the SQL to execute\n\t * @param types the SQL types of the parameters, as defined in the\n\t * {@code java.sql.Types} class\n\t * @see java.sql.Types\n\t */\n\tpublic SqlFunction(DataSource ds, String sql, int[] types) {\n\t\tsetRowsExpected(1);\n\t\tsetDataSource(ds);\n\t\tsetSql(sql);\n\t\tsetTypes(types);\n\t}\n\n\t/**\n\t * Create a new SqlFunction object with SQL, parameters and a result type.\n\t * @param ds the DataSource to obtain connections from\n\t * @param sql the SQL to execute\n\t * @param types the SQL types of the parameters, as defined in the\n\t * {@code java.sql.Types} class\n\t * @param resultType the type that the result object is required to match\n\t * @see #setResultType(Class)\n\t * @see java.sql.Types\n\t */\n\tpublic SqlFunction(DataSource ds, String sql, int[] types, Class<T> resultType) {\n\t\tsetRowsExpected(1);\n\t\tsetDataSource(ds);\n\t\tsetSql(sql);\n\t\tsetTypes(types);\n\t\tsetResultType(resultType);\n\t}\n\n\n\t/**\n\t * Specify the type that the result object is required to match.\n\t * <p>If not specified, the result value will be exposed as\n\t * returned by the JDBC driver.\n\t */\n\tpublic void setResultType(Class<T> resultType) {\n\t\tthis.rowMapper.setRequiredType(resultType);\n\t}\n\n\n\t/**\n\t * This implementation of this method extracts a single value from the\n\t * single row returned by the function. If there are a different number\n\t * of rows returned, this is treated as an error.\n\t */\n\t@Override\n\t@Nullable\n\tprotected T mapRow(ResultSet rs, int rowNum) throws SQLException {\n\t\treturn this.rowMapper.mapRow(rs, rowNum);\n\t}\n\n\n\t/**\n\t * Convenient method to run the function without arguments.\n\t * @return the value of the function\n\t */\n\tpublic int run() {\n\t\treturn run(new Object[0]);\n\t}\n\n\t/**\n\t * Convenient method to run the function with a single int argument.\n\t * @param parameter single int parameter\n\t * @return the value of the function\n\t */\n\tpublic int run(int parameter) {\n\t\treturn run(new Object[] {parameter});\n\t}\n\n\t/**\n\t * Analogous to the SqlQuery.execute([]) method. This is a\n\t * generic method to execute a query, taken a number of arguments.\n\t * @param parameters array of parameters. These will be objects or\n\t * object wrapper types for primitives.\n\t * @return the value of the function\n\t */\n\tpublic int run(Object... parameters) {\n\t\tObject obj = super.findObject(parameters);\n\t\tif (!(obj instanceof Number number)) {\n\t\t\tthrow new TypeMismatchDataAccessException(\"Could not convert result object [\" + obj + \"] to int\");\n\t\t}\n\t\treturn number.intValue();\n\t}\n\n\t/**\n\t * Convenient method to run the function without arguments,\n\t * returning the value as an object.\n\t * @return the value of the function\n\t */\n\t@Nullable\n\tpublic Object runGeneric() {\n\t\treturn findObject((Object[]) null, null);\n\t}\n\n\t/**\n\t * Convenient method to run the function with a single int argument.\n\t * @param parameter single int parameter\n\t * @return the value of the function as an Object\n\t */\n\t@Nullable\n\tpublic Object runGeneric(int parameter) {\n\t\treturn findObject(parameter);\n\t}\n\n\t/**\n\t * Analogous to the {@code SqlQuery.findObject(Object[])} method.\n\t * This is a generic method to execute a query, taken a number of arguments.\n\t * @param parameters array of parameters. These will be objects or\n\t * object wrapper types for primitives.\n\t * @return the value of the function, as an Object\n\t * @see #execute(Object[])\n\t */\n\t@Nullable\n\tpublic Object runGeneric(Object[] parameters) {\n\t\treturn findObject(parameters);\n\t}\n\n}"
  },
  "org.springframework.jdbc.object.SqlFunction#mapRow(rs,rowNum)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation of this method extracts a single value from the\n\t * single row returned by the function. If there are a different number\n\t * of rows returned, this is treated as an error.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "rowNum"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "T",
    "signature": "protected T mapRow(ResultSet rs, int rowNum)",
    "source_code": "\tprotected T mapRow(ResultSet rs, int rowNum) throws SQLException {\n\t\treturn this.rowMapper.mapRow(rs, rowNum);\n\t}"
  },
  "org.springframework.jdbc.object.SqlFunction#run()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to run the function without arguments.\n\t * @return the value of the function\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "int",
    "signature": "public int run()",
    "source_code": "\tpublic int run() {\n\t\treturn run(new Object[0]);\n\t}"
  },
  "org.springframework.jdbc.object.SqlFunction#run(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to run the function with a single int argument.\n\t * @param parameter single int parameter\n\t * @return the value of the function\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "int",
    "signature": "public int run(int parameter)",
    "source_code": "\tpublic int run(int parameter) {\n\t\treturn run(new Object[] {parameter});\n\t}"
  },
  "org.springframework.jdbc.object.SqlFunction#run(parameters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Analogous to the SqlQuery.execute([]) method. This is a\n\t * generic method to execute a query, taken a number of arguments.\n\t * @param parameters array of parameters. These will be objects or\n\t * object wrapper types for primitives.\n\t * @return the value of the function\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "int",
    "signature": "public int run(Object... parameters)",
    "source_code": "\tpublic int run(Object... parameters) {\n\t\tObject obj = super.findObject(parameters);\n\t\tif (!(obj instanceof Number number)) {\n\t\t\tthrow new TypeMismatchDataAccessException(\"Could not convert result object [\" + obj + \"] to int\");\n\t\t}\n\t\treturn number.intValue();\n\t}"
  },
  "org.springframework.jdbc.object.SqlFunction#runGeneric()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to run the function without arguments,\n\t * returning the value as an object.\n\t * @return the value of the function\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "Object",
    "signature": "public Object runGeneric()",
    "source_code": "\tpublic Object runGeneric() {\n\t\treturn findObject((Object[]) null, null);\n\t}"
  },
  "org.springframework.jdbc.object.SqlFunction#runGeneric(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to run the function with a single int argument.\n\t * @param parameter single int parameter\n\t * @return the value of the function as an Object\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "Object",
    "signature": "public Object runGeneric(int parameter)",
    "source_code": "\tpublic Object runGeneric(int parameter) {\n\t\treturn findObject(parameter);\n\t}"
  },
  "org.springframework.jdbc.object.SqlFunction#runGeneric(parameters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Analogous to the {@code SqlQuery.findObject(Object[])} method.\n\t * This is a generic method to execute a query, taken a number of arguments.\n\t * @param parameters array of parameters. These will be objects or\n\t * object wrapper types for primitives.\n\t * @return the value of the function, as an Object\n\t * @see #execute(Object[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "Object",
    "signature": "public Object runGeneric(Object[] parameters)",
    "source_code": "\tpublic Object runGeneric(Object[] parameters) {\n\t\treturn findObject(parameters);\n\t}"
  },
  "org.springframework.jdbc.object.SqlFunction#setResultType(resultType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the type that the result object is required to match.\n\t * <p>If not specified, the result value will be exposed as\n\t * returned by the JDBC driver.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resultType"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void setResultType(Class<T> resultType)",
    "source_code": "\tpublic void setResultType(Class<T> resultType) {\n\t\tthis.rowMapper.setRequiredType(resultType);\n\t}"
  },
  "org.springframework.jms.listener.adapter.MessageListenerAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Message listener adapter that delegates the handling of messages to target\n * listener methods via reflection, with flexible message type conversion.\n * Allows listener methods to operate on message content types, completely\n * independent of the JMS API.\n *\n * <p>By default, the content of incoming JMS messages gets extracted before\n * being passed into the target listener method, to let the target method\n * operate on message content types such as String or byte array instead of\n * the raw {@link Message}. Message type conversion is delegated to a Spring\n * JMS {@link MessageConverter}. By default, a {@link SimpleMessageConverter}\n * will be used. (If you do not want such automatic message conversion taking\n * place, then be sure to set the {@link #setMessageConverter MessageConverter}\n * to {@code null}.)\n *\n * <p>If a target listener method returns a non-null object (typically of a\n * message content type such as {@code String} or byte array), it will get\n * wrapped in a JMS {@code Message} and sent to the response destination\n * (either the JMS \"reply-to\" destination or a\n * {@link #setDefaultResponseDestination(jakarta.jms.Destination) specified default\n * destination}).\n *\n * <p><b>Note:</b> The sending of response messages is only available when\n * using the {@link SessionAwareMessageListener} entry point (typically through a\n * Spring message listener container). Usage as standard JMS {@link MessageListener}\n * does <i>not</i> support the generation of response messages.\n *\n * <p>Find below some examples of method signatures compliant with this\n * adapter class. This first example handles all {@code Message} types\n * and gets passed the contents of each {@code Message} type as an\n * argument. No {@code Message} will be sent back as all of these\n * methods return {@code void}.\n *\n * <pre class=\"code\">public interface MessageContentsDelegate {\n *    void handleMessage(String text);\n *    void handleMessage(Map map);\n *    void handleMessage(byte[] bytes);\n *    void handleMessage(Serializable obj);\n * }</pre>\n *\n * This next example handles all {@code Message} types and gets\n * passed the actual (raw) {@code Message} as an argument. Again, no\n * {@code Message} will be sent back as all of these methods return\n * {@code void}.\n *\n * <pre class=\"code\">public interface RawMessageDelegate {\n *    void handleMessage(TextMessage message);\n *    void handleMessage(MapMessage message);\n *    void handleMessage(BytesMessage message);\n *    void handleMessage(ObjectMessage message);\n * }</pre>\n *\n * This next example illustrates a {@code Message} delegate\n * that just consumes the {@code String} contents of\n * {@link jakarta.jms.TextMessage TextMessages}. Notice also how the\n * name of the {@code Message} handling method is different from the\n * {@link #ORIGINAL_DEFAULT_LISTENER_METHOD original} (this will have to\n * be configured in the attendant bean definition). Again, no {@code Message}\n * will be sent back as the method returns {@code void}.\n *\n * <pre class=\"code\">public interface TextMessageContentDelegate {\n *    void onMessage(String text);\n * }</pre>\n *\n * This final example illustrates a {@code Message} delegate\n * that just consumes the {@code String} contents of\n * {@link jakarta.jms.TextMessage TextMessages}. Notice how the return type\n * of this method is {@code String}: This will result in the configured\n * {@link MessageListenerAdapter} sending a {@link jakarta.jms.TextMessage} in response.\n *\n * <pre class=\"code\">public interface ResponsiveTextMessageContentDelegate {\n *    String handleMessage(String text);\n * }</pre>\n *\n * For further examples and discussion please do refer to the Spring\n * reference documentation which describes this class (and it's attendant\n * XML configuration) in detail.\n *\n * @author Juergen Hoeller\n * @since 2.0\n * @see #setDelegate\n * @see #setDefaultListenerMethod\n * @see #setDefaultResponseDestination\n * @see #setMessageConverter\n * @see org.springframework.jms.support.converter.SimpleMessageConverter\n * @see org.springframework.jms.listener.SessionAwareMessageListener\n * @see org.springframework.jms.listener.AbstractMessageListenerContainer#setMessageListener\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "signature": "public class MessageListenerAdapter",
    "source_code": "public class MessageListenerAdapter extends AbstractAdaptableMessageListener implements SubscriptionNameProvider {\n\n\t/**\n\t * Out-of-the-box value for the default listener method: \"handleMessage\".\n\t */\n\tpublic static final String ORIGINAL_DEFAULT_LISTENER_METHOD = \"handleMessage\";\n\n\n\tprivate Object delegate;\n\n\tprivate String defaultListenerMethod = ORIGINAL_DEFAULT_LISTENER_METHOD;\n\n\n\t/**\n\t * Create a new {@link MessageListenerAdapter} with default settings.\n\t */\n\tpublic MessageListenerAdapter() {\n\t\tthis.delegate = this;\n\t}\n\n\t/**\n\t * Create a new {@link MessageListenerAdapter} for the given delegate.\n\t * @param delegate the delegate object\n\t */\n\tpublic MessageListenerAdapter(Object delegate) {\n\t\tAssert.notNull(delegate, \"Delegate must not be null\");\n\t\tthis.delegate = delegate;\n\t}\n\n\n\t/**\n\t * Set a target object to delegate message listening to.\n\t * Specified listener methods have to be present on this target object.\n\t * <p>If no explicit delegate object has been specified, listener\n\t * methods are expected to present on this adapter instance, that is,\n\t * on a custom subclass of this adapter, defining listener methods.\n\t */\n\tpublic void setDelegate(Object delegate) {\n\t\tAssert.notNull(delegate, \"Delegate must not be null\");\n\t\tthis.delegate = delegate;\n\t}\n\n\t/**\n\t * Return the target object to delegate message listening to.\n\t */\n\tprotected Object getDelegate() {\n\t\treturn this.delegate;\n\t}\n\n\t/**\n\t * Specify the name of the default listener method to delegate to,\n\t * for the case where no specific listener method has been determined.\n\t * Out-of-the-box value is {@link #ORIGINAL_DEFAULT_LISTENER_METHOD \"handleMessage\"}.\n\t * @see #getListenerMethodName\n\t */\n\tpublic void setDefaultListenerMethod(String defaultListenerMethod) {\n\t\tthis.defaultListenerMethod = defaultListenerMethod;\n\t}\n\n\t/**\n\t * Return the name of the default listener method to delegate to.\n\t */\n\tprotected String getDefaultListenerMethod() {\n\t\treturn this.defaultListenerMethod;\n\t}\n\n\n\t/**\n\t * Spring {@link SessionAwareMessageListener} entry point.\n\t * <p>Delegates the message to the target listener method, with appropriate\n\t * conversion of the message argument. If the target method returns a\n\t * non-null object, wrap in a JMS message and send it back.\n\t * @param message the incoming JMS message\n\t * @param session the JMS session to operate on\n\t * @throws JMSException if thrown by JMS API methods\n\t */\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void onMessage(Message message, @Nullable Session session) throws JMSException {\n\t\t// Check whether the delegate is a MessageListener impl itself.\n\t\t// In that case, the adapter will simply act as a pass-through.\n\t\tObject delegate = getDelegate();\n\t\tif (delegate != this) {\n\t\t\tif (delegate instanceof SessionAwareMessageListener) {\n\t\t\t\tAssert.state(session != null, \"Session is required for SessionAwareMessageListener\");\n\t\t\t\t((SessionAwareMessageListener<Message>) delegate).onMessage(message, session);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (delegate instanceof MessageListener listener) {\n\t\t\t\tlistener.onMessage(message);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Regular case: find a handler method reflectively.\n\t\tObject convertedMessage = extractMessage(message);\n\t\tString methodName = getListenerMethodName(message, convertedMessage);\n\n\t\t// Invoke the handler method with appropriate arguments.\n\t\tObject[] listenerArguments = buildListenerArguments(convertedMessage);\n\t\tObject result = invokeListenerMethod(methodName, listenerArguments);\n\t\tif (result != null) {\n\t\t\thandleResult(result, message, session);\n\t\t}\n\t\telse {\n\t\t\tlogger.trace(\"No result object given - no result to handle\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getSubscriptionName() {\n\t\tObject delegate = getDelegate();\n\t\tif (delegate != this && delegate instanceof SubscriptionNameProvider provider) {\n\t\t\treturn provider.getSubscriptionName();\n\t\t}\n\t\telse {\n\t\t\treturn delegate.getClass().getName();\n\t\t}\n\t}\n\n\t/**\n\t * Determine the name of the listener method that is supposed to\n\t * handle the given message.\n\t * <p>The default implementation simply returns the configured\n\t * default listener method, if any.\n\t * @param originalMessage the JMS request message\n\t * @param extractedMessage the converted JMS request message,\n\t * to be passed into the listener method as argument\n\t * @return the name of the listener method (never {@code null})\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setDefaultListenerMethod\n\t */\n\tprotected String getListenerMethodName(Message originalMessage, Object extractedMessage) throws JMSException {\n\t\treturn getDefaultListenerMethod();\n\t}\n\n\t/**\n\t * Build an array of arguments to be passed into the target listener method.\n\t * Allows for multiple method arguments to be built from a single message object.\n\t * <p>The default implementation builds an array with the given message object\n\t * as sole element. This means that the extracted message will always be passed\n\t * into a <i>single</i> method argument, even if it is an array, with the target\n\t * method having a corresponding single argument of the array's type declared.\n\t * <p>This can be overridden to treat special message content such as arrays\n\t * differently, for example passing in each element of the message array\n\t * as distinct method argument.\n\t * @param extractedMessage the content of the message\n\t * @return the array of arguments to be passed into the\n\t * listener method (each element of the array corresponding\n\t * to a distinct method argument)\n\t */\n\tprotected Object[] buildListenerArguments(Object extractedMessage) {\n\t\treturn new Object[] {extractedMessage};\n\t}\n\n\t/**\n\t * Invoke the specified listener method.\n\t * @param methodName the name of the listener method\n\t * @param arguments the message arguments to be passed in\n\t * @return the result returned from the listener method\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #getListenerMethodName\n\t * @see #buildListenerArguments\n\t */\n\t@Nullable\n\tprotected Object invokeListenerMethod(String methodName, Object[] arguments) throws JMSException {\n\t\ttry {\n\t\t\tMethodInvoker methodInvoker = new MethodInvoker();\n\t\t\tmethodInvoker.setTargetObject(getDelegate());\n\t\t\tmethodInvoker.setTargetMethod(methodName);\n\t\t\tmethodInvoker.setArguments(arguments);\n\t\t\tmethodInvoker.prepare();\n\t\t\treturn methodInvoker.invoke();\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tThrowable targetEx = ex.getTargetException();\n\t\t\tif (targetEx instanceof JMSException jmsException) {\n\t\t\t\tthrow jmsException;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new ListenerExecutionFailedException(\n\t\t\t\t\t\t\"Listener method '\" + methodName + \"' threw exception\", targetEx);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new ListenerExecutionFailedException(\"Failed to invoke target method '\" + methodName +\n\t\t\t\t\t\"' with arguments \" + ObjectUtils.nullSafeToString(arguments), ex);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jms.listener.adapter.MessageListenerAdapter#buildListenerArguments(extractedMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build an array of arguments to be passed into the target listener method.\n\t * Allows for multiple method arguments to be built from a single message object.\n\t * <p>The default implementation builds an array with the given message object\n\t * as sole element. This means that the extracted message will always be passed\n\t * into a <i>single</i> method argument, even if it is an array, with the target\n\t * method having a corresponding single argument of the array's type declared.\n\t * <p>This can be overridden to treat special message content such as arrays\n\t * differently, for example passing in each element of the message array\n\t * as distinct method argument.\n\t * @param extractedMessage the content of the message\n\t * @return the array of arguments to be passed into the\n\t * listener method (each element of the array corresponding\n\t * to a distinct method argument)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "extractedMessage"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "Object[]",
    "signature": "protected Object[] buildListenerArguments(Object extractedMessage)",
    "source_code": "\tprotected Object[] buildListenerArguments(Object extractedMessage) {\n\t\treturn new Object[] {extractedMessage};\n\t}"
  },
  "org.springframework.jms.listener.adapter.MessageListenerAdapter#getDefaultListenerMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the default listener method to delegate to.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "String",
    "signature": "protected String getDefaultListenerMethod()",
    "source_code": "\tprotected String getDefaultListenerMethod() {\n\t\treturn this.defaultListenerMethod;\n\t}"
  },
  "org.springframework.jms.listener.adapter.MessageListenerAdapter#getDelegate()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the target object to delegate message listening to.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "Object",
    "signature": "protected Object getDelegate()",
    "source_code": "\tprotected Object getDelegate() {\n\t\treturn this.delegate;\n\t}"
  },
  "org.springframework.jms.listener.adapter.MessageListenerAdapter#getListenerMethodName(originalMessage,extractedMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the name of the listener method that is supposed to\n\t * handle the given message.\n\t * <p>The default implementation simply returns the configured\n\t * default listener method, if any.\n\t * @param originalMessage the JMS request message\n\t * @param extractedMessage the converted JMS request message,\n\t * to be passed into the listener method as argument\n\t * @return the name of the listener method (never {@code null})\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setDefaultListenerMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "originalMessage",
      "extractedMessage"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "String",
    "signature": "protected String getListenerMethodName(Message originalMessage, Object extractedMessage)",
    "source_code": "\tprotected String getListenerMethodName(Message originalMessage, Object extractedMessage) throws JMSException {\n\t\treturn getDefaultListenerMethod();\n\t}"
  },
  "org.springframework.jms.listener.adapter.MessageListenerAdapter#getSubscriptionName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "String",
    "signature": "public String getSubscriptionName()",
    "source_code": "\tpublic String getSubscriptionName() {\n\t\tObject delegate = getDelegate();\n\t\tif (delegate != this && delegate instanceof SubscriptionNameProvider provider) {\n\t\t\treturn provider.getSubscriptionName();\n\t\t}\n\t\telse {\n\t\t\treturn delegate.getClass().getName();\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.adapter.MessageListenerAdapter#invokeListenerMethod(methodName,arguments)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified listener method.\n\t * @param methodName the name of the listener method\n\t * @param arguments the message arguments to be passed in\n\t * @return the result returned from the listener method\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #getListenerMethodName\n\t * @see #buildListenerArguments\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "Object",
    "signature": "protected Object invokeListenerMethod(String methodName, Object[] arguments)",
    "source_code": "\tprotected Object invokeListenerMethod(String methodName, Object[] arguments) throws JMSException {\n\t\ttry {\n\t\t\tMethodInvoker methodInvoker = new MethodInvoker();\n\t\t\tmethodInvoker.setTargetObject(getDelegate());\n\t\t\tmethodInvoker.setTargetMethod(methodName);\n\t\t\tmethodInvoker.setArguments(arguments);\n\t\t\tmethodInvoker.prepare();\n\t\t\treturn methodInvoker.invoke();\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tThrowable targetEx = ex.getTargetException();\n\t\t\tif (targetEx instanceof JMSException jmsException) {\n\t\t\t\tthrow jmsException;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new ListenerExecutionFailedException(\n\t\t\t\t\t\t\"Listener method '\" + methodName + \"' threw exception\", targetEx);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new ListenerExecutionFailedException(\"Failed to invoke target method '\" + methodName +\n\t\t\t\t\t\"' with arguments \" + ObjectUtils.nullSafeToString(arguments), ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.adapter.MessageListenerAdapter#onMessage(message,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Spring {@link SessionAwareMessageListener} entry point.\n\t * <p>Delegates the message to the target listener method, with appropriate\n\t * conversion of the message argument. If the target method returns a\n\t * non-null object, wrap in a JMS message and send it back.\n\t * @param message the incoming JMS message\n\t * @param session the JMS session to operate on\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "void",
    "signature": "public void onMessage(Message message, @Nullable Session session)",
    "source_code": "\tpublic void onMessage(Message message, @Nullable Session session) throws JMSException {\n\t\t// Check whether the delegate is a MessageListener impl itself.\n\t\t// In that case, the adapter will simply act as a pass-through.\n\t\tObject delegate = getDelegate();\n\t\tif (delegate != this) {\n\t\t\tif (delegate instanceof SessionAwareMessageListener) {\n\t\t\t\tAssert.state(session != null, \"Session is required for SessionAwareMessageListener\");\n\t\t\t\t((SessionAwareMessageListener<Message>) delegate).onMessage(message, session);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (delegate instanceof MessageListener listener) {\n\t\t\t\tlistener.onMessage(message);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Regular case: find a handler method reflectively.\n\t\tObject convertedMessage = extractMessage(message);\n\t\tString methodName = getListenerMethodName(message, convertedMessage);\n\n\t\t// Invoke the handler method with appropriate arguments.\n\t\tObject[] listenerArguments = buildListenerArguments(convertedMessage);\n\t\tObject result = invokeListenerMethod(methodName, listenerArguments);\n\t\tif (result != null) {\n\t\t\thandleResult(result, message, session);\n\t\t}\n\t\telse {\n\t\t\tlogger.trace(\"No result object given - no result to handle\");\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.adapter.MessageListenerAdapter#setDefaultListenerMethod(defaultListenerMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the name of the default listener method to delegate to,\n\t * for the case where no specific listener method has been determined.\n\t * Out-of-the-box value is {@link #ORIGINAL_DEFAULT_LISTENER_METHOD \"handleMessage\"}.\n\t * @see #getListenerMethodName\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultListenerMethod"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "void",
    "signature": "public void setDefaultListenerMethod(String defaultListenerMethod)",
    "source_code": "\tpublic void setDefaultListenerMethod(String defaultListenerMethod) {\n\t\tthis.defaultListenerMethod = defaultListenerMethod;\n\t}"
  },
  "org.springframework.jms.listener.adapter.MessageListenerAdapter#setDelegate(delegate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a target object to delegate message listening to.\n\t * Specified listener methods have to be present on this target object.\n\t * <p>If no explicit delegate object has been specified, listener\n\t * methods are expected to present on this adapter instance, that is,\n\t * on a custom subclass of this adapter, defining listener methods.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "delegate"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void setDelegate(Object delegate)",
    "source_code": "\tpublic void setDelegate(Object delegate) {\n\t\tAssert.notNull(delegate, \"Delegate must not be null\");\n\t\tthis.delegate = delegate;\n\t}"
  },
  "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@link jakarta.jms.MessageListener} adapter that invokes a configurable\n * {@link InvocableHandlerMethod}.\n *\n * <p>Wraps the incoming {@link jakarta.jms.Message} to Spring's {@link Message}\n * abstraction, copying the JMS standard headers using a configurable\n * {@link JmsHeaderMapper}.\n *\n * <p>The original {@link jakarta.jms.Message} and the {@link jakarta.jms.Session}\n * are provided as additional arguments so that these can be injected as\n * method arguments if necessary.\n *\n * @author Stephane Nicoll\n * @since 4.1\n * @see Message\n * @see JmsHeaderMapper\n * @see InvocableHandlerMethod\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class MessagingMessageListenerAdapter",
    "source_code": "public class MessagingMessageListenerAdapter extends AbstractAdaptableMessageListener {\n\n\t@Nullable\n\tprivate InvocableHandlerMethod handlerMethod;\n\n\n\t/**\n\t * Set the {@link InvocableHandlerMethod} to use to invoke the method\n\t * processing an incoming {@link jakarta.jms.Message}.\n\t */\n\tpublic void setHandlerMethod(InvocableHandlerMethod handlerMethod) {\n\t\tthis.handlerMethod = handlerMethod;\n\t}\n\n\tprivate InvocableHandlerMethod getHandlerMethod() {\n\t\tAssert.state(this.handlerMethod != null, \"No HandlerMethod set\");\n\t\treturn this.handlerMethod;\n\t}\n\n\n\t@Override\n\tpublic void onMessage(jakarta.jms.Message jmsMessage, @Nullable Session session) throws JMSException {\n\t\tMessage<?> message = toMessagingMessage(jmsMessage);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Processing [\" + message + \"]\");\n\t\t}\n\t\tObject result = invokeHandler(jmsMessage, session, message);\n\t\tif (result != null) {\n\t\t\thandleResult(result, jmsMessage, session);\n\t\t}\n\t\telse {\n\t\t\tlogger.trace(\"No result object given - no result to handle\");\n\t\t}\n\t}\n\n\t@Override\n\tprotected Object preProcessResponse(Object result) {\n\t\tMethodParameter returnType = getHandlerMethod().getReturnType();\n\t\tif (result instanceof Message<?> message) {\n\t\t\treturn MessageBuilder.fromMessage(message)\n\t\t\t\t\t.setHeader(AbstractMessageSendingTemplate.CONVERSION_HINT_HEADER, returnType)\n\t\t\t\t\t.build();\n\t\t}\n\t\treturn MessageBuilder.withPayload(result).setHeader(\n\t\t\t\tAbstractMessageSendingTemplate.CONVERSION_HINT_HEADER, returnType).build();\n\t}\n\n\tprotected Message<?> toMessagingMessage(jakarta.jms.Message jmsMessage) {\n\t\ttry {\n\t\t\treturn (Message<?>) getMessagingMessageConverter().fromMessage(jmsMessage);\n\t\t}\n\t\tcatch (JMSException ex) {\n\t\t\tthrow new MessageConversionException(\"Could not convert JMS message\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Invoke the handler, wrapping any exception to a {@link ListenerExecutionFailedException}\n\t * with a dedicated error message.\n\t */\n\t@Nullable\n\tprivate Object invokeHandler(jakarta.jms.Message jmsMessage, @Nullable Session session, Message<?> message) {\n\t\tInvocableHandlerMethod handlerMethod = getHandlerMethod();\n\t\ttry {\n\t\t\treturn handlerMethod.invoke(message, jmsMessage, session);\n\t\t}\n\t\tcatch (MessagingException ex) {\n\t\t\tthrow new ListenerExecutionFailedException(\n\t\t\t\t\tcreateMessagingErrorMessage(\"Listener method could not be invoked with incoming message\"), ex);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new ListenerExecutionFailedException(\"Listener method '\" +\n\t\t\t\t\thandlerMethod.getMethod().toGenericString() + \"' threw exception\", ex);\n\t\t}\n\t}\n\n\tprivate String createMessagingErrorMessage(String description) {\n\t\tInvocableHandlerMethod handlerMethod = getHandlerMethod();\n\t\tStringBuilder sb = new StringBuilder(description).append('\\n')\n\t\t\t\t.append(\"Endpoint handler details:\\n\")\n\t\t\t\t.append(\"Method [\").append(handlerMethod.getMethod()).append(\"]\\n\")\n\t\t\t\t.append(\"Bean [\").append(handlerMethod.getBean()).append(\"]\\n\");\n\t\treturn sb.toString();\n\t}\n\n}"
  },
  "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapter#onMessage(jmsMessage,session)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jmsMessage",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "public void onMessage(jakarta.jms.Message jmsMessage, @Nullable Session session)",
    "source_code": "\tpublic void onMessage(jakarta.jms.Message jmsMessage, @Nullable Session session) throws JMSException {\n\t\tMessage<?> message = toMessagingMessage(jmsMessage);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Processing [\" + message + \"]\");\n\t\t}\n\t\tObject result = invokeHandler(jmsMessage, session, message);\n\t\tif (result != null) {\n\t\t\thandleResult(result, jmsMessage, session);\n\t\t}\n\t\telse {\n\t\t\tlogger.trace(\"No result object given - no result to handle\");\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapter#preProcessResponse(result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "result"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "Object",
    "signature": "protected Object preProcessResponse(Object result)",
    "source_code": "\tprotected Object preProcessResponse(Object result) {\n\t\tMethodParameter returnType = getHandlerMethod().getReturnType();\n\t\tif (result instanceof Message<?> message) {\n\t\t\treturn MessageBuilder.fromMessage(message)\n\t\t\t\t\t.setHeader(AbstractMessageSendingTemplate.CONVERSION_HINT_HEADER, returnType)\n\t\t\t\t\t.build();\n\t\t}\n\t\treturn MessageBuilder.withPayload(result).setHeader(\n\t\t\t\tAbstractMessageSendingTemplate.CONVERSION_HINT_HEADER, returnType).build();\n\t}"
  },
  "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapter#setHandlerMethod(handlerMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link InvocableHandlerMethod} to use to invoke the method\n\t * processing an incoming {@link jakarta.jms.Message}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "void",
    "signature": "public void setHandlerMethod(InvocableHandlerMethod handlerMethod)",
    "source_code": "\tpublic void setHandlerMethod(InvocableHandlerMethod handlerMethod) {\n\t\tthis.handlerMethod = handlerMethod;\n\t}"
  },
  "org.springframework.jms.listener.adapter.ORIGINAL_DEFAULT_LISTENER_METHOD": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Out-of-the-box value for the default listener method: \"handleMessage\".\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "signature": "public String ORIGINAL_DEFAULT_LISTENER_METHOD",
    "source_code": "\tpublic static final String ORIGINAL_DEFAULT_LISTENER_METHOD = \"handleMessage\";",
    "type": "String"
  },
  "org.springframework.jms.support.converter.MessagingMessageConverter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Convert a {@link Message} from the messaging abstraction to and from a\n * {@link jakarta.jms.Message} using an underlying {@link MessageConverter}\n * for the payload and a {@link org.springframework.jms.support.JmsHeaderMapper}\n * to map the JMS headers to and from standard message headers.\n *\n * @author Stephane Nicoll\n * @since 4.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public class MessagingMessageConverter",
    "source_code": "public class MessagingMessageConverter implements MessageConverter, InitializingBean {\n\n\tprivate MessageConverter payloadConverter;\n\n\tprivate JmsHeaderMapper headerMapper;\n\n\n\t/**\n\t * Create an instance with a default payload converter.\n\t * @see org.springframework.jms.support.converter.SimpleMessageConverter\n\t * @see org.springframework.jms.support.SimpleJmsHeaderMapper\n\t */\n\tpublic MessagingMessageConverter() {\n\t\tthis(new SimpleMessageConverter(), new SimpleJmsHeaderMapper());\n\t}\n\n\t/**\n\t * Create an instance with the specific payload converter.\n\t * @param payloadConverter the payload converter to use\n\t * @since 4.3.12\n\t */\n\tpublic MessagingMessageConverter(MessageConverter payloadConverter) {\n\t\tthis(payloadConverter, new SimpleJmsHeaderMapper());\n\t}\n\n\t/**\n\t * Create an instance with the specified payload converter and\n\t * header mapper.\n\t */\n\tpublic MessagingMessageConverter(MessageConverter payloadConverter, JmsHeaderMapper headerMapper) {\n\t\tAssert.notNull(payloadConverter, \"'payloadConverter' must not be null\");\n\t\tAssert.notNull(headerMapper, \"'headerMapper' must not be null\");\n\t\tthis.payloadConverter = payloadConverter;\n\t\tthis.headerMapper = headerMapper;\n\t}\n\n\n\t/**\n\t * Set the {@link MessageConverter} to use to convert the payload.\n\t */\n\tpublic void setPayloadConverter(MessageConverter payloadConverter) {\n\t\tthis.payloadConverter = payloadConverter;\n\t}\n\n\t/**\n\t * Set the {@link JmsHeaderMapper} to use to map JMS headers to and from\n\t * standard message headers.\n\t */\n\tpublic void setHeaderMapper(JmsHeaderMapper headerMapper) {\n\t\tthis.headerMapper = headerMapper;\n\t}\n\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\tAssert.notNull(this.payloadConverter, \"Property 'payloadConverter' is required\");\n\t\tAssert.notNull(this.headerMapper, \"Property 'headerMapper' is required\");\n\t}\n\n\n\t@Override\n\tpublic jakarta.jms.Message toMessage(Object object, Session session) throws JMSException, MessageConversionException {\n\t\tif (!(object instanceof Message<?> input)) {\n\t\t\tthrow new IllegalArgumentException(\"Could not convert [\" + object + \"] - only [\" +\n\t\t\t\t\tMessage.class.getName() + \"] is handled by this converter\");\n\t\t}\n\t\tMessageHeaders headers = input.getHeaders();\n\t\tObject conversionHint = headers.get(AbstractMessageSendingTemplate.CONVERSION_HINT_HEADER);\n\t\tjakarta.jms.Message reply = createMessageForPayload(input.getPayload(), session, conversionHint);\n\t\tthis.headerMapper.fromHeaders(headers, reply);\n\t\treturn reply;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic Object fromMessage(jakarta.jms.Message message) throws JMSException, MessageConversionException {\n\t\tMap<String, Object> mappedHeaders = extractHeaders(message);\n\t\tObject convertedObject = extractPayload(message);\n\t\tMessageBuilder<Object> builder = (convertedObject instanceof org.springframework.messaging.Message ?\n\t\t\t\tMessageBuilder.fromMessage((org.springframework.messaging.Message<Object>) convertedObject) :\n\t\t\t\tMessageBuilder.withPayload(convertedObject));\n\t\treturn builder.copyHeadersIfAbsent(mappedHeaders).build();\n\t}\n\n\t/**\n\t * Extract the payload of the specified {@link jakarta.jms.Message}.\n\t */\n\tprotected Object extractPayload(jakarta.jms.Message message) throws JMSException {\n\t\treturn this.payloadConverter.fromMessage(message);\n\t}\n\n\t/**\n\t * Create a JMS message for the specified payload and conversionHint.\n\t * The conversion hint is an extra object passed to the {@link MessageConverter},\n\t * e.g. the associated {@code MethodParameter} (may be {@code null}}."
  },
  "org.springframework.jms.support.converter.MessagingMessageConverter#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tAssert.notNull(this.payloadConverter, \"Property 'payloadConverter' is required\");\n\t\tAssert.notNull(this.headerMapper, \"Property 'headerMapper' is required\");\n\t}"
  },
  "org.springframework.jms.support.converter.MessagingMessageConverter#extractHeaders(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "MessageHeaders",
    "signature": "protected MessageHeaders extractHeaders(jakarta.jms.Message message)",
    "source_code": "\tprotected final MessageHeaders extractHeaders(jakarta.jms.Message message) {\n\t\treturn this.headerMapper.toHeaders(message);\n\t}"
  },
  "org.springframework.jms.support.converter.MessagingMessageConverter#extractPayload(message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract the payload of the specified {@link jakarta.jms.Message}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "Object",
    "signature": "protected Object extractPayload(jakarta.jms.Message message)",
    "source_code": "\tprotected Object extractPayload(jakarta.jms.Message message) throws JMSException {\n\t\treturn this.payloadConverter.fromMessage(message);\n\t}"
  },
  "org.springframework.jms.support.converter.MessagingMessageConverter#fromMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "Object",
    "signature": "public Object fromMessage(jakarta.jms.Message message)",
    "source_code": "\tpublic Object fromMessage(jakarta.jms.Message message) throws JMSException, MessageConversionException {\n\t\tMap<String, Object> mappedHeaders = extractHeaders(message);\n\t\tObject convertedObject = extractPayload(message);\n\t\tMessageBuilder<Object> builder = (convertedObject instanceof org.springframework.messaging.Message ?\n\t\t\t\tMessageBuilder.fromMessage((org.springframework.messaging.Message<Object>) convertedObject) :\n\t\t\t\tMessageBuilder.withPayload(convertedObject));\n\t\treturn builder.copyHeadersIfAbsent(mappedHeaders).build();\n\t}"
  },
  "org.springframework.jms.support.converter.MessagingMessageConverter#setHeaderMapper(headerMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link JmsHeaderMapper} to use to map JMS headers to and from\n\t * standard message headers.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerMapper"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void setHeaderMapper(JmsHeaderMapper headerMapper)",
    "source_code": "\tpublic void setHeaderMapper(JmsHeaderMapper headerMapper) {\n\t\tthis.headerMapper = headerMapper;\n\t}"
  },
  "org.springframework.jms.support.converter.MessagingMessageConverter#setPayloadConverter(payloadConverter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link MessageConverter} to use to convert the payload.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payloadConverter"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void setPayloadConverter(MessageConverter payloadConverter)",
    "source_code": "\tpublic void setPayloadConverter(MessageConverter payloadConverter) {\n\t\tthis.payloadConverter = payloadConverter;\n\t}"
  },
  "org.springframework.mock.web.MockBodyContent": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Mock implementation of the {@link jakarta.servlet.jsp.tagext.BodyContent} class.\n * Only necessary for testing applications when testing custom JSP tags.\n *\n * @author Juergen Hoeller\n * @since 2.5\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class MockBodyContent",
    "source_code": "public class MockBodyContent extends BodyContent {\n\n\tprivate final String content;\n\n\n\t/**\n\t * Create a MockBodyContent for the given response.\n\t * @param content the body content to expose\n\t * @param response the servlet response to wrap\n\t */\n\tpublic MockBodyContent(String content, HttpServletResponse response) {\n\t\tthis(content, response, null);\n\t}\n\n\t/**\n\t * Create a MockBodyContent for the given response.\n\t * @param content the body content to expose\n\t * @param targetWriter the target Writer to wrap\n\t */\n\tpublic MockBodyContent(String content, Writer targetWriter) {\n\t\tthis(content, null, targetWriter);\n\t}\n\n\t/**\n\t * Create a MockBodyContent for the given response.\n\t * @param content the body content to expose\n\t * @param response the servlet response to wrap\n\t * @param targetWriter the target Writer to wrap\n\t */\n\tpublic MockBodyContent(String content, @Nullable HttpServletResponse response, @Nullable Writer targetWriter) {\n\t\tsuper(adaptJspWriter(targetWriter, response));\n\t\tthis.content = content;\n\t}\n\n\tprivate static JspWriter adaptJspWriter(@Nullable Writer targetWriter, @Nullable HttpServletResponse response) {\n\t\tif (targetWriter instanceof JspWriter jspWriter) {\n\t\t\treturn jspWriter;\n\t\t}\n\t\telse {\n\t\t\treturn new MockJspWriter(response, targetWriter);\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic Reader getReader() {\n\t\treturn new StringReader(this.content);\n\t}\n\n\t@Override\n\tpublic String getString() {\n\t\treturn this.content;\n\t}\n\n\t@Override\n\tpublic void writeOut(Writer writer) throws IOException {\n\t\twriter.write(this.content);\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Delegating implementations of JspWriter's abstract methods\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic void clear() throws IOException {\n\t\tgetEnclosingWriter().clear();\n\t}\n\n\t@Override\n\tpublic void clearBuffer() throws IOException {\n\t\tgetEnclosingWriter().clearBuffer();\n\t}\n\n\t@Override\n\tpublic void close() throws IOException {\n\t\tgetEnclosingWriter().close();\n\t}\n\n\t@Override\n\tpublic int getRemaining() {\n\t\treturn getEnclosingWriter().getRemaining();\n\t}\n\n\t@Override\n\tpublic void newLine() throws IOException {\n\t\tgetEnclosingWriter().println();\n\t}\n\n\t@Override\n\tpublic void write(char[] value, int offset, int length) throws IOException {\n\t\tgetEnclosingWriter().write(value, offset, length);\n\t}\n\n\t@Override\n\tpublic void print(boolean value) throws IOException {\n\t\tgetEnclosingWriter().print(value);\n\t}\n\n\t@Override\n\tpublic void print(char value) throws IOException {\n\t\tgetEnclosingWriter().print(value);\n\t}\n\n\t@Override\n\tpublic void print(char[] value) throws IOException {\n\t\tgetEnclosingWriter().print(value);\n\t}\n\n\t@Override\n\tpublic void print(double value) throws IOException {\n\t\tgetEnclosingWriter().print(value);\n\t}\n\n\t@Override\n\tpublic void print(float value) throws IOException {\n\t\tgetEnclosingWriter().print(value);\n\t}\n\n\t@Override\n\tpublic void print(int value) throws IOException {\n\t\tgetEnclosingWriter().print(value);\n\t}\n\n\t@Override\n\tpublic void print(long value) throws IOException {\n\t\tgetEnclosingWriter().print(value);\n\t}\n\n\t@Override\n\tpublic void print(Object value) throws IOException {\n\t\tgetEnclosingWriter().print(value);\n\t}\n\n\t@Override\n\tpublic void print(String value) throws IOException {\n\t\tgetEnclosingWriter().print(value);\n\t}\n\n\t@Override\n\tpublic void println() throws IOException {\n\t\tgetEnclosingWriter().println();\n\t}\n\n\t@Override\n\tpublic void println(boolean value) throws IOException {\n\t\tgetEnclosingWriter().println(value);\n\t}\n\n\t@Override\n\tpublic void println(char value) throws IOException {\n\t\tgetEnclosingWriter().println(value);\n\t}\n\n\t@Override\n\tpublic void println(char[] value) throws IOException {\n\t\tgetEnclosingWriter().println(value);\n\t}\n\n\t@Override\n\tpublic void println(double value) throws IOException {\n\t\tgetEnclosingWriter().println(value);\n\t}\n\n\t@Override\n\tpublic void println(float value) throws IOException {\n\t\tgetEnclosingWriter().println(value);\n\t}\n\n\t@Override\n\tpublic void println(int value) throws IOException {\n\t\tgetEnclosingWriter().println(value);\n\t}\n\n\t@Override\n\tpublic void println(long value) throws IOException {\n\t\tgetEnclosingWriter().println(value);\n\t}\n\n\t@Override\n\tpublic void println(Object value) throws IOException {\n\t\tgetEnclosingWriter().println(value);\n\t}\n\n\t@Override\n\tpublic void println(String value) throws IOException {\n\t\tgetEnclosingWriter().println(value);\n\t}\n\n}"
  },
  "org.springframework.mock.web.MockBodyContent#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() throws IOException {\n\t\tgetEnclosingWriter().clear();\n\t}"
  },
  "org.springframework.mock.web.MockBodyContent#clearBuffer()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void clearBuffer()",
    "source_code": "\tpublic void clearBuffer() throws IOException {\n\t\tgetEnclosingWriter().clearBuffer();\n\t}"
  },
  "org.springframework.mock.web.MockBodyContent#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\tpublic void close() throws IOException {\n\t\tgetEnclosingWriter().close();\n\t}"
  },
  "org.springframework.mock.web.MockBodyContent#getReader()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "Reader",
    "signature": "public Reader getReader()",
    "source_code": "\tpublic Reader getReader() {\n\t\treturn new StringReader(this.content);\n\t}"
  },
  "org.springframework.mock.web.MockBodyContent#getRemaining()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "int",
    "signature": "public int getRemaining()",
    "source_code": "\tpublic int getRemaining() {\n\t\treturn getEnclosingWriter().getRemaining();\n\t}"
  },
  "org.springframework.mock.web.MockBodyContent#getString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "String",
    "signature": "public String getString()",
    "source_code": "\tpublic String getString() {\n\t\treturn this.content;\n\t}"
  },
  "org.springframework.mock.web.MockBodyContent#newLine()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void newLine()",
    "source_code": "\tpublic void newLine() throws IOException {\n\t\tgetEnclosingWriter().println();\n\t}"
  },
  "org.springframework.mock.web.MockBodyContent#print(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "void",
    "signature": "public void print(String value)",
    "source_code": "\tpublic void print(String value) throws IOException {\n\t\tgetEnclosingWriter().print(value);\n\t}"
  },
  "org.springframework.mock.web.MockBodyContent#println()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "void",
    "signature": "public void println()",
    "source_code": "\tpublic void println() throws IOException {\n\t\tgetEnclosingWriter().println();\n\t}"
  },
  "org.springframework.mock.web.MockBodyContent#println(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "void",
    "signature": "public void println(String value)",
    "source_code": "\tpublic void println(String value) throws IOException {\n\t\tgetEnclosingWriter().println(value);\n\t}"
  },
  "org.springframework.mock.web.MockBodyContent#write(value,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void write(char[] value, int offset, int length)",
    "source_code": "\tpublic void write(char[] value, int offset, int length) throws IOException {\n\t\tgetEnclosingWriter().write(value, offset, length);\n\t}"
  },
  "org.springframework.mock.web.MockBodyContent#writeOut(writer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "writer"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "void",
    "signature": "public void writeOut(Writer writer)",
    "source_code": "\tpublic void writeOut(Writer writer) throws IOException {\n\t\twriter.write(this.content);\n\t}"
  },
  "org.springframework.mock.web.MockHttpSession": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Mock implementation of the {@link jakarta.servlet.http.HttpSession} interface.\n *\n * <p>As of Spring 6.0, this set of mocks is designed on a Servlet 6.0 baseline.\n *\n * @author Juergen Hoeller\n * @author Rod Johnson\n * @author Mark Fisher\n * @author Sam Brannen\n * @author Vedran Pavic\n * @since 1.0.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class MockHttpSession",
    "source_code": "public class MockHttpSession implements HttpSession {\n\n\t/**\n\t * The session cookie name.\n\t */\n\tpublic static final String SESSION_COOKIE_NAME = \"JSESSION\";\n\n\n\tprivate static int nextId = 1;\n\n\tprivate String id;\n\n\tprivate final long creationTime = System.currentTimeMillis();\n\n\tprivate int maxInactiveInterval;\n\n\tprivate long lastAccessedTime = System.currentTimeMillis();\n\n\tprivate final ServletContext servletContext;\n\n\tprivate final Map<String, Object> attributes = new LinkedHashMap<>();\n\n\tprivate boolean invalid = false;\n\n\tprivate boolean isNew = true;\n\n\n\t/**\n\t * Create a new MockHttpSession with a default {@link MockServletContext}.\n\t * @see MockServletContext\n\t */\n\tpublic MockHttpSession() {\n\t\tthis(null);\n\t}\n\n\t/**\n\t * Create a new MockHttpSession.\n\t * @param servletContext the ServletContext that the session runs in\n\t */\n\tpublic MockHttpSession(@Nullable ServletContext servletContext) {\n\t\tthis(servletContext, null);\n\t}\n\n\t/**\n\t * Create a new MockHttpSession.\n\t * @param servletContext the ServletContext that the session runs in\n\t * @param id a unique identifier for this session\n\t */\n\tpublic MockHttpSession(@Nullable ServletContext servletContext, @Nullable String id) {\n\t\tthis.servletContext = (servletContext != null ? servletContext : new MockServletContext());\n\t\tthis.id = (id != null ? id : Integer.toString(nextId++));\n\t}\n\n\n\t@Override\n\tpublic long getCreationTime() {\n\t\tassertIsValid();\n\t\treturn this.creationTime;\n\t}\n\n\t@Override\n\tpublic String getId() {\n\t\treturn this.id;\n\t}\n\n\t/**\n\t * As of Servlet 3.1, the id of a session can be changed.\n\t * @return the new session id\n\t * @since 4.0.3\n\t */\n\tpublic String changeSessionId() {\n\t\tthis.id = Integer.toString(nextId++);\n\t\treturn this.id;\n\t}\n\n\tpublic void access() {\n\t\tthis.lastAccessedTime = System.currentTimeMillis();\n\t\tthis.isNew = false;\n\t}\n\n\t@Override\n\tpublic long getLastAccessedTime() {\n\t\tassertIsValid();\n\t\treturn this.lastAccessedTime;\n\t}\n\n\t@Override\n\tpublic ServletContext getServletContext() {\n\t\treturn this.servletContext;\n\t}\n\n\t@Override\n\tpublic void setMaxInactiveInterval(int interval) {\n\t\tthis.maxInactiveInterval = interval;\n\t}\n\n\t@Override\n\tpublic int getMaxInactiveInterval() {\n\t\treturn this.maxInactiveInterval;\n\t}\n\n\t@Override\n\tpublic Object getAttribute(String name) {\n\t\tassertIsValid();\n\t\tAssert.notNull(name, \"Attribute name must not be null\");\n\t\treturn this.attributes.get(name);\n\t}\n\n\t@Override\n\tpublic Enumeration<String> getAttributeNames() {\n\t\tassertIsValid();\n\t\treturn Collections.enumeration(new LinkedHashSet<>(this.attributes.keySet()));\n\t}\n\n\t@Override\n\tpublic void setAttribute(String name, @Nullable Object value) {\n\t\tassertIsValid();\n\t\tAssert.notNull(name, \"Attribute name must not be null\");\n\t\tif (value != null) {\n\t\t\tObject oldValue = this.attributes.put(name, value);\n\t\t\tif (value != oldValue) {\n\t\t\t\tif (oldValue instanceof HttpSessionBindingListener listener) {\n\t\t\t\t\tlistener.valueUnbound(new HttpSessionBindingEvent(this, name, oldValue));\n\t\t\t\t}\n\t\t\t\tif (value instanceof HttpSessionBindingListener listener) {\n\t\t\t\t\tlistener.valueBound(new HttpSessionBindingEvent(this, name, value));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tremoveAttribute(name);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void removeAttribute(String name) {\n\t\tassertIsValid();\n\t\tAssert.notNull(name, \"Attribute name must not be null\");\n\t\tObject value = this.attributes.remove(name);\n\t\tif (value instanceof HttpSessionBindingListener listener) {\n\t\t\tlistener.valueUnbound(new HttpSessionBindingEvent(this, name, value));\n\t\t}\n\t}\n\n\t/**\n\t * Clear all of this session's attributes.\n\t */\n\tpublic void clearAttributes() {\n\t\tfor (Iterator<Map.Entry<String, Object>> it = this.attributes.entrySet().iterator(); it.hasNext();) {\n\t\t\tMap.Entry<String, Object> entry = it.next();\n\t\t\tString name = entry.getKey();\n\t\t\tObject value = entry.getValue();\n\t\t\tit.remove();\n\t\t\tif (value instanceof HttpSessionBindingListener listener) {\n\t\t\t\tlistener.valueUnbound(new HttpSessionBindingEvent(this, name, value));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Invalidates this session then unbinds any objects bound to it.\n\t * @throws IllegalStateException if this method is called on an already invalidated session\n\t */\n\t@Override\n\tpublic void invalidate() {\n\t\tassertIsValid();\n\t\tthis.invalid = true;\n\t\tclearAttributes();\n\t}\n\n\tpublic boolean isInvalid() {\n\t\treturn this.invalid;\n\t}\n\n\t/**\n\t * Convenience method for asserting that this session has not been\n\t * {@linkplain #invalidate() invalidated}.\n\t * @throws IllegalStateException if this session has been invalidated\n\t */\n\tprivate void assertIsValid() {\n\t\tAssert.state(!isInvalid(), \"The session has already been invalidated\");\n\t}\n\n\tpublic void setNew(boolean value) {\n\t\tthis.isNew = value;\n\t}\n\n\t@Override\n\tpublic boolean isNew() {\n\t\tassertIsValid();\n\t\treturn this.isNew;\n\t}\n\n\t/**\n\t * Serialize the attributes of this session into an object that can be\n\t * turned into a byte array with standard Java serialization.\n\t * @return a representation of this session's serialized state\n\t */\n\tpublic Serializable serializeState() {\n\t\tHashMap<String, Serializable> state = new HashMap<>();\n\t\tfor (Iterator<Map.Entry<String, Object>> it = this.attributes.entrySet().iterator(); it.hasNext();) {\n\t\t\tMap.Entry<String, Object> entry = it.next();\n\t\t\tString name = entry.getKey();\n\t\t\tObject value = entry.getValue();\n\t\t\tit.remove();\n\t\t\tif (value instanceof Serializable serializable) {\n\t\t\t\tstate.put(name, serializable);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Not serializable... Servlet containers usually automatically\n\t\t\t\t// unbind the attribute in this case.\n\t\t\t\tif (value instanceof HttpSessionBindingListener listener) {\n\t\t\t\t\tlistener.valueUnbound(new HttpSessionBindingEvent(this, name, value));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn state;\n\t}\n\n\t/**\n\t * Deserialize the attributes of this session from a state object created by\n\t * {@link #serializeState()}.\n\t * @param state a representation of this session's serialized state\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void deserializeState(Serializable state) {\n\t\tAssert.isTrue(state instanceof Map, \"Serialized state needs to be of type [java.util.Map]\");\n\t\tthis.attributes.putAll((Map<String, Object>) state);\n\t}\n\n}"
  },
  "org.springframework.mock.web.MockHttpSession#access()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "void",
    "signature": "public void access()",
    "source_code": "\tpublic void access() {\n\t\tthis.lastAccessedTime = System.currentTimeMillis();\n\t\tthis.isNew = false;\n\t}"
  },
  "org.springframework.mock.web.MockHttpSession#changeSessionId()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * As of Servlet 3.1, the id of a session can be changed.\n\t * @return the new session id\n\t * @since 4.0.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "String",
    "signature": "public String changeSessionId()",
    "source_code": "\tpublic String changeSessionId() {\n\t\tthis.id = Integer.toString(nextId++);\n\t\treturn this.id;\n\t}"
  },
  "org.springframework.mock.web.MockHttpSession#clearAttributes()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Clear all of this session's attributes.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "void",
    "signature": "public void clearAttributes()",
    "source_code": "\tpublic void clearAttributes() {\n\t\tfor (Iterator<Map.Entry<String, Object>> it = this.attributes.entrySet().iterator(); it.hasNext();) {\n\t\t\tMap.Entry<String, Object> entry = it.next();\n\t\t\tString name = entry.getKey();\n\t\t\tObject value = entry.getValue();\n\t\t\tit.remove();\n\t\t\tif (value instanceof HttpSessionBindingListener listener) {\n\t\t\t\tlistener.valueUnbound(new HttpSessionBindingEvent(this, name, value));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.MockHttpSession#deserializeState(state)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Deserialize the attributes of this session from a state object created by\n\t * {@link #serializeState()}.\n\t * @param state a representation of this session's serialized state\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "state"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "void",
    "signature": "public void deserializeState(Serializable state)",
    "source_code": "\tpublic void deserializeState(Serializable state) {\n\t\tAssert.isTrue(state instanceof Map, \"Serialized state needs to be of type [java.util.Map]\");\n\t\tthis.attributes.putAll((Map<String, Object>) state);\n\t}"
  },
  "org.springframework.mock.web.MockHttpSession#getAttribute(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "Object",
    "signature": "public Object getAttribute(String name)",
    "source_code": "\tpublic Object getAttribute(String name) {\n\t\tassertIsValid();\n\t\tAssert.notNull(name, \"Attribute name must not be null\");\n\t\treturn this.attributes.get(name);\n\t}"
  },
  "org.springframework.mock.web.MockHttpSession#getAttributeNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "Enumeration<String>",
    "signature": "public Enumeration<String> getAttributeNames()",
    "source_code": "\tpublic Enumeration<String> getAttributeNames() {\n\t\tassertIsValid();\n\t\treturn Collections.enumeration(new LinkedHashSet<>(this.attributes.keySet()));\n\t}"
  },
  "org.springframework.mock.web.MockHttpSession#getCreationTime()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "long",
    "signature": "public long getCreationTime()",
    "source_code": "\tpublic long getCreationTime() {\n\t\tassertIsValid();\n\t\treturn this.creationTime;\n\t}"
  },
  "org.springframework.mock.web.MockHttpSession#getId()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "String",
    "signature": "public String getId()",
    "source_code": "\tpublic String getId() {\n\t\treturn this.id;\n\t}"
  },
  "org.springframework.mock.web.MockHttpSession#getLastAccessedTime()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "long",
    "signature": "public long getLastAccessedTime()",
    "source_code": "\tpublic long getLastAccessedTime() {\n\t\tassertIsValid();\n\t\treturn this.lastAccessedTime;\n\t}"
  },
  "org.springframework.mock.web.MockHttpSession#getMaxInactiveInterval()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "int",
    "signature": "public int getMaxInactiveInterval()",
    "source_code": "\tpublic int getMaxInactiveInterval() {\n\t\treturn this.maxInactiveInterval;\n\t}"
  },
  "org.springframework.mock.web.MockHttpSession#getServletContext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "ServletContext",
    "signature": "public ServletContext getServletContext()",
    "source_code": "\tpublic ServletContext getServletContext() {\n\t\treturn this.servletContext;\n\t}"
  },
  "org.springframework.mock.web.MockHttpSession#invalidate()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invalidates this session then unbinds any objects bound to it.\n\t * @throws IllegalStateException if this method is called on an already invalidated session\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "void",
    "signature": "public void invalidate()",
    "source_code": "\tpublic void invalidate() {\n\t\tassertIsValid();\n\t\tthis.invalid = true;\n\t\tclearAttributes();\n\t}"
  },
  "org.springframework.mock.web.MockHttpSession#isInvalid()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "boolean",
    "signature": "public boolean isInvalid()",
    "source_code": "\tpublic boolean isInvalid() {\n\t\treturn this.invalid;\n\t}"
  },
  "org.springframework.mock.web.MockHttpSession#isNew()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "boolean",
    "signature": "public boolean isNew()",
    "source_code": "\tpublic boolean isNew() {\n\t\tassertIsValid();\n\t\treturn this.isNew;\n\t}"
  },
  "org.springframework.mock.web.MockHttpSession#removeAttribute(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void removeAttribute(String name)",
    "source_code": "\tpublic void removeAttribute(String name) {\n\t\tassertIsValid();\n\t\tAssert.notNull(name, \"Attribute name must not be null\");\n\t\tObject value = this.attributes.remove(name);\n\t\tif (value instanceof HttpSessionBindingListener listener) {\n\t\t\tlistener.valueUnbound(new HttpSessionBindingEvent(this, name, value));\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.MockHttpSession#serializeState()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Serialize the attributes of this session into an object that can be\n\t * turned into a byte array with standard Java serialization.\n\t * @return a representation of this session's serialized state\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "Serializable",
    "signature": "public Serializable serializeState()",
    "source_code": "\tpublic Serializable serializeState() {\n\t\tHashMap<String, Serializable> state = new HashMap<>();\n\t\tfor (Iterator<Map.Entry<String, Object>> it = this.attributes.entrySet().iterator(); it.hasNext();) {\n\t\t\tMap.Entry<String, Object> entry = it.next();\n\t\t\tString name = entry.getKey();\n\t\t\tObject value = entry.getValue();\n\t\t\tit.remove();\n\t\t\tif (value instanceof Serializable serializable) {\n\t\t\t\tstate.put(name, serializable);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Not serializable... Servlet containers usually automatically\n\t\t\t\t// unbind the attribute in this case.\n\t\t\t\tif (value instanceof HttpSessionBindingListener listener) {\n\t\t\t\t\tlistener.valueUnbound(new HttpSessionBindingEvent(this, name, value));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn state;\n\t}"
  },
  "org.springframework.mock.web.MockHttpSession#setAttribute(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void setAttribute(String name, @Nullable Object value)",
    "source_code": "\tpublic void setAttribute(String name, @Nullable Object value) {\n\t\tassertIsValid();\n\t\tAssert.notNull(name, \"Attribute name must not be null\");\n\t\tif (value != null) {\n\t\t\tObject oldValue = this.attributes.put(name, value);\n\t\t\tif (value != oldValue) {\n\t\t\t\tif (oldValue instanceof HttpSessionBindingListener listener) {\n\t\t\t\t\tlistener.valueUnbound(new HttpSessionBindingEvent(this, name, oldValue));\n\t\t\t\t}\n\t\t\t\tif (value instanceof HttpSessionBindingListener listener) {\n\t\t\t\t\tlistener.valueBound(new HttpSessionBindingEvent(this, name, value));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tremoveAttribute(name);\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.MockHttpSession#setMaxInactiveInterval(interval)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interval"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "public void setMaxInactiveInterval(int interval)",
    "source_code": "\tpublic void setMaxInactiveInterval(int interval) {\n\t\tthis.maxInactiveInterval = interval;\n\t}"
  },
  "org.springframework.mock.web.MockHttpSession#setNew(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "void",
    "signature": "public void setNew(boolean value)",
    "source_code": "\tpublic void setNew(boolean value) {\n\t\tthis.isNew = value;\n\t}"
  },
  "org.springframework.mock.web.MockJspWriter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Mock implementation of the {@link jakarta.servlet.jsp.JspWriter} class.\n * Only necessary for testing applications when testing custom JSP tags.\n *\n * @author Juergen Hoeller\n * @since 2.5\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class MockJspWriter",
    "source_code": "public class MockJspWriter extends JspWriter {\n\n\tprivate final HttpServletResponse response;\n\n\t@Nullable\n\tprivate PrintWriter targetWriter;\n\n\n\t/**\n\t * Create a MockJspWriter for the given response,\n\t * using the response's default Writer.\n\t * @param response the servlet response to wrap\n\t */\n\tpublic MockJspWriter(HttpServletResponse response) {\n\t\tthis(response, null);\n\t}\n\n\t/**\n\t * Create a MockJspWriter for the given plain Writer.\n\t * @param targetWriter the target Writer to wrap\n\t */\n\tpublic MockJspWriter(Writer targetWriter) {\n\t\tthis(null, targetWriter);\n\t}\n\n\t/**\n\t * Create a MockJspWriter for the given response.\n\t * @param response the servlet response to wrap\n\t * @param targetWriter the target Writer to wrap\n\t */\n\tpublic MockJspWriter(@Nullable HttpServletResponse response, @Nullable Writer targetWriter) {\n\t\tsuper(DEFAULT_BUFFER, true);\n\t\tthis.response = (response != null ? response : new MockHttpServletResponse());\n\t\tif (targetWriter instanceof PrintWriter printWriter) {\n\t\t\tthis.targetWriter = printWriter;\n\t\t}\n\t\telse if (targetWriter != null) {\n\t\t\tthis.targetWriter = new PrintWriter(targetWriter);\n\t\t}\n\t}\n\n\t/**\n\t * Lazily initialize the target Writer.\n\t */\n\tprotected PrintWriter getTargetWriter() throws IOException {\n\t\tif (this.targetWriter == null) {\n\t\t\tthis.targetWriter = this.response.getWriter();\n\t\t}\n\t\treturn this.targetWriter;\n\t}\n\n\n\t@Override\n\tpublic void clear() throws IOException {\n\t\tif (this.response.isCommitted()) {\n\t\t\tthrow new IOException(\"Response already committed\");\n\t\t}\n\t\tthis.response.resetBuffer();\n\t}\n\n\t@Override\n\tpublic void clearBuffer() throws IOException {\n\t}\n\n\t@Override\n\tpublic void flush() throws IOException {\n\t\tthis.response.flushBuffer();\n\t}\n\n\t@Override\n\tpublic void close() throws IOException {\n\t\tflush();\n\t}\n\n\t@Override\n\tpublic int getRemaining() {\n\t\treturn Integer.MAX_VALUE;\n\t}\n\n\t@Override\n\tpublic void newLine() throws IOException {\n\t\tgetTargetWriter().println();\n\t}\n\n\t@Override\n\tpublic void write(char[] value, int offset, int length) throws IOException {\n\t\tgetTargetWriter().write(value, offset, length);\n\t}\n\n\t@Override\n\tpublic void print(boolean value) throws IOException {\n\t\tgetTargetWriter().print(value);\n\t}\n\n\t@Override\n\tpublic void print(char value) throws IOException {\n\t\tgetTargetWriter().print(value);\n\t}\n\n\t@Override\n\tpublic void print(char[] value) throws IOException {\n\t\tgetTargetWriter().print(value);\n\t}\n\n\t@Override\n\tpublic void print(double value) throws IOException {\n\t\tgetTargetWriter().print(value);\n\t}\n\n\t@Override\n\tpublic void print(float value) throws IOException {\n\t\tgetTargetWriter().print(value);\n\t}\n\n\t@Override\n\tpublic void print(int value) throws IOException {\n\t\tgetTargetWriter().print(value);\n\t}\n\n\t@Override\n\tpublic void print(long value) throws IOException {\n\t\tgetTargetWriter().print(value);\n\t}\n\n\t@Override\n\tpublic void print(Object value) throws IOException {\n\t\tgetTargetWriter().print(value);\n\t}\n\n\t@Override\n\tpublic void print(String value) throws IOException {\n\t\tgetTargetWriter().print(value);\n\t}\n\n\t@Override\n\tpublic void println() throws IOException {\n\t\tgetTargetWriter().println();\n\t}\n\n\t@Override\n\tpublic void println(boolean value) throws IOException {\n\t\tgetTargetWriter().println(value);\n\t}\n\n\t@Override\n\tpublic void println(char value) throws IOException {\n\t\tgetTargetWriter().println(value);\n\t}\n\n\t@Override\n\tpublic void println(char[] value) throws IOException {\n\t\tgetTargetWriter().println(value);\n\t}\n\n\t@Override\n\tpublic void println(double value) throws IOException {\n\t\tgetTargetWriter().println(value);\n\t}\n\n\t@Override\n\tpublic void println(float value) throws IOException {\n\t\tgetTargetWriter().println(value);\n\t}\n\n\t@Override\n\tpublic void println(int value) throws IOException {\n\t\tgetTargetWriter().println(value);\n\t}\n\n\t@Override\n\tpublic void println(long value) throws IOException {\n\t\tgetTargetWriter().println(value);\n\t}\n\n\t@Override\n\tpublic void println(Object value) throws IOException {\n\t\tgetTargetWriter().println(value);\n\t}\n\n\t@Override\n\tpublic void println(String value) throws IOException {\n\t\tgetTargetWriter().println(value);\n\t}\n\n}"
  },
  "org.springframework.mock.web.MockJspWriter#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() throws IOException {\n\t\tif (this.response.isCommitted()) {\n\t\t\tthrow new IOException(\"Response already committed\");\n\t\t}\n\t\tthis.response.resetBuffer();\n\t}"
  },
  "org.springframework.mock.web.MockJspWriter#clearBuffer()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void clearBuffer()",
    "source_code": "\tpublic void clearBuffer() throws IOException {\n\t}"
  },
  "org.springframework.mock.web.MockJspWriter#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\tpublic void close() throws IOException {\n\t\tflush();\n\t}"
  },
  "org.springframework.mock.web.MockJspWriter#flush()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void flush()",
    "source_code": "\tpublic void flush() throws IOException {\n\t\tthis.response.flushBuffer();\n\t}"
  },
  "org.springframework.mock.web.MockJspWriter#getRemaining()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "int",
    "signature": "public int getRemaining()",
    "source_code": "\tpublic int getRemaining() {\n\t\treturn Integer.MAX_VALUE;\n\t}"
  },
  "org.springframework.mock.web.MockJspWriter#getTargetWriter()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Lazily initialize the target Writer.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "PrintWriter",
    "signature": "protected PrintWriter getTargetWriter()",
    "source_code": "\tprotected PrintWriter getTargetWriter() throws IOException {\n\t\tif (this.targetWriter == null) {\n\t\t\tthis.targetWriter = this.response.getWriter();\n\t\t}\n\t\treturn this.targetWriter;\n\t}"
  },
  "org.springframework.mock.web.MockJspWriter#newLine()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void newLine()",
    "source_code": "\tpublic void newLine() throws IOException {\n\t\tgetTargetWriter().println();\n\t}"
  },
  "org.springframework.mock.web.MockJspWriter#print(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "void",
    "signature": "public void print(String value)",
    "source_code": "\tpublic void print(String value) throws IOException {\n\t\tgetTargetWriter().print(value);\n\t}"
  },
  "org.springframework.mock.web.MockJspWriter#println()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "void",
    "signature": "public void println()",
    "source_code": "\tpublic void println() throws IOException {\n\t\tgetTargetWriter().println();\n\t}"
  },
  "org.springframework.mock.web.MockJspWriter#println(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "public void println(String value)",
    "source_code": "\tpublic void println(String value) throws IOException {\n\t\tgetTargetWriter().println(value);\n\t}"
  },
  "org.springframework.mock.web.MockJspWriter#write(value,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "void",
    "signature": "public void write(char[] value, int offset, int length)",
    "source_code": "\tpublic void write(char[] value, int offset, int length) throws IOException {\n\t\tgetTargetWriter().write(value, offset, length);\n\t}"
  },
  "org.springframework.mock.web.MockRequestDispatcher": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Mock implementation of the {@link jakarta.servlet.RequestDispatcher} interface.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 1.0.2\n * @see MockHttpServletRequest#getRequestDispatcher(String)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class MockRequestDispatcher",
    "source_code": "public class MockRequestDispatcher implements RequestDispatcher {\n\n\tprivate final Log logger = LogFactory.getLog(getClass());\n\n\tprivate final String resource;\n\n\n\t/**\n\t * Create a new MockRequestDispatcher for the given resource.\n\t * @param resource the server resource to dispatch to, located at a\n\t * particular path or given by a particular name\n\t */\n\tpublic MockRequestDispatcher(String resource) {\n\t\tAssert.notNull(resource, \"Resource must not be null\");\n\t\tthis.resource = resource;\n\t}\n\n\n\t@Override\n\tpublic void forward(ServletRequest request, ServletResponse response) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tAssert.notNull(response, \"Response must not be null\");\n\t\tAssert.state(!response.isCommitted(), \"Cannot perform forward - response is already committed\");\n\t\tgetMockHttpServletResponse(response).setForwardedUrl(this.resource);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"MockRequestDispatcher: forwarding to [\" + this.resource + \"]\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic void include(ServletRequest request, ServletResponse response) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tAssert.notNull(response, \"Response must not be null\");\n\t\tgetMockHttpServletResponse(response).addIncludedUrl(this.resource);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"MockRequestDispatcher: including [\" + this.resource + \"]\");\n\t\t}\n\t}\n\n\t/**\n\t * Obtain the underlying {@link MockHttpServletResponse}, unwrapping\n\t * {@link HttpServletResponseWrapper} decorators if necessary.\n\t */\n\tprotected MockHttpServletResponse getMockHttpServletResponse(ServletResponse response) {\n\t\tif (response instanceof MockHttpServletResponse mockResponse) {\n\t\t\treturn mockResponse;\n\t\t}\n\t\tif (response instanceof HttpServletResponseWrapper wrapper) {\n\t\t\treturn getMockHttpServletResponse(wrapper.getResponse());\n\t\t}\n\t\tthrow new IllegalArgumentException(\"MockRequestDispatcher requires MockHttpServletResponse\");\n\t}\n\n}"
  },
  "org.springframework.mock.web.MockRequestDispatcher#forward(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "void",
    "signature": "public void forward(ServletRequest request, ServletResponse response)",
    "source_code": "\tpublic void forward(ServletRequest request, ServletResponse response) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tAssert.notNull(response, \"Response must not be null\");\n\t\tAssert.state(!response.isCommitted(), \"Cannot perform forward - response is already committed\");\n\t\tgetMockHttpServletResponse(response).setForwardedUrl(this.resource);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"MockRequestDispatcher: forwarding to [\" + this.resource + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.MockRequestDispatcher#getMockHttpServletResponse(response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the underlying {@link MockHttpServletResponse}, unwrapping\n\t * {@link HttpServletResponseWrapper} decorators if necessary.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "MockHttpServletResponse",
    "signature": "protected MockHttpServletResponse getMockHttpServletResponse(ServletResponse response)",
    "source_code": "\tprotected MockHttpServletResponse getMockHttpServletResponse(ServletResponse response) {\n\t\tif (response instanceof MockHttpServletResponse mockResponse) {\n\t\t\treturn mockResponse;\n\t\t}\n\t\tif (response instanceof HttpServletResponseWrapper wrapper) {\n\t\t\treturn getMockHttpServletResponse(wrapper.getResponse());\n\t\t}\n\t\tthrow new IllegalArgumentException(\"MockRequestDispatcher requires MockHttpServletResponse\");\n\t}"
  },
  "org.springframework.mock.web.MockRequestDispatcher#include(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "public void include(ServletRequest request, ServletResponse response)",
    "source_code": "\tpublic void include(ServletRequest request, ServletResponse response) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tAssert.notNull(response, \"Response must not be null\");\n\t\tgetMockHttpServletResponse(response).addIncludedUrl(this.resource);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"MockRequestDispatcher: including [\" + this.resource + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.SESSION_COOKIE_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The session cookie name.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "signature": "public String SESSION_COOKIE_NAME",
    "source_code": "\tpublic static final String SESSION_COOKIE_NAME = \"JSESSION\";",
    "type": "String"
  },
  "org.springframework.test.context.TestContextManager": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code TestContextManager} is the main entry point into the <em>Spring\n * TestContext Framework</em>.\n *\n * <p>Specifically, a {@code TestContextManager} is responsible for managing a\n * single {@link TestContext} and signaling events to each registered\n * {@link TestExecutionListener} at the following test execution points.\n *\n * <ul>\n * <li>{@link #beforeTestClass() before test class execution}: prior to any\n * <em>before class callbacks</em> of a particular testing framework &mdash; for\n * example, JUnit Jupiter's {@link org.junit.jupiter.api.BeforeAll @BeforeAll}</li>\n * <li>{@link #prepareTestInstance test instance preparation}:\n * immediately following instantiation of the test class</li>\n * <li>{@link #beforeTestMethod before test setup}:\n * prior to any <em>before method callbacks</em> of a particular testing framework &mdash;\n * for example, JUnit Jupiter's {@link org.junit.jupiter.api.BeforeEach @BeforeEach}</li>\n * <li>{@link #beforeTestExecution before test execution}:\n * immediately before execution of the {@linkplain java.lang.reflect.Method\n * test method} but after test setup</li>\n * <li>{@link #afterTestExecution after test execution}:\n * immediately after execution of the {@linkplain java.lang.reflect.Method\n * test method} but before test tear down</li>\n * <li>{@link #afterTestMethod(Object, Method, Throwable) after test tear down}:\n * after any <em>after method callbacks</em> of a particular testing framework &mdash;\n * for example, JUnit Jupiter's {@link org.junit.jupiter.api.AfterEach @AfterEach}</li>\n * <li>{@link #afterTestClass() after test class execution}: after any\n * <em>after class callbacks</em> of a particular testing framework &mdash; for example,\n * JUnit Jupiter's {@link org.junit.jupiter.api.AfterAll @AfterAll}</li>\n * </ul>\n *\n * <p>Support for loading and accessing\n * {@linkplain org.springframework.context.ApplicationContext application contexts},\n * dependency injection of test instances,\n * {@linkplain org.springframework.transaction.annotation.Transactional transactional}\n * execution of test methods, etc. is provided by\n * {@link SmartContextLoader ContextLoaders} and {@code TestExecutionListeners},\n * which are configured via {@link ContextConfiguration @ContextConfiguration} and\n * {@link TestExecutionListeners @TestExecutionListeners}, respectively.\n *\n * <p>Bootstrapping of the {@code TestContext}, the default {@code ContextLoader},\n * default {@code TestExecutionListeners}, and their collaborators is performed\n * by a {@link TestContextBootstrapper}, which is configured via\n * {@link BootstrapWith @BootstrapWith}.\n *\n * @author Sam Brannen\n * @author Juergen Hoeller\n * @since 2.5\n * @see BootstrapWith\n * @see BootstrapContext\n * @see TestContextBootstrapper\n * @see TestContext\n * @see TestExecutionListener\n * @see TestExecutionListeners\n * @see ContextConfiguration\n * @see ContextHierarchy\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "signature": "public class TestContextManager",
    "source_code": "public class TestContextManager {\n\n\tprivate static final Log logger = LogFactory.getLog(TestContextManager.class);\n\n\tprivate final TestContext testContext;\n\n\tprivate final ThreadLocal<TestContext> testContextHolder;\n\n\tprivate final List<TestExecutionListener> testExecutionListeners = new ArrayList<>(8);\n\n\n\t/**\n\t * Construct a new {@code TestContextManager} for the supplied {@linkplain Class test class}.\n\t * <p>Delegates to {@link #TestContextManager(TestContextBootstrapper)} with\n\t * the {@link TestContextBootstrapper} configured for the test class. If the\n\t * {@link BootstrapWith @BootstrapWith} annotation is present on the test\n\t * class, either directly or as a meta-annotation, then its\n\t * {@link BootstrapWith#value value} will be used as the bootstrapper type;\n\t * otherwise, the {@link org.springframework.test.context.support.DefaultTestContextBootstrapper\n\t * DefaultTestContextBootstrapper} will be used.\n\t * @param testClass the test class to be managed\n\t * @see #TestContextManager(TestContextBootstrapper)\n\t */\n\tpublic TestContextManager(Class<?> testClass) {\n\t\tthis(BootstrapUtils.resolveTestContextBootstrapper(testClass));\n\t}\n\n\t/**\n\t * Construct a new {@code TestContextManager} using the supplied {@link TestContextBootstrapper}\n\t * and {@linkplain #registerTestExecutionListeners register} the necessary\n\t * {@link TestExecutionListener TestExecutionListeners}.\n\t * <p>Delegates to the supplied {@code TestContextBootstrapper} for building\n\t * the {@code TestContext} and retrieving the {@code TestExecutionListeners}.\n\t * @param testContextBootstrapper the bootstrapper to use\n\t * @since 4.2\n\t * @see TestContextBootstrapper#buildTestContext\n\t * @see TestContextBootstrapper#getTestExecutionListeners\n\t * @see #registerTestExecutionListeners\n\t */\n\tpublic TestContextManager(TestContextBootstrapper testContextBootstrapper) {\n\t\tthis.testContext = testContextBootstrapper.buildTestContext();\n\t\tthis.testContextHolder = ThreadLocal.withInitial(() -> copyTestContext(this.testContext));\n\t\tregisterTestExecutionListeners(testContextBootstrapper.getTestExecutionListeners());\n\t}\n\n\t/**\n\t * Get the {@link TestContext} managed by this {@code TestContextManager}.\n\t */\n\tpublic final TestContext getTestContext() {\n\t\treturn this.testContextHolder.get();\n\t}\n\n\t/**\n\t * Register the supplied list of {@link TestExecutionListener TestExecutionListeners}\n\t * by appending them to the list of listeners used by this {@code TestContextManager}.\n\t * @see #registerTestExecutionListeners(TestExecutionListener...)\n\t */\n\tpublic void registerTestExecutionListeners(List<TestExecutionListener> testExecutionListeners) {\n\t\tregisterTestExecutionListeners(testExecutionListeners.toArray(new TestExecutionListener[0]));\n\t}\n\n\t/**\n\t * Register the supplied array of {@link TestExecutionListener TestExecutionListeners}\n\t * by appending them to the list of listeners used by this {@code TestContextManager}.\n\t */\n\tpublic void registerTestExecutionListeners(TestExecutionListener... testExecutionListeners) {\n\t\tfor (TestExecutionListener listener : testExecutionListeners) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Registering TestExecutionListener: \" + typeName(listener));\n\t\t\t}\n\t\t\tthis.testExecutionListeners.add(listener);\n\t\t}\n\t}\n\n\t/**\n\t * Get the current {@link TestExecutionListener TestExecutionListeners}\n\t * registered for this {@code TestContextManager}.\n\t * <p>Allows for modifications, e.g. adding a listener to the beginning of the list.\n\t * However, make sure to keep the list stable while actually executing tests.\n\t */\n\tpublic final List<TestExecutionListener> getTestExecutionListeners() {\n\t\treturn this.testExecutionListeners;\n\t}\n\n\t/**\n\t * Get a copy of the {@link TestExecutionListener TestExecutionListeners}\n\t * registered for this {@code TestContextManager} in reverse order.\n\t */\n\tprivate List<TestExecutionListener> getReversedTestExecutionListeners() {\n\t\tList<TestExecutionListener> listenersReversed = new ArrayList<>(getTestExecutionListeners());\n\t\tCollections.reverse(listenersReversed);\n\t\treturn listenersReversed;\n\t}\n\n\t/**\n\t * Hook for pre-processing a test class <em>before</em> execution of any\n\t * tests within the class. Should be called prior to any framework-specific\n\t * <em>before class methods</em> &mdash; for example, methods annotated with\n\t * JUnit Jupiter's {@link org.junit.jupiter.api.BeforeAll @BeforeAll}.\n\t * <p>An attempt will be made to give each registered\n\t * {@link TestExecutionListener} a chance to pre-process the test class\n\t * execution. If a listener throws an exception, however, the remaining\n\t * registered listeners will <strong>not</strong> be called.\n\t * @throws Exception if a registered TestExecutionListener throws an\n\t * exception\n\t * @since 3.0\n\t * @see #getTestExecutionListeners()\n\t */\n\tpublic void beforeTestClass() throws Exception {\n\t\tClass<?> testClass = getTestContext().getTestClass();\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"beforeTestClass(): class [\" + typeName(testClass) + \"]\");\n\t\t}\n\t\tgetTestContext().updateState(null, null, null);\n\n\t\tfor (TestExecutionListener testExecutionListener : getTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.beforeTestClass(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogException(ex, \"beforeTestClass\", testExecutionListener, testClass);\n\t\t\t\tReflectionUtils.rethrowException(ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Hook for preparing a test instance prior to execution of any individual\n\t * test methods &mdash; for example, to inject dependencies.\n\t * <p>This method should be called immediately after instantiation of the test\n\t * class or as soon after instantiation as possible (as is the case with the\n\t * {@link org.springframework.test.context.junit4.rules.SpringMethodRule\n\t * SpringMethodRule}). In any case, this method must be called prior to any\n\t * framework-specific lifecycle callbacks.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance}.\n\t * <p>An attempt will be made to give each registered\n\t * {@link TestExecutionListener} a chance to prepare the test instance. If a\n\t * listener throws an exception, however, the remaining registered listeners\n\t * will <strong>not</strong> be called.\n\t * @param testInstance the test instance to prepare\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @see #getTestExecutionListeners()\n\t */\n\tpublic void prepareTestInstance(Object testInstance) throws Exception {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"prepareTestInstance(): instance [\" + testInstance + \"]\");\n\t\t}\n\t\tgetTestContext().updateState(testInstance, null, null);\n\n\t\tfor (TestExecutionListener testExecutionListener : getTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.prepareTestInstance(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\tlogger.error(\"\"\"\n\t\t\t\t\t\t\tCaught exception while allowing TestExecutionListener [%s] to \\\n\t\t\t\t\t\t\tprepare test instance [%s]\"\"\"\n\t\t\t\t\t\t\t\t.formatted(typeName(testExecutionListener), testInstance), ex);\n\t\t\t\t}\n\t\t\t\tReflectionUtils.rethrowException(ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Hook for pre-processing a test <em>before</em> execution of <em>before</em>\n\t * lifecycle callbacks of the underlying test framework &mdash; for example,\n\t * setting up test fixtures, starting a transaction, etc.\n\t * <p>This method <strong>must</strong> be called immediately prior to\n\t * framework-specific <em>before</em> lifecycle callbacks &mdash; for example, methods\n\t * annotated with JUnit Jupiter's {@link org.junit.jupiter.api.BeforeEach @BeforeEach}.\n\t * For historical reasons, this method is named {@code beforeTestMethod}. Since\n\t * the introduction of {@link #beforeTestExecution}, a more suitable name for\n\t * this method might be something like {@code beforeTestSetUp} or\n\t * {@code beforeEach}; however, it is unfortunately impossible to rename\n\t * this method due to backward compatibility concerns.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance} and {@code testMethod}.\n\t * <p>An attempt will be made to give each registered\n\t * {@link TestExecutionListener} a chance to perform its pre-processing.\n\t * If a listener throws an exception, however, the remaining registered\n\t * listeners will <strong>not</strong> be called.\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which is about to be executed on the\n\t * test instance\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @see #afterTestMethod\n\t * @see #beforeTestExecution\n\t * @see #afterTestExecution\n\t * @see #getTestExecutionListeners()\n\t */\n\tpublic void beforeTestMethod(Object testInstance, Method testMethod) throws Exception {\n\t\tString callbackName = \"beforeTestMethod\";\n\t\tprepareForBeforeCallback(callbackName, testInstance, testMethod);\n\n\t\tfor (TestExecutionListener testExecutionListener : getTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.beforeTestMethod(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\thandleBeforeException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Hook for pre-processing a test <em>immediately before</em> execution of\n\t * the {@linkplain java.lang.reflect.Method test method} in the supplied\n\t * {@linkplain TestContext test context} &mdash; for example, for timing\n\t * or logging purposes.\n\t * <p>This method <strong>must</strong> be called after framework-specific\n\t * <em>before</em> lifecycle callbacks &mdash; for example, methods annotated\n\t * with JUnit Jupiter's {@link org.junit.jupiter.api.BeforeEach @BeforeEach}.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance} and {@code testMethod}.\n\t * <p>An attempt will be made to give each registered\n\t * {@link TestExecutionListener} a chance to perform its pre-processing.\n\t * If a listener throws an exception, however, the remaining registered\n\t * listeners will <strong>not</strong> be called.\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which is about to be executed on the\n\t * test instance\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @since 5.0\n\t * @see #beforeTestMethod\n\t * @see #afterTestMethod\n\t * @see #beforeTestExecution\n\t * @see #afterTestExecution\n\t * @see #getTestExecutionListeners()\n\t */\n\tpublic void beforeTestExecution(Object testInstance, Method testMethod) throws Exception {\n\t\tString callbackName = \"beforeTestExecution\";\n\t\tprepareForBeforeCallback(callbackName, testInstance, testMethod);\n\n\t\tfor (TestExecutionListener testExecutionListener : getTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.beforeTestExecution(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\thandleBeforeException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Hook for post-processing a test <em>immediately after</em> execution of\n\t * the {@linkplain java.lang.reflect.Method test method} in the supplied\n\t * {@linkplain TestContext test context} &mdash; for example, for timing\n\t * or logging purposes.\n\t * <p>This method <strong>must</strong> be called before framework-specific\n\t * <em>after</em> lifecycle callbacks &mdash; for example, methods annotated\n\t * with JUnit Jupiter's {@link org.junit.jupiter.api.AfterEach @AfterEach}.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance}, {@code testMethod}, and {@code exception}.\n\t * <p>Each registered {@link TestExecutionListener} will be given a chance\n\t * to perform its post-processing. If a listener throws an exception, the\n\t * remaining registered listeners will still be called. After all listeners\n\t * have executed, the first caught exception will be rethrown with any\n\t * subsequent exceptions {@linkplain Throwable#addSuppressed suppressed} in\n\t * the first exception.\n\t * <p>Note that registered listeners will be executed in the opposite\n\t * order in which they were registered.\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which has just been executed on the\n\t * test instance\n\t * @param exception the exception that was thrown during execution of the\n\t * test method or by a TestExecutionListener, or {@code null} if none\n\t * was thrown\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @since 5.0\n\t * @see #beforeTestMethod\n\t * @see #afterTestMethod\n\t * @see #beforeTestExecution\n\t * @see #getTestExecutionListeners()\n\t * @see Throwable#addSuppressed(Throwable)\n\t */\n\tpublic void afterTestExecution(Object testInstance, Method testMethod, @Nullable Throwable exception)\n\t\t\tthrows Exception {\n\n\t\tString callbackName = \"afterTestExecution\";\n\t\tprepareForAfterCallback(callbackName, testInstance, testMethod, exception);\n\t\tThrowable afterTestExecutionException = null;\n\n\t\t// Traverse the TestExecutionListeners in reverse order to ensure proper\n\t\t// \"wrapper\"-style execution of listeners.\n\t\tfor (TestExecutionListener testExecutionListener : getReversedTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.afterTestExecution(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t\tif (afterTestExecutionException == null) {\n\t\t\t\t\tafterTestExecutionException = ex;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tafterTestExecutionException.addSuppressed(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (afterTestExecutionException != null) {\n\t\t\tReflectionUtils.rethrowException(afterTestExecutionException);\n\t\t}\n\t}\n\n\t/**\n\t * Hook for post-processing a test <em>after</em> execution of <em>after</em>\n\t * lifecycle callbacks of the underlying test framework &mdash; for example,\n\t * tearing down test fixtures, ending a transaction, etc.\n\t * <p>This method <strong>must</strong> be called immediately after\n\t * framework-specific <em>after</em> lifecycle callbacks &mdash; for example, methods\n\t * annotated with JUnit Jupiter's {@link org.junit.jupiter.api.AfterEach @AfterEach}.\n\t * For historical reasons, this method is named {@code afterTestMethod}. Since\n\t * the introduction of {@link #afterTestExecution}, a more suitable name for\n\t * this method might be something like {@code afterTestTearDown} or\n\t * {@code afterEach}; however, it is unfortunately impossible to rename\n\t * this method due to backward compatibility concerns.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance}, {@code testMethod}, and {@code exception}.\n\t * <p>Each registered {@link TestExecutionListener} will be given a chance\n\t * to perform its post-processing. If a listener throws an exception, the\n\t * remaining registered listeners will still be called. After all listeners\n\t * have executed, the first caught exception will be rethrown with any\n\t * subsequent exceptions {@linkplain Throwable#addSuppressed suppressed} in\n\t * the first exception.\n\t * <p>Note that registered listeners will be executed in the opposite\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which has just been executed on the\n\t * test instance\n\t * @param exception the exception that was thrown during execution of the test\n\t * method or by a TestExecutionListener, or {@code null} if none was thrown\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @see #beforeTestMethod\n\t * @see #beforeTestExecution\n\t * @see #afterTestExecution\n\t * @see #getTestExecutionListeners()\n\t * @see Throwable#addSuppressed(Throwable)\n\t */\n\tpublic void afterTestMethod(Object testInstance, Method testMethod, @Nullable Throwable exception)\n\t\t\tthrows Exception {\n\n\t\tString callbackName = \"afterTestMethod\";\n\t\tprepareForAfterCallback(callbackName, testInstance, testMethod, exception);\n\t\tThrowable afterTestMethodException = null;\n\n\t\t// Traverse the TestExecutionListeners in reverse order to ensure proper\n\t\t// \"wrapper\"-style execution of listeners.\n\t\tfor (TestExecutionListener testExecutionListener : getReversedTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.afterTestMethod(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t\tif (afterTestMethodException == null) {\n\t\t\t\t\tafterTestMethodException = ex;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tafterTestMethodException.addSuppressed(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (afterTestMethodException != null) {\n\t\t\tReflectionUtils.rethrowException(afterTestMethodException);\n\t\t}\n\t}\n\n\t/**\n\t * Hook for post-processing a test class <em>after</em> execution of all\n\t * tests within the class. Should be called after any framework-specific\n\t * <em>after class methods</em> &mdash; for example, methods annotated with\n\t * JUnit Jupiter's {@link org.junit.jupiter.api.AfterAll @AfterAll}.\n\t * <p>Each registered {@link TestExecutionListener} will be given a chance\n\t * to perform its post-processing. If a listener throws an exception, the\n\t * remaining registered listeners will still be called. After all listeners\n\t * have executed, the first caught exception will be rethrown with any\n\t * subsequent exceptions {@linkplain Throwable#addSuppressed suppressed} in\n\t * the first exception.\n\t * <p>Note that registered listeners will be executed in the opposite\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @since 3.0\n\t * @see #getTestExecutionListeners()\n\t * @see Throwable#addSuppressed(Throwable)\n\t */\n\tpublic void afterTestClass() throws Exception {\n\t\tClass<?> testClass = getTestContext().getTestClass();\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"afterTestClass(): class [\" + typeName(testClass) + \"]\");\n\t\t}\n\t\tgetTestContext().updateState(null, null, null);\n\n\t\tThrowable afterTestClassException = null;\n\t\t// Traverse the TestExecutionListeners in reverse order to ensure proper\n\t\t// \"wrapper\"-style execution of listeners.\n\t\tfor (TestExecutionListener testExecutionListener : getReversedTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.afterTestClass(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogException(ex, \"afterTestClass\", testExecutionListener, testClass);\n\t\t\t\tif (afterTestClassException == null) {\n\t\t\t\t\tafterTestClassException = ex;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tafterTestClassException.addSuppressed(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.testContextHolder.remove();\n\n\t\tif (afterTestClassException != null) {\n\t\t\tReflectionUtils.rethrowException(afterTestClassException);\n\t\t}\n\t}\n\n\tprivate void prepareForBeforeCallback(String callbackName, Object testInstance, Method testMethod) {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"%s(): instance [%s], method [%s]\".formatted(callbackName, testInstance, testMethod));\n\t\t}\n\t\tgetTestContext().updateState(testInstance, testMethod, null);\n\t}\n\n\tprivate void prepareForAfterCallback(String callbackName, Object testInstance, Method testMethod,\n\t\t\t@Nullable Throwable exception) {\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"%s(): instance [%s], method [%s], exception [%s]\"\n\t\t\t\t\t.formatted(callbackName, testInstance, testMethod, exception));\n\t\t}\n\t\tgetTestContext().updateState(testInstance, testMethod, exception);\n\t}\n\n\tprivate void handleBeforeException(Throwable ex, String callbackName, TestExecutionListener testExecutionListener,\n\t\t\tObject testInstance, Method testMethod) throws Exception {\n\n\t\tlogException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\tReflectionUtils.rethrowException(ex);\n\t}\n\n\tprivate void logException(\n\t\t\tThrowable ex, String callbackName, TestExecutionListener testExecutionListener, Class<?> testClass) {\n\n\t\tif (logger.isWarnEnabled()) {\n\t\t\tlogger.warn(\"\"\"\n\t\t\t\t\tCaught exception while invoking '%s' callback on TestExecutionListener [%s] \\\n\t\t\t\t\tfor test class [%s]\"\"\"\n\t\t\t\t\t\t.formatted(callbackName, typeName(testExecutionListener), typeName(testClass)), ex);\n\t\t}\n\t}\n\n\tprivate void logException(Throwable ex, String callbackName, TestExecutionListener testExecutionListener,\n\t\t\tObject testInstance, Method testMethod) {\n\n\t\tif (logger.isWarnEnabled()) {\n\t\t\tlogger.warn(\"\"\"\n\t\t\t\t\tCaught exception while invoking '%s' callback on TestExecutionListener [%s] for \\\n\t\t\t\t\ttest method [%s] and test instance [%s]\"\"\"\n\t\t\t\t\t\t.formatted(callbackName, typeName(testExecutionListener), testMethod, testInstance), ex);\n\t\t}\n\t}\n\n\n\t/**\n\t * Attempt to create a copy of the supplied {@code TestContext} using its\n\t * <em>copy constructor</em>.\n\t */\n\tprivate static TestContext copyTestContext(TestContext testContext) {\n\t\tConstructor<? extends TestContext> constructor =\n\t\t\t\tClassUtils.getConstructorIfAvailable(testContext.getClass(), testContext.getClass());\n\n\t\tif (constructor != null) {\n\t\t\ttry {\n\t\t\t\tReflectionUtils.makeAccessible(constructor);\n\t\t\t\treturn constructor.newInstance(testContext);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"\"\"\n\t\t\t\t\t\t\tFailed to invoke copy constructor for [%s]; concurrent test execution \\\n\t\t\t\t\t\t\tis therefore likely not supported.\"\"\".formatted(testContext), ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Fallback to original instance\n\t\treturn testContext;\n\t}\n\n\tprivate static String typeName(Object obj) {\n\t\tif (obj == null) {\n\t\t\treturn \"null\";\n\t\t}\n\t\tif (obj instanceof Class<?> type) {\n\t\t\treturn type.getName();\n\t\t}\n\t\treturn obj.getClass().getName();\n\t}\n\n}"
  },
  "org.springframework.test.context.TestContextManager#afterTestClass()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for post-processing a test class <em>after</em> execution of all\n\t * tests within the class. Should be called after any framework-specific\n\t * <em>after class methods</em> &mdash; for example, methods annotated with\n\t * JUnit Jupiter's {@link org.junit.jupiter.api.AfterAll @AfterAll}.\n\t * <p>Each registered {@link TestExecutionListener} will be given a chance\n\t * to perform its post-processing. If a listener throws an exception, the\n\t * remaining registered listeners will still be called. After all listeners\n\t * have executed, the first caught exception will be rethrown with any\n\t * subsequent exceptions {@linkplain Throwable#addSuppressed suppressed} in\n\t * the first exception.\n\t * <p>Note that registered listeners will be executed in the opposite\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @since 3.0\n\t * @see #getTestExecutionListeners()\n\t * @see Throwable#addSuppressed(Throwable)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 475
    },
    "return": "void",
    "signature": "public void afterTestClass()",
    "source_code": "\tpublic void afterTestClass() throws Exception {\n\t\tClass<?> testClass = getTestContext().getTestClass();\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"afterTestClass(): class [\" + typeName(testClass) + \"]\");\n\t\t}\n\t\tgetTestContext().updateState(null, null, null);\n\n\t\tThrowable afterTestClassException = null;\n\t\t// Traverse the TestExecutionListeners in reverse order to ensure proper\n\t\t// \"wrapper\"-style execution of listeners.\n\t\tfor (TestExecutionListener testExecutionListener : getReversedTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.afterTestClass(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogException(ex, \"afterTestClass\", testExecutionListener, testClass);\n\t\t\t\tif (afterTestClassException == null) {\n\t\t\t\t\tafterTestClassException = ex;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tafterTestClassException.addSuppressed(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.testContextHolder.remove();\n\n\t\tif (afterTestClassException != null) {\n\t\t\tReflectionUtils.rethrowException(afterTestClassException);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.TestContextManager#afterTestExecution(testInstance,testMethod,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for post-processing a test <em>immediately after</em> execution of\n\t * the {@linkplain java.lang.reflect.Method test method} in the supplied\n\t * {@linkplain TestContext test context} &mdash; for example, for timing\n\t * or logging purposes.\n\t * <p>This method <strong>must</strong> be called before framework-specific\n\t * <em>after</em> lifecycle callbacks &mdash; for example, methods annotated\n\t * with JUnit Jupiter's {@link org.junit.jupiter.api.AfterEach @AfterEach}.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance}, {@code testMethod}, and {@code exception}.\n\t * <p>Each registered {@link TestExecutionListener} will be given a chance\n\t * to perform its post-processing. If a listener throws an exception, the\n\t * remaining registered listeners will still be called. After all listeners\n\t * have executed, the first caught exception will be rethrown with any\n\t * subsequent exceptions {@linkplain Throwable#addSuppressed suppressed} in\n\t * the first exception.\n\t * <p>Note that registered listeners will be executed in the opposite\n\t * order in which they were registered.\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which has just been executed on the\n\t * test instance\n\t * @param exception the exception that was thrown during execution of the\n\t * test method or by a TestExecutionListener, or {@code null} if none\n\t * was thrown\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @since 5.0\n\t * @see #beforeTestMethod\n\t * @see #afterTestMethod\n\t * @see #beforeTestExecution\n\t * @see #getTestExecutionListeners()\n\t * @see Throwable#addSuppressed(Throwable)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 367
    },
    "return": "void",
    "signature": "public void afterTestExecution(Object testInstance, Method testMethod, @Nullable Throwable exception)",
    "source_code": "\tpublic void afterTestExecution(Object testInstance, Method testMethod, @Nullable Throwable exception)"
  },
  "org.springframework.test.context.TestContextManager#afterTestMethod(testInstance,testMethod,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for post-processing a test <em>after</em> execution of <em>after</em>\n\t * lifecycle callbacks of the underlying test framework &mdash; for example,\n\t * tearing down test fixtures, ending a transaction, etc.\n\t * <p>This method <strong>must</strong> be called immediately after\n\t * framework-specific <em>after</em> lifecycle callbacks &mdash; for example, methods\n\t * annotated with JUnit Jupiter's {@link org.junit.jupiter.api.AfterEach @AfterEach}.\n\t * For historical reasons, this method is named {@code afterTestMethod}. Since\n\t * the introduction of {@link #afterTestExecution}, a more suitable name for\n\t * this method might be something like {@code afterTestTearDown} or\n\t * {@code afterEach}; however, it is unfortunately impossible to rename\n\t * this method due to backward compatibility concerns.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance}, {@code testMethod}, and {@code exception}.\n\t * <p>Each registered {@link TestExecutionListener} will be given a chance\n\t * to perform its post-processing. If a listener throws an exception, the\n\t * remaining registered listeners will still be called. After all listeners\n\t * have executed, the first caught exception will be rethrown with any\n\t * subsequent exceptions {@linkplain Throwable#addSuppressed suppressed} in\n\t * the first exception.\n\t * <p>Note that registered listeners will be executed in the opposite\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which has just been executed on the\n\t * test instance\n\t * @param exception the exception that was thrown during execution of the test\n\t * method or by a TestExecutionListener, or {@code null} if none was thrown\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @see #beforeTestMethod\n\t * @see #beforeTestExecution\n\t * @see #afterTestExecution\n\t * @see #getTestExecutionListeners()\n\t * @see Throwable#addSuppressed(Throwable)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "void",
    "signature": "public void afterTestMethod(Object testInstance, Method testMethod, @Nullable Throwable exception)",
    "source_code": "\tpublic void afterTestMethod(Object testInstance, Method testMethod, @Nullable Throwable exception)"
  },
  "org.springframework.test.context.TestContextManager#beforeTestClass()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for pre-processing a test class <em>before</em> execution of any\n\t * tests within the class. Should be called prior to any framework-specific\n\t * <em>before class methods</em> &mdash; for example, methods annotated with\n\t * JUnit Jupiter's {@link org.junit.jupiter.api.BeforeAll @BeforeAll}.\n\t * <p>An attempt will be made to give each registered\n\t * {@link TestExecutionListener} a chance to pre-process the test class\n\t * execution. If a listener throws an exception, however, the remaining\n\t * registered listeners will <strong>not</strong> be called.\n\t * @throws Exception if a registered TestExecutionListener throws an\n\t * exception\n\t * @since 3.0\n\t * @see #getTestExecutionListeners()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "void",
    "signature": "public void beforeTestClass()",
    "source_code": "\tpublic void beforeTestClass() throws Exception {\n\t\tClass<?> testClass = getTestContext().getTestClass();\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"beforeTestClass(): class [\" + typeName(testClass) + \"]\");\n\t\t}\n\t\tgetTestContext().updateState(null, null, null);\n\n\t\tfor (TestExecutionListener testExecutionListener : getTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.beforeTestClass(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogException(ex, \"beforeTestClass\", testExecutionListener, testClass);\n\t\t\t\tReflectionUtils.rethrowException(ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.context.TestContextManager#beforeTestExecution(testInstance,testMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for pre-processing a test <em>immediately before</em> execution of\n\t * the {@linkplain java.lang.reflect.Method test method} in the supplied\n\t * {@linkplain TestContext test context} &mdash; for example, for timing\n\t * or logging purposes.\n\t * <p>This method <strong>must</strong> be called after framework-specific\n\t * <em>before</em> lifecycle callbacks &mdash; for example, methods annotated\n\t * with JUnit Jupiter's {@link org.junit.jupiter.api.BeforeEach @BeforeEach}.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance} and {@code testMethod}.\n\t * <p>An attempt will be made to give each registered\n\t * {@link TestExecutionListener} a chance to perform its pre-processing.\n\t * If a listener throws an exception, however, the remaining registered\n\t * listeners will <strong>not</strong> be called.\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which is about to be executed on the\n\t * test instance\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @since 5.0\n\t * @see #beforeTestMethod\n\t * @see #afterTestMethod\n\t * @see #beforeTestExecution\n\t * @see #afterTestExecution\n\t * @see #getTestExecutionListeners()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "void",
    "signature": "public void beforeTestExecution(Object testInstance, Method testMethod)",
    "source_code": "\tpublic void beforeTestExecution(Object testInstance, Method testMethod) throws Exception {\n\t\tString callbackName = \"beforeTestExecution\";\n\t\tprepareForBeforeCallback(callbackName, testInstance, testMethod);\n\n\t\tfor (TestExecutionListener testExecutionListener : getTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.beforeTestExecution(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\thandleBeforeException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.context.TestContextManager#beforeTestMethod(testInstance,testMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for pre-processing a test <em>before</em> execution of <em>before</em>\n\t * lifecycle callbacks of the underlying test framework &mdash; for example,\n\t * setting up test fixtures, starting a transaction, etc.\n\t * <p>This method <strong>must</strong> be called immediately prior to\n\t * framework-specific <em>before</em> lifecycle callbacks &mdash; for example, methods\n\t * annotated with JUnit Jupiter's {@link org.junit.jupiter.api.BeforeEach @BeforeEach}.\n\t * For historical reasons, this method is named {@code beforeTestMethod}. Since\n\t * the introduction of {@link #beforeTestExecution}, a more suitable name for\n\t * this method might be something like {@code beforeTestSetUp} or\n\t * {@code beforeEach}; however, it is unfortunately impossible to rename\n\t * this method due to backward compatibility concerns.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance} and {@code testMethod}.\n\t * <p>An attempt will be made to give each registered\n\t * {@link TestExecutionListener} a chance to perform its pre-processing.\n\t * If a listener throws an exception, however, the remaining registered\n\t * listeners will <strong>not</strong> be called.\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which is about to be executed on the\n\t * test instance\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @see #afterTestMethod\n\t * @see #beforeTestExecution\n\t * @see #afterTestExecution\n\t * @see #getTestExecutionListeners()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "void",
    "signature": "public void beforeTestMethod(Object testInstance, Method testMethod)",
    "source_code": "\tpublic void beforeTestMethod(Object testInstance, Method testMethod) throws Exception {\n\t\tString callbackName = \"beforeTestMethod\";\n\t\tprepareForBeforeCallback(callbackName, testInstance, testMethod);\n\n\t\tfor (TestExecutionListener testExecutionListener : getTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.beforeTestMethod(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\thandleBeforeException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.context.TestContextManager#getTestContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link TestContext} managed by this {@code TestContextManager}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "TestContext",
    "signature": "public TestContext getTestContext()",
    "source_code": "\tpublic final TestContext getTestContext() {\n\t\treturn this.testContextHolder.get();\n\t}"
  },
  "org.springframework.test.context.TestContextManager#getTestExecutionListeners()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the current {@link TestExecutionListener TestExecutionListeners}\n\t * registered for this {@code TestContextManager}.\n\t * <p>Allows for modifications, e.g. adding a listener to the beginning of the list.\n\t * However, make sure to keep the list stable while actually executing tests.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "List<TestExecutionListener>",
    "signature": "public List<TestExecutionListener> getTestExecutionListeners()",
    "source_code": "\tpublic final List<TestExecutionListener> getTestExecutionListeners() {\n\t\treturn this.testExecutionListeners;\n\t}"
  },
  "org.springframework.test.context.TestContextManager#prepareTestInstance(testInstance)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for preparing a test instance prior to execution of any individual\n\t * test methods &mdash; for example, to inject dependencies.\n\t * <p>This method should be called immediately after instantiation of the test\n\t * class or as soon after instantiation as possible (as is the case with the\n\t * {@link org.springframework.test.context.junit4.rules.SpringMethodRule\n\t * SpringMethodRule}). In any case, this method must be called prior to any\n\t * framework-specific lifecycle callbacks.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance}.\n\t * <p>An attempt will be made to give each registered\n\t * {@link TestExecutionListener} a chance to prepare the test instance. If a\n\t * listener throws an exception, however, the remaining registered listeners\n\t * will <strong>not</strong> be called.\n\t * @param testInstance the test instance to prepare\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @see #getTestExecutionListeners()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "void",
    "signature": "public void prepareTestInstance(Object testInstance)",
    "source_code": "\tpublic void prepareTestInstance(Object testInstance) throws Exception {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"prepareTestInstance(): instance [\" + testInstance + \"]\");\n\t\t}\n\t\tgetTestContext().updateState(testInstance, null, null);\n\n\t\tfor (TestExecutionListener testExecutionListener : getTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.prepareTestInstance(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\tlogger.error(\"\"\"\n\t\t\t\t\t\t\tCaught exception while allowing TestExecutionListener [%s] to \\\n\t\t\t\t\t\t\tprepare test instance [%s]\"\"\"\n\t\t\t\t\t\t\t\t.formatted(typeName(testExecutionListener), testInstance), ex);\n\t\t\t\t}\n\t\t\t\tReflectionUtils.rethrowException(ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.context.TestContextManager#registerTestExecutionListeners(testExecutionListeners)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the supplied array of {@link TestExecutionListener TestExecutionListeners}\n\t * by appending them to the list of listeners used by this {@code TestContextManager}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testExecutionListeners"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "public void registerTestExecutionListeners(TestExecutionListener... testExecutionListeners)",
    "source_code": "\tpublic void registerTestExecutionListeners(TestExecutionListener... testExecutionListeners) {\n\t\tfor (TestExecutionListener listener : testExecutionListeners) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Registering TestExecutionListener: \" + typeName(listener));\n\t\t\t}\n\t\t\tthis.testExecutionListeners.add(listener);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultContextCache": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Default implementation of the {@link ContextCache} API.\n *\n * <p>Uses a synchronized {@link Map} configured with a maximum size\n * and a <em>least recently used</em> (LRU) eviction policy to cache\n * {@link ApplicationContext} instances.\n *\n * <p>The maximum size may be supplied as a {@linkplain #DefaultContextCache(int)\n * constructor argument} or set via a system property or Spring property named\n * {@code spring.test.context.cache.maxSize}.\n *\n * @author Sam Brannen\n * @author Juergen Hoeller\n * @since 2.5\n * @see ContextCacheUtils#retrieveMaxCacheSize()\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "signature": "public class DefaultContextCache",
    "source_code": "public class DefaultContextCache implements ContextCache {\n\n\tprivate static final Log statsLogger = LogFactory.getLog(CONTEXT_CACHE_LOGGING_CATEGORY);\n\n\t/**\n\t * Map of context keys to Spring {@code ApplicationContext} instances.\n\t */\n\tprivate final Map<MergedContextConfiguration, ApplicationContext> contextMap =\n\t\t\tCollections.synchronizedMap(new LruCache(32, 0.75f));\n\n\t/**\n\t * Map of parent keys to sets of children keys, representing a top-down <em>tree</em>\n\t * of context hierarchies. This information is used for determining which subtrees\n\t * need to be recursively removed and closed when removing a context that is a parent\n\t * of other contexts.\n\t */\n\tprivate final Map<MergedContextConfiguration, Set<MergedContextConfiguration>> hierarchyMap =\n\t\t\tnew ConcurrentHashMap<>(32);\n\n\tprivate final int maxSize;\n\n\tprivate final AtomicInteger hitCount = new AtomicInteger();\n\n\tprivate final AtomicInteger missCount = new AtomicInteger();\n\n\n\t/**\n\t * Create a new {@code DefaultContextCache} using the maximum cache size\n\t * obtained via {@link ContextCacheUtils#retrieveMaxCacheSize()}.\n\t * @since 4.3\n\t * @see #DefaultContextCache(int)\n\t * @see ContextCacheUtils#retrieveMaxCacheSize()\n\t */\n\tpublic DefaultContextCache() {\n\t\tthis(ContextCacheUtils.retrieveMaxCacheSize());\n\t}\n\n\t/**\n\t * Create a new {@code DefaultContextCache} using the supplied maximum\n\t * cache size.\n\t * @param maxSize the maximum cache size\n\t * @throws IllegalArgumentException if the supplied {@code maxSize} value\n\t * is not positive\n\t * @since 4.3\n\t * @see #DefaultContextCache()\n\t */\n\tpublic DefaultContextCache(int maxSize) {\n\t\tAssert.isTrue(maxSize > 0, \"'maxSize' must be positive\");\n\t\tthis.maxSize = maxSize;\n\t}\n\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic boolean contains(MergedContextConfiguration key) {\n\t\tAssert.notNull(key, \"Key must not be null\");\n\t\treturn this.contextMap.containsKey(key);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\t@Nullable\n\tpublic ApplicationContext get(MergedContextConfiguration key) {\n\t\tAssert.notNull(key, \"Key must not be null\");\n\t\tApplicationContext context = this.contextMap.get(key);\n\t\tif (context == null) {\n\t\t\tthis.missCount.incrementAndGet();\n\t\t}\n\t\telse {\n\t\t\tthis.hitCount.incrementAndGet();\n\t\t}\n\t\treturn context;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic void put(MergedContextConfiguration key, ApplicationContext context) {\n\t\tAssert.notNull(key, \"Key must not be null\");\n\t\tAssert.notNull(context, \"ApplicationContext must not be null\");\n\n\t\tthis.contextMap.put(key, context);\n\t\tMergedContextConfiguration child = key;\n\t\tMergedContextConfiguration parent = child.getParent();\n\t\twhile (parent != null) {\n\t\t\tSet<MergedContextConfiguration> list = this.hierarchyMap.computeIfAbsent(parent, k -> new HashSet<>());\n\t\t\tlist.add(child);\n\t\t\tchild = parent;\n\t\t\tparent = child.getParent();\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic void remove(MergedContextConfiguration key, @Nullable HierarchyMode hierarchyMode) {\n\t\tAssert.notNull(key, \"Key must not be null\");\n\n\t\t// startKey is the level at which to begin clearing the cache,\n\t\t// depending on the configured hierarchy mode.s\n\t\tMergedContextConfiguration startKey = key;\n\t\tif (hierarchyMode == HierarchyMode.EXHAUSTIVE) {\n\t\t\tMergedContextConfiguration parent = startKey.getParent();\n\t\t\twhile (parent != null) {\n\t\t\t\tstartKey = parent;\n\t\t\t\tparent = startKey.getParent();\n\t\t\t}\n\t\t}\n\n\t\tList<MergedContextConfiguration> removedContexts = new ArrayList<>();\n\t\tremove(removedContexts, startKey);\n\n\t\t// Remove all remaining references to any removed contexts from the\n\t\t// hierarchy map.\n\t\tfor (MergedContextConfiguration currentKey : removedContexts) {\n\t\t\tfor (Set<MergedContextConfiguration> children : this.hierarchyMap.values()) {\n\t\t\t\tchildren.remove(currentKey);\n\t\t\t}\n\t\t}\n\n\t\t// Remove empty entries from the hierarchy map.\n\t\tfor (Map.Entry<MergedContextConfiguration, Set<MergedContextConfiguration>> entry : this.hierarchyMap.entrySet()) {\n\t\t\tif (entry.getValue().isEmpty()) {\n\t\t\t\tthis.hierarchyMap.remove(entry.getKey());\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void remove(List<MergedContextConfiguration> removedContexts, MergedContextConfiguration key) {\n\t\tAssert.notNull(key, \"Key must not be null\");\n\n\t\tSet<MergedContextConfiguration> children = this.hierarchyMap.get(key);\n\t\tif (children != null) {\n\t\t\tfor (MergedContextConfiguration child : children) {\n\t\t\t\t// Recurse through lower levels\n\t\t\t\tremove(removedContexts, child);\n\t\t\t}\n\t\t\t// Remove the set of children for the current context from the hierarchy map.\n\t\t\tthis.hierarchyMap.remove(key);\n\t\t}\n\n\t\t// Physically remove and close leaf nodes first (i.e., on the way back up the\n\t\t// stack as opposed to prior to the recursive call).\n\t\tApplicationContext context = this.contextMap.remove(key);\n\t\tif (context instanceof ConfigurableApplicationContext cac) {\n\t\t\tcac.close();\n\t\t}\n\t\tremovedContexts.add(key);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic int size() {\n\t\treturn this.contextMap.size();\n\t}\n\n\t/**\n\t * Get the maximum size of this cache.\n\t */\n\tpublic int getMaxSize() {\n\t\treturn this.maxSize;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic int getParentContextCount() {\n\t\treturn this.hierarchyMap.size();\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic int getHitCount() {\n\t\treturn this.hitCount.get();\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic int getMissCount() {\n\t\treturn this.missCount.get();\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic void reset() {\n\t\tsynchronized (this.contextMap) {\n\t\t\tclear();\n\t\t\tclearStatistics();\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic void clear() {\n\t\tsynchronized (this.contextMap) {\n\t\t\tthis.contextMap.clear();\n\t\t\tthis.hierarchyMap.clear();\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic void clearStatistics() {\n\t\tsynchronized (this.contextMap) {\n\t\t\tthis.hitCount.set(0);\n\t\t\tthis.missCount.set(0);\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic void logStatistics() {\n\t\tif (statsLogger.isDebugEnabled()) {\n\t\t\tstatsLogger.debug(\"Spring test ApplicationContext cache statistics: \" + this);\n\t\t}\n\t}\n\n\t/**\n\t * Generate a text string containing the implementation type of this\n\t * cache and its statistics.\n\t * <p>The string returned by this method contains all information\n\t * required for compliance with the contract for {@link #logStatistics()}.\n\t * @return a string representation of this cache, including statistics\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn new ToStringCreator(this)\n\t\t\t\t.append(\"size\", size())\n\t\t\t\t.append(\"maxSize\", getMaxSize())\n\t\t\t\t.append(\"parentContextCount\", getParentContextCount())\n\t\t\t\t.append(\"hitCount\", getHitCount())\n\t\t\t\t.append(\"missCount\", getMissCount())\n\t\t\t\t.toString();\n\t}\n\n\n\t/**\n\t * Simple cache implementation based on {@link LinkedHashMap} with a maximum\n\t * size and a <em>least recently used</em> (LRU) eviction policy that\n\t * properly closes application contexts.\n\t * @since 4.3\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate class LruCache extends LinkedHashMap<MergedContextConfiguration, ApplicationContext> {\n\n\t\t/**\n\t\t * Create a new {@code LruCache} with the supplied initial capacity\n\t\t * and load factor.\n\t\t * @param initialCapacity the initial capacity\n\t\t * @param loadFactor the load factor\n\t\t */\n\t\tLruCache(int initialCapacity, float loadFactor) {\n\t\t\tsuper(initialCapacity, loadFactor, true);\n\t\t}\n\n\t\t@Override\n\t\tprotected boolean removeEldestEntry(Map.Entry<MergedContextConfiguration, ApplicationContext> eldest) {\n\t\t\tif (this.size() > DefaultContextCache.this.getMaxSize()) {\n\t\t\t\t// Do NOT delete \"DefaultContextCache.this.\"; otherwise, we accidentally\n\t\t\t\t// invoke java.util.Map.remove(Object, Object).\n\t\t\t\tDefaultContextCache.this.remove(eldest.getKey(), HierarchyMode.CURRENT_LEVEL);\n\t\t\t}\n\n\t\t\t// Return false since we invoke a custom eviction algorithm.\n\t\t\treturn false;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.test.context.cache.DefaultContextCache#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tsynchronized (this.contextMap) {\n\t\t\tthis.contextMap.clear();\n\t\t\tthis.hierarchyMap.clear();\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultContextCache#clearStatistics()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "void",
    "signature": "public void clearStatistics()",
    "source_code": "\tpublic void clearStatistics() {\n\t\tsynchronized (this.contextMap) {\n\t\t\tthis.hitCount.set(0);\n\t\t\tthis.missCount.set(0);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultContextCache#contains(key)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "boolean",
    "signature": "public boolean contains(MergedContextConfiguration key)",
    "source_code": "\tpublic boolean contains(MergedContextConfiguration key) {\n\t\tAssert.notNull(key, \"Key must not be null\");\n\t\treturn this.contextMap.containsKey(key);\n\t}"
  },
  "org.springframework.test.context.cache.DefaultContextCache#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext get(MergedContextConfiguration key)",
    "source_code": "\tpublic ApplicationContext get(MergedContextConfiguration key) {\n\t\tAssert.notNull(key, \"Key must not be null\");\n\t\tApplicationContext context = this.contextMap.get(key);\n\t\tif (context == null) {\n\t\t\tthis.missCount.incrementAndGet();\n\t\t}\n\t\telse {\n\t\t\tthis.hitCount.incrementAndGet();\n\t\t}\n\t\treturn context;\n\t}"
  },
  "org.springframework.test.context.cache.DefaultContextCache#getHitCount()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "int",
    "signature": "public int getHitCount()",
    "source_code": "\tpublic int getHitCount() {\n\t\treturn this.hitCount.get();\n\t}"
  },
  "org.springframework.test.context.cache.DefaultContextCache#getMaxSize()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the maximum size of this cache.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "int",
    "signature": "public int getMaxSize()",
    "source_code": "\tpublic int getMaxSize() {\n\t\treturn this.maxSize;\n\t}"
  },
  "org.springframework.test.context.cache.DefaultContextCache#getMissCount()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "int",
    "signature": "public int getMissCount()",
    "source_code": "\tpublic int getMissCount() {\n\t\treturn this.missCount.get();\n\t}"
  },
  "org.springframework.test.context.cache.DefaultContextCache#getParentContextCount()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "int",
    "signature": "public int getParentContextCount()",
    "source_code": "\tpublic int getParentContextCount() {\n\t\treturn this.hierarchyMap.size();\n\t}"
  },
  "org.springframework.test.context.cache.DefaultContextCache#logStatistics()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "void",
    "signature": "public void logStatistics()",
    "source_code": "\tpublic void logStatistics() {\n\t\tif (statsLogger.isDebugEnabled()) {\n\t\t\tstatsLogger.debug(\"Spring test ApplicationContext cache statistics: \" + this);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultContextCache#put(key,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void put(MergedContextConfiguration key, ApplicationContext context)",
    "source_code": "\tpublic void put(MergedContextConfiguration key, ApplicationContext context) {\n\t\tAssert.notNull(key, \"Key must not be null\");\n\t\tAssert.notNull(context, \"ApplicationContext must not be null\");\n\n\t\tthis.contextMap.put(key, context);\n\t\tMergedContextConfiguration child = key;\n\t\tMergedContextConfiguration parent = child.getParent();\n\t\twhile (parent != null) {\n\t\t\tSet<MergedContextConfiguration> list = this.hierarchyMap.computeIfAbsent(parent, k -> new HashSet<>());\n\t\t\tlist.add(child);\n\t\t\tchild = parent;\n\t\t\tparent = child.getParent();\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultContextCache#remove(key,hierarchyMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "public void remove(MergedContextConfiguration key, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tpublic void remove(MergedContextConfiguration key, @Nullable HierarchyMode hierarchyMode) {\n\t\tAssert.notNull(key, \"Key must not be null\");\n\n\t\t// startKey is the level at which to begin clearing the cache,\n\t\t// depending on the configured hierarchy mode.s\n\t\tMergedContextConfiguration startKey = key;\n\t\tif (hierarchyMode == HierarchyMode.EXHAUSTIVE) {\n\t\t\tMergedContextConfiguration parent = startKey.getParent();\n\t\t\twhile (parent != null) {\n\t\t\t\tstartKey = parent;\n\t\t\t\tparent = startKey.getParent();\n\t\t\t}\n\t\t}\n\n\t\tList<MergedContextConfiguration> removedContexts = new ArrayList<>();\n\t\tremove(removedContexts, startKey);\n\n\t\t// Remove all remaining references to any removed contexts from the\n\t\t// hierarchy map.\n\t\tfor (MergedContextConfiguration currentKey : removedContexts) {\n\t\t\tfor (Set<MergedContextConfiguration> children : this.hierarchyMap.values()) {\n\t\t\t\tchildren.remove(currentKey);\n\t\t\t}\n\t\t}\n\n\t\t// Remove empty entries from the hierarchy map.\n\t\tfor (Map.Entry<MergedContextConfiguration, Set<MergedContextConfiguration>> entry : this.hierarchyMap.entrySet()) {\n\t\t\tif (entry.getValue().isEmpty()) {\n\t\t\t\tthis.hierarchyMap.remove(entry.getKey());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultContextCache#removeEldestEntry(Map.Entry<MergedContextConfiguration,eldest)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map.Entry<MergedContextConfiguration",
      "eldest"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "boolean",
    "signature": "protected boolean removeEldestEntry(Map.Entry<MergedContextConfiguration, ApplicationContext> eldest)",
    "source_code": "\t\tprotected boolean removeEldestEntry(Map.Entry<MergedContextConfiguration, ApplicationContext> eldest) {\n\t\t\tif (this.size() > DefaultContextCache.this.getMaxSize()) {\n\t\t\t\t// Do NOT delete \"DefaultContextCache.this.\"; otherwise, we accidentally\n\t\t\t\t// invoke java.util.Map.remove(Object, Object).\n\t\t\t\tDefaultContextCache.this.remove(eldest.getKey(), HierarchyMode.CURRENT_LEVEL);\n\t\t\t}\n\n\t\t\t// Return false since we invoke a custom eviction algorithm.\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.test.context.cache.DefaultContextCache#reset()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "void",
    "signature": "public void reset()",
    "source_code": "\tpublic void reset() {\n\t\tsynchronized (this.contextMap) {\n\t\t\tclear();\n\t\t\tclearStatistics();\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultContextCache#size()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\tpublic int size() {\n\t\treturn this.contextMap.size();\n\t}"
  },
  "org.springframework.test.context.cache.DefaultContextCache#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a text string containing the implementation type of this\n\t * cache and its statistics.\n\t * <p>The string returned by this method contains all information\n\t * required for compliance with the contract for {@link #logStatistics()}.\n\t * @return a string representation of this cache, including statistics\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn new ToStringCreator(this)\n\t\t\t\t.append(\"size\", size())\n\t\t\t\t.append(\"maxSize\", getMaxSize())\n\t\t\t\t.append(\"parentContextCount\", getParentContextCount())\n\t\t\t\t.append(\"hitCount\", getHitCount())\n\t\t\t\t.append(\"missCount\", getMissCount())\n\t\t\t\t.toString();\n\t}"
  },
  "org.springframework.test.context.jdbc.<unknown>#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a String representation of the merged SQL script configuration.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn new ToStringCreator(this, new DefaultToStringStyler(new SimpleValueStyler()))\n\t\t\t\t.append(\"dataSource\", this.dataSource)\n\t\t\t\t.append(\"transactionManager\", this.transactionManager)\n\t\t\t\t.append(\"transactionMode\", this.transactionMode)\n\t\t\t\t.append(\"encoding\", this.encoding)\n\t\t\t\t.append(\"separator\", this.separator)\n\t\t\t\t.append(\"commentPrefixes\", this.commentPrefixes)\n\t\t\t\t.append(\"blockCommentStartDelimiter\", this.blockCommentStartDelimiter)\n\t\t\t\t.append(\"blockCommentEndDelimiter\", this.blockCommentEndDelimiter)\n\t\t\t\t.append(\"errorMode\", this.errorMode)\n\t\t\t\t.toString();\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.<unknown>#evaluateAnnotation(annotationType,Function<A,expressionExtractor,Function<A,reasonExtractor,Function<A,loadContextExtractor,enabledOnTrue,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Evaluate the expression configured via the supplied annotation type on\n\t * the {@link AnnotatedElement} for the supplied {@link ExtensionContext}.\n\t * @param annotationType the type of annotation to process\n\t * @param expressionExtractor a function that extracts the expression from\n\t * the annotation\n\t * @param reasonExtractor a function that extracts the reason from the\n\t * annotation\n\t * @param loadContextExtractor a function that extracts the {@code loadContext}\n\t * flag from the annotation\n\t * @param enabledOnTrue indicates whether the returned {@code ConditionEvaluationResult}\n\t * should be {@link ConditionEvaluationResult#enabled enabled} if the expression\n\t * evaluates to {@code true}\n\t * @param context the {@code ExtensionContext}\n\t * @return {@link ConditionEvaluationResult#enabled enabled} if the container\n\t * or test should be enabled; otherwise {@link ConditionEvaluationResult#disabled disabled}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "annotationType",
      "Function<A",
      "expressionExtractor",
      "Function<A",
      "reasonExtractor",
      "Function<A",
      "loadContextExtractor",
      "enabledOnTrue",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "ConditionEvaluationResult",
    "signature": "protected ConditionEvaluationResult evaluateAnnotation(Class<A> annotationType,\n\t\t\tFunction<A, String> expressionExtractor, Function<A, String> reasonExtractor,\n\t\t\tFunction<A, Boolean> loadContextExtractor, boolean enabledOnTrue, ExtensionContext context)",
    "source_code": "\tprotected <A extends Annotation> ConditionEvaluationResult evaluateAnnotation(Class<A> annotationType,"
  },
  "org.springframework.test.context.support.TestConstructorUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility methods for working with {@link TestConstructor @TestConstructor}.\n *\n * <p>Primarily intended for use within the framework.\n *\n * @author Sam Brannen\n * @since 5.2\n * @see TestConstructor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class TestConstructorUtils",
    "source_code": "public abstract class TestConstructorUtils {\n\n\tprivate TestConstructorUtils() {\n\t}\n\n\t/**\n\t * Determine if the supplied executable for the given test class is an\n\t * autowirable constructor.\n\t * <p>This method delegates to {@link #isAutowirableConstructor(Executable, Class, PropertyProvider)}\n\t * will a value of {@code null} for the fallback {@link PropertyProvider}.\n\t * @param executable an executable for the test class\n\t * @param testClass the test class\n\t * @return {@code true} if the executable is an autowirable constructor\n\t * @see #isAutowirableConstructor(Executable, Class, PropertyProvider)\n\t */\n\tpublic static boolean isAutowirableConstructor(Executable executable, Class<?> testClass) {\n\t\treturn isAutowirableConstructor(executable, testClass, null);\n\t}\n\n\t/**\n\t * Determine if the supplied constructor for the given test class is\n\t * autowirable.\n\t * <p>This method delegates to {@link #isAutowirableConstructor(Constructor, Class, PropertyProvider)}\n\t * will a value of {@code null} for the fallback {@link PropertyProvider}.\n\t * @param constructor a constructor for the test class\n\t * @param testClass the test class\n\t * @return {@code true} if the constructor is autowirable\n\t * @see #isAutowirableConstructor(Constructor, Class, PropertyProvider)\n\t */\n\tpublic static boolean isAutowirableConstructor(Constructor<?> constructor, Class<?> testClass) {\n\t\treturn isAutowirableConstructor(constructor, testClass, null);\n\t}\n\n\t/**\n\t * Determine if the supplied executable for the given test class is an\n\t * autowirable constructor.\n\t * <p>This method delegates to {@link #isAutowirableConstructor(Constructor, Class, PropertyProvider)}\n\t * if the supplied executable is a constructor and otherwise returns {@code false}.\n\t * @param executable an executable for the test class\n\t * @param testClass the test class\n\t * @param fallbackPropertyProvider fallback property provider used to look up\n\t * the value for {@link TestConstructor#TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME}\n\t * if no such value is found in {@link SpringProperties}\n\t * @return {@code true} if the executable is an autowirable constructor\n\t * @since 5.3\n\t * @see #isAutowirableConstructor(Constructor, Class, PropertyProvider)\n\t */\n\tpublic static boolean isAutowirableConstructor(Executable executable, Class<?> testClass,\n\t\t\t@Nullable PropertyProvider fallbackPropertyProvider) {\n\n\t\treturn (executable instanceof Constructor<?> constructor &&\n\t\t\t\tisAutowirableConstructor(constructor, testClass, fallbackPropertyProvider));\n\t}\n\n\t/**\n\t * Determine if the supplied constructor for the given test class is\n\t * autowirable.\n\t *\n\t * <p>A constructor is considered to be autowirable if one of the following\n\t * conditions is {@code true}.\n\t *\n\t * <ol>\n\t * <li>The constructor is annotated with {@link Autowired @Autowired}.</li>\n\t * <li>{@link TestConstructor @TestConstructor} is <em>present</em> or\n\t * <em>meta-present</em> on the test class with\n\t * {@link TestConstructor#autowireMode() autowireMode} set to\n\t * {@link AutowireMode#ALL ALL}.</li>\n\t * <li>The default <em>test constructor autowire mode</em> has been set to\n\t * {@code ALL} in {@link SpringProperties} or in the supplied fallback\n\t * {@link PropertyProvider} (see\n\t * {@link TestConstructor#TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME}).</li>\n\t * </ol>\n\t * @param constructor a constructor for the test class\n\t * @param testClass the test class\n\t * @param fallbackPropertyProvider fallback property provider used to look up\n\t * the value for the default <em>test constructor autowire mode</em> if no\n\t * such value is found in {@link SpringProperties}\n\t * @return {@code true} if the constructor is autowirable\n\t * @since 5.3\n\t */\n\tpublic static boolean isAutowirableConstructor(Constructor<?> constructor, Class<?> testClass,\n\t\t\t@Nullable PropertyProvider fallbackPropertyProvider) {\n\n\t\t// Is the constructor annotated with @Autowired?\n\t\tif (AnnotatedElementUtils.hasAnnotation(constructor, Autowired.class)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tAutowireMode autowireMode = null;\n\n\t\t// Is the test class annotated with @TestConstructor?\n\t\tTestConstructor testConstructor = TestContextAnnotationUtils.findMergedAnnotation(testClass, TestConstructor.class);\n\t\tif (testConstructor != null) {\n\t\t\tautowireMode = testConstructor.autowireMode();\n\t\t}\n\t\telse {\n\t\t\t// Custom global default from SpringProperties?\n\t\t\tString value = SpringProperties.getProperty(TestConstructor.TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME);\n\t\t\tautowireMode = AutowireMode.from(value);\n\n\t\t\t// Use fallback provider?\n\t\t\tif (autowireMode == null && fallbackPropertyProvider != null) {\n\t\t\t\tvalue = fallbackPropertyProvider.get(TestConstructor.TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME);\n\t\t\t\tautowireMode = AutowireMode.from(value);\n\t\t\t}\n\t\t}\n\n\t\treturn (autowireMode == AutowireMode.ALL);\n\t}\n\n}"
  },
  "org.springframework.test.context.support.TestConstructorUtils#isAutowirableConstructor(constructor,testClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied constructor for the given test class is\n\t * autowirable.\n\t * <p>This method delegates to {@link #isAutowirableConstructor(Constructor, Class, PropertyProvider)}\n\t * will a value of {@code null} for the fallback {@link PropertyProvider}.\n\t * @param constructor a constructor for the test class\n\t * @param testClass the test class\n\t * @return {@code true} if the constructor is autowirable\n\t * @see #isAutowirableConstructor(Constructor, Class, PropertyProvider)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constructor",
      "testClass"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "boolean",
    "signature": "public boolean isAutowirableConstructor(Constructor<?> constructor, Class<?> testClass)",
    "source_code": "\tpublic static boolean isAutowirableConstructor(Constructor<?> constructor, Class<?> testClass) {\n\t\treturn isAutowirableConstructor(constructor, testClass, null);\n\t}"
  },
  "org.springframework.test.context.support.TestConstructorUtils#isAutowirableConstructor(constructor,testClass,fallbackPropertyProvider)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied constructor for the given test class is\n\t * autowirable.\n\t *\n\t * <p>A constructor is considered to be autowirable if one of the following\n\t * conditions is {@code true}.\n\t *\n\t * <ol>\n\t * <li>The constructor is annotated with {@link Autowired @Autowired}.</li>\n\t * <li>{@link TestConstructor @TestConstructor} is <em>present</em> or\n\t * <em>meta-present</em> on the test class with\n\t * {@link TestConstructor#autowireMode() autowireMode} set to\n\t * {@link AutowireMode#ALL ALL}.</li>\n\t * <li>The default <em>test constructor autowire mode</em> has been set to\n\t * {@code ALL} in {@link SpringProperties} or in the supplied fallback\n\t * {@link PropertyProvider} (see\n\t * {@link TestConstructor#TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME}).</li>\n\t * </ol>\n\t * @param constructor a constructor for the test class\n\t * @param testClass the test class\n\t * @param fallbackPropertyProvider fallback property provider used to look up\n\t * the value for the default <em>test constructor autowire mode</em> if no\n\t * such value is found in {@link SpringProperties}\n\t * @return {@code true} if the constructor is autowirable\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constructor",
      "testClass",
      "fallbackPropertyProvider"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "boolean",
    "signature": "public boolean isAutowirableConstructor(Constructor<?> constructor, Class<?> testClass,\n\t\t\t@Nullable PropertyProvider fallbackPropertyProvider)",
    "source_code": "\tpublic static boolean isAutowirableConstructor(Constructor<?> constructor, Class<?> testClass,"
  },
  "org.springframework.test.context.support.TestConstructorUtils#isAutowirableConstructor(executable,testClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied executable for the given test class is an\n\t * autowirable constructor.\n\t * <p>This method delegates to {@link #isAutowirableConstructor(Executable, Class, PropertyProvider)}\n\t * will a value of {@code null} for the fallback {@link PropertyProvider}.\n\t * @param executable an executable for the test class\n\t * @param testClass the test class\n\t * @return {@code true} if the executable is an autowirable constructor\n\t * @see #isAutowirableConstructor(Executable, Class, PropertyProvider)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executable",
      "testClass"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "boolean",
    "signature": "public boolean isAutowirableConstructor(Executable executable, Class<?> testClass)",
    "source_code": "\tpublic static boolean isAutowirableConstructor(Executable executable, Class<?> testClass) {\n\t\treturn isAutowirableConstructor(executable, testClass, null);\n\t}"
  },
  "org.springframework.test.context.support.TestConstructorUtils#isAutowirableConstructor(executable,testClass,fallbackPropertyProvider)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied executable for the given test class is an\n\t * autowirable constructor.\n\t * <p>This method delegates to {@link #isAutowirableConstructor(Constructor, Class, PropertyProvider)}\n\t * if the supplied executable is a constructor and otherwise returns {@code false}.\n\t * @param executable an executable for the test class\n\t * @param testClass the test class\n\t * @param fallbackPropertyProvider fallback property provider used to look up\n\t * the value for {@link TestConstructor#TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME}\n\t * if no such value is found in {@link SpringProperties}\n\t * @return {@code true} if the executable is an autowirable constructor\n\t * @since 5.3\n\t * @see #isAutowirableConstructor(Constructor, Class, PropertyProvider)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executable",
      "testClass",
      "fallbackPropertyProvider"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "boolean",
    "signature": "public boolean isAutowirableConstructor(Executable executable, Class<?> testClass,\n\t\t\t@Nullable PropertyProvider fallbackPropertyProvider)",
    "source_code": "\tpublic static boolean isAutowirableConstructor(Executable executable, Class<?> testClass,"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Factory for request content {@code RequestMatcher}'s. An instance of this\n * class is typically accessed via {@link MockRestRequestMatchers#content()}.\n *\n * @author Rossen Stoyanchev\n * @since 3.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "signature": "public class ContentRequestMatchers",
    "source_code": "public class ContentRequestMatchers {\n\n\tprivate final XmlExpectationsHelper xmlHelper;\n\n\tprivate final JsonExpectationsHelper jsonHelper;\n\n\n\t/**\n\t * Class constructor, not for direct instantiation.\n\t * Use {@link MockRestRequestMatchers#content()}.\n\t */\n\tprotected ContentRequestMatchers() {\n\t\tthis.xmlHelper = new XmlExpectationsHelper();\n\t\tthis.jsonHelper = new JsonExpectationsHelper();\n\t}\n\n\n\t/**\n\t * Assert the request content type as a String.\n\t */\n\tpublic RequestMatcher contentType(String expectedContentType) {\n\t\treturn contentType(MediaType.parseMediaType(expectedContentType));\n\t}\n\n\t/**\n\t * Assert the request content type as a {@link MediaType}.\n\t */\n\tpublic RequestMatcher contentType(MediaType expectedContentType) {\n\t\treturn request -> {\n\t\t\tMediaType actualContentType = request.getHeaders().getContentType();\n\t\t\tassertTrue(\"Content type not set\", actualContentType != null);\n\t\t\tassertEquals(\"Content type\", expectedContentType, actualContentType);\n\t\t};\n\t}\n\n\t/**\n\t * Assert the request content type is compatible with the given\n\t * content type as defined by {@link MediaType#isCompatibleWith(MediaType)}.\n\t */\n\tpublic RequestMatcher contentTypeCompatibleWith(String contentType) {\n\t\treturn contentTypeCompatibleWith(MediaType.parseMediaType(contentType));\n\t}\n\n\t/**\n\t * Assert the request content type is compatible with the given\n\t * content type as defined by {@link MediaType#isCompatibleWith(MediaType)}.\n\t */\n\tpublic RequestMatcher contentTypeCompatibleWith(MediaType contentType) {\n\t\treturn request -> {\n\t\t\tMediaType actualContentType = request.getHeaders().getContentType();\n\t\t\tassertTrue(\"Content type not set\", actualContentType != null);\n\t\t\tif (actualContentType != null) {\n\t\t\t\tassertTrue(\"Content type [\" + actualContentType + \"] is not compatible with [\" + contentType + \"]\",\n\t\t\t\t\t\tactualContentType.isCompatibleWith(contentType));\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Get the body of the request as a UTF-8 string and apply the given {@link Matcher}.\n\t */\n\tpublic RequestMatcher string(Matcher<? super String> matcher) {\n\t\treturn request -> {\n\t\t\tMockClientHttpRequest mockRequest = (MockClientHttpRequest) request;\n\t\t\tassertThat(\"Request content\", mockRequest.getBodyAsString(), matcher);\n\t\t};\n\t}\n\n\t/**\n\t * Get the body of the request as a UTF-8 string and compare it to the given String.\n\t */\n\tpublic RequestMatcher string(String expectedContent) {\n\t\treturn request -> {\n\t\t\tMockClientHttpRequest mockRequest = (MockClientHttpRequest) request;\n\t\t\tassertEquals(\"Request content\", expectedContent, mockRequest.getBodyAsString());\n\t\t};\n\t}\n\n\t/**\n\t * Compare the body of the request to the given byte array.\n\t */\n\tpublic RequestMatcher bytes(byte[] expectedContent) {\n\t\treturn request -> {\n\t\t\tMockClientHttpRequest mockRequest = (MockClientHttpRequest) request;\n\t\t\tassertEquals(\"Request content\", expectedContent, mockRequest.getBodyAsBytes());\n\t\t};\n\t}\n\n\t/**\n\t * Parse the body as form data and compare to the given {@code MultiValueMap}.\n\t * @since 4.3\n\t */\n\tpublic RequestMatcher formData(MultiValueMap<String, String> expected) {\n\t\treturn formData(expected, true);\n\t}\n\n\t/**\n\t * Variant of {@link #formData(MultiValueMap)} that matches the given subset\n\t * of expected form parameters.\n\t * @since 5.3\n\t */\n\tpublic RequestMatcher formDataContains(Map<String, String> expected) {\n\t\tMultiValueMap<String, String> multiValueMap = new LinkedMultiValueMap<>(expected.size());\n\t\texpected.forEach(multiValueMap::add);\n\t\treturn formData(multiValueMap, false);\n\t}\n\n\tprivate RequestMatcher formData(MultiValueMap<String, String> expectedMap, boolean containsExactly) {\n\t\treturn request -> {\n\t\t\tMockClientHttpRequest mockRequest = (MockClientHttpRequest) request;\n\t\t\tMockHttpInputMessage message = new MockHttpInputMessage(mockRequest.getBodyAsBytes());\n\t\t\tmessage.getHeaders().putAll(mockRequest.getHeaders());\n\t\t\tMultiValueMap<String, String> actualMap = new FormHttpMessageConverter().read(null, message);\n\t\t\tif (containsExactly) {\n\t\t\t\tassertEquals(\"Form data\", expectedMap, actualMap);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassertTrue(\"Form data \" + actualMap, expectedMap.size() <= actualMap.size());\n\t\t\t\tfor (Map.Entry<String, ? extends List<?>> entry : expectedMap.entrySet()) {\n\t\t\t\t\tString name = entry.getKey();\n\t\t\t\t\tList<?> values = entry.getValue();\n\t\t\t\t\tassertTrue(\"No form parameter '\" + name + \"'\", actualMap.get(name) != null);\n\t\t\t\t\tassertTrue(\"Parameter value count \" + values.size(), values.size() <= actualMap.get(name).size());\n\t\t\t\t\tfor (int i = 0; i < values.size(); i++) {\n\t\t\t\t\t\tassertEquals(\"Form parameter\", values.get(i), actualMap.get(name).get(i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Parse the body as multipart data and assert it contains exactly the\n\t * values from the given {@code MultiValueMap}. Values may be of type:\n\t * <ul>\n\t * <li>{@code String} - form field\n\t * <li>{@link Resource} - content from a file\n\t * <li>{@code byte[]} - other raw content\n\t * </ul>\n\t * <p><strong>Note:</strong> This method uses the Apache Commons FileUpload\n\t * library to parse the multipart data and it must be on the test classpath.\n\t * @param expectedMap the expected multipart values\n\t * @since 5.3\n\t */\n\tpublic RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap) {\n\t\treturn multipartData(expectedMap, true);\n\t}\n\n\t/**\n\t * Variant of {@link #multipartData(MultiValueMap)} that does the same but\n\t * only for a subset of the actual values.\n\t * @param expectedMap the expected multipart values\n\t * @since 5.3\n\t */\n\tpublic RequestMatcher multipartDataContains(Map<String, ?> expectedMap) {\n\t\tMultiValueMap<String, Object> map = new LinkedMultiValueMap<>(expectedMap.size());\n\t\texpectedMap.forEach(map::add);\n\t\treturn multipartData(map, false);\n\t}\n\n\t@SuppressWarnings(\"ConstantConditions\")\n\tprivate RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap, boolean containsExactly) {\n\t\treturn request -> {\n\t\t\tMultiValueMap<String, ?> actualMap = MultipartHelper.parse((MockClientHttpRequest) request);\n\t\t\tif (containsExactly) {\n\t\t\t\tassertEquals(\"Multipart request content: \" + actualMap, expectedMap.size(), actualMap.size());\n\t\t\t}\n\t\t\tfor (Map.Entry<String, ? extends List<?>> entry : expectedMap.entrySet()) {\n\t\t\t\tString name = entry.getKey();\n\t\t\t\tList<?> values = entry.getValue();\n\t\t\t\tassertTrue(\"No Multipart '\" + name + \"'\", actualMap.get(name) != null);\n\t\t\t\tassertTrue(\"Multipart value count \" + values.size(), containsExactly ?\n\t\t\t\t\t\tvalues.size() == actualMap.get(name).size() :\n\t\t\t\t\t\tvalues.size() <= actualMap.get(name).size());\n\t\t\t\tfor (int i = 0; i < values.size(); i++) {\n\t\t\t\t\tObject expected = values.get(i);\n\t\t\t\t\tObject actual = actualMap.get(name).get(i);\n\t\t\t\t\tif (expected instanceof Resource resource) {\n\t\t\t\t\t\texpected = StreamUtils.copyToByteArray(resource.getInputStream());\n\t\t\t\t\t}\n\t\t\t\t\tif (expected instanceof byte[]) {\n\t\t\t\t\t\tassertTrue(\"Multipart is not a file\", actual instanceof byte[]);\n\t\t\t\t\t\tassertEquals(\"Multipart content\", expected, actual);\n\t\t\t\t\t}\n\t\t\t\t\telse if (expected instanceof String) {\n\t\t\t\t\t\tassertTrue(\"Multipart is not a String\", actual instanceof String);\n\t\t\t\t\t\tassertEquals(\"Multipart content\", expected, actual);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Unexpected multipart value: \" + expected.getClass());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Parse the request body and the given String as XML and assert that the\n\t * two are \"similar\" - i.e. they contain the same elements and attributes\n\t * regardless of order.\n\t * <p>Use of this matcher assumes the\n\t * <a href=\"https://www.xmlunit.org/\">XMLUnit</a> library is available.\n\t * @param expectedXmlContent the expected XML content\n\t */\n\tpublic RequestMatcher xml(String expectedXmlContent) {\n\t\treturn new AbstractXmlRequestMatcher() {\n\t\t\t@Override\n\t\t\tprotected void matchInternal(MockClientHttpRequest request) throws Exception {\n\t\t\t\txmlHelper.assertXmlEqual(expectedXmlContent, request.getBodyAsString());\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Parse the request content as {@link Node} and apply the given {@link Matcher}.\n\t */\n\tpublic RequestMatcher node(Matcher<? super Node> matcher) {\n\t\treturn new AbstractXmlRequestMatcher() {\n\t\t\t@Override\n\t\t\tprotected void matchInternal(MockClientHttpRequest request) throws Exception {\n\t\t\t\txmlHelper.assertNode(request.getBodyAsString(), matcher);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Parse the request content as {@link DOMSource} and apply the given {@link Matcher}.\n\t * @see <a href=\"https://code.google.com/p/xml-matchers/\">https://code.google.com/p/xml-matchers/</a>\n\t */\n\tpublic RequestMatcher source(Matcher<? super Source> matcher) {\n\t\treturn new AbstractXmlRequestMatcher() {\n\t\t\t@Override\n\t\t\tprotected void matchInternal(MockClientHttpRequest request) throws Exception {\n\t\t\t\txmlHelper.assertSource(request.getBodyAsString(), matcher);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Parse the expected and actual strings as JSON and assert the two\n\t * are \"similar\" - i.e. they contain the same attribute-value pairs\n\t * regardless of formatting with a lenient checking (extensible, and non-strict array\n\t * ordering).\n\t * <p>Use of this matcher requires the <a\n\t * href=\"https://jsonassert.skyscreamer.org/\">JSONassert</a> library.\n\t * @param expectedJsonContent the expected JSON content\n\t * @since 5.0.5\n\t */\n\tpublic RequestMatcher json(String expectedJsonContent) {\n\t\treturn json(expectedJsonContent, false);\n\t}\n\n\t/**\n\t * Parse the request body and the given string as JSON and assert the two\n\t * are \"similar\" - i.e. they contain the same attribute-value pairs\n\t * regardless of formatting.\n\t * <p>Can compare in two modes, depending on {@code strict} parameter value:\n\t * <ul>\n\t * <li>{@code true}: strict checking. Not extensible, and strict array ordering.</li>\n\t * <li>{@code false}: lenient checking. Extensible, and non-strict array ordering.</li>\n\t * </ul>\n\t * <p>Use of this matcher requires the <a\n\t * href=\"https://jsonassert.skyscreamer.org/\">JSONassert</a> library.\n\t * @param expectedJsonContent the expected JSON content\n\t * @param strict enables strict checking\n\t * @since 5.0.5\n\t */\n\tpublic RequestMatcher json(String expectedJsonContent, boolean strict) {\n\t\treturn request -> {\n\t\t\ttry {\n\t\t\t\tMockClientHttpRequest mockRequest = (MockClientHttpRequest) request;\n\t\t\t\tthis.jsonHelper.assertJsonEqual(expectedJsonContent, mockRequest.getBodyAsString(), strict);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new AssertionError(\"Failed to parse expected or actual JSON request content\", ex);\n\t\t\t}\n\t\t};\n\t}\n\n\n\t/**\n\t * Abstract base class for XML {@link RequestMatcher}'s.\n\t */\n\tprivate abstract static class AbstractXmlRequestMatcher implements RequestMatcher {\n\n\t\t@Override\n\t\tpublic final void match(ClientHttpRequest request) throws IOException, AssertionError {\n\t\t\ttry {\n\t\t\t\tMockClientHttpRequest mockRequest = (MockClientHttpRequest) request;\n\t\t\t\tmatchInternal(mockRequest);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new AssertionError(\"Failed to parse expected or actual XML request content\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprotected abstract void matchInternal(MockClientHttpRequest request) throws Exception;\n\t}\n\n\n\tprivate static class MultipartHelper {\n\n\t\tpublic static MultiValueMap<String, ?> parse(MockClientHttpRequest request) {\n\t\t\ttry {\n\t\t\t\tFileUpload fileUpload = new FileUpload();\n\t\t\t\tfileUpload.setFileItemFactory(new DiskFileItemFactory());\n\n\t\t\t\tList<FileItem> fileItems = fileUpload.parseRequest(new UploadContext() {\n\t\t\t\t\tprivate final byte[] body = request.getBodyAsBytes();\n\t\t\t\t\t@Override\n\t\t\t\t\t@Nullable\n\t\t\t\t\tpublic String getCharacterEncoding() {\n\t\t\t\t\t\treturn request.getHeaders().getFirst(HttpHeaders.CONTENT_ENCODING);\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\t@Nullable\n\t\t\t\t\tpublic String getContentType() {\n\t\t\t\t\t\treturn request.getHeaders().getFirst(HttpHeaders.CONTENT_TYPE);\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic InputStream getInputStream() {\n\t\t\t\t\t\treturn new ByteArrayInputStream(this.body);\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic long contentLength() {\n\t\t\t\t\t\treturn this.body.length;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tMultiValueMap<String, Object> result = new LinkedMultiValueMap<>();\n\t\t\t\tfor (FileItem fileItem : fileItems) {\n\t\t\t\t\tresult.add(fileItem.getFieldName(),\n\t\t\t\t\t\t\t(fileItem.isFormField() ? fileItem.getString() : fileItem.get()));\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to parse multipart request\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#bytes(expectedContent)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Compare the body of the request to the given byte array.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedContent"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher bytes(byte[] expectedContent)",
    "source_code": "\tpublic RequestMatcher bytes(byte[] expectedContent) {\n\t\treturn request -> {\n\t\t\tMockClientHttpRequest mockRequest = (MockClientHttpRequest) request;\n\t\t\tassertEquals(\"Request content\", expectedContent, mockRequest.getBodyAsBytes());\n\t\t};\n\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#contentLength()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "long",
    "signature": "public long contentLength()",
    "source_code": "\t\t\t\t\tpublic long contentLength() {\n\t\t\t\t\t\treturn this.body.length;\n\t\t\t\t\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#contentType(expectedContentType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the request content type as a {@link MediaType}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedContentType"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher contentType(MediaType expectedContentType)",
    "source_code": "\tpublic RequestMatcher contentType(MediaType expectedContentType) {\n\t\treturn request -> {\n\t\t\tMediaType actualContentType = request.getHeaders().getContentType();\n\t\t\tassertTrue(\"Content type not set\", actualContentType != null);\n\t\t\tassertEquals(\"Content type\", expectedContentType, actualContentType);\n\t\t};\n\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#contentTypeCompatibleWith(contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the request content type is compatible with the given\n\t * content type as defined by {@link MediaType#isCompatibleWith(MediaType)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher contentTypeCompatibleWith(MediaType contentType)",
    "source_code": "\tpublic RequestMatcher contentTypeCompatibleWith(MediaType contentType) {\n\t\treturn request -> {\n\t\t\tMediaType actualContentType = request.getHeaders().getContentType();\n\t\t\tassertTrue(\"Content type not set\", actualContentType != null);\n\t\t\tif (actualContentType != null) {\n\t\t\t\tassertTrue(\"Content type [\" + actualContentType + \"] is not compatible with [\" + contentType + \"]\",\n\t\t\t\t\t\tactualContentType.isCompatibleWith(contentType));\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#formData(MultiValueMap<String,expected)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the body as form data and compare to the given {@code MultiValueMap}.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "expected"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher formData(MultiValueMap<String, String> expected)",
    "source_code": "\tpublic RequestMatcher formData(MultiValueMap<String, String> expected) {\n\t\treturn formData(expected, true);\n\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#formDataContains(Map<String,expected)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #formData(MultiValueMap)} that matches the given subset\n\t * of expected form parameters.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "expected"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher formDataContains(Map<String, String> expected)",
    "source_code": "\tpublic RequestMatcher formDataContains(Map<String, String> expected) {\n\t\tMultiValueMap<String, String> multiValueMap = new LinkedMultiValueMap<>(expected.size());\n\t\texpected.forEach(multiValueMap::add);\n\t\treturn formData(multiValueMap, false);\n\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#getCharacterEncoding()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "String",
    "signature": "public String getCharacterEncoding()",
    "source_code": "\t\t\t\t\tpublic String getCharacterEncoding() {\n\t\t\t\t\t\treturn request.getHeaders().getFirst(HttpHeaders.CONTENT_ENCODING);\n\t\t\t\t\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#getContentType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "String",
    "signature": "public String getContentType()",
    "source_code": "\t\t\t\t\tpublic String getContentType() {\n\t\t\t\t\t\treturn request.getHeaders().getFirst(HttpHeaders.CONTENT_TYPE);\n\t\t\t\t\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#getInputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "InputStream",
    "signature": "public InputStream getInputStream()",
    "source_code": "\t\t\t\t\tpublic InputStream getInputStream() {\n\t\t\t\t\t\treturn new ByteArrayInputStream(this.body);\n\t\t\t\t\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#json(expectedJsonContent)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the expected and actual strings as JSON and assert the two\n\t * are \"similar\" - i.e. they contain the same attribute-value pairs\n\t * regardless of formatting with a lenient checking (extensible, and non-strict array\n\t * ordering).\n\t * <p>Use of this matcher requires the <a\n\t * href=\"https://jsonassert.skyscreamer.org/\">JSONassert</a> library.\n\t * @param expectedJsonContent the expected JSON content\n\t * @since 5.0.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedJsonContent"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher json(String expectedJsonContent)",
    "source_code": "\tpublic RequestMatcher json(String expectedJsonContent) {\n\t\treturn json(expectedJsonContent, false);\n\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#json(expectedJsonContent,strict)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the request body and the given string as JSON and assert the two\n\t * are \"similar\" - i.e. they contain the same attribute-value pairs\n\t * regardless of formatting.\n\t * <p>Can compare in two modes, depending on {@code strict} parameter value:\n\t * <ul>\n\t * <li>{@code true}: strict checking. Not extensible, and strict array ordering.</li>\n\t * <li>{@code false}: lenient checking. Extensible, and non-strict array ordering.</li>\n\t * </ul>\n\t * <p>Use of this matcher requires the <a\n\t * href=\"https://jsonassert.skyscreamer.org/\">JSONassert</a> library.\n\t * @param expectedJsonContent the expected JSON content\n\t * @param strict enables strict checking\n\t * @since 5.0.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedJsonContent",
      "strict"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher json(String expectedJsonContent, boolean strict)",
    "source_code": "\tpublic RequestMatcher json(String expectedJsonContent, boolean strict) {\n\t\treturn request -> {\n\t\t\ttry {\n\t\t\t\tMockClientHttpRequest mockRequest = (MockClientHttpRequest) request;\n\t\t\t\tthis.jsonHelper.assertJsonEqual(expectedJsonContent, mockRequest.getBodyAsString(), strict);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new AssertionError(\"Failed to parse expected or actual JSON request content\", ex);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#match(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "void",
    "signature": "public void match(ClientHttpRequest request)",
    "source_code": "\t\tpublic final void match(ClientHttpRequest request) throws IOException, AssertionError {\n\t\t\ttry {\n\t\t\t\tMockClientHttpRequest mockRequest = (MockClientHttpRequest) request;\n\t\t\t\tmatchInternal(mockRequest);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new AssertionError(\"Failed to parse expected or actual XML request content\", ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#matchInternal(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "void",
    "signature": "protected void matchInternal(MockClientHttpRequest request)",
    "source_code": "\t\tprotected abstract void matchInternal(MockClientHttpRequest request) throws Exception;"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#multipartData(MultiValueMap<String,expectedMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the body as multipart data and assert it contains exactly the\n\t * values from the given {@code MultiValueMap}. Values may be of type:\n\t * <ul>\n\t * <li>{@code String} - form field\n\t * <li>{@link Resource} - content from a file\n\t * <li>{@code byte[]} - other raw content\n\t * </ul>\n\t * <p><strong>Note:</strong> This method uses the Apache Commons FileUpload\n\t * library to parse the multipart data and it must be on the test classpath.\n\t * @param expectedMap the expected multipart values\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "expectedMap"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap)",
    "source_code": "\tpublic RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap) {\n\t\treturn multipartData(expectedMap, true);\n\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#multipartDataContains(Map<String,expectedMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #multipartData(MultiValueMap)} that does the same but\n\t * only for a subset of the actual values.\n\t * @param expectedMap the expected multipart values\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "expectedMap"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher multipartDataContains(Map<String, ?> expectedMap)",
    "source_code": "\tpublic RequestMatcher multipartDataContains(Map<String, ?> expectedMap) {\n\t\tMultiValueMap<String, Object> map = new LinkedMultiValueMap<>(expectedMap.size());\n\t\texpectedMap.forEach(map::add);\n\t\treturn multipartData(map, false);\n\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#node(matcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the request content as {@link Node} and apply the given {@link Matcher}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher node(Matcher<? super Node> matcher)",
    "source_code": "\tpublic RequestMatcher node(Matcher<? super Node> matcher) {\n\t\treturn new AbstractXmlRequestMatcher() {\n\t\t\t@Override\n\t\t\tprotected void matchInternal(MockClientHttpRequest request) throws Exception {\n\t\t\t\txmlHelper.assertNode(request.getBodyAsString(), matcher);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#source(matcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the request content as {@link DOMSource} and apply the given {@link Matcher}.\n\t * @see <a href=\"https://code.google.com/p/xml-matchers/\">https://code.google.com/p/xml-matchers/</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher source(Matcher<? super Source> matcher)",
    "source_code": "\tpublic RequestMatcher source(Matcher<? super Source> matcher) {\n\t\treturn new AbstractXmlRequestMatcher() {\n\t\t\t@Override\n\t\t\tprotected void matchInternal(MockClientHttpRequest request) throws Exception {\n\t\t\t\txmlHelper.assertSource(request.getBodyAsString(), matcher);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#string(expectedContent)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the body of the request as a UTF-8 string and compare it to the given String.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedContent"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher string(String expectedContent)",
    "source_code": "\tpublic RequestMatcher string(String expectedContent) {\n\t\treturn request -> {\n\t\t\tMockClientHttpRequest mockRequest = (MockClientHttpRequest) request;\n\t\t\tassertEquals(\"Request content\", expectedContent, mockRequest.getBodyAsString());\n\t\t};\n\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#string(matcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the body of the request as a UTF-8 string and apply the given {@link Matcher}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher string(Matcher<? super String> matcher)",
    "source_code": "\tpublic RequestMatcher string(Matcher<? super String> matcher) {\n\t\treturn request -> {\n\t\t\tMockClientHttpRequest mockRequest = (MockClientHttpRequest) request;\n\t\t\tassertThat(\"Request content\", mockRequest.getBodyAsString(), matcher);\n\t\t};\n\t}"
  },
  "org.springframework.test.web.client.match.ContentRequestMatchers#xml(expectedXmlContent)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the request body and the given String as XML and assert that the\n\t * two are \"similar\" - i.e. they contain the same elements and attributes\n\t * regardless of order.\n\t * <p>Use of this matcher assumes the\n\t * <a href=\"https://www.xmlunit.org/\">XMLUnit</a> library is available.\n\t * @param expectedXmlContent the expected XML content\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedXmlContent"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher xml(String expectedXmlContent)",
    "source_code": "\tpublic RequestMatcher xml(String expectedXmlContent) {\n\t\treturn new AbstractXmlRequestMatcher() {\n\t\t\t@Override\n\t\t\tprotected void matchInternal(MockClientHttpRequest request) throws Exception {\n\t\t\t\txmlHelper.assertXmlEqual(expectedXmlContent, request.getBodyAsString());\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#connect(method,uri,ClientHttpRequest,requestCallback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uri",
      "ClientHttpRequest",
      "requestCallback"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "Mono<ClientHttpResponse>",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,"
  },
  "org.springframework.test.web.reactive.server.<unknown>#getBody()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> getBody()",
    "source_code": "\t\tpublic Flux<DataBuffer> getBody() {\n\t\t\treturn Flux.from(this.recorder.getPublisherToUse());\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#getContent()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "Mono<byte[]>",
    "signature": "public Mono<byte[]> getContent()",
    "source_code": "\t\tpublic Mono<byte[]> getContent() {\n\t\t\treturn Mono.defer(() -> {\n\t\t\t\tif (this.content.scan(Scannable.Attr.TERMINATED) == Boolean.TRUE) {\n\t\t\t\t\treturn this.content.asMono();\n\t\t\t\t}\n\t\t\t\tif (!this.hasContentConsumer) {\n\t\t\t\t\t// Couple of possible cases:\n\t\t\t\t\t//  1. Mock server never consumed request body (e.g. error before read)\n\t\t\t\t\t//  2. FluxExchangeResult: getResponseBodyContent called before getResponseBody\n\t\t\t\t\t//noinspection ConstantConditions\n\t\t\t\t\t(this.publisher != null ? this.publisher : this.publisherNested)\n\t\t\t\t\t\t\t.onErrorMap(ex -> new IllegalStateException(\n\t\t\t\t\t\t\t\t\t\"Content has not been consumed, and \" +\n\t\t\t\t\t\t\t\t\t\t\t\"an error was raised while attempting to produce it.\", ex))\n\t\t\t\t\t\t\t.subscribe();\n\t\t\t\t}\n\t\t\t\treturn this.content.asMono();\n\t\t\t});\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#getMockServerResult()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "Object",
    "signature": "public Object getMockServerResult()",
    "source_code": "\t\tpublic Object getMockServerResult() {\n\t\t\treturn (getDelegate() instanceof MockServerClientHttpResponse mockResponse ?\n\t\t\t\t\tmockResponse.getServerResult() : null);\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#getRecorder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "WiretapRecorder",
    "signature": "public WiretapRecorder getRecorder()",
    "source_code": "\t\tpublic WiretapRecorder getRecorder() {\n\t\t\treturn this.recorder;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#getRequest()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "WiretapClientHttpRequest",
    "signature": "public WiretapClientHttpRequest getRequest()",
    "source_code": "\t\tpublic WiretapClientHttpRequest getRequest() {\n\t\t\treturn this.request;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#getResponse()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "WiretapClientHttpResponse",
    "signature": "public WiretapClientHttpResponse getResponse()",
    "source_code": "\t\tpublic WiretapClientHttpResponse getResponse() {\n\t\t\treturn this.response;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#setComplete()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> setComplete()",
    "source_code": "\t\tpublic Mono<Void> setComplete() {\n\t\t\tthis.recorder = new WiretapRecorder(null, null);\n\t\t\treturn super.setComplete();\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#writeAndFlushWith(publisher)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> publisher)",
    "source_code": "\t\tpublic Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> publisher) {\n\t\t\tthis.recorder = new WiretapRecorder(null, publisher);\n\t\t\treturn super.writeAndFlushWith(this.recorder.getNestedPublisherToUse());\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#writeWith(publisher)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> writeWith(Publisher<? extends DataBuffer> publisher)",
    "source_code": "\t\tpublic Mono<Void> writeWith(Publisher<? extends DataBuffer> publisher) {\n\t\t\tthis.recorder = new WiretapRecorder(publisher, null);\n\t\t\treturn super.writeWith(this.recorder.getPublisherToUse());\n\t\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#getHandler(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "HandlerExecutionChain",
    "signature": "protected HandlerExecutionChain getHandler(HttpServletRequest request)",
    "source_code": "\tprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n\t\tHandlerExecutionChain chain = super.getHandler(request);\n\t\tif (chain != null) {\n\t\t\tDefaultMvcResult mvcResult = getMvcResult(request);\n\t\t\tmvcResult.setHandler(chain.getHandler());\n\t\t\tmvcResult.setInterceptors(chain.getInterceptors());\n\t\t}\n\t\treturn chain;\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#getMvcResult(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "DefaultMvcResult",
    "signature": "protected DefaultMvcResult getMvcResult(ServletRequest request)",
    "source_code": "\tprotected DefaultMvcResult getMvcResult(ServletRequest request) {\n\t\treturn (DefaultMvcResult) request.getAttribute(MockMvc.MVC_RESULT_ATTRIBUTE);\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#postProcess(r,result,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "r",
      "result",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void postProcess(NativeWebRequest r, DeferredResult<T> result, Object value)",
    "source_code": "\t\t\t\t\tpublic <T> void postProcess(NativeWebRequest r, DeferredResult<T> result, Object value) {\n\t\t\t\t\t\tgetMvcResult(request).setAsyncResult(value);\n\t\t\t\t\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#postProcess(r,task,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "r",
      "task",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "void",
    "signature": "public void postProcess(NativeWebRequest r, Callable<T> task, Object value)",
    "source_code": "\t\t\t\t\tpublic <T> void postProcess(NativeWebRequest r, Callable<T> task, Object value) {\n\t\t\t\t\t\t// We got the result, must also wait for the dispatch\n\t\t\t\t\t\tgetMvcResult(request).setAsyncResult(value);\n\t\t\t\t\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#processHandlerException(request,response,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,\n\t\t\t@Nullable Object handler, Exception ex)",
    "source_code": "\tprotected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,"
  },
  "org.springframework.test.web.servlet.<unknown>#render(mv,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)"
  },
  "org.springframework.test.web.servlet.<unknown>#service(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "protected void service(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void service(HttpServletRequest request, HttpServletResponse response)"
  },
  "org.springframework.test.web.servlet.MockMvc": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * <strong>Main entry point for server-side Spring MVC test support.</strong>\n *\n * <h3>Example</h3>\n *\n * <pre class=\"code\">\n * import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;\n * import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;\n * import static org.springframework.test.web.servlet.setup.MockMvcBuilders.*;\n *\n * // ...\n *\n * WebApplicationContext wac = ...;\n *\n * MockMvc mockMvc = webAppContextSetup(wac).build();\n *\n * mockMvc.perform(get(\"/form\"))\n *     .andExpectAll(\n *         status().isOk(),\n *         content().contentType(\"text/html\"),\n *         forwardedUrl(\"/WEB-INF/layouts/main.jsp\")\n *     );\n * </pre>\n *\n * @author Rossen Stoyanchev\n * @author Rob Winch\n * @author Sam Brannen\n * @since 3.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "signature": "public class MockMvc",
    "source_code": "public final class MockMvc {\n\n\tstatic final String MVC_RESULT_ATTRIBUTE = MockMvc.class.getName().concat(\".MVC_RESULT_ATTRIBUTE\");\n\n\tprivate final TestDispatcherServlet servlet;\n\n\tprivate final Filter[] filters;\n\n\tprivate final ServletContext servletContext;\n\n\t@Nullable\n\tprivate RequestBuilder defaultRequestBuilder;\n\n\t@Nullable\n\tprivate Charset defaultResponseCharacterEncoding;\n\n\tprivate List<ResultMatcher> defaultResultMatchers = new ArrayList<>();\n\n\tprivate List<ResultHandler> defaultResultHandlers = new ArrayList<>();\n\n\n\t/**\n\t * Private constructor, not for direct instantiation.\n\t * @see org.springframework.test.web.servlet.setup.MockMvcBuilders\n\t */\n\tMockMvc(TestDispatcherServlet servlet, Filter... filters) {\n\t\tAssert.notNull(servlet, \"DispatcherServlet is required\");\n\t\tAssert.notNull(filters, \"Filters cannot be null\");\n\t\tAssert.noNullElements(filters, \"Filters cannot contain null values\");\n\n\t\tthis.servlet = servlet;\n\t\tthis.filters = filters;\n\t\tthis.servletContext = servlet.getServletContext();\n\t}\n\n\n\t/**\n\t * A default request builder merged into every performed request.\n\t * @see org.springframework.test.web.servlet.setup.DefaultMockMvcBuilder#defaultRequest(RequestBuilder)\n\t */\n\tvoid setDefaultRequest(@Nullable RequestBuilder requestBuilder) {\n\t\tthis.defaultRequestBuilder = requestBuilder;\n\t}\n\n\t/**\n\t * The default character encoding to be applied to every response.\n\t * @see org.springframework.test.web.servlet.setup.ConfigurableMockMvcBuilder#defaultResponseCharacterEncoding(Charset)\n\t */\n\tvoid setDefaultResponseCharacterEncoding(@Nullable Charset defaultResponseCharacterEncoding) {\n\t\tthis.defaultResponseCharacterEncoding = defaultResponseCharacterEncoding;\n\t}\n\n\t/**\n\t * Expectations to assert after every performed request.\n\t * @see org.springframework.test.web.servlet.setup.DefaultMockMvcBuilder#alwaysExpect(ResultMatcher)\n\t */\n\tvoid setGlobalResultMatchers(List<ResultMatcher> resultMatchers) {\n\t\tAssert.notNull(resultMatchers, \"ResultMatcher List is required\");\n\t\tthis.defaultResultMatchers = resultMatchers;\n\t}\n\n\t/**\n\t * General actions to apply after every performed request.\n\t * @see org.springframework.test.web.servlet.setup.DefaultMockMvcBuilder#alwaysDo(ResultHandler)\n\t */\n\tvoid setGlobalResultHandlers(List<ResultHandler> resultHandlers) {\n\t\tAssert.notNull(resultHandlers, \"ResultHandler List is required\");\n\t\tthis.defaultResultHandlers = resultHandlers;\n\t}\n\n\t/**\n\t * Return the underlying {@link DispatcherServlet} instance that this\n\t * {@code MockMvc} was initialized with.\n\t * <p>This is intended for use in custom request processing scenario where a\n\t * request handling component happens to delegate to the {@code DispatcherServlet}\n\t * at runtime and therefore needs to be injected with it.\n\t * <p>For most processing scenarios, simply use {@link MockMvc#perform},\n\t * or if you need to configure the {@code DispatcherServlet}, provide a\n\t * {@link DispatcherServletCustomizer} to the {@code MockMvcBuilder}.\n\t * @since 5.1\n\t */\n\tpublic DispatcherServlet getDispatcherServlet() {\n\t\treturn this.servlet;\n\t}\n\n\n\t/**\n\t * Perform a request and return a type that allows chaining further\n\t * actions, such as asserting expectations, on the result.\n\t * @param requestBuilder used to prepare the request to execute;\n\t * see static factory methods in\n\t * {@link org.springframework.test.web.servlet.request.MockMvcRequestBuilders}\n\t * @return an instance of {@link ResultActions} (never {@code null})\n\t * @see org.springframework.test.web.servlet.request.MockMvcRequestBuilders\n\t * @see org.springframework.test.web.servlet.result.MockMvcResultMatchers\n\t */\n\tpublic ResultActions perform(RequestBuilder requestBuilder) throws Exception {\n\t\tif (this.defaultRequestBuilder != null && requestBuilder instanceof Mergeable mergeable) {\n\t\t\trequestBuilder = (RequestBuilder) mergeable.merge(this.defaultRequestBuilder);\n\t\t}\n\n\t\tMockHttpServletRequest request = requestBuilder.buildRequest(this.servletContext);\n\n\t\tAsyncContext asyncContext = request.getAsyncContext();\n\t\tMockHttpServletResponse mockResponse;\n\t\tHttpServletResponse servletResponse;\n\t\tif (asyncContext != null) {\n\t\t\tservletResponse = (HttpServletResponse) asyncContext.getResponse();\n\t\t\tmockResponse = unwrapResponseIfNecessary(servletResponse);\n\t\t}\n\t\telse {\n\t\t\tmockResponse = new MockHttpServletResponse();\n\t\t\tservletResponse = mockResponse;\n\t\t}\n\n\t\tif (this.defaultResponseCharacterEncoding != null) {\n\t\t\tmockResponse.setDefaultCharacterEncoding(this.defaultResponseCharacterEncoding.name());\n\t\t}\n\n\t\tif (requestBuilder instanceof SmartRequestBuilder smartRequestBuilder) {\n\t\t\trequest = smartRequestBuilder.postProcessRequest(request);\n\t\t}\n\n\t\tMvcResult mvcResult = new DefaultMvcResult(request, mockResponse);\n\t\trequest.setAttribute(MVC_RESULT_ATTRIBUTE, mvcResult);\n\n\t\tRequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();\n\t\tRequestContextHolder.setRequestAttributes(new ServletRequestAttributes(request, servletResponse));\n\n\t\tMockFilterChain filterChain = new MockFilterChain(this.servlet, this.filters);\n\t\tfilterChain.doFilter(request, servletResponse);\n\n\t\tif (DispatcherType.ASYNC.equals(request.getDispatcherType()) &&\n\t\t\t\tasyncContext != null && !request.isAsyncStarted()) {\n\t\t\tasyncContext.complete();\n\t\t}\n\n\t\tapplyDefaultResultActions(mvcResult);\n\t\tRequestContextHolder.setRequestAttributes(previousAttributes);\n\n\t\treturn new ResultActions() {\n\t\t\t@Override\n\t\t\tpublic ResultActions andExpect(ResultMatcher matcher) throws Exception {\n\t\t\t\tmatcher.match(mvcResult);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic ResultActions andDo(ResultHandler handler) throws Exception {\n\t\t\t\thandler.handle(mvcResult);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic MvcResult andReturn() {\n\t\t\t\treturn mvcResult;\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate MockHttpServletResponse unwrapResponseIfNecessary(ServletResponse servletResponse) {\n\t\twhile (servletResponse instanceof HttpServletResponseWrapper wrapper) {\n\t\t\tservletResponse = wrapper.getResponse();\n\t\t}\n\t\tAssert.isInstanceOf(MockHttpServletResponse.class, servletResponse);\n\t\treturn (MockHttpServletResponse) servletResponse;\n\t}\n\n\tprivate void applyDefaultResultActions(MvcResult mvcResult) throws Exception {\n\t\tfor (ResultHandler handler : this.defaultResultHandlers) {\n\t\t\thandler.handle(mvcResult);\n\t\t}\n\t\tfor (ResultMatcher matcher : this.defaultResultMatchers) {\n\t\t\tmatcher.match(mvcResult);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.test.web.servlet.MockMvc#andDo(handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "ResultActions",
    "signature": "public ResultActions andDo(ResultHandler handler)",
    "source_code": "\t\t\tpublic ResultActions andDo(ResultHandler handler) throws Exception {\n\t\t\t\thandler.handle(mvcResult);\n\t\t\t\treturn this;\n\t\t\t}"
  },
  "org.springframework.test.web.servlet.MockMvc#andExpect(matcher)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "ResultActions",
    "signature": "public ResultActions andExpect(ResultMatcher matcher)",
    "source_code": "\t\t\tpublic ResultActions andExpect(ResultMatcher matcher) throws Exception {\n\t\t\t\tmatcher.match(mvcResult);\n\t\t\t\treturn this;\n\t\t\t}"
  },
  "org.springframework.test.web.servlet.MockMvc#andReturn()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "MvcResult",
    "signature": "public MvcResult andReturn()",
    "source_code": "\t\t\tpublic MvcResult andReturn() {\n\t\t\t\treturn mvcResult;\n\t\t\t}"
  },
  "org.springframework.test.web.servlet.MockMvc#getDispatcherServlet()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the underlying {@link DispatcherServlet} instance that this\n\t * {@code MockMvc} was initialized with.\n\t * <p>This is intended for use in custom request processing scenario where a\n\t * request handling component happens to delegate to the {@code DispatcherServlet}\n\t * at runtime and therefore needs to be injected with it.\n\t * <p>For most processing scenarios, simply use {@link MockMvc#perform},\n\t * or if you need to configure the {@code DispatcherServlet}, provide a\n\t * {@link DispatcherServletCustomizer} to the {@code MockMvcBuilder}.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "DispatcherServlet",
    "signature": "public DispatcherServlet getDispatcherServlet()",
    "source_code": "\tpublic DispatcherServlet getDispatcherServlet() {\n\t\treturn this.servlet;\n\t}"
  },
  "org.springframework.test.web.servlet.MockMvc#perform(requestBuilder)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a request and return a type that allows chaining further\n\t * actions, such as asserting expectations, on the result.\n\t * @param requestBuilder used to prepare the request to execute;\n\t * see static factory methods in\n\t * {@link org.springframework.test.web.servlet.request.MockMvcRequestBuilders}\n\t * @return an instance of {@link ResultActions} (never {@code null})\n\t * @see org.springframework.test.web.servlet.request.MockMvcRequestBuilders\n\t * @see org.springframework.test.web.servlet.result.MockMvcResultMatchers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestBuilder"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "ResultActions",
    "signature": "public ResultActions perform(RequestBuilder requestBuilder)",
    "source_code": "\tpublic ResultActions perform(RequestBuilder requestBuilder) throws Exception {\n\t\tif (this.defaultRequestBuilder != null && requestBuilder instanceof Mergeable mergeable) {\n\t\t\trequestBuilder = (RequestBuilder) mergeable.merge(this.defaultRequestBuilder);\n\t\t}\n\n\t\tMockHttpServletRequest request = requestBuilder.buildRequest(this.servletContext);\n\n\t\tAsyncContext asyncContext = request.getAsyncContext();\n\t\tMockHttpServletResponse mockResponse;\n\t\tHttpServletResponse servletResponse;\n\t\tif (asyncContext != null) {\n\t\t\tservletResponse = (HttpServletResponse) asyncContext.getResponse();\n\t\t\tmockResponse = unwrapResponseIfNecessary(servletResponse);\n\t\t}\n\t\telse {\n\t\t\tmockResponse = new MockHttpServletResponse();\n\t\t\tservletResponse = mockResponse;\n\t\t}\n\n\t\tif (this.defaultResponseCharacterEncoding != null) {\n\t\t\tmockResponse.setDefaultCharacterEncoding(this.defaultResponseCharacterEncoding.name());\n\t\t}\n\n\t\tif (requestBuilder instanceof SmartRequestBuilder smartRequestBuilder) {\n\t\t\trequest = smartRequestBuilder.postProcessRequest(request);\n\t\t}\n\n\t\tMvcResult mvcResult = new DefaultMvcResult(request, mockResponse);\n\t\trequest.setAttribute(MVC_RESULT_ATTRIBUTE, mvcResult);\n\n\t\tRequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();\n\t\tRequestContextHolder.setRequestAttributes(new ServletRequestAttributes(request, servletResponse));\n\n\t\tMockFilterChain filterChain = new MockFilterChain(this.servlet, this.filters);\n\t\tfilterChain.doFilter(request, servletResponse);\n\n\t\tif (DispatcherType.ASYNC.equals(request.getDispatcherType()) &&\n\t\t\t\tasyncContext != null && !request.isAsyncStarted()) {\n\t\t\tasyncContext.complete();\n\t\t}\n\n\t\tapplyDefaultResultActions(mvcResult);\n\t\tRequestContextHolder.setRequestAttributes(previousAttributes);\n\n\t\treturn new ResultActions() {\n\t\t\t@Override\n\t\t\tpublic ResultActions andExpect(ResultMatcher matcher) throws Exception {\n\t\t\t\tmatcher.match(mvcResult);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic ResultActions andDo(ResultHandler handler) throws Exception {\n\t\t\t\thandler.handle(mvcResult);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic MvcResult andReturn() {\n\t\t\t\treturn mvcResult;\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.client.MockMvcHttpConnector": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Connector that handles requests by invoking a {@link MockMvc} rather than\n * making actual requests over HTTP.\n *\n * @author Rossen Stoyanchev\n * @since 5.3\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "signature": "public class MockMvcHttpConnector",
    "source_code": "public class MockMvcHttpConnector implements ClientHttpConnector {\n\n\tprivate static final DefaultPartHttpMessageReader MULTIPART_READER = new DefaultPartHttpMessageReader();\n\n\tprivate static final Duration TIMEOUT = Duration.ofSeconds(5);\n\n\n\tprivate final MockMvc mockMvc;\n\n\n\tpublic MockMvcHttpConnector(MockMvc mockMvc) {\n\t\tthis.mockMvc = mockMvc;\n\t}\n\n\n\t@Override\n\tpublic Mono<ClientHttpResponse> connect(\n\t\t\tHttpMethod method, URI uri, Function<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n\n\t\tRequestBuilder requestBuilder = adaptRequest(method, uri, requestCallback);\n\t\ttry {\n\t\t\tMvcResult mvcResult = this.mockMvc.perform(requestBuilder).andReturn();\n\t\t\tif (mvcResult.getRequest().isAsyncStarted()) {\n\t\t\t\tmvcResult.getAsyncResult();\n\t\t\t\tmvcResult = this.mockMvc.perform(asyncDispatch(mvcResult)).andReturn();\n\t\t\t}\n\t\t\treturn Mono.just(adaptResponse(mvcResult));\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t}\n\n\tprivate RequestBuilder adaptRequest(\n\t\t\tHttpMethod httpMethod, URI uri, Function<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n\n\t\tMockClientHttpRequest httpRequest = new MockClientHttpRequest(httpMethod, uri);\n\n\t\tAtomicReference<byte[]> contentRef = new AtomicReference<>();\n\t\thttpRequest.setWriteHandler(dataBuffers ->\n\t\t\t\tDataBufferUtils.join(dataBuffers)\n\t\t\t\t\t\t.doOnNext(buffer -> {\n\t\t\t\t\t\t\tbyte[] bytes = new byte[buffer.readableByteCount()];\n\t\t\t\t\t\t\tbuffer.read(bytes);\n\t\t\t\t\t\t\tDataBufferUtils.release(buffer);\n\t\t\t\t\t\t\tcontentRef.set(bytes);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then());\n\n\t\t// Initialize the client request\n\t\trequestCallback.apply(httpRequest).block(TIMEOUT);\n\n\t\tMockHttpServletRequestBuilder requestBuilder =\n\t\t\t\tinitRequestBuilder(httpMethod, uri, httpRequest, contentRef.get());\n\n\t\trequestBuilder.headers(httpRequest.getHeaders());\n\t\tfor (List<HttpCookie> cookies : httpRequest.getCookies().values()) {\n\t\t\tfor (HttpCookie cookie : cookies) {\n\t\t\t\trequestBuilder.cookie(new Cookie(cookie.getName(), cookie.getValue()));\n\t\t\t}\n\t\t}\n\n\t\treturn requestBuilder;\n\t}\n\n\tprivate MockHttpServletRequestBuilder initRequestBuilder(\n\t\t\tHttpMethod httpMethod, URI uri, MockClientHttpRequest httpRequest, @Nullable byte[] bytes) {\n\n\t\tString contentType = httpRequest.getHeaders().getFirst(HttpHeaders.CONTENT_TYPE);\n\t\tif (!StringUtils.startsWithIgnoreCase(contentType, \"multipart/\")) {\n\t\t\tMockHttpServletRequestBuilder requestBuilder = MockMvcRequestBuilders.request(httpMethod, uri);\n\t\t\tif (!ObjectUtils.isEmpty(bytes)) {\n\t\t\t\trequestBuilder.content(bytes);\n\t\t\t}\n\t\t\treturn requestBuilder;\n\t\t}\n\n\t\t// Parse the multipart request in order to adapt to Servlet Part's\n\t\tMockMultipartHttpServletRequestBuilder requestBuilder = MockMvcRequestBuilders.multipart(httpMethod, uri);\n\n\t\tAssert.notNull(bytes, \"No multipart content\");\n\t\tReactiveHttpInputMessage inputMessage = MockServerHttpRequest.post(uri.toString())\n\t\t\t\t.headers(httpRequest.getHeaders())\n\t\t\t\t.body(Mono.just(DefaultDataBufferFactory.sharedInstance.wrap(bytes)));\n\n\t\tMULTIPART_READER.read(ResolvableType.forClass(Part.class), inputMessage, Collections.emptyMap())\n\t\t\t\t.flatMap(part ->\n\t\t\t\t\t\tDataBufferUtils.join(part.content())\n\t\t\t\t\t\t\t\t.doOnNext(buffer -> {\n\t\t\t\t\t\t\t\t\tbyte[] partBytes = new byte[buffer.readableByteCount()];\n\t\t\t\t\t\t\t\t\tbuffer.read(partBytes);\n\t\t\t\t\t\t\t\t\tDataBufferUtils.release(buffer);\n\n\t\t\t\t\t\t\t\t\t// Adapt to jakarta.servlet.http.Part...\n\t\t\t\t\t\t\t\t\tMockPart mockPart = (part instanceof FilePart filePart ?\n\t\t\t\t\t\t\t\t\t\t\tnew MockPart(part.name(), filePart.filename(), partBytes) :\n\t\t\t\t\t\t\t\t\t\t\tnew MockPart(part.name(), partBytes));\n\t\t\t\t\t\t\t\t\tmockPart.getHeaders().putAll(part.headers());\n\t\t\t\t\t\t\t\t\trequestBuilder.part(mockPart);\n\t\t\t\t\t\t\t\t}))\n\t\t\t\t.blockLast(TIMEOUT);\n\n\t\treturn requestBuilder;\n\t}\n\n\tprivate MockClientHttpResponse adaptResponse(MvcResult mvcResult) {\n\t\tMockClientHttpResponse clientResponse = new MockMvcServerClientHttpResponse(mvcResult);\n\t\tMockHttpServletResponse servletResponse = mvcResult.getResponse();\n\t\tfor (String header : servletResponse.getHeaderNames()) {\n\t\t\tfor (String value : servletResponse.getHeaders(header)) {\n\t\t\t\tclientResponse.getHeaders().add(header, value);\n\t\t\t}\n\t\t}\n\t\tif (servletResponse.getForwardedUrl() != null) {\n\t\t\tclientResponse.getHeaders().add(\"Forwarded-Url\", servletResponse.getForwardedUrl());\n\t\t}\n\t\tfor (Cookie cookie : servletResponse.getCookies()) {\n\t\t\tResponseCookie httpCookie =\n\t\t\t\t\tResponseCookie.fromClientResponse(cookie.getName(), cookie.getValue())\n\t\t\t\t\t\t\t.maxAge(Duration.ofSeconds(cookie.getMaxAge()))\n\t\t\t\t\t\t\t.domain(cookie.getDomain())\n\t\t\t\t\t\t\t.path(cookie.getPath())\n\t\t\t\t\t\t\t.secure(cookie.getSecure())\n\t\t\t\t\t\t\t.httpOnly(cookie.isHttpOnly())\n\t\t\t\t\t\t\t.build();\n\t\t\tclientResponse.getCookies().add(httpCookie.getName(), httpCookie);\n\t\t}\n\t\tbyte[] bytes = servletResponse.getContentAsByteArray();\n\t\tDefaultDataBuffer dataBuffer = DefaultDataBufferFactory.sharedInstance.wrap(bytes);\n\t\tclientResponse.setBody(Mono.just(dataBuffer));\n\t\treturn clientResponse;\n\t}\n\n\n\tprivate static class MockMvcServerClientHttpResponse\n\t\t\textends MockClientHttpResponse implements MockServerClientHttpResponse {\n\n\t\tprivate final MvcResult mvcResult;\n\n\n\t\tpublic MockMvcServerClientHttpResponse(MvcResult result) {\n\t\t\tsuper(result.getResponse().getStatus());\n\t\t\tthis.mvcResult = new PrintingMvcResult(result);\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getServerResult() {\n\t\t\treturn this.mvcResult;\n\t\t}\n\t}\n\n\n\tprivate static class PrintingMvcResult implements MvcResult {\n\n\t\tprivate final MvcResult mvcResult;\n\n\t\tpublic PrintingMvcResult(MvcResult mvcResult) {\n\t\t\tthis.mvcResult = mvcResult;\n\t\t}\n\n\t\t@Override\n\t\tpublic MockHttpServletRequest getRequest() {\n\t\t\treturn this.mvcResult.getRequest();\n\t\t}\n\n\t\t@Override\n\t\tpublic MockHttpServletResponse getResponse() {\n\t\t\treturn this.mvcResult.getResponse();\n\t\t}\n\n\t\t@Nullable\n\t\t@Override\n\t\tpublic Object getHandler() {\n\t\t\treturn this.mvcResult.getHandler();\n\t\t}\n\n\t\t@Nullable\n\t\t@Override\n\t\tpublic HandlerInterceptor[] getInterceptors() {\n\t\t\treturn this.mvcResult.getInterceptors();\n\t\t}\n\n\t\t@Nullable\n\t\t@Override\n\t\tpublic ModelAndView getModelAndView() {\n\t\t\treturn this.mvcResult.getModelAndView();\n\t\t}\n\n\t\t@Nullable\n\t\t@Override\n\t\tpublic Exception getResolvedException() {\n\t\t\treturn this.mvcResult.getResolvedException();\n\t\t}\n\n\t\t@Override\n\t\tpublic FlashMap getFlashMap() {\n\t\t\treturn this.mvcResult.getFlashMap();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getAsyncResult() {\n\t\t\treturn this.mvcResult.getAsyncResult();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getAsyncResult(long timeToWait) {\n\t\t\treturn this.mvcResult.getAsyncResult(timeToWait);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tStringWriter writer = new StringWriter();\n\t\t\ttry {\n\t\t\t\tMockMvcResultHandlers.print(writer).handle(this);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\twriter.append(\"Unable to format \")\n\t\t\t\t\t\t.append(String.valueOf(this))\n\t\t\t\t\t\t.append(\": \")\n\t\t\t\t\t\t.append(ex.getMessage());\n\t\t\t}\n\t\t\treturn writer.toString();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.test.web.servlet.client.MockMvcHttpConnector#connect(method,uri,ClientHttpRequest,requestCallback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uri",
      "ClientHttpRequest",
      "requestCallback"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "Mono<ClientHttpResponse>",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri, Function<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect("
  },
  "org.springframework.test.web.servlet.client.MockMvcHttpConnector#getAsyncResult()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "Object",
    "signature": "public Object getAsyncResult()",
    "source_code": "\t\tpublic Object getAsyncResult() {\n\t\t\treturn this.mvcResult.getAsyncResult();\n\t\t}"
  },
  "org.springframework.test.web.servlet.client.MockMvcHttpConnector#getAsyncResult(timeToWait)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeToWait"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "Object",
    "signature": "public Object getAsyncResult(long timeToWait)",
    "source_code": "\t\tpublic Object getAsyncResult(long timeToWait) {\n\t\t\treturn this.mvcResult.getAsyncResult(timeToWait);\n\t\t}"
  },
  "org.springframework.test.web.servlet.client.MockMvcHttpConnector#getFlashMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "FlashMap",
    "signature": "public FlashMap getFlashMap()",
    "source_code": "\t\tpublic FlashMap getFlashMap() {\n\t\t\treturn this.mvcResult.getFlashMap();\n\t\t}"
  },
  "org.springframework.test.web.servlet.client.MockMvcHttpConnector#getHandler()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "Object",
    "signature": "public Object getHandler()",
    "source_code": "\t\tpublic Object getHandler() {\n\t\t\treturn this.mvcResult.getHandler();\n\t\t}"
  },
  "org.springframework.test.web.servlet.client.MockMvcHttpConnector#getInterceptors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "HandlerInterceptor[]",
    "signature": "public HandlerInterceptor[] getInterceptors()",
    "source_code": "\t\tpublic HandlerInterceptor[] getInterceptors() {\n\t\t\treturn this.mvcResult.getInterceptors();\n\t\t}"
  },
  "org.springframework.test.web.servlet.client.MockMvcHttpConnector#getModelAndView()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView getModelAndView()",
    "source_code": "\t\tpublic ModelAndView getModelAndView() {\n\t\t\treturn this.mvcResult.getModelAndView();\n\t\t}"
  },
  "org.springframework.test.web.servlet.client.MockMvcHttpConnector#getRequest()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "MockHttpServletRequest",
    "signature": "public MockHttpServletRequest getRequest()",
    "source_code": "\t\tpublic MockHttpServletRequest getRequest() {\n\t\t\treturn this.mvcResult.getRequest();\n\t\t}"
  },
  "org.springframework.test.web.servlet.client.MockMvcHttpConnector#getResolvedException()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "Exception",
    "signature": "public Exception getResolvedException()",
    "source_code": "\t\tpublic Exception getResolvedException() {\n\t\t\treturn this.mvcResult.getResolvedException();\n\t\t}"
  },
  "org.springframework.test.web.servlet.client.MockMvcHttpConnector#getResponse()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "MockHttpServletResponse",
    "signature": "public MockHttpServletResponse getResponse()",
    "source_code": "\t\tpublic MockHttpServletResponse getResponse() {\n\t\t\treturn this.mvcResult.getResponse();\n\t\t}"
  },
  "org.springframework.test.web.servlet.client.MockMvcHttpConnector#getServerResult()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "Object",
    "signature": "public Object getServerResult()",
    "source_code": "\t\tpublic Object getServerResult() {\n\t\t\treturn this.mvcResult;\n\t\t}"
  },
  "org.springframework.test.web.servlet.client.MockMvcHttpConnector#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\tStringWriter writer = new StringWriter();\n\t\t\ttry {\n\t\t\t\tMockMvcResultHandlers.print(writer).handle(this);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\twriter.append(\"Unable to format \")\n\t\t\t\t\t\t.append(String.valueOf(this))\n\t\t\t\t\t\t.append(\": \")\n\t\t\t\t\t\t.append(ex.getMessage());\n\t\t\t}\n\t\t\treturn writer.toString();\n\t\t}"
  },
  "org.springframework.test.web.servlet.client.MockMvcWebTestClient": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * The main class for testing Spring MVC applications via {@link WebTestClient}\n * with {@link MockMvc} for server request handling.\n *\n * <p>Provides static factory methods and specs to initialize {@code MockMvc}\n * to which the {@code WebTestClient} connects to. For example:\n * <pre class=\"code\">\n * WebTestClient client = MockMvcWebTestClient.bindToController(myController)\n *         .controllerAdvice(myControllerAdvice)\n *         .validator(myValidator)\n *         .build()\n * </pre>\n *\n * <p>The client itself can also be configured. For example:\n * <pre class=\"code\">\n * WebTestClient client = MockMvcWebTestClient.bindToController(myController)\n *         .validator(myValidator)\n *         .configureClient()\n *         .baseUrl(\"/path\")\n *         .build();\n * </pre>\n *\n * @author Rossen Stoyanchev\n * @since 5.3\n */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public interface MockMvcWebTestClient",
    "source_code": "public interface MockMvcWebTestClient {\n\n\t/**\n\t * Begin creating a {@link WebTestClient} by providing the {@code @Controller}\n\t * instance(s) to handle requests with.\n\t * <p>Internally this is delegated to and equivalent to using\n\t * {@link org.springframework.test.web.servlet.setup.MockMvcBuilders#standaloneSetup(Object...)}.\n\t * to initialize {@link MockMvc}.\n\t */\n\tstatic ControllerSpec bindToController(Object... controllers) {\n\t\treturn new StandaloneMockMvcSpec(controllers);\n\t}\n\n\t/**\n\t * Begin creating a {@link WebTestClient} by providing a\n\t * {@link WebApplicationContext} with Spring MVC infrastructure and\n\t * controllers.\n\t * <p>Internally this is delegated to and equivalent to using\n\t * {@link org.springframework.test.web.servlet.setup.MockMvcBuilders#webAppContextSetup(WebApplicationContext)}\n\t * to initialize {@code MockMvc}.\n\t */\n\tstatic MockMvcServerSpec<?> bindToApplicationContext(WebApplicationContext context) {\n\t\treturn new ApplicationContextMockMvcSpec(context);\n\t}\n\n\t/**\n\t * Begin creating a {@link WebTestClient} by providing an already\n\t * initialized {@link MockMvc} instance to use as the server.\n\t */\n\tstatic WebTestClient.Builder bindTo(MockMvc mockMvc) {\n\t\tClientHttpConnector connector = new MockMvcHttpConnector(mockMvc);\n\t\treturn WebTestClient.bindToServer(connector);\n\t}\n\n\t/**\n\t * This method can be used to apply further assertions on a given\n\t * {@link ExchangeResult} based the state of the server response.\n\t * <p>Normally {@link WebTestClient} is used to assert the client response\n\t * including HTTP status, headers, and body. That is all that is available\n\t * when making a live request over HTTP. However when the server is\n\t * {@link MockMvc}, many more assertions are possible against the server\n\t * response, e.g. model attributes, flash attributes, etc.\n\t *\n\t * <p>Example:\n\t * <pre class=\"code\">\n\t * EntityExchangeResult&lt;Void&gt; result =\n\t * \t\twebTestClient.post().uri(\"/people/123\")\n\t * \t\t\t\t.exchange()\n\t * \t\t\t\t.expectStatus().isFound()\n\t * \t\t\t\t.expectHeader().location(\"/persons/Joe\")\n\t * \t\t\t\t.expectBody().isEmpty();\n\t *\n\t * MockMvcWebTestClient.resultActionsFor(result)\n\t * \t\t.andExpect(model().size(1))\n\t * \t\t.andExpect(model().attributeExists(\"name\"))\n\t * \t\t.andExpect(flash().attributeCount(1))\n\t * \t\t.andExpect(flash().attribute(\"message\", \"success!\"));\n\t * </pre>\n\t * <p>Note: this method works only if the {@link WebTestClient} used to\n\t * perform the request was initialized through one of bind method in this\n\t * class, and therefore requests are handled by {@link MockMvc}.\n\t */\n\tstatic ResultActions resultActionsFor(ExchangeResult exchangeResult) {\n\t\tObject serverResult = exchangeResult.getMockServerResult();\n\t\tif (!(serverResult instanceof MvcResult mvcResult)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Result from mock server exchange must be an instance of MvcResult instead of \" +\n\t\t\t\t\t\t\t(serverResult != null ? serverResult.getClass().getName() : \"null\"));\n\t\t}\n\t\treturn new ResultActions() {\n\t\t\t@Override\n\t\t\tpublic ResultActions andExpect(ResultMatcher matcher) throws Exception {\n\t\t\t\tmatcher.match(mvcResult);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic ResultActions andDo(ResultHandler handler) throws Exception {\n\t\t\t\thandler.handle(mvcResult);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic MvcResult andReturn() {\n\t\t\t\treturn mvcResult;\n\t\t\t}\n\t\t};\n\t}\n\n\n\t/**\n\t * Base specification for configuring {@link MockMvc}, and a simple facade\n\t * around {@link ConfigurableMockMvcBuilder}.\n\t *\n\t * @param <B> a self reference to the builder type\n\t */\n\tinterface MockMvcServerSpec<B extends MockMvcServerSpec<B>> {\n\n\t\t/**\n\t\t * Add a global filter.\n\t\t * <p>This is delegated to\n\t\t * {@link ConfigurableMockMvcBuilder#addFilters(Filter...)}.\n\t\t */\n\t\t<T extends B> T filters(Filter... filters);\n\n\t\t/**\n\t\t * Add a filter for specific URL patterns.\n\t\t * <p>This is delegated to\n\t\t * {@link ConfigurableMockMvcBuilder#addFilter(Filter, String...)}.\n\t\t */\n\t\t<T extends B> T filter(Filter filter, String... urlPatterns);\n\n\t\t/**\n\t\t * Define default request properties that should be merged into all\n\t\t * performed requests such that input from the client request override\n\t\t * the default properties defined here.\n\t\t * <p>This is delegated to\n\t\t * {@link ConfigurableMockMvcBuilder#defaultRequest(RequestBuilder)}.\n\t\t */\n\t\t<T extends B> T defaultRequest(RequestBuilder requestBuilder);\n\n\t\t/**\n\t\t * Define a global expectation that should <em>always</em> be applied to\n\t\t * every response.\n\t\t * <p>This is delegated to\n\t\t * {@link ConfigurableMockMvcBuilder#alwaysExpect(ResultMatcher)}.\n\t\t */\n\t\t<T extends B> T alwaysExpect(ResultMatcher resultMatcher);\n\n\t\t/**\n\t\t * Whether to handle HTTP OPTIONS requests.\n\t\t * <p>This is delegated to\n\t\t * {@link ConfigurableMockMvcBuilder#dispatchOptions(boolean)}.\n\t\t */\n\t\t<T extends B> T dispatchOptions(boolean dispatchOptions);\n\n\t\t/**\n\t\t * Allow customization of {@code DispatcherServlet}.\n\t\t * <p>This is delegated to\n\t\t * {@link ConfigurableMockMvcBuilder#addDispatcherServletCustomizer(DispatcherServletCustomizer)}.\n\t\t */\n\t\t<T extends B> T dispatcherServletCustomizer(DispatcherServletCustomizer customizer);\n\n\t\t/**\n\t\t * Add a {@code MockMvcConfigurer} that automates MockMvc setup.\n\t\t * <p>This is delegated to\n\t\t * {@link ConfigurableMockMvcBuilder#apply(MockMvcConfigurer)}.\n\t\t */\n\t\t<T extends B> T apply(MockMvcConfigurer configurer);\n\n\t\t/**\n\t\t * Proceed to configure and build the test client.\n\t\t */\n\t\tWebTestClient.Builder configureClient();\n\n\t\t/**\n\t\t * Shortcut to build the test client.\n\t\t */\n\t\tWebTestClient build();\n\t}\n\n\n\t/**\n\t * Specification for configuring {@link MockMvc} to test one or more\n\t * controllers directly, and a simple facade around\n\t * {@link StandaloneMockMvcBuilder}.\n\t */\n\tinterface ControllerSpec extends MockMvcServerSpec<ControllerSpec> {\n\n\t\t/**\n\t\t * Register {@link org.springframework.web.bind.annotation.ControllerAdvice}\n\t\t * <p>This is delegated to\n\t\t * {@link StandaloneMockMvcBuilder#setControllerAdvice(Object...)}.\n\t\t */\n\t\tControllerSpec controllerAdvice(Object... controllerAdvice);\n\n\t\t/**\n\t\t * Set the message converters to use.\n\t\t * <p>This is delegated to\n\t\t * {@link StandaloneMockMvcBuilder#setMessageConverters(HttpMessageConverter[])}.\n\t\t */\n\t\tControllerSpec messageConverters(HttpMessageConverter<?>... messageConverters);\n\n\t\t/**\n\t\t * Provide a custom {@link Validator}.\n\t\t * <p>This is delegated to\n\t\t * {@link StandaloneMockMvcBuilder#setValidator(Validator)}.\n\t\t */\n\t\tControllerSpec validator(Validator validator);\n\n\t\t/**\n\t\t * Provide a conversion service.\n\t\t * <p>This is delegated to\n\t\t * {@link StandaloneMockMvcBuilder#setConversionService(FormattingConversionService)}.\n\t\t */\n\t\tControllerSpec conversionService(FormattingConversionService conversionService);\n\n\t\t/**\n\t\t * Add global interceptors.\n\t\t * <p>This is delegated to\n\t\t * {@link StandaloneMockMvcBuilder#addInterceptors(HandlerInterceptor...)}.\n\t\t */\n\t\tControllerSpec interceptors(HandlerInterceptor... interceptors);\n\n\t\t/**\n\t\t * Add interceptors for specific patterns.\n\t\t * <p>This is delegated to\n\t\t * {@link StandaloneMockMvcBuilder#addMappedInterceptors(String[], HandlerInterceptor...)}.\n\t\t */\n\t\tControllerSpec mappedInterceptors(\n\t\t\t\t@Nullable String[] pathPatterns, HandlerInterceptor... interceptors);\n\n\t\t/**\n\t\t * Set a ContentNegotiationManager.\n\t\t * <p>This is delegated to\n\t\t * {@link StandaloneMockMvcBuilder#setContentNegotiationManager(ContentNegotiationManager)}.\n\t\t */\n\t\tControllerSpec contentNegotiationManager(ContentNegotiationManager manager);\n\n\t\t/**\n\t\t * Specify the timeout value for async execution.\n\t\t * <p>This is delegated to\n\t\t * {@link StandaloneMockMvcBuilder#setAsyncRequestTimeout(long)}.\n\t\t */\n\t\tControllerSpec asyncRequestTimeout(long timeout);\n\n\t\t/**\n\t\t * Provide custom argument resolvers.\n\t\t * <p>This is delegated to\n\t\t * {@link StandaloneMockMvcBuilder#setCustomArgumentResolvers(HandlerMethodArgumentResolver...)}.\n\t\t */\n\t\tControllerSpec customArgumentResolvers(HandlerMethodArgumentResolver... argumentResolvers);\n\n\t\t/**\n\t\t * Provide custom return value handlers.\n\t\t * <p>This is delegated to\n\t\t * {@link StandaloneMockMvcBuilder#setCustomReturnValueHandlers(HandlerMethodReturnValueHandler...)}.\n\t\t */\n\t\tControllerSpec customReturnValueHandlers(HandlerMethodReturnValueHandler... handlers);\n\n\t\t/**\n\t\t * Set the HandlerExceptionResolver types to use.\n\t\t * <p>This is delegated to\n\t\t * {@link StandaloneMockMvcBuilder#setHandlerExceptionResolvers(HandlerExceptionResolver...)}.\n\t\t */\n\t\tControllerSpec handlerExceptionResolvers(HandlerExceptionResolver... exceptionResolvers);\n\n\t\t/**\n\t\t * Set up view resolution.\n\t\t * <p>This is delegated to\n\t\t * {@link StandaloneMockMvcBuilder#setViewResolvers(ViewResolver...)}.\n\t\t */\n\t\tControllerSpec viewResolvers(ViewResolver... resolvers);\n\n\t\t/**\n\t\t * Set up a single {@link ViewResolver} with a fixed view.\n\t\t * <p>This is delegated to\n\t\t * {@link StandaloneMockMvcBuilder#setSingleView(View)}.\n\t\t */\n\t\tControllerSpec singleView(View view);\n\n\t\t/**\n\t\t * Provide the LocaleResolver to use.\n\t\t * <p>This is delegated to\n\t\t * {@link StandaloneMockMvcBuilder#setLocaleResolver(LocaleResolver)}.\n\t\t */\n\t\tControllerSpec localeResolver(LocaleResolver localeResolver);\n\n\t\t/**\n\t\t * Provide a custom FlashMapManager.\n\t\t * <p>This is delegated to\n\t\t * {@link StandaloneMockMvcBuilder#setFlashMapManager(FlashMapManager)}.\n\t\t */\n\t\tControllerSpec flashMapManager(FlashMapManager flashMapManager);\n\n\t\t/**\n\t\t * Enable URL path matching with parsed\n\t\t * {@link org.springframework.web.util.pattern.PathPattern PathPatterns}.\n\t\t * <p>This is delegated to\n\t\t * {@link StandaloneMockMvcBuilder#setPatternParser(PathPatternParser)}.\n\t\t */\n\t\tControllerSpec patternParser(PathPatternParser parser);\n\n\t\t/**\n\t\t * Whether to match trailing slashes.\n\t\t * <p>This is delegated to\n\t\t * {@link StandaloneMockMvcBuilder#setUseTrailingSlashPatternMatch(boolean)}.\n\t\t * @deprecated as of 6.0, see\n\t\t * {@link PathPatternParser#setMatchOptionalTrailingSeparator(boolean)}\n\t\t */\n\t\t@Deprecated(since = \"6.0\")\n\t\tControllerSpec useTrailingSlashPatternMatch(boolean useTrailingSlashPatternMatch);\n\n\t\t/**\n\t\t * Configure placeholder values to use.\n\t\t * <p>This is delegated to\n\t\t * {@link StandaloneMockMvcBuilder#addPlaceholderValue(String, String)}.\n\t\t */\n\t\tControllerSpec placeholderValue(String name, String value);\n\n\t\t/**\n\t\t * Configure factory for a custom {@link RequestMappingHandlerMapping}.\n\t\t * <p>This is delegated to\n\t\t * {@link StandaloneMockMvcBuilder#setCustomHandlerMapping(Supplier)}.\n\t\t */\n\t\tControllerSpec customHandlerMapping(Supplier<RequestMappingHandlerMapping> factory);\n\t}\n\n}"
  },
  "org.springframework.test.web.servlet.client.MockMvcWebTestClient#andDo(handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "ResultActions",
    "signature": "public ResultActions andDo(ResultHandler handler)",
    "source_code": "\t\t\tpublic ResultActions andDo(ResultHandler handler) throws Exception {\n\t\t\t\thandler.handle(mvcResult);\n\t\t\t\treturn this;\n\t\t\t}"
  },
  "org.springframework.test.web.servlet.client.MockMvcWebTestClient#andExpect(matcher)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "ResultActions",
    "signature": "public ResultActions andExpect(ResultMatcher matcher)",
    "source_code": "\t\t\tpublic ResultActions andExpect(ResultMatcher matcher) throws Exception {\n\t\t\t\tmatcher.match(mvcResult);\n\t\t\t\treturn this;\n\t\t\t}"
  },
  "org.springframework.test.web.servlet.client.MockMvcWebTestClient#andReturn()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "MvcResult",
    "signature": "public MvcResult andReturn()",
    "source_code": "\t\t\tpublic MvcResult andReturn() {\n\t\t\t\treturn mvcResult;\n\t\t\t}"
  },
  "org.springframework.test.web.servlet.htmlunit.<unknown>#buildRequest(servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "MockHttpServletRequest",
    "signature": "public MockHttpServletRequest buildRequest(ServletContext servletContext)",
    "source_code": "\tpublic MockHttpServletRequest buildRequest(ServletContext servletContext) {\n\t\tString httpMethod = this.webRequest.getHttpMethod().name();\n\t\tUriComponents uri = UriComponentsBuilder.fromUriString(this.webRequest.getUrl().toExternalForm()).build();\n\n\t\tMockHttpServletRequest request = new HtmlUnitMockHttpServletRequest(\n\t\t\t\tservletContext, httpMethod, (uri.getPath() != null ? uri.getPath() : \"\"));\n\n\t\tparent(request, this.parentBuilder);\n\n\t\trequest.setProtocol(\"HTTP/1.1\");\n\t\trequest.setScheme(uri.getScheme() != null ? uri.getScheme() : \"\");\n\t\trequest.setServerName(uri.getHost() != null ? uri.getHost() : \"\");  // needs to be first for additional headers\n\t\tports(uri, request);\n\t\tauthType(request);\n\t\tcontextPath(request, uri);\n\t\tservletPath(uri, request);\n\t\trequest.setPathInfo(null);\n\n\t\tCharset charset = this.webRequest.getCharset();\n\t\tcharset = (charset != null ? charset : StandardCharsets.ISO_8859_1);\n\t\trequest.setCharacterEncoding(charset.name());\n\t\tcontent(request, charset);\n\t\tcontentType(request);\n\n\t\tcookies(request);\n\t\tthis.webRequest.getAdditionalHeaders().forEach(request::addHeader);\n\t\tlocales(request);\n\t\tparams(request);\n\t\trequest.setQueryString(uri.getQuery());\n\n\t\treturn postProcess(request);\n\t}"
  },
  "org.springframework.test.web.servlet.htmlunit.<unknown>#getSession(create)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "create"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "HttpSession",
    "signature": "public HttpSession getSession(boolean create)",
    "source_code": "\t\tpublic HttpSession getSession(boolean create) {\n\t\t\tHttpSession session = super.getSession(false);\n\t\t\tif (session == null && create) {\n\t\t\t\tHtmlUnitMockHttpSession newSession = new HtmlUnitMockHttpSession(this);\n\t\t\t\tsetSession(newSession);\n\t\t\t\tnewSession.setNew(true);\n\t\t\t\tString sessionid = newSession.getId();\n\t\t\t\tsynchronized (HtmlUnitRequestBuilder.this.sessions) {\n\t\t\t\t\tHtmlUnitRequestBuilder.this.sessions.put(sessionid, newSession);\n\t\t\t\t}\n\t\t\t\taddSessionCookie(this, sessionid);\n\t\t\t\tsession = newSession;\n\t\t\t}\n\t\t\treturn session;\n\t\t}"
  },
  "org.springframework.test.web.servlet.htmlunit.<unknown>#invalidate()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 492
    },
    "return": "void",
    "signature": "public void invalidate()",
    "source_code": "\t\tpublic void invalidate() {\n\t\t\tsuper.invalidate();\n\t\t\tsynchronized (HtmlUnitRequestBuilder.this.sessions) {\n\t\t\t\tHtmlUnitRequestBuilder.this.sessions.remove(getId());\n\t\t\t}\n\t\t\tremoveSessionCookie(this.request, getId());\n\t\t}"
  },
  "org.springframework.test.web.servlet.htmlunit.<unknown>#isMergeEnabled()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the contextPath to be used.\n\t * <p>The value may be null in which case the first path segment of the\n\t * URL is turned into the contextPath. Otherwise it must conform to\n\t * {@link HttpServletRequest#getContextPath()} which states it can be\n\t * an empty string, or it must start with a \"/\" and not end with a \"/\".\n\t * @param contextPath a valid contextPath\n\t * @throws IllegalArgumentException if the contextPath is not a valid\n\t * {@link HttpServletRequest#getContextPath()}\n\t */\n\tpublic void setContextPath(@Nullable String contextPath) {\n\t\tMockMvcWebConnection.validateContextPath(contextPath);\n\t\tthis.contextPath = contextPath;\n\t}\n\n\tpublic void setForwardPostProcessor(RequestPostProcessor forwardPostProcessor) {\n\t\tthis.forwardPostProcessor = forwardPostProcessor;\n\t}\n\n\n\t@Override\n\tpublic MockHttpServletRequest buildRequest(ServletContext servletContext) {\n\t\tString httpMethod = this.webRequest.getHttpMethod().name();\n\t\tUriComponents uri = UriComponentsBuilder.fromUriString(this.webRequest.getUrl().toExternalForm()).build();\n\n\t\tMockHttpServletRequest request = new HtmlUnitMockHttpServletRequest(\n\t\t\t\tservletContext, httpMethod, (uri.getPath() != null ? uri.getPath() : \"\"));\n\n\t\tparent(request, this.parentBuilder);\n\n\t\trequest.setProtocol(\"HTTP/1.1\");\n\t\trequest.setScheme(uri.getScheme() != null ? uri.getScheme() : \"\");\n\t\trequest.setServerName(uri.getHost() != null ? uri.getHost() : \"\");  // needs to be first for additional headers\n\t\tports(uri, request);\n\t\tauthType(request);\n\t\tcontextPath(request, uri);\n\t\tservletPath(uri, request);\n\t\trequest.setPathInfo(null);\n\n\t\tCharset charset = this.webRequest.getCharset();\n\t\tcharset = (charset != null ? charset : StandardCharsets.ISO_8859_1);\n\t\trequest.setCharacterEncoding(charset.name());\n\t\tcontent(request, charset);\n\t\tcontentType(request);\n\n\t\tcookies(request);\n\t\tthis.webRequest.getAdditionalHeaders().forEach(request::addHeader);\n\t\tlocales(request);\n\t\tparams(request);\n\t\trequest.setQueryString(uri.getQuery());\n\n\t\treturn postProcess(request);\n\t}\n\n\tprivate void parent(MockHttpServletRequest request, @Nullable RequestBuilder parent) {\n\t\tif (parent == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tMockHttpServletRequest parentRequest = parent.buildRequest(request.getServletContext());\n\n\t\t// session\n\t\tHttpSession parentSession = parentRequest.getSession(false);\n\t\tif (parentSession != null) {\n\t\t\tHttpSession localSession = request.getSession();\n\t\t\tAssert.state(localSession != null, \"No local HttpSession\");\n\t\t\tEnumeration<String> attrNames = parentSession.getAttributeNames();\n\t\t\twhile (attrNames.hasMoreElements()) {\n\t\t\t\tString attrName = attrNames.nextElement();\n\t\t\t\tObject attrValue = parentSession.getAttribute(attrName);\n\t\t\t\tlocalSession.setAttribute(attrName, attrValue);\n\t\t\t}\n\t\t}\n\n\t\t// header\n\t\tEnumeration<String> headerNames = parentRequest.getHeaderNames();\n\t\twhile (headerNames.hasMoreElements()) {\n\t\t\tString attrName = headerNames.nextElement();\n\t\t\tEnumeration<String> attrValues = parentRequest.getHeaders(attrName);\n\t\t\twhile (attrValues.hasMoreElements()) {\n\t\t\t\tString attrValue = attrValues.nextElement();\n\t\t\t\trequest.addHeader(attrName, attrValue);\n\t\t\t}\n\t\t}\n\n\t\t// parameter\n\t\tMap<String, String[]> parentParams = parentRequest.getParameterMap();\n\t\tparentParams.forEach(request::addParameter);\n\n\t\t// cookie\n\t\tCookie[] parentCookies = parentRequest.getCookies();\n\t\tif (!ObjectUtils.isEmpty(parentCookies)) {\n\t\t\trequest.setCookies(parentCookies);\n\t\t}\n\n\t\t// request attribute\n\t\tEnumeration<String> parentAttrNames = parentRequest.getAttributeNames();\n\t\twhile (parentAttrNames.hasMoreElements()) {\n\t\t\tString parentAttrName = parentAttrNames.nextElement();\n\t\t\trequest.setAttribute(parentAttrName, parentRequest.getAttribute(parentAttrName));\n\t\t}\n\t}\n\n\tprivate void ports(UriComponents uriComponents, MockHttpServletRequest request) {\n\t\tint serverPort = uriComponents.getPort();\n\t\trequest.setServerPort(serverPort);\n\t\tif (serverPort == -1) {\n\t\t\tint portConnection = this.webRequest.getUrl().getDefaultPort();\n\t\t\trequest.setLocalPort(serverPort);\n\t\t\trequest.setRemotePort(portConnection);\n\t\t}\n\t\telse {\n\t\t\trequest.setRemotePort(serverPort);\n\t\t}\n\t}\n\n\tprivate void authType(MockHttpServletRequest request) {\n\t\tString authorization = getHeader(\"Authorization\");\n\t\tString[] authSplit = StringUtils.split(authorization, \": \");\n\t\tif (authSplit != null) {\n\t\t\trequest.setAuthType(authSplit[0]);\n\t\t}\n\t}\n\n\t@Nullable\n\tprivate String getHeader(String headerName) {\n\t\treturn this.webRequest.getAdditionalHeaders().get(headerName);\n\t}\n\n\tprivate void contextPath(MockHttpServletRequest request, UriComponents uriComponents) {\n\t\tif (this.contextPath == null) {\n\t\t\tList<String> pathSegments = uriComponents.getPathSegments();\n\t\t\tif (pathSegments.isEmpty()) {\n\t\t\t\trequest.setContextPath(\"\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\trequest.setContextPath(\"/\" + pathSegments.get(0));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString path = uriComponents.getPath();\n\t\t\tAssert.isTrue(path != null && path.startsWith(this.contextPath),\n\t\t\t\t\t() -> \"\\\"\" + uriComponents.getPath() +\n\t\t\t\t\t\t\t\"\\\" should start with context path \\\"\" + this.contextPath + \"\\\"\");\n\t\t\trequest.setContextPath(this.contextPath);\n\t\t}\n\t}\n\n\tprivate void servletPath(UriComponents uriComponents, MockHttpServletRequest request) {\n\t\tString path = uriComponents.getPath();\n\t\tString requestPath = (path != null ? path : \"\");\n\t\tString servletPath = requestPath.substring(request.getContextPath().length());\n\t\tservletPath = UriUtils.decode(servletPath, StandardCharsets.UTF_8);\n\t\trequest.setServletPath(servletPath);\n\t}\n\n\tprivate void content(MockHttpServletRequest request, Charset charset) {\n\t\tString requestBody = this.webRequest.getRequestBody();\n\t\tif (requestBody == null) {\n\t\t\treturn;\n\t\t}\n\t\trequest.setContent(requestBody.getBytes(charset));\n\t}\n\n\tprivate void contentType(MockHttpServletRequest request) {\n\t\tString contentType = getHeader(\"Content-Type\");\n\t\tif (contentType == null) {\n\t\t\tFormEncodingType encodingType = this.webRequest.getEncodingType();\n\t\t\tif (encodingType != null) {\n\t\t\t\tcontentType = encodingType.getName();\n\t\t\t}\n\t\t}\n\t\trequest.setContentType(contentType != null ? contentType : MediaType.ALL_VALUE);\n\t}\n\n\tprivate void cookies(MockHttpServletRequest request) {\n\t\tList<Cookie> cookies = new ArrayList<>();\n\n\t\tString cookieHeaderValue = getHeader(\"Cookie\");\n\t\tif (cookieHeaderValue != null) {\n\t\t\tStringTokenizer tokens = new StringTokenizer(cookieHeaderValue, \"=;\");\n\t\t\twhile (tokens.hasMoreTokens()) {\n\t\t\t\tString cookieName = tokens.nextToken().trim();\n\t\t\t\tAssert.isTrue(tokens.hasMoreTokens(),\n\t\t\t\t\t\t() -> \"Expected value for cookie name '\" + cookieName +\n\t\t\t\t\t\t\t\t\"': full cookie header was [\" + cookieHeaderValue + \"]\");\n\t\t\t\tString cookieValue = tokens.nextToken().trim();\n\t\t\t\tprocessCookie(request, cookies, new Cookie(cookieName, cookieValue));\n\t\t\t}\n\t\t}\n\n\t\tSet<com.gargoylesoftware.htmlunit.util.Cookie> managedCookies = this.webClient.getCookies(this.webRequest.getUrl());\n\t\tfor (com.gargoylesoftware.htmlunit.util.Cookie cookie : managedCookies) {\n\t\t\tprocessCookie(request, cookies, new Cookie(cookie.getName(), cookie.getValue()));\n\t\t}\n\n\t\tCookie[] parentCookies = request.getCookies();\n\t\tif (parentCookies != null) {\n\t\t\tCollections.addAll(cookies, parentCookies);\n\t\t}\n\n\t\tif (!ObjectUtils.isEmpty(cookies)) {\n\t\t\trequest.setCookies(cookies.toArray(new Cookie[0]));\n\t\t}\n\t}\n\n\tprivate void processCookie(MockHttpServletRequest request, List<Cookie> cookies, Cookie cookie) {\n\t\tcookies.add(cookie);\n\t\tif (\"JSESSIONID\".equals(cookie.getName())) {\n\t\t\trequest.setRequestedSessionId(cookie.getValue());\n\t\t\trequest.setSession(httpSession(request, cookie.getValue()));\n\t\t}\n\t}\n\n\tprivate MockHttpSession httpSession(MockHttpServletRequest request, final String sessionid) {\n\t\tMockHttpSession session;\n\t\tsynchronized (this.sessions) {\n\t\t\tsession = this.sessions.get(sessionid);\n\t\t\tif (session == null) {\n\t\t\t\tsession = new HtmlUnitMockHttpSession(request, sessionid);\n\t\t\t\tsession.setNew(true);\n\t\t\t\tsynchronized (this.sessions) {\n\t\t\t\t\tthis.sessions.put(sessionid, session);\n\t\t\t\t}\n\t\t\t\taddSessionCookie(request, sessionid);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsession.setNew(false);\n\t\t\t}\n\t\t}\n\t\treturn session;\n\t}\n\n\tprivate void addSessionCookie(MockHttpServletRequest request, String sessionid) {\n\t\tthis.webClient.getCookieManager().addCookie(createCookie(request, sessionid));\n\t}\n\n\tprivate void removeSessionCookie(MockHttpServletRequest request, String sessionid) {\n\t\tthis.webClient.getCookieManager().removeCookie(createCookie(request, sessionid));\n\t}\n\n\tprivate com.gargoylesoftware.htmlunit.util.Cookie createCookie(MockHttpServletRequest request, String sessionid) {\n\t\treturn new com.gargoylesoftware.htmlunit.util.Cookie(request.getServerName(), \"JSESSIONID\", sessionid,\n\t\t\t\trequest.getContextPath() + \"/\", null, request.isSecure(), true);\n\t}\n\n\tprivate void locales(MockHttpServletRequest request) {\n\t\tString locale = getHeader(\"Accept-Language\");\n\t\tif (locale == null) {\n\t\t\trequest.addPreferredLocale(Locale.getDefault());\n\t\t}\n\t}\n\n\tprivate void params(MockHttpServletRequest request) {\n\t\tfor (NameValuePair param : this.webRequest.getParameters()) {\n\t\t\taddRequestParameter(request, param);\n\t\t}\n\t}\n\n\tprivate void addRequestParameter(MockHttpServletRequest request, NameValuePair param) {\n\t\tif (param instanceof KeyDataPair pair) {\n\t\t\tFile file = pair.getFile();\n\t\t\tMockPart part;\n\t\t\tif (file != null) {\n\t\t\t\tpart = new MockPart(pair.getName(), file.getName(), readAllBytes(file));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Support empty file upload OR file upload via setData().\n\t\t\t\t// For an empty file upload, getValue() returns an empty string, and\n\t\t\t\t// getData() returns null.\n\t\t\t\t// For a file upload via setData(), getData() returns the file data, and\n\t\t\t\t// getValue() returns the file name (if set) or an empty string.\n\t\t\t\tpart = new MockPart(pair.getName(), pair.getValue(), pair.getData());\n\t\t\t}\n\t\t\tMediaType mediaType = (pair.getMimeType() != null ? MediaType.valueOf(pair.getMimeType()) :\n\t\t\t\t\tMediaType.APPLICATION_OCTET_STREAM);\n\t\t\tpart.getHeaders().setContentType(mediaType);\n\t\t\trequest.addPart(part);\n\t\t}\n\t\telse {\n\t\t\trequest.addParameter(param.getName(), param.getValue());\n\t\t}\n\t}\n\n\tprivate byte[] readAllBytes(File file) {\n\t\ttry {\n\t\t\treturn Files.readAllBytes(file.toPath());\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t}\n\n\tprivate MockHttpServletRequest postProcess(MockHttpServletRequest request) {\n\t\tif (this.parentPostProcessor != null) {\n\t\t\trequest = this.parentPostProcessor.postProcessRequest(request);\n\t\t}\n\t\tif (this.forwardPostProcessor != null) {\n\t\t\trequest = this.forwardPostProcessor.postProcessRequest(request);\n\t\t}\n\t\treturn request;\n\t}\n\n\n\t/* Mergeable methods */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 420
    },
    "return": "boolean",
    "signature": "public boolean isMergeEnabled()",
    "source_code": "\tpublic boolean isMergeEnabled() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.test.web.servlet.htmlunit.<unknown>#merge(parent)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parent"
    ],
    "position": {
      "column": 1,
      "line": 425
    },
    "return": "Object",
    "signature": "public Object merge(@Nullable Object parent)",
    "source_code": "\tpublic Object merge(@Nullable Object parent) {\n\t\tif (parent instanceof RequestBuilder requestBuilder) {\n\t\t\tif (parent instanceof MockHttpServletRequestBuilder) {\n\t\t\t\tMockHttpServletRequestBuilder copiedParent = MockMvcRequestBuilders.get(\"/\");\n\t\t\t\tcopiedParent.merge(parent);\n\t\t\t\tthis.parentBuilder = copiedParent;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.parentBuilder = requestBuilder;\n\t\t\t}\n\t\t\tif (parent instanceof SmartRequestBuilder smartRequestBuilder) {\n\t\t\t\tthis.parentPostProcessor = smartRequestBuilder;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.htmlunit.<unknown>#setContextPath(contextPath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the contextPath to be used.\n\t * <p>The value may be null in which case the first path segment of the\n\t * URL is turned into the contextPath. Otherwise it must conform to\n\t * {@link HttpServletRequest#getContextPath()} which states it can be\n\t * an empty string, or it must start with a \"/\" and not end with a \"/\".\n\t * @param contextPath a valid contextPath\n\t * @throws IllegalArgumentException if the contextPath is not a valid\n\t * {@link HttpServletRequest#getContextPath()}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contextPath"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "public void setContextPath(@Nullable String contextPath)",
    "source_code": "\tpublic void setContextPath(@Nullable String contextPath) {\n\t\tMockMvcWebConnection.validateContextPath(contextPath);\n\t\tthis.contextPath = contextPath;\n\t}"
  },
  "org.springframework.test.web.servlet.htmlunit.<unknown>#setForwardPostProcessor(forwardPostProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "forwardPostProcessor"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "void",
    "signature": "public void setForwardPostProcessor(RequestPostProcessor forwardPostProcessor)",
    "source_code": "\tpublic void setForwardPostProcessor(RequestPostProcessor forwardPostProcessor) {\n\t\tthis.forwardPostProcessor = forwardPostProcessor;\n\t}"
  },
  "org.springframework.test.web.servlet.result.HandlerResultMatchers": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Factory for assertions on the selected handler or handler method.\n *\n * <p>An instance of this class is typically accessed via\n * {@link MockMvcResultMatchers#handler}.\n *\n * <p><strong>Note:</strong> Expectations that assert the controller method\n * used to process the request work only for requests processed with\n * {@link RequestMappingHandlerMapping} and {@link RequestMappingHandlerAdapter}\n * which is used by default with the Spring MVC Java config and XML namespace.\n *\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 3.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public class HandlerResultMatchers",
    "source_code": "public class HandlerResultMatchers {\n\n\t/**\n\t * Protected constructor.\n\t * Use {@link MockMvcResultMatchers#handler()}.\n\t */\n\tprotected HandlerResultMatchers() {\n\t}\n\n\n\t/**\n\t * Assert the type of the handler that processed the request.\n\t */\n\tpublic ResultMatcher handlerType(Class<?> type) {\n\t\treturn result -> {\n\t\t\tObject handler = result.getHandler();\n\t\t\tassertNotNull(\"No handler\", handler);\n\t\t\tClass<?> actual = handler.getClass();\n\t\t\tif (handler instanceof HandlerMethod handlerMethod) {\n\t\t\t\tactual = handlerMethod.getBeanType();\n\t\t\t}\n\t\t\tassertEquals(\"Handler type\", type, ClassUtils.getUserClass(actual));\n\t\t};\n\t}\n\n\t/**\n\t * Assert the controller method used to process the request.\n\t * <p>The expected method is specified through a \"mock\" controller method\n\t * invocation similar to {@link MvcUriComponentsBuilder#fromMethodCall(Object)}.\n\t * <p>For example, given this controller:\n\t * <pre class=\"code\">\n\t * &#064;RestController\n\t * public class SimpleController {\n\t *\n\t *     &#064;RequestMapping(\"/\")\n\t *     public ResponseEntity&lt;Void&gt; handle() {\n\t *         return ResponseEntity.ok().build();\n\t *     }\n\t * }\n\t * </pre>\n\t * <p>A test that has statically imported {@link MvcUriComponentsBuilder#on}\n\t * can be performed as follows:\n\t * <pre class=\"code\">\n\t * mockMvc.perform(get(\"/\"))\n\t *     .andExpect(handler().methodCall(on(SimpleController.class).handle()));\n\t * </pre>\n\t * @param obj either the value returned from a \"mock\" controller invocation\n\t * or the \"mock\" controller itself after an invocation\n\t */\n\tpublic ResultMatcher methodCall(Object obj) {\n\t\treturn result -> {\n\t\t\tif (!(obj instanceof MethodInvocationInfo invocationInfo)) {\n\t\t\t\tthrow new AssertionError(\"\"\"\n\t\t\t\t\t\tThe supplied object [%s] is not an instance of %s. Ensure \\\n\t\t\t\t\t\tthat you invoke the handler method via MvcUriComponentsBuilder.on().\"\"\"\n\t\t\t\t\t\t\t.formatted(obj, MethodInvocationInfo.class.getName()));\n\t\t\t}\n\t\t\tMethod expected = invocationInfo.getControllerMethod();\n\t\t\tMethod actual = getHandlerMethod(result).getMethod();\n\t\t\tassertEquals(\"Handler method\", expected, actual);\n\t\t};\n\t}\n\n\t/**\n\t * Assert the name of the controller method used to process the request\n\t * using the given Hamcrest {@link Matcher}.\n\t */\n\tpublic ResultMatcher methodName(Matcher<? super String> matcher) {\n\t\treturn result -> {\n\t\t\tHandlerMethod handlerMethod = getHandlerMethod(result);\n\t\t\tassertThat(\"Handler method\", handlerMethod.getMethod().getName(), matcher);\n\t\t};\n\t}\n\n\t/**\n\t * Assert the name of the controller method used to process the request.\n\t */\n\tpublic ResultMatcher methodName(String name) {\n\t\treturn result -> {\n\t\t\tHandlerMethod handlerMethod = getHandlerMethod(result);\n\t\t\tassertEquals(\"Handler method\", name, handlerMethod.getMethod().getName());\n\t\t};\n\t}\n\n\t/**\n\t * Assert the controller method used to process the request.\n\t */\n\tpublic ResultMatcher method(Method method) {\n\t\treturn result -> {\n\t\t\tHandlerMethod handlerMethod = getHandlerMethod(result);\n\t\t\tassertEquals(\"Handler method\", method, handlerMethod.getMethod());\n\t\t};\n\t}\n\n\n\tprivate static HandlerMethod getHandlerMethod(MvcResult result) {\n\t\tObject handler = result.getHandler();\n\t\tassertTrue(\"Not a HandlerMethod: \" + handler, handler instanceof HandlerMethod);\n\t\treturn (HandlerMethod) handler;\n\t}\n\n}"
  },
  "org.springframework.test.web.servlet.result.HandlerResultMatchers#handlerType(type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the type of the handler that processed the request.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher handlerType(Class<?> type)",
    "source_code": "\tpublic ResultMatcher handlerType(Class<?> type) {\n\t\treturn result -> {\n\t\t\tObject handler = result.getHandler();\n\t\t\tassertNotNull(\"No handler\", handler);\n\t\t\tClass<?> actual = handler.getClass();\n\t\t\tif (handler instanceof HandlerMethod handlerMethod) {\n\t\t\t\tactual = handlerMethod.getBeanType();\n\t\t\t}\n\t\t\tassertEquals(\"Handler type\", type, ClassUtils.getUserClass(actual));\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.HandlerResultMatchers#method(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the controller method used to process the request.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher method(Method method)",
    "source_code": "\tpublic ResultMatcher method(Method method) {\n\t\treturn result -> {\n\t\t\tHandlerMethod handlerMethod = getHandlerMethod(result);\n\t\t\tassertEquals(\"Handler method\", method, handlerMethod.getMethod());\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.HandlerResultMatchers#methodCall(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the controller method used to process the request.\n\t * <p>The expected method is specified through a \"mock\" controller method\n\t * invocation similar to {@link MvcUriComponentsBuilder#fromMethodCall(Object)}.\n\t * <p>For example, given this controller:\n\t * <pre class=\"code\">\n\t * &#064;RestController\n\t * public class SimpleController {\n\t *\n\t *     &#064;RequestMapping(\"/\")\n\t *     public ResponseEntity&lt;Void&gt; handle() {\n\t *         return ResponseEntity.ok().build();\n\t *     }\n\t * }\n\t * </pre>\n\t * <p>A test that has statically imported {@link MvcUriComponentsBuilder#on}\n\t * can be performed as follows:\n\t * <pre class=\"code\">\n\t * mockMvc.perform(get(\"/\"))\n\t *     .andExpect(handler().methodCall(on(SimpleController.class).handle()));\n\t * </pre>\n\t * @param obj either the value returned from a \"mock\" controller invocation\n\t * or the \"mock\" controller itself after an invocation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher methodCall(Object obj)",
    "source_code": "\tpublic ResultMatcher methodCall(Object obj) {\n\t\treturn result -> {\n\t\t\tif (!(obj instanceof MethodInvocationInfo invocationInfo)) {\n\t\t\t\tthrow new AssertionError(\"\"\"\n\t\t\t\t\t\tThe supplied object [%s] is not an instance of %s. Ensure \\\n\t\t\t\t\t\tthat you invoke the handler method via MvcUriComponentsBuilder.on().\"\"\"\n\t\t\t\t\t\t\t.formatted(obj, MethodInvocationInfo.class.getName()));\n\t\t\t}\n\t\t\tMethod expected = invocationInfo.getControllerMethod();\n\t\t\tMethod actual = getHandlerMethod(result).getMethod();\n\t\t\tassertEquals(\"Handler method\", expected, actual);\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.HandlerResultMatchers#methodName(matcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the name of the controller method used to process the request\n\t * using the given Hamcrest {@link Matcher}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher methodName(Matcher<? super String> matcher)",
    "source_code": "\tpublic ResultMatcher methodName(Matcher<? super String> matcher) {\n\t\treturn result -> {\n\t\t\tHandlerMethod handlerMethod = getHandlerMethod(result);\n\t\t\tassertThat(\"Handler method\", handlerMethod.getMethod().getName(), matcher);\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.HandlerResultMatchers#methodName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the name of the controller method used to process the request.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher methodName(String name)",
    "source_code": "\tpublic ResultMatcher methodName(String name) {\n\t\treturn result -> {\n\t\t\tHandlerMethod handlerMethod = getHandlerMethod(result);\n\t\t\tassertEquals(\"Handler method\", name, handlerMethod.getMethod().getName());\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.ModelResultMatchers": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Factory for assertions on the model.\n *\n * <p>An instance of this class is typically accessed via\n * {@link MockMvcResultMatchers#model}.\n *\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 3.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "signature": "public class ModelResultMatchers",
    "source_code": "public class ModelResultMatchers {\n\n\t/**\n\t * Protected constructor.\n\t * Use {@link MockMvcResultMatchers#model()}.\n\t */\n\tprotected ModelResultMatchers() {\n\t}\n\n\n\t/**\n\t * Assert a model attribute value with the given Hamcrest {@link Matcher}.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> ResultMatcher attribute(String name, Matcher<? super T> matcher) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tassertThat(\"Model attribute '\" + name + \"'\", (T) mav.getModel().get(name), matcher);\n\t\t};\n\t}\n\n\t/**\n\t * Assert a model attribute value.\n\t */\n\tpublic ResultMatcher attribute(String name, @Nullable Object value) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tassertEquals(\"Model attribute '\" + name + \"'\", value, mav.getModel().get(name));\n\t\t};\n\t}\n\n\t/**\n\t * Assert the given model attributes exist.\n\t */\n\tpublic ResultMatcher attributeExists(String... names) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tfor (String name : names) {\n\t\t\t\tassertNotNull(\"Model attribute '\" + name + \"' does not exist\", mav.getModel().get(name));\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Assert the given model attributes do not exist.\n\t */\n\tpublic ResultMatcher attributeDoesNotExist(String... names) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tfor (String name : names) {\n\t\t\t\tassertNull(\"Model attribute '\" + name + \"' exists\", mav.getModel().get(name));\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Assert the given model attribute(s) have errors.\n\t */\n\tpublic ResultMatcher attributeErrorCount(String name, int expectedCount) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tErrors errors = getBindingResult(mav, name);\n\t\t\tassertEquals(\"Binding/validation error count for attribute '\" + name + \"',\",\n\t\t\t\t\texpectedCount, errors.getErrorCount());\n\t\t};\n\t}\n\n\t/**\n\t * Assert the given model attribute(s) have errors.\n\t */\n\tpublic ResultMatcher attributeHasErrors(String... names) {\n\t\treturn mvcResult -> {\n\t\t\tModelAndView mav = getModelAndView(mvcResult);\n\t\t\tfor (String name : names) {\n\t\t\t\tBindingResult result = getBindingResult(mav, name);\n\t\t\t\tassertTrue(\"No errors for attribute '\" + name + \"'\", result.hasErrors());\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Assert the given model attribute(s) do not have errors.\n\t */\n\tpublic ResultMatcher attributeHasNoErrors(String... names) {\n\t\treturn mvcResult -> {\n\t\t\tModelAndView mav = getModelAndView(mvcResult);\n\t\t\tfor (String name : names) {\n\t\t\t\tBindingResult result = getBindingResult(mav, name);\n\t\t\t\tassertFalse(\"Unexpected errors for attribute '\" + name + \"': \" + result.getAllErrors(),\n\t\t\t\t\t\tresult.hasErrors());\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Assert the given model attribute field(s) have errors.\n\t */\n\tpublic ResultMatcher attributeHasFieldErrors(String name, String... fieldNames) {\n\t\treturn mvcResult -> {\n\t\t\tModelAndView mav = getModelAndView(mvcResult);\n\t\t\tBindingResult result = getBindingResult(mav, name);\n\t\t\tassertTrue(\"No errors for attribute '\" + name + \"'\", result.hasErrors());\n\t\t\tfor (String fieldName : fieldNames) {\n\t\t\t\tboolean hasFieldErrors = result.hasFieldErrors(fieldName);\n\t\t\t\tassertTrue(\"No errors for field '\" + fieldName + \"' of attribute '\" + name + \"'\", hasFieldErrors);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Assert a field error code for a model attribute using exact String match.\n\t * @since 4.1\n\t */\n\tpublic ResultMatcher attributeHasFieldErrorCode(String name, String fieldName, String error) {\n\t\treturn mvcResult -> {\n\t\t\tModelAndView mav = getModelAndView(mvcResult);\n\t\t\tBindingResult result = getBindingResult(mav, name);\n\t\t\tassertTrue(\"No errors for attribute '\" + name + \"'\", result.hasErrors());\n\t\t\tFieldError fieldError = result.getFieldError(fieldName);\n\t\t\tassertNotNull(\"No errors for field '\" + fieldName + \"' of attribute '\" + name + \"'\", fieldError);\n\t\t\tString code = fieldError.getCode();\n\t\t\tassertEquals(\"Field error code\", error, code);\n\t\t};\n\t}\n\n\t/**\n\t * Assert a field error code for a model attribute using a {@link org.hamcrest.Matcher}.\n\t * @since 4.1\n\t */\n\tpublic ResultMatcher attributeHasFieldErrorCode(String name, String fieldName,\n\t\t\tMatcher<? super String> matcher) {\n\n\t\treturn mvcResult -> {\n\t\t\tModelAndView mav = getModelAndView(mvcResult);\n\t\t\tBindingResult result = getBindingResult(mav, name);\n\t\t\tassertTrue(\"No errors for attribute '\" + name + \"'\", result.hasErrors());\n\t\t\tFieldError fieldError = result.getFieldError(fieldName);\n\t\t\tassertNotNull(\"No errors for field '\" + fieldName + \"' of attribute '\" + name + \"'\", fieldError);\n\t\t\tString code = fieldError.getCode();\n\t\t\tassertThat(\"Field name '\" + fieldName + \"' of attribute '\" + name + \"'\", code, matcher);\n\t\t};\n\t}\n\n\t/**\n\t * Assert the total number of errors in the model.\n\t */\n\tpublic ResultMatcher errorCount(int expectedCount) {\n\t\treturn result -> {\n\t\t\tint actualCount = getErrorCount(getModelAndView(result).getModelMap());\n\t\t\tassertEquals(\"Binding/validation error count\", expectedCount, actualCount);\n\t\t};\n\t}\n\n\t/**\n\t * Assert the model has errors.\n\t */\n\tpublic ResultMatcher hasErrors() {\n\t\treturn result -> {\n\t\t\tint count = getErrorCount(getModelAndView(result).getModelMap());\n\t\t\tassertTrue(\"Expected binding/validation errors\", count != 0);\n\t\t};\n\t}\n\n\t/**\n\t * Assert the model has no errors.\n\t */\n\tpublic ResultMatcher hasNoErrors() {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tfor (Object value : mav.getModel().values()) {\n\t\t\t\tif (value instanceof Errors errors) {\n\t\t\t\t\tassertFalse(\"Unexpected binding/validation errors: \" + value, errors.hasErrors());\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Assert the number of model attributes.\n\t */\n\tpublic ResultMatcher size(int size) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tint actual = 0;\n\t\t\tfor (String key : mav.getModel().keySet()) {\n\t\t\t\tif (!key.startsWith(BindingResult.MODEL_KEY_PREFIX)) {\n\t\t\t\t\tactual++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassertEquals(\"Model size\", size, actual);\n\t\t};\n\t}\n\n\tprivate ModelAndView getModelAndView(MvcResult mvcResult) {\n\t\tModelAndView mav = mvcResult.getModelAndView();\n\t\tassertNotNull(\"No ModelAndView found\", mav);\n\t\treturn mav;\n\t}\n\n\tprivate BindingResult getBindingResult(ModelAndView mav, String name) {\n\t\tBindingResult result = (BindingResult) mav.getModel().get(BindingResult.MODEL_KEY_PREFIX + name);\n\t\tassertNotNull(\"No BindingResult for attribute: \" + name, result);\n\t\treturn result;\n\t}\n\n\tprivate int getErrorCount(ModelMap model) {\n\t\tint count = 0;\n\t\tfor (Object value : model.values()) {\n\t\t\tif (value instanceof Errors errors) {\n\t\t\t\tcount += errors.getErrorCount();\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n}"
  },
  "org.springframework.test.web.servlet.result.ModelResultMatchers#attribute(name,matcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a model attribute value with the given Hamcrest {@link Matcher}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attribute(String name, Matcher<? super T> matcher)",
    "source_code": "\tpublic <T> ResultMatcher attribute(String name, Matcher<? super T> matcher) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tassertThat(\"Model attribute '\" + name + \"'\", (T) mav.getModel().get(name), matcher);\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.ModelResultMatchers#attribute(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a model attribute value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attribute(String name, @Nullable Object value)",
    "source_code": "\tpublic ResultMatcher attribute(String name, @Nullable Object value) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tassertEquals(\"Model attribute '\" + name + \"'\", value, mav.getModel().get(name));\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.ModelResultMatchers#attributeDoesNotExist(names)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the given model attributes do not exist.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "names"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attributeDoesNotExist(String... names)",
    "source_code": "\tpublic ResultMatcher attributeDoesNotExist(String... names) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tfor (String name : names) {\n\t\t\t\tassertNull(\"Model attribute '\" + name + \"' exists\", mav.getModel().get(name));\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.ModelResultMatchers#attributeErrorCount(name,expectedCount)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the given model attribute(s) have errors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "expectedCount"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attributeErrorCount(String name, int expectedCount)",
    "source_code": "\tpublic ResultMatcher attributeErrorCount(String name, int expectedCount) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tErrors errors = getBindingResult(mav, name);\n\t\t\tassertEquals(\"Binding/validation error count for attribute '\" + name + \"',\",\n\t\t\t\t\texpectedCount, errors.getErrorCount());\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.ModelResultMatchers#attributeExists(names)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the given model attributes exist.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "names"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attributeExists(String... names)",
    "source_code": "\tpublic ResultMatcher attributeExists(String... names) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tfor (String name : names) {\n\t\t\t\tassertNotNull(\"Model attribute '\" + name + \"' does not exist\", mav.getModel().get(name));\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.ModelResultMatchers#attributeHasErrors(names)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the given model attribute(s) have errors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "names"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attributeHasErrors(String... names)",
    "source_code": "\tpublic ResultMatcher attributeHasErrors(String... names) {\n\t\treturn mvcResult -> {\n\t\t\tModelAndView mav = getModelAndView(mvcResult);\n\t\t\tfor (String name : names) {\n\t\t\t\tBindingResult result = getBindingResult(mav, name);\n\t\t\t\tassertTrue(\"No errors for attribute '\" + name + \"'\", result.hasErrors());\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.ModelResultMatchers#attributeHasFieldErrorCode(name,fieldName,error)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a field error code for a model attribute using exact String match.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "fieldName",
      "error"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attributeHasFieldErrorCode(String name, String fieldName, String error)",
    "source_code": "\tpublic ResultMatcher attributeHasFieldErrorCode(String name, String fieldName, String error) {\n\t\treturn mvcResult -> {\n\t\t\tModelAndView mav = getModelAndView(mvcResult);\n\t\t\tBindingResult result = getBindingResult(mav, name);\n\t\t\tassertTrue(\"No errors for attribute '\" + name + \"'\", result.hasErrors());\n\t\t\tFieldError fieldError = result.getFieldError(fieldName);\n\t\t\tassertNotNull(\"No errors for field '\" + fieldName + \"' of attribute '\" + name + \"'\", fieldError);\n\t\t\tString code = fieldError.getCode();\n\t\t\tassertEquals(\"Field error code\", error, code);\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.ModelResultMatchers#attributeHasFieldErrorCode(name,fieldName,matcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a field error code for a model attribute using a {@link org.hamcrest.Matcher}.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "fieldName",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attributeHasFieldErrorCode(String name, String fieldName,\n\t\t\tMatcher<? super String> matcher)",
    "source_code": "\tpublic ResultMatcher attributeHasFieldErrorCode(String name, String fieldName,"
  },
  "org.springframework.test.web.servlet.result.ModelResultMatchers#attributeHasFieldErrors(name,fieldNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the given model attribute field(s) have errors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "fieldNames"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attributeHasFieldErrors(String name, String... fieldNames)",
    "source_code": "\tpublic ResultMatcher attributeHasFieldErrors(String name, String... fieldNames) {\n\t\treturn mvcResult -> {\n\t\t\tModelAndView mav = getModelAndView(mvcResult);\n\t\t\tBindingResult result = getBindingResult(mav, name);\n\t\t\tassertTrue(\"No errors for attribute '\" + name + \"'\", result.hasErrors());\n\t\t\tfor (String fieldName : fieldNames) {\n\t\t\t\tboolean hasFieldErrors = result.hasFieldErrors(fieldName);\n\t\t\t\tassertTrue(\"No errors for field '\" + fieldName + \"' of attribute '\" + name + \"'\", hasFieldErrors);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.ModelResultMatchers#attributeHasNoErrors(names)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the given model attribute(s) do not have errors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "names"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attributeHasNoErrors(String... names)",
    "source_code": "\tpublic ResultMatcher attributeHasNoErrors(String... names) {\n\t\treturn mvcResult -> {\n\t\t\tModelAndView mav = getModelAndView(mvcResult);\n\t\t\tfor (String name : names) {\n\t\t\t\tBindingResult result = getBindingResult(mav, name);\n\t\t\t\tassertFalse(\"Unexpected errors for attribute '\" + name + \"': \" + result.getAllErrors(),\n\t\t\t\t\t\tresult.hasErrors());\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.ModelResultMatchers#errorCount(expectedCount)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the total number of errors in the model.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedCount"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher errorCount(int expectedCount)",
    "source_code": "\tpublic ResultMatcher errorCount(int expectedCount) {\n\t\treturn result -> {\n\t\t\tint actualCount = getErrorCount(getModelAndView(result).getModelMap());\n\t\t\tassertEquals(\"Binding/validation error count\", expectedCount, actualCount);\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.ModelResultMatchers#hasErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the model has errors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher hasErrors()",
    "source_code": "\tpublic ResultMatcher hasErrors() {\n\t\treturn result -> {\n\t\t\tint count = getErrorCount(getModelAndView(result).getModelMap());\n\t\t\tassertTrue(\"Expected binding/validation errors\", count != 0);\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.ModelResultMatchers#hasNoErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the model has no errors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher hasNoErrors()",
    "source_code": "\tpublic ResultMatcher hasNoErrors() {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tfor (Object value : mav.getModel().values()) {\n\t\t\t\tif (value instanceof Errors errors) {\n\t\t\t\t\tassertFalse(\"Unexpected binding/validation errors: \" + value, errors.hasErrors());\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.ModelResultMatchers#size(size)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the number of model attributes.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "size"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher size(int size)",
    "source_code": "\tpublic ResultMatcher size(int size) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tint actual = 0;\n\t\t\tfor (String key : mav.getModel().keySet()) {\n\t\t\t\tif (!key.startsWith(BindingResult.MODEL_KEY_PREFIX)) {\n\t\t\t\t\tactual++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassertEquals(\"Model size\", size, actual);\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract implementation of {@link MockMvcBuilder} with common methods for\n * configuring filters, default request properties, global expectations and\n * global result actions.\n *\n * <p>Subclasses can use different strategies to prepare the Spring\n * {@code WebApplicationContext} that will be passed to the\n * {@code DispatcherServlet}.\n *\n * @author Rossen Stoyanchev\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @since 4.0\n * @param <B> a self reference to the builder type\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "signature": "public class AbstractMockMvcBuilder",
    "source_code": "public abstract class AbstractMockMvcBuilder<B extends AbstractMockMvcBuilder<B>>"
  },
  "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder#addDispatcherServletCustomizer(customizer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "T",
    "signature": "public T addDispatcherServletCustomizer(DispatcherServletCustomizer customizer)",
    "source_code": "\tpublic final <T extends B> T addDispatcherServletCustomizer(DispatcherServletCustomizer customizer) {\n\t\tthis.dispatcherServletCustomizers.add(customizer);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder#addFilter(filter,urlPatterns)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filter",
      "urlPatterns"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "T",
    "signature": "public T addFilter(Filter filter, String... urlPatterns)",
    "source_code": "\tpublic final <T extends B> T addFilter(Filter filter, String... urlPatterns) {\n\t\tAssert.notNull(filter, \"filter cannot be null\");\n\t\tAssert.notNull(urlPatterns, \"urlPatterns cannot be null\");\n\t\tif (urlPatterns.length > 0) {\n\t\t\tfilter = new PatternMappingFilterProxy(filter, urlPatterns);\n\t\t}\n\t\tthis.filters.add(filter);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder#addFilters(filters)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filters"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "T",
    "signature": "public T addFilters(Filter... filters)",
    "source_code": "\tpublic final <T extends B> T addFilters(Filter... filters) {\n\t\tAssert.notNull(filters, \"filters cannot be null\");\n\t\tfor (Filter f : filters) {\n\t\t\tAssert.notNull(f, \"filters cannot contain null values\");\n\t\t\tthis.filters.add(f);\n\t\t}\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder#alwaysDo(resultHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resultHandler"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "T",
    "signature": "public T alwaysDo(ResultHandler resultHandler)",
    "source_code": "\tpublic final <T extends B> T alwaysDo(ResultHandler resultHandler) {\n\t\tthis.globalResultHandlers.add(resultHandler);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder#alwaysExpect(resultMatcher)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resultMatcher"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "T",
    "signature": "public T alwaysExpect(ResultMatcher resultMatcher)",
    "source_code": "\tpublic final <T extends B> T alwaysExpect(ResultMatcher resultMatcher) {\n\t\tthis.globalResultMatchers.add(resultMatcher);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder#apply(configurer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configurer"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "T",
    "signature": "public T apply(MockMvcConfigurer configurer)",
    "source_code": "\tpublic final <T extends B> T apply(MockMvcConfigurer configurer) {\n\t\tconfigurer.afterConfigurerAdded(this);\n\t\tthis.configurers.add(configurer);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder#build()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link org.springframework.test.web.servlet.MockMvc} instance.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "MockMvc",
    "signature": "public MockMvc build()",
    "source_code": "\tpublic final MockMvc build() {\n\t\tWebApplicationContext wac = initWebAppContext();\n\t\tServletContext servletContext = wac.getServletContext();\n\t\tMockServletConfig mockServletConfig = new MockServletConfig(servletContext);\n\n\t\tfor (MockMvcConfigurer configurer : this.configurers) {\n\t\t\tRequestPostProcessor processor = configurer.beforeMockMvcCreated(this, wac);\n\t\t\tif (processor != null) {\n\t\t\t\tif (this.defaultRequestBuilder == null) {\n\t\t\t\t\tthis.defaultRequestBuilder = MockMvcRequestBuilders.get(\"/\");\n\t\t\t\t}\n\t\t\t\tif (this.defaultRequestBuilder instanceof ConfigurableSmartRequestBuilder configurableBuilder) {\n\t\t\t\t\tconfigurableBuilder.with(processor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tFilter[] filterArray = this.filters.toArray(new Filter[0]);\n\n\t\treturn super.createMockMvc(filterArray, mockServletConfig, wac, this.defaultRequestBuilder,\n\t\t\t\tthis.defaultResponseCharacterEncoding, this.globalResultMatchers, this.globalResultHandlers,\n\t\t\t\tthis.dispatcherServletCustomizers);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder#defaultRequest(requestBuilder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestBuilder"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "T",
    "signature": "public T defaultRequest(RequestBuilder requestBuilder)",
    "source_code": "\tpublic final <T extends B> T defaultRequest(RequestBuilder requestBuilder) {\n\t\tthis.defaultRequestBuilder = requestBuilder;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder#defaultResponseCharacterEncoding(defaultResponseCharacterEncoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Define the default character encoding to be applied to every response.\n\t * @param defaultResponseCharacterEncoding the default response character encoding\n\t * @since 5.3.10\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultResponseCharacterEncoding"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "T",
    "signature": "public T defaultResponseCharacterEncoding(Charset defaultResponseCharacterEncoding)",
    "source_code": "\tpublic final <T extends B> T defaultResponseCharacterEncoding(Charset defaultResponseCharacterEncoding) {\n\t\tthis.defaultResponseCharacterEncoding = defaultResponseCharacterEncoding;\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder#dispatchOptions(dispatchOptions)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dispatchOptions"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "T",
    "signature": "public T dispatchOptions(boolean dispatchOptions)",
    "source_code": "\tpublic final <T extends B> T dispatchOptions(boolean dispatchOptions) {\n\t\treturn addDispatcherServletCustomizer(\n\t\t\t\tdispatcherServlet -> dispatcherServlet.setDispatchOptionsRequest(dispatchOptions));\n\t}"
  },
  "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder#initWebAppContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A method to obtain the {@code WebApplicationContext} to be passed to the\n\t * {@code DispatcherServlet}. Invoked from {@link #build()} before the\n\t * {@link MockMvc} instance is created.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "WebApplicationContext",
    "signature": "protected WebApplicationContext initWebAppContext()",
    "source_code": "\tprotected abstract WebApplicationContext initWebAppContext();"
  },
  "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder#self()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "T",
    "signature": "protected T self()",
    "source_code": "\tprotected <T extends B> T self() {\n\t\treturn (T) this;\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#resolveErrorMessages(messageSource,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve global and field errors to messages with the given\n\t * {@link MessageSource} and {@link Locale}.\n\t * @return a Map with errors as key and resolves messages as value\n\t * @since 6.0.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "String>",
    "signature": "public String> resolveErrorMessages(MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic Map<ObjectError, String> resolveErrorMessages(MessageSource messageSource, Locale locale) {\n\t\tMap<ObjectError, String> map = new LinkedHashMap<>();\n\t\taddMessages(map, getGlobalErrors(), messageSource, locale);\n\t\taddMessages(map, getFieldErrors(), messageSource, locale);\n\t\treturn map;\n\t}"
  },
  "org.springframework.web.reactive.config.ResourceHandlerRegistry": {
    "change": "added",
    "deprecated": false,
    "doc": " * serve static resources (e.g. {@code \"/resources/**\"}).\n *\n * <p>Then use additional methods on the returned\n * {@link ResourceHandlerRegistration} to add one or more locations from which\n * to serve static content from (e.g. {{@code \"/\"},\n * {@code \"classpath:/META-INF/public-web-resources/\"}}) or to specify a cache\n * period for served resources.\n *\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "signature": "public class ResourceHandlerRegistry",
    "source_code": "public class ResourceHandlerRegistry {\n\n\tprivate final ResourceLoader resourceLoader;\n\n\tprivate final List<ResourceHandlerRegistration> registrations = new ArrayList<>();\n\n\tprivate int order = Ordered.LOWEST_PRECEDENCE - 1;\n\n\t@Nullable\n\tprivate ResourceUrlProvider resourceUrlProvider;\n\n\n\t/**\n\t * Create a new resource handler registry for the given resource loader\n\t * (typically an application context).\n\t * @param resourceLoader the resource loader to use\n\t */\n\tpublic ResourceHandlerRegistry(ResourceLoader resourceLoader) {\n\t\tthis.resourceLoader = resourceLoader;\n\t}\n\n\t/**\n\t * Configure the {@link ResourceUrlProvider} that can be used by\n\t * {@link org.springframework.web.reactive.resource.ResourceTransformer} instances.\n\t * @param resourceUrlProvider the resource URL provider to use\n\t * @since 5.0.11\n\t */\n\tpublic void setResourceUrlProvider(@Nullable ResourceUrlProvider resourceUrlProvider) {\n\t\tthis.resourceUrlProvider = resourceUrlProvider;\n\t}\n\n\n\n\t/**\n\t * Add a resource handler for serving static resources based on the specified\n\t * URL path patterns. The handler will be invoked for every incoming request\n\t * that matches to one of the specified path patterns.\n\t * <p>Patterns like {@code \"/static/**\"} or {@code \"/css/{filename:\\\\w+\\\\.css}\"}\n\t * are allowed. See {@link org.springframework.web.util.pattern.PathPattern}\n\t * for more details on the syntax.\n\t * @return a {@link ResourceHandlerRegistration} to use to further configure\n\t * the registered resource handler\n\t */\n\tpublic ResourceHandlerRegistration addResourceHandler(String... patterns) {\n\t\tResourceHandlerRegistration registration = new ResourceHandlerRegistration(this.resourceLoader, patterns);\n\t\tthis.registrations.add(registration);\n\t\treturn registration;\n\t}\n\n\t/**\n\t * Whether a resource handler has already been registered for the given path pattern.\n\t */\n\tpublic boolean hasMappingForPattern(String pathPattern) {\n\t\tfor (ResourceHandlerRegistration registration : this.registrations) {\n\t\t\tif (Arrays.asList(registration.getPathPatterns()).contains(pathPattern)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Specify the order to use for resource handling relative to other\n\t * {@code HandlerMapping}s configured in the Spring configuration.\n\t * <p>The default value used is {@code Integer.MAX_VALUE-1}.\n\t */\n\tpublic ResourceHandlerRegistry setOrder(int order) {\n\t\tthis.order = order;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return a handler mapping with the mapped resource handlers; or {@code null} in case\n\t * of no registrations.\n\t */\n\t@Nullable\n\tprotected AbstractUrlHandlerMapping getHandlerMapping() {\n\t\tif (this.registrations.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tMap<String, WebHandler> urlMap = new LinkedHashMap<>();\n\t\tfor (ResourceHandlerRegistration registration : this.registrations) {\n\t\t\tResourceWebHandler handler = getRequestHandler(registration);\n\t\t\tfor (String pathPattern : registration.getPathPatterns()) {\n\t\t\t\turlMap.put(pathPattern, handler);\n\t\t\t}\n\t\t}\n\t\treturn new SimpleUrlHandlerMapping(urlMap, this.order);\n\t}\n\n\tprivate ResourceWebHandler getRequestHandler(ResourceHandlerRegistration registration) {\n\t\tResourceWebHandler handler = registration.getRequestHandler();\n\t\tfor (ResourceTransformer transformer : handler.getResourceTransformers()) {\n\t\t\tif (transformer instanceof ResourceTransformerSupport resourceTransformerSupport) {\n\t\t\t\tresourceTransformerSupport.setResourceUrlProvider(this.resourceUrlProvider);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\thandler.afterPropertiesSet();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanInitializationException(\"Failed to init ResourceHttpRequestHandler\", ex);\n\t\t}\n\t\treturn handler;\n\t}\n\n}"
  },
  "org.springframework.web.reactive.config.ResourceHandlerRegistry#addResourceHandler(patterns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t * <p>Patterns like {@code \"/static/**\"} or {@code \"/css/{filename:\\\\w+\\\\.css}\"}\n\t * are allowed. See {@link org.springframework.web.util.pattern.PathPattern}\n\t * for more details on the syntax.\n\t * @return a {@link ResourceHandlerRegistration} to use to further configure\n\t * the registered resource handler\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "patterns"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "ResourceHandlerRegistration",
    "signature": "public ResourceHandlerRegistration addResourceHandler(String... patterns)",
    "source_code": "\tpublic ResourceHandlerRegistration addResourceHandler(String... patterns) {\n\t\tResourceHandlerRegistration registration = new ResourceHandlerRegistration(this.resourceLoader, patterns);\n\t\tthis.registrations.add(registration);\n\t\treturn registration;\n\t}"
  },
  "org.springframework.web.reactive.config.ResourceHandlerRegistry#getHandlerMapping()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a handler mapping with the mapped resource handlers; or {@code null} in case\n\t * of no registrations.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "AbstractUrlHandlerMapping",
    "signature": "protected AbstractUrlHandlerMapping getHandlerMapping()",
    "source_code": "\tprotected AbstractUrlHandlerMapping getHandlerMapping() {\n\t\tif (this.registrations.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tMap<String, WebHandler> urlMap = new LinkedHashMap<>();\n\t\tfor (ResourceHandlerRegistration registration : this.registrations) {\n\t\t\tResourceWebHandler handler = getRequestHandler(registration);\n\t\t\tfor (String pathPattern : registration.getPathPatterns()) {\n\t\t\t\turlMap.put(pathPattern, handler);\n\t\t\t}\n\t\t}\n\t\treturn new SimpleUrlHandlerMapping(urlMap, this.order);\n\t}"
  },
  "org.springframework.web.reactive.config.ResourceHandlerRegistry#hasMappingForPattern(pathPattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether a resource handler has already been registered for the given path pattern.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathPattern"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "boolean",
    "signature": "public boolean hasMappingForPattern(String pathPattern)",
    "source_code": "\tpublic boolean hasMappingForPattern(String pathPattern) {\n\t\tfor (ResourceHandlerRegistration registration : this.registrations) {\n\t\t\tif (Arrays.asList(registration.getPathPatterns()).contains(pathPattern)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.reactive.config.ResourceHandlerRegistry#setOrder(order)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the order to use for resource handling relative to other\n\t * {@code HandlerMapping}s configured in the Spring configuration.\n\t * <p>The default value used is {@code Integer.MAX_VALUE-1}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "order"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "ResourceHandlerRegistry",
    "signature": "public ResourceHandlerRegistry setOrder(int order)",
    "source_code": "\tpublic ResourceHandlerRegistry setOrder(int order) {\n\t\tthis.order = order;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.reactive.config.ResourceHandlerRegistry#setResourceUrlProvider(resourceUrlProvider)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link ResourceUrlProvider} that can be used by\n\t * {@link org.springframework.web.reactive.resource.ResourceTransformer} instances.\n\t * @param resourceUrlProvider the resource URL provider to use\n\t * @since 5.0.11\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceUrlProvider"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "void",
    "signature": "public void setResourceUrlProvider(@Nullable ResourceUrlProvider resourceUrlProvider)",
    "source_code": "\tpublic void setResourceUrlProvider(@Nullable ResourceUrlProvider resourceUrlProvider) {\n\t\tthis.resourceUrlProvider = resourceUrlProvider;\n\t}"
  },
  "org.springframework.web.reactive.function.BodyInserters": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Static factory methods for {@link BodyInserter} implementations.\n *\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class BodyInserters",
    "source_code": "public abstract class BodyInserters {\n\n\tprivate static final ResolvableType RESOURCE_TYPE = ResolvableType.forClass(Resource.class);\n\n\tprivate static final ResolvableType SSE_TYPE = ResolvableType.forClass(ServerSentEvent.class);\n\n\tprivate static final ResolvableType FORM_DATA_TYPE =\n\t\t\tResolvableType.forClassWithGenerics(MultiValueMap.class, String.class, String.class);\n\n\tprivate static final ResolvableType MULTIPART_DATA_TYPE = ResolvableType.forClassWithGenerics(\n\t\t\tMultiValueMap.class, String.class, Object.class);\n\n\tprivate static final BodyInserter<Void, ReactiveHttpOutputMessage> EMPTY_INSERTER =\n\t\t\t(response, context) -> response.setComplete();\n\n\tprivate static final ReactiveAdapterRegistry registry = ReactiveAdapterRegistry.getSharedInstance();\n\n\n\t/**\n\t * Inserter that does not write.\n\t * @return the inserter\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> empty() {\n\t\treturn (BodyInserter<T, ReactiveHttpOutputMessage>) EMPTY_INSERTER;\n\t}\n\n\t/**\n\t * Inserter to write the given value.\n\t * <p>Alternatively, consider using the {@code bodyValue(Object)} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param body the value to write\n\t * @param <T> the type of the body\n\t * @return the inserter to write a single value\n\t * @throws IllegalArgumentException if {@code body} is a {@link Publisher} or an\n\t * instance of a type supported by {@link ReactiveAdapterRegistry#getSharedInstance()},\n\t * for which {@link #fromPublisher(Publisher, Class)} or\n\t * {@link #fromProducer(Object, Class)} should be used.\n\t * @see #fromPublisher(Publisher, Class)\n\t * @see #fromProducer(Object, Class)\n\t */\n\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromValue(T body) {\n\t\tAssert.notNull(body, \"'body' must not be null\");\n\t\tAssert.isNull(registry.getAdapter(body.getClass()),\n\t\t\t\t\"'body' should be an object, for reactive types use a variant specifying a publisher/producer and its related element type\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, Mono.just(body), ResolvableType.forInstance(body), null);\n\t}\n\n\t/**\n\t * Inserter to write the given object.\n\t * <p>Alternatively, consider using the {@code bodyValue(Object)} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param body the body to write to the response\n\t * @param <T> the type of the body\n\t * @return the inserter to write a single object\n\t * @throws IllegalArgumentException if {@code body} is a {@link Publisher} or an\n\t * instance of a type supported by {@link ReactiveAdapterRegistry#getSharedInstance()},\n\t * for which {@link #fromPublisher(Publisher, Class)} or\n\t * {@link #fromProducer(Object, Class)} should be used.\n\t * @see #fromPublisher(Publisher, Class)\n\t * @see #fromProducer(Object, Class)\n\t * @deprecated As of Spring Framework 5.2, in favor of {@link #fromValue(Object)}\n\t */\n\t@Deprecated\n\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromObject(T body) {\n\t\treturn fromValue(body);\n\t}\n\n\t/**\n\t * Inserter to write the given producer of value(s) which must be a {@link Publisher}\n\t * or another producer adaptable to a {@code Publisher} via\n\t * {@link ReactiveAdapterRegistry}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param <T> the type of the body\n\t * @param producer the source of body value(s).\n\t * @param elementClass the class of values to be produced\n\t * @return the inserter to write a producer\n\t * @since 5.2\n\t */\n\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromProducer(T producer, Class<?> elementClass) {\n\t\tAssert.notNull(producer, \"'producer' must not be null\");\n\t\tAssert.notNull(elementClass, \"'elementClass' must not be null\");\n\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(producer.getClass());\n\t\tAssert.notNull(adapter, \"'producer' type is unknown to ReactiveAdapterRegistry\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, producer, ResolvableType.forClass(elementClass), adapter);\n\t}\n\n\t/**\n\t * Inserter to write the given producer of value(s) which must be a {@link Publisher}\n\t * or another producer adaptable to a {@code Publisher} via\n\t * {@link ReactiveAdapterRegistry}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param <T> the type of the body\n\t * @param producer the source of body value(s).\n\t * @param elementTypeRef the type of values to be produced\n\t * @return the inserter to write a producer\n\t * @since 5.2\n\t */\n\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromProducer(\n\t\t\tT producer, ParameterizedTypeReference<?> elementTypeRef) {\n\n\t\tAssert.notNull(producer, \"'producer' must not be null\");\n\t\tAssert.notNull(elementTypeRef, \"'elementTypeRef' must not be null\");\n\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(producer.getClass());\n\t\tAssert.notNull(adapter, \"'producer' type is unknown to ReactiveAdapterRegistry\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, producer, ResolvableType.forType(elementTypeRef), adapter);\n\t}\n\n\t/**\n\t * Inserter to write the given {@link Publisher}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param publisher the publisher to write with\n\t * @param elementClass the class of elements in the publisher\n\t * @param <T> the type of the elements contained in the publisher\n\t * @param <P> the {@code Publisher} type\n\t * @return the inserter to write a {@code Publisher}\n\t */\n\tpublic static <T, P extends Publisher<T>> BodyInserter<P, ReactiveHttpOutputMessage> fromPublisher(\n\t\t\tP publisher, Class<T> elementClass) {\n\n\t\tAssert.notNull(publisher, \"'publisher' must not be null\");\n\t\tAssert.notNull(elementClass, \"'elementClass' must not be null\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, publisher, ResolvableType.forClass(elementClass), null);\n\t}\n\n\t/**\n\t * Inserter to write the given {@link Publisher}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param publisher the publisher to write with\n\t * @param elementTypeRef the type of elements contained in the publisher\n\t * @param <T> the type of the elements contained in the publisher\n\t * @param <P> the {@code Publisher} type\n\t * @return the inserter to write a {@code Publisher}\n\t */\n\tpublic static <T, P extends Publisher<T>> BodyInserter<P, ReactiveHttpOutputMessage> fromPublisher(\n\t\t\tP publisher, ParameterizedTypeReference<T> elementTypeRef) {\n\n\t\tAssert.notNull(publisher, \"'publisher' must not be null\");\n\t\tAssert.notNull(elementTypeRef, \"'elementTypeRef' must not be null\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, publisher, ResolvableType.forType(elementTypeRef.getType()), null);\n\t}\n\n\t/**\n\t * Inserter to write the given {@code Resource}.\n\t * <p>If the resource can be resolved to a {@linkplain Resource#getFile() file}, it will\n\t * be copied using <a href=\"https://en.wikipedia.org/wiki/Zero-copy\">zero-copy</a>.\n\t * @param resource the resource to write to the output message\n\t * @param <T> the type of the {@code Resource}\n\t * @return the inserter to write a {@code Publisher}\n\t */\n\tpublic static <T extends Resource> BodyInserter<T, ReactiveHttpOutputMessage> fromResource(T resource) {\n\t\tAssert.notNull(resource, \"'resource' must not be null\");\n\t\treturn (outputMessage, context) -> {\n\t\t\tResolvableType elementType = RESOURCE_TYPE;\n\t\t\tHttpMessageWriter<Resource> writer = findWriter(context, elementType, null);\n\t\t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n\t\t\treturn write(Mono.just(resource), elementType, contentType, outputMessage, context, writer);\n\t\t};\n\t}\n\n\t/**\n\t * Inserter to write the given {@code ServerSentEvent} publisher.\n\t * <p>Alternatively, you can provide event data objects via\n\t * {@link #fromPublisher(Publisher, Class)} or {@link #fromProducer(Object, Class)},\n\t * and set the \"Content-Type\" to {@link MediaType#TEXT_EVENT_STREAM text/event-stream}.\n\t * @param eventsPublisher the {@code ServerSentEvent} publisher to write to the response body\n\t * @param <T> the type of the data elements in the {@link ServerSentEvent}\n\t * @return the inserter to write a {@code ServerSentEvent} publisher\n\t * @see <a href=\"https://www.w3.org/TR/eventsource/\">Server-Sent Events W3C recommendation</a>\n\t */\n\t// Parameterized for server-side use\n\tpublic static <T, S extends Publisher<ServerSentEvent<T>>> BodyInserter<S, ServerHttpResponse> fromServerSentEvents(\n\t\t\tS eventsPublisher) {\n\n\t\tAssert.notNull(eventsPublisher, \"'eventsPublisher' must not be null\");\n\t\treturn (serverResponse, context) -> {\n\t\t\tResolvableType elementType = SSE_TYPE;\n\t\t\tMediaType mediaType = MediaType.TEXT_EVENT_STREAM;\n\t\t\tHttpMessageWriter<ServerSentEvent<T>> writer = findWriter(context, elementType, mediaType);\n\t\t\treturn write(eventsPublisher, elementType, mediaType, serverResponse, context, writer);\n\t\t};\n\t}\n\n\t/**\n\t * Return a {@link FormInserter} to write the given {@code MultiValueMap}\n\t * as URL-encoded form data. The returned inserter allows for additional\n\t * entries to be added via {@link FormInserter#with(String, Object)}.\n\t * <p>Note that you can also use the {@code bodyValue(Object)} method in the\n\t * request builders of both the {@code WebClient} and {@code WebTestClient}.\n\t * In that case the setting of the request content type is also not required,\n\t * just be sure the map contains String values only or otherwise it would be\n\t * interpreted as a multipart request.\n\t * @param formData the form data to write to the output message\n\t * @return the inserter that allows adding more form data\n\t */\n\tpublic static FormInserter<String> fromFormData(MultiValueMap<String, String> formData) {\n\t\treturn new DefaultFormInserter().with(formData);\n\t}\n\n\t/**\n\t * Return a {@link FormInserter} to write the given key-value pair as\n\t * URL-encoded form data. The returned inserter allows for additional\n\t * entries to be added via {@link FormInserter#with(String, Object)}.\n\t * @param name the key to add to the form\n\t * @param value the value to add to the form\n\t * @return the inserter that allows adding more form data\n\t */\n\tpublic static FormInserter<String> fromFormData(String name, String value) {\n\t\tAssert.notNull(name, \"'name' must not be null\");\n\t\tAssert.notNull(value, \"'value' must not be null\");\n\t\treturn new DefaultFormInserter().with(name, value);\n\t}\n\n\t/**\n\t * Return a {@link MultipartInserter} to write the given\n\t * {@code MultiValueMap} as multipart data. Values in the map can be an\n\t * Object or an {@link HttpEntity}.\n\t * <p>Note that you can also build the multipart data externally with\n\t * {@link MultipartBodyBuilder}, and pass the resulting map directly to the\n\t * {@code bodyValue(Object)} shortcut method in {@code WebClient}.\n\t * @param multipartData the form data to write to the output message\n\t * @return the inserter that allows adding more parts\n\t * @see MultipartBodyBuilder\n\t */\n\tpublic static MultipartInserter fromMultipartData(MultiValueMap<String, ?> multipartData) {\n\t\tAssert.notNull(multipartData, \"'multipartData' must not be null\");\n\t\treturn new DefaultMultipartInserter().withInternal(multipartData);\n\t}\n\n\t/**\n\t * Return a {@link MultipartInserter} to write the given parts,\n\t * as multipart data. Values in the map can be an Object or an\n\t * {@link HttpEntity}.\n\t * <p>Note that you can also build the multipart data externally with\n\t * {@link MultipartBodyBuilder}, and pass the resulting map directly to the\n\t * {@code bodyValue(Object)} shortcut method in {@code WebClient}.\n\t * @param name the part name\n\t * @param value the part value, an Object or {@code HttpEntity}\n\t * @return the inserter that allows adding more parts\n\t */\n\tpublic static MultipartInserter fromMultipartData(String name, Object value) {\n\t\tAssert.notNull(name, \"'name' must not be null\");\n\t\tAssert.notNull(value, \"'value' must not be null\");\n\t\treturn new DefaultMultipartInserter().with(name, value);\n\t}\n\n\t/**\n\t * Return a {@link MultipartInserter} to write the given asynchronous parts,\n\t * as multipart data.\n\t * <p>Note that you can also build the multipart data externally with\n\t * {@link MultipartBodyBuilder}, and pass the resulting map directly to the\n\t * {@code bodyValue(Object)} shortcut method in {@code WebClient}.\n\t * @param name the part name\n\t * @param publisher the publisher that forms the part value\n\t * @param elementClass the class contained in the {@code publisher}\n\t * @return the inserter that allows adding more parts\n\t */\n\tpublic static <T, P extends Publisher<T>> MultipartInserter fromMultipartAsyncData(\n\t\t\tString name, P publisher, Class<T> elementClass) {\n\n\t\treturn new DefaultMultipartInserter().withPublisher(name, publisher, elementClass);\n\t}\n\n\t/**\n\t * Variant of {@link #fromMultipartAsyncData(String, Publisher, Class)} that\n\t * accepts a {@link ParameterizedTypeReference} for the element type, which\n\t * allows specifying generic type information.\n\t * <p>Note that you can also build the multipart data externally with\n\t * {@link MultipartBodyBuilder}, and pass the resulting map directly to the\n\t * {@code bodyValue(Object)} shortcut method in {@code WebClient}.\n\t * @param name the part name\n\t * @param publisher the publisher that forms the part value\n\t * @param typeReference the type contained in the {@code publisher}\n\t * @return the inserter that allows adding more parts\n\t */\n\tpublic static <T, P extends Publisher<T>> MultipartInserter fromMultipartAsyncData(\n\t\t\tString name, P publisher, ParameterizedTypeReference<T> typeReference) {\n\n\t\treturn new DefaultMultipartInserter().withPublisher(name, publisher, typeReference);\n\t}\n\n\t/**\n\t * Inserter to write the given {@code Publisher<DataBuffer>} to the body.\n\t * @param publisher the data buffer publisher to write\n\t * @param <T> the type of the publisher\n\t * @return the inserter to write directly to the body\n\t * @see ReactiveHttpOutputMessage#writeWith(Publisher)\n\t */\n\tpublic static <T extends Publisher<DataBuffer>> BodyInserter<T, ReactiveHttpOutputMessage> fromDataBuffers(\n\t\t\tT publisher) {\n\n\t\tAssert.notNull(publisher, \"'publisher' must not be null\");\n\t\treturn (outputMessage, context) -> outputMessage.writeWith(publisher);\n\t}\n\n\n\tprivate static <M extends ReactiveHttpOutputMessage> Mono<Void> writeWithMessageWriters(\n\t\t\tM outputMessage, BodyInserter.Context context, Object body, ResolvableType bodyType, @Nullable ReactiveAdapter adapter) {\n\n\t\tPublisher<?> publisher;\n\t\tif (body instanceof Publisher<?> publisherBody) {\n\t\t\tpublisher = publisherBody;\n\t\t}\n\t\telse if (adapter != null) {\n\t\t\tpublisher = adapter.toPublisher(body);\n\t\t}\n\t\telse {\n\t\t\tpublisher = Mono.just(body);\n\t\t}\n\t\tMediaType mediaType = outputMessage.getHeaders().getContentType();\n\t\treturn context.messageWriters().stream()\n\t\t\t\t.filter(messageWriter -> messageWriter.canWrite(bodyType, mediaType))\n\t\t\t\t.findFirst()\n\t\t\t\t.map(BodyInserters::cast)\n\t\t\t\t.map(writer -> write(publisher, bodyType, mediaType, outputMessage, context, writer))\n\t\t\t\t.orElseGet(() -> Mono.error(unsupportedError(bodyType, context, mediaType)));\n\t}\n\n\tprivate static UnsupportedMediaTypeException unsupportedError(ResolvableType bodyType,\n\t\t\tBodyInserter.Context context, @Nullable MediaType mediaType) {\n\n\t\tList<MediaType> supportedMediaTypes = context.messageWriters().stream()\n\t\t\t\t.flatMap(reader -> reader.getWritableMediaTypes(bodyType).stream())\n\t\t\t\t.toList();\n\n\t\treturn new UnsupportedMediaTypeException(mediaType, supportedMediaTypes, bodyType);\n\t}\n\n\tprivate static <T> Mono<Void> write(Publisher<? extends T> input, ResolvableType type,\n\t\t\t@Nullable MediaType mediaType, ReactiveHttpOutputMessage message,\n\t\t\tBodyInserter.Context context, HttpMessageWriter<T> writer) {\n\n\t\treturn context.serverRequest()\n\t\t\t\t.map(request -> {\n\t\t\t\t\tServerHttpResponse response = (ServerHttpResponse) message;\n\t\t\t\t\treturn writer.write(input, type, type, mediaType, request, response, context.hints());\n\t\t\t\t})\n\t\t\t\t.orElseGet(() -> writer.write(input, type, mediaType, message, context.hints()));\n\t}\n\n\tprivate static <T> HttpMessageWriter<T> findWriter(\n\t\t\tBodyInserter.Context context, ResolvableType elementType, @Nullable MediaType mediaType) {\n\n\t\treturn context.messageWriters().stream()\n\t\t\t\t.filter(messageWriter -> messageWriter.canWrite(elementType, mediaType))\n\t\t\t\t.findFirst()\n\t\t\t\t.map(BodyInserters::<T>cast)\n\t\t\t\t.orElseThrow(() -> new IllegalStateException(\n\t\t\t\t\t\t\"No HttpMessageWriter for \\\"\" + mediaType + \"\\\" and \\\"\" + elementType + \"\\\"\"));\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static <T> HttpMessageWriter<T> cast(HttpMessageWriter<?> messageWriter) {\n\t\treturn (HttpMessageWriter<T>) messageWriter;\n\t}\n\n\n\t/**\n\t * Extension of {@link BodyInserter} that allows for adding form data or\n\t * multipart form data.\n\t *\n\t * @param <T> the value type\n\t */\n\tpublic interface FormInserter<T> extends BodyInserter<MultiValueMap<String, T>, ClientHttpRequest> {\n\n\t\t// FormInserter is parameterized to ClientHttpRequest (for client-side use only)\n\n\t\t/**\n\t\t * Adds the specified key-value pair to the form.\n\t\t * @param key the key to be added\n\t\t * @param value the value to be added\n\t\t * @return this inserter for adding more parts\n\t\t */\n\t\tFormInserter<T> with(String key, T value);\n\n\t\t/**\n\t\t * Adds the specified values to the form.\n\t\t * @param values the values to be added\n\t\t * @return this inserter for adding more parts\n\t\t */\n\t\tFormInserter<T> with(MultiValueMap<String, T> values);\n\n\t}\n\n\n\t/**\n\t * Extension of {@link FormInserter} that allows for adding asynchronous parts.\n\t */\n\tpublic interface MultipartInserter extends FormInserter<Object> {\n\n\t\t/**\n\t\t * Add an asynchronous part with {@link Publisher}-based content.\n\t\t * @param name the name of the part to add\n\t\t * @param publisher the part contents\n\t\t * @param elementClass the type of elements contained in the publisher\n\t\t * @return this inserter for adding more parts\n\t\t */\n\t\t<T, P extends Publisher<T>> MultipartInserter withPublisher(String name, P publisher,\n\t\t\t\tClass<T> elementClass);\n\n\t\t/**\n\t\t * Variant of {@link #withPublisher(String, Publisher, Class)} that accepts a\n\t\t * {@link ParameterizedTypeReference} for the element type, which allows\n\t\t * specifying generic type information.\n\t\t * @param name the key to be added\n\t\t * @param publisher the publisher to be added as value\n\t\t * @param typeReference the type of elements contained in {@code publisher}\n\t\t * @return this inserter for adding more parts\n\t\t */\n\t\t<T, P extends Publisher<T>> MultipartInserter withPublisher(String name, P publisher,\n\t\t\t\tParameterizedTypeReference<T> typeReference);\n\n\t}\n\n\n\tprivate static class DefaultFormInserter implements FormInserter<String> {\n\n\t\tprivate final MultiValueMap<String, String> data = new LinkedMultiValueMap<>();\n\n\t\t@Override\n\t\tpublic FormInserter<String> with(String key, @Nullable String value) {\n\t\t\tthis.data.add(key, value);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic FormInserter<String> with(MultiValueMap<String, String> values) {\n\t\t\tthis.data.addAll(values);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<Void> insert(ClientHttpRequest outputMessage, Context context) {\n\t\t\tHttpMessageWriter<MultiValueMap<String, String>> messageWriter =\n\t\t\t\t\tfindWriter(context, FORM_DATA_TYPE, MediaType.APPLICATION_FORM_URLENCODED);\n\t\t\treturn messageWriter.write(Mono.just(this.data), FORM_DATA_TYPE,\n\t\t\t\t\tMediaType.APPLICATION_FORM_URLENCODED,\n\t\t\t\t\toutputMessage, context.hints());\n\t\t}\n\t}\n\n\n\tprivate static class DefaultMultipartInserter implements MultipartInserter {\n\n\t\tprivate final MultipartBodyBuilder builder = new MultipartBodyBuilder();\n\n\t\t@Override\n\t\tpublic MultipartInserter with(String key, Object value) {\n\t\t\tthis.builder.part(key, value);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic MultipartInserter with(MultiValueMap<String, Object> values) {\n\t\t\treturn withInternal(values);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tprivate MultipartInserter withInternal(MultiValueMap<String, ?> values) {\n\t\t\tvalues.forEach((key, valueList) -> {\n\t\t\t\tfor (Object value : valueList) {\n\t\t\t\t\tthis.builder.part(key, value);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, P extends Publisher<T>> MultipartInserter withPublisher(\n\t\t\t\tString name, P publisher, Class<T> elementClass) {\n\n\t\t\tthis.builder.asyncPart(name, publisher, elementClass);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, P extends Publisher<T>> MultipartInserter withPublisher(\n\t\t\t\tString name, P publisher, ParameterizedTypeReference<T> typeReference) {\n\n\t\t\tthis.builder.asyncPart(name, publisher, typeReference);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<Void> insert(ClientHttpRequest outputMessage, Context context) {\n\t\t\tHttpMessageWriter<MultiValueMap<String, HttpEntity<?>>> messageWriter =\n\t\t\t\t\tfindWriter(context, MULTIPART_DATA_TYPE, MediaType.MULTIPART_FORM_DATA);\n\t\t\tMultiValueMap<String, HttpEntity<?>> body = this.builder.build();\n\t\t\treturn messageWriter.write(Mono.just(body), MULTIPART_DATA_TYPE,\n\t\t\t\t\tMediaType.MULTIPART_FORM_DATA, outputMessage, context.hints());\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.function.BodyInserters#empty()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter that does not write.\n\t * @return the inserter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> empty()",
    "source_code": "\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> empty() {\n\t\treturn (BodyInserter<T, ReactiveHttpOutputMessage>) EMPTY_INSERTER;\n\t}"
  },
  "org.springframework.web.reactive.function.BodyInserters#fromDataBuffers(publisher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given {@code Publisher<DataBuffer>} to the body.\n\t * @param publisher the data buffer publisher to write\n\t * @param <T> the type of the publisher\n\t * @return the inserter to write directly to the body\n\t * @see ReactiveHttpOutputMessage#writeWith(Publisher)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromDataBuffers(T publisher)",
    "source_code": "\tpublic static <T extends Publisher<DataBuffer>> BodyInserter<T, ReactiveHttpOutputMessage> fromDataBuffers("
  },
  "org.springframework.web.reactive.function.BodyInserters#fromFormData(MultiValueMap<String,formData)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link FormInserter} to write the given {@code MultiValueMap}\n\t * as URL-encoded form data. The returned inserter allows for additional\n\t * entries to be added via {@link FormInserter#with(String, Object)}.\n\t * <p>Note that you can also use the {@code bodyValue(Object)} method in the\n\t * request builders of both the {@code WebClient} and {@code WebTestClient}.\n\t * In that case the setting of the request content type is also not required,\n\t * just be sure the map contains String values only or otherwise it would be\n\t * interpreted as a multipart request.\n\t * @param formData the form data to write to the output message\n\t * @return the inserter that allows adding more form data\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "formData"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "FormInserter<String>",
    "signature": "public FormInserter<String> fromFormData(MultiValueMap<String, String> formData)",
    "source_code": "\tpublic static FormInserter<String> fromFormData(MultiValueMap<String, String> formData) {\n\t\treturn new DefaultFormInserter().with(formData);\n\t}"
  },
  "org.springframework.web.reactive.function.BodyInserters#fromFormData(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link FormInserter} to write the given key-value pair as\n\t * URL-encoded form data. The returned inserter allows for additional\n\t * entries to be added via {@link FormInserter#with(String, Object)}.\n\t * @param name the key to add to the form\n\t * @param value the value to add to the form\n\t * @return the inserter that allows adding more form data\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "FormInserter<String>",
    "signature": "public FormInserter<String> fromFormData(String name, String value)",
    "source_code": "\tpublic static FormInserter<String> fromFormData(String name, String value) {\n\t\tAssert.notNull(name, \"'name' must not be null\");\n\t\tAssert.notNull(value, \"'value' must not be null\");\n\t\treturn new DefaultFormInserter().with(name, value);\n\t}"
  },
  "org.springframework.web.reactive.function.BodyInserters#fromMultipartAsyncData(name,publisher,elementClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link MultipartInserter} to write the given asynchronous parts,\n\t * as multipart data.\n\t * <p>Note that you can also build the multipart data externally with\n\t * {@link MultipartBodyBuilder}, and pass the resulting map directly to the\n\t * {@code bodyValue(Object)} shortcut method in {@code WebClient}.\n\t * @param name the part name\n\t * @param publisher the publisher that forms the part value\n\t * @param elementClass the class contained in the {@code publisher}\n\t * @return the inserter that allows adding more parts\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter fromMultipartAsyncData(String name, P publisher, Class<T> elementClass)",
    "source_code": "\tpublic static <T, P extends Publisher<T>> MultipartInserter fromMultipartAsyncData("
  },
  "org.springframework.web.reactive.function.BodyInserters#fromMultipartAsyncData(name,publisher,typeReference)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #fromMultipartAsyncData(String, Publisher, Class)} that\n\t * accepts a {@link ParameterizedTypeReference} for the element type, which\n\t * allows specifying generic type information.\n\t * <p>Note that you can also build the multipart data externally with\n\t * {@link MultipartBodyBuilder}, and pass the resulting map directly to the\n\t * {@code bodyValue(Object)} shortcut method in {@code WebClient}.\n\t * @param name the part name\n\t * @param publisher the publisher that forms the part value\n\t * @param typeReference the type contained in the {@code publisher}\n\t * @return the inserter that allows adding more parts\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "typeReference"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter fromMultipartAsyncData(String name, P publisher, ParameterizedTypeReference<T> typeReference)",
    "source_code": "\tpublic static <T, P extends Publisher<T>> MultipartInserter fromMultipartAsyncData("
  },
  "org.springframework.web.reactive.function.BodyInserters#fromMultipartData(MultiValueMap<String,multipartData)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link MultipartInserter} to write the given\n\t * {@code MultiValueMap} as multipart data. Values in the map can be an\n\t * Object or an {@link HttpEntity}.\n\t * <p>Note that you can also build the multipart data externally with\n\t * {@link MultipartBodyBuilder}, and pass the resulting map directly to the\n\t * {@code bodyValue(Object)} shortcut method in {@code WebClient}.\n\t * @param multipartData the form data to write to the output message\n\t * @return the inserter that allows adding more parts\n\t * @see MultipartBodyBuilder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "multipartData"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter fromMultipartData(MultiValueMap<String, ?> multipartData)",
    "source_code": "\tpublic static MultipartInserter fromMultipartData(MultiValueMap<String, ?> multipartData) {\n\t\tAssert.notNull(multipartData, \"'multipartData' must not be null\");\n\t\treturn new DefaultMultipartInserter().withInternal(multipartData);\n\t}"
  },
  "org.springframework.web.reactive.function.BodyInserters#fromMultipartData(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link MultipartInserter} to write the given parts,\n\t * as multipart data. Values in the map can be an Object or an\n\t * {@link HttpEntity}.\n\t * <p>Note that you can also build the multipart data externally with\n\t * {@link MultipartBodyBuilder}, and pass the resulting map directly to the\n\t * {@code bodyValue(Object)} shortcut method in {@code WebClient}.\n\t * @param name the part name\n\t * @param value the part value, an Object or {@code HttpEntity}\n\t * @return the inserter that allows adding more parts\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter fromMultipartData(String name, Object value)",
    "source_code": "\tpublic static MultipartInserter fromMultipartData(String name, Object value) {\n\t\tAssert.notNull(name, \"'name' must not be null\");\n\t\tAssert.notNull(value, \"'value' must not be null\");\n\t\treturn new DefaultMultipartInserter().with(name, value);\n\t}"
  },
  "org.springframework.web.reactive.function.BodyInserters#fromObject(body)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given object.\n\t * <p>Alternatively, consider using the {@code bodyValue(Object)} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param body the body to write to the response\n\t * @param <T> the type of the body\n\t * @return the inserter to write a single object\n\t * @throws IllegalArgumentException if {@code body} is a {@link Publisher} or an\n\t * instance of a type supported by {@link ReactiveAdapterRegistry#getSharedInstance()},\n\t * for which {@link #fromPublisher(Publisher, Class)} or\n\t * {@link #fromProducer(Object, Class)} should be used.\n\t * @see #fromPublisher(Publisher, Class)\n\t * @see #fromProducer(Object, Class)\n\t * @deprecated As of Spring Framework 5.2, in favor of {@link #fromValue(Object)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromObject(T body)",
    "source_code": "\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromObject(T body) {\n\t\treturn fromValue(body);\n\t}"
  },
  "org.springframework.web.reactive.function.BodyInserters#fromProducer(producer,elementClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given producer of value(s) which must be a {@link Publisher}\n\t * or another producer adaptable to a {@code Publisher} via\n\t * {@link ReactiveAdapterRegistry}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param <T> the type of the body\n\t * @param producer the source of body value(s).\n\t * @param elementClass the class of values to be produced\n\t * @return the inserter to write a producer\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromProducer(T producer, Class<?> elementClass)",
    "source_code": "\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromProducer(T producer, Class<?> elementClass) {\n\t\tAssert.notNull(producer, \"'producer' must not be null\");\n\t\tAssert.notNull(elementClass, \"'elementClass' must not be null\");\n\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(producer.getClass());\n\t\tAssert.notNull(adapter, \"'producer' type is unknown to ReactiveAdapterRegistry\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, producer, ResolvableType.forClass(elementClass), adapter);\n\t}"
  },
  "org.springframework.web.reactive.function.BodyInserters#fromProducer(producer,elementTypeRef)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given producer of value(s) which must be a {@link Publisher}\n\t * or another producer adaptable to a {@code Publisher} via\n\t * {@link ReactiveAdapterRegistry}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param <T> the type of the body\n\t * @param producer the source of body value(s).\n\t * @param elementTypeRef the type of values to be produced\n\t * @return the inserter to write a producer\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromProducer(T producer, ParameterizedTypeReference<?> elementTypeRef)",
    "source_code": "\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromProducer("
  },
  "org.springframework.web.reactive.function.BodyInserters#fromPublisher(publisher,elementClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given {@link Publisher}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param publisher the publisher to write with\n\t * @param elementClass the class of elements in the publisher\n\t * @param <T> the type of the elements contained in the publisher\n\t * @param <P> the {@code Publisher} type\n\t * @return the inserter to write a {@code Publisher}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromPublisher(P publisher, Class<T> elementClass)",
    "source_code": "\tpublic static <T, P extends Publisher<T>> BodyInserter<P, ReactiveHttpOutputMessage> fromPublisher("
  },
  "org.springframework.web.reactive.function.BodyInserters#fromPublisher(publisher,elementTypeRef)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given {@link Publisher}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param publisher the publisher to write with\n\t * @param elementTypeRef the type of elements contained in the publisher\n\t * @param <T> the type of the elements contained in the publisher\n\t * @param <P> the {@code Publisher} type\n\t * @return the inserter to write a {@code Publisher}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "elementTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromPublisher(P publisher, ParameterizedTypeReference<T> elementTypeRef)",
    "source_code": "\tpublic static <T, P extends Publisher<T>> BodyInserter<P, ReactiveHttpOutputMessage> fromPublisher("
  },
  "org.springframework.web.reactive.function.BodyInserters#fromResource(resource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given {@code Resource}.\n\t * <p>If the resource can be resolved to a {@linkplain Resource#getFile() file}, it will\n\t * be copied using <a href=\"https://en.wikipedia.org/wiki/Zero-copy\">zero-copy</a>.\n\t * @param resource the resource to write to the output message\n\t * @param <T> the type of the {@code Resource}\n\t * @return the inserter to write a {@code Publisher}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromResource(T resource)",
    "source_code": "\tpublic static <T extends Resource> BodyInserter<T, ReactiveHttpOutputMessage> fromResource(T resource) {\n\t\tAssert.notNull(resource, \"'resource' must not be null\");\n\t\treturn (outputMessage, context) -> {\n\t\t\tResolvableType elementType = RESOURCE_TYPE;\n\t\t\tHttpMessageWriter<Resource> writer = findWriter(context, elementType, null);\n\t\t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n\t\t\treturn write(Mono.just(resource), elementType, contentType, outputMessage, context, writer);\n\t\t};\n\t}"
  },
  "org.springframework.web.reactive.function.BodyInserters#fromServerSentEvents(eventsPublisher)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "eventsPublisher"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "ServerHttpResponse>",
    "signature": "public ServerHttpResponse> fromServerSentEvents(S eventsPublisher)",
    "source_code": "\tpublic static <T, S extends Publisher<ServerSentEvent<T>>> BodyInserter<S, ServerHttpResponse> fromServerSentEvents("
  },
  "org.springframework.web.reactive.function.BodyInserters#fromValue(body)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given value.\n\t * <p>Alternatively, consider using the {@code bodyValue(Object)} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param body the value to write\n\t * @param <T> the type of the body\n\t * @return the inserter to write a single value\n\t * @throws IllegalArgumentException if {@code body} is a {@link Publisher} or an\n\t * instance of a type supported by {@link ReactiveAdapterRegistry#getSharedInstance()},\n\t * for which {@link #fromPublisher(Publisher, Class)} or\n\t * {@link #fromProducer(Object, Class)} should be used.\n\t * @see #fromPublisher(Publisher, Class)\n\t * @see #fromProducer(Object, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromValue(T body)",
    "source_code": "\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromValue(T body) {\n\t\tAssert.notNull(body, \"'body' must not be null\");\n\t\tAssert.isNull(registry.getAdapter(body.getClass()),\n\t\t\t\t\"'body' should be an object, for reactive types use a variant specifying a publisher/producer and its related element type\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, Mono.just(body), ResolvableType.forInstance(body), null);\n\t}"
  },
  "org.springframework.web.reactive.function.BodyInserters#insert(outputMessage,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputMessage",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 550
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> insert(ClientHttpRequest outputMessage, Context context)",
    "source_code": "\t\tpublic Mono<Void> insert(ClientHttpRequest outputMessage, Context context) {\n\t\t\tHttpMessageWriter<MultiValueMap<String, HttpEntity<?>>> messageWriter =\n\t\t\t\t\tfindWriter(context, MULTIPART_DATA_TYPE, MediaType.MULTIPART_FORM_DATA);\n\t\t\tMultiValueMap<String, HttpEntity<?>> body = this.builder.build();\n\t\t\treturn messageWriter.write(Mono.just(body), MULTIPART_DATA_TYPE,\n\t\t\t\t\tMediaType.MULTIPART_FORM_DATA, outputMessage, context.hints());\n\t\t}"
  },
  "org.springframework.web.reactive.function.BodyInserters#with(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 519
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter with(MultiValueMap<String, Object> values)",
    "source_code": "\t\tpublic MultipartInserter with(MultiValueMap<String, Object> values) {\n\t\t\treturn withInternal(values);\n\t\t}"
  },
  "org.springframework.web.reactive.function.BodyInserters#with(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 513
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter with(String key, Object value)",
    "source_code": "\t\tpublic MultipartInserter with(String key, Object value) {\n\t\t\tthis.builder.part(key, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.BodyInserters#withPublisher(name,publisher,elementClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter withPublisher(String name, P publisher, Class<T> elementClass)",
    "source_code": "\t\tpublic <T, P extends Publisher<T>> MultipartInserter withPublisher("
  },
  "org.springframework.web.reactive.function.BodyInserters#withPublisher(name,publisher,typeReference)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "typeReference"
    ],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter withPublisher(String name, P publisher, ParameterizedTypeReference<T> typeReference)",
    "source_code": "\t\tpublic <T, P extends Publisher<T>> MultipartInserter withPublisher("
  },
  "org.springframework.web.reactive.function.FormInserter": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension of {@link BodyInserter} that allows for adding form data or\n\t * multipart form data.\n\t *\n\t * @param <T> the value type\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "signature": "public interface FormInserter",
    "source_code": "\tpublic interface FormInserter<T> extends BodyInserter<MultiValueMap<String, T>, ClientHttpRequest> {\n\n\t\t// FormInserter is parameterized to ClientHttpRequest (for client-side use only)\n\n\t\t/**\n\t\t * Adds the specified key-value pair to the form.\n\t\t * @param key the key to be added\n\t\t * @param value the value to be added\n\t\t * @return this inserter for adding more parts\n\t\t */\n\t\tFormInserter<T> with(String key, T value);\n\n\t\t/**\n\t\t * Adds the specified values to the form.\n\t\t * @param values the values to be added\n\t\t * @return this inserter for adding more parts\n\t\t */\n\t\tFormInserter<T> with(MultiValueMap<String, T> values);\n\n\t}"
  },
  "org.springframework.web.reactive.function.MultipartInserter": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension of {@link FormInserter} that allows for adding asynchronous parts.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "signature": "public interface MultipartInserter",
    "source_code": "\tpublic interface MultipartInserter extends FormInserter<Object> {\n\n\t\t/**\n\t\t * Add an asynchronous part with {@link Publisher}-based content.\n\t\t * @param name the name of the part to add\n\t\t * @param publisher the part contents\n\t\t * @param elementClass the type of elements contained in the publisher\n\t\t * @return this inserter for adding more parts\n\t\t */\n\t\t<T, P extends Publisher<T>> MultipartInserter withPublisher(String name, P publisher,\n\t\t\t\tClass<T> elementClass);\n\n\t\t/**\n\t\t * Variant of {@link #withPublisher(String, Publisher, Class)} that accepts a\n\t\t * {@link ParameterizedTypeReference} for the element type, which allows\n\t\t * specifying generic type information.\n\t\t * @param name the key to be added\n\t\t * @param publisher the publisher to be added as value\n\t\t * @param typeReference the type of elements contained in {@code publisher}\n\t\t * @return this inserter for adding more parts\n\t\t */\n\t\t<T, P extends Publisher<T>> MultipartInserter withPublisher(String name, P publisher,\n\t\t\t\tParameterizedTypeReference<T> typeReference);\n\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#apply(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "Mono<Resource>",
    "signature": "public Mono<Resource> apply(ServerRequest request)",
    "source_code": "\tpublic Mono<Resource> apply(ServerRequest request) {\n\t\tPathContainer pathContainer = request.requestPath().pathWithinApplication();\n\t\tif (!this.pattern.matches(pathContainer)) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tpathContainer = this.pattern.extractPathWithinPattern(pathContainer);\n\t\tString path = processPath(pathContainer.value());\n\t\tif (path.contains(\"%\")) {\n\t\t\tpath = StringUtils.uriDecode(path, StandardCharsets.UTF_8);\n\t\t}\n\t\tif (!StringUtils.hasLength(path) || isInvalidPath(path)) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\ttry {\n\t\t\tResource resource = this.location.createRelative(path);\n\t\t\tif (resource.isReadable() && isResourceUnderLocation(resource)) {\n\t\t\t\treturn Mono.just(resource);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Mono.empty();\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new UncheckedIOException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#build()": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "Mono<RenderingResponse>",
    "signature": "public Mono<RenderingResponse> build()",
    "source_code": "\tpublic Mono<RenderingResponse> build() {\n\t\treturn Mono.just(\n\t\t\t\tnew DefaultRenderingResponse(this.status, this.headers, this.cookies, this.name, this.model));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn this.pattern + \" -> \" + this.location;\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Implementations of {@link RequestPredicate} that implement various useful\n * request matching operations, such as matching based on path, HTTP method, etc.\n *\n * @author Arjen Poutsma\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "signature": "public class RequestPredicates",
    "source_code": "public abstract class RequestPredicates {\n\n\tprivate static final Log logger = LogFactory.getLog(RequestPredicates.class);\n\n\n\t/**\n\t * Return a {@code RequestPredicate} that always matches.\n\t * @return a predicate that always matches\n\t */\n\tpublic static RequestPredicate all() {\n\t\treturn request -> true;\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's\n\t * HTTP method is equal to the given method.\n\t * @param httpMethod the HTTP method to match against\n\t * @return a predicate that tests against the given HTTP method\n\t */\n\tpublic static RequestPredicate method(HttpMethod httpMethod) {\n\t\treturn new HttpMethodPredicate(httpMethod);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's\n\t * HTTP method is equal to one the of the given methods.\n\t * @param httpMethods the HTTP methods to match against\n\t * @return a predicate that tests against the given HTTP methods\n\t * @since 5.1\n\t */\n\tpublic static RequestPredicate methods(HttpMethod... httpMethods) {\n\t\treturn new HttpMethodPredicate(httpMethods);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that tests the request path\n\t * against the given path pattern.\n\t * @param pattern the pattern to match to\n\t * @return a predicate that tests against the given path pattern\n\t */\n\tpublic static RequestPredicate path(String pattern) {\n\t\tAssert.notNull(pattern, \"'pattern' must not be null\");\n\t\tif (!pattern.isEmpty() && !pattern.startsWith(\"/\")) {\n\t\t\tpattern = \"/\" + pattern;\n\t\t}\n\t\treturn pathPredicates(PathPatternParser.defaultInstance).apply(pattern);\n\t}\n\n\t/**\n\t * Return a function that creates new path-matching {@code RequestPredicates}\n\t * from pattern Strings using the given {@link PathPatternParser}.\n\t * <p>This method can be used to specify a non-default, customized\n\t * {@code PathPatternParser} when resolving path patterns.\n\t * @param patternParser the parser used to parse patterns given to the returned function\n\t * @return a function that resolves a pattern String into a path-matching\n\t * {@code RequestPredicates} instance\n\t */\n\tpublic static Function<String, RequestPredicate> pathPredicates(PathPatternParser patternParser) {\n\t\tAssert.notNull(patternParser, \"PathPatternParser must not be null\");\n\t\treturn pattern -> new PathPatternPredicate(patternParser.parse(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that tests the request's headers\n\t * against the given headers predicate.\n\t * @param headersPredicate a predicate that tests against the request headers\n\t * @return a predicate that tests against the given header predicate\n\t */\n\tpublic static RequestPredicate headers(Predicate<ServerRequest.Headers> headersPredicate) {\n\t\treturn new HeadersPredicate(headersPredicate);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that tests if the request's\n\t * {@linkplain ServerRequest.Headers#contentType() content type} is\n\t * {@linkplain MediaType#includes(MediaType) included} by any of the given media types.\n\t * @param mediaTypes the media types to match the request's content type against\n\t * @return a predicate that tests the request's content type against the given media types\n\t */\n\tpublic static RequestPredicate contentType(MediaType... mediaTypes) {\n\t\tAssert.notEmpty(mediaTypes, \"'mediaTypes' must not be empty\");\n\t\treturn new ContentTypePredicate(mediaTypes);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that tests if the request's\n\t * {@linkplain ServerRequest.Headers#accept() accept} header is\n\t * {@linkplain MediaType#isCompatibleWith(MediaType) compatible} with any of the given media types.\n\t * @param mediaTypes the media types to match the request's accept header against\n\t * @return a predicate that tests the request's accept header against the given media types\n\t */\n\tpublic static RequestPredicate accept(MediaType... mediaTypes) {\n\t\tAssert.notEmpty(mediaTypes, \"'mediaTypes' must not be empty\");\n\t\treturn new AcceptPredicate(mediaTypes);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code GET}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is GET and if the given pattern\n\t * matches against the request path\n\t */\n\tpublic static RequestPredicate GET(String pattern) {\n\t\treturn method(HttpMethod.GET).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code HEAD}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is HEAD and if the given pattern\n\t * matches against the request path\n\t */\n\tpublic static RequestPredicate HEAD(String pattern) {\n\t\treturn method(HttpMethod.HEAD).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code POST}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is POST and if the given pattern\n\t * matches against the request path\n\t */\n\tpublic static RequestPredicate POST(String pattern) {\n\t\treturn method(HttpMethod.POST).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code PUT}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is PUT and if the given pattern\n\t * matches against the request path\n\t */\n\tpublic static RequestPredicate PUT(String pattern) {\n\t\treturn method(HttpMethod.PUT).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code PATCH}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is PATCH and if the given pattern\n\t * matches against the request path\n\t */\n\tpublic static RequestPredicate PATCH(String pattern) {\n\t\treturn method(HttpMethod.PATCH).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code DELETE}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is DELETE and if the given pattern\n\t * matches against the request path\n\t */\n\tpublic static RequestPredicate DELETE(String pattern) {\n\t\treturn method(HttpMethod.DELETE).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code OPTIONS}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is OPTIONS and if the given pattern\n\t * matches against the request path\n\t */\n\tpublic static RequestPredicate OPTIONS(String pattern) {\n\t\treturn method(HttpMethod.OPTIONS).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's path has the given extension.\n\t * @param extension the path extension to match against, ignoring case\n\t * @return a predicate that matches if the request's path has the given file extension\n\t */\n\tpublic static RequestPredicate pathExtension(String extension) {\n\t\tAssert.notNull(extension, \"'extension' must not be null\");\n\t\treturn new PathExtensionPredicate(extension);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's path matches the given\n\t * predicate.\n\t * @param extensionPredicate the predicate to test against the request path extension\n\t * @return a predicate that matches if the given predicate matches against the request's path\n\t * file extension\n\t */\n\tpublic static RequestPredicate pathExtension(Predicate<String> extensionPredicate) {\n\t\treturn new PathExtensionPredicate(extensionPredicate);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's query parameter of the given name\n\t * has the given value.\n\t * @param name the name of the query parameter to test against\n\t * @param value the value of the query parameter to test against\n\t * @return a predicate that matches if the query parameter has the given value\n\t * @since 5.0.7\n\t * @see ServerRequest#queryParam(String)\n\t */\n\tpublic static RequestPredicate queryParam(String name, String value) {\n\t\treturn new QueryParamPredicate(name, value);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that tests the request's query parameter of the given name\n\t * against the given predicate.\n\t * @param name the name of the query parameter to test against\n\t * @param predicate the predicate to test against the query parameter value\n\t * @return a predicate that matches the given predicate against the query parameter of the given name\n\t * @see ServerRequest#queryParam(String)\n\t */\n\tpublic static RequestPredicate queryParam(String name, Predicate<String> predicate) {\n\t\treturn new QueryParamPredicate(name, predicate);\n\t}\n\n\n\tprivate static void traceMatch(String prefix, Object desired, @Nullable Object actual, boolean match) {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(String.format(\"%s \\\"%s\\\" %s against value \\\"%s\\\"\",\n\t\t\t\t\tprefix, desired, match ? \"matches\" : \"does not match\", actual));\n\t\t}\n\t}\n\n\tprivate static void restoreAttributes(ServerRequest request, Map<String, Object> attributes) {\n\t\trequest.attributes().clear();\n\t\trequest.attributes().putAll(attributes);\n\t}\n\n\tprivate static Map<String, String> mergePathVariables(Map<String, String> oldVariables,\n\t\t\tMap<String, String> newVariables) {\n\n\t\tif (!newVariables.isEmpty()) {\n\t\t\tMap<String, String> mergedVariables = new LinkedHashMap<>(oldVariables);\n\t\t\tmergedVariables.putAll(newVariables);\n\t\t\treturn mergedVariables;\n\t\t}\n\t\telse {\n\t\t\treturn oldVariables;\n\t\t}\n\t}\n\n\tprivate static PathPattern mergePatterns(@Nullable PathPattern oldPattern, PathPattern newPattern) {\n\t\tif (oldPattern != null) {\n\t\t\treturn oldPattern.combine(newPattern);\n\t\t}\n\t\telse {\n\t\t\treturn newPattern;\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Receives notifications from the logical structure of request predicates.\n\t */\n\tpublic interface Visitor {\n\n\t\t/**\n\t\t * Receive notification of an HTTP method predicate.\n\t\t * @param methods the HTTP methods that make up the predicate\n\t\t * @see RequestPredicates#method(HttpMethod)\n\t\t */\n\t\tvoid method(Set<HttpMethod> methods);\n\n\t\t/**\n\t\t * Receive notification of a path predicate.\n\t\t * @param pattern the path pattern that makes up the predicate\n\t\t * @see RequestPredicates#path(String)\n\t\t */\n\t\tvoid path(String pattern);\n\n\t\t/**\n\t\t * Receive notification of a path extension predicate.\n\t\t * @param extension the path extension that makes up the predicate\n\t\t * @see RequestPredicates#pathExtension(String)\n\t\t */\n\t\tvoid pathExtension(String extension);\n\n\t\t/**\n\t\t * Receive notification of an HTTP header predicate.\n\t\t * @param name the name of the HTTP header to check\n\t\t * @param value the desired value of the HTTP header\n\t\t * @see RequestPredicates#headers(Predicate)\n\t\t * @see RequestPredicates#contentType(MediaType...)\n\t\t * @see RequestPredicates#accept(MediaType...)\n\t\t */\n\t\tvoid header(String name, String value);\n\n\t\t/**\n\t\t * Receive notification of a query parameter predicate.\n\t\t * @param name the name of the query parameter\n\t\t * @param value the desired value of the parameter\n\t\t * @see RequestPredicates#queryParam(String, String)\n\t\t */\n\t\tvoid queryParam(String name, String value);\n\n\t\t/**\n\t\t * Receive first notification of a logical AND predicate.\n\t\t * The first subsequent notification will contain the left-hand side of the AND-predicate;\n\t\t * followed by {@link #and()}, followed by the right-hand side, followed by {@link #endAnd()}.\n\t\t * @see RequestPredicate#and(RequestPredicate)\n\t\t */\n\t\tvoid startAnd();\n\n\t\t/**\n\t\t * Receive \"middle\" notification of a logical AND predicate.\n\t\t * The following notification contains the right-hand side, followed by {@link #endAnd()}.\n\t\t * @see RequestPredicate#and(RequestPredicate)\n\t\t */\n\t\tvoid and();\n\n\t\t/**\n\t\t * Receive last notification of a logical AND predicate.\n\t\t * @see RequestPredicate#and(RequestPredicate)\n\t\t */\n\t\tvoid endAnd();\n\n\t\t/**\n\t\t * Receive first notification of a logical OR predicate.\n\t\t * The first subsequent notification will contain the left-hand side of the OR-predicate;\n\t\t * the second notification contains the right-hand side, followed by {@link #endOr()}.\n\t\t * @see RequestPredicate#or(RequestPredicate)\n\t\t */\n\t\tvoid startOr();\n\n\t\t/**\n\t\t * Receive \"middle\" notification of a logical OR predicate.\n\t\t * The following notification contains the right-hand side, followed by {@link #endOr()}.\n\t\t * @see RequestPredicate#or(RequestPredicate)\n\t\t */\n\t\tvoid or();\n\n\t\t/**\n\t\t * Receive last notification of a logical OR predicate.\n\t\t * @see RequestPredicate#or(RequestPredicate)\n\t\t */\n\t\tvoid endOr();\n\n\t\t/**\n\t\t * Receive first notification of a negated predicate.\n\t\t * The first subsequent notification will contain the negated predicated, followed\n\t\t * by {@link #endNegate()}.\n\t\t * @see RequestPredicate#negate()\n\t\t */\n\t\tvoid startNegate();\n\n\t\t/**\n\t\t * Receive last notification of a negated predicate.\n\t\t * @see RequestPredicate#negate()\n\t\t */\n\t\tvoid endNegate();\n\n\t\t/**\n\t\t * Receive first notification of an unknown predicate.\n\t\t */\n\t\tvoid unknown(RequestPredicate predicate);\n\t}\n\n\n\tprivate static class HttpMethodPredicate implements RequestPredicate {\n\n\t\tprivate final Set<HttpMethod> httpMethods;\n\n\t\tpublic HttpMethodPredicate(HttpMethod httpMethod) {\n\t\t\tAssert.notNull(httpMethod, \"HttpMethod must not be null\");\n\t\t\tthis.httpMethods = Collections.singleton(httpMethod);\n\t\t}\n\n\t\tpublic HttpMethodPredicate(HttpMethod... httpMethods) {\n\t\t\tAssert.notEmpty(httpMethods, \"HttpMethods must not be empty\");\n\t\t\tthis.httpMethods = new LinkedHashSet<>(Arrays.asList(httpMethods));\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(ServerRequest request) {\n\t\t\tHttpMethod method = method(request);\n\t\t\tboolean match = this.httpMethods.contains(method);\n\t\t\ttraceMatch(\"Method\", this.httpMethods, method, match);\n\t\t\treturn match;\n\t\t}\n\n\t\tprivate static HttpMethod method(ServerRequest request) {\n\t\t\tif (CorsUtils.isPreFlightRequest(request.exchange().getRequest())) {\n\t\t\t\tString accessControlRequestMethod =\n\t\t\t\t\t\trequest.headers().firstHeader(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD);\n\t\t\t\tif (accessControlRequestMethod != null) {\n\t\t\t\t\treturn HttpMethod.valueOf(accessControlRequestMethod);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn request.method();\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.method(Collections.unmodifiableSet(this.httpMethods));\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (this.httpMethods.size() == 1) {\n\t\t\t\treturn this.httpMethods.iterator().next().toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.httpMethods.toString();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static class PathPatternPredicate implements RequestPredicate, ChangePathPatternParserVisitor.Target {\n\n\t\tprivate PathPattern pattern;\n\n\t\tpublic PathPatternPredicate(PathPattern pattern) {\n\t\t\tAssert.notNull(pattern, \"'pattern' must not be null\");\n\t\t\tthis.pattern = pattern;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(ServerRequest request) {\n\t\t\tPathContainer pathContainer = request.requestPath().pathWithinApplication();\n\t\t\tPathPattern.PathMatchInfo info = this.pattern.matchAndExtract(pathContainer);\n\t\t\ttraceMatch(\"Pattern\", this.pattern.getPatternString(), request.path(), info != null);\n\t\t\tif (info != null) {\n\t\t\t\tmergeAttributes(request, info.getUriVariables(), this.pattern);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tprivate static void mergeAttributes(ServerRequest request, Map<String, String> variables,\n\t\t\t\tPathPattern pattern) {\n\t\t\tMap<String, String> pathVariables = mergePathVariables(request.pathVariables(), variables);\n\t\t\trequest.attributes().put(RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE,\n\t\t\t\t\t\tCollections.unmodifiableMap(pathVariables));\n\n\t\t\tpattern = mergePatterns(\n\t\t\t\t\t(PathPattern) request.attributes().get(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE),\n\t\t\t\t\tpattern);\n\t\t\trequest.attributes().put(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE, pattern);\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<ServerRequest> nest(ServerRequest request) {\n\t\t\treturn Optional.ofNullable(this.pattern.matchStartOfPath(request.requestPath().pathWithinApplication()))\n\t\t\t\t\t.map(info -> new SubPathServerRequestWrapper(request, info, this.pattern));\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.path(this.pattern.getPatternString());\n\t\t}\n\n\t\t@Override\n\t\tpublic void changeParser(PathPatternParser parser) {\n\t\t\tString patternString = this.pattern.getPatternString();\n\t\t\tthis.pattern = parser.parse(patternString);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.pattern.getPatternString();\n\t\t}\n\t}\n\n\n\tprivate static class HeadersPredicate implements RequestPredicate {\n\n\t\tprivate final Predicate<ServerRequest.Headers> headersPredicate;\n\n\t\tpublic HeadersPredicate(Predicate<ServerRequest.Headers> headersPredicate) {\n\t\t\tAssert.notNull(headersPredicate, \"Predicate must not be null\");\n\t\t\tthis.headersPredicate = headersPredicate;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(ServerRequest request) {\n\t\t\tif (CorsUtils.isPreFlightRequest(request.exchange().getRequest())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.headersPredicate.test(request.headers());\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.headersPredicate.toString();\n\t\t}\n\t}\n\n\n\tprivate static class ContentTypePredicate extends HeadersPredicate {\n\n\t\tprivate final Set<MediaType> mediaTypes;\n\n\t\tpublic ContentTypePredicate(MediaType... mediaTypes) {\n\t\t\tthis(Set.of(mediaTypes));\n\t\t}\n\n\t\tprivate ContentTypePredicate(Set<MediaType> mediaTypes) {\n\t\t\tsuper(headers -> {\n\t\t\t\tMediaType contentType =\n\t\t\t\t\t\theaders.contentType().orElse(MediaType.APPLICATION_OCTET_STREAM);\n\t\t\t\tboolean match = mediaTypes.stream()\n\t\t\t\t\t\t.anyMatch(mediaType -> mediaType.includes(contentType));\n\t\t\t\ttraceMatch(\"Content-Type\", mediaTypes, contentType, match);\n\t\t\t\treturn match;\n\t\t\t});\n\t\t\tthis.mediaTypes = mediaTypes;\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.header(HttpHeaders.CONTENT_TYPE,\n\t\t\t\t\t(this.mediaTypes.size() == 1) ?\n\t\t\t\t\t\t\tthis.mediaTypes.iterator().next().toString() :\n\t\t\t\t\t\t\tthis.mediaTypes.toString());\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"Content-Type: %s\",\n\t\t\t\t\t(this.mediaTypes.size() == 1) ?\n\t\t\t\t\t\t\tthis.mediaTypes.iterator().next().toString() :\n\t\t\t\t\t\t\tthis.mediaTypes.toString());\n\t\t}\n\t}\n\n\n\tprivate static class AcceptPredicate extends HeadersPredicate {\n\n\t\tprivate final Set<MediaType> mediaTypes;\n\n\t\tpublic AcceptPredicate(MediaType... mediaTypes) {\n\t\t\tthis(Set.of(mediaTypes));\n\t\t}\n\n\t\tprivate AcceptPredicate(Set<MediaType> mediaTypes) {\n\t\t\tsuper(headers -> {\n\t\t\t\tList<MediaType> acceptedMediaTypes = acceptedMediaTypes(headers);\n\t\t\t\tboolean match = acceptedMediaTypes.stream()\n\t\t\t\t\t\t.anyMatch(acceptedMediaType -> mediaTypes.stream()\n\t\t\t\t\t\t\t\t.anyMatch(acceptedMediaType::isCompatibleWith));\n\t\t\t\ttraceMatch(\"Accept\", mediaTypes, acceptedMediaTypes, match);\n\t\t\t\treturn match;\n\t\t\t});\n\t\t\tthis.mediaTypes = mediaTypes;\n\t\t}\n\n\t\t@NonNull\n\t\tprivate static List<MediaType> acceptedMediaTypes(ServerRequest.Headers headers) {\n\t\t\tList<MediaType> acceptedMediaTypes = headers.accept();\n\t\t\tif (acceptedMediaTypes.isEmpty()) {\n\t\t\t\tacceptedMediaTypes = Collections.singletonList(MediaType.ALL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMimeTypeUtils.sortBySpecificity(acceptedMediaTypes);\n\t\t\t}\n\t\t\treturn acceptedMediaTypes;\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.header(HttpHeaders.ACCEPT,\n\t\t\t\t\t(this.mediaTypes.size() == 1) ?\n\t\t\t\t\t\t\tthis.mediaTypes.iterator().next().toString() :\n\t\t\t\t\t\t\tthis.mediaTypes.toString());\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"Accept: %s\",\n\t\t\t\t\t(this.mediaTypes.size() == 1) ?\n\t\t\t\t\t\t\tthis.mediaTypes.iterator().next().toString() :\n\t\t\t\t\t\t\tthis.mediaTypes.toString());\n\t\t}\n\t}\n\n\n\tprivate static class PathExtensionPredicate implements RequestPredicate {\n\n\t\tprivate final Predicate<String> extensionPredicate;\n\n\t\t@Nullable\n\t\tprivate final String extension;\n\n\t\tpublic PathExtensionPredicate(Predicate<String> extensionPredicate) {\n\t\t\tAssert.notNull(extensionPredicate, \"Predicate must not be null\");\n\t\t\tthis.extensionPredicate = extensionPredicate;\n\t\t\tthis.extension = null;\n\t\t}\n\n\t\tpublic PathExtensionPredicate(String extension) {\n\t\t\tAssert.notNull(extension, \"Extension must not be null\");\n\n\t\t\tthis.extensionPredicate = s -> {\n\t\t\t\tboolean match = extension.equalsIgnoreCase(s);\n\t\t\t\ttraceMatch(\"Extension\", extension, s, match);\n\t\t\t\treturn match;\n\t\t\t};\n\t\t\tthis.extension = extension;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(ServerRequest request) {\n\t\t\tString pathExtension = UriUtils.extractFileExtension(request.path());\n\t\t\treturn this.extensionPredicate.test(pathExtension);\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.pathExtension(\n\t\t\t\t\t(this.extension != null) ?\n\t\t\t\t\t\t\tthis.extension :\n\t\t\t\t\t\t\tthis.extensionPredicate.toString());\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"*.%s\",\n\t\t\t\t\t(this.extension != null) ?\n\t\t\t\t\t\t\tthis.extension :\n\t\t\t\t\t\t\tthis.extensionPredicate);\n\t\t}\n\t}\n\n\n\tprivate static class QueryParamPredicate implements RequestPredicate {\n\n\t\tprivate final String name;\n\n\t\tprivate final Predicate<String> valuePredicate;\n\n\t\t@Nullable\n\t\tprivate final String value;\n\n\t\tpublic QueryParamPredicate(String name, Predicate<String> valuePredicate) {\n\t\t\tAssert.notNull(name, \"Name must not be null\");\n\t\t\tAssert.notNull(valuePredicate, \"Predicate must not be null\");\n\t\t\tthis.name = name;\n\t\t\tthis.valuePredicate = valuePredicate;\n\t\t\tthis.value = null;\n\t\t}\n\n\t\tpublic QueryParamPredicate(String name, String value) {\n\t\t\tAssert.notNull(name, \"Name must not be null\");\n\t\t\tAssert.notNull(value, \"Value must not be null\");\n\t\t\tthis.name = name;\n\t\t\tthis.valuePredicate = value::equals;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(ServerRequest request) {\n\t\t\tOptional<String> s = request.queryParam(this.name);\n\t\t\treturn s.filter(this.valuePredicate).isPresent();\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.queryParam(this.name,\n\t\t\t\t\t(this.value != null) ?\n\t\t\t\t\t\t\tthis.value :\n\t\t\t\t\t\t\tthis.valuePredicate.toString());\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"?%s %s\", this.name,\n\t\t\t\t\t(this.value != null) ?\n\t\t\t\t\t\t\tthis.value :\n\t\t\t\t\t\t\tthis.valuePredicate);\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link RequestPredicate} for where both {@code left} and {@code right} predicates\n\t * must match.\n\t */\n\tstatic class AndRequestPredicate implements RequestPredicate, ChangePathPatternParserVisitor.Target {\n\n\t\tprivate final RequestPredicate left;\n\n\t\tprivate final RequestPredicate right;\n\n\t\tpublic AndRequestPredicate(RequestPredicate left, RequestPredicate right) {\n\t\t\tAssert.notNull(left, \"Left RequestPredicate must not be null\");\n\t\t\tAssert.notNull(right, \"Right RequestPredicate must not be null\");\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(ServerRequest request) {\n\t\t\tMap<String, Object> oldAttributes = new HashMap<>(request.attributes());\n\n\t\t\tif (this.left.test(request) && this.right.test(request)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\trestoreAttributes(request, oldAttributes);\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<ServerRequest> nest(ServerRequest request) {\n\t\t\treturn this.left.nest(request).flatMap(this.right::nest);\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.startAnd();\n\t\t\tthis.left.accept(visitor);\n\t\t\tvisitor.and();\n\t\t\tthis.right.accept(visitor);\n\t\t\tvisitor.endAnd();\n\t\t}\n\n\t\t@Override\n\t\tpublic void changeParser(PathPatternParser parser) {\n\t\t\tif (this.left instanceof ChangePathPatternParserVisitor.Target leftTarget) {\n\t\t\t\tleftTarget.changeParser(parser);\n\t\t\t}\n\t\t\tif (this.right instanceof ChangePathPatternParserVisitor.Target rightTarget) {\n\t\t\t\trightTarget.changeParser(parser);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"(%s && %s)\", this.left, this.right);\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link RequestPredicate} that negates a delegate predicate.\n\t */\n\tstatic class NegateRequestPredicate implements RequestPredicate, ChangePathPatternParserVisitor.Target {\n\n\t\tprivate final RequestPredicate delegate;\n\n\t\tpublic NegateRequestPredicate(RequestPredicate delegate) {\n\t\t\tAssert.notNull(delegate, \"Delegate must not be null\");\n\t\t\tthis.delegate = delegate;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(ServerRequest request) {\n\t\t\tMap<String, Object> oldAttributes = new HashMap<>(request.attributes());\n\t\t\tboolean result = !this.delegate.test(request);\n\t\t\tif (!result) {\n\t\t\t\trestoreAttributes(request, oldAttributes);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.startNegate();\n\t\t\tthis.delegate.accept(visitor);\n\t\t\tvisitor.endNegate();\n\t\t}\n\n\t\t@Override\n\t\tpublic void changeParser(PathPatternParser parser) {\n\t\t\tif (this.delegate instanceof ChangePathPatternParserVisitor.Target target) {\n\t\t\t\ttarget.changeParser(parser);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"!\" + this.delegate.toString();\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link RequestPredicate} where either {@code left} or {@code right} predicates\n\t * may match.\n\t */\n\tstatic class OrRequestPredicate implements RequestPredicate, ChangePathPatternParserVisitor.Target {\n\n\t\tprivate final RequestPredicate left;\n\n\t\tprivate final RequestPredicate right;\n\n\t\tpublic OrRequestPredicate(RequestPredicate left, RequestPredicate right) {\n\t\t\tAssert.notNull(left, \"Left RequestPredicate must not be null\");\n\t\t\tAssert.notNull(right, \"Right RequestPredicate must not be null\");\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(ServerRequest request) {\n\t\t\tMap<String, Object> oldAttributes = new HashMap<>(request.attributes());\n\n\t\t\tif (this.left.test(request)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trestoreAttributes(request, oldAttributes);\n\t\t\t\tif (this.right.test(request)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\trestoreAttributes(request, oldAttributes);\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<ServerRequest> nest(ServerRequest request) {\n\t\t\tOptional<ServerRequest> leftResult = this.left.nest(request);\n\t\t\tif (leftResult.isPresent()) {\n\t\t\t\treturn leftResult;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.right.nest(request);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.startOr();\n\t\t\tthis.left.accept(visitor);\n\t\t\tvisitor.or();\n\t\t\tthis.right.accept(visitor);\n\t\t\tvisitor.endOr();\n\t\t}\n\n\t\t@Override\n\t\tpublic void changeParser(PathPatternParser parser) {\n\t\t\tif (this.left instanceof ChangePathPatternParserVisitor.Target leftTarget) {\n\t\t\t\tleftTarget.changeParser(parser);\n\t\t\t}\n\t\t\tif (this.right instanceof ChangePathPatternParserVisitor.Target rightTarget) {\n\t\t\t\trightTarget.changeParser(parser);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"(%s || %s)\", this.left, this.right);\n\t\t}\n\t}\n\n\n\tprivate static class SubPathServerRequestWrapper implements ServerRequest {\n\n\t\tprivate final ServerRequest request;\n\n\t\tprivate final RequestPath requestPath;\n\n\t\tprivate final Map<String, Object> attributes;\n\n\t\tpublic SubPathServerRequestWrapper(ServerRequest request,\n\t\t\t\tPathPattern.PathRemainingMatchInfo info, PathPattern pattern) {\n\t\t\tthis.request = request;\n\t\t\tthis.requestPath = requestPath(request.requestPath(), info);\n\t\t\tthis.attributes = mergeAttributes(request, info.getUriVariables(), pattern);\n\t\t}\n\n\t\tprivate static RequestPath requestPath(RequestPath original, PathPattern.PathRemainingMatchInfo info) {\n\t\t\tStringBuilder contextPath = new StringBuilder(original.contextPath().value());\n\t\t\tcontextPath.append(info.getPathMatched().value());\n\t\t\tint length = contextPath.length();\n\t\t\tif (length > 0 && contextPath.charAt(length - 1) == '/') {\n\t\t\t\tcontextPath.setLength(length - 1);\n\t\t\t}\n\t\t\treturn original.modifyContextPath(contextPath.toString());\n\t\t}\n\n\t\tprivate static Map<String, Object> mergeAttributes(ServerRequest request,\n\t\tMap<String, String> pathVariables, PathPattern pattern) {\n\t\t\tMap<String, Object> result = new ConcurrentHashMap<>(request.attributes());\n\n\t\t\tresult.put(RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE,\n\t\t\t\t\tmergePathVariables(request.pathVariables(), pathVariables));\n\n\t\t\tpattern = mergePatterns(\n\t\t\t\t\t(PathPattern) request.attributes().get(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE),\n\t\t\t\t\tpattern);\n\t\t\tresult.put(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE, pattern);\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic HttpMethod method() {\n\t\t\treturn this.request.method();\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic String methodName() {\n\t\t\treturn this.request.methodName();\n\t\t}\n\n\t\t@Override\n\t\tpublic URI uri() {\n\t\t\treturn this.request.uri();\n\t\t}\n\n\t\t@Override\n\t\tpublic UriBuilder uriBuilder() {\n\t\t\treturn this.request.uriBuilder();\n\t\t}\n\n\t\t@Override\n\t\tpublic RequestPath requestPath() {\n\t\t\treturn this.requestPath;\n\t\t}\n\n\t\t@Override\n\t\tpublic Headers headers() {\n\t\t\treturn this.request.headers();\n\t\t}\n\n\t\t@Override\n\t\tpublic MultiValueMap<String, HttpCookie> cookies() {\n\t\t\treturn this.request.cookies();\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<InetSocketAddress> remoteAddress() {\n\t\t\treturn this.request.remoteAddress();\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<InetSocketAddress> localAddress() {\n\t\t\treturn this.request.localAddress();\n\t\t}\n\n\t\t@Override\n\t\tpublic List<HttpMessageReader<?>> messageReaders() {\n\t\t\treturn this.request.messageReaders();\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T body(BodyExtractor<T, ? super ServerHttpRequest> extractor) {\n\t\t\treturn this.request.body(extractor);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T body(BodyExtractor<T, ? super ServerHttpRequest> extractor, Map<String, Object> hints) {\n\t\t\treturn this.request.body(extractor, hints);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Mono<T> bodyToMono(Class<? extends T> elementClass) {\n\t\t\treturn this.request.bodyToMono(elementClass);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Mono<T> bodyToMono(ParameterizedTypeReference<T> typeReference) {\n\t\t\treturn this.request.bodyToMono(typeReference);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Flux<T> bodyToFlux(Class<? extends T> elementClass) {\n\t\t\treturn this.request.bodyToFlux(elementClass);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Flux<T> bodyToFlux(ParameterizedTypeReference<T> typeReference) {\n\t\t\treturn this.request.bodyToFlux(typeReference);\n\t\t}\n\n\t\t@Override\n\t\tpublic Map<String, Object> attributes() {\n\t\t\treturn this.attributes;\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<String> queryParam(String name) {\n\t\t\treturn this.request.queryParam(name);\n\t\t}\n\n\t\t@Override\n\t\tpublic MultiValueMap<String, String> queryParams() {\n\t\t\treturn this.request.queryParams();\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Map<String, String> pathVariables() {\n\t\t\treturn (Map<String, String>) this.attributes.getOrDefault(\n\t\t\t\t\tRouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE, Collections.emptyMap());\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<WebSession> session() {\n\t\t\treturn this.request.session();\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<? extends Principal> principal() {\n\t\t\treturn this.request.principal();\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<MultiValueMap<String, String>> formData() {\n\t\t\treturn this.request.formData();\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<MultiValueMap<String, Part>> multipartData() {\n\t\t\treturn this.request.multipartData();\n\t\t}\n\n\t\t@Override\n\t\tpublic ServerWebExchange exchange() {\n\t\t\treturn this.request.exchange();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn method() + \" \" +  path();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#DELETE(pattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code DELETE}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is DELETE and if the given pattern\n\t * matches against the request path\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate DELETE(String pattern)",
    "source_code": "\tpublic static RequestPredicate DELETE(String pattern) {\n\t\treturn method(HttpMethod.DELETE).and(path(pattern));\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#GET(pattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code GET}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is GET and if the given pattern\n\t * matches against the request path\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate GET(String pattern)",
    "source_code": "\tpublic static RequestPredicate GET(String pattern) {\n\t\treturn method(HttpMethod.GET).and(path(pattern));\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#HEAD(pattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code HEAD}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is HEAD and if the given pattern\n\t * matches against the request path\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate HEAD(String pattern)",
    "source_code": "\tpublic static RequestPredicate HEAD(String pattern) {\n\t\treturn method(HttpMethod.HEAD).and(path(pattern));\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#OPTIONS(pattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code OPTIONS}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is OPTIONS and if the given pattern\n\t * matches against the request path\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate OPTIONS(String pattern)",
    "source_code": "\tpublic static RequestPredicate OPTIONS(String pattern) {\n\t\treturn method(HttpMethod.OPTIONS).and(path(pattern));\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#PATCH(pattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code PATCH}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is PATCH and if the given pattern\n\t * matches against the request path\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate PATCH(String pattern)",
    "source_code": "\tpublic static RequestPredicate PATCH(String pattern) {\n\t\treturn method(HttpMethod.PATCH).and(path(pattern));\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#POST(pattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code POST}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is POST and if the given pattern\n\t * matches against the request path\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate POST(String pattern)",
    "source_code": "\tpublic static RequestPredicate POST(String pattern) {\n\t\treturn method(HttpMethod.POST).and(path(pattern));\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#PUT(pattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code PUT}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is PUT and if the given pattern\n\t * matches against the request path\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate PUT(String pattern)",
    "source_code": "\tpublic static RequestPredicate PUT(String pattern) {\n\t\treturn method(HttpMethod.PUT).and(path(pattern));\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#accept(mediaTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that tests if the request's\n\t * {@linkplain ServerRequest.Headers#accept() accept} header is\n\t * {@linkplain MediaType#isCompatibleWith(MediaType) compatible} with any of the given media types.\n\t * @param mediaTypes the media types to match the request's accept header against\n\t * @return a predicate that tests the request's accept header against the given media types\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate accept(MediaType... mediaTypes)",
    "source_code": "\tpublic static RequestPredicate accept(MediaType... mediaTypes) {\n\t\tAssert.notEmpty(mediaTypes, \"'mediaTypes' must not be empty\");\n\t\treturn new AcceptPredicate(mediaTypes);\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#accept(visitor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "visitor"
    ],
    "position": {
      "column": 1,
      "line": 902
    },
    "return": "void",
    "signature": "public void accept(Visitor visitor)",
    "source_code": "\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.startOr();\n\t\t\tthis.left.accept(visitor);\n\t\t\tvisitor.or();\n\t\t\tthis.right.accept(visitor);\n\t\t\tvisitor.endOr();\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#all()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that always matches.\n\t * @return a predicate that always matches\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate all()",
    "source_code": "\tpublic static RequestPredicate all() {\n\t\treturn request -> true;\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#attributes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1048
    },
    "return": "Object>",
    "signature": "public Object> attributes()",
    "source_code": "\t\tpublic Map<String, Object> attributes() {\n\t\t\treturn this.attributes;\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#body(BodyExtractor<T,extractor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BodyExtractor<T",
      "extractor"
    ],
    "position": {
      "column": 1,
      "line": 1018
    },
    "return": "T",
    "signature": "public T body(BodyExtractor<T, ? super ServerHttpRequest> extractor)",
    "source_code": "\t\tpublic <T> T body(BodyExtractor<T, ? super ServerHttpRequest> extractor) {\n\t\t\treturn this.request.body(extractor);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#body(BodyExtractor<T,extractor,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BodyExtractor<T",
      "extractor",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 1023
    },
    "return": "T",
    "signature": "public T body(BodyExtractor<T, ? super ServerHttpRequest> extractor, Map<String, Object> hints)",
    "source_code": "\t\tpublic <T> T body(BodyExtractor<T, ? super ServerHttpRequest> extractor, Map<String, Object> hints) {\n\t\t\treturn this.request.body(extractor, hints);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#bodyToFlux(elementClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 1038
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> bodyToFlux(Class<? extends T> elementClass)",
    "source_code": "\t\tpublic <T> Flux<T> bodyToFlux(Class<? extends T> elementClass) {\n\t\t\treturn this.request.bodyToFlux(elementClass);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#bodyToFlux(typeReference)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeReference"
    ],
    "position": {
      "column": 1,
      "line": 1043
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> bodyToFlux(ParameterizedTypeReference<T> typeReference)",
    "source_code": "\t\tpublic <T> Flux<T> bodyToFlux(ParameterizedTypeReference<T> typeReference) {\n\t\t\treturn this.request.bodyToFlux(typeReference);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#bodyToMono(elementClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 1028
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> bodyToMono(Class<? extends T> elementClass)",
    "source_code": "\t\tpublic <T> Mono<T> bodyToMono(Class<? extends T> elementClass) {\n\t\t\treturn this.request.bodyToMono(elementClass);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#bodyToMono(typeReference)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeReference"
    ],
    "position": {
      "column": 1,
      "line": 1033
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> bodyToMono(ParameterizedTypeReference<T> typeReference)",
    "source_code": "\t\tpublic <T> Mono<T> bodyToMono(ParameterizedTypeReference<T> typeReference) {\n\t\t\treturn this.request.bodyToMono(typeReference);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#changeParser(parser)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parser"
    ],
    "position": {
      "column": 1,
      "line": 911
    },
    "return": "void",
    "signature": "public void changeParser(PathPatternParser parser)",
    "source_code": "\t\tpublic void changeParser(PathPatternParser parser) {\n\t\t\tif (this.left instanceof ChangePathPatternParserVisitor.Target leftTarget) {\n\t\t\t\tleftTarget.changeParser(parser);\n\t\t\t}\n\t\t\tif (this.right instanceof ChangePathPatternParserVisitor.Target rightTarget) {\n\t\t\t\trightTarget.changeParser(parser);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#contentType(mediaTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that tests if the request's\n\t * {@linkplain ServerRequest.Headers#contentType() content type} is\n\t * {@linkplain MediaType#includes(MediaType) included} by any of the given media types.\n\t * @param mediaTypes the media types to match the request's content type against\n\t * @return a predicate that tests the request's content type against the given media types\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate contentType(MediaType... mediaTypes)",
    "source_code": "\tpublic static RequestPredicate contentType(MediaType... mediaTypes) {\n\t\tAssert.notEmpty(mediaTypes, \"'mediaTypes' must not be empty\");\n\t\treturn new ContentTypePredicate(mediaTypes);\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#cookies()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 998
    },
    "return": "HttpCookie>",
    "signature": "public HttpCookie> cookies()",
    "source_code": "\t\tpublic MultiValueMap<String, HttpCookie> cookies() {\n\t\t\treturn this.request.cookies();\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#exchange()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1091
    },
    "return": "ServerWebExchange",
    "signature": "public ServerWebExchange exchange()",
    "source_code": "\t\tpublic ServerWebExchange exchange() {\n\t\t\treturn this.request.exchange();\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#formData()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1081
    },
    "return": "String>>",
    "signature": "public String>> formData()",
    "source_code": "\t\tpublic Mono<MultiValueMap<String, String>> formData() {\n\t\t\treturn this.request.formData();\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#headers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 993
    },
    "return": "Headers",
    "signature": "public Headers headers()",
    "source_code": "\t\tpublic Headers headers() {\n\t\t\treturn this.request.headers();\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#headers(headersPredicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that tests the request's headers\n\t * against the given headers predicate.\n\t * @param headersPredicate a predicate that tests against the request headers\n\t * @return a predicate that tests against the given header predicate\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headersPredicate"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate headers(Predicate<ServerRequest.Headers> headersPredicate)",
    "source_code": "\tpublic static RequestPredicate headers(Predicate<ServerRequest.Headers> headersPredicate) {\n\t\treturn new HeadersPredicate(headersPredicate);\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#localAddress()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1008
    },
    "return": "Optional<InetSocketAddress>",
    "signature": "public Optional<InetSocketAddress> localAddress()",
    "source_code": "\t\tpublic Optional<InetSocketAddress> localAddress() {\n\t\t\treturn this.request.localAddress();\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#method()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 967
    },
    "return": "HttpMethod",
    "signature": "public HttpMethod method()",
    "source_code": "\t\tpublic HttpMethod method() {\n\t\t\treturn this.request.method();\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#method(httpMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's\n\t * HTTP method is equal to the given method.\n\t * @param httpMethod the HTTP method to match against\n\t * @return a predicate that tests against the given HTTP method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "httpMethod"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate method(HttpMethod httpMethod)",
    "source_code": "\tpublic static RequestPredicate method(HttpMethod httpMethod) {\n\t\treturn new HttpMethodPredicate(httpMethod);\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#methodName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 973
    },
    "return": "String",
    "signature": "public String methodName()",
    "source_code": "\t\tpublic String methodName() {\n\t\t\treturn this.request.methodName();\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#methods(httpMethods)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's\n\t * HTTP method is equal to one the of the given methods.\n\t * @param httpMethods the HTTP methods to match against\n\t * @return a predicate that tests against the given HTTP methods\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "httpMethods"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate methods(HttpMethod... httpMethods)",
    "source_code": "\tpublic static RequestPredicate methods(HttpMethod... httpMethods) {\n\t\treturn new HttpMethodPredicate(httpMethods);\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#multipartData()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1086
    },
    "return": "Part>>",
    "signature": "public Part>> multipartData()",
    "source_code": "\t\tpublic Mono<MultiValueMap<String, Part>> multipartData() {\n\t\t\treturn this.request.multipartData();\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#nest(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 891
    },
    "return": "Optional<ServerRequest>",
    "signature": "public Optional<ServerRequest> nest(ServerRequest request)",
    "source_code": "\t\tpublic Optional<ServerRequest> nest(ServerRequest request) {\n\t\t\tOptional<ServerRequest> leftResult = this.left.nest(request);\n\t\t\tif (leftResult.isPresent()) {\n\t\t\t\treturn leftResult;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.right.nest(request);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#path(pattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that tests the request path\n\t * against the given path pattern.\n\t * @param pattern the pattern to match to\n\t * @return a predicate that tests against the given path pattern\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate path(String pattern)",
    "source_code": "\tpublic static RequestPredicate path(String pattern) {\n\t\tAssert.notNull(pattern, \"'pattern' must not be null\");\n\t\tif (!pattern.isEmpty() && !pattern.startsWith(\"/\")) {\n\t\t\tpattern = \"/\" + pattern;\n\t\t}\n\t\treturn pathPredicates(PathPatternParser.defaultInstance).apply(pattern);\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#pathExtension(extension)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's path has the given extension.\n\t * @param extension the path extension to match against, ignoring case\n\t * @return a predicate that matches if the request's path has the given file extension\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "extension"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate pathExtension(String extension)",
    "source_code": "\tpublic static RequestPredicate pathExtension(String extension) {\n\t\tAssert.notNull(extension, \"'extension' must not be null\");\n\t\treturn new PathExtensionPredicate(extension);\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#pathExtension(extensionPredicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's path matches the given\n\t * predicate.\n\t * @param extensionPredicate the predicate to test against the request path extension\n\t * @return a predicate that matches if the given predicate matches against the request's path\n\t * file extension\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "extensionPredicate"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate pathExtension(Predicate<String> extensionPredicate)",
    "source_code": "\tpublic static RequestPredicate pathExtension(Predicate<String> extensionPredicate) {\n\t\treturn new PathExtensionPredicate(extensionPredicate);\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#pathPredicates(patternParser)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a function that creates new path-matching {@code RequestPredicates}\n\t * from pattern Strings using the given {@link PathPatternParser}.\n\t * <p>This method can be used to specify a non-default, customized\n\t * {@code PathPatternParser} when resolving path patterns.\n\t * @param patternParser the parser used to parse patterns given to the returned function\n\t * @return a function that resolves a pattern String into a path-matching\n\t * {@code RequestPredicates} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "patternParser"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "RequestPredicate>",
    "signature": "public RequestPredicate> pathPredicates(PathPatternParser patternParser)",
    "source_code": "\tpublic static Function<String, RequestPredicate> pathPredicates(PathPatternParser patternParser) {\n\t\tAssert.notNull(patternParser, \"PathPatternParser must not be null\");\n\t\treturn pattern -> new PathPatternPredicate(patternParser.parse(pattern));\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#pathVariables()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1064
    },
    "return": "String>",
    "signature": "public String> pathVariables()",
    "source_code": "\t\tpublic Map<String, String> pathVariables() {\n\t\t\treturn (Map<String, String>) this.attributes.getOrDefault(\n\t\t\t\t\tRouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE, Collections.emptyMap());\n\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#queryParam(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 1053
    },
    "return": "Optional<String>",
    "signature": "public Optional<String> queryParam(String name)",
    "source_code": "\t\tpublic Optional<String> queryParam(String name) {\n\t\t\treturn this.request.queryParam(name);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#queryParam(name,predicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that tests the request's query parameter of the given name\n\t * against the given predicate.\n\t * @param name the name of the query parameter to test against\n\t * @param predicate the predicate to test against the query parameter value\n\t * @return a predicate that matches the given predicate against the query parameter of the given name\n\t * @see ServerRequest#queryParam(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "predicate"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate queryParam(String name, Predicate<String> predicate)",
    "source_code": "\tpublic static RequestPredicate queryParam(String name, Predicate<String> predicate) {\n\t\treturn new QueryParamPredicate(name, predicate);\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#queryParam(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's query parameter of the given name\n\t * has the given value.\n\t * @param name the name of the query parameter to test against\n\t * @param value the value of the query parameter to test against\n\t * @return a predicate that matches if the query parameter has the given value\n\t * @since 5.0.7\n\t * @see ServerRequest#queryParam(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate queryParam(String name, String value)",
    "source_code": "\tpublic static RequestPredicate queryParam(String name, String value) {\n\t\treturn new QueryParamPredicate(name, value);\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#queryParams()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1058
    },
    "return": "String>",
    "signature": "public String> queryParams()",
    "source_code": "\t\tpublic MultiValueMap<String, String> queryParams() {\n\t\t\treturn this.request.queryParams();\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#remoteAddress()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1003
    },
    "return": "Optional<InetSocketAddress>",
    "signature": "public Optional<InetSocketAddress> remoteAddress()",
    "source_code": "\t\tpublic Optional<InetSocketAddress> remoteAddress() {\n\t\t\treturn this.request.remoteAddress();\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#requestPath()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 988
    },
    "return": "RequestPath",
    "signature": "public RequestPath requestPath()",
    "source_code": "\t\tpublic RequestPath requestPath() {\n\t\t\treturn this.requestPath;\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#session()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1071
    },
    "return": "Mono<WebSession>",
    "signature": "public Mono<WebSession> session()",
    "source_code": "\t\tpublic Mono<WebSession> session() {\n\t\t\treturn this.request.session();\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#test(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 874
    },
    "return": "boolean",
    "signature": "public boolean test(ServerRequest request)",
    "source_code": "\t\tpublic boolean test(ServerRequest request) {\n\t\t\tMap<String, Object> oldAttributes = new HashMap<>(request.attributes());\n\n\t\t\tif (this.left.test(request)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trestoreAttributes(request, oldAttributes);\n\t\t\t\tif (this.right.test(request)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\trestoreAttributes(request, oldAttributes);\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1096
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn method() + \" \" +  path();\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#uri()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 978
    },
    "return": "URI",
    "signature": "public URI uri()",
    "source_code": "\t\tpublic URI uri() {\n\t\t\treturn this.request.uri();\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#uriBuilder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 983
    },
    "return": "UriBuilder",
    "signature": "public UriBuilder uriBuilder()",
    "source_code": "\t\tpublic UriBuilder uriBuilder() {\n\t\t\treturn this.request.uriBuilder();\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.Visitor": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Receives notifications from the logical structure of request predicates.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "signature": "public interface Visitor",
    "source_code": "\tpublic interface Visitor {\n\n\t\t/**\n\t\t * Receive notification of an HTTP method predicate.\n\t\t * @param methods the HTTP methods that make up the predicate\n\t\t * @see RequestPredicates#method(HttpMethod)\n\t\t */\n\t\tvoid method(Set<HttpMethod> methods);\n\n\t\t/**\n\t\t * Receive notification of a path predicate.\n\t\t * @param pattern the path pattern that makes up the predicate\n\t\t * @see RequestPredicates#path(String)\n\t\t */\n\t\tvoid path(String pattern);\n\n\t\t/**\n\t\t * Receive notification of a path extension predicate.\n\t\t * @param extension the path extension that makes up the predicate\n\t\t * @see RequestPredicates#pathExtension(String)\n\t\t */\n\t\tvoid pathExtension(String extension);\n\n\t\t/**\n\t\t * Receive notification of an HTTP header predicate.\n\t\t * @param name the name of the HTTP header to check\n\t\t * @param value the desired value of the HTTP header\n\t\t * @see RequestPredicates#headers(Predicate)\n\t\t * @see RequestPredicates#contentType(MediaType...)\n\t\t * @see RequestPredicates#accept(MediaType...)\n\t\t */\n\t\tvoid header(String name, String value);\n\n\t\t/**\n\t\t * Receive notification of a query parameter predicate.\n\t\t * @param name the name of the query parameter\n\t\t * @param value the desired value of the parameter\n\t\t * @see RequestPredicates#queryParam(String, String)\n\t\t */\n\t\tvoid queryParam(String name, String value);\n\n\t\t/**\n\t\t * Receive first notification of a logical AND predicate.\n\t\t * The first subsequent notification will contain the left-hand side of the AND-predicate;\n\t\t * followed by {@link #and()}, followed by the right-hand side, followed by {@link #endAnd()}.\n\t\t * @see RequestPredicate#and(RequestPredicate)\n\t\t */\n\t\tvoid startAnd();\n\n\t\t/**\n\t\t * Receive \"middle\" notification of a logical AND predicate.\n\t\t * The following notification contains the right-hand side, followed by {@link #endAnd()}.\n\t\t * @see RequestPredicate#and(RequestPredicate)\n\t\t */\n\t\tvoid and();\n\n\t\t/**\n\t\t * Receive last notification of a logical AND predicate.\n\t\t * @see RequestPredicate#and(RequestPredicate)\n\t\t */\n\t\tvoid endAnd();\n\n\t\t/**\n\t\t * Receive first notification of a logical OR predicate.\n\t\t * The first subsequent notification will contain the left-hand side of the OR-predicate;\n\t\t * the second notification contains the right-hand side, followed by {@link #endOr()}.\n\t\t * @see RequestPredicate#or(RequestPredicate)\n\t\t */\n\t\tvoid startOr();\n\n\t\t/**\n\t\t * Receive \"middle\" notification of a logical OR predicate.\n\t\t * The following notification contains the right-hand side, followed by {@link #endOr()}.\n\t\t * @see RequestPredicate#or(RequestPredicate)\n\t\t */\n\t\tvoid or();\n\n\t\t/**\n\t\t * Receive last notification of a logical OR predicate.\n\t\t * @see RequestPredicate#or(RequestPredicate)\n\t\t */\n\t\tvoid endOr();\n\n\t\t/**\n\t\t * Receive first notification of a negated predicate.\n\t\t * The first subsequent notification will contain the negated predicated, followed\n\t\t * by {@link #endNegate()}.\n\t\t * @see RequestPredicate#negate()\n\t\t */\n\t\tvoid startNegate();\n\n\t\t/**\n\t\t * Receive last notification of a negated predicate.\n\t\t * @see RequestPredicate#negate()\n\t\t */\n\t\tvoid endNegate();\n\n\t\t/**\n\t\t * Receive first notification of an unknown predicate.\n\t\t */\n\t\tvoid unknown(RequestPredicate predicate);\n\t}"
  },
  "org.springframework.web.reactive.handler.AbstractHandlerMapping": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for {@link org.springframework.web.reactive.HandlerMapping}\n * implementations.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Brian Clozel\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class AbstractHandlerMapping",
    "source_code": "public abstract class AbstractHandlerMapping extends ApplicationObjectSupport"
  },
  "org.springframework.web.reactive.handler.AbstractHandlerMapping#formatMappingName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "String",
    "signature": "protected String formatMappingName()",
    "source_code": "\tprotected String formatMappingName() {\n\t\treturn this.beanName != null ? \"'\" + this.beanName + \"'\" : \"<unknown>\";\n\t}"
  },
  "org.springframework.web.reactive.handler.AbstractHandlerMapping#getCorsConfiguration(handler,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the CORS configuration for the given handler.\n\t * @param handler the handler to check (never {@code null})\n\t * @param exchange the current exchange\n\t * @return the CORS configuration for the handler, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration getCorsConfiguration(Object handler, ServerWebExchange exchange)",
    "source_code": "\tprotected CorsConfiguration getCorsConfiguration(Object handler, ServerWebExchange exchange) {\n\t\tif (handler instanceof CorsConfigurationSource ccs) {\n\t\t\treturn ccs.getCorsConfiguration(exchange);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.reactive.handler.AbstractHandlerMapping#getCorsProcessor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link CorsProcessor}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "CorsProcessor",
    "signature": "public CorsProcessor getCorsProcessor()",
    "source_code": "\tpublic CorsProcessor getCorsProcessor() {\n\t\treturn this.corsProcessor;\n\t}"
  },
  "org.springframework.web.reactive.handler.AbstractHandlerMapping#getHandler(exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "Mono<Object>",
    "signature": "public Mono<Object> getHandler(ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Object> getHandler(ServerWebExchange exchange) {\n\t\treturn getHandlerInternal(exchange).map(handler -> {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(exchange.getLogPrefix() + \"Mapped to \" + handler);\n\t\t\t}\n\t\t\tServerHttpRequest request = exchange.getRequest();\n\t\t\tif (hasCorsConfigurationSource(handler) || CorsUtils.isPreFlightRequest(request)) {\n\t\t\t\tCorsConfiguration config = (this.corsConfigurationSource != null ?\n\t\t\t\t\t\tthis.corsConfigurationSource.getCorsConfiguration(exchange) : null);\n\t\t\t\tCorsConfiguration handlerConfig = getCorsConfiguration(handler, exchange);\n\t\t\t\tconfig = (config != null ? config.combine(handlerConfig) : handlerConfig);\n\t\t\t\tif (config != null) {\n\t\t\t\t\tconfig.validateAllowCredentials();\n\t\t\t\t}\n\t\t\t\tif (!this.corsProcessor.process(config, exchange) || CorsUtils.isPreFlightRequest(request)) {\n\t\t\t\t\treturn NO_OP_HANDLER;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn handler;\n\t\t});\n\t}"
  },
  "org.springframework.web.reactive.handler.AbstractHandlerMapping#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic int getOrder() {\n\t\treturn this.order;\n\t}"
  },
  "org.springframework.web.reactive.handler.AbstractHandlerMapping#getPathPatternParser()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link PathPatternParser} instance that is used for\n\t * {@link #setCorsConfigurations(Map) CORS configuration checks}.\n\t * Subclasses can also use this pattern parser for their own request\n\t * mapping purposes.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "PathPatternParser",
    "signature": "public PathPatternParser getPathPatternParser()",
    "source_code": "\tpublic PathPatternParser getPathPatternParser() {\n\t\treturn this.patternParser;\n\t}"
  },
  "org.springframework.web.reactive.handler.AbstractHandlerMapping#hasCorsConfigurationSource(handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if there is a {@link CorsConfigurationSource} for this handler.\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "boolean",
    "signature": "protected boolean hasCorsConfigurationSource(Object handler)",
    "source_code": "\tprotected boolean hasCorsConfigurationSource(Object handler) {\n\t\treturn (handler instanceof CorsConfigurationSource || this.corsConfigurationSource != null);\n\t}"
  },
  "org.springframework.web.reactive.handler.AbstractHandlerMapping#setBeanName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "void",
    "signature": "public void setBeanName(String name)",
    "source_code": "\tpublic void setBeanName(String name) {\n\t\tthis.beanName = name;\n\t}"
  },
  "org.springframework.web.reactive.handler.AbstractHandlerMapping#setCorsConfigurationSource(corsConfigurationSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the \"global\" CORS configuration source. By default, the first matching URL\n\t * pattern is combined with the CORS configuration for the handler, if any.\n\t * @since 5.1\n\t * @see #setCorsConfigurations(Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "corsConfigurationSource"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "void",
    "signature": "public void setCorsConfigurationSource(CorsConfigurationSource corsConfigurationSource)",
    "source_code": "\tpublic void setCorsConfigurationSource(CorsConfigurationSource corsConfigurationSource) {\n\t\tAssert.notNull(corsConfigurationSource, \"corsConfigurationSource must not be null\");\n\t\tthis.corsConfigurationSource = corsConfigurationSource;\n\t}"
  },
  "org.springframework.web.reactive.handler.AbstractHandlerMapping#setCorsConfigurations(Map<String,corsConfigurations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the \"global\" CORS configurations based on URL patterns. By default, the\n\t * first matching URL pattern is combined with handler-level CORS configuration if any.\n\t * @see #setCorsConfigurationSource(CorsConfigurationSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "corsConfigurations"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void setCorsConfigurations(Map<String, CorsConfiguration> corsConfigurations)",
    "source_code": "\tpublic void setCorsConfigurations(Map<String, CorsConfiguration> corsConfigurations) {\n\t\tAssert.notNull(corsConfigurations, \"corsConfigurations must not be null\");\n\t\tif (!corsConfigurations.isEmpty()) {\n\t\t\tUrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(this.patternParser);\n\t\t\tsource.setCorsConfigurations(corsConfigurations);\n\t\t\tthis.corsConfigurationSource = source;\n\t\t}\n\t\telse {\n\t\t\tthis.corsConfigurationSource = null;\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.handler.AbstractHandlerMapping#setCorsProcessor(corsProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a custom {@link CorsProcessor} to use to apply the matched\n\t * {@link CorsConfiguration} for a request.\n\t * <p>By default an instance of {@link DefaultCorsProcessor} is used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "corsProcessor"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void setCorsProcessor(CorsProcessor corsProcessor)",
    "source_code": "\tpublic void setCorsProcessor(CorsProcessor corsProcessor) {\n\t\tAssert.notNull(corsProcessor, \"CorsProcessor must not be null\");\n\t\tthis.corsProcessor = corsProcessor;\n\t}"
  },
  "org.springframework.web.reactive.handler.AbstractHandlerMapping#setOrder(order)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the order value for this HandlerMapping bean.\n\t * <p>The default value is {@code Ordered.LOWEST_PRECEDENCE}, meaning non-ordered.\n\t * @see org.springframework.core.Ordered#getOrder()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "order"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "void",
    "signature": "public void setOrder(int order)",
    "source_code": "\tpublic void setOrder(int order) {\n\t\tthis.order = order;\n\t}"
  },
  "org.springframework.web.reactive.handler.AbstractHandlerMapping#setUseCaseSensitiveMatch(caseSensitiveMatch)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut method for setting the same property on the underlying pattern\n\t * parser in use. For more details see:\n\t * <ul>\n\t * <li>{@link #getPathPatternParser()} -- the underlying pattern parser\n\t * <li>{@link PathPatternParser#setCaseSensitive(boolean)} -- the case\n\t * sensitive slash option, including its default value.\n\t * </ul>\n\t * <p><strong>Note:</strong> aside from\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "caseSensitiveMatch"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void setUseCaseSensitiveMatch(boolean caseSensitiveMatch)",
    "source_code": "\tpublic void setUseCaseSensitiveMatch(boolean caseSensitiveMatch) {\n\t\tthis.patternParser.setCaseSensitive(caseSensitiveMatch);\n\t}"
  },
  "org.springframework.web.reactive.handler.AbstractHandlerMapping#setUseTrailingSlashMatch(trailingSlashMatch)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut method for setting the same property on the underlying pattern\n\t * parser in use. For more details see:\n\t * <ul>\n\t * <li>{@link #getPathPatternParser()} -- the underlying pattern parser\n\t * <li>{@link PathPatternParser#setMatchOptionalTrailingSeparator(boolean)} --\n\t * the trailing slash option, including its default value.\n\t * </ul>\n\t * <p>The default was changed in 6.0 from {@code true} to {@code false} in\n\t * order to support the deprecation of the property.\n\t * @deprecated as of 6.0, see\n\t * {@link PathPatternParser#setMatchOptionalTrailingSeparator(boolean)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "trailingSlashMatch"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void setUseTrailingSlashMatch(boolean trailingSlashMatch)",
    "source_code": "\tpublic void setUseTrailingSlashMatch(boolean trailingSlashMatch) {\n\t\tthis.patternParser.setMatchOptionalTrailingSeparator(trailingSlashMatch);\n\t}"
  },
  "org.springframework.web.reactive.handler.SimpleUrlHandlerMapping": {
    "change": "added",
    "deprecated": false,
    "doc": " * \"/test/**\" matches all paths below \"/test\". For details, see the\n * {@link org.springframework.web.util.pattern.PathPattern} javadoc.\n *\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "signature": "public class SimpleUrlHandlerMapping",
    "source_code": "public class SimpleUrlHandlerMapping extends AbstractUrlHandlerMapping {\n\n\tprivate final Map<String, Object> urlMap = new LinkedHashMap<>();\n\n\n\t/**\n\t * Create a {@code SimpleUrlHandlerMapping} with default settings.\n\t */\n\tpublic SimpleUrlHandlerMapping() {\n\t}\n\n\t/**\n\t * Create a {@code SimpleUrlHandlerMapping} using the supplied URL map.\n\t * @param urlMap map with URL paths as keys and handler beans (or handler\n\t * bean names) as values\n\t * @since 5.2\n\t * @see #setUrlMap(Map)\n\t */\n\tpublic SimpleUrlHandlerMapping(Map<String, ?> urlMap) {\n\t\tsetUrlMap(urlMap);\n\t}\n\n\t/**\n\t * Create a {@code SimpleUrlHandlerMapping} using the supplied URL map and order.\n\t * @param urlMap map with URL paths as keys and handler beans (or handler\n\t * bean names) as values\n\t * @param order the order value for this {@code SimpleUrlHandlerMapping}\n\t * @since 5.2\n\t * @see #setUrlMap(Map)\n\t * @see #setOrder(int)\n\t */\n\tpublic SimpleUrlHandlerMapping(Map<String, ?> urlMap, int order) {\n\t\tsetUrlMap(urlMap);\n\t\tsetOrder(order);\n\t}\n\n\n\t/**\n\t * Map URL paths to handler bean names.\n\t * This is the typical way of configuring this HandlerMapping.\n\t * <p>Supports direct URL matches and Ant-style pattern matches. For syntax details,\n\t * see the {@link org.springframework.web.util.pattern.PathPattern} javadoc.\n\t * @param mappings properties with URLs as keys and bean names as values\n\t * @see #setUrlMap\n\t */\n\tpublic void setMappings(Properties mappings) {\n\t\tCollectionUtils.mergePropertiesIntoMap(mappings, this.urlMap);\n\t}\n\n\t/**\n\t * Set a Map with URL paths as keys and handler beans (or handler bean names)\n\t * as values. Convenient for population with bean references.\n\t * <p>Supports direct URL matches and Ant-style pattern matches. For syntax details,\n\t * see the {@link org.springframework.web.util.pattern.PathPattern} javadoc.\n\t * @param urlMap map with URLs as keys and beans as values\n\t * @see #setMappings\n\t */\n\tpublic void setUrlMap(Map<String, ?> urlMap) {\n\t\tthis.urlMap.putAll(urlMap);\n\t}\n\n\t/**\n\t * Allow {@code Map} access to the URL path mappings, with the option to add or\n\t * override specific entries.\n\t * <p>Useful for specifying entries directly, for example via \"urlMap[myKey]\".\n\t * This is particularly useful for adding or overriding entries in child\n\t * bean definitions.\n\t */\n\tpublic Map<String, ?> getUrlMap() {\n\t\treturn this.urlMap;\n\t}\n\n\n\t/**\n\t * Calls the {@link #registerHandlers} method in addition to the\n\t * superclass's initialization.\n\t */\n\t@Override\n\tpublic void initApplicationContext() throws BeansException {\n\t\tsuper.initApplicationContext();\n\t\tregisterHandlers(this.urlMap);\n\t}\n\n\t/**\n\t * Register all handlers specified in the URL map for the corresponding paths.\n\t * @param urlMap a Map with URL paths as keys and handler beans or bean names as values\n\t * @throws BeansException if a handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */\n\tprotected void registerHandlers(Map<String, Object> urlMap) throws BeansException {\n\t\tif (urlMap.isEmpty()) {\n\t\t\tlogger.trace(\"No patterns in \" + formatMappingName());\n\t\t}\n\t\telse {\n\t\t\tfor (Map.Entry<String, Object> entry : urlMap.entrySet()) {\n\t\t\t\tString url = entry.getKey();\n\t\t\t\tObject handler = entry.getValue();\n\t\t\t\t// Prepend with slash if not already present.\n\t\t\t\tif (!url.startsWith(\"/\")) {\n\t\t\t\t\turl = \"/\" + url;\n\t\t\t\t}\n\t\t\t\t// Remove whitespace from handler bean name.\n\t\t\t\tif (handler instanceof String handlerName) {\n\t\t\t\t\thandler = handlerName.trim();\n\t\t\t\t}\n\t\t\t\tregisterHandler(url, handler);\n\t\t\t}\n\t\t\tlogMappings();\n\t\t}\n\t}\n\n\tprivate void logMappings() {\n\t\tif (mappingsLogger.isDebugEnabled()) {\n\t\t\tmappingsLogger.debug(formatMappingName() + \" \" + getHandlerMap());\n\t\t}\n\t\telse if (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Patterns \" + getHandlerMap().keySet() + \" in \" + formatMappingName());\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.handler.SimpleUrlHandlerMapping#initApplicationContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Calls the {@link #registerHandlers} method in addition to the\n\t * superclass's initialization.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void initApplicationContext()",
    "source_code": "\tpublic void initApplicationContext() throws BeansException {\n\t\tsuper.initApplicationContext();\n\t\tregisterHandlers(this.urlMap);\n\t}"
  },
  "org.springframework.web.reactive.handler.SimpleUrlHandlerMapping#registerHandlers(Map<String,urlMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register all handlers specified in the URL map for the corresponding paths.\n\t * @param urlMap a Map with URL paths as keys and handler beans or bean names as values\n\t * @throws BeansException if a handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "urlMap"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "protected void registerHandlers(Map<String, Object> urlMap)",
    "source_code": "\tprotected void registerHandlers(Map<String, Object> urlMap) throws BeansException {\n\t\tif (urlMap.isEmpty()) {\n\t\t\tlogger.trace(\"No patterns in \" + formatMappingName());\n\t\t}\n\t\telse {\n\t\t\tfor (Map.Entry<String, Object> entry : urlMap.entrySet()) {\n\t\t\t\tString url = entry.getKey();\n\t\t\t\tObject handler = entry.getValue();\n\t\t\t\t// Prepend with slash if not already present.\n\t\t\t\tif (!url.startsWith(\"/\")) {\n\t\t\t\t\turl = \"/\" + url;\n\t\t\t\t}\n\t\t\t\t// Remove whitespace from handler bean name.\n\t\t\t\tif (handler instanceof String handlerName) {\n\t\t\t\t\thandler = handlerName.trim();\n\t\t\t\t}\n\t\t\t\tregisterHandler(url, handler);\n\t\t\t}\n\t\t\tlogMappings();\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.handler.SimpleUrlHandlerMapping#setMappings(mappings)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Map URL paths to handler bean names.\n\t * This is the typical way of configuring this HandlerMapping.\n\t * <p>Supports direct URL matches and Ant-style pattern matches. For syntax details,\n\t * see the {@link org.springframework.web.util.pattern.PathPattern} javadoc.\n\t * @param mappings properties with URLs as keys and bean names as values\n\t * @see #setUrlMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappings"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void setMappings(Properties mappings)",
    "source_code": "\tpublic void setMappings(Properties mappings) {\n\t\tCollectionUtils.mergePropertiesIntoMap(mappings, this.urlMap);\n\t}"
  },
  "org.springframework.web.reactive.handler.SimpleUrlHandlerMapping#setUrlMap(Map<String,urlMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Map with URL paths as keys and handler beans (or handler bean names)\n\t * as values. Convenient for population with bean references.\n\t * <p>Supports direct URL matches and Ant-style pattern matches. For syntax details,\n\t * see the {@link org.springframework.web.util.pattern.PathPattern} javadoc.\n\t * @param urlMap map with URLs as keys and beans as values\n\t * @see #setMappings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "urlMap"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void setUrlMap(Map<String, ?> urlMap)",
    "source_code": "\tpublic void setUrlMap(Map<String, ?> urlMap) {\n\t\tthis.urlMap.putAll(urlMap);\n\t}"
  },
  "org.springframework.web.reactive.handler.mappingsLogger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Dedicated \"hidden\" logger for request mappings. */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "signature": "protected Log mappingsLogger",
    "source_code": "\tprotected final Log mappingsLogger =",
    "type": "Log"
  },
  "org.springframework.web.reactive.resource.DEFAULT_CODINGS": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The default content codings.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "signature": "public List<String> DEFAULT_CODINGS",
    "source_code": "\tpublic static final List<String> DEFAULT_CODINGS = Arrays.asList(\"br\", \"gzip\");",
    "type": "List<String>"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Resolver that delegates to the chain, and if a resource is found, it then\n * attempts to find an encoded (e.g. gzip, brotli) variant that is acceptable\n * based on the \"Accept-Encoding\" request header.\n *\n * <p>The list of supported {@link #setContentCodings(List) contentCodings} can\n * be configured, in order of preference, and each coding must be associated\n * with {@link #setExtensions(Map) extensions}.\n *\n * <p>Note that this resolver must be ordered ahead of a\n * {@link VersionResourceResolver} with a content-based, version strategy to\n * ensure the version calculation is not impacted by the encoding.\n *\n * @author Rossen Stoyanchev\n * @since 5.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "signature": "public class EncodedResourceResolver",
    "source_code": "public class EncodedResourceResolver extends AbstractResourceResolver {\n\n\t/**\n\t * The default content codings.\n\t */\n\tpublic static final List<String> DEFAULT_CODINGS = Arrays.asList(\"br\", \"gzip\");\n\n\n\tprivate final List<String> contentCodings = new ArrayList<>(DEFAULT_CODINGS);\n\n\tprivate final Map<String, String> extensions = new LinkedHashMap<>();\n\n\n\tpublic EncodedResourceResolver() {\n\t\tthis.extensions.put(\"gzip\", \".gz\");\n\t\tthis.extensions.put(\"br\", \".br\");\n\t}\n\n\n\t/**\n\t * Configure the supported content codings in order of preference. The first\n\t * coding that is present in the {@literal \"Accept-Encoding\"} header for a\n\t * given request, and that has a file present with the associated extension,\n\t * is used.\n\t * <p><strong>Note:</strong> Each coding must be associated with a file\n\t * extension via {@link #registerExtension} or {@link #setExtensions}. Also\n\t * customizations to the list of codings here should be matched by\n\t * customizations to the same list in {@link CachingResourceResolver} to\n\t * ensure encoded variants of a resource are cached under separate keys.\n\t * <p>By default this property is set to {@literal [\"br\", \"gzip\"]}.\n\t * @param codings one or more supported content codings\n\t */\n\tpublic void setContentCodings(List<String> codings) {\n\t\tAssert.notEmpty(codings, \"At least one content coding expected\");\n\t\tthis.contentCodings.clear();\n\t\tthis.contentCodings.addAll(codings);\n\t}\n\n\t/**\n\t * Return a read-only list with the supported content codings.\n\t */\n\tpublic List<String> getContentCodings() {\n\t\treturn Collections.unmodifiableList(this.contentCodings);\n\t}\n\n\t/**\n\t * Configure mappings from content codings to file extensions. A dot \".\"\n\t * will be prepended in front of the extension value if not present.\n\t * <p>By default this is configured with {@literal [\"br\" -> \".br\"]} and\n\t * {@literal [\"gzip\" -> \".gz\"]}.\n\t * @param extensions the extensions to use.\n\t * @see #registerExtension(String, String)\n\t */\n\tpublic void setExtensions(Map<String, String> extensions) {\n\t\textensions.forEach(this::registerExtension);\n\t}\n\n\t/**\n\t * Return a read-only map with coding-to-extension mappings.\n\t */\n\tpublic Map<String, String> getExtensions() {\n\t\treturn Collections.unmodifiableMap(this.extensions);\n\t}\n\n\t/**\n\t * Java config friendly alternative to {@link #setExtensions(Map)}.\n\t * @param coding the content coding\n\t * @param extension the associated file extension\n\t */\n\tpublic void registerExtension(String coding, String extension) {\n\t\tthis.extensions.put(coding, (extension.startsWith(\".\") ? extension : \".\" + extension));\n\t}\n\n\n\t@Override\n\tprotected Mono<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,\n\t\t\tString requestPath, List<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\treturn chain.resolveResource(exchange, requestPath, locations).map(resource -> {\n\n\t\t\tif (exchange == null) {\n\t\t\t\treturn resource;\n\t\t\t}\n\n\t\t\tString acceptEncoding = getAcceptEncoding(exchange);\n\t\t\tif (acceptEncoding == null) {\n\t\t\t\treturn resource;\n\t\t\t}\n\n\t\t\tfor (String coding : this.contentCodings) {\n\t\t\t\tif (acceptEncoding.contains(coding)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString extension = getExtension(coding);\n\t\t\t\t\t\tResource encoded = new EncodedResource(resource, coding, extension);\n\t\t\t\t\t\tif (encoded.exists()) {\n\t\t\t\t\t\t\treturn encoded;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t\tlogger.trace(exchange.getLogPrefix() +\n\t\t\t\t\t\t\t\t\"No \" + coding + \" resource for [\" + resource.getFilename() + \"]\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn resource;\n\t\t});\n\t}\n\n\t@Nullable\n\tprivate String getAcceptEncoding(ServerWebExchange exchange) {\n\t\tServerHttpRequest request = exchange.getRequest();\n\t\tString header = request.getHeaders().getFirst(HttpHeaders.ACCEPT_ENCODING);\n\t\treturn (header != null ? header.toLowerCase() : null);\n\t}\n\n\tprivate String getExtension(String coding) {\n\t\tString extension = this.extensions.get(coding);\n\t\tif (extension == null) {\n\t\t\tthrow new IllegalStateException(\"No file extension associated with content coding \" + coding);\n\t\t}\n\t\treturn extension;\n\t}\n\n\t@Override\n\tprotected Mono<String> resolveUrlPathInternal(String resourceUrlPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\treturn chain.resolveUrlPath(resourceUrlPath, locations);\n\t}\n\n\n\t/**\n\t * An encoded {@link HttpResource}.\n\t */\n\tstatic final class EncodedResource extends AbstractResource implements HttpResource {\n\n\t\tprivate final Resource original;\n\n\t\tprivate final String coding;\n\n\t\tprivate final Resource encoded;\n\n\t\tEncodedResource(Resource original, String coding, String extension) throws IOException {\n\t\t\tthis.original = original;\n\t\t\tthis.coding = coding;\n\t\t\tthis.encoded = original.createRelative(original.getFilename() + extension);\n\t\t}\n\n\t\t@Override\n\t\tpublic InputStream getInputStream() throws IOException {\n\t\t\treturn this.encoded.getInputStream();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean exists() {\n\t\t\treturn this.encoded.exists();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isReadable() {\n\t\t\treturn this.encoded.isReadable();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isOpen() {\n\t\t\treturn this.encoded.isOpen();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isFile() {\n\t\t\treturn this.encoded.isFile();\n\t\t}\n\n\t\t@Override\n\t\tpublic URL getURL() throws IOException {\n\t\t\treturn this.encoded.getURL();\n\t\t}\n\n\t\t@Override\n\t\tpublic URI getURI() throws IOException {\n\t\t\treturn this.encoded.getURI();\n\t\t}\n\n\t\t@Override\n\t\tpublic File getFile() throws IOException {\n\t\t\treturn this.encoded.getFile();\n\t\t}\n\n\t\t@Override\n\t\tpublic long contentLength() throws IOException {\n\t\t\treturn this.encoded.contentLength();\n\t\t}\n\n\t\t@Override\n\t\tpublic long lastModified() throws IOException {\n\t\t\treturn this.encoded.lastModified();\n\t\t}\n\n\t\t@Override\n\t\tpublic Resource createRelative(String relativePath) throws IOException {\n\t\t\treturn this.encoded.createRelative(relativePath);\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic String getFilename() {\n\t\t\treturn this.original.getFilename();\n\t\t}\n\n\t\t@Override\n\t\tpublic String getDescription() {\n\t\t\treturn this.encoded.getDescription();\n\t\t}\n\n\t\t@Override\n\t\tpublic HttpHeaders getResponseHeaders() {\n\t\t\tHttpHeaders headers;\n\t\t\tif (this.original instanceof HttpResource httpResource) {\n\t\t\t\theaders = httpResource.getResponseHeaders();\n\t\t\t}\n\t\t\telse {\n\t\t\t\theaders = new HttpHeaders();\n\t\t\t}\n\t\t\theaders.add(HttpHeaders.CONTENT_ENCODING, this.coding);\n\t\t\theaders.add(HttpHeaders.VARY, HttpHeaders.ACCEPT_ENCODING);\n\t\t\treturn headers;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#contentLength()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "long",
    "signature": "public long contentLength()",
    "source_code": "\t\tpublic long contentLength() throws IOException {\n\t\t\treturn this.encoded.contentLength();\n\t\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#createRelative(relativePath)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativePath"
    ],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "Resource",
    "signature": "public Resource createRelative(String relativePath)",
    "source_code": "\t\tpublic Resource createRelative(String relativePath) throws IOException {\n\t\t\treturn this.encoded.createRelative(relativePath);\n\t\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#exists()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "boolean",
    "signature": "public boolean exists()",
    "source_code": "\t\tpublic boolean exists() {\n\t\t\treturn this.encoded.exists();\n\t\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#getContentCodings()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a read-only list with the supported content codings.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "List<String>",
    "signature": "public List<String> getContentCodings()",
    "source_code": "\tpublic List<String> getContentCodings() {\n\t\treturn Collections.unmodifiableList(this.contentCodings);\n\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#getDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "String",
    "signature": "public String getDescription()",
    "source_code": "\t\tpublic String getDescription() {\n\t\t\treturn this.encoded.getDescription();\n\t\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#getExtensions()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a read-only map with coding-to-extension mappings.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "String>",
    "signature": "public String> getExtensions()",
    "source_code": "\tpublic Map<String, String> getExtensions() {\n\t\treturn Collections.unmodifiableMap(this.extensions);\n\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#getFile()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "File",
    "signature": "public File getFile()",
    "source_code": "\t\tpublic File getFile() throws IOException {\n\t\t\treturn this.encoded.getFile();\n\t\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#getFilename()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "String",
    "signature": "public String getFilename()",
    "source_code": "\t\tpublic String getFilename() {\n\t\t\treturn this.original.getFilename();\n\t\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#getInputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "InputStream",
    "signature": "public InputStream getInputStream()",
    "source_code": "\t\tpublic InputStream getInputStream() throws IOException {\n\t\t\treturn this.encoded.getInputStream();\n\t\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#getResponseHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getResponseHeaders()",
    "source_code": "\t\tpublic HttpHeaders getResponseHeaders() {\n\t\t\tHttpHeaders headers;\n\t\t\tif (this.original instanceof HttpResource httpResource) {\n\t\t\t\theaders = httpResource.getResponseHeaders();\n\t\t\t}\n\t\t\telse {\n\t\t\t\theaders = new HttpHeaders();\n\t\t\t}\n\t\t\theaders.add(HttpHeaders.CONTENT_ENCODING, this.coding);\n\t\t\theaders.add(HttpHeaders.VARY, HttpHeaders.ACCEPT_ENCODING);\n\t\t\treturn headers;\n\t\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#getURI()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "URI",
    "signature": "public URI getURI()",
    "source_code": "\t\tpublic URI getURI() throws IOException {\n\t\t\treturn this.encoded.getURI();\n\t\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#getURL()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "URL",
    "signature": "public URL getURL()",
    "source_code": "\t\tpublic URL getURL() throws IOException {\n\t\t\treturn this.encoded.getURL();\n\t\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#isFile()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "boolean",
    "signature": "public boolean isFile()",
    "source_code": "\t\tpublic boolean isFile() {\n\t\t\treturn this.encoded.isFile();\n\t\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#isOpen()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "boolean",
    "signature": "public boolean isOpen()",
    "source_code": "\t\tpublic boolean isOpen() {\n\t\t\treturn this.encoded.isOpen();\n\t\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#isReadable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "boolean",
    "signature": "public boolean isReadable()",
    "source_code": "\t\tpublic boolean isReadable() {\n\t\t\treturn this.encoded.isReadable();\n\t\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#lastModified()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "long",
    "signature": "public long lastModified()",
    "source_code": "\t\tpublic long lastModified() throws IOException {\n\t\t\treturn this.encoded.lastModified();\n\t\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#registerExtension(coding,extension)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Java config friendly alternative to {@link #setExtensions(Map)}.\n\t * @param coding the content coding\n\t * @param extension the associated file extension\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "coding",
      "extension"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void registerExtension(String coding, String extension)",
    "source_code": "\tpublic void registerExtension(String coding, String extension) {\n\t\tthis.extensions.put(coding, (extension.startsWith(\".\") ? extension : \".\" + extension));\n\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#resolveResourceInternal(exchange,requestPath,locations,chain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exchange",
      "requestPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "Mono<Resource>",
    "signature": "protected Mono<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,\n\t\t\tString requestPath, List<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected Mono<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#resolveUrlPathInternal(resourceUrlPath,locations,chain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourceUrlPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "Mono<String>",
    "signature": "protected Mono<String> resolveUrlPathInternal(String resourceUrlPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected Mono<String> resolveUrlPathInternal(String resourceUrlPath,"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#setContentCodings(codings)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the supported content codings in order of preference. The first\n\t * coding that is present in the {@literal \"Accept-Encoding\"} header for a\n\t * given request, and that has a file present with the associated extension,\n\t * is used.\n\t * <p><strong>Note:</strong> Each coding must be associated with a file\n\t * extension via {@link #registerExtension} or {@link #setExtensions}. Also\n\t * customizations to the list of codings here should be matched by\n\t * customizations to the same list in {@link CachingResourceResolver} to\n\t * ensure encoded variants of a resource are cached under separate keys.\n\t * <p>By default this property is set to {@literal [\"br\", \"gzip\"]}.\n\t * @param codings one or more supported content codings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codings"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void setContentCodings(List<String> codings)",
    "source_code": "\tpublic void setContentCodings(List<String> codings) {\n\t\tAssert.notEmpty(codings, \"At least one content coding expected\");\n\t\tthis.contentCodings.clear();\n\t\tthis.contentCodings.addAll(codings);\n\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#setExtensions(Map<String,extensions)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure mappings from content codings to file extensions. A dot \".\"\n\t * will be prepended in front of the extension value if not present.\n\t * <p>By default this is configured with {@literal [\"br\" -> \".br\"]} and\n\t * {@literal [\"gzip\" -> \".gz\"]}.\n\t * @param extensions the extensions to use.\n\t * @see #registerExtension(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "extensions"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void setExtensions(Map<String, String> extensions)",
    "source_code": "\tpublic void setExtensions(Map<String, String> extensions) {\n\t\textensions.forEach(this::registerExtension);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Resolve {@code @ModelAttribute} annotated method arguments.\n *\n * <p>Model attributes are sourced from the model, or created using a default\n * constructor and then added to the model. Once created the attribute is\n * populated via data binding to the request (form data, query params).\n * Validation also may be applied if the argument is annotated with\n * {@code @jakarta.validation.Valid} or Spring's own\n * {@code @org.springframework.validation.annotation.Validated}.\n *\n * <p>When this handler is created with {@code useDefaultResolution=true}\n * any non-simple type argument and return value is regarded as a model\n * attribute with or without the presence of an {@code @ModelAttribute}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "signature": "public class ModelAttributeMethodArgumentResolver",
    "source_code": "public class ModelAttributeMethodArgumentResolver extends HandlerMethodArgumentResolverSupport {\n\n\tprivate final boolean useDefaultResolution;\n\n\n\t/**\n\t * Class constructor with a default resolution mode flag.\n\t * @param adapterRegistry for adapting to other reactive types from and to Mono\n\t * @param useDefaultResolution if \"true\", non-simple method arguments and\n\t * return values are considered model attributes with or without a\n\t * {@code @ModelAttribute} annotation present.\n\t */\n\tpublic ModelAttributeMethodArgumentResolver(ReactiveAdapterRegistry adapterRegistry,\n\t\t\tboolean useDefaultResolution) {\n\n\t\tsuper(adapterRegistry);\n\t\tthis.useDefaultResolution = useDefaultResolution;\n\t}\n\n\n\t@Override\n\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\tif (parameter.hasParameterAnnotation(ModelAttribute.class)) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (this.useDefaultResolution) {\n\t\t\treturn checkParameterType(parameter, type -> !BeanUtils.isSimpleProperty(type));\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Mono<Object> resolveArgument(\n\t\t\tMethodParameter parameter, BindingContext context, ServerWebExchange exchange) {\n\n\t\tResolvableType type = ResolvableType.forMethodParameter(parameter);\n\t\tClass<?> resolvedType = type.resolve();\n\t\tReactiveAdapter adapter = (resolvedType != null ? getAdapterRegistry().getAdapter(resolvedType) : null);\n\t\tResolvableType valueType = (adapter != null ? type.getGeneric() : type);\n\n\t\tAssert.state(adapter == null || !adapter.isMultiValue(),\n\t\t\t\t() -> getClass().getSimpleName() + \" does not support multi-value reactive type wrapper: \" +\n\t\t\t\t\t\tparameter.getGenericParameterType());\n\n\t\tString name = ModelInitializer.getNameForParameter(parameter);\n\t\tMono<?> valueMono = prepareAttributeMono(name, valueType, context, exchange);\n\n\t\t// unsafe(): we're intercepting, already serialized Publisher signals\n\t\tSinks.One<BindingResult> bindingResultSink = Sinks.unsafe().one();\n\n\t\tMap<String, Object> model = context.getModel().asMap();\n\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, bindingResultSink.asMono());\n\n\t\treturn valueMono.flatMap(value -> {\n\t\t\tWebExchangeDataBinder binder = context.createDataBinder(exchange, value, name);\n\t\t\treturn (bindingDisabled(parameter) ? Mono.empty() : bindRequestParameters(binder, exchange))\n\t\t\t\t\t.doOnError(bindingResultSink::tryEmitError)\n\t\t\t\t\t.doOnSuccess(aVoid -> {\n\t\t\t\t\t\tvalidateIfApplicable(binder, parameter);\n\t\t\t\t\t\tBindingResult bindingResult = binder.getBindingResult();\n\t\t\t\t\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, bindingResult);\n\t\t\t\t\t\tmodel.put(name, value);\n\t\t\t\t\t\t// Ignore result: serialized and buffered (should never fail)\n\t\t\t\t\t\tbindingResultSink.tryEmitValue(bindingResult);\n\t\t\t\t\t})\n\t\t\t\t\t.then(Mono.fromCallable(() -> {\n\t\t\t\t\t\tBindingResult errors = binder.getBindingResult();\n\t\t\t\t\t\tif (adapter != null) {\n\t\t\t\t\t\t\treturn adapter.fromPublisher(errors.hasErrors() ?\n\t\t\t\t\t\t\t\t\tMono.error(new WebExchangeBindException(parameter, errors)) : valueMono);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (errors.hasErrors() && !hasErrorsArgument(parameter)) {\n\t\t\t\t\t\t\t\tthrow new WebExchangeBindException(parameter, errors);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t});\n\t}\n\n\t/**\n\t * Determine if binding should be disabled for the supplied {@link MethodParameter},\n\t * based on the {@link ModelAttribute#binding} annotation attribute.\n\t * @since 5.2.15\n\t */\n\tprivate boolean bindingDisabled(MethodParameter parameter) {\n\t\tModelAttribute modelAttribute = parameter.getParameterAnnotation(ModelAttribute.class);\n\t\treturn (modelAttribute != null && !modelAttribute.binding());\n\t}\n\n\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param exchange the current request\n\t * @since 5.2.6\n\t */\n\tprotected Mono<Void> bindRequestParameters(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.bind(exchange);\n\t}\n\n\tprivate Mono<?> prepareAttributeMono(String attributeName, ResolvableType attributeType,\n\t\t\tBindingContext context, ServerWebExchange exchange) {\n\n\t\tObject attribute = context.getModel().asMap().get(attributeName);\n\n\t\tif (attribute == null) {\n\t\t\tattribute = findAndRemoveReactiveAttribute(context.getModel(), attributeName);\n\t\t}\n\n\t\tif (attribute == null) {\n\t\t\treturn createAttribute(attributeName, attributeType.toClass(), context, exchange);\n\t\t}\n\n\t\tReactiveAdapter adapter = getAdapterRegistry().getAdapter(null, attribute);\n\t\tif (adapter != null) {\n\t\t\tAssert.isTrue(!adapter.isMultiValue(), \"Data binding only supports single-value async types\");\n\t\t\treturn Mono.from(adapter.toPublisher(attribute));\n\t\t}\n\t\telse {\n\t\t\treturn Mono.justOrEmpty(attribute);\n\t\t}\n\t}\n\n\t@Nullable\n\tprivate Object findAndRemoveReactiveAttribute(Model model, String attributeName) {\n\t\treturn model.asMap().entrySet().stream()\n\t\t\t\t.filter(entry -> {\n\t\t\t\t\tif (!entry.getKey().startsWith(attributeName)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tReactiveAdapter adapter = getAdapterRegistry().getAdapter(null, entry.getValue());\n\t\t\t\t\tif (adapter == null) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tString name = attributeName + ClassUtils.getShortName(adapter.getReactiveType());\n\t\t\t\t\treturn entry.getKey().equals(name);\n\t\t\t\t})\n\t\t\t\t.findFirst()\n\t\t\t\t.map(entry -> {\n\t\t\t\t\t// Remove since we will be re-inserting the resolved attribute value\n\t\t\t\t\tmodel.asMap().remove(entry.getKey());\n\t\t\t\t\treturn entry.getValue();\n\t\t\t\t})\n\t\t\t\t.orElse(null);\n\t}\n\n\tprivate Mono<?> createAttribute(\n\t\t\tString attributeName, Class<?> clazz, BindingContext context, ServerWebExchange exchange) {\n\n\t\tConstructor<?> ctor = BeanUtils.getResolvableConstructor(clazz);\n\t\treturn constructAttribute(ctor, attributeName, context, exchange);\n\t}\n\n\tprivate Mono<?> constructAttribute(Constructor<?> ctor, String attributeName,\n\t\t\tBindingContext context, ServerWebExchange exchange) {\n\n\t\tif (ctor.getParameterCount() == 0) {\n\t\t\t// A single default constructor -> clearly a standard JavaBeans arrangement.\n\t\t\treturn Mono.just(BeanUtils.instantiateClass(ctor));\n\t\t}\n\n\t\t// A single data class constructor -> resolve constructor arguments from request parameters.\n\t\tWebExchangeDataBinder binder = context.createDataBinder(exchange, null, attributeName);\n\t\treturn getValuesToBind(binder, exchange).map(bindValues -> {\n\t\t\tString[] paramNames = BeanUtils.getParameterNames(ctor);\n\t\t\tClass<?>[] paramTypes = ctor.getParameterTypes();\n\t\t\tObject[] args = new Object[paramTypes.length];\n\t\t\tString fieldDefaultPrefix = binder.getFieldDefaultPrefix();\n\t\t\tString fieldMarkerPrefix = binder.getFieldMarkerPrefix();\n\t\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\t\tString paramName = paramNames[i];\n\t\t\t\tClass<?> paramType = paramTypes[i];\n\t\t\t\tObject value = bindValues.get(paramName);\n\t\t\t\tif (value == null) {\n\t\t\t\t\tif (fieldDefaultPrefix != null) {\n\t\t\t\t\t\tvalue = bindValues.get(fieldDefaultPrefix + paramName);\n\t\t\t\t\t}\n\t\t\t\t\tif (value == null && fieldMarkerPrefix != null) {\n\t\t\t\t\t\tif (bindValues.get(fieldMarkerPrefix + paramName) != null) {\n\t\t\t\t\t\t\tvalue = binder.getEmptyValue(paramType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvalue = (value instanceof List<?> list ? list.toArray() : value);\n\t\t\t\tMethodParameter methodParam = new MethodParameter(ctor, i);\n\t\t\t\tif (value == null && methodParam.isOptional()) {\n\t\t\t\t\targs[i] = (methodParam.getParameterType() == Optional.class ? Optional.empty() : null);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\targs[i] = binder.convertIfNecessary(value, paramTypes[i], methodParam);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn BeanUtils.instantiateClass(ctor, args);\n\t\t});\n\t}\n\n\t/**\n\t * Protected method to obtain the values for data binding. By default this\n\t * method delegates to {@link WebExchangeDataBinder#getValuesToBind}.\n\t * @param binder the data binder in use\n\t * @param exchange the current exchange\n\t * @return a map of bind values\n\t * @since 5.3\n\t */\n\tpublic Mono<Map<String, Object>> getValuesToBind(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.getValuesToBind(exchange);\n\t}\n\n\tprivate boolean hasErrorsArgument(MethodParameter parameter) {\n\t\tint i = parameter.getParameterIndex();\n\t\tClass<?>[] paramTypes = parameter.getExecutable().getParameterTypes();\n\t\treturn (paramTypes.length > i + 1 && Errors.class.isAssignableFrom(paramTypes[i + 1]));\n\t}\n\n\tprivate void validateIfApplicable(WebExchangeDataBinder binder, MethodParameter parameter) {\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tbinder.validate(validationHints);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver#bindRequestParameters(binder,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param exchange the current request\n\t * @since 5.2.6\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> bindRequestParameters(WebExchangeDataBinder binder, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<Void> bindRequestParameters(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.bind(exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver#getValuesToBind(binder,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Protected method to obtain the values for data binding. By default this\n\t * method delegates to {@link WebExchangeDataBinder#getValuesToBind}.\n\t * @param binder the data binder in use\n\t * @param exchange the current exchange\n\t * @return a map of bind values\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "binder",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "Object>>",
    "signature": "public Object>> getValuesToBind(WebExchangeDataBinder binder, ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Map<String, Object>> getValuesToBind(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.getValuesToBind(exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver#resolveArgument(parameter,context,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "context",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "Mono<Object>",
    "signature": "public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext context, ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Object> resolveArgument("
  },
  "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver#supportsParameter(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "boolean",
    "signature": "public boolean supportsParameter(MethodParameter parameter)",
    "source_code": "\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\tif (parameter.hasParameterAnnotation(ModelAttribute.class)) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (this.useDefaultResolution) {\n\t\t\treturn checkParameterType(parameter, type -> !BeanUtils.isSimpleProperty(type));\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An extension of {@link RequestMappingInfoHandlerMapping} that creates\n * {@link RequestMappingInfo} instances from class-level and method-level\n * {@link RequestMapping @RequestMapping} annotations.\n *\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "signature": "public class RequestMappingHandlerMapping",
    "source_code": "public class RequestMappingHandlerMapping extends RequestMappingInfoHandlerMapping"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tthis.config = new RequestMappingInfo.BuilderConfiguration();\n\t\tthis.config.setPatternParser(getPathPatternParser());\n\t\tthis.config.setContentTypeResolver(getContentTypeResolver());\n\n\t\tsuper.afterPropertiesSet();\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping#createRequestMappingInfo(requestMapping,customCondition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RequestMappingInfo} from the supplied\n\t * {@link RequestMapping @RequestMapping} annotation, which is either\n\t * a directly declared annotation, a meta-annotation, or the synthesized\n\t * result of merging annotation attributes within an annotation hierarchy.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "requestMapping",
      "customCondition"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo createRequestMappingInfo(RequestMapping requestMapping, @Nullable RequestCondition<?> customCondition)",
    "source_code": "\tprotected RequestMappingInfo createRequestMappingInfo("
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping#getContentTypeResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link RequestedContentTypeResolver}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "RequestedContentTypeResolver",
    "signature": "public RequestedContentTypeResolver getContentTypeResolver()",
    "source_code": "\tpublic RequestedContentTypeResolver getContentTypeResolver() {\n\t\treturn this.contentTypeResolver;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping#getMappingForMethod(method,handlerType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Uses method and type-level @{@link RequestMapping} annotations to create\n\t * the RequestMappingInfo.\n\t * @return the created RequestMappingInfo, or {@code null} if the method\n\t * does not have a {@code @RequestMapping} annotation.\n\t * @see #getCustomMethodCondition(Method)\n\t * @see #getCustomTypeCondition(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n\t\tRequestMappingInfo info = createRequestMappingInfo(method);\n\t\tif (info != null) {\n\t\t\tRequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);\n\t\t\tif (typeInfo != null) {\n\t\t\t\tinfo = typeInfo.combine(info);\n\t\t\t}\n\t\t\tfor (Map.Entry<String, Predicate<Class<?>>> entry : this.pathPrefixes.entrySet()) {\n\t\t\t\tif (entry.getValue().test(handlerType)) {\n\t\t\t\t\tString prefix = entry.getKey();\n\t\t\t\t\tif (this.embeddedValueResolver != null) {\n\t\t\t\t\t\tprefix = this.embeddedValueResolver.resolveStringValue(prefix);\n\t\t\t\t\t}\n\t\t\t\t\tinfo = RequestMappingInfo.paths(prefix).options(this.config).build().combine(info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn info;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping#initCorsConfiguration(handler,method,mappingInfo)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mappingInfo"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mappingInfo)",
    "source_code": "\tprotected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mappingInfo) {\n\t\tHandlerMethod handlerMethod = createHandlerMethod(handler, method);\n\t\tClass<?> beanType = handlerMethod.getBeanType();\n\t\tCrossOrigin typeAnnotation = AnnotatedElementUtils.findMergedAnnotation(beanType, CrossOrigin.class);\n\t\tCrossOrigin methodAnnotation = AnnotatedElementUtils.findMergedAnnotation(method, CrossOrigin.class);\n\n\t\tif (typeAnnotation == null && methodAnnotation == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tCorsConfiguration config = new CorsConfiguration();\n\t\tupdateCorsConfig(config, typeAnnotation);\n\t\tupdateCorsConfig(config, methodAnnotation);\n\n\t\tif (CollectionUtils.isEmpty(config.getAllowedMethods())) {\n\t\t\tfor (RequestMethod allowedMethod : mappingInfo.getMethodsCondition().getMethods()) {\n\t\t\t\tconfig.addAllowedMethod(allowedMethod.name());\n\t\t\t}\n\t\t}\n\t\treturn config.applyPermitDefaultValues();\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping#isHandler(beanType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * Expects a handler to have a type-level @{@link Controller} annotation.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanType"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "boolean",
    "signature": "protected boolean isHandler(Class<?> beanType)",
    "source_code": "\tprotected boolean isHandler(Class<?> beanType) {\n\t\treturn AnnotatedElementUtils.hasAnnotation(beanType, Controller.class);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping#registerHandlerMethod(handler,method,mapping)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "void",
    "signature": "protected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping)",
    "source_code": "\tprotected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping) {\n\t\tsuper.registerHandlerMethod(handler, method, mapping);\n\t\tupdateConsumesCondition(mapping, method);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping#registerMapping(mapping,handler,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "void",
    "signature": "public void registerMapping(RequestMappingInfo mapping, Object handler, Method method)",
    "source_code": "\tpublic void registerMapping(RequestMappingInfo mapping, Object handler, Method method) {\n\t\tsuper.registerMapping(mapping, handler, method);\n\t\tupdateConsumesCondition(mapping, method);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping#resolveEmbeddedValuesInPatterns(patterns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve placeholder values in the given array of patterns.\n\t * @return a new array with updated patterns\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "patterns"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "String[]",
    "signature": "protected String[] resolveEmbeddedValuesInPatterns(String[] patterns)",
    "source_code": "\tprotected String[] resolveEmbeddedValuesInPatterns(String[] patterns) {\n\t\tif (this.embeddedValueResolver == null) {\n\t\t\treturn patterns;\n\t\t}\n\t\telse {\n\t\t\tString[] resolvedPatterns = new String[patterns.length];\n\t\t\tfor (int i = 0; i < patterns.length; i++) {\n\t\t\t\tresolvedPatterns[i] = this.embeddedValueResolver.resolveStringValue(patterns[i]);\n\t\t\t}\n\t\t\treturn resolvedPatterns;\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping#setContentTypeResolver(contentTypeResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link RequestedContentTypeResolver} to use to determine requested\n\t * media types. If not set, the default constructor is used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentTypeResolver"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void setContentTypeResolver(RequestedContentTypeResolver contentTypeResolver)",
    "source_code": "\tpublic void setContentTypeResolver(RequestedContentTypeResolver contentTypeResolver) {\n\t\tAssert.notNull(contentTypeResolver, \"'contentTypeResolver' must not be null\");\n\t\tthis.contentTypeResolver = contentTypeResolver;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping#setEmbeddedValueResolver(resolver)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void setEmbeddedValueResolver(StringValueResolver resolver)",
    "source_code": "\tpublic void setEmbeddedValueResolver(StringValueResolver resolver) {\n\t\tthis.embeddedValueResolver = resolver;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping#setPathPrefixes(Map<String,prefixes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure path prefixes to apply to controller methods.\n\t * <p>Prefixes are used to enrich the mappings of every {@code @RequestMapping}\n\t * method whose controller type is matched by a corresponding\n\t * {@code Predicate} in the map. The prefix for the first matching predicate\n\t * is used, assuming the input map has predictable order.\n\t * <p>Consider using {@link org.springframework.web.method.HandlerTypePredicate\n\t * HandlerTypePredicate} to group controllers.\n\t * @param prefixes a map with path prefixes as key\n\t * @since 5.1\n\t * @see org.springframework.web.method.HandlerTypePredicate\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "prefixes"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void setPathPrefixes(Map<String, Predicate<Class<?>>> prefixes)",
    "source_code": "\tpublic void setPathPrefixes(Map<String, Predicate<Class<?>>> prefixes) {\n\t\tthis.pathPrefixes.clear();\n\t\tprefixes.entrySet().stream()\n\t\t\t\t.filter(entry -> StringUtils.hasText(entry.getKey()))\n\t\t\t\t.forEach(entry -> this.pathPrefixes.put(entry.getKey(), entry.getValue()));\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.ResponseEntityExceptionHandler#getMessageSource()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link MessageSource} that this exception handler uses.\n\t * @since 6.0.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "MessageSource",
    "signature": "protected MessageSource getMessageSource()",
    "source_code": "\tprotected MessageSource getMessageSource() {\n\t\treturn this.messageSource;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.ServerWebExchangeMethodArgumentResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Resolves ServerWebExchange-related method argument values of the following types:\n * <ul>\n * <li>{@link ServerWebExchange}\n * <li>{@link ServerHttpRequest}\n * <li>{@link ServerHttpResponse}\n * <li>{@link HttpMethod}\n * <li>{@link Locale}\n * <li>{@link TimeZone}\n * <li>{@link ZoneId}\n * <li>{@link UriBuilder} or {@link UriComponentsBuilder} -- for building URL's\n * relative to the current request\n * </ul>\n *\n * <p>For the {@code WebSession} see {@link WebSessionMethodArgumentResolver}\n * and for the {@code Principal} see {@link PrincipalMethodArgumentResolver}.\n *\n * @author Rossen Stoyanchev\n * @since 5.2\n * @see WebSessionMethodArgumentResolver\n * @see PrincipalMethodArgumentResolver\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "signature": "public class ServerWebExchangeMethodArgumentResolver",
    "source_code": "public class ServerWebExchangeMethodArgumentResolver extends HandlerMethodArgumentResolverSupport"
  },
  "org.springframework.web.reactive.result.method.annotation.ServerWebExchangeMethodArgumentResolver#resolveArgumentValue(methodParameter,context,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodParameter",
      "context",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "Object",
    "signature": "public Object resolveArgumentValue(MethodParameter methodParameter, BindingContext context, ServerWebExchange exchange)",
    "source_code": "\tpublic Object resolveArgumentValue("
  },
  "org.springframework.web.reactive.result.method.annotation.ServerWebExchangeMethodArgumentResolver#supportsParameter(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "boolean",
    "signature": "public boolean supportsParameter(MethodParameter parameter)",
    "source_code": "\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\treturn checkParameterTypeNoReactiveWrapper(parameter,\n\t\t\t\ttype -> ServerWebExchange.class.isAssignableFrom(type) ||\n\t\t\t\t\t\tServerHttpRequest.class.isAssignableFrom(type) ||\n\t\t\t\t\t\tServerHttpResponse.class.isAssignableFrom(type) ||\n\t\t\t\t\t\tHttpMethod.class == type ||\n\t\t\t\t\t\tLocale.class == type ||\n\t\t\t\t\t\tTimeZone.class == type ||\n\t\t\t\t\t\tZoneId.class == type ||\n\t\t\t\t\t\tUriBuilder.class == type || UriComponentsBuilder.class == type);\n\t}"
  },
  "org.springframework.web.reactive.result.view.BindStatus": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Simple adapter to expose the bind status of a field or object.\n * Set as a variable by FreeMarker macros and other tag libraries.\n *\n * <p>Obviously, object status representations (i.e. errors at the object level\n * rather than the field level) do not have an expression and a value but only\n * error codes and messages. For simplicity's sake and to be able to use the same\n * tags and macros, the same status class is used for both scenarios.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 5.0\n * @see RequestContext#getBindStatus\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class BindStatus",
    "source_code": "public class BindStatus {\n\n\tprivate final RequestContext requestContext;\n\n\tprivate final String path;\n\n\tprivate final boolean htmlEscape;\n\n\t@Nullable\n\tprivate final String expression;\n\n\t@Nullable\n\tprivate final Errors errors;\n\n\tprivate final String[] errorCodes;\n\n\t@Nullable\n\tprivate String[] errorMessages;\n\n\t@Nullable\n\tprivate List<? extends ObjectError> objectErrors;\n\n\t@Nullable\n\tprivate Object value;\n\n\t@Nullable\n\tprivate Class<?> valueType;\n\n\t@Nullable\n\tprivate Object actualValue;\n\n\t@Nullable\n\tprivate PropertyEditor editor;\n\n\t@Nullable\n\tprivate BindingResult bindingResult;\n\n\n\t/**\n\t * Create a new BindStatus instance, representing a field or object status.\n\t * @param requestContext the current RequestContext\n\t * @param path the bean and property path for which values and errors\n\t * will be resolved (e.g. \"customer.address.street\")\n\t * @param htmlEscape whether to HTML-escape error messages and string values\n\t * @throws IllegalStateException if no corresponding Errors object found\n\t */\n\tpublic BindStatus(RequestContext requestContext, String path, boolean htmlEscape) throws IllegalStateException {\n\t\tthis.requestContext = requestContext;\n\t\tthis.path = path;\n\t\tthis.htmlEscape = htmlEscape;\n\n\t\t// determine name of the object and property\n\t\tString beanName;\n\t\tint dotPos = path.indexOf('.');\n\t\tif (dotPos == -1) {\n\t\t\t// property not set, only the object itself\n\t\t\tbeanName = path;\n\t\t\tthis.expression = null;\n\t\t}\n\t\telse {\n\t\t\tbeanName = path.substring(0, dotPos);\n\t\t\tthis.expression = path.substring(dotPos + 1);\n\t\t}\n\n\t\tthis.errors = requestContext.getErrors(beanName, false);\n\n\t\tif (this.errors != null) {\n\t\t\t// Usual case: A BindingResult is available as request attribute.\n\t\t\t// Can determine error codes and messages for the given expression.\n\t\t\t// Can use a custom PropertyEditor, as registered by a form controller.\n\t\t\tif (this.expression != null) {\n\t\t\t\tif (\"*\".equals(this.expression)) {\n\t\t\t\t\tthis.objectErrors = this.errors.getAllErrors();\n\t\t\t\t}\n\t\t\t\telse if (this.expression.endsWith(\"*\")) {\n\t\t\t\t\tthis.objectErrors = this.errors.getFieldErrors(this.expression);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.objectErrors = this.errors.getFieldErrors(this.expression);\n\t\t\t\t\tthis.value = this.errors.getFieldValue(this.expression);\n\t\t\t\t\tthis.valueType = this.errors.getFieldType(this.expression);\n\t\t\t\t\tif (this.errors instanceof BindingResult br) {\n\t\t\t\t\t\tthis.bindingResult = br;\n\t\t\t\t\t\tthis.actualValue = this.bindingResult.getRawFieldValue(this.expression);\n\t\t\t\t\t\tthis.editor = this.bindingResult.findEditor(this.expression, null);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.actualValue = this.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.objectErrors = this.errors.getGlobalErrors();\n\t\t\t}\n\t\t\tthis.errorCodes = initErrorCodes(this.objectErrors);\n\t\t}\n\n\t\telse {\n\t\t\t// No BindingResult available as request attribute:\n\t\t\t// Probably forwarded directly to a form view.\n\t\t\t// Let's do the best we can: extract a plain target if appropriate.\n\t\t\tObject target = requestContext.getModelObject(beanName);\n\t\t\tif (target == null) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Neither BindingResult nor plain target object for bean name '\" +\n\t\t\t\t\t\tbeanName + \"' available as request attribute\");\n\t\t\t}\n\t\t\tif (this.expression != null && !\"*\".equals(this.expression) && !this.expression.endsWith(\"*\")) {\n\t\t\t\tBeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(target);\n\t\t\t\tthis.value = bw.getPropertyValue(this.expression);\n\t\t\t\tthis.valueType = bw.getPropertyType(this.expression);\n\t\t\t\tthis.actualValue = this.value;\n\t\t\t}\n\t\t\tthis.errorCodes = new String[0];\n\t\t\tthis.errorMessages = new String[0];\n\t\t}\n\n\t\tif (htmlEscape && this.value instanceof String text) {\n\t\t\tthis.value = HtmlUtils.htmlEscape(text);\n\t\t}\n\t}\n\n\t/**\n\t * Extract the error codes from the ObjectError list.\n\t */\n\tprivate static String[] initErrorCodes(List<? extends ObjectError> objectErrors) {\n\t\tString[] errorCodes = new String[objectErrors.size()];\n\t\tfor (int i = 0; i < objectErrors.size(); i++) {\n\t\t\tObjectError error = objectErrors.get(i);\n\t\t\terrorCodes[i] = error.getCode();\n\t\t}\n\t\treturn errorCodes;\n\t}\n\n\n\t/**\n\t * Return the bean and property path for which values and errors\n\t * will be resolved (e.g. \"customer.address.street\").\n\t */\n\tpublic String getPath() {\n\t\treturn this.path;\n\t}\n\n\t/**\n\t * Return a bind expression that can be used in HTML forms as input name\n\t * for the respective field, or {@code null} if not field-specific.\n\t * <p>Returns a bind path appropriate for resubmission, e.g. \"address.street\".\n\t * Note that the complete bind path as required by the bind tag is\n\t * \"customer.address.street\", if bound to a \"customer\" bean.\n\t */\n\t@Nullable\n\tpublic String getExpression() {\n\t\treturn this.expression;\n\t}\n\n\t/**\n\t * Return the current value of the field, i.e. either the property value\n\t * or a rejected update, or {@code null} if not field-specific.\n\t * <p>This value will be an HTML-escaped String if the original value\n\t * already was a String.\n\t */\n\t@Nullable\n\tpublic Object getValue() {\n\t\treturn this.value;\n\t}\n\n\t/**\n\t * Get the '{@code Class}' type of the field. Favor this instead of\n\t * '{@code getValue().getClass()}' since '{@code getValue()}' may\n\t * return '{@code null}'.\n\t */\n\t@Nullable\n\tpublic Class<?> getValueType() {\n\t\treturn this.valueType;\n\t}\n\n\t/**\n\t * Return the actual value of the field, i.e. the raw property value,\n\t * or {@code null} if not available.\n\t */\n\t@Nullable\n\tpublic Object getActualValue() {\n\t\treturn this.actualValue;\n\t}\n\n\t/**\n\t * Return a suitable display value for the field, i.e. the stringified\n\t * value if not null, and an empty string in case of a null value.\n\t * <p>This value will be an HTML-escaped String if the original value\n\t * was non-null: the {@code toString} result of the original value\n\t * will get HTML-escaped.\n\t */\n\tpublic String getDisplayValue() {\n\t\tif (this.value instanceof String displayValue) {\n\t\t\treturn displayValue;\n\t\t}\n\t\tif (this.value != null) {\n\t\t\treturn (this.htmlEscape ?\n\t\t\t\t\tHtmlUtils.htmlEscape(this.value.toString()) : this.value.toString());\n\t\t}\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Return if this status represents a field or object error.\n\t */\n\tpublic boolean isError() {\n\t\treturn (this.errorCodes.length > 0);\n\t}\n\n\t/**\n\t * Return the error codes for the field or object, if any.\n\t * Returns an empty array instead of null if none.\n\t */\n\tpublic String[] getErrorCodes() {\n\t\treturn this.errorCodes;\n\t}\n\n\t/**\n\t * Return the first error codes for the field or object, if any.\n\t */\n\tpublic String getErrorCode() {\n\t\treturn (!ObjectUtils.isEmpty(this.errorCodes) ? this.errorCodes[0] : \"\");\n\t}\n\n\t/**\n\t * Return the resolved error messages for the field or object,\n\t * if any. Returns an empty array instead of null if none.\n\t */\n\tpublic String[] getErrorMessages() {\n\t\treturn initErrorMessages();\n\t}\n\n\t/**\n\t * Return the first error message for the field or object, if any.\n\t */\n\tpublic String getErrorMessage() {\n\t\tString[] errorMessages = initErrorMessages();\n\t\treturn (errorMessages.length > 0 ? errorMessages[0] : \"\");\n\t}\n\n\t/**\n\t * Return an error message string, concatenating all messages\n\t * separated by the given delimiter.\n\t * @param delimiter separator string, e.g. \", \" or \"<br>\"\n\t * @return the error message string\n\t */\n\tpublic String getErrorMessagesAsString(String delimiter) {\n\t\treturn StringUtils.arrayToDelimitedString(initErrorMessages(), delimiter);\n\t}\n\n\t/**\n\t * Extract the error messages from the ObjectError list.\n\t */\n\tprivate String[] initErrorMessages() throws NoSuchMessageException {\n\t\tif (this.errorMessages == null) {\n\t\t\tif (this.objectErrors != null) {\n\t\t\t\tthis.errorMessages = new String[this.objectErrors.size()];\n\t\t\t\tfor (int i = 0; i < this.objectErrors.size(); i++) {\n\t\t\t\t\tObjectError error = this.objectErrors.get(i);\n\t\t\t\t\tthis.errorMessages[i] = this.requestContext.getMessage(error, this.htmlEscape);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.errorMessages = new String[0];\n\t\t\t}\n\t\t}\n\t\treturn this.errorMessages;\n\t}\n\n\t/**\n\t * Return the Errors instance (typically a BindingResult) that this\n\t * bind status is currently associated with.\n\t * @return the current Errors instance, or {@code null} if none\n\t * @see org.springframework.validation.BindingResult\n\t */\n\t@Nullable\n\tpublic Errors getErrors() {\n\t\treturn this.errors;\n\t}\n\n\t/**\n\t * Return the PropertyEditor for the property that this bind status\n\t * is currently bound to.\n\t * @return the current PropertyEditor, or {@code null} if none\n\t */\n\t@Nullable\n\tpublic PropertyEditor getEditor() {\n\t\treturn this.editor;\n\t}\n\n\t/**\n\t * Find a PropertyEditor for the given value class, associated with\n\t * the property that this bound status is currently bound to.\n\t * @param valueClass the value class that an editor is needed for\n\t * @return the associated PropertyEditor, or {@code null} if none\n\t */\n\t@Nullable\n\tpublic PropertyEditor findEditor(Class<?> valueClass) {\n\t\treturn (this.bindingResult != null ?\n\t\t\t\tthis.bindingResult.findEditor(this.expression, valueClass) : null);\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(\"BindStatus: \");\n\t\tsb.append(\"expression=[\").append(this.expression).append(\"]; \");\n\t\tsb.append(\"value=[\").append(this.value).append(']');\n\t\tif (!ObjectUtils.isEmpty(this.errorCodes)) {\n\t\t\tsb.append(\"; errorCodes=\").append(Arrays.asList(this.errorCodes));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n}"
  },
  "org.springframework.web.reactive.result.view.BindStatus#findEditor(valueClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a PropertyEditor for the given value class, associated with\n\t * the property that this bound status is currently bound to.\n\t * @param valueClass the value class that an editor is needed for\n\t * @return the associated PropertyEditor, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "valueClass"
    ],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "PropertyEditor",
    "signature": "public PropertyEditor findEditor(Class<?> valueClass)",
    "source_code": "\tpublic PropertyEditor findEditor(Class<?> valueClass) {\n\t\treturn (this.bindingResult != null ?\n\t\t\t\tthis.bindingResult.findEditor(this.expression, valueClass) : null);\n\t}"
  },
  "org.springframework.web.reactive.result.view.BindStatus#getActualValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the actual value of the field, i.e. the raw property value,\n\t * or {@code null} if not available.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "Object",
    "signature": "public Object getActualValue()",
    "source_code": "\tpublic Object getActualValue() {\n\t\treturn this.actualValue;\n\t}"
  },
  "org.springframework.web.reactive.result.view.BindStatus#getDisplayValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a suitable display value for the field, i.e. the stringified\n\t * value if not null, and an empty string in case of a null value.\n\t * <p>This value will be an HTML-escaped String if the original value\n\t * was non-null: the {@code toString} result of the original value\n\t * will get HTML-escaped.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "String",
    "signature": "public String getDisplayValue()",
    "source_code": "\tpublic String getDisplayValue() {\n\t\tif (this.value instanceof String displayValue) {\n\t\t\treturn displayValue;\n\t\t}\n\t\tif (this.value != null) {\n\t\t\treturn (this.htmlEscape ?\n\t\t\t\t\tHtmlUtils.htmlEscape(this.value.toString()) : this.value.toString());\n\t\t}\n\t\treturn \"\";\n\t}"
  },
  "org.springframework.web.reactive.result.view.BindStatus#getEditor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the PropertyEditor for the property that this bind status\n\t * is currently bound to.\n\t * @return the current PropertyEditor, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "PropertyEditor",
    "signature": "public PropertyEditor getEditor()",
    "source_code": "\tpublic PropertyEditor getEditor() {\n\t\treturn this.editor;\n\t}"
  },
  "org.springframework.web.reactive.result.view.BindStatus#getErrorCode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the first error codes for the field or object, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "String",
    "signature": "public String getErrorCode()",
    "source_code": "\tpublic String getErrorCode() {\n\t\treturn (!ObjectUtils.isEmpty(this.errorCodes) ? this.errorCodes[0] : \"\");\n\t}"
  },
  "org.springframework.web.reactive.result.view.BindStatus#getErrorCodes()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the error codes for the field or object, if any.\n\t * Returns an empty array instead of null if none.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "String[]",
    "signature": "public String[] getErrorCodes()",
    "source_code": "\tpublic String[] getErrorCodes() {\n\t\treturn this.errorCodes;\n\t}"
  },
  "org.springframework.web.reactive.result.view.BindStatus#getErrorMessage()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the first error message for the field or object, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "String",
    "signature": "public String getErrorMessage()",
    "source_code": "\tpublic String getErrorMessage() {\n\t\tString[] errorMessages = initErrorMessages();\n\t\treturn (errorMessages.length > 0 ? errorMessages[0] : \"\");\n\t}"
  },
  "org.springframework.web.reactive.result.view.BindStatus#getErrorMessages()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the resolved error messages for the field or object,\n\t * if any. Returns an empty array instead of null if none.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "String[]",
    "signature": "public String[] getErrorMessages()",
    "source_code": "\tpublic String[] getErrorMessages() {\n\t\treturn initErrorMessages();\n\t}"
  },
  "org.springframework.web.reactive.result.view.BindStatus#getErrorMessagesAsString(delimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an error message string, concatenating all messages\n\t * separated by the given delimiter.\n\t * @param delimiter separator string, e.g. \", \" or \"<br>\"\n\t * @return the error message string\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "String",
    "signature": "public String getErrorMessagesAsString(String delimiter)",
    "source_code": "\tpublic String getErrorMessagesAsString(String delimiter) {\n\t\treturn StringUtils.arrayToDelimitedString(initErrorMessages(), delimiter);\n\t}"
  },
  "org.springframework.web.reactive.result.view.BindStatus#getErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Errors instance (typically a BindingResult) that this\n\t * bind status is currently associated with.\n\t * @return the current Errors instance, or {@code null} if none\n\t * @see org.springframework.validation.BindingResult\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "Errors",
    "signature": "public Errors getErrors()",
    "source_code": "\tpublic Errors getErrors() {\n\t\treturn this.errors;\n\t}"
  },
  "org.springframework.web.reactive.result.view.BindStatus#getExpression()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a bind expression that can be used in HTML forms as input name\n\t * for the respective field, or {@code null} if not field-specific.\n\t * <p>Returns a bind path appropriate for resubmission, e.g. \"address.street\".\n\t * Note that the complete bind path as required by the bind tag is\n\t * \"customer.address.street\", if bound to a \"customer\" bean.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "String",
    "signature": "public String getExpression()",
    "source_code": "\tpublic String getExpression() {\n\t\treturn this.expression;\n\t}"
  },
  "org.springframework.web.reactive.result.view.BindStatus#getPath()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the bean and property path for which values and errors\n\t * will be resolved (e.g. \"customer.address.street\").\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "String",
    "signature": "public String getPath()",
    "source_code": "\tpublic String getPath() {\n\t\treturn this.path;\n\t}"
  },
  "org.springframework.web.reactive.result.view.BindStatus#getValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the current value of the field, i.e. either the property value\n\t * or a rejected update, or {@code null} if not field-specific.\n\t * <p>This value will be an HTML-escaped String if the original value\n\t * already was a String.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "Object",
    "signature": "public Object getValue()",
    "source_code": "\tpublic Object getValue() {\n\t\treturn this.value;\n\t}"
  },
  "org.springframework.web.reactive.result.view.BindStatus#isError()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return if this status represents a field or object error.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "boolean",
    "signature": "public boolean isError()",
    "source_code": "\tpublic boolean isError() {\n\t\treturn (this.errorCodes.length > 0);\n\t}"
  },
  "org.springframework.web.reactive.result.view.BindStatus#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 353
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(\"BindStatus: \");\n\t\tsb.append(\"expression=[\").append(this.expression).append(\"]; \");\n\t\tsb.append(\"value=[\").append(this.value).append(']');\n\t\tif (!ObjectUtils.isEmpty(this.errorCodes)) {\n\t\t\tsb.append(\"; errorCodes=\").append(Arrays.asList(this.errorCodes));\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.web.reactive.result.view.REDIRECT_URL_PREFIX": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prefix for special view names that specify a redirect URL (usually\n\t * to a controller after a form has been submitted and processed).\n\t * Such view names will not be resolved in the configured default\n\t * way but rather be treated as special shortcut.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "signature": "public String REDIRECT_URL_PREFIX",
    "source_code": "\tpublic static final String REDIRECT_URL_PREFIX = \"redirect:\";",
    "type": "String"
  },
  "org.springframework.web.reactive.result.view.UrlBasedViewResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@link ViewResolver} that allows direct resolution of symbolic view names\n * to URLs without explicit mapping definitions. This is useful if symbolic names\n * match the names of view resources in a straightforward manner (i.e. the\n * symbolic name is the unique part of the resource's filename), without the need\n * for a dedicated mapping to be defined for each view.\n *\n * <p>Supports {@link AbstractUrlBasedView} subclasses like\n * {@link org.springframework.web.reactive.result.view.freemarker.FreeMarkerView}.\n * The view class for all views generated by this resolver can be specified\n * via the \"viewClass\" property.\n *\n * <p>View names can either be resource URLs themselves, or get augmented by a\n * specified prefix and/or suffix. Exporting an attribute that holds the\n * RequestContext to all views is explicitly supported.\n *\n * <p>Example: prefix=\"templates/\", suffix=\".ftl\", viewname=\"test\" &rarr;\n * \"templates/test.ftl\"\n *\n * <p>As a special feature, redirect URLs can be specified via the \"redirect:\"\n * prefix. E.g.: \"redirect:myAction\" will trigger a redirect to the given\n * URL, rather than resolution as standard view name. This is typically used\n * for redirecting to a controller URL after finishing a form workflow.\n *\n * <p>Note: This class does not support localized resolution, i.e. resolving\n * a symbolic view name to different resources depending on the current locale.\n *\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "signature": "public class UrlBasedViewResolver",
    "source_code": "public class UrlBasedViewResolver extends ViewResolverSupport"
  },
  "org.springframework.web.reactive.result.view.UrlBasedViewResolver#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() throws Exception {\n\t\tif (getViewClass() == null) {\n\t\t\tthrow new IllegalArgumentException(\"Property 'viewClass' is required\");\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.view.UrlBasedViewResolver#applyLifecycleMethods(viewName,view)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the containing {@link ApplicationContext}'s lifecycle methods\n\t * to the given {@link View} instance, if such a context is available.\n\t * @param viewName the name of the view\n\t * @param view the freshly created View instance, pre-configured with\n\t * {@link AbstractUrlBasedView}'s properties\n\t * @return the {@link View} instance to use (either the original one\n\t * or a decorated variant)\n\t * @see #getApplicationContext()\n\t * @see ApplicationContext#getAutowireCapableBeanFactory()\n\t * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#initializeBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "view"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "View",
    "signature": "protected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view)",
    "source_code": "\tprotected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view) {\n\t\tApplicationContext context = getApplicationContext();\n\t\tif (context != null) {\n\t\t\tObject initialized = context.getAutowireCapableBeanFactory().initializeBean(view, viewName);\n\t\t\tif (initialized instanceof View initializedView) {\n\t\t\t\treturn initializedView;\n\t\t\t}\n\t\t}\n\t\treturn view;\n\t}"
  },
  "org.springframework.web.reactive.result.view.UrlBasedViewResolver#canHandle(viewName,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicates whether this {@link ViewResolver} can handle the supplied\n\t * view name. If not, an empty result is returned. The default implementation\n\t * checks against the configured {@link #setViewNames view names}.\n\t * @param viewName the name of the view to retrieve\n\t * @param locale the Locale to retrieve the view for\n\t * @return whether this resolver applies to the specified view\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "boolean",
    "signature": "protected boolean canHandle(String viewName, Locale locale)",
    "source_code": "\tprotected boolean canHandle(String viewName, Locale locale) {\n\t\tString[] viewNames = getViewNames();\n\t\treturn (viewNames == null || PatternMatchUtils.simpleMatch(viewNames, viewName));\n\t}"
  },
  "org.springframework.web.reactive.result.view.UrlBasedViewResolver#createView(viewName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Creates a new View instance of the specified view class and configures it.\n\t * <p>Does <i>not</i> perform any lookup for pre-defined View instances.\n\t * <p>Spring lifecycle methods as defined by the bean container do not have to\n\t * be called here: They will be automatically applied afterwards, provided\n\t * that an {@link #setApplicationContext ApplicationContext} is available.\n\t * @param viewName the name of the view to build\n\t * @return the View instance\n\t * @see #getViewClass()\n\t * @see #applyLifecycleMethods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "AbstractUrlBasedView",
    "signature": "protected AbstractUrlBasedView createView(String viewName)",
    "source_code": "\tprotected AbstractUrlBasedView createView(String viewName) {\n\t\tAbstractUrlBasedView view = instantiateView();\n\t\tview.setSupportedMediaTypes(getSupportedMediaTypes());\n\t\tview.setDefaultCharset(getDefaultCharset());\n\t\tview.setUrl(getPrefix() + viewName + getSuffix());\n\n\t\tString requestContextAttribute = getRequestContextAttribute();\n\t\tif (requestContextAttribute != null) {\n\t\t\tview.setRequestContextAttribute(requestContextAttribute);\n\t\t}\n\n\t\treturn view;\n\t}"
  },
  "org.springframework.web.reactive.result.view.UrlBasedViewResolver#getApplicationContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the containing {@code ApplicationContext}, if any.\n\t * @see #setApplicationContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext getApplicationContext()",
    "source_code": "\tpublic ApplicationContext getApplicationContext() {\n\t\treturn this.applicationContext;\n\t}"
  },
  "org.springframework.web.reactive.result.view.UrlBasedViewResolver#getPrefix()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the prefix that gets prepended to view names when building a URL.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "String",
    "signature": "protected String getPrefix()",
    "source_code": "\tprotected String getPrefix() {\n\t\treturn this.prefix;\n\t}"
  },
  "org.springframework.web.reactive.result.view.UrlBasedViewResolver#getRequestContextAttribute()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the {@link RequestContext} attribute for all views, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "String",
    "signature": "protected String getRequestContextAttribute()",
    "source_code": "\tprotected String getRequestContextAttribute() {\n\t\treturn this.requestContextAttribute;\n\t}"
  },
  "org.springframework.web.reactive.result.view.UrlBasedViewResolver#getSuffix()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the suffix that gets appended to view names when building a URL.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "String",
    "signature": "protected String getSuffix()",
    "source_code": "\tprotected String getSuffix() {\n\t\treturn this.suffix;\n\t}"
  },
  "org.springframework.web.reactive.result.view.UrlBasedViewResolver#getViewNames()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the view names (or name patterns) that can be handled by this\n\t * {@link ViewResolver}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "String[]",
    "signature": "protected String[] getViewNames()",
    "source_code": "\tprotected String[] getViewNames() {\n\t\treturn this.viewNames;\n\t}"
  },
  "org.springframework.web.reactive.result.view.UrlBasedViewResolver#instantiateView()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate the specified view class.\n\t * <p>The default implementation uses reflection to instantiate the class.\n\t * @return a new instance of the view class\n\t * @since 5.3\n\t * @see #setViewClass\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "AbstractUrlBasedView",
    "signature": "protected AbstractUrlBasedView instantiateView()",
    "source_code": "\tprotected AbstractUrlBasedView instantiateView() {\n\t\tClass<?> viewClass = getViewClass();\n\t\tAssert.state(viewClass != null, \"No view class\");\n\t\treturn (AbstractUrlBasedView) BeanUtils.instantiateClass(viewClass);\n\t}"
  },
  "org.springframework.web.reactive.result.view.UrlBasedViewResolver#resolveViewName(viewName,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "Mono<View>",
    "signature": "public Mono<View> resolveViewName(String viewName, Locale locale)",
    "source_code": "\tpublic Mono<View> resolveViewName(String viewName, Locale locale) {\n\t\tif (!canHandle(viewName, locale)) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tAbstractUrlBasedView urlBasedView;\n\t\tif (viewName.startsWith(REDIRECT_URL_PREFIX)) {\n\t\t\tString redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length());\n\t\t\turlBasedView = this.redirectViewProvider.apply(redirectUrl);\n\t\t}\n\t\telse {\n\t\t\turlBasedView = createView(viewName);\n\t\t}\n\n\t\tView view = applyLifecycleMethods(viewName, urlBasedView);\n\t\ttry {\n\t\t\treturn (urlBasedView.checkResourceExists(locale) ? Mono.just(view) : Mono.empty());\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.view.UrlBasedViewResolver#setApplicationContext(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Accept the containing {@code ApplicationContext}, if any.\n\t * <p>To be used for the initialization of newly created {@link View} instances,\n\t * applying lifecycle callbacks and providing access to the containing environment.\n\t * @see #setViewClass\n\t * @see #createView\n\t * @see #applyLifecycleMethods\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void setApplicationContext(@Nullable ApplicationContext applicationContext)",
    "source_code": "\tpublic void setApplicationContext(@Nullable ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t}"
  },
  "org.springframework.web.reactive.result.view.UrlBasedViewResolver#setPrefix(prefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the prefix that gets prepended to view names when building a URL.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void setPrefix(@Nullable String prefix)",
    "source_code": "\tpublic void setPrefix(@Nullable String prefix) {\n\t\tthis.prefix = (prefix != null ? prefix : \"\");\n\t}"
  },
  "org.springframework.web.reactive.result.view.UrlBasedViewResolver#setRedirectViewProvider(Function<String,redirectViewProvider)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * URL based {@link RedirectView} provider which can be used to provide, for example,\n\t * redirect views with a custom default status code.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<String",
      "redirectViewProvider"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "public void setRedirectViewProvider(Function<String, RedirectView> redirectViewProvider)",
    "source_code": "\tpublic void setRedirectViewProvider(Function<String, RedirectView> redirectViewProvider) {\n\t\tthis.redirectViewProvider = redirectViewProvider;\n\t}"
  },
  "org.springframework.web.reactive.result.view.UrlBasedViewResolver#setRequestContextAttribute(requestContextAttribute)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the {@link RequestContext} attribute for all views.\n\t * @param requestContextAttribute name of the RequestContext attribute\n\t * @see AbstractView#setRequestContextAttribute\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestContextAttribute"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "void",
    "signature": "public void setRequestContextAttribute(@Nullable String requestContextAttribute)",
    "source_code": "\tpublic void setRequestContextAttribute(@Nullable String requestContextAttribute) {\n\t\tthis.requestContextAttribute = requestContextAttribute;\n\t}"
  },
  "org.springframework.web.reactive.result.view.UrlBasedViewResolver#setSuffix(suffix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the suffix that gets appended to view names when building a URL.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "suffix"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "void",
    "signature": "public void setSuffix(@Nullable String suffix)",
    "source_code": "\tpublic void setSuffix(@Nullable String suffix) {\n\t\tthis.suffix = (suffix != null ? suffix : \"\");\n\t}"
  },
  "org.springframework.web.reactive.result.view.UrlBasedViewResolver#setViewClass(viewClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the view class that should be used to create views.\n\t * @param viewClass a class that is assignable to the required view class\n\t * (by default: AbstractUrlBasedView)\n\t * @see #requiredViewClass()\n\t * @see #instantiateView()\n\t * @see AbstractUrlBasedView\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewClass"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "void",
    "signature": "public void setViewClass(@Nullable Class<?> viewClass)",
    "source_code": "\tpublic void setViewClass(@Nullable Class<?> viewClass) {\n\t\tif (viewClass != null && !requiredViewClass().isAssignableFrom(viewClass)) {\n\t\t\tString name = viewClass.getName();\n\t\t\tthrow new IllegalArgumentException(\"Given view class [\" + name + \"] \" +\n\t\t\t\t\t\"is not of type [\" + requiredViewClass().getName() + \"]\");\n\t\t}\n\t\tthis.viewClass = viewClass;\n\t}"
  },
  "org.springframework.web.reactive.result.view.UrlBasedViewResolver#setViewNames(viewNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the view names (or name patterns) that can be handled by this\n\t * {@link ViewResolver}. View names can contain simple wildcards such that\n\t * 'my*', '*Report' and '*Repo*' will all match the view name 'myReport'.\n\t * @see #canHandle\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewNames"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "void",
    "signature": "public void setViewNames(@Nullable String... viewNames)",
    "source_code": "\tpublic void setViewNames(@Nullable String... viewNames) {\n\t\tthis.viewNames = viewNames;\n\t}"
  },
  "org.springframework.web.reactive.result.view.ViewResolutionResultHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code HandlerResultHandler} that encapsulates the view resolution algorithm\n * supporting the following return types:\n * <ul>\n * <li>{@link Void} or no value -- default view name</li>\n * <li>{@link String} -- view name unless {@code @ModelAttribute}-annotated\n * <li>{@link View} -- View to render with\n * <li>{@link Model} -- attributes to add to the model\n * <li>{@link Map} -- attributes to add to the model\n * <li>{@link Rendering} -- use case driven API for view resolution</li>\n * <li>{@link ModelAttribute @ModelAttribute} -- attribute for the model\n * <li>Non-simple value -- attribute for the model\n * </ul>\n *\n * <p>A String-based view name is resolved through the configured\n * {@link ViewResolver} instances into a {@link View} to use for rendering.\n * If a view is left unspecified (e.g. by returning {@code null} or a\n * model-related return value), a default view name is selected.\n *\n * <p>By default this resolver is ordered at {@link Ordered#LOWEST_PRECEDENCE}\n * and generally needs to be late in the order since it interprets any String\n * return value as a view name or any non-simple value type as a model attribute\n * while other result handlers may interpret the same otherwise based on the\n * presence of annotations, e.g. for {@code @ResponseBody}.\n *\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "signature": "public class ViewResolutionResultHandler",
    "source_code": "public class ViewResolutionResultHandler extends HandlerResultHandlerSupport implements HandlerResultHandler, Ordered {\n\n\tprivate static final Object NO_VALUE = new Object();\n\n\tprivate static final Mono<Object> NO_VALUE_MONO = Mono.just(NO_VALUE);\n\n\n\tprivate final List<ViewResolver> viewResolvers = new ArrayList<>(4);\n\n\tprivate final List<View> defaultViews = new ArrayList<>(4);\n\n\n\t/**\n\t * Basic constructor with a default {@link ReactiveAdapterRegistry}.\n\t * @param viewResolvers the resolver to use\n\t * @param contentTypeResolver to determine the requested content type\n\t */\n\tpublic ViewResolutionResultHandler(List<ViewResolver> viewResolvers,\n\t\t\tRequestedContentTypeResolver contentTypeResolver) {\n\n\t\tthis(viewResolvers, contentTypeResolver, ReactiveAdapterRegistry.getSharedInstance());\n\t}\n\n\t/**\n\t * Constructor with an {@link ReactiveAdapterRegistry} instance.\n\t * @param viewResolvers the view resolver to use\n\t * @param contentTypeResolver to determine the requested content type\n\t * @param registry for adaptation to reactive types\n\t */\n\tpublic ViewResolutionResultHandler(List<ViewResolver> viewResolvers,\n\t\t\tRequestedContentTypeResolver contentTypeResolver, ReactiveAdapterRegistry registry) {\n\n\t\tsuper(contentTypeResolver, registry);\n\t\tthis.viewResolvers.addAll(viewResolvers);\n\t\tAnnotationAwareOrderComparator.sort(this.viewResolvers);\n\t}\n\n\n\t/**\n\t * Return a read-only list of view resolvers.\n\t */\n\tpublic List<ViewResolver> getViewResolvers() {\n\t\treturn Collections.unmodifiableList(this.viewResolvers);\n\t}\n\n\t/**\n\t * Set the default views to consider always when resolving view names and\n\t * trying to satisfy the best matching content type.\n\t */\n\tpublic void setDefaultViews(@Nullable List<View> defaultViews) {\n\t\tthis.defaultViews.clear();\n\t\tif (defaultViews != null) {\n\t\t\tthis.defaultViews.addAll(defaultViews);\n\t\t}\n\t}\n\n\t/**\n\t * Return the configured default {@code View}'s.\n\t */\n\tpublic List<View> getDefaultViews() {\n\t\treturn this.defaultViews;\n\t}\n\n\n\t@Override\n\tpublic boolean supports(HandlerResult result) {\n\t\tif (hasModelAnnotation(result.getReturnTypeSource())) {\n\t\t\treturn true;\n\t\t}\n\n\t\tClass<?> type = result.getReturnType().toClass();\n\t\tReactiveAdapter adapter = getAdapter(result);\n\t\tif (adapter != null) {\n\t\t\tif (adapter.isNoValue()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\ttype = result.getReturnType().getGeneric().toClass();\n\t\t}\n\n\t\treturn (CharSequence.class.isAssignableFrom(type) ||\n\t\t\t\tRendering.class.isAssignableFrom(type) ||\n\t\t\t\tModel.class.isAssignableFrom(type) ||\n\t\t\t\tMap.class.isAssignableFrom(type) ||\n\t\t\t\tView.class.isAssignableFrom(type) ||\n\t\t\t\t!BeanUtils.isSimpleProperty(type));\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n\t\tMono<Object> valueMono;\n\t\tResolvableType valueType;\n\t\tReactiveAdapter adapter = getAdapter(result);\n\n\t\tif (adapter != null) {\n\t\t\tif (adapter.isMultiValue()) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Multi-value reactive types not supported in view resolution: \" + result.getReturnType());\n\t\t\t}\n\n\t\t\tvalueMono = (result.getReturnValue() != null ?\n\t\t\t\t\tMono.from(adapter.toPublisher(result.getReturnValue())) : Mono.empty());\n\n\t\t\tvalueType = (adapter.isNoValue() ? ResolvableType.forClass(Void.class) :\n\t\t\t\t\tresult.getReturnType().getGeneric());\n\t\t}\n\t\telse {\n\t\t\tvalueMono = Mono.justOrEmpty(result.getReturnValue());\n\t\t\tvalueType = result.getReturnType();\n\t\t}\n\n\t\treturn valueMono\n\t\t\t\t.switchIfEmpty(exchange.isNotModified() ? Mono.empty() : NO_VALUE_MONO)\n\t\t\t\t.flatMap(returnValue -> {\n\n\t\t\t\t\tMono<List<View>> viewsMono;\n\t\t\t\t\tModel model = result.getModel();\n\t\t\t\t\tMethodParameter parameter = result.getReturnTypeSource();\n\t\t\t\t\tLocale locale = LocaleContextHolder.getLocale(exchange.getLocaleContext());\n\n\t\t\t\t\tClass<?> clazz = valueType.toClass();\n\t\t\t\t\tif (clazz == Object.class) {\n\t\t\t\t\t\tclazz = returnValue.getClass();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (returnValue == NO_VALUE || clazz == void.class || clazz == Void.class) {\n\t\t\t\t\t\tviewsMono = resolveViews(getDefaultViewName(exchange), locale);\n\t\t\t\t\t}\n\t\t\t\t\telse if (CharSequence.class.isAssignableFrom(clazz) && !hasModelAnnotation(parameter)) {\n\t\t\t\t\t\tviewsMono = resolveViews(returnValue.toString(), locale);\n\t\t\t\t\t}\n\t\t\t\t\telse if (Rendering.class.isAssignableFrom(clazz)) {\n\t\t\t\t\t\tRendering render = (Rendering) returnValue;\n\t\t\t\t\t\tHttpStatusCode status = render.status();\n\t\t\t\t\t\tif (status != null) {\n\t\t\t\t\t\t\texchange.getResponse().setStatusCode(status);\n\t\t\t\t\t\t}\n\t\t\t\t\t\texchange.getResponse().getHeaders().putAll(render.headers());\n\t\t\t\t\t\tmodel.addAllAttributes(render.modelAttributes());\n\t\t\t\t\t\tObject view = render.view();\n\t\t\t\t\t\tif (view == null) {\n\t\t\t\t\t\t\tview = getDefaultViewName(exchange);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tviewsMono = (view instanceof String viewName ? resolveViews(viewName, locale) :\n\t\t\t\t\t\t\t\tMono.just(Collections.singletonList((View) view)));\n\t\t\t\t\t}\n\t\t\t\t\telse if (Model.class.isAssignableFrom(clazz)) {\n\t\t\t\t\t\tmodel.addAllAttributes(((Model) returnValue).asMap());\n\t\t\t\t\t\tviewsMono = resolveViews(getDefaultViewName(exchange), locale);\n\t\t\t\t\t}\n\t\t\t\t\telse if (Map.class.isAssignableFrom(clazz) && !hasModelAnnotation(parameter)) {\n\t\t\t\t\t\tmodel.addAllAttributes((Map<String, ?>) returnValue);\n\t\t\t\t\t\tviewsMono = resolveViews(getDefaultViewName(exchange), locale);\n\t\t\t\t\t}\n\t\t\t\t\telse if (View.class.isAssignableFrom(clazz)) {\n\t\t\t\t\t\tviewsMono = Mono.just(Collections.singletonList((View) returnValue));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tString name = getNameForReturnValue(parameter);\n\t\t\t\t\t\tmodel.addAttribute(name, returnValue);\n\t\t\t\t\t\tviewsMono = resolveViews(getDefaultViewName(exchange), locale);\n\t\t\t\t\t}\n\t\t\t\t\tBindingContext bindingContext = result.getBindingContext();\n\t\t\t\t\tupdateBindingResult(bindingContext, exchange);\n\t\t\t\t\treturn viewsMono.flatMap(views -> render(views, model.asMap(), bindingContext, exchange));\n\t\t\t\t});\n\t}\n\n\n\tprivate boolean hasModelAnnotation(MethodParameter parameter) {\n\t\treturn parameter.hasMethodAnnotation(ModelAttribute.class);\n\t}\n\n\t/**\n\t * Select a default view name when a controller did not specify it.\n\t * Use the request path the leading and trailing slash stripped.\n\t */\n\tprivate String getDefaultViewName(ServerWebExchange exchange) {\n\t\tString path = exchange.getRequest().getPath().pathWithinApplication().value();\n\t\tif (path.startsWith(\"/\")) {\n\t\t\tpath = path.substring(1);\n\t\t}\n\t\tif (path.endsWith(\"/\")) {\n\t\t\tpath = path.substring(0, path.length() - 1);\n\t\t}\n\t\treturn StringUtils.stripFilenameExtension(path);\n\t}\n\n\tprivate Mono<List<View>> resolveViews(String viewName, Locale locale) {\n\t\treturn Flux.fromIterable(getViewResolvers())\n\t\t\t\t.concatMap(resolver -> resolver.resolveViewName(viewName, locale))\n\t\t\t\t.collectList()\n\t\t\t\t.map(views -> {\n\t\t\t\t\tif (views.isEmpty()) {\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\"Could not resolve view with name '\" + viewName + \"'.\");\n\t\t\t\t\t}\n\t\t\t\t\tviews.addAll(getDefaultViews());\n\t\t\t\t\treturn views;\n\t\t\t\t});\n\t}\n\n\tprivate String getNameForReturnValue(MethodParameter returnType) {\n\t\treturn Optional.ofNullable(returnType.getMethodAnnotation(ModelAttribute.class))\n\t\t\t\t.filter(ann -> StringUtils.hasText(ann.value()))\n\t\t\t\t.map(ModelAttribute::value)\n\t\t\t\t.orElseGet(() -> Conventions.getVariableNameForParameter(returnType));\n\t}\n\n\tprivate void updateBindingResult(BindingContext context, ServerWebExchange exchange) {\n\t\tMap<String, Object> model = context.getModel().asMap();\n\t\tfor (Map.Entry<String, Object> entry : model.entrySet()) {\n\t\t\tString name = entry.getKey();\n\t\t\tObject value = entry.getValue();\n\t\t\tif (isBindingCandidate(name, value)) {\n\t\t\t\tif (!model.containsKey(BindingResult.MODEL_KEY_PREFIX + name)) {\n\t\t\t\t\tWebExchangeDataBinder binder = context.createDataBinder(exchange, value, name);\n\t\t\t\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isBindingCandidate(String name, @Nullable Object value) {\n\t\treturn (!name.startsWith(BindingResult.MODEL_KEY_PREFIX) && value != null &&\n\t\t\t\t!value.getClass().isArray() && !(value instanceof Collection) && !(value instanceof Map) &&\n\t\t\t\tgetAdapterRegistry().getAdapter(null, value) == null &&\n\t\t\t\t!BeanUtils.isSimpleValueType(value.getClass()));\n\t}\n\n\tprivate Mono<? extends Void> render(List<View> views, Map<String, Object> model,\n\t\t\tBindingContext bindingContext, ServerWebExchange exchange) {\n\n\t\tfor (View view : views) {\n\t\t\tif (view.isRedirectView()) {\n\t\t\t\treturn renderWith(view, model, null, exchange, bindingContext);\n\t\t\t}\n\t\t}\n\t\tList<MediaType> mediaTypes = getMediaTypes(views);\n\t\tMediaType bestMediaType;\n\t\ttry {\n\t\t\tbestMediaType = selectMediaType(exchange, () -> mediaTypes);\n\t\t}\n\t\tcatch (NotAcceptableStatusException ex) {\n\t\t\tHttpStatusCode statusCode = exchange.getResponse().getStatusCode();\n\t\t\tif (statusCode != null && statusCode.isError()) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Ignoring error response content (if any). \" + ex.getReason());\n\t\t\t\t}\n\t\t\t\treturn Mono.empty();\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t\tif (bestMediaType != null) {\n\t\t\tfor (View view : views) {\n\t\t\t\tfor (MediaType mediaType : view.getSupportedMediaTypes()) {\n\t\t\t\t\tif (mediaType.isCompatibleWith(bestMediaType)) {\n\t\t\t\t\t\treturn renderWith(view, model, mediaType, exchange, bindingContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new NotAcceptableStatusException(mediaTypes);\n\t}\n\n\tprivate Mono<? extends Void> renderWith(View view, Map<String, Object> model,\n\t\t\t@Nullable MediaType mediaType, ServerWebExchange exchange, BindingContext bindingContext) {\n\n\t\texchange.getAttributes().put(View.BINDING_CONTEXT_ATTRIBUTE, bindingContext);\n\t\treturn view.render(model, mediaType, exchange)\n\t\t\t\t.doOnTerminate(() -> exchange.getAttributes().remove(View.BINDING_CONTEXT_ATTRIBUTE));\n\t}\n\n\tprivate List<MediaType> getMediaTypes(List<View> views) {\n\t\treturn views.stream()\n\t\t\t\t.flatMap(view -> view.getSupportedMediaTypes().stream())\n\t\t\t\t.toList();\n\t}\n\n}"
  },
  "org.springframework.web.reactive.result.view.ViewResolutionResultHandler#getDefaultViews()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured default {@code View}'s.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "List<View>",
    "signature": "public List<View> getDefaultViews()",
    "source_code": "\tpublic List<View> getDefaultViews() {\n\t\treturn this.defaultViews;\n\t}"
  },
  "org.springframework.web.reactive.result.view.ViewResolutionResultHandler#getViewResolvers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a read-only list of view resolvers.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "List<ViewResolver>",
    "signature": "public List<ViewResolver> getViewResolvers()",
    "source_code": "\tpublic List<ViewResolver> getViewResolvers() {\n\t\treturn Collections.unmodifiableList(this.viewResolvers);\n\t}"
  },
  "org.springframework.web.reactive.result.view.ViewResolutionResultHandler#handleResult(exchange,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result)",
    "source_code": "\tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n\t\tMono<Object> valueMono;\n\t\tResolvableType valueType;\n\t\tReactiveAdapter adapter = getAdapter(result);\n\n\t\tif (adapter != null) {\n\t\t\tif (adapter.isMultiValue()) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Multi-value reactive types not supported in view resolution: \" + result.getReturnType());\n\t\t\t}\n\n\t\t\tvalueMono = (result.getReturnValue() != null ?\n\t\t\t\t\tMono.from(adapter.toPublisher(result.getReturnValue())) : Mono.empty());\n\n\t\t\tvalueType = (adapter.isNoValue() ? ResolvableType.forClass(Void.class) :\n\t\t\t\t\tresult.getReturnType().getGeneric());\n\t\t}\n\t\telse {\n\t\t\tvalueMono = Mono.justOrEmpty(result.getReturnValue());\n\t\t\tvalueType = result.getReturnType();\n\t\t}\n\n\t\treturn valueMono\n\t\t\t\t.switchIfEmpty(exchange.isNotModified() ? Mono.empty() : NO_VALUE_MONO)\n\t\t\t\t.flatMap(returnValue -> {\n\n\t\t\t\t\tMono<List<View>> viewsMono;\n\t\t\t\t\tModel model = result.getModel();\n\t\t\t\t\tMethodParameter parameter = result.getReturnTypeSource();\n\t\t\t\t\tLocale locale = LocaleContextHolder.getLocale(exchange.getLocaleContext());\n\n\t\t\t\t\tClass<?> clazz = valueType.toClass();\n\t\t\t\t\tif (clazz == Object.class) {\n\t\t\t\t\t\tclazz = returnValue.getClass();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (returnValue == NO_VALUE || clazz == void.class || clazz == Void.class) {\n\t\t\t\t\t\tviewsMono = resolveViews(getDefaultViewName(exchange), locale);\n\t\t\t\t\t}\n\t\t\t\t\telse if (CharSequence.class.isAssignableFrom(clazz) && !hasModelAnnotation(parameter)) {\n\t\t\t\t\t\tviewsMono = resolveViews(returnValue.toString(), locale);\n\t\t\t\t\t}\n\t\t\t\t\telse if (Rendering.class.isAssignableFrom(clazz)) {\n\t\t\t\t\t\tRendering render = (Rendering) returnValue;\n\t\t\t\t\t\tHttpStatusCode status = render.status();\n\t\t\t\t\t\tif (status != null) {\n\t\t\t\t\t\t\texchange.getResponse().setStatusCode(status);\n\t\t\t\t\t\t}\n\t\t\t\t\t\texchange.getResponse().getHeaders().putAll(render.headers());\n\t\t\t\t\t\tmodel.addAllAttributes(render.modelAttributes());\n\t\t\t\t\t\tObject view = render.view();\n\t\t\t\t\t\tif (view == null) {\n\t\t\t\t\t\t\tview = getDefaultViewName(exchange);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tviewsMono = (view instanceof String viewName ? resolveViews(viewName, locale) :\n\t\t\t\t\t\t\t\tMono.just(Collections.singletonList((View) view)));\n\t\t\t\t\t}\n\t\t\t\t\telse if (Model.class.isAssignableFrom(clazz)) {\n\t\t\t\t\t\tmodel.addAllAttributes(((Model) returnValue).asMap());\n\t\t\t\t\t\tviewsMono = resolveViews(getDefaultViewName(exchange), locale);\n\t\t\t\t\t}\n\t\t\t\t\telse if (Map.class.isAssignableFrom(clazz) && !hasModelAnnotation(parameter)) {\n\t\t\t\t\t\tmodel.addAllAttributes((Map<String, ?>) returnValue);\n\t\t\t\t\t\tviewsMono = resolveViews(getDefaultViewName(exchange), locale);\n\t\t\t\t\t}\n\t\t\t\t\telse if (View.class.isAssignableFrom(clazz)) {\n\t\t\t\t\t\tviewsMono = Mono.just(Collections.singletonList((View) returnValue));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tString name = getNameForReturnValue(parameter);\n\t\t\t\t\t\tmodel.addAttribute(name, returnValue);\n\t\t\t\t\t\tviewsMono = resolveViews(getDefaultViewName(exchange), locale);\n\t\t\t\t\t}\n\t\t\t\t\tBindingContext bindingContext = result.getBindingContext();\n\t\t\t\t\tupdateBindingResult(bindingContext, exchange);\n\t\t\t\t\treturn viewsMono.flatMap(views -> render(views, model.asMap(), bindingContext, exchange));\n\t\t\t\t});\n\t}"
  },
  "org.springframework.web.reactive.result.view.ViewResolutionResultHandler#setDefaultViews(defaultViews)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the default views to consider always when resolving view names and\n\t * trying to satisfy the best matching content type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultViews"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void setDefaultViews(@Nullable List<View> defaultViews)",
    "source_code": "\tpublic void setDefaultViews(@Nullable List<View> defaultViews) {\n\t\tthis.defaultViews.clear();\n\t\tif (defaultViews != null) {\n\t\t\tthis.defaultViews.addAll(defaultViews);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.view.ViewResolutionResultHandler#supports(result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "boolean",
    "signature": "public boolean supports(HandlerResult result)",
    "source_code": "\tpublic boolean supports(HandlerResult result) {\n\t\tif (hasModelAnnotation(result.getReturnTypeSource())) {\n\t\t\treturn true;\n\t\t}\n\n\t\tClass<?> type = result.getReturnType().toClass();\n\t\tReactiveAdapter adapter = getAdapter(result);\n\t\tif (adapter != null) {\n\t\t\tif (adapter.isNoValue()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\ttype = result.getReturnType().getGeneric().toClass();\n\t\t}\n\n\t\treturn (CharSequence.class.isAssignableFrom(type) ||\n\t\t\t\tRendering.class.isAssignableFrom(type) ||\n\t\t\t\tModel.class.isAssignableFrom(type) ||\n\t\t\t\tMap.class.isAssignableFrom(type) ||\n\t\t\t\tView.class.isAssignableFrom(type) ||\n\t\t\t\t!BeanUtils.isSimpleProperty(type));\n\t}"
  },
  "org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code WebSocketService} implementation that handles a WebSocket HTTP\n * handshake request by delegating to a {@link RequestUpgradeStrategy} which\n * is either auto-detected (no-arg constructor) from the classpath but can\n * also be explicitly configured.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "signature": "public class HandshakeWebSocketService",
    "source_code": "public class HandshakeWebSocketService implements WebSocketService, Lifecycle {\n\n\tprivate static final String SEC_WEBSOCKET_KEY = \"Sec-WebSocket-Key\";\n\n\tprivate static final String SEC_WEBSOCKET_PROTOCOL = \"Sec-WebSocket-Protocol\";\n\n\tprivate static final Mono<Map<String, Object>> EMPTY_ATTRIBUTES = Mono.just(Collections.emptyMap());\n\n\n\tprivate static final boolean tomcatWsPresent;\n\n\tprivate static final boolean jettyWsPresent;\n\n\tprivate static final boolean undertowWsPresent;\n\n\tprivate static final boolean reactorNettyPresent;\n\n\tprivate static final boolean reactorNetty2Present;\n\n\tstatic {\n\t\tClassLoader classLoader = HandshakeWebSocketService.class.getClassLoader();\n\t\ttomcatWsPresent = ClassUtils.isPresent(\n\t\t\t\t\"org.apache.tomcat.websocket.server.WsHttpUpgradeHandler\", classLoader);\n\t\tjettyWsPresent = ClassUtils.isPresent(\n\t\t\t\t\"org.eclipse.jetty.websocket.server.JettyWebSocketServerContainer\", classLoader);\n\t\tundertowWsPresent = ClassUtils.isPresent(\n\t\t\t\t\"io.undertow.websockets.WebSocketProtocolHandshakeHandler\", classLoader);\n\t\treactorNettyPresent = ClassUtils.isPresent(\n\t\t\t\t\"reactor.netty.http.server.HttpServerResponse\", classLoader);\n\t\treactorNetty2Present = ClassUtils.isPresent(\n\t\t\t\t\"reactor.netty5.http.server.HttpServerResponse\", classLoader);\n\t}\n\n\n\tprivate static final Log logger = LogFactory.getLog(HandshakeWebSocketService.class);\n\n\tprivate final RequestUpgradeStrategy upgradeStrategy;\n\n\t@Nullable\n\tprivate Predicate<String> sessionAttributePredicate;\n\n\tprivate volatile boolean running;\n\n\n\t/**\n\t * Default constructor automatic, classpath detection based discovery of the\n\t * {@link RequestUpgradeStrategy} to use.\n\t */\n\tpublic HandshakeWebSocketService() {\n\t\tthis(initUpgradeStrategy());\n\t}\n\n\t/**\n\t * Alternative constructor with the {@link RequestUpgradeStrategy} to use.\n\t * @param upgradeStrategy the strategy to use\n\t */\n\tpublic HandshakeWebSocketService(RequestUpgradeStrategy upgradeStrategy) {\n\t\tAssert.notNull(upgradeStrategy, \"RequestUpgradeStrategy is required\");\n\t\tthis.upgradeStrategy = upgradeStrategy;\n\t}\n\n\n\t/**\n\t * Return the {@link RequestUpgradeStrategy} for WebSocket requests.\n\t */\n\tpublic RequestUpgradeStrategy getUpgradeStrategy() {\n\t\treturn this.upgradeStrategy;\n\t}\n\n\t/**\n\t * Configure a predicate to use to extract\n\t * {@link org.springframework.web.server.WebSession WebSession} attributes\n\t * and use them to initialize the WebSocket session with.\n\t * <p>By default this is not set in which case no attributes are passed.\n\t * @param predicate the predicate\n\t * @since 5.1\n\t */\n\tpublic void setSessionAttributePredicate(@Nullable Predicate<String> predicate) {\n\t\tthis.sessionAttributePredicate = predicate;\n\t}\n\n\t/**\n\t * Return the configured predicate for initialization WebSocket session\n\t * attributes from {@code WebSession} attributes.\n\t * @since 5.1\n\t */\n\t@Nullable\n\tpublic Predicate<String> getSessionAttributePredicate() {\n\t\treturn this.sessionAttributePredicate;\n\t}\n\n\n\t@Override\n\tpublic void start() {\n\t\tif (!isRunning()) {\n\t\t\tthis.running = true;\n\t\t\tdoStart();\n\t\t}\n\t}\n\n\tprotected void doStart() {\n\t\tif (getUpgradeStrategy() instanceof Lifecycle lifecycle) {\n\t\t\tlifecycle.start();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void stop() {\n\t\tif (isRunning()) {\n\t\t\tthis.running = false;\n\t\t\tdoStop();\n\t\t}\n\t}\n\n\tprotected void doStop() {\n\t\tif (getUpgradeStrategy() instanceof Lifecycle lifecycle) {\n\t\t\tlifecycle.stop();\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isRunning() {\n\t\treturn this.running;\n\t}\n\n\n\t@Override\n\tpublic Mono<Void> handleRequest(ServerWebExchange exchange, WebSocketHandler handler) {\n\t\tServerHttpRequest request = exchange.getRequest();\n\t\tHttpMethod method = request.getMethod();\n\t\tHttpHeaders headers = request.getHeaders();\n\n\t\tif (HttpMethod.GET != method) {\n\t\t\treturn Mono.error(new MethodNotAllowedException(\n\t\t\t\t\trequest.getMethod(), Collections.singleton(HttpMethod.GET)));\n\t\t}\n\n\t\tif (!\"WebSocket\".equalsIgnoreCase(headers.getUpgrade())) {\n\t\t\treturn handleBadRequest(exchange, \"Invalid 'Upgrade' header: \" + headers);\n\t\t}\n\n\t\tList<String> connectionValue = headers.getConnection();\n\t\tif (!connectionValue.contains(\"Upgrade\") && !connectionValue.contains(\"upgrade\")) {\n\t\t\treturn handleBadRequest(exchange, \"Invalid 'Connection' header: \" + headers);\n\t\t}\n\n\t\tString key = headers.getFirst(SEC_WEBSOCKET_KEY);\n\t\tif (key == null) {\n\t\t\treturn handleBadRequest(exchange, \"Missing \\\"Sec-WebSocket-Key\\\" header\");\n\t\t}\n\n\t\tString protocol = selectProtocol(headers, handler);\n\n\t\treturn initAttributes(exchange).flatMap(attributes ->\n\t\t\t\tthis.upgradeStrategy.upgrade(exchange, handler, protocol,\n\t\t\t\t\t\t() -> createHandshakeInfo(exchange, request, protocol, attributes))\n\t\t);\n\t}\n\n\tprivate Mono<Void> handleBadRequest(ServerWebExchange exchange, String reason) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(exchange.getLogPrefix() + reason);\n\t\t}\n\t\treturn Mono.error(new ServerWebInputException(reason));\n\t}\n\n\t@Nullable\n\tprivate String selectProtocol(HttpHeaders headers, WebSocketHandler handler) {\n\t\tString protocolHeader = headers.getFirst(SEC_WEBSOCKET_PROTOCOL);\n\t\tif (protocolHeader != null) {\n\t\t\tList<String> supportedProtocols = handler.getSubProtocols();\n\t\t\tfor (String protocol : StringUtils.commaDelimitedListToStringArray(protocolHeader)) {\n\t\t\t\tif (supportedProtocols.contains(protocol)) {\n\t\t\t\t\treturn protocol;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate Mono<Map<String, Object>> initAttributes(ServerWebExchange exchange) {\n\t\tif (this.sessionAttributePredicate == null) {\n\t\t\treturn EMPTY_ATTRIBUTES;\n\t\t}\n\t\treturn exchange.getSession().map(session ->\n\t\t\t\tsession.getAttributes().entrySet().stream()\n\t\t\t\t\t\t.filter(entry -> this.sessionAttributePredicate.test(entry.getKey()))\n\t\t\t\t\t\t.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)));\n\t}\n\n\tprivate HandshakeInfo createHandshakeInfo(ServerWebExchange exchange, ServerHttpRequest request,\n\t\t\t@Nullable String protocol, Map<String, Object> attributes) {\n\n\t\tURI uri = request.getURI();\n\t\t// Copy request headers, as they might be pooled and recycled by\n\t\t// the server implementation once the handshake HTTP exchange is done.\n\t\tHttpHeaders headers = new HttpHeaders();\n\t\theaders.addAll(request.getHeaders());\n\t\tMultiValueMap<String, HttpCookie> cookies = request.getCookies();\n\t\tMono<Principal> principal = exchange.getPrincipal();\n\t\tString logPrefix = exchange.getLogPrefix();\n\t\tInetSocketAddress remoteAddress = request.getRemoteAddress();\n\t\treturn new HandshakeInfo(uri, headers, cookies, principal, protocol, remoteAddress, attributes, logPrefix);\n\t}\n\n\n\tstatic RequestUpgradeStrategy initUpgradeStrategy() {\n\t\tif (tomcatWsPresent) {\n\t\t\treturn new TomcatRequestUpgradeStrategy();\n\t\t}\n\t\telse if (jettyWsPresent) {\n\t\t\treturn new JettyRequestUpgradeStrategy();\n\t\t}\n\t\telse if (undertowWsPresent) {\n\t\t\treturn new UndertowRequestUpgradeStrategy();\n\t\t}\n\t\telse if (reactorNettyPresent) {\n\t\t\t// As late as possible (Reactor Netty commonly used for WebClient)\n\t\t\treturn ReactorNettyStrategyDelegate.forReactorNetty1();\n\t\t}\n\t\telse if (reactorNetty2Present) {\n\t\t\t// As late as possible (Reactor Netty commonly used for WebClient)\n\t\t\treturn ReactorNettyStrategyDelegate.forReactorNetty2();\n\t\t}\n\t\telse {\n\t\t\t// Let's assume Jakarta WebSocket API 2.1+\n\t\t\treturn new StandardWebSocketUpgradeStrategy();\n\t\t}\n\t}\n\n\n\t/**\n\t * Inner class to avoid a reachable dependency on Reactor Netty API.\n\t */\n\tprivate static class ReactorNettyStrategyDelegate {\n\n\t\tpublic static RequestUpgradeStrategy forReactorNetty1() {\n\t\t\treturn new ReactorNettyRequestUpgradeStrategy();\n\t\t}\n\n\t\tpublic static RequestUpgradeStrategy forReactorNetty2() {\n\t\t\treturn new ReactorNetty2RequestUpgradeStrategy();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService#doStart()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "void",
    "signature": "protected void doStart()",
    "source_code": "\tprotected void doStart() {\n\t\tif (getUpgradeStrategy() instanceof Lifecycle lifecycle) {\n\t\t\tlifecycle.start();\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService#doStop()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "void",
    "signature": "protected void doStop()",
    "source_code": "\tprotected void doStop() {\n\t\tif (getUpgradeStrategy() instanceof Lifecycle lifecycle) {\n\t\t\tlifecycle.stop();\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService#forReactorNetty1()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "RequestUpgradeStrategy",
    "signature": "public RequestUpgradeStrategy forReactorNetty1()",
    "source_code": "\t\tpublic static RequestUpgradeStrategy forReactorNetty1() {\n\t\t\treturn new ReactorNettyRequestUpgradeStrategy();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService#forReactorNetty2()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "RequestUpgradeStrategy",
    "signature": "public RequestUpgradeStrategy forReactorNetty2()",
    "source_code": "\t\tpublic static RequestUpgradeStrategy forReactorNetty2() {\n\t\t\treturn new ReactorNetty2RequestUpgradeStrategy();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService#getSessionAttributePredicate()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured predicate for initialization WebSocket session\n\t * attributes from {@code WebSession} attributes.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Predicate<String>",
    "signature": "public Predicate<String> getSessionAttributePredicate()",
    "source_code": "\tpublic Predicate<String> getSessionAttributePredicate() {\n\t\treturn this.sessionAttributePredicate;\n\t}"
  },
  "org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService#getUpgradeStrategy()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link RequestUpgradeStrategy} for WebSocket requests.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "RequestUpgradeStrategy",
    "signature": "public RequestUpgradeStrategy getUpgradeStrategy()",
    "source_code": "\tpublic RequestUpgradeStrategy getUpgradeStrategy() {\n\t\treturn this.upgradeStrategy;\n\t}"
  },
  "org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService#handleRequest(exchange,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> handleRequest(ServerWebExchange exchange, WebSocketHandler handler)",
    "source_code": "\tpublic Mono<Void> handleRequest(ServerWebExchange exchange, WebSocketHandler handler) {\n\t\tServerHttpRequest request = exchange.getRequest();\n\t\tHttpMethod method = request.getMethod();\n\t\tHttpHeaders headers = request.getHeaders();\n\n\t\tif (HttpMethod.GET != method) {\n\t\t\treturn Mono.error(new MethodNotAllowedException(\n\t\t\t\t\trequest.getMethod(), Collections.singleton(HttpMethod.GET)));\n\t\t}\n\n\t\tif (!\"WebSocket\".equalsIgnoreCase(headers.getUpgrade())) {\n\t\t\treturn handleBadRequest(exchange, \"Invalid 'Upgrade' header: \" + headers);\n\t\t}\n\n\t\tList<String> connectionValue = headers.getConnection();\n\t\tif (!connectionValue.contains(\"Upgrade\") && !connectionValue.contains(\"upgrade\")) {\n\t\t\treturn handleBadRequest(exchange, \"Invalid 'Connection' header: \" + headers);\n\t\t}\n\n\t\tString key = headers.getFirst(SEC_WEBSOCKET_KEY);\n\t\tif (key == null) {\n\t\t\treturn handleBadRequest(exchange, \"Missing \\\"Sec-WebSocket-Key\\\" header\");\n\t\t}\n\n\t\tString protocol = selectProtocol(headers, handler);\n\n\t\treturn initAttributes(exchange).flatMap(attributes ->\n\t\t\t\tthis.upgradeStrategy.upgrade(exchange, handler, protocol,\n\t\t\t\t\t\t() -> createHandshakeInfo(exchange, request, protocol, attributes))\n\t\t);\n\t}"
  },
  "org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() {\n\t\treturn this.running;\n\t}"
  },
  "org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService#setSessionAttributePredicate(predicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a predicate to use to extract\n\t * {@link org.springframework.web.server.WebSession WebSession} attributes\n\t * and use them to initialize the WebSocket session with.\n\t * <p>By default this is not set in which case no attributes are passed.\n\t * @param predicate the predicate\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void setSessionAttributePredicate(@Nullable Predicate<String> predicate)",
    "source_code": "\tpublic void setSessionAttributePredicate(@Nullable Predicate<String> predicate) {\n\t\tthis.sessionAttributePredicate = predicate;\n\t}"
  },
  "org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService#start()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() {\n\t\tif (!isRunning()) {\n\t\t\tthis.running = true;\n\t\t\tdoStart();\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() {\n\t\tif (isRunning()) {\n\t\t\tthis.running = false;\n\t\t\tdoStop();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#model()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "Object>",
    "signature": "public Object> model()",
    "source_code": "\t\tpublic Map<String, Object> model() {\n\t\t\treturn this.model;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#name()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "String",
    "signature": "public String name()",
    "source_code": "\t\tpublic String name() {\n\t\t\treturn this.name;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#writeToInternal(request,response,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView writeToInternal(HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, Context context)",
    "source_code": "\t\tprotected ModelAndView writeToInternal(HttpServletRequest request,"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Creates {@link RequestMappingInfo} instances from type and method-level\n * {@link RequestMapping @RequestMapping} annotations in\n * {@link Controller @Controller} classes.\n *\n * <p><strong>Deprecation Note:</strong></p> In 5.2.4,\n * {@link #setUseSuffixPatternMatch(boolean) useSuffixPatternMatch} and\n * {@link #setUseRegisteredSuffixPatternMatch(boolean) useRegisteredSuffixPatternMatch}\n * were deprecated in order to discourage use of path extensions for request\n * mapping and for content negotiation (with similar deprecations in\n * {@link org.springframework.web.accept.ContentNegotiationManagerFactoryBean\n * ContentNegotiationManagerFactoryBean}). For further context, please read issue\n * <a href=\"https://github.com/spring-projects/spring-framework/issues/24179\">#24179</a>.\n *\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "signature": "public class RequestMappingHandlerMapping",
    "source_code": "public class RequestMappingHandlerMapping extends RequestMappingInfoHandlerMapping"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tthis.config = new RequestMappingInfo.BuilderConfiguration();\n\t\tthis.config.setTrailingSlashMatch(useTrailingSlashMatch());\n\t\tthis.config.setContentNegotiationManager(getContentNegotiationManager());\n\n\t\tif (getPatternParser() != null && this.defaultPatternParser &&\n\t\t\t\t(this.useSuffixPatternMatch || this.useRegisteredSuffixPatternMatch)) {\n\n\t\t\tsetPatternParser(null);\n\t\t}\n\n\t\tif (getPatternParser() != null) {\n\t\t\tthis.config.setPatternParser(getPatternParser());\n\t\t\tAssert.isTrue(!this.useSuffixPatternMatch && !this.useRegisteredSuffixPatternMatch,\n\t\t\t\t\t\"Suffix pattern matching not supported with PathPatternParser.\");\n\t\t}\n\t\telse {\n\t\t\tthis.config.setSuffixPatternMatch(useSuffixPatternMatch());\n\t\t\tthis.config.setRegisteredSuffixPatternMatch(useRegisteredSuffixPatternMatch());\n\t\t\tthis.config.setPathMatcher(getPathMatcher());\n\t\t}\n\n\t\tsuper.afterPropertiesSet();\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#createRequestMappingInfo(requestMapping,customCondition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RequestMappingInfo} from the supplied\n\t * {@link RequestMapping @RequestMapping} annotation, which is either\n\t * a directly declared annotation, a meta-annotation, or the synthesized\n\t * result of merging annotation attributes within an annotation hierarchy.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "requestMapping",
      "customCondition"
    ],
    "position": {
      "column": 1,
      "line": 383
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo createRequestMappingInfo(RequestMapping requestMapping, @Nullable RequestCondition<?> customCondition)",
    "source_code": "\tprotected RequestMappingInfo createRequestMappingInfo("
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#getContentNegotiationManager()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link ContentNegotiationManager}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "ContentNegotiationManager",
    "signature": "public ContentNegotiationManager getContentNegotiationManager()",
    "source_code": "\tpublic ContentNegotiationManager getContentNegotiationManager() {\n\t\treturn this.contentNegotiationManager;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#getFileExtensions()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the file extensions to use for suffix pattern matching.\n\t * @deprecated as of 5.2.4. See class-level note on the deprecation of path\n\t * extension config options.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "List<String>",
    "signature": "public List<String> getFileExtensions()",
    "source_code": "\tpublic List<String> getFileExtensions() {\n\t\treturn this.config.getFileExtensions();\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#getMappingForMethod(method,handlerType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Uses method and type-level @{@link RequestMapping} annotations to create\n\t * the RequestMappingInfo.\n\t * @return the created RequestMappingInfo, or {@code null} if the method\n\t * does not have a {@code @RequestMapping} annotation.\n\t * @see #getCustomMethodCondition(Method)\n\t * @see #getCustomTypeCondition(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n\t\tRequestMappingInfo info = createRequestMappingInfo(method);\n\t\tif (info != null) {\n\t\t\tRequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);\n\t\t\tif (typeInfo != null) {\n\t\t\t\tinfo = typeInfo.combine(info);\n\t\t\t}\n\t\t\tString prefix = getPathPrefix(handlerType);\n\t\t\tif (prefix != null) {\n\t\t\t\tinfo = RequestMappingInfo.paths(prefix).options(this.config).build().combine(info);\n\t\t\t}\n\t\t}\n\t\treturn info;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#initCorsConfiguration(handler,method,mappingInfo)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mappingInfo"
    ],
    "position": {
      "column": 1,
      "line": 468
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mappingInfo)",
    "source_code": "\tprotected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mappingInfo) {\n\t\tHandlerMethod handlerMethod = createHandlerMethod(handler, method);\n\t\tClass<?> beanType = handlerMethod.getBeanType();\n\t\tCrossOrigin typeAnnotation = AnnotatedElementUtils.findMergedAnnotation(beanType, CrossOrigin.class);\n\t\tCrossOrigin methodAnnotation = AnnotatedElementUtils.findMergedAnnotation(method, CrossOrigin.class);\n\n\t\tif (typeAnnotation == null && methodAnnotation == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tCorsConfiguration config = new CorsConfiguration();\n\t\tupdateCorsConfig(config, typeAnnotation);\n\t\tupdateCorsConfig(config, methodAnnotation);\n\n\t\tif (CollectionUtils.isEmpty(config.getAllowedMethods())) {\n\t\t\tfor (RequestMethod allowedMethod : mappingInfo.getMethodsCondition().getMethods()) {\n\t\t\t\tconfig.addAllowedMethod(allowedMethod.name());\n\t\t\t}\n\t\t}\n\t\treturn config.applyPermitDefaultValues();\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#isHandler(beanType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>Expects a handler to have a type-level @{@link Controller} annotation.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanType"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "boolean",
    "signature": "protected boolean isHandler(Class<?> beanType)",
    "source_code": "\tprotected boolean isHandler(Class<?> beanType) {\n\t\treturn AnnotatedElementUtils.hasAnnotation(beanType, Controller.class);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#match(request,pattern)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 456
    },
    "return": "RequestMatchResult",
    "signature": "public RequestMatchResult match(HttpServletRequest request, String pattern)",
    "source_code": "\tpublic RequestMatchResult match(HttpServletRequest request, String pattern) {\n\t\tAssert.state(getPatternParser() == null, \"This HandlerMapping uses PathPatterns.\");\n\t\tRequestMappingInfo info = RequestMappingInfo.paths(pattern).options(this.config).build();\n\t\tRequestMappingInfo match = info.getMatchingCondition(request);\n\t\treturn (match != null && match.getPatternsCondition() != null ?\n\t\t\t\tnew RequestMatchResult(\n\t\t\t\t\t\tmatch.getPatternsCondition().getPatterns().iterator().next(),\n\t\t\t\t\t\tUrlPathHelper.getResolvedLookupPath(request),\n\t\t\t\t\t\tgetPathMatcher()) : null);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#registerHandlerMethod(handler,method,mapping)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p><strong>Note:</strong> To create the {@link RequestMappingInfo},\n\t * please use {@link #getBuilderConfiguration()} and set the options on\n\t * {@link RequestMappingInfo.Builder#options(RequestMappingInfo.BuilderConfiguration)}\n\t * to match how this {@code HandlerMapping} is configured. This\n\t * is important for example to ensure use of\n\t * {@link org.springframework.web.util.pattern.PathPattern} or\n\t * {@link org.springframework.util.PathMatcher} based matching.\n\t * @param handler the bean name of the handler or the handler instance\n\t * @param method the method to register\n\t * @param mapping the mapping conditions associated with the handler method\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "void",
    "signature": "protected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping)",
    "source_code": "\tprotected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping) {\n\t\tsuper.registerHandlerMethod(handler, method, mapping);\n\t\tupdateConsumesCondition(mapping, method);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#registerMapping(mapping,handler,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 418
    },
    "return": "void",
    "signature": "public void registerMapping(RequestMappingInfo mapping, Object handler, Method method)",
    "source_code": "\tpublic void registerMapping(RequestMappingInfo mapping, Object handler, Method method) {\n\t\tsuper.registerMapping(mapping, handler, method);\n\t\tupdateConsumesCondition(mapping, method);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#resolveEmbeddedValuesInPatterns(patterns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve placeholder values in the given array of patterns.\n\t * @return a new array with updated patterns\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "patterns"
    ],
    "position": {
      "column": 1,
      "line": 404
    },
    "return": "String[]",
    "signature": "protected String[] resolveEmbeddedValuesInPatterns(String[] patterns)",
    "source_code": "\tprotected String[] resolveEmbeddedValuesInPatterns(String[] patterns) {\n\t\tif (this.embeddedValueResolver == null) {\n\t\t\treturn patterns;\n\t\t}\n\t\telse {\n\t\t\tString[] resolvedPatterns = new String[patterns.length];\n\t\t\tfor (int i = 0; i < patterns.length; i++) {\n\t\t\t\tresolvedPatterns[i] = this.embeddedValueResolver.resolveStringValue(patterns[i]);\n\t\t\t}\n\t\t\treturn resolvedPatterns;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#setContentNegotiationManager(contentNegotiationManager)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link ContentNegotiationManager} to use to determine requested media types.\n\t * If not set, the default constructor is used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentNegotiationManager"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void setContentNegotiationManager(ContentNegotiationManager contentNegotiationManager)",
    "source_code": "\tpublic void setContentNegotiationManager(ContentNegotiationManager contentNegotiationManager) {\n\t\tAssert.notNull(contentNegotiationManager, \"ContentNegotiationManager must not be null\");\n\t\tthis.contentNegotiationManager = contentNegotiationManager;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#setEmbeddedValueResolver(resolver)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "void",
    "signature": "public void setEmbeddedValueResolver(StringValueResolver resolver)",
    "source_code": "\tpublic void setEmbeddedValueResolver(StringValueResolver resolver) {\n\t\tthis.embeddedValueResolver = resolver;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#setPathPrefixes(Map<String,prefixes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure path prefixes to apply to controller methods.\n\t * <p>Prefixes are used to enrich the mappings of every {@code @RequestMapping}\n\t * method whose controller type is matched by the corresponding\n\t * {@code Predicate}. The prefix for the first matching predicate is used.\n\t * <p>Consider using {@link org.springframework.web.method.HandlerTypePredicate\n\t * HandlerTypePredicate} to group controllers.\n\t * @param prefixes a map with path prefixes as key\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "prefixes"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "void",
    "signature": "public void setPathPrefixes(Map<String, Predicate<Class<?>>> prefixes)",
    "source_code": "\tpublic void setPathPrefixes(Map<String, Predicate<Class<?>>> prefixes) {\n\t\tthis.pathPrefixes = (!prefixes.isEmpty() ?\n\t\t\t\tCollections.unmodifiableMap(new LinkedHashMap<>(prefixes)) :\n\t\t\t\tCollections.emptyMap());\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#setPatternParser(patternParser)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "patternParser"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void setPatternParser(@Nullable PathPatternParser patternParser)",
    "source_code": "\tpublic void setPatternParser(@Nullable PathPatternParser patternParser) {\n\t\tif (patternParser != null) {\n\t\t\tthis.defaultPatternParser = false;\n\t\t}\n\t\tsuper.setPatternParser(patternParser);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#setUseRegisteredSuffixPatternMatch(useRegisteredSuffixPatternMatch)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether suffix pattern matching should work only against path extensions\n\t * explicitly registered with the {@link ContentNegotiationManager}. This\n\t * is generally recommended to reduce ambiguity and to avoid issues such as\n\t * when a \".\" appears in the path for other reasons.\n\t * <p>By default this is set to \"false\".\n\t * <p><strong>Note:</strong> This property is ignored when\n\t * {@link #setPatternParser(PathPatternParser)} is configured.\n\t * @deprecated as of 5.2.4. See class level note on the deprecation of\n\t * path extension config options.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "useRegisteredSuffixPatternMatch"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void setUseRegisteredSuffixPatternMatch(boolean useRegisteredSuffixPatternMatch)",
    "source_code": "\tpublic void setUseRegisteredSuffixPatternMatch(boolean useRegisteredSuffixPatternMatch) {\n\t\tthis.useRegisteredSuffixPatternMatch = useRegisteredSuffixPatternMatch;\n\t\tthis.useSuffixPatternMatch = (useRegisteredSuffixPatternMatch || this.useSuffixPatternMatch);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#setUseSuffixPatternMatch(useSuffixPatternMatch)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to use suffix pattern match (\".*\") when matching patterns to\n\t * requests. If enabled a method mapped to \"/users\" also matches to \"/users.*\".\n\t * <p>By default value this is set to {@code false}.\n\t * <p>Also see {@link #setUseRegisteredSuffixPatternMatch(boolean)} for\n\t * more fine-grained control over specific suffixes to allow.\n\t * <p><strong>Note:</strong> This property is ignored when\n\t * {@link #setPatternParser(PathPatternParser)} is configured.\n\t * @deprecated as of 5.2.4. See class level note on the deprecation of\n\t * path extension config options. As there is no replacement for this method,\n\t * in 5.2.x it is necessary to set it to {@code false}. In 5.3 the default\n\t * changes to {@code false} and use of this property becomes unnecessary.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "useSuffixPatternMatch"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void setUseSuffixPatternMatch(boolean useSuffixPatternMatch)",
    "source_code": "\tpublic void setUseSuffixPatternMatch(boolean useSuffixPatternMatch) {\n\t\tthis.useSuffixPatternMatch = useSuffixPatternMatch;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#setUseTrailingSlashMatch(useTrailingSlashMatch)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to match to URLs irrespective of the presence of a trailing slash.\n\t * If enabled a method mapped to \"/users\" also matches to \"/users/\".\n\t * <p>The default was changed in 6.0 from {@code true} to {@code false} in\n\t * order to support the deprecation of the property.\n\t * @deprecated as of 6.0, see\n\t * {@link PathPatternParser#setMatchOptionalTrailingSeparator(boolean)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "useTrailingSlashMatch"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void setUseTrailingSlashMatch(boolean useTrailingSlashMatch)",
    "source_code": "\tpublic void setUseTrailingSlashMatch(boolean useTrailingSlashMatch) {\n\t\tthis.useTrailingSlashMatch = useTrailingSlashMatch;\n\t\tif (getPatternParser() != null) {\n\t\t\tgetPatternParser().setMatchOptionalTrailingSeparator(useTrailingSlashMatch);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#useRegisteredSuffixPatternMatch()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to use registered suffixes for pattern matching.\n\t * @deprecated as of 5.2.4. See deprecation notice on\n\t * {@link #setUseRegisteredSuffixPatternMatch(boolean)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "boolean",
    "signature": "public boolean useRegisteredSuffixPatternMatch()",
    "source_code": "\tpublic boolean useRegisteredSuffixPatternMatch() {\n\t\treturn this.useRegisteredSuffixPatternMatch;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#useSuffixPatternMatch()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to use registered suffixes for pattern matching.\n\t * @deprecated as of 5.2.4. See deprecation notice on\n\t * {@link #setUseSuffixPatternMatch(boolean)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "boolean",
    "signature": "public boolean useSuffixPatternMatch()",
    "source_code": "\tpublic boolean useSuffixPatternMatch() {\n\t\treturn this.useSuffixPatternMatch;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#useTrailingSlashMatch()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to match to URLs irrespective of the presence of a trailing slash.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "boolean",
    "signature": "public boolean useTrailingSlashMatch()",
    "source_code": "\tpublic boolean useTrailingSlashMatch() {\n\t\treturn this.useTrailingSlashMatch;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#getMessageSource()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link MessageSource} that this exception handler uses.\n\t * @since 6.0.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "MessageSource",
    "signature": "protected MessageSource getMessageSource()",
    "source_code": "\tprotected MessageSource getMessageSource() {\n\t\treturn this.messageSource;\n\t}"
  },
  "org.springframework.web.servlet.support.BindStatus": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Simple adapter to expose the bind status of a field or object.\n * Set as a variable both by the JSP bind tag and FreeMarker macros.\n *\n * <p>Obviously, object status representations (i.e. errors at the object level\n * rather than the field level) do not have an expression and a value but only\n * error codes and messages. For simplicity's sake and to be able to use the same\n * tags and macros, the same status class is used for both scenarios.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Darren Davison\n * @see RequestContext#getBindStatus\n * @see org.springframework.web.servlet.tags.BindTag\n * @see org.springframework.web.servlet.view.AbstractTemplateView#setExposeSpringMacroHelpers\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class BindStatus",
    "source_code": "public class BindStatus {\n\n\tprivate final RequestContext requestContext;\n\n\tprivate final String path;\n\n\tprivate final boolean htmlEscape;\n\n\t@Nullable\n\tprivate final String expression;\n\n\t@Nullable\n\tprivate final Errors errors;\n\n\tprivate final String[] errorCodes;\n\n\t@Nullable\n\tprivate String[] errorMessages;\n\n\t@Nullable\n\tprivate List<? extends ObjectError> objectErrors;\n\n\t@Nullable\n\tprivate Object value;\n\n\t@Nullable\n\tprivate Class<?> valueType;\n\n\t@Nullable\n\tprivate Object actualValue;\n\n\t@Nullable\n\tprivate PropertyEditor editor;\n\n\t@Nullable\n\tprivate BindingResult bindingResult;\n\n\n\t/**\n\t * Create a new BindStatus instance, representing a field or object status.\n\t * @param requestContext the current RequestContext\n\t * @param path the bean and property path for which values and errors\n\t * will be resolved (e.g. \"customer.address.street\")\n\t * @param htmlEscape whether to HTML-escape error messages and string values\n\t * @throws IllegalStateException if no corresponding Errors object found\n\t */\n\tpublic BindStatus(RequestContext requestContext, String path, boolean htmlEscape) throws IllegalStateException {\n\t\tthis.requestContext = requestContext;\n\t\tthis.path = path;\n\t\tthis.htmlEscape = htmlEscape;\n\n\t\t// determine name of the object and property\n\t\tString beanName;\n\t\tint dotPos = path.indexOf('.');\n\t\tif (dotPos == -1) {\n\t\t\t// property not set, only the object itself\n\t\t\tbeanName = path;\n\t\t\tthis.expression = null;\n\t\t}\n\t\telse {\n\t\t\tbeanName = path.substring(0, dotPos);\n\t\t\tthis.expression = path.substring(dotPos + 1);\n\t\t}\n\n\t\tthis.errors = requestContext.getErrors(beanName, false);\n\n\t\tif (this.errors != null) {\n\t\t\t// Usual case: A BindingResult is available as request attribute.\n\t\t\t// Can determine error codes and messages for the given expression.\n\t\t\t// Can use a custom PropertyEditor, as registered by a form controller.\n\t\t\tif (this.expression != null) {\n\t\t\t\tif (\"*\".equals(this.expression)) {\n\t\t\t\t\tthis.objectErrors = this.errors.getAllErrors();\n\t\t\t\t}\n\t\t\t\telse if (this.expression.endsWith(\"*\")) {\n\t\t\t\t\tthis.objectErrors = this.errors.getFieldErrors(this.expression);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.objectErrors = this.errors.getFieldErrors(this.expression);\n\t\t\t\t\tthis.value = this.errors.getFieldValue(this.expression);\n\t\t\t\t\tthis.valueType = this.errors.getFieldType(this.expression);\n\t\t\t\t\tif (this.errors instanceof BindingResult br) {\n\t\t\t\t\t\tthis.bindingResult = br;\n\t\t\t\t\t\tthis.actualValue = this.bindingResult.getRawFieldValue(this.expression);\n\t\t\t\t\t\tthis.editor = this.bindingResult.findEditor(this.expression, null);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.actualValue = this.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.objectErrors = this.errors.getGlobalErrors();\n\t\t\t}\n\t\t\tthis.errorCodes = initErrorCodes(this.objectErrors);\n\t\t}\n\n\t\telse {\n\t\t\t// No BindingResult available as request attribute:\n\t\t\t// Probably forwarded directly to a form view.\n\t\t\t// Let's do the best we can: extract a plain target if appropriate.\n\t\t\tObject target = requestContext.getModelObject(beanName);\n\t\t\tif (target == null) {\n\t\t\t\tthrow new IllegalStateException(\"Neither BindingResult nor plain target object for bean name '\" +\n\t\t\t\t\t\tbeanName + \"' available as request attribute\");\n\t\t\t}\n\t\t\tif (this.expression != null && !\"*\".equals(this.expression) && !this.expression.endsWith(\"*\")) {\n\t\t\t\tBeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(target);\n\t\t\t\tthis.value = bw.getPropertyValue(this.expression);\n\t\t\t\tthis.valueType = bw.getPropertyType(this.expression);\n\t\t\t\tthis.actualValue = this.value;\n\t\t\t}\n\t\t\tthis.errorCodes = new String[0];\n\t\t\tthis.errorMessages = new String[0];\n\t\t}\n\n\t\tif (htmlEscape && this.value instanceof String text) {\n\t\t\tthis.value = HtmlUtils.htmlEscape(text);\n\t\t}\n\t}\n\n\t/**\n\t * Extract the error codes from the ObjectError list.\n\t */\n\tprivate static String[] initErrorCodes(List<? extends ObjectError> objectErrors) {\n\t\tString[] errorCodes = new String[objectErrors.size()];\n\t\tfor (int i = 0; i < objectErrors.size(); i++) {\n\t\t\tObjectError error = objectErrors.get(i);\n\t\t\terrorCodes[i] = error.getCode();\n\t\t}\n\t\treturn errorCodes;\n\t}\n\n\n\t/**\n\t * Return the bean and property path for which values and errors\n\t * will be resolved (e.g. \"customer.address.street\").\n\t */\n\tpublic String getPath() {\n\t\treturn this.path;\n\t}\n\n\t/**\n\t * Return a bind expression that can be used in HTML forms as input name\n\t * for the respective field, or {@code null} if not field-specific.\n\t * <p>Returns a bind path appropriate for resubmission, e.g. \"address.street\".\n\t * Note that the complete bind path as required by the bind tag is\n\t * \"customer.address.street\", if bound to a \"customer\" bean.\n\t */\n\t@Nullable\n\tpublic String getExpression() {\n\t\treturn this.expression;\n\t}\n\n\t/**\n\t * Return the current value of the field, i.e. either the property value\n\t * or a rejected update, or {@code null} if not field-specific.\n\t * <p>This value will be an HTML-escaped String if the original value\n\t * already was a String.\n\t */\n\t@Nullable\n\tpublic Object getValue() {\n\t\treturn this.value;\n\t}\n\n\t/**\n\t * Get the '{@code Class}' type of the field. Favor this instead of\n\t * '{@code getValue().getClass()}' since '{@code getValue()}' may\n\t * return '{@code null}'.\n\t */\n\t@Nullable\n\tpublic Class<?> getValueType() {\n\t\treturn this.valueType;\n\t}\n\n\t/**\n\t * Return the actual value of the field, i.e. the raw property value,\n\t * or {@code null} if not available.\n\t */\n\t@Nullable\n\tpublic Object getActualValue() {\n\t\treturn this.actualValue;\n\t}\n\n\t/**\n\t * Return a suitable display value for the field, i.e. the stringified\n\t * value if not null, and an empty string in case of a null value.\n\t * <p>This value will be an HTML-escaped String if the original value\n\t * was non-null: the {@code toString} result of the original value\n\t * will get HTML-escaped.\n\t */\n\tpublic String getDisplayValue() {\n\t\tif (this.value instanceof String displayValue) {\n\t\t\treturn displayValue;\n\t\t}\n\t\tif (this.value != null) {\n\t\t\treturn (this.htmlEscape ? HtmlUtils.htmlEscape(this.value.toString()) : this.value.toString());\n\t\t}\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Return if this status represents a field or object error.\n\t */\n\tpublic boolean isError() {\n\t\treturn (this.errorCodes.length > 0);\n\t}\n\n\t/**\n\t * Return the error codes for the field or object, if any.\n\t * Returns an empty array instead of null if none.\n\t */\n\tpublic String[] getErrorCodes() {\n\t\treturn this.errorCodes;\n\t}\n\n\t/**\n\t * Return the first error codes for the field or object, if any.\n\t */\n\tpublic String getErrorCode() {\n\t\treturn (this.errorCodes.length > 0 ? this.errorCodes[0] : \"\");\n\t}\n\n\t/**\n\t * Return the resolved error messages for the field or object,\n\t * if any. Returns an empty array instead of null if none.\n\t */\n\tpublic String[] getErrorMessages() {\n\t\treturn initErrorMessages();\n\t}\n\n\t/**\n\t * Return the first error message for the field or object, if any.\n\t */\n\tpublic String getErrorMessage() {\n\t\tString[] errorMessages = initErrorMessages();\n\t\treturn (errorMessages.length > 0 ? errorMessages[0] : \"\");\n\t}\n\n\t/**\n\t * Return an error message string, concatenating all messages\n\t * separated by the given delimiter.\n\t * @param delimiter separator string, e.g. \", \" or \"<br>\"\n\t * @return the error message string\n\t */\n\tpublic String getErrorMessagesAsString(String delimiter) {\n\t\treturn StringUtils.arrayToDelimitedString(initErrorMessages(), delimiter);\n\t}\n\n\t/**\n\t * Extract the error messages from the ObjectError list.\n\t */\n\tprivate String[] initErrorMessages() throws NoSuchMessageException {\n\t\tif (this.errorMessages == null) {\n\t\t\tif (this.objectErrors != null) {\n\t\t\t\tthis.errorMessages = new String[this.objectErrors.size()];\n\t\t\t\tfor (int i = 0; i < this.objectErrors.size(); i++) {\n\t\t\t\t\tObjectError error = this.objectErrors.get(i);\n\t\t\t\t\tthis.errorMessages[i] = this.requestContext.getMessage(error, this.htmlEscape);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.errorMessages = new String[0];\n\t\t\t}\n\t\t}\n\t\treturn this.errorMessages;\n\t}\n\n\t/**\n\t * Return the Errors instance (typically a BindingResult) that this\n\t * bind status is currently associated with.\n\t * @return the current Errors instance, or {@code null} if none\n\t * @see org.springframework.validation.BindingResult\n\t */\n\t@Nullable\n\tpublic Errors getErrors() {\n\t\treturn this.errors;\n\t}\n\n\t/**\n\t * Return the PropertyEditor for the property that this bind status\n\t * is currently bound to.\n\t * @return the current PropertyEditor, or {@code null} if none\n\t */\n\t@Nullable\n\tpublic PropertyEditor getEditor() {\n\t\treturn this.editor;\n\t}\n\n\t/**\n\t * Find a PropertyEditor for the given value class, associated with\n\t * the property that this bound status is currently bound to.\n\t * @param valueClass the value class that an editor is needed for\n\t * @return the associated PropertyEditor, or {@code null} if none\n\t */\n\t@Nullable\n\tpublic PropertyEditor findEditor(Class<?> valueClass) {\n\t\treturn (this.bindingResult != null ? this.bindingResult.findEditor(this.expression, valueClass) : null);\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(\"BindStatus: \");\n\t\tsb.append(\"expression=[\").append(this.expression).append(\"]; \");\n\t\tsb.append(\"value=[\").append(this.value).append(']');\n\t\tif (!ObjectUtils.isEmpty(this.errorCodes)) {\n\t\t\tsb.append(\"; errorCodes=\").append(Arrays.asList(this.errorCodes));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n}"
  },
  "org.springframework.web.servlet.support.BindStatus#findEditor(valueClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a PropertyEditor for the given value class, associated with\n\t * the property that this bound status is currently bound to.\n\t * @param valueClass the value class that an editor is needed for\n\t * @return the associated PropertyEditor, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "valueClass"
    ],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "PropertyEditor",
    "signature": "public PropertyEditor findEditor(Class<?> valueClass)",
    "source_code": "\tpublic PropertyEditor findEditor(Class<?> valueClass) {\n\t\treturn (this.bindingResult != null ? this.bindingResult.findEditor(this.expression, valueClass) : null);\n\t}"
  },
  "org.springframework.web.servlet.support.BindStatus#getActualValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the actual value of the field, i.e. the raw property value,\n\t * or {@code null} if not available.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "Object",
    "signature": "public Object getActualValue()",
    "source_code": "\tpublic Object getActualValue() {\n\t\treturn this.actualValue;\n\t}"
  },
  "org.springframework.web.servlet.support.BindStatus#getDisplayValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a suitable display value for the field, i.e. the stringified\n\t * value if not null, and an empty string in case of a null value.\n\t * <p>This value will be an HTML-escaped String if the original value\n\t * was non-null: the {@code toString} result of the original value\n\t * will get HTML-escaped.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "String",
    "signature": "public String getDisplayValue()",
    "source_code": "\tpublic String getDisplayValue() {\n\t\tif (this.value instanceof String displayValue) {\n\t\t\treturn displayValue;\n\t\t}\n\t\tif (this.value != null) {\n\t\t\treturn (this.htmlEscape ? HtmlUtils.htmlEscape(this.value.toString()) : this.value.toString());\n\t\t}\n\t\treturn \"\";\n\t}"
  },
  "org.springframework.web.servlet.support.BindStatus#getEditor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the PropertyEditor for the property that this bind status\n\t * is currently bound to.\n\t * @return the current PropertyEditor, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "PropertyEditor",
    "signature": "public PropertyEditor getEditor()",
    "source_code": "\tpublic PropertyEditor getEditor() {\n\t\treturn this.editor;\n\t}"
  },
  "org.springframework.web.servlet.support.BindStatus#getErrorCode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the first error codes for the field or object, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "String",
    "signature": "public String getErrorCode()",
    "source_code": "\tpublic String getErrorCode() {\n\t\treturn (this.errorCodes.length > 0 ? this.errorCodes[0] : \"\");\n\t}"
  },
  "org.springframework.web.servlet.support.BindStatus#getErrorCodes()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the error codes for the field or object, if any.\n\t * Returns an empty array instead of null if none.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "String[]",
    "signature": "public String[] getErrorCodes()",
    "source_code": "\tpublic String[] getErrorCodes() {\n\t\treturn this.errorCodes;\n\t}"
  },
  "org.springframework.web.servlet.support.BindStatus#getErrorMessage()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the first error message for the field or object, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "String",
    "signature": "public String getErrorMessage()",
    "source_code": "\tpublic String getErrorMessage() {\n\t\tString[] errorMessages = initErrorMessages();\n\t\treturn (errorMessages.length > 0 ? errorMessages[0] : \"\");\n\t}"
  },
  "org.springframework.web.servlet.support.BindStatus#getErrorMessages()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the resolved error messages for the field or object,\n\t * if any. Returns an empty array instead of null if none.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "String[]",
    "signature": "public String[] getErrorMessages()",
    "source_code": "\tpublic String[] getErrorMessages() {\n\t\treturn initErrorMessages();\n\t}"
  },
  "org.springframework.web.servlet.support.BindStatus#getErrorMessagesAsString(delimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an error message string, concatenating all messages\n\t * separated by the given delimiter.\n\t * @param delimiter separator string, e.g. \", \" or \"<br>\"\n\t * @return the error message string\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "String",
    "signature": "public String getErrorMessagesAsString(String delimiter)",
    "source_code": "\tpublic String getErrorMessagesAsString(String delimiter) {\n\t\treturn StringUtils.arrayToDelimitedString(initErrorMessages(), delimiter);\n\t}"
  },
  "org.springframework.web.servlet.support.BindStatus#getErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Errors instance (typically a BindingResult) that this\n\t * bind status is currently associated with.\n\t * @return the current Errors instance, or {@code null} if none\n\t * @see org.springframework.validation.BindingResult\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "Errors",
    "signature": "public Errors getErrors()",
    "source_code": "\tpublic Errors getErrors() {\n\t\treturn this.errors;\n\t}"
  },
  "org.springframework.web.servlet.support.BindStatus#getExpression()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a bind expression that can be used in HTML forms as input name\n\t * for the respective field, or {@code null} if not field-specific.\n\t * <p>Returns a bind path appropriate for resubmission, e.g. \"address.street\".\n\t * Note that the complete bind path as required by the bind tag is\n\t * \"customer.address.street\", if bound to a \"customer\" bean.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "String",
    "signature": "public String getExpression()",
    "source_code": "\tpublic String getExpression() {\n\t\treturn this.expression;\n\t}"
  },
  "org.springframework.web.servlet.support.BindStatus#getPath()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the bean and property path for which values and errors\n\t * will be resolved (e.g. \"customer.address.street\").\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "String",
    "signature": "public String getPath()",
    "source_code": "\tpublic String getPath() {\n\t\treturn this.path;\n\t}"
  },
  "org.springframework.web.servlet.support.BindStatus#getValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the current value of the field, i.e. either the property value\n\t * or a rejected update, or {@code null} if not field-specific.\n\t * <p>This value will be an HTML-escaped String if the original value\n\t * already was a String.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "Object",
    "signature": "public Object getValue()",
    "source_code": "\tpublic Object getValue() {\n\t\treturn this.value;\n\t}"
  },
  "org.springframework.web.servlet.support.BindStatus#isError()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return if this status represents a field or object error.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "boolean",
    "signature": "public boolean isError()",
    "source_code": "\tpublic boolean isError() {\n\t\treturn (this.errorCodes.length > 0);\n\t}"
  },
  "org.springframework.web.servlet.support.BindStatus#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(\"BindStatus: \");\n\t\tsb.append(\"expression=[\").append(this.expression).append(\"]; \");\n\t\tsb.append(\"value=[\").append(this.value).append(']');\n\t\tif (!ObjectUtils.isEmpty(this.errorCodes)) {\n\t\t\tsb.append(\"; errorCodes=\").append(Arrays.asList(this.errorCodes));\n\t\t}\n\t\treturn sb.toString();\n\t}"
  }
}