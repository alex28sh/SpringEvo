{
  "org.springframework.aop.aspectj.AmbiguousBindingException": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Thrown in response to an ambiguous binding being detected when\n\t * trying to resolve a method's parameter names.\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 766
    },
    "signature": "public class AmbiguousBindingException",
    "source_code": "\tpublic static class AmbiguousBindingException extends RuntimeException {\n\n\t\t/**\n\t\t * Construct a new AmbiguousBindingException with the specified message.\n\t\t * @param msg the detail message\n\t\t */\n\t\tpublic AmbiguousBindingException(String msg) {\n\t\t\tsuper(msg);\n\t\t}\n\t}"
  },
  "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link ParameterNameDiscoverer} implementation that tries to deduce parameter names\n * for an advice method from the pointcut expression, returning, and throwing clauses.\n * If an unambiguous interpretation is not available, it returns {@code null}.\n *\n * <p>This class interprets arguments in the following way:\n * <ol>\n * <li>If the first parameter of the method is of type {@link JoinPoint}\n * or {@link ProceedingJoinPoint}, it is assumed to be for passing\n * {@code thisJoinPoint} to the advice, and the parameter name will\n * be assigned the value {@code \"thisJoinPoint\"}.</li>\n * <li>If the first parameter of the method is of type\n * {@code JoinPoint.StaticPart}, it is assumed to be for passing\n * {@code \"thisJoinPointStaticPart\"} to the advice, and the parameter name\n * will be assigned the value {@code \"thisJoinPointStaticPart\"}.</li>\n * <li>If a {@link #setThrowingName(String) throwingName} has been set, and\n * there are no unbound arguments of type {@code Throwable+}, then an\n * {@link IllegalArgumentException} is raised. If there is more than one\n * unbound argument of type {@code Throwable+}, then an\n * {@link AmbiguousBindingException} is raised. If there is exactly one\n * unbound argument of type {@code Throwable+}, then the corresponding\n * parameter name is assigned the value &lt;throwingName&gt;.</li>\n * <li>If there remain unbound arguments, then the pointcut expression is\n * examined. Let {@code a} be the number of annotation-based pointcut\n * expressions (&#64;annotation, &#64;this, &#64;target, &#64;args,\n * &#64;within, &#64;withincode) that are used in binding form. Usage in\n * binding form has itself to be deduced: if the expression inside the\n * pointcut is a single string literal that meets Java variable name\n * conventions it is assumed to be a variable name. If {@code a} is\n * zero we proceed to the next stage. If {@code a} &gt; 1 then an\n * {@code AmbiguousBindingException} is raised. If {@code a} == 1,\n * and there are no unbound arguments of type {@code Annotation+},\n * then an {@code IllegalArgumentException} is raised. if there is\n * exactly one such argument, then the corresponding parameter name is\n * assigned the value from the pointcut expression.</li>\n * <li>If a returningName has been set, and there are no unbound arguments\n * then an {@code IllegalArgumentException} is raised. If there is\n * more than one unbound argument then an\n * {@code AmbiguousBindingException} is raised. If there is exactly\n * one unbound argument then the corresponding parameter name is assigned\n * the value &lt;returningName&gt;.</li>\n * <li>If there remain unbound arguments, then the pointcut expression is\n * examined once more for {@code this}, {@code target}, and\n * {@code args} pointcut expressions used in the binding form (binding\n * forms are deduced as described for the annotation based pointcuts). If\n * there remains more than one unbound argument of a primitive type (which\n * can only be bound in {@code args}) then an\n * {@code AmbiguousBindingException} is raised. If there is exactly\n * one argument of a primitive type, then if exactly one {@code args}\n * bound variable was found, we assign the corresponding parameter name\n * the variable name. If there were no {@code args} bound variables\n * found an {@code IllegalStateException} is raised. If there are\n * multiple {@code args} bound variables, an\n * {@code AmbiguousBindingException} is raised. At this point, if\n * there remains more than one unbound argument we raise an\n * {@code AmbiguousBindingException}. If there are no unbound arguments\n * remaining, we are done. If there is exactly one unbound argument\n * remaining, and only one candidate variable name unbound from\n * {@code this}, {@code target}, or {@code args}, it is\n * assigned as the corresponding parameter name. If there are multiple\n * possibilities, an {@code AmbiguousBindingException} is raised.</li>\n * </ol>\n *\n * <p>The behavior on raising an {@code IllegalArgumentException} or\n * {@code AmbiguousBindingException} is configurable to allow this discoverer\n * to be used as part of a chain-of-responsibility. By default the condition will\n * be logged and the {@code getParameterNames(..)} method will simply return\n * {@code null}. If the {@link #setRaiseExceptions(boolean) raiseExceptions}\n * property is set to {@code true}, the conditions will be thrown as\n * {@code IllegalArgumentException} and {@code AmbiguousBindingException},\n * respectively.\n *\n * <p>Was that perfectly clear? ;)\n *\n * <p>Short version: If an unambiguous binding can be deduced, then it is.\n * If the advice requirements cannot possibly be satisfied, then {@code null}\n * is returned. By setting the {@link #setRaiseExceptions(boolean) raiseExceptions}\n * property to {@code true}, descriptive exceptions will be thrown instead of\n * returning {@code null} in the case that the parameter names cannot be discovered.\n *\n * @author Adrian Colyer\n * @author Juergen Hoeller\n * @since 2.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "signature": "public class AspectJAdviceParameterNameDiscoverer",
    "source_code": "public class AspectJAdviceParameterNameDiscoverer implements ParameterNameDiscoverer {\n\n\tprivate static final String THIS_JOIN_POINT = \"thisJoinPoint\";\n\tprivate static final String THIS_JOIN_POINT_STATIC_PART = \"thisJoinPointStaticPart\";\n\n\t// Steps in the binding algorithm...\n\tprivate static final int STEP_JOIN_POINT_BINDING = 1;\n\tprivate static final int STEP_THROWING_BINDING = 2;\n\tprivate static final int STEP_ANNOTATION_BINDING = 3;\n\tprivate static final int STEP_RETURNING_BINDING = 4;\n\tprivate static final int STEP_PRIMITIVE_ARGS_BINDING = 5;\n\tprivate static final int STEP_THIS_TARGET_ARGS_BINDING = 6;\n\tprivate static final int STEP_REFERENCE_PCUT_BINDING = 7;\n\tprivate static final int STEP_FINISHED = 8;\n\n\tprivate static final Set<String> singleValuedAnnotationPcds = Set.of(\n\t\t\t\"@this\",\n\t\t\t\"@target\",\n\t\t\t\"@within\",\n\t\t\t\"@withincode\",\n\t\t\t\"@annotation\");\n\n\tprivate static final Set<String> nonReferencePointcutTokens = new HashSet<>();\n\n\n\tstatic {\n\t\tSet<PointcutPrimitive> pointcutPrimitives = PointcutParser.getAllSupportedPointcutPrimitives();\n\t\tfor (PointcutPrimitive primitive : pointcutPrimitives) {\n\t\t\tnonReferencePointcutTokens.add(primitive.getName());\n\t\t}\n\t\tnonReferencePointcutTokens.add(\"&&\");\n\t\tnonReferencePointcutTokens.add(\"!\");\n\t\tnonReferencePointcutTokens.add(\"||\");\n\t\tnonReferencePointcutTokens.add(\"and\");\n\t\tnonReferencePointcutTokens.add(\"or\");\n\t\tnonReferencePointcutTokens.add(\"not\");\n\t}\n\n\n\t/** The pointcut expression associated with the advice, as a simple String. */\n\t@Nullable\n\tprivate final String pointcutExpression;\n\n\tprivate boolean raiseExceptions;\n\n\t/** If the advice is afterReturning, and binds the return value, this is the parameter name used. */\n\t@Nullable\n\tprivate String returningName;\n\n\t/** If the advice is afterThrowing, and binds the thrown value, this is the parameter name used. */\n\t@Nullable\n\tprivate String throwingName;\n\n\tprivate Class<?>[] argumentTypes = new Class<?>[0];\n\n\tprivate String[] parameterNameBindings = new String[0];\n\n\tprivate int numberOfRemainingUnboundArguments;\n\n\n\t/**\n\t * Create a new discoverer that attempts to discover parameter names.\n\t * from the given pointcut expression.\n\t */\n\tpublic AspectJAdviceParameterNameDiscoverer(@Nullable String pointcutExpression) {\n\t\tthis.pointcutExpression = pointcutExpression;\n\t}\n\n\n\t/**\n\t * Indicate whether {@link IllegalArgumentException} and {@link AmbiguousBindingException}\n\t * must be thrown as appropriate in the case of failing to deduce advice parameter names.\n\t * @param raiseExceptions {@code true} if exceptions are to be thrown\n\t */\n\tpublic void setRaiseExceptions(boolean raiseExceptions) {\n\t\tthis.raiseExceptions = raiseExceptions;\n\t}\n\n\t/**\n\t * If {@code afterReturning} advice binds the return value, the\n\t * returning variable name must be specified.\n\t * @param returningName the name of the returning variable\n\t */\n\tpublic void setReturningName(@Nullable String returningName) {\n\t\tthis.returningName = returningName;\n\t}\n\n\t/**\n\t * If {@code afterThrowing} advice binds the thrown value, the\n\t * throwing variable name must be specified.\n\t * @param throwingName the name of the throwing variable\n\t */\n\tpublic void setThrowingName(@Nullable String throwingName) {\n\t\tthis.throwingName = throwingName;\n\t}\n\n\n\t/**\n\t * Deduce the parameter names for an advice method.\n\t * <p>See the {@link AspectJAdviceParameterNameDiscoverer class level javadoc}\n\t * for this class for details of the algorithm used.\n\t * @param method the target {@link Method}\n\t * @return the parameter names\n\t */\n\t@Override\n\t@Nullable\n\tpublic String[] getParameterNames(Method method) {\n\t\tthis.argumentTypes = method.getParameterTypes();\n\t\tthis.numberOfRemainingUnboundArguments = this.argumentTypes.length;\n\t\tthis.parameterNameBindings = new String[this.numberOfRemainingUnboundArguments];\n\n\t\tint minimumNumberUnboundArgs = 0;\n\t\tif (this.returningName != null) {\n\t\t\tminimumNumberUnboundArgs++;\n\t\t}\n\t\tif (this.throwingName != null) {\n\t\t\tminimumNumberUnboundArgs++;\n\t\t}\n\t\tif (this.numberOfRemainingUnboundArguments < minimumNumberUnboundArgs) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Not enough arguments in method to satisfy binding of returning and throwing variables\");\n\t\t}\n\n\t\ttry {\n\t\t\tint algorithmicStep = STEP_JOIN_POINT_BINDING;\n\t\t\twhile ((this.numberOfRemainingUnboundArguments > 0) && algorithmicStep < STEP_FINISHED) {\n\t\t\t\tswitch (algorithmicStep++) {\n\t\t\t\t\tcase STEP_JOIN_POINT_BINDING -> {\n\t\t\t\t\t\tif (!maybeBindThisJoinPoint()) {\n\t\t\t\t\t\t\tmaybeBindThisJoinPointStaticPart();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcase STEP_THROWING_BINDING -> maybeBindThrowingVariable();\n\t\t\t\t\tcase STEP_ANNOTATION_BINDING -> maybeBindAnnotationsFromPointcutExpression();\n\t\t\t\t\tcase STEP_RETURNING_BINDING -> maybeBindReturningVariable();\n\t\t\t\t\tcase STEP_PRIMITIVE_ARGS_BINDING -> maybeBindPrimitiveArgsFromPointcutExpression();\n\t\t\t\t\tcase STEP_THIS_TARGET_ARGS_BINDING -> maybeBindThisOrTargetOrArgsFromPointcutExpression();\n\t\t\t\t\tcase STEP_REFERENCE_PCUT_BINDING -> maybeBindReferencePointcutParameter();\n\t\t\t\t\tdefault -> throw new IllegalStateException(\"Unknown algorithmic step: \" + (algorithmicStep - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (AmbiguousBindingException | IllegalArgumentException ex) {\n\t\t\tif (this.raiseExceptions) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (this.numberOfRemainingUnboundArguments == 0) {\n\t\t\treturn this.parameterNameBindings;\n\t\t}\n\t\telse {\n\t\t\tif (this.raiseExceptions) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to bind all argument names: \" +\n\t\t\t\t\t\tthis.numberOfRemainingUnboundArguments + \" argument(s) could not be bound\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// convention for failing is to return null, allowing participation in a chain of responsibility\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * An advice method can never be a constructor in Spring.\n\t * @return {@code null}\n\t * @throws UnsupportedOperationException if\n\t * {@link #setRaiseExceptions(boolean) raiseExceptions} has been set to {@code true}\n\t */\n\t@Override\n\t@Nullable\n\tpublic String[] getParameterNames(Constructor<?> ctor) {\n\t\tif (this.raiseExceptions) {\n\t\t\tthrow new UnsupportedOperationException(\"An advice method can never be a constructor\");\n\t\t}\n\t\telse {\n\t\t\t// we return null rather than throw an exception so that we behave well\n\t\t\t// in a chain-of-responsibility.\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\tprivate void bindParameterName(int index, String name) {\n\t\tthis.parameterNameBindings[index] = name;\n\t\tthis.numberOfRemainingUnboundArguments--;\n\t}\n\n\t/**\n\t * If the first parameter is of type JoinPoint or ProceedingJoinPoint,bind \"thisJoinPoint\" as\n\t * parameter name and return true, else return false.\n\t */\n\tprivate boolean maybeBindThisJoinPoint() {\n\t\tif ((this.argumentTypes[0] == JoinPoint.class) || (this.argumentTypes[0] == ProceedingJoinPoint.class)) {\n\t\t\tbindParameterName(0, THIS_JOIN_POINT);\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate void maybeBindThisJoinPointStaticPart() {\n\t\tif (this.argumentTypes[0] == JoinPoint.StaticPart.class) {\n\t\t\tbindParameterName(0, THIS_JOIN_POINT_STATIC_PART);\n\t\t}\n\t}\n\n\t/**\n\t * If a throwing name was specified and there is exactly one choice remaining\n\t * (argument that is a subtype of Throwable) then bind it.\n\t */\n\tprivate void maybeBindThrowingVariable() {\n\t\tif (this.throwingName == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// So there is binding work to do...\n\t\tint throwableIndex = -1;\n\t\tfor (int i = 0; i < this.argumentTypes.length; i++) {\n\t\t\tif (isUnbound(i) && isSubtypeOf(Throwable.class, i)) {\n\t\t\t\tif (throwableIndex == -1) {\n\t\t\t\t\tthrowableIndex = i;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Second candidate we've found - ambiguous binding\n\t\t\t\t\tthrow new AmbiguousBindingException(\"Binding of throwing parameter '\" +\n\t\t\t\t\t\t\tthis.throwingName + \"' is ambiguous: could be bound to argument \" +\n\t\t\t\t\t\t\tthrowableIndex + \" or argument \" + i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (throwableIndex == -1) {\n\t\t\tthrow new IllegalStateException(\"Binding of throwing parameter '\" + this.throwingName\n\t\t\t\t\t+ \"' could not be completed as no available arguments are a subtype of Throwable\");\n\t\t}\n\t\telse {\n\t\t\tbindParameterName(throwableIndex, this.throwingName);\n\t\t}\n\t}\n\n\t/**\n\t * If a returning variable was specified and there is only one choice remaining, bind it.\n\t */\n\tprivate void maybeBindReturningVariable() {\n\t\tif (this.numberOfRemainingUnboundArguments == 0) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Algorithm assumes that there must be at least one unbound parameter on entry to this method\");\n\t\t}\n\n\t\tif (this.returningName != null) {\n\t\t\tif (this.numberOfRemainingUnboundArguments > 1) {\n\t\t\t\tthrow new AmbiguousBindingException(\"Binding of returning parameter '\" + this.returningName +\n\t\t\t\t\t\t\"' is ambiguous, there are \" + this.numberOfRemainingUnboundArguments + \" candidates.\");\n\t\t\t}\n\n\t\t\t// We're all set... find the unbound parameter, and bind it.\n\t\t\tfor (int i = 0; i < this.parameterNameBindings.length; i++) {\n\t\t\t\tif (this.parameterNameBindings[i] == null) {\n\t\t\t\t\tbindParameterName(i, this.returningName);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Parse the string pointcut expression looking for:\n\t * &#64;this, &#64;target, &#64;args, &#64;within, &#64;withincode, &#64;annotation.\n\t * If we find one of these pointcut expressions, try and extract a candidate variable\n\t * name (or variable names, in the case of args).\n\t * <p>Some more support from AspectJ in doing this exercise would be nice... :)\n\t */\n\tprivate void maybeBindAnnotationsFromPointcutExpression() {\n\t\tList<String> varNames = new ArrayList<>();\n\t\tString[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, \" \");\n\t\tfor (int i = 0; i < tokens.length; i++) {\n\t\t\tString toMatch = tokens[i];\n\t\t\tint firstParenIndex = toMatch.indexOf('(');\n\t\t\tif (firstParenIndex != -1) {\n\t\t\t\ttoMatch = toMatch.substring(0, firstParenIndex);\n\t\t\t}\n\t\t\tif (singleValuedAnnotationPcds.contains(toMatch)) {\n\t\t\t\tPointcutBody body = getPointcutBody(tokens, i);\n\t\t\t\ti += body.numTokensConsumed;\n\t\t\t\tString varName = maybeExtractVariableName(body.text);\n\t\t\t\tif (varName != null) {\n\t\t\t\t\tvarNames.add(varName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (tokens[i].startsWith(\"@args(\") || tokens[i].equals(\"@args\")) {\n\t\t\t\tPointcutBody body = getPointcutBody(tokens, i);\n\t\t\t\ti += body.numTokensConsumed;\n\t\t\t\tmaybeExtractVariableNamesFromArgs(body.text, varNames);\n\t\t\t}\n\t\t}\n\n\t\tbindAnnotationsFromVarNames(varNames);\n\t}\n\n\t/**\n\t * Match the given list of extracted variable names to argument slots.\n\t */\n\tprivate void bindAnnotationsFromVarNames(List<String> varNames) {\n\t\tif (!varNames.isEmpty()) {\n\t\t\t// we have work to do...\n\t\t\tint numAnnotationSlots = countNumberOfUnboundAnnotationArguments();\n\t\t\tif (numAnnotationSlots > 1) {\n\t\t\t\tthrow new AmbiguousBindingException(\"Found \" + varNames.size() +\n\t\t\t\t\t\t\" potential annotation variable(s), and \" +\n\t\t\t\t\t\tnumAnnotationSlots + \" potential argument slots\");\n\t\t\t}\n\t\t\telse if (numAnnotationSlots == 1) {\n\t\t\t\tif (varNames.size() == 1) {\n\t\t\t\t\t// it's a match\n\t\t\t\t\tfindAndBind(Annotation.class, varNames.get(0));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// multiple candidate vars, but only one slot\n\t\t\t\t\tthrow new IllegalArgumentException(\"Found \" + varNames.size() +\n\t\t\t\t\t\t\t\" candidate annotation binding variables\" +\n\t\t\t\t\t\t\t\" but only one potential argument binding slot\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// no slots so presume those candidate vars were actually type names\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If the token starts meets Java identifier conventions, it's in.\n\t */\n\t@Nullable\n\tprivate String maybeExtractVariableName(@Nullable String candidateToken) {\n\t\tif (AspectJProxyUtils.isVariableName(candidateToken)) {\n\t\t\treturn candidateToken;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Given an args pointcut body (could be {@code args} or {@code at_args}),\n\t * add any candidate variable names to the given list.\n\t */\n\tprivate void maybeExtractVariableNamesFromArgs(@Nullable String argsSpec, List<String> varNames) {\n\t\tif (argsSpec == null) {\n\t\t\treturn;\n\t\t}\n\t\tString[] tokens = StringUtils.tokenizeToStringArray(argsSpec, \",\");\n\t\tfor (int i = 0; i < tokens.length; i++) {\n\t\t\ttokens[i] = tokens[i].strip();\n\t\t\tString varName = maybeExtractVariableName(tokens[i]);\n\t\t\tif (varName != null) {\n\t\t\t\tvarNames.add(varName);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Parse the string pointcut expression looking for this(), target() and args() expressions.\n\t * If we find one, try and extract a candidate variable name and bind it.\n\t */\n\tprivate void maybeBindThisOrTargetOrArgsFromPointcutExpression() {\n\t\tif (this.numberOfRemainingUnboundArguments > 1) {\n\t\t\tthrow new AmbiguousBindingException(\"Still \" + this.numberOfRemainingUnboundArguments\n\t\t\t\t\t+ \" unbound args at this(),target(),args() binding stage, with no way to determine between them\");\n\t\t}\n\n\t\tList<String> varNames = new ArrayList<>();\n\t\tString[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, \" \");\n\t\tfor (int i = 0; i < tokens.length; i++) {\n\t\t\tif (tokens[i].equals(\"this\") ||\n\t\t\t\t\ttokens[i].startsWith(\"this(\") ||\n\t\t\t\t\ttokens[i].equals(\"target\") ||\n\t\t\t\t\ttokens[i].startsWith(\"target(\")) {\n\t\t\t\tPointcutBody body = getPointcutBody(tokens, i);\n\t\t\t\ti += body.numTokensConsumed;\n\t\t\t\tString varName = maybeExtractVariableName(body.text);\n\t\t\t\tif (varName != null) {\n\t\t\t\t\tvarNames.add(varName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (tokens[i].equals(\"args\") || tokens[i].startsWith(\"args(\")) {\n\t\t\t\tPointcutBody body = getPointcutBody(tokens, i);\n\t\t\t\ti += body.numTokensConsumed;\n\t\t\t\tList<String> candidateVarNames = new ArrayList<>();\n\t\t\t\tmaybeExtractVariableNamesFromArgs(body.text, candidateVarNames);\n\t\t\t\t// we may have found some var names that were bound in previous primitive args binding step,\n\t\t\t\t// filter them out...\n\t\t\t\tfor (String varName : candidateVarNames) {\n\t\t\t\t\tif (!alreadyBound(varName)) {\n\t\t\t\t\t\tvarNames.add(varName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tif (varNames.size() > 1) {\n\t\t\tthrow new AmbiguousBindingException(\"Found \" + varNames.size() +\n\t\t\t\t\t\" candidate this(), target() or args() variables but only one unbound argument slot\");\n\t\t}\n\t\telse if (varNames.size() == 1) {\n\t\t\tfor (int j = 0; j < this.parameterNameBindings.length; j++) {\n\t\t\t\tif (isUnbound(j)) {\n\t\t\t\t\tbindParameterName(j, varNames.get(0));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// else varNames.size must be 0 and we have nothing to bind.\n\t}\n\n\tprivate void maybeBindReferencePointcutParameter() {\n\t\tif (this.numberOfRemainingUnboundArguments > 1) {\n\t\t\tthrow new AmbiguousBindingException(\"Still \" + this.numberOfRemainingUnboundArguments\n\t\t\t\t\t+ \" unbound args at reference pointcut binding stage, with no way to determine between them\");\n\t\t}\n\n\t\tList<String> varNames = new ArrayList<>();\n\t\tString[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, \" \");\n\t\tfor (int i = 0; i < tokens.length; i++) {\n\t\t\tString toMatch = tokens[i];\n\t\t\tif (toMatch.startsWith(\"!\")) {\n\t\t\t\ttoMatch = toMatch.substring(1);\n\t\t\t}\n\t\t\tint firstParenIndex = toMatch.indexOf('(');\n\t\t\tif (firstParenIndex != -1) {\n\t\t\t\ttoMatch = toMatch.substring(0, firstParenIndex);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tokens.length < i + 2) {\n\t\t\t\t\t// no \"(\" and nothing following\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString nextToken = tokens[i + 1];\n\t\t\t\t\tif (nextToken.charAt(0) != '(') {\n\t\t\t\t\t\t// next token is not \"(\" either, can't be a pc...\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// eat the body\n\t\t\tPointcutBody body = getPointcutBody(tokens, i);\n\t\t\ti += body.numTokensConsumed;\n\n\t\t\tif (!nonReferencePointcutTokens.contains(toMatch)) {\n\t\t\t\t// then it could be a reference pointcut\n\t\t\t\tString varName = maybeExtractVariableName(body.text);\n\t\t\t\tif (varName != null) {\n\t\t\t\t\tvarNames.add(varName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (varNames.size() > 1) {\n\t\t\tthrow new AmbiguousBindingException(\"Found \" + varNames.size() +\n\t\t\t\t\t\" candidate reference pointcut variables but only one unbound argument slot\");\n\t\t}\n\t\telse if (varNames.size() == 1) {\n\t\t\tfor (int j = 0; j < this.parameterNameBindings.length; j++) {\n\t\t\t\tif (isUnbound(j)) {\n\t\t\t\t\tbindParameterName(j, varNames.get(0));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// else varNames.size must be 0 and we have nothing to bind.\n\t}\n\n\t/*\n\t * We've found the start of a binding pointcut at the given index into the\n\t * token array. Now we need to extract the pointcut body and return it.\n\t */\n\tprivate PointcutBody getPointcutBody(String[] tokens, int startIndex) {\n\t\tint numTokensConsumed = 0;\n\t\tString currentToken = tokens[startIndex];\n\t\tint bodyStart = currentToken.indexOf('(');\n\t\tif (currentToken.charAt(currentToken.length() - 1) == ')') {\n\t\t\t// It's an all in one... get the text between the first (and the last)\n\t\t\treturn new PointcutBody(0, currentToken.substring(bodyStart + 1, currentToken.length() - 1));\n\t\t}\n\t\telse {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (bodyStart >= 0 && bodyStart != (currentToken.length() - 1)) {\n\t\t\t\tsb.append(currentToken.substring(bodyStart + 1));\n\t\t\t\tsb.append(' ');\n\t\t\t}\n\t\t\tnumTokensConsumed++;\n\t\t\tint currentIndex = startIndex + numTokensConsumed;\n\t\t\twhile (currentIndex < tokens.length) {\n\t\t\t\tif (tokens[currentIndex].equals(\"(\")) {\n\t\t\t\t\tcurrentIndex++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (tokens[currentIndex].endsWith(\")\")) {\n\t\t\t\t\tsb.append(tokens[currentIndex], 0, tokens[currentIndex].length() - 1);\n\t\t\t\t\treturn new PointcutBody(numTokensConsumed, sb.toString().trim());\n\t\t\t\t}\n\n\t\t\t\tString toAppend = tokens[currentIndex];\n\t\t\t\tif (toAppend.startsWith(\"(\")) {\n\t\t\t\t\ttoAppend = toAppend.substring(1);\n\t\t\t\t}\n\t\t\t\tsb.append(toAppend);\n\t\t\t\tsb.append(' ');\n\t\t\t\tcurrentIndex++;\n\t\t\t\tnumTokensConsumed++;\n\t\t\t}\n\n\t\t}\n\n\t\t// We looked and failed...\n\t\treturn new PointcutBody(numTokensConsumed, null);\n\t}\n\n\t/**\n\t * Match up args against unbound arguments of primitive types.\n\t */\n\tprivate void maybeBindPrimitiveArgsFromPointcutExpression() {\n\t\tint numUnboundPrimitives = countNumberOfUnboundPrimitiveArguments();\n\t\tif (numUnboundPrimitives > 1) {\n\t\t\tthrow new AmbiguousBindingException(\"Found '\" + numUnboundPrimitives +\n\t\t\t\t\t\"' unbound primitive arguments with no way to distinguish between them.\");\n\t\t}\n\t\tif (numUnboundPrimitives == 1) {\n\t\t\t// Look for arg variable and bind it if we find exactly one...\n\t\t\tList<String> varNames = new ArrayList<>();\n\t\t\tString[] tokens = StringUtils.tokenizeToStringArray(this.pointcutExpression, \" \");\n\t\t\tfor (int i = 0; i < tokens.length; i++) {\n\t\t\t\tif (tokens[i].equals(\"args\") || tokens[i].startsWith(\"args(\")) {\n\t\t\t\t\tPointcutBody body = getPointcutBody(tokens, i);\n\t\t\t\t\ti += body.numTokensConsumed;\n\t\t\t\t\tmaybeExtractVariableNamesFromArgs(body.text, varNames);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (varNames.size() > 1) {\n\t\t\t\tthrow new AmbiguousBindingException(\"Found \" + varNames.size() +\n\t\t\t\t\t\t\" candidate variable names but only one candidate binding slot when matching primitive args\");\n\t\t\t}\n\t\t\telse if (varNames.size() == 1) {\n\t\t\t\t// 1 primitive arg, and one candidate...\n\t\t\t\tfor (int i = 0; i < this.argumentTypes.length; i++) {\n\t\t\t\t\tif (isUnbound(i) && this.argumentTypes[i].isPrimitive()) {\n\t\t\t\t\t\tbindParameterName(i, varNames.get(0));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Return true if the parameter name binding for the given parameter\n\t * index has not yet been assigned.\n\t */\n\tprivate boolean isUnbound(int i) {\n\t\treturn this.parameterNameBindings[i] == null;\n\t}\n\n\tprivate boolean alreadyBound(String varName) {\n\t\tfor (int i = 0; i < this.parameterNameBindings.length; i++) {\n\t\t\tif (!isUnbound(i) && varName.equals(this.parameterNameBindings[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/*\n\t * Return {@code true} if the given argument type is a subclass\n\t * of the given supertype.\n\t */\n\tprivate boolean isSubtypeOf(Class<?> supertype, int argumentNumber) {\n\t\treturn supertype.isAssignableFrom(this.argumentTypes[argumentNumber]);\n\t}\n\n\tprivate int countNumberOfUnboundAnnotationArguments() {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < this.argumentTypes.length; i++) {\n\t\t\tif (isUnbound(i) && isSubtypeOf(Annotation.class, i)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tprivate int countNumberOfUnboundPrimitiveArguments() {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < this.argumentTypes.length; i++) {\n\t\t\tif (isUnbound(i) && this.argumentTypes[i].isPrimitive()) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\t/*\n\t * Find the argument index with the given type, and bind the given\n\t * {@code varName} in that position.\n\t */\n\tprivate void findAndBind(Class<?> argumentType, String varName) {\n\t\tfor (int i = 0; i < this.argumentTypes.length; i++) {\n\t\t\tif (isUnbound(i) && isSubtypeOf(argumentType, i)) {\n\t\t\t\tbindParameterName(i, varName);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalStateException(\"Expected to find an unbound argument of type '\" +\n\t\t\t\targumentType.getName() + \"'\");\n\t}\n\n\n\t/**\n\t * Simple struct to hold the extracted text from a pointcut body, together\n\t * with the number of tokens consumed in extracting it.\n\t */\n\tprivate static class PointcutBody {\n\n\t\tprivate final int numTokensConsumed;\n\n\t\t@Nullable\n\t\tprivate final String text;\n\n\t\tpublic PointcutBody(int tokens, @Nullable String text) {\n\t\t\tthis.numTokensConsumed = tokens;\n\t\t\tthis.text = text;\n\t\t}\n\t}\n\n\n\t/**\n\t * Thrown in response to an ambiguous binding being detected when\n\t * trying to resolve a method's parameter names.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tpublic static class AmbiguousBindingException extends RuntimeException {\n\n\t\t/**\n\t\t * Construct a new AmbiguousBindingException with the specified message.\n\t\t * @param msg the detail message\n\t\t */\n\t\tpublic AmbiguousBindingException(String msg) {\n\t\t\tsuper(msg);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer#getParameterNames(ctor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An advice method can never be a constructor in Spring.\n\t * @return {@code null}\n\t * @throws UnsupportedOperationException if\n\t * {@link #setRaiseExceptions(boolean) raiseExceptions} has been set to {@code true}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ctor"
    ],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "String[]",
    "signature": "public String[] getParameterNames(Constructor<?> ctor)",
    "source_code": "\tpublic String[] getParameterNames(Constructor<?> ctor) {\n\t\tif (this.raiseExceptions) {\n\t\t\tthrow new UnsupportedOperationException(\"An advice method can never be a constructor\");\n\t\t}\n\t\telse {\n\t\t\t// we return null rather than throw an exception so that we behave well\n\t\t\t// in a chain-of-responsibility.\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer#getParameterNames(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Deduce the parameter names for an advice method.\n\t * <p>See the {@link AspectJAdviceParameterNameDiscoverer class level javadoc}\n\t * for this class for details of the algorithm used.\n\t * @param method the target {@link Method}\n\t * @return the parameter names\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "String[]",
    "signature": "public String[] getParameterNames(Method method)",
    "source_code": "\tpublic String[] getParameterNames(Method method) {\n\t\tthis.argumentTypes = method.getParameterTypes();\n\t\tthis.numberOfRemainingUnboundArguments = this.argumentTypes.length;\n\t\tthis.parameterNameBindings = new String[this.numberOfRemainingUnboundArguments];\n\n\t\tint minimumNumberUnboundArgs = 0;\n\t\tif (this.returningName != null) {\n\t\t\tminimumNumberUnboundArgs++;\n\t\t}\n\t\tif (this.throwingName != null) {\n\t\t\tminimumNumberUnboundArgs++;\n\t\t}\n\t\tif (this.numberOfRemainingUnboundArguments < minimumNumberUnboundArgs) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Not enough arguments in method to satisfy binding of returning and throwing variables\");\n\t\t}\n\n\t\ttry {\n\t\t\tint algorithmicStep = STEP_JOIN_POINT_BINDING;\n\t\t\twhile ((this.numberOfRemainingUnboundArguments > 0) && algorithmicStep < STEP_FINISHED) {\n\t\t\t\tswitch (algorithmicStep++) {\n\t\t\t\t\tcase STEP_JOIN_POINT_BINDING -> {\n\t\t\t\t\t\tif (!maybeBindThisJoinPoint()) {\n\t\t\t\t\t\t\tmaybeBindThisJoinPointStaticPart();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcase STEP_THROWING_BINDING -> maybeBindThrowingVariable();\n\t\t\t\t\tcase STEP_ANNOTATION_BINDING -> maybeBindAnnotationsFromPointcutExpression();\n\t\t\t\t\tcase STEP_RETURNING_BINDING -> maybeBindReturningVariable();\n\t\t\t\t\tcase STEP_PRIMITIVE_ARGS_BINDING -> maybeBindPrimitiveArgsFromPointcutExpression();\n\t\t\t\t\tcase STEP_THIS_TARGET_ARGS_BINDING -> maybeBindThisOrTargetOrArgsFromPointcutExpression();\n\t\t\t\t\tcase STEP_REFERENCE_PCUT_BINDING -> maybeBindReferencePointcutParameter();\n\t\t\t\t\tdefault -> throw new IllegalStateException(\"Unknown algorithmic step: \" + (algorithmicStep - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (AmbiguousBindingException | IllegalArgumentException ex) {\n\t\t\tif (this.raiseExceptions) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (this.numberOfRemainingUnboundArguments == 0) {\n\t\t\treturn this.parameterNameBindings;\n\t\t}\n\t\telse {\n\t\t\tif (this.raiseExceptions) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to bind all argument names: \" +\n\t\t\t\t\t\tthis.numberOfRemainingUnboundArguments + \" argument(s) could not be bound\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// convention for failing is to return null, allowing participation in a chain of responsibility\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer#setRaiseExceptions(raiseExceptions)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicate whether {@link IllegalArgumentException} and {@link AmbiguousBindingException}\n\t * must be thrown as appropriate in the case of failing to deduce advice parameter names.\n\t * @param raiseExceptions {@code true} if exceptions are to be thrown\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "raiseExceptions"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "void",
    "signature": "public void setRaiseExceptions(boolean raiseExceptions)",
    "source_code": "\tpublic void setRaiseExceptions(boolean raiseExceptions) {\n\t\tthis.raiseExceptions = raiseExceptions;\n\t}"
  },
  "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer#setReturningName(returningName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * If {@code afterReturning} advice binds the return value, the\n\t * returning variable name must be specified.\n\t * @param returningName the name of the returning variable\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returningName"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void setReturningName(@Nullable String returningName)",
    "source_code": "\tpublic void setReturningName(@Nullable String returningName) {\n\t\tthis.returningName = returningName;\n\t}"
  },
  "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer#setThrowingName(throwingName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * If {@code afterThrowing} advice binds the thrown value, the\n\t * throwing variable name must be specified.\n\t * @param throwingName the name of the throwing variable\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "throwingName"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "void",
    "signature": "public void setThrowingName(@Nullable String throwingName)",
    "source_code": "\tpublic void setThrowingName(@Nullable String throwingName) {\n\t\tthis.throwingName = throwingName;\n\t}"
  },
  "org.springframework.beans.<unknown>#convertIfNecessary(propertyName,oldValue,newValue,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the value to the required type for the specified property.\n\t * @param propertyName name of the property\n\t * @param oldValue the previous value, if available (may be {@code null})\n\t * @param newValue the proposed new value\n\t * @param requiredType the type we must convert to\n\t * (or {@code null} if not known, for example in case of a collection element)\n\t * @return the new value, possibly the result of type conversion\n\t * @throws IllegalArgumentException if type conversion failed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "oldValue",
      "newValue",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue,\n\t\t\tObject newValue, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue,"
  },
  "org.springframework.beans.<unknown>#convertIfNecessary(propertyName,oldValue,newValue,requiredType,typeDescriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the value to the required type (if necessary from a String),\n\t * for the specified property.\n\t * @param propertyName name of the property\n\t * @param oldValue the previous value, if available (may be {@code null})\n\t * @param newValue the proposed new value\n\t * @param requiredType the type we must convert to\n\t * (or {@code null} if not known, for example in case of a collection element)\n\t * @param typeDescriptor the descriptor for the target property or field\n\t * @return the new value, possibly the result of type conversion\n\t * @throws IllegalArgumentException if type conversion failed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "oldValue",
      "newValue",
      "requiredType",
      "typeDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,\n\t\t\t@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,"
  },
  "org.springframework.beans.<unknown>#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object obj) {\n\t\t\treturn (this == obj || (obj instanceof PropertyDescriptor that &&\n\t\t\t\t\tPropertyDescriptorUtils.equals(this, that)));\n\t\t}"
  },
  "org.springframework.beans.MutablePropertyValues#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof MutablePropertyValues that &&\n\t\t\t\tthis.propertyValueList.equals(that.propertyValueList)));\n\t}"
  },
  "org.springframework.beans.MutablePropertyValues#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof MutablePropertyValues &&\n\t\t\t\tthis.propertyValueList.equals(((MutablePropertyValues) other).propertyValueList)));\n\t}"
  },
  "org.springframework.beans.factory.BeanCreationException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Exception thrown when a BeanFactory encounters an error when\n * attempting to create a bean from a bean definition.\n *\n * @author Juergen Hoeller\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class BeanCreationException",
    "source_code": "public class BeanCreationException extends FatalBeanException {\n\n\t@Nullable\n\tprivate final String beanName;\n\n\t@Nullable\n\tprivate final String resourceDescription;\n\n\t@Nullable\n\tprivate List<Throwable> relatedCauses;\n\n\n\t/**\n\t * Create a new BeanCreationException.\n\t * @param msg the detail message\n\t */\n\tpublic BeanCreationException(String msg) {\n\t\tsuper(msg);\n\t\tthis.beanName = null;\n\t\tthis.resourceDescription = null;\n\t}\n\n\t/**\n\t * Create a new BeanCreationException.\n\t * @param msg the detail message\n\t * @param cause the root cause\n\t */\n\tpublic BeanCreationException(String msg, Throwable cause) {\n\t\tsuper(msg, cause);\n\t\tthis.beanName = null;\n\t\tthis.resourceDescription = null;\n\t}\n\n\t/**\n\t * Create a new BeanCreationException.\n\t * @param beanName the name of the bean requested\n\t * @param msg the detail message\n\t */\n\tpublic BeanCreationException(String beanName, String msg) {\n\t\tsuper(\"Error creating bean with name '\" + beanName + \"': \" + msg);\n\t\tthis.beanName = beanName;\n\t\tthis.resourceDescription = null;\n\t}\n\n\t/**\n\t * Create a new BeanCreationException.\n\t * @param beanName the name of the bean requested\n\t * @param msg the detail message\n\t * @param cause the root cause\n\t */\n\tpublic BeanCreationException(String beanName, String msg, Throwable cause) {\n\t\tthis(beanName, msg);\n\t\tinitCause(cause);\n\t}\n\n\t/**\n\t * Create a new BeanCreationException.\n\t * @param resourceDescription description of the resource\n\t * that the bean definition came from\n\t * @param beanName the name of the bean requested\n\t * @param msg the detail message\n\t */\n\tpublic BeanCreationException(@Nullable String resourceDescription, @Nullable String beanName, String msg) {\n\t\tsuper(\"Error creating bean with name '\" + beanName + \"'\" +\n\t\t\t\t(resourceDescription != null ? \" defined in \" + resourceDescription : \"\") + \": \" + msg);\n\t\tthis.resourceDescription = resourceDescription;\n\t\tthis.beanName = beanName;\n\t\tthis.relatedCauses = null;\n\t}\n\n\t/**\n\t * Create a new BeanCreationException.\n\t * @param resourceDescription description of the resource\n\t * that the bean definition came from\n\t * @param beanName the name of the bean requested\n\t * @param msg the detail message\n\t * @param cause the root cause\n\t */\n\tpublic BeanCreationException(@Nullable String resourceDescription, String beanName, String msg, Throwable cause) {\n\t\tthis(resourceDescription, beanName, msg);\n\t\tinitCause(cause);\n\t}\n\n\n\t/**\n\t * Return the description of the resource that the bean\n\t * definition came from, if any.\n\t */\n\t@Nullable\n\tpublic String getResourceDescription() {\n\t\treturn this.resourceDescription;\n\t}\n\n\t/**\n\t * Return the name of the bean requested, if any.\n\t */\n\t@Nullable\n\tpublic String getBeanName() {\n\t\treturn this.beanName;\n\t}\n\n\t/**\n\t * Add a related cause to this bean creation exception,\n\t * not being a direct cause of the failure but having occurred\n\t * earlier in the creation of the same bean instance.\n\t * @param ex the related cause to add\n\t */\n\tpublic void addRelatedCause(Throwable ex) {\n\t\tif (this.relatedCauses == null) {\n\t\t\tthis.relatedCauses = new ArrayList<>();\n\t\t}\n\t\tthis.relatedCauses.add(ex);\n\t}\n\n\t/**\n\t * Return the related causes, if any.\n\t * @return the array of related causes, or {@code null} if none\n\t */\n\t@Nullable\n\tpublic Throwable[] getRelatedCauses() {\n\t\tif (this.relatedCauses == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.relatedCauses.toArray(new Throwable[0]);\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(super.toString());\n\t\tif (this.relatedCauses != null) {\n\t\t\tfor (Throwable relatedCause : this.relatedCauses) {\n\t\t\t\tsb.append(\"\\nRelated cause: \");\n\t\t\t\tsb.append(relatedCause);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t@Override\n\tpublic void printStackTrace(PrintStream ps) {\n\t\tsynchronized (ps) {\n\t\t\tsuper.printStackTrace(ps);\n\t\t\tif (this.relatedCauses != null) {\n\t\t\t\tfor (Throwable relatedCause : this.relatedCauses) {\n\t\t\t\t\tps.println(\"Related cause:\");\n\t\t\t\t\trelatedCause.printStackTrace(ps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void printStackTrace(PrintWriter pw) {\n\t\tsynchronized (pw) {\n\t\t\tsuper.printStackTrace(pw);\n\t\t\tif (this.relatedCauses != null) {\n\t\t\t\tfor (Throwable relatedCause : this.relatedCauses) {\n\t\t\t\t\tpw.println(\"Related cause:\");\n\t\t\t\t\trelatedCause.printStackTrace(pw);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean contains(@Nullable Class<?> exClass) {\n\t\tif (super.contains(exClass)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this.relatedCauses != null) {\n\t\t\tfor (Throwable relatedCause : this.relatedCauses) {\n\t\t\t\tif (relatedCause instanceof NestedRuntimeException nested && nested.contains(exClass)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}"
  },
  "org.springframework.beans.factory.BeanCreationException#addRelatedCause(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a related cause to this bean creation exception,\n\t * not being a direct cause of the failure but having occurred\n\t * earlier in the creation of the same bean instance.\n\t * @param ex the related cause to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "void",
    "signature": "public void addRelatedCause(Throwable ex)",
    "source_code": "\tpublic void addRelatedCause(Throwable ex) {\n\t\tif (this.relatedCauses == null) {\n\t\t\tthis.relatedCauses = new ArrayList<>();\n\t\t}\n\t\tthis.relatedCauses.add(ex);\n\t}"
  },
  "org.springframework.beans.factory.BeanCreationException#contains(exClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exClass"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "boolean",
    "signature": "public boolean contains(@Nullable Class<?> exClass)",
    "source_code": "\tpublic boolean contains(@Nullable Class<?> exClass) {\n\t\tif (super.contains(exClass)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this.relatedCauses != null) {\n\t\t\tfor (Throwable relatedCause : this.relatedCauses) {\n\t\t\t\tif (relatedCause instanceof NestedRuntimeException nested && nested.contains(exClass)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.beans.factory.BeanCreationException#getBeanName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the bean requested, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "String",
    "signature": "public String getBeanName()",
    "source_code": "\tpublic String getBeanName() {\n\t\treturn this.beanName;\n\t}"
  },
  "org.springframework.beans.factory.BeanCreationException#getRelatedCauses()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the related causes, if any.\n\t * @return the array of related causes, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "Throwable[]",
    "signature": "public Throwable[] getRelatedCauses()",
    "source_code": "\tpublic Throwable[] getRelatedCauses() {\n\t\tif (this.relatedCauses == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.relatedCauses.toArray(new Throwable[0]);\n\t}"
  },
  "org.springframework.beans.factory.BeanCreationException#getResourceDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the description of the resource that the bean\n\t * definition came from, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "String",
    "signature": "public String getResourceDescription()",
    "source_code": "\tpublic String getResourceDescription() {\n\t\treturn this.resourceDescription;\n\t}"
  },
  "org.springframework.beans.factory.BeanCreationException#printStackTrace(ps)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "void",
    "signature": "public void printStackTrace(PrintStream ps)",
    "source_code": "\tpublic void printStackTrace(PrintStream ps) {\n\t\tsynchronized (ps) {\n\t\t\tsuper.printStackTrace(ps);\n\t\t\tif (this.relatedCauses != null) {\n\t\t\t\tfor (Throwable relatedCause : this.relatedCauses) {\n\t\t\t\t\tps.println(\"Related cause:\");\n\t\t\t\t\trelatedCause.printStackTrace(ps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.BeanCreationException#printStackTrace(pw)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pw"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "void",
    "signature": "public void printStackTrace(PrintWriter pw)",
    "source_code": "\tpublic void printStackTrace(PrintWriter pw) {\n\t\tsynchronized (pw) {\n\t\t\tsuper.printStackTrace(pw);\n\t\t\tif (this.relatedCauses != null) {\n\t\t\t\tfor (Throwable relatedCause : this.relatedCauses) {\n\t\t\t\t\tpw.println(\"Related cause:\");\n\t\t\t\t\trelatedCause.printStackTrace(pw);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.BeanCreationException#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(super.toString());\n\t\tif (this.relatedCauses != null) {\n\t\t\tfor (Throwable relatedCause : this.relatedCauses) {\n\t\t\t\tsb.append(\"\\nRelated cause: \");\n\t\t\t\tsb.append(relatedCause);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link AutowireCandidateResolver} implementation that matches bean definition qualifiers\n * against {@link Qualifier qualifier annotations} on the field or parameter to be autowired.\n * Also supports suggested expression values through a {@link Value value} annotation.\n *\n * <p>Also supports JSR-330's {@link jakarta.inject.Qualifier} annotation, if available.\n *\n * @author Mark Fisher\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @since 2.5\n * @see AutowireCandidateQualifier\n * @see Qualifier\n * @see Value\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "signature": "public class QualifierAnnotationAutowireCandidateResolver",
    "source_code": "public class QualifierAnnotationAutowireCandidateResolver extends GenericTypeAwareAutowireCandidateResolver {\n\n\tprivate final Set<Class<? extends Annotation>> qualifierTypes = new LinkedHashSet<>(2);\n\n\tprivate Class<? extends Annotation> valueAnnotationType = Value.class;\n\n\n\t/**\n\t * Create a new QualifierAnnotationAutowireCandidateResolver\n\t * for Spring's standard {@link Qualifier} annotation.\n\t * <p>Also supports JSR-330's {@link jakarta.inject.Qualifier} annotation, if available.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic QualifierAnnotationAutowireCandidateResolver() {\n\t\tthis.qualifierTypes.add(Qualifier.class);\n\t\ttry {\n\t\t\tthis.qualifierTypes.add((Class<? extends Annotation>) ClassUtils.forName(\"jakarta.inject.Qualifier\",\n\t\t\t\t\t\t\tQualifierAnnotationAutowireCandidateResolver.class.getClassLoader()));\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t// JSR-330 API not available - simply skip.\n\t\t}\n\t}\n\n\t/**\n\t * Create a new QualifierAnnotationAutowireCandidateResolver\n\t * for the given qualifier annotation type.\n\t * @param qualifierType the qualifier annotation to look for\n\t */\n\tpublic QualifierAnnotationAutowireCandidateResolver(Class<? extends Annotation> qualifierType) {\n\t\tAssert.notNull(qualifierType, \"'qualifierType' must not be null\");\n\t\tthis.qualifierTypes.add(qualifierType);\n\t}\n\n\t/**\n\t * Create a new QualifierAnnotationAutowireCandidateResolver\n\t * for the given qualifier annotation types.\n\t * @param qualifierTypes the qualifier annotations to look for\n\t */\n\tpublic QualifierAnnotationAutowireCandidateResolver(Set<Class<? extends Annotation>> qualifierTypes) {\n\t\tAssert.notNull(qualifierTypes, \"'qualifierTypes' must not be null\");\n\t\tthis.qualifierTypes.addAll(qualifierTypes);\n\t}\n\n\n\t/**\n\t * Register the given type to be used as a qualifier when autowiring.\n\t * <p>This identifies qualifier annotations for direct use (on fields,\n\t * method parameters and constructor parameters) as well as meta\n\t * annotations that in turn identify actual qualifier annotations.\n\t * <p>This implementation only supports annotations as qualifier types.\n\t * The default is Spring's {@link Qualifier} annotation which serves\n\t * as a qualifier for direct use and also as a meta annotation.\n\t * @param qualifierType the annotation type to register\n\t */\n\tpublic void addQualifierType(Class<? extends Annotation> qualifierType) {\n\t\tthis.qualifierTypes.add(qualifierType);\n\t}\n\n\t/**\n\t * Set the 'value' annotation type, to be used on fields, method parameters\n\t * and constructor parameters.\n\t * <p>The default value annotation type is the Spring-provided\n\t * {@link Value} annotation.\n\t * <p>This setter property exists so that developers can provide their own\n\t * (non-Spring-specific) annotation type to indicate a default value\n\t * expression for a specific argument.\n\t */\n\tpublic void setValueAnnotationType(Class<? extends Annotation> valueAnnotationType) {\n\t\tthis.valueAnnotationType = valueAnnotationType;\n\t}\n\n\n\t/**\n\t * Determine whether the provided bean definition is an autowire candidate.\n\t * <p>To be considered a candidate the bean's <em>autowire-candidate</em>\n\t * attribute must not have been set to 'false'. Also, if an annotation on\n\t * the field or parameter to be autowired is recognized by this bean factory\n\t * as a <em>qualifier</em>, the bean must 'match' against the annotation as\n\t * well as any attributes it may contain. The bean definition must contain\n\t * the same qualifier or match by meta attributes. A \"value\" attribute will\n\t * fall back to match against the bean name or an alias if a qualifier or\n\t * attribute does not match.\n\t * @see Qualifier\n\t */\n\t@Override\n\tpublic boolean isAutowireCandidate(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor) {\n\t\tboolean match = super.isAutowireCandidate(bdHolder, descriptor);\n\t\tif (match) {\n\t\t\tmatch = checkQualifiers(bdHolder, descriptor.getAnnotations());\n\t\t\tif (match) {\n\t\t\t\tMethodParameter methodParam = descriptor.getMethodParameter();\n\t\t\t\tif (methodParam != null) {\n\t\t\t\t\tMethod method = methodParam.getMethod();\n\t\t\t\t\tif (method == null || void.class == method.getReturnType()) {\n\t\t\t\t\t\tmatch = checkQualifiers(bdHolder, methodParam.getMethodAnnotations());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn match;\n\t}\n\n\t/**\n\t * Match the given qualifier annotations against the candidate bean definition.\n\t */\n\tprotected boolean checkQualifiers(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch) {\n\t\tif (ObjectUtils.isEmpty(annotationsToSearch)) {\n\t\t\treturn true;\n\t\t}\n\t\tSimpleTypeConverter typeConverter = new SimpleTypeConverter();\n\t\tfor (Annotation annotation : annotationsToSearch) {\n\t\t\tClass<? extends Annotation> type = annotation.annotationType();\n\t\t\tboolean checkMeta = true;\n\t\t\tboolean fallbackToMeta = false;\n\t\t\tif (isQualifier(type)) {\n\t\t\t\tif (!checkQualifier(bdHolder, annotation, typeConverter)) {\n\t\t\t\t\tfallbackToMeta = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcheckMeta = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (checkMeta) {\n\t\t\t\tboolean foundMeta = false;\n\t\t\t\tfor (Annotation metaAnn : type.getAnnotations()) {\n\t\t\t\t\tClass<? extends Annotation> metaType = metaAnn.annotationType();\n\t\t\t\t\tif (isQualifier(metaType)) {\n\t\t\t\t\t\tfoundMeta = true;\n\t\t\t\t\t\t// Only accept fallback match if @Qualifier annotation has a value...\n\t\t\t\t\t\t// Otherwise, it is just a marker for a custom qualifier annotation.\n\t\t\t\t\t\tif ((fallbackToMeta && ObjectUtils.isEmpty(AnnotationUtils.getValue(metaAnn))) ||\n\t\t\t\t\t\t\t\t!checkQualifier(bdHolder, metaAnn, typeConverter)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (fallbackToMeta && !foundMeta) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks whether the given annotation type is a recognized qualifier type.\n\t */\n\tprotected boolean isQualifier(Class<? extends Annotation> annotationType) {\n\t\tfor (Class<? extends Annotation> qualifierType : this.qualifierTypes) {\n\t\t\tif (annotationType.equals(qualifierType) || annotationType.isAnnotationPresent(qualifierType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Match the given qualifier annotation against the candidate bean definition.\n\t */\n\tprotected boolean checkQualifier(\n\t\t\tBeanDefinitionHolder bdHolder, Annotation annotation, TypeConverter typeConverter) {\n\n\t\tClass<? extends Annotation> type = annotation.annotationType();\n\t\tRootBeanDefinition bd = (RootBeanDefinition) bdHolder.getBeanDefinition();\n\n\t\tAutowireCandidateQualifier qualifier = bd.getQualifier(type.getName());\n\t\tif (qualifier == null) {\n\t\t\tqualifier = bd.getQualifier(ClassUtils.getShortName(type));\n\t\t}\n\t\tif (qualifier == null) {\n\t\t\t// First, check annotation on qualified element, if any\n\t\t\tAnnotation targetAnnotation = getQualifiedElementAnnotation(bd, type);\n\t\t\t// Then, check annotation on factory method, if applicable\n\t\t\tif (targetAnnotation == null) {\n\t\t\t\ttargetAnnotation = getFactoryMethodAnnotation(bd, type);\n\t\t\t}\n\t\t\tif (targetAnnotation == null) {\n\t\t\t\tRootBeanDefinition dbd = getResolvedDecoratedDefinition(bd);\n\t\t\t\tif (dbd != null) {\n\t\t\t\t\ttargetAnnotation = getFactoryMethodAnnotation(dbd, type);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (targetAnnotation == null) {\n\t\t\t\t// Look for matching annotation on the target class\n\t\t\t\tif (getBeanFactory() != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tClass<?> beanType = getBeanFactory().getType(bdHolder.getBeanName());\n\t\t\t\t\t\tif (beanType != null) {\n\t\t\t\t\t\t\ttargetAnnotation = AnnotationUtils.getAnnotation(ClassUtils.getUserClass(beanType), type);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t\t// Not the usual case - simply forget about the type check...\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (targetAnnotation == null && bd.hasBeanClass()) {\n\t\t\t\t\ttargetAnnotation = AnnotationUtils.getAnnotation(ClassUtils.getUserClass(bd.getBeanClass()), type);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (targetAnnotation != null && targetAnnotation.equals(annotation)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tMap<String, Object> attributes = AnnotationUtils.getAnnotationAttributes(annotation);\n\t\tif (attributes.isEmpty() && qualifier == null) {\n\t\t\t// If no attributes, the qualifier must be present\n\t\t\treturn false;\n\t\t}\n\t\tfor (Map.Entry<String, Object> entry : attributes.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\t\t\tObject expectedValue = entry.getValue();\n\t\t\tObject actualValue = null;\n\t\t\t// Check qualifier first\n\t\t\tif (qualifier != null) {\n\t\t\t\tactualValue = qualifier.getAttribute(attributeName);\n\t\t\t}\n\t\t\tif (actualValue == null) {\n\t\t\t\t// Fall back on bean definition attribute\n\t\t\t\tactualValue = bd.getAttribute(attributeName);\n\t\t\t}\n\t\t\tif (actualValue == null && attributeName.equals(AutowireCandidateQualifier.VALUE_KEY) &&\n\t\t\t\t\texpectedValue instanceof String name && bdHolder.matchesName(name)) {\n\t\t\t\t// Fall back on bean name (or alias) match\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (actualValue == null && qualifier != null) {\n\t\t\t\t// Fall back on default, but only if the qualifier is present\n\t\t\t\tactualValue = AnnotationUtils.getDefaultValue(annotation, attributeName);\n\t\t\t}\n\t\t\tif (actualValue != null) {\n\t\t\t\tactualValue = typeConverter.convertIfNecessary(actualValue, expectedValue.getClass());\n\t\t\t}\n\t\t\tif (!expectedValue.equals(actualValue)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Nullable\n\tprotected Annotation getQualifiedElementAnnotation(RootBeanDefinition bd, Class<? extends Annotation> type) {\n\t\tAnnotatedElement qualifiedElement = bd.getQualifiedElement();\n\t\treturn (qualifiedElement != null ? AnnotationUtils.getAnnotation(qualifiedElement, type) : null);\n\t}\n\n\t@Nullable\n\tprotected Annotation getFactoryMethodAnnotation(RootBeanDefinition bd, Class<? extends Annotation> type) {\n\t\tMethod resolvedFactoryMethod = bd.getResolvedFactoryMethod();\n\t\treturn (resolvedFactoryMethod != null ? AnnotationUtils.getAnnotation(resolvedFactoryMethod, type) : null);\n\t}\n\n\n\t/**\n\t * Determine whether the given dependency declares an autowired annotation,\n\t * checking its required flag.\n\t * @see Autowired#required()\n\t */\n\t@Override\n\tpublic boolean isRequired(DependencyDescriptor descriptor) {\n\t\tif (!super.isRequired(descriptor)) {\n\t\t\treturn false;\n\t\t}\n\t\tAutowired autowired = descriptor.getAnnotation(Autowired.class);\n\t\treturn (autowired == null || autowired.required());\n\t}\n\n\t/**\n\t * Determine whether the given dependency declares a qualifier annotation.\n\t * @see #isQualifier(Class)\n\t * @see Qualifier\n\t */\n\t@Override\n\tpublic boolean hasQualifier(DependencyDescriptor descriptor) {\n\t\tfor (Annotation ann : descriptor.getAnnotations()) {\n\t\t\tif (isQualifier(ann.annotationType())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine whether the given dependency declares a value annotation.\n\t * @see Value\n\t */\n\t@Override\n\t@Nullable\n\tpublic Object getSuggestedValue(DependencyDescriptor descriptor) {\n\t\tObject value = findValue(descriptor.getAnnotations());\n\t\tif (value == null) {\n\t\t\tMethodParameter methodParam = descriptor.getMethodParameter();\n\t\t\tif (methodParam != null) {\n\t\t\t\tvalue = findValue(methodParam.getMethodAnnotations());\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Determine a suggested value from any of the given candidate annotations.\n\t */\n\t@Nullable\n\tprotected Object findValue(Annotation[] annotationsToSearch) {\n\t\tif (annotationsToSearch.length > 0) {   // qualifier annotations have to be local\n\t\t\tAnnotationAttributes attr = AnnotatedElementUtils.getMergedAnnotationAttributes(\n\t\t\t\t\tAnnotatedElementUtils.forAnnotations(annotationsToSearch), this.valueAnnotationType);\n\t\t\tif (attr != null) {\n\t\t\t\treturn extractValue(attr);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Extract the value attribute from the given annotation.\n\t * @since 4.3\n\t */\n\tprotected Object extractValue(AnnotationAttributes attr) {\n\t\tObject value = attr.get(AnnotationUtils.VALUE);\n\t\tif (value == null) {\n\t\t\tthrow new IllegalStateException(\"Value annotation must have a value attribute\");\n\t\t}\n\t\treturn value;\n\t}\n\n}"
  },
  "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#addQualifierType(qualifierType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given type to be used as a qualifier when autowiring.\n\t * <p>This identifies qualifier annotations for direct use (on fields,\n\t * method parameters and constructor parameters) as well as meta\n\t * annotations that in turn identify actual qualifier annotations.\n\t * <p>This implementation only supports annotations as qualifier types.\n\t * The default is Spring's {@link Qualifier} annotation which serves\n\t * as a qualifier for direct use and also as a meta annotation.\n\t * @param qualifierType the annotation type to register\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "qualifierType"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "void",
    "signature": "public void addQualifierType(Class<? extends Annotation> qualifierType)",
    "source_code": "\tpublic void addQualifierType(Class<? extends Annotation> qualifierType) {\n\t\tthis.qualifierTypes.add(qualifierType);\n\t}"
  },
  "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#checkQualifier(bdHolder,annotation,typeConverter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Match the given qualifier annotation against the candidate bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bdHolder",
      "annotation",
      "typeConverter"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "boolean",
    "signature": "protected boolean checkQualifier(BeanDefinitionHolder bdHolder, Annotation annotation, TypeConverter typeConverter)",
    "source_code": "\tprotected boolean checkQualifier("
  },
  "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#checkQualifiers(bdHolder,annotationsToSearch)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Match the given qualifier annotations against the candidate bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bdHolder",
      "annotationsToSearch"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "boolean",
    "signature": "protected boolean checkQualifiers(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch)",
    "source_code": "\tprotected boolean checkQualifiers(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch) {\n\t\tif (ObjectUtils.isEmpty(annotationsToSearch)) {\n\t\t\treturn true;\n\t\t}\n\t\tSimpleTypeConverter typeConverter = new SimpleTypeConverter();\n\t\tfor (Annotation annotation : annotationsToSearch) {\n\t\t\tClass<? extends Annotation> type = annotation.annotationType();\n\t\t\tboolean checkMeta = true;\n\t\t\tboolean fallbackToMeta = false;\n\t\t\tif (isQualifier(type)) {\n\t\t\t\tif (!checkQualifier(bdHolder, annotation, typeConverter)) {\n\t\t\t\t\tfallbackToMeta = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcheckMeta = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (checkMeta) {\n\t\t\t\tboolean foundMeta = false;\n\t\t\t\tfor (Annotation metaAnn : type.getAnnotations()) {\n\t\t\t\t\tClass<? extends Annotation> metaType = metaAnn.annotationType();\n\t\t\t\t\tif (isQualifier(metaType)) {\n\t\t\t\t\t\tfoundMeta = true;\n\t\t\t\t\t\t// Only accept fallback match if @Qualifier annotation has a value...\n\t\t\t\t\t\t// Otherwise, it is just a marker for a custom qualifier annotation.\n\t\t\t\t\t\tif ((fallbackToMeta && ObjectUtils.isEmpty(AnnotationUtils.getValue(metaAnn))) ||\n\t\t\t\t\t\t\t\t!checkQualifier(bdHolder, metaAnn, typeConverter)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (fallbackToMeta && !foundMeta) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#extractValue(attr)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract the value attribute from the given annotation.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "attr"
    ],
    "position": {
      "column": 1,
      "line": 378
    },
    "return": "Object",
    "signature": "protected Object extractValue(AnnotationAttributes attr)",
    "source_code": "\tprotected Object extractValue(AnnotationAttributes attr) {\n\t\tObject value = attr.get(AnnotationUtils.VALUE);\n\t\tif (value == null) {\n\t\t\tthrow new IllegalStateException(\"Value annotation must have a value attribute\");\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#findValue(annotationsToSearch)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine a suggested value from any of the given candidate annotations.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "annotationsToSearch"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "Object",
    "signature": "protected Object findValue(Annotation[] annotationsToSearch)",
    "source_code": "\tprotected Object findValue(Annotation[] annotationsToSearch) {\n\t\tif (annotationsToSearch.length > 0) {   // qualifier annotations have to be local\n\t\t\tAnnotationAttributes attr = AnnotatedElementUtils.getMergedAnnotationAttributes(\n\t\t\t\t\tAnnotatedElementUtils.forAnnotations(annotationsToSearch), this.valueAnnotationType);\n\t\t\tif (attr != null) {\n\t\t\t\treturn extractValue(attr);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#getFactoryMethodAnnotation(bd,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "Annotation",
    "signature": "protected Annotation getFactoryMethodAnnotation(RootBeanDefinition bd, Class<? extends Annotation> type)",
    "source_code": "\tprotected Annotation getFactoryMethodAnnotation(RootBeanDefinition bd, Class<? extends Annotation> type) {\n\t\tMethod resolvedFactoryMethod = bd.getResolvedFactoryMethod();\n\t\treturn (resolvedFactoryMethod != null ? AnnotationUtils.getAnnotation(resolvedFactoryMethod, type) : null);\n\t}"
  },
  "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#getQualifiedElementAnnotation(bd,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "Annotation",
    "signature": "protected Annotation getQualifiedElementAnnotation(RootBeanDefinition bd, Class<? extends Annotation> type)",
    "source_code": "\tprotected Annotation getQualifiedElementAnnotation(RootBeanDefinition bd, Class<? extends Annotation> type) {\n\t\tAnnotatedElement qualifiedElement = bd.getQualifiedElement();\n\t\treturn (qualifiedElement != null ? AnnotationUtils.getAnnotation(qualifiedElement, type) : null);\n\t}"
  },
  "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#getSuggestedValue(descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given dependency declares a value annotation.\n\t * @see Value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "Object",
    "signature": "public Object getSuggestedValue(DependencyDescriptor descriptor)",
    "source_code": "\tpublic Object getSuggestedValue(DependencyDescriptor descriptor) {\n\t\tObject value = findValue(descriptor.getAnnotations());\n\t\tif (value == null) {\n\t\t\tMethodParameter methodParam = descriptor.getMethodParameter();\n\t\t\tif (methodParam != null) {\n\t\t\t\tvalue = findValue(methodParam.getMethodAnnotations());\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#hasQualifier(descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given dependency declares a qualifier annotation.\n\t * @see #isQualifier(Class)\n\t * @see Qualifier\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "boolean",
    "signature": "public boolean hasQualifier(DependencyDescriptor descriptor)",
    "source_code": "\tpublic boolean hasQualifier(DependencyDescriptor descriptor) {\n\t\tfor (Annotation ann : descriptor.getAnnotations()) {\n\t\t\tif (isQualifier(ann.annotationType())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#isAutowireCandidate(bdHolder,descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the provided bean definition is an autowire candidate.\n\t * <p>To be considered a candidate the bean's <em>autowire-candidate</em>\n\t * attribute must not have been set to 'false'. Also, if an annotation on\n\t * the field or parameter to be autowired is recognized by this bean factory\n\t * as a <em>qualifier</em>, the bean must 'match' against the annotation as\n\t * well as any attributes it may contain. The bean definition must contain\n\t * the same qualifier or match by meta attributes. A \"value\" attribute will\n\t * fall back to match against the bean name or an alias if a qualifier or\n\t * attribute does not match.\n\t * @see Qualifier\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bdHolder",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "boolean",
    "signature": "public boolean isAutowireCandidate(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor)",
    "source_code": "\tpublic boolean isAutowireCandidate(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor) {\n\t\tboolean match = super.isAutowireCandidate(bdHolder, descriptor);\n\t\tif (match) {\n\t\t\tmatch = checkQualifiers(bdHolder, descriptor.getAnnotations());\n\t\t\tif (match) {\n\t\t\t\tMethodParameter methodParam = descriptor.getMethodParameter();\n\t\t\t\tif (methodParam != null) {\n\t\t\t\t\tMethod method = methodParam.getMethod();\n\t\t\t\t\tif (method == null || void.class == method.getReturnType()) {\n\t\t\t\t\t\tmatch = checkQualifiers(bdHolder, methodParam.getMethodAnnotations());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn match;\n\t}"
  },
  "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#isQualifier(annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Checks whether the given annotation type is a recognized qualifier type.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "boolean",
    "signature": "protected boolean isQualifier(Class<? extends Annotation> annotationType)",
    "source_code": "\tprotected boolean isQualifier(Class<? extends Annotation> annotationType) {\n\t\tfor (Class<? extends Annotation> qualifierType : this.qualifierTypes) {\n\t\t\tif (annotationType.equals(qualifierType) || annotationType.isAnnotationPresent(qualifierType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#isRequired(descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given dependency declares an autowired annotation,\n\t * checking its required flag.\n\t * @see Autowired#required()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "boolean",
    "signature": "public boolean isRequired(DependencyDescriptor descriptor)",
    "source_code": "\tpublic boolean isRequired(DependencyDescriptor descriptor) {\n\t\tif (!super.isRequired(descriptor)) {\n\t\t\treturn false;\n\t\t}\n\t\tAutowired autowired = descriptor.getAnnotation(Autowired.class);\n\t\treturn (autowired == null || autowired.required());\n\t}"
  },
  "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#setValueAnnotationType(valueAnnotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the 'value' annotation type, to be used on fields, method parameters\n\t * and constructor parameters.\n\t * <p>The default value annotation type is the Spring-provided\n\t * {@link Value} annotation.\n\t * <p>This setter property exists so that developers can provide their own\n\t * (non-Spring-specific) annotation type to indicate a default value\n\t * expression for a specific argument.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "valueAnnotationType"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void setValueAnnotationType(Class<? extends Annotation> valueAnnotationType)",
    "source_code": "\tpublic void setValueAnnotationType(Class<? extends Annotation> valueAnnotationType) {\n\t\tthis.valueAnnotationType = valueAnnotationType;\n\t}"
  },
  "org.springframework.beans.factory.config.AbstractFactoryBean": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Simple template superclass for {@link FactoryBean} implementations that\n * creates a singleton or a prototype object, depending on a flag.\n *\n * <p>If the \"singleton\" flag is {@code true} (the default),\n * this class will create the object that it creates exactly once\n * on initialization and subsequently return said singleton instance\n * on all calls to the {@link #getObject()} method.\n *\n * <p>Else, this class will create a new instance every time the\n * {@link #getObject()} method is invoked. Subclasses are responsible\n * for implementing the abstract {@link #createInstance()} template\n * method to actually create the object(s) to expose.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @since 1.0.2\n * @param <T> the bean type\n * @see #setSingleton\n * @see #createInstance()\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "signature": "public class AbstractFactoryBean",
    "source_code": "public abstract class AbstractFactoryBean<T>"
  },
  "org.springframework.beans.factory.config.AbstractFactoryBean#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Eagerly create the singleton instance, if necessary.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() throws Exception {\n\t\tif (isSingleton()) {\n\t\t\tthis.initialized = true;\n\t\t\tthis.singletonInstance = createInstance();\n\t\t\tthis.earlySingletonInstance = null;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.AbstractFactoryBean#createInstance()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that subclasses must override to construct\n\t * the object returned by this factory.\n\t * <p>Invoked on initialization of this FactoryBean in case of\n\t * a singleton; else, on each {@link #getObject()} call.\n\t * @return the object returned by this factory\n\t * @throws Exception if an exception occurred during object creation\n\t * @see #getObject()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "T",
    "signature": "protected T createInstance()",
    "source_code": "\tprotected abstract T createInstance() throws Exception;"
  },
  "org.springframework.beans.factory.config.AbstractFactoryBean#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Destroy the singleton instance, if any.\n\t * @see #destroyInstance(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() throws Exception {\n\t\tif (isSingleton()) {\n\t\t\tdestroyInstance(this.singletonInstance);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.AbstractFactoryBean#destroyInstance(instance)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Callback for destroying a singleton instance. Subclasses may\n\t * override this to destroy the previously created instance.\n\t * <p>The default implementation is empty.\n\t * @param instance the singleton instance, as returned by\n\t * {@link #createInstance()}\n\t * @throws Exception in case of shutdown errors\n\t * @see #createInstance()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "instance"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "void",
    "signature": "protected void destroyInstance(@Nullable T instance)",
    "source_code": "\tprotected void destroyInstance(@Nullable T instance) throws Exception {\n\t}"
  },
  "org.springframework.beans.factory.config.AbstractFactoryBean#getBeanFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the BeanFactory that this bean runs in.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "BeanFactory",
    "signature": "protected BeanFactory getBeanFactory()",
    "source_code": "\tprotected BeanFactory getBeanFactory() {\n\t\treturn this.beanFactory;\n\t}"
  },
  "org.springframework.beans.factory.config.AbstractFactoryBean#getBeanTypeConverter()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a bean type converter from the BeanFactory that this bean\n\t * runs in. This is typically a fresh instance for each call,\n\t * since TypeConverters are usually <i>not</i> thread-safe.\n\t * <p>Falls back to a SimpleTypeConverter when not running in a BeanFactory.\n\t * @see ConfigurableBeanFactory#getTypeConverter()\n\t * @see org.springframework.beans.SimpleTypeConverter\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "TypeConverter",
    "signature": "protected TypeConverter getBeanTypeConverter()",
    "source_code": "\tprotected TypeConverter getBeanTypeConverter() {\n\t\tBeanFactory beanFactory = getBeanFactory();\n\t\tif (beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\treturn cbf.getTypeConverter();\n\t\t}\n\t\telse {\n\t\t\treturn new SimpleTypeConverter();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.AbstractFactoryBean#getObject()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Expose the singleton instance or create a new prototype instance.\n\t * @see #createInstance()\n\t * @see #getEarlySingletonInterfaces()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "T",
    "signature": "public T getObject()",
    "source_code": "\tpublic final T getObject() throws Exception {\n\t\tif (isSingleton()) {\n\t\t\treturn (this.initialized ? this.singletonInstance : getEarlySingletonInstance());\n\t\t}\n\t\telse {\n\t\t\treturn createInstance();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.AbstractFactoryBean#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tif (ReflectionUtils.isEqualsMethod(method)) {\n\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\treturn (proxy == args[0]);\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isHashCodeMethod(method)) {\n\t\t\t\t// Use hashCode of reference proxy.\n\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t}\n\t\t\telse if (!initialized && ReflectionUtils.isToStringMethod(method)) {\n\t\t\t\treturn \"Early singleton proxy for interfaces \" +\n\t\t\t\t\t\tObjectUtils.nullSafeToString(getEarlySingletonInterfaces());\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn method.invoke(getSingletonInstance(), args);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.config.AbstractFactoryBean#isSingleton()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "boolean",
    "signature": "public boolean isSingleton()",
    "source_code": "\tpublic boolean isSingleton() {\n\t\treturn this.singleton;\n\t}"
  },
  "org.springframework.beans.factory.config.AbstractFactoryBean#setBeanClassLoader(classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void setBeanClassLoader(ClassLoader classLoader)",
    "source_code": "\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\tthis.beanClassLoader = classLoader;\n\t}"
  },
  "org.springframework.beans.factory.config.AbstractFactoryBean#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void setBeanFactory(@Nullable BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(@Nullable BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t}"
  },
  "org.springframework.beans.factory.config.AbstractFactoryBean#setSingleton(singleton)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set if a singleton should be created, or a new object on each request\n\t * otherwise. Default is {@code true} (a singleton).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "singleton"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "void",
    "signature": "public void setSingleton(boolean singleton)",
    "source_code": "\tpublic void setSingleton(boolean singleton) {\n\t\tthis.singleton = singleton;\n\t}"
  },
  "org.springframework.beans.factory.config.DocumentMatcher": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Strategy interface used to test if properties match.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 367
    },
    "signature": "public interface DocumentMatcher",
    "source_code": "\tpublic interface DocumentMatcher {\n\n\t\t/**\n\t\t * Test if the given properties match.\n\t\t * @param properties the properties to test\n\t\t * @return the status of the match\n\t\t */\n\t\tMatchStatus matches(Properties properties);\n\t}"
  },
  "org.springframework.beans.factory.config.MatchCallback": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Callback interface used to process the YAML parsing results.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 350
    },
    "signature": "public interface MatchCallback",
    "source_code": "\tpublic interface MatchCallback {\n\n\t\t/**\n\t\t * Process the given representation of the parsing results.\n\t\t * @param properties the properties to process (as a flattened\n\t\t * representation with indexed keys in case of a collection or map)\n\t\t * @param map the result map (preserving the original value structure\n\t\t * in the YAML document)\n\t\t */\n\t\tvoid process(Properties properties, Map<String, Object> map);\n\t}"
  },
  "org.springframework.beans.factory.config.MatchStatus": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Status returned from {@link DocumentMatcher#matches(java.util.Properties)}.\n\t */",
    "kind": "enum",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "signature": "public enum MatchStatus",
    "source_code": "\tpublic enum MatchStatus {\n\n\t\t/**\n\t\t * A match was found.\n\t\t */\n\t\tFOUND,\n\n\t\t/**\n\t\t * No match was found.\n\t\t */\n\t\tNOT_FOUND,\n\n\t\t/**\n\t\t * The matcher should not be considered.\n\t\t */\n\t\tABSTAIN;\n\n\t\t/**\n\t\t * Compare two {@link MatchStatus} items, returning the most specific status.\n\t\t */\n\t\tpublic static MatchStatus getMostSpecific(MatchStatus a, MatchStatus b) {\n\t\t\treturn (a.ordinal() < b.ordinal() ? a : b);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.MethodInvokingBean": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Simple method invoker bean: just invoking a target method, not expecting a result\n * to expose to the container (in contrast to {@link MethodInvokingFactoryBean}).\n *\n * <p>This invoker supports any kind of target method. A static method may be specified\n * by setting the {@link #setTargetMethod targetMethod} property to a String representing\n * the static method name, with {@link #setTargetClass targetClass} specifying the Class\n * that the static method is defined on. Alternatively, a target instance method may be\n * specified, by setting the {@link #setTargetObject targetObject} property as the target\n * object, and the {@link #setTargetMethod targetMethod} property as the name of the\n * method to call on that target object. Arguments for the method invocation may be\n * specified by setting the {@link #setArguments arguments} property.\n *\n * <p>This class depends on {@link #afterPropertiesSet()} being called once\n * all properties have been set, as per the InitializingBean contract.\n *\n * <p>An example (in an XML based bean factory definition) of a bean definition\n * which uses this class to call a static initialization method:\n *\n * <pre class=\"code\">\n * &lt;bean id=\"myObject\" class=\"org.springframework.beans.factory.config.MethodInvokingBean\"&gt;\n *   &lt;property name=\"staticMethod\" value=\"com.whatever.MyClass.init\"/&gt;\n * &lt;/bean&gt;</pre>\n *\n * <p>An example of calling an instance method to start some server bean:\n *\n * <pre class=\"code\">\n * &lt;bean id=\"myStarter\" class=\"org.springframework.beans.factory.config.MethodInvokingBean\"&gt;\n *   &lt;property name=\"targetObject\" ref=\"myServer\"/&gt;\n *   &lt;property name=\"targetMethod\" value=\"start\"/&gt;\n * &lt;/bean&gt;</pre>\n *\n * @author Juergen Hoeller\n * @since 4.0.3\n * @see MethodInvokingFactoryBean\n * @see org.springframework.util.MethodInvoker\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "signature": "public class MethodInvokingBean",
    "source_code": "public class MethodInvokingBean extends ArgumentConvertingMethodInvoker"
  },
  "org.springframework.beans.factory.config.MethodInvokingBean#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() throws Exception {\n\t\tprepare();\n\t\tinvokeWithTargetException();\n\t}"
  },
  "org.springframework.beans.factory.config.MethodInvokingBean#getDefaultTypeConverter()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the TypeConverter from the BeanFactory that this bean runs in,\n\t * if possible.\n\t * @see ConfigurableBeanFactory#getTypeConverter()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "TypeConverter",
    "signature": "protected TypeConverter getDefaultTypeConverter()",
    "source_code": "\tprotected TypeConverter getDefaultTypeConverter() {\n\t\tif (this.beanFactory != null) {\n\t\t\treturn this.beanFactory.getTypeConverter();\n\t\t}\n\t\telse {\n\t\t\treturn super.getDefaultTypeConverter();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.MethodInvokingBean#invokeWithTargetException()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform the invocation and convert InvocationTargetException\n\t * into the underlying target exception.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "Object",
    "signature": "protected Object invokeWithTargetException()",
    "source_code": "\tprotected Object invokeWithTargetException() throws Exception {\n\t\ttry {\n\t\t\treturn invoke();\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tif (ex.getTargetException() instanceof Exception exception) {\n\t\t\t\tthrow exception;\n\t\t\t}\n\t\t\tif (ex.getTargetException() instanceof Error error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.MethodInvokingBean#setBeanClassLoader(classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "void",
    "signature": "public void setBeanClassLoader(ClassLoader classLoader)",
    "source_code": "\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\tthis.beanClassLoader = classLoader;\n\t}"
  },
  "org.springframework.beans.factory.config.MethodInvokingBean#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tif (beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tthis.beanFactory = cbf;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.PropertyPathFactoryBean": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link FactoryBean} that evaluates a property path on a given target object.\n *\n * <p>The target object can be specified directly or via a bean name.\n *\n * <p>Usage examples:\n *\n * <pre class=\"code\">&lt;!-- target bean to be referenced by name --&gt;\n * &lt;bean id=\"tb\" class=\"org.springframework.beans.TestBean\" singleton=\"false\"&gt;\n *   &lt;property name=\"age\" value=\"10\"/&gt;\n *   &lt;property name=\"spouse\"&gt;\n *     &lt;bean class=\"org.springframework.beans.TestBean\"&gt;\n *       &lt;property name=\"age\" value=\"11\"/&gt;\n *     &lt;/bean&gt;\n *   &lt;/property&gt;\n * &lt;/bean&gt;\n *\n * &lt;!-- will result in 12, which is the value of property 'age' of the inner bean --&gt;\n * &lt;bean id=\"propertyPath1\" class=\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"&gt;\n *   &lt;property name=\"targetObject\"&gt;\n *     &lt;bean class=\"org.springframework.beans.TestBean\"&gt;\n *       &lt;property name=\"age\" value=\"12\"/&gt;\n *     &lt;/bean&gt;\n *   &lt;/property&gt;\n *   &lt;property name=\"propertyPath\" value=\"age\"/&gt;\n * &lt;/bean&gt;\n *\n * &lt;!-- will result in 11, which is the value of property 'spouse.age' of bean 'tb' --&gt;\n * &lt;bean id=\"propertyPath2\" class=\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"&gt;\n *   &lt;property name=\"targetBeanName\" value=\"tb\"/&gt;\n *   &lt;property name=\"propertyPath\" value=\"spouse.age\"/&gt;\n * &lt;/bean&gt;\n *\n * &lt;!-- will result in 10, which is the value of property 'age' of bean 'tb' --&gt;\n * &lt;bean id=\"tb.age\" class=\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"/&gt;</pre>\n *\n * <p>If you are using Spring 2.0 and XML Schema support in your configuration file(s),\n * you can also use the following style of configuration for property path access.\n * (See also the appendix entitled 'XML Schema-based configuration' in the Spring\n * reference manual for more examples.)\n *\n * <pre class=\"code\"> &lt;!-- will result in 10, which is the value of property 'age' of bean 'tb' --&gt;\n * &lt;util:property-path id=\"name\" path=\"testBean.age\"/&gt;</pre>\n *\n * Thanks to Matthias Ernst for the suggestion and initial prototype!\n *\n * @author Juergen Hoeller\n * @since 1.1.2\n * @see #setTargetObject\n * @see #setTargetBeanName\n * @see #setPropertyPath\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "signature": "public class PropertyPathFactoryBean",
    "source_code": "public class PropertyPathFactoryBean implements FactoryBean<Object>, BeanNameAware, BeanFactoryAware {\n\n\tprivate static final Log logger = LogFactory.getLog(PropertyPathFactoryBean.class);\n\n\t@Nullable\n\tprivate BeanWrapper targetBeanWrapper;\n\n\t@Nullable\n\tprivate String targetBeanName;\n\n\t@Nullable\n\tprivate String propertyPath;\n\n\t@Nullable\n\tprivate Class<?> resultType;\n\n\t@Nullable\n\tprivate String beanName;\n\n\t@Nullable\n\tprivate BeanFactory beanFactory;\n\n\n\t/**\n\t * Specify a target object to apply the property path to.\n\t * Alternatively, specify a target bean name.\n\t * @param targetObject a target object, for example a bean reference\n\t * or an inner bean\n\t * @see #setTargetBeanName\n\t */\n\tpublic void setTargetObject(Object targetObject) {\n\t\tthis.targetBeanWrapper = PropertyAccessorFactory.forBeanPropertyAccess(targetObject);\n\t}\n\n\t/**\n\t * Specify the name of a target bean to apply the property path to.\n\t * Alternatively, specify a target object directly.\n\t * @param targetBeanName the bean name to be looked up in the\n\t * containing bean factory (e.g. \"testBean\")\n\t * @see #setTargetObject\n\t */\n\tpublic void setTargetBeanName(String targetBeanName) {\n\t\tthis.targetBeanName = StringUtils.trimAllWhitespace(targetBeanName);\n\t}\n\n\t/**\n\t * Specify the property path to apply to the target.\n\t * @param propertyPath the property path, potentially nested\n\t * (e.g. \"age\" or \"spouse.age\")\n\t */\n\tpublic void setPropertyPath(String propertyPath) {\n\t\tthis.propertyPath = StringUtils.trimAllWhitespace(propertyPath);\n\t}\n\n\t/**\n\t * Specify the type of the result from evaluating the property path.\n\t * <p>Note: This is not necessary for directly specified target objects\n\t * or singleton target beans, where the type can be determined through\n\t * introspection. Just specify this in case of a prototype target,\n\t * provided that you need matching by type (for example, for autowiring).\n\t * @param resultType the result type, for example \"java.lang.Integer\"\n\t */\n\tpublic void setResultType(Class<?> resultType) {\n\t\tthis.resultType = resultType;\n\t}\n\n\t/**\n\t * The bean name of this PropertyPathFactoryBean will be interpreted\n\t * as \"beanName.property\" pattern, if neither \"targetObject\" nor\n\t * \"targetBeanName\" nor \"propertyPath\" have been specified.\n\t * This allows for concise bean definitions with just an id/name.\n\t */\n\t@Override\n\tpublic void setBeanName(String beanName) {\n\t\tthis.beanName = StringUtils.trimAllWhitespace(BeanFactoryUtils.originalBeanName(beanName));\n\t}\n\n\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\n\t\tif (this.targetBeanWrapper != null && this.targetBeanName != null) {\n\t\t\tthrow new IllegalArgumentException(\"Specify either 'targetObject' or 'targetBeanName', not both\");\n\t\t}\n\n\t\tif (this.targetBeanWrapper == null && this.targetBeanName == null) {\n\t\t\tif (this.propertyPath != null) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Specify 'targetObject' or 'targetBeanName' in combination with 'propertyPath'\");\n\t\t\t}\n\n\t\t\t// No other properties specified: check bean name.\n\t\t\tint dotIndex = (this.beanName != null ? this.beanName.indexOf('.') : -1);\n\t\t\tif (dotIndex == -1) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Neither 'targetObject' nor 'targetBeanName' specified, and PropertyPathFactoryBean \" +\n\t\t\t\t\t\t\"bean name '\" + this.beanName + \"' does not follow 'beanName.property' syntax\");\n\t\t\t}\n\t\t\tthis.targetBeanName = this.beanName.substring(0, dotIndex);\n\t\t\tthis.propertyPath = this.beanName.substring(dotIndex + 1);\n\t\t}\n\n\t\telse if (this.propertyPath == null) {\n\t\t\t// either targetObject or targetBeanName specified\n\t\t\tthrow new IllegalArgumentException(\"'propertyPath' is required\");\n\t\t}\n\n\t\tif (this.targetBeanWrapper == null && this.beanFactory.isSingleton(this.targetBeanName)) {\n\t\t\t// Eagerly fetch singleton target bean, and determine result type.\n\t\t\tObject bean = this.beanFactory.getBean(this.targetBeanName);\n\t\t\tthis.targetBeanWrapper = PropertyAccessorFactory.forBeanPropertyAccess(bean);\n\t\t\tthis.resultType = this.targetBeanWrapper.getPropertyType(this.propertyPath);\n\t\t}\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic Object getObject() throws BeansException {\n\t\tBeanWrapper target = this.targetBeanWrapper;\n\t\tif (target != null) {\n\t\t\tif (logger.isWarnEnabled() && this.targetBeanName != null &&\n\t\t\t\t\tthis.beanFactory instanceof ConfigurableBeanFactory cbf &&\n\t\t\t\t\tcbf.isCurrentlyInCreation(this.targetBeanName)) {\n\t\t\t\tlogger.warn(\"Target bean '\" + this.targetBeanName + \"' is still in creation due to a circular \" +\n\t\t\t\t\t\t\"reference - obtained value for property '\" + this.propertyPath + \"' may be outdated!\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Fetch prototype target bean...\n\t\t\tAssert.state(this.beanFactory != null, \"No BeanFactory available\");\n\t\t\tAssert.state(this.targetBeanName != null, \"No target bean name specified\");\n\t\t\tObject bean = this.beanFactory.getBean(this.targetBeanName);\n\t\t\ttarget = PropertyAccessorFactory.forBeanPropertyAccess(bean);\n\t\t}\n\t\tAssert.state(this.propertyPath != null, \"No property path specified\");\n\t\treturn target.getPropertyValue(this.propertyPath);\n\t}\n\n\t@Override\n\tpublic Class<?> getObjectType() {\n\t\treturn this.resultType;\n\t}\n\n\t/**\n\t * While this FactoryBean will often be used for singleton targets,\n\t * the invoked getters for the property path might return a new object\n\t * for each call, so we have to assume that we're not returning the\n\t * same object for each {@link #getObject()} call.\n\t */\n\t@Override\n\tpublic boolean isSingleton() {\n\t\treturn false;\n\t}\n\n}"
  },
  "org.springframework.beans.factory.config.PropertyPathFactoryBean#getObject()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "Object",
    "signature": "public Object getObject()",
    "source_code": "\tpublic Object getObject() throws BeansException {\n\t\tBeanWrapper target = this.targetBeanWrapper;\n\t\tif (target != null) {\n\t\t\tif (logger.isWarnEnabled() && this.targetBeanName != null &&\n\t\t\t\t\tthis.beanFactory instanceof ConfigurableBeanFactory cbf &&\n\t\t\t\t\tcbf.isCurrentlyInCreation(this.targetBeanName)) {\n\t\t\t\tlogger.warn(\"Target bean '\" + this.targetBeanName + \"' is still in creation due to a circular \" +\n\t\t\t\t\t\t\"reference - obtained value for property '\" + this.propertyPath + \"' may be outdated!\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Fetch prototype target bean...\n\t\t\tAssert.state(this.beanFactory != null, \"No BeanFactory available\");\n\t\t\tAssert.state(this.targetBeanName != null, \"No target bean name specified\");\n\t\t\tObject bean = this.beanFactory.getBean(this.targetBeanName);\n\t\t\ttarget = PropertyAccessorFactory.forBeanPropertyAccess(bean);\n\t\t}\n\t\tAssert.state(this.propertyPath != null, \"No property path specified\");\n\t\treturn target.getPropertyValue(this.propertyPath);\n\t}"
  },
  "org.springframework.beans.factory.config.PropertyPathFactoryBean#isSingleton()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * While this FactoryBean will often be used for singleton targets,\n\t * the invoked getters for the property path might return a new object\n\t * for each call, so we have to assume that we're not returning the\n\t * same object for each {@link #getObject()} call.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "boolean",
    "signature": "public boolean isSingleton()",
    "source_code": "\tpublic boolean isSingleton() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.beans.factory.config.PropertyPathFactoryBean#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\n\t\tif (this.targetBeanWrapper != null && this.targetBeanName != null) {\n\t\t\tthrow new IllegalArgumentException(\"Specify either 'targetObject' or 'targetBeanName', not both\");\n\t\t}\n\n\t\tif (this.targetBeanWrapper == null && this.targetBeanName == null) {\n\t\t\tif (this.propertyPath != null) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Specify 'targetObject' or 'targetBeanName' in combination with 'propertyPath'\");\n\t\t\t}\n\n\t\t\t// No other properties specified: check bean name.\n\t\t\tint dotIndex = (this.beanName != null ? this.beanName.indexOf('.') : -1);\n\t\t\tif (dotIndex == -1) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Neither 'targetObject' nor 'targetBeanName' specified, and PropertyPathFactoryBean \" +\n\t\t\t\t\t\t\"bean name '\" + this.beanName + \"' does not follow 'beanName.property' syntax\");\n\t\t\t}\n\t\t\tthis.targetBeanName = this.beanName.substring(0, dotIndex);\n\t\t\tthis.propertyPath = this.beanName.substring(dotIndex + 1);\n\t\t}\n\n\t\telse if (this.propertyPath == null) {\n\t\t\t// either targetObject or targetBeanName specified\n\t\t\tthrow new IllegalArgumentException(\"'propertyPath' is required\");\n\t\t}\n\n\t\tif (this.targetBeanWrapper == null && this.beanFactory.isSingleton(this.targetBeanName)) {\n\t\t\t// Eagerly fetch singleton target bean, and determine result type.\n\t\t\tObject bean = this.beanFactory.getBean(this.targetBeanName);\n\t\t\tthis.targetBeanWrapper = PropertyAccessorFactory.forBeanPropertyAccess(bean);\n\t\t\tthis.resultType = this.targetBeanWrapper.getPropertyType(this.propertyPath);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.PropertyPathFactoryBean#setBeanName(beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The bean name of this PropertyPathFactoryBean will be interpreted\n\t * as \"beanName.property\" pattern, if neither \"targetObject\" nor\n\t * \"targetBeanName\" nor \"propertyPath\" have been specified.\n\t * This allows for concise bean definitions with just an id/name.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void setBeanName(String beanName)",
    "source_code": "\tpublic void setBeanName(String beanName) {\n\t\tthis.beanName = StringUtils.trimAllWhitespace(BeanFactoryUtils.originalBeanName(beanName));\n\t}"
  },
  "org.springframework.beans.factory.config.PropertyPathFactoryBean#setPropertyPath(propertyPath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the property path to apply to the target.\n\t * @param propertyPath the property path, potentially nested\n\t * (e.g. \"age\" or \"spouse.age\")\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyPath"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "public void setPropertyPath(String propertyPath)",
    "source_code": "\tpublic void setPropertyPath(String propertyPath) {\n\t\tthis.propertyPath = StringUtils.trimAllWhitespace(propertyPath);\n\t}"
  },
  "org.springframework.beans.factory.config.PropertyPathFactoryBean#setResultType(resultType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the type of the result from evaluating the property path.\n\t * <p>Note: This is not necessary for directly specified target objects\n\t * or singleton target beans, where the type can be determined through\n\t * introspection. Just specify this in case of a prototype target,\n\t * provided that you need matching by type (for example, for autowiring).\n\t * @param resultType the result type, for example \"java.lang.Integer\"\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resultType"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void setResultType(Class<?> resultType)",
    "source_code": "\tpublic void setResultType(Class<?> resultType) {\n\t\tthis.resultType = resultType;\n\t}"
  },
  "org.springframework.beans.factory.config.PropertyPathFactoryBean#setTargetBeanName(targetBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the name of a target bean to apply the property path to.\n\t * Alternatively, specify a target object directly.\n\t * @param targetBeanName the bean name to be looked up in the\n\t * containing bean factory (e.g. \"testBean\")\n\t * @see #setTargetObject\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetBeanName"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void setTargetBeanName(String targetBeanName)",
    "source_code": "\tpublic void setTargetBeanName(String targetBeanName) {\n\t\tthis.targetBeanName = StringUtils.trimAllWhitespace(targetBeanName);\n\t}"
  },
  "org.springframework.beans.factory.config.PropertyPathFactoryBean#setTargetObject(targetObject)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a target object to apply the property path to.\n\t * Alternatively, specify a target bean name.\n\t * @param targetObject a target object, for example a bean reference\n\t * or an inner bean\n\t * @see #setTargetBeanName\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetObject"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void setTargetObject(Object targetObject)",
    "source_code": "\tpublic void setTargetObject(Object targetObject) {\n\t\tthis.targetBeanWrapper = PropertyAccessorFactory.forBeanPropertyAccess(targetObject);\n\t}"
  },
  "org.springframework.beans.factory.config.ResolutionMethod": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Method to use for resolving resources.\n\t */",
    "kind": "enum",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 410
    },
    "signature": "public enum ResolutionMethod",
    "source_code": "\tpublic enum ResolutionMethod {\n\n\t\t/**\n\t\t * Replace values from earlier in the list.\n\t\t */\n\t\tOVERRIDE,\n\n\t\t/**\n\t\t * Replace values from earlier in the list, ignoring any failures.\n\t\t */\n\t\tOVERRIDE_AND_IGNORE,\n\n\t\t/**\n\t\t * Take the first resource in the list that exists and use just that.\n\t\t */\n\t\tFIRST_FOUND\n\t}"
  },
  "org.springframework.beans.factory.config.ServiceLocatorFactoryBean": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@link FactoryBean} implementation that takes an interface which must have one or more\n * methods with the signatures {@code MyType xxx()} or {@code MyType xxx(MyIdType id)}\n * (typically, {@code MyService getService()} or {@code MyService getService(String id)})\n * and creates a dynamic proxy which implements that interface, delegating to an\n * underlying {@link org.springframework.beans.factory.BeanFactory}.\n *\n * <p>Such service locators permit the decoupling of calling code from\n * the {@link org.springframework.beans.factory.BeanFactory} API, by using an\n * appropriate custom locator interface. They will typically be used for\n * <b>prototype beans</b>, i.e. for factory methods that are supposed to\n * return a new instance for each call. The client receives a reference to the\n * service locator via setter or constructor injection, to be able to invoke\n * the locator's factory methods on demand. <b>For singleton beans, direct\n * setter or constructor injection of the target bean is preferable.</b>\n *\n * <p>On invocation of the no-arg factory method, or the single-arg factory\n * method with a String id of {@code null} or empty String, if exactly\n * <b>one</b> bean in the factory matches the return type of the factory\n * method, that bean is returned, otherwise a\n * {@link org.springframework.beans.factory.NoSuchBeanDefinitionException}\n * is thrown.\n *\n * <p>On invocation of the single-arg factory method with a non-null (and\n * non-empty) argument, the proxy returns the result of a\n * {@link org.springframework.beans.factory.BeanFactory#getBean(String)} call,\n * using a stringified version of the passed-in id as bean name.\n *\n * <p>A factory method argument will usually be a String, but can also be an\n * int or a custom enumeration type, for example, stringified via\n * {@code toString}. The resulting String can be used as bean name as-is,\n * provided that corresponding beans are defined in the bean factory.\n * Alternatively, {@linkplain #setServiceMappings(java.util.Properties) a custom\n * mapping} between service IDs and bean names can be defined.\n *\n * <p>By way of an example, consider the following service locator interface.\n * Note that this interface is not dependent on any Spring APIs.\n *\n * <pre class=\"code\">package a.b.c;\n *\n *public interface ServiceFactory {\n *\n *    public MyService getService();\n *}</pre>\n *\n * <p>A sample config in an XML-based\n * {@link org.springframework.beans.factory.BeanFactory} might look as follows:\n *\n * <pre class=\"code\">&lt;beans&gt;\n *\n *   &lt;!-- Prototype bean since we have state --&gt;\n *   &lt;bean id=\"myService\" class=\"a.b.c.MyService\" singleton=\"false\"/&gt;\n *\n *   &lt;!-- will lookup the above 'myService' bean by *TYPE* --&gt;\n *   &lt;bean id=\"myServiceFactory\"\n *            class=\"org.springframework.beans.factory.config.ServiceLocatorFactoryBean\"&gt;\n *     &lt;property name=\"serviceLocatorInterface\" value=\"a.b.c.ServiceFactory\"/&gt;\n *   &lt;/bean&gt;\n *\n *   &lt;bean id=\"clientBean\" class=\"a.b.c.MyClientBean\"&gt;\n *     &lt;property name=\"myServiceFactory\" ref=\"myServiceFactory\"/&gt;\n *   &lt;/bean&gt;\n *\n *&lt;/beans&gt;</pre>\n *\n * <p>The attendant {@code MyClientBean} class implementation might then\n * look something like this:\n *\n * <pre class=\"code\">package a.b.c;\n *\n *public class MyClientBean {\n *\n *    private ServiceFactory myServiceFactory;\n *\n *    // actual implementation provided by the Spring container\n *    public void setServiceFactory(ServiceFactory myServiceFactory) {\n *        this.myServiceFactory = myServiceFactory;\n *    }\n *\n *    public void someBusinessMethod() {\n *        // get a 'fresh', brand new MyService instance\n *        MyService service = this.myServiceFactory.getService();\n *        // use the service object to effect the business logic...\n *    }\n *}</pre>\n *\n * <p>By way of an example that looks up a bean <b>by name</b>, consider\n * the following service locator interface. Again, note that this\n * interface is not dependent on any Spring APIs.\n *\n * <pre class=\"code\">package a.b.c;\n *\n *public interface ServiceFactory {\n *\n *    public MyService getService (String serviceName);\n *}</pre>\n *\n * <p>A sample config in an XML-based\n * {@link org.springframework.beans.factory.BeanFactory} might look as follows:\n *\n * <pre class=\"code\">&lt;beans&gt;\n *\n *   &lt;!-- Prototype beans since we have state (both extend MyService) --&gt;\n *   &lt;bean id=\"specialService\" class=\"a.b.c.SpecialService\" singleton=\"false\"/&gt;\n *   &lt;bean id=\"anotherService\" class=\"a.b.c.AnotherService\" singleton=\"false\"/&gt;\n *\n *   &lt;bean id=\"myServiceFactory\"\n *            class=\"org.springframework.beans.factory.config.ServiceLocatorFactoryBean\"&gt;\n *     &lt;property name=\"serviceLocatorInterface\" value=\"a.b.c.ServiceFactory\"/&gt;\n *   &lt;/bean&gt;\n *\n *   &lt;bean id=\"clientBean\" class=\"a.b.c.MyClientBean\"&gt;\n *     &lt;property name=\"myServiceFactory\" ref=\"myServiceFactory\"/&gt;\n *   &lt;/bean&gt;\n *\n *&lt;/beans&gt;</pre>\n *\n * <p>The attendant {@code MyClientBean} class implementation might then\n * look something like this:\n *\n * <pre class=\"code\">package a.b.c;\n *\n *public class MyClientBean {\n *\n *    private ServiceFactory myServiceFactory;\n *\n *    // actual implementation provided by the Spring container\n *    public void setServiceFactory(ServiceFactory myServiceFactory) {\n *        this.myServiceFactory = myServiceFactory;\n *    }\n *\n *    public void someBusinessMethod() {\n *        // get a 'fresh', brand new MyService instance\n *        MyService service = this.myServiceFactory.getService(\"specialService\");\n *        // use the service object to effect the business logic...\n *    }\n *\n *    public void anotherBusinessMethod() {\n *        // get a 'fresh', brand new MyService instance\n *        MyService service = this.myServiceFactory.getService(\"anotherService\");\n *        // use the service object to effect the business logic...\n *    }\n *}</pre>\n *\n * <p>See {@link ObjectFactoryCreatingFactoryBean} for an alternate approach.\n *\n * @author Colin Sampaleanu\n * @author Juergen Hoeller\n * @since 1.1.4\n * @see #setServiceLocatorInterface\n * @see #setServiceMappings\n * @see ObjectFactoryCreatingFactoryBean\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "signature": "public class ServiceLocatorFactoryBean",
    "source_code": "public class ServiceLocatorFactoryBean implements FactoryBean<Object>, BeanFactoryAware, InitializingBean {\n\n\t@Nullable\n\tprivate Class<?> serviceLocatorInterface;\n\n\t@Nullable\n\tprivate Constructor<Exception> serviceLocatorExceptionConstructor;\n\n\t@Nullable\n\tprivate Properties serviceMappings;\n\n\t@Nullable\n\tprivate ListableBeanFactory beanFactory;\n\n\t@Nullable\n\tprivate Object proxy;\n\n\n\t/**\n\t * Set the service locator interface to use, which must have one or more methods with\n\t * the signatures {@code MyType xxx()} or {@code MyType xxx(MyIdType id)}\n\t * (typically, {@code MyService getService()} or {@code MyService getService(String id)}).\n\t * See the {@link ServiceLocatorFactoryBean class-level Javadoc} for\n\t * information on the semantics of such methods.\n\t */\n\tpublic void setServiceLocatorInterface(Class<?> interfaceType) {\n\t\tthis.serviceLocatorInterface = interfaceType;\n\t}\n\n\t/**\n\t * Set the exception class that the service locator should throw if service\n\t * lookup failed. The specified exception class must have a constructor\n\t * with one of the following parameter types: {@code (String, Throwable)}\n\t * or {@code (Throwable)} or {@code (String)}.\n\t * <p>If not specified, subclasses of Spring's BeansException will be thrown,\n\t * for example NoSuchBeanDefinitionException. As those are unchecked, the\n\t * caller does not need to handle them, so it might be acceptable that\n\t * Spring exceptions get thrown as long as they are just handled generically.\n\t * @see #determineServiceLocatorExceptionConstructor\n\t * @see #createServiceLocatorException\n\t */\n\tpublic void setServiceLocatorExceptionClass(Class<? extends Exception> serviceLocatorExceptionClass) {\n\t\tthis.serviceLocatorExceptionConstructor =\n\t\t\t\tdetermineServiceLocatorExceptionConstructor(serviceLocatorExceptionClass);\n\t}\n\n\t/**\n\t * Set mappings between service ids (passed into the service locator)\n\t * and bean names (in the bean factory). Service ids that are not defined\n\t * here will be treated as bean names as-is.\n\t * <p>The empty string as service id key defines the mapping for {@code null} and\n\t * empty string, and for factory methods without parameter. If not defined,\n\t * a single matching bean will be retrieved from the bean factory.\n\t * @param serviceMappings mappings between service ids and bean names,\n\t * with service ids as keys as bean names as values\n\t */\n\tpublic void setServiceMappings(Properties serviceMappings) {\n\t\tthis.serviceMappings = serviceMappings;\n\t}\n\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n\t\tif (!(beanFactory instanceof ListableBeanFactory lbf)) {\n\t\t\tthrow new FatalBeanException(\n\t\t\t\t\t\"ServiceLocatorFactoryBean needs to run in a BeanFactory that is a ListableBeanFactory\");\n\t\t}\n\t\tthis.beanFactory = lbf;\n\t}\n\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\tif (this.serviceLocatorInterface == null) {\n\t\t\tthrow new IllegalArgumentException(\"Property 'serviceLocatorInterface' is required\");\n\t\t}\n\n\t\t// Create service locator proxy.\n\t\tthis.proxy = Proxy.newProxyInstance(\n\t\t\t\tthis.serviceLocatorInterface.getClassLoader(),\n\t\t\t\tnew Class<?>[] {this.serviceLocatorInterface},\n\t\t\t\tnew ServiceLocatorInvocationHandler());\n\t}\n\n\n\t/**\n\t * Determine the constructor to use for the given service locator exception\n\t * class. Only called in case of a custom service locator exception.\n\t * <p>The default implementation looks for a constructor with one of the\n\t * following parameter types: {@code (String, Throwable)}\n\t * or {@code (Throwable)} or {@code (String)}.\n\t * @param exceptionClass the exception class\n\t * @return the constructor to use\n\t * @see #setServiceLocatorExceptionClass\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected Constructor<Exception> determineServiceLocatorExceptionConstructor(Class<? extends Exception> exceptionClass) {\n\t\ttry {\n\t\t\treturn (Constructor<Exception>) exceptionClass.getConstructor(String.class, Throwable.class);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\ttry {\n\t\t\t\treturn (Constructor<Exception>) exceptionClass.getConstructor(Throwable.class);\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ex2) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (Constructor<Exception>) exceptionClass.getConstructor(String.class);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchMethodException ex3) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\"Service locator exception [\" + exceptionClass.getName() +\n\t\t\t\t\t\t\t\"] neither has a (String, Throwable) constructor nor a (String) constructor\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Create a service locator exception for the given cause.\n\t * Only called in case of a custom service locator exception.\n\t * <p>The default implementation can handle all variations of\n\t * message and exception arguments.\n\t * @param exceptionConstructor the constructor to use\n\t * @param cause the cause of the service lookup failure\n\t * @return the service locator exception to throw\n\t * @see #setServiceLocatorExceptionClass\n\t */\n\tprotected Exception createServiceLocatorException(Constructor<Exception> exceptionConstructor, BeansException cause) {\n\t\tClass<?>[] paramTypes = exceptionConstructor.getParameterTypes();\n\t\tObject[] args = new Object[paramTypes.length];\n\t\tfor (int i = 0; i < paramTypes.length; i++) {\n\t\t\tif (String.class == paramTypes[i]) {\n\t\t\t\targs[i] = cause.getMessage();\n\t\t\t}\n\t\t\telse if (paramTypes[i].isInstance(cause)) {\n\t\t\t\targs[i] = cause;\n\t\t\t}\n\t\t}\n\t\treturn BeanUtils.instantiateClass(exceptionConstructor, args);\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic Object getObject() {\n\t\treturn this.proxy;\n\t}\n\n\t@Override\n\tpublic Class<?> getObjectType() {\n\t\treturn this.serviceLocatorInterface;\n\t}\n\n\t@Override\n\tpublic boolean isSingleton() {\n\t\treturn true;\n\t}\n\n\n\t/**\n\t * Invocation handler that delegates service locator calls to the bean factory.\n\t */\n\tprivate class ServiceLocatorInvocationHandler implements InvocationHandler {\n\n\t\t@Override\n\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tif (ReflectionUtils.isEqualsMethod(method)) {\n\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\treturn (proxy == args[0]);\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isHashCodeMethod(method)) {\n\t\t\t\t// Use hashCode of service locator proxy.\n\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isToStringMethod(method)) {\n\t\t\t\treturn \"Service locator: \" + serviceLocatorInterface;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn invokeServiceLocatorMethod(method, args);\n\t\t\t}\n\t\t}\n\n\t\tprivate Object invokeServiceLocatorMethod(Method method, Object[] args) throws Exception {\n\t\t\tClass<?> serviceLocatorMethodReturnType = getServiceLocatorMethodReturnType(method);\n\t\t\ttry {\n\t\t\t\tString beanName = tryGetBeanName(args);\n\t\t\t\tAssert.state(beanFactory != null, \"No BeanFactory available\");\n\t\t\t\tif (StringUtils.hasLength(beanName)) {\n\t\t\t\t\t// Service locator for a specific bean name\n\t\t\t\t\treturn beanFactory.getBean(beanName, serviceLocatorMethodReturnType);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Service locator for a bean type\n\t\t\t\t\treturn beanFactory.getBean(serviceLocatorMethodReturnType);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (BeansException ex) {\n\t\t\t\tif (serviceLocatorExceptionConstructor != null) {\n\t\t\t\t\tthrow createServiceLocatorException(serviceLocatorExceptionConstructor, ex);\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Check whether a service id was passed in.\n\t\t */\n\t\tprivate String tryGetBeanName(@Nullable Object[] args) {\n\t\t\tString beanName = \"\";\n\t\t\tif (args != null && args.length == 1 && args[0] != null) {\n\t\t\t\tbeanName = args[0].toString();\n\t\t\t}\n\t\t\t// Look for explicit serviceId-to-beanName mappings.\n\t\t\tif (serviceMappings != null) {\n\t\t\t\tString mappedName = serviceMappings.getProperty(beanName);\n\t\t\t\tif (mappedName != null) {\n\t\t\t\t\tbeanName = mappedName;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn beanName;\n\t\t}\n\n\t\tprivate Class<?> getServiceLocatorMethodReturnType(Method method) throws NoSuchMethodException {\n\t\t\tAssert.state(serviceLocatorInterface != null, \"No service locator interface specified\");\n\t\t\tClass<?>[] paramTypes = method.getParameterTypes();\n\t\t\tMethod interfaceMethod = serviceLocatorInterface.getMethod(method.getName(), paramTypes);\n\t\t\tClass<?> serviceLocatorReturnType = interfaceMethod.getReturnType();\n\n\t\t\t// Check whether the method is a valid service locator.\n\t\t\tif (paramTypes.length > 1 || void.class == serviceLocatorReturnType) {\n\t\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\t\"May only call methods with signature '<type> xxx()' or '<type> xxx(<idtype> id)' \" +\n\t\t\t\t\t\t\"on factory interface, but tried to call: \" + interfaceMethod);\n\t\t\t}\n\t\t\treturn serviceLocatorReturnType;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.beans.factory.config.ServiceLocatorFactoryBean#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tif (this.serviceLocatorInterface == null) {\n\t\t\tthrow new IllegalArgumentException(\"Property 'serviceLocatorInterface' is required\");\n\t\t}\n\n\t\t// Create service locator proxy.\n\t\tthis.proxy = Proxy.newProxyInstance(\n\t\t\t\tthis.serviceLocatorInterface.getClassLoader(),\n\t\t\t\tnew Class<?>[] {this.serviceLocatorInterface},\n\t\t\t\tnew ServiceLocatorInvocationHandler());\n\t}"
  },
  "org.springframework.beans.factory.config.ServiceLocatorFactoryBean#createServiceLocatorException(exceptionConstructor,cause)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a service locator exception for the given cause.\n\t * Only called in case of a custom service locator exception.\n\t * <p>The default implementation can handle all variations of\n\t * message and exception arguments.\n\t * @param exceptionConstructor the constructor to use\n\t * @param cause the cause of the service lookup failure\n\t * @return the service locator exception to throw\n\t * @see #setServiceLocatorExceptionClass\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exceptionConstructor",
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "Exception",
    "signature": "protected Exception createServiceLocatorException(Constructor<Exception> exceptionConstructor, BeansException cause)",
    "source_code": "\tprotected Exception createServiceLocatorException(Constructor<Exception> exceptionConstructor, BeansException cause) {\n\t\tClass<?>[] paramTypes = exceptionConstructor.getParameterTypes();\n\t\tObject[] args = new Object[paramTypes.length];\n\t\tfor (int i = 0; i < paramTypes.length; i++) {\n\t\t\tif (String.class == paramTypes[i]) {\n\t\t\t\targs[i] = cause.getMessage();\n\t\t\t}\n\t\t\telse if (paramTypes[i].isInstance(cause)) {\n\t\t\t\targs[i] = cause;\n\t\t\t}\n\t\t}\n\t\treturn BeanUtils.instantiateClass(exceptionConstructor, args);\n\t}"
  },
  "org.springframework.beans.factory.config.ServiceLocatorFactoryBean#determineServiceLocatorExceptionConstructor(exceptionClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the constructor to use for the given service locator exception\n\t * class. Only called in case of a custom service locator exception.\n\t * <p>The default implementation looks for a constructor with one of the\n\t * following parameter types: {@code (String, Throwable)}\n\t * or {@code (Throwable)} or {@code (String)}.\n\t * @param exceptionClass the exception class\n\t * @return the constructor to use\n\t * @see #setServiceLocatorExceptionClass\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exceptionClass"
    ],
    "position": {
      "column": 1,
      "line": 285
    },
    "return": "Constructor<Exception>",
    "signature": "protected Constructor<Exception> determineServiceLocatorExceptionConstructor(Class<? extends Exception> exceptionClass)",
    "source_code": "\tprotected Constructor<Exception> determineServiceLocatorExceptionConstructor(Class<? extends Exception> exceptionClass) {\n\t\ttry {\n\t\t\treturn (Constructor<Exception>) exceptionClass.getConstructor(String.class, Throwable.class);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\ttry {\n\t\t\t\treturn (Constructor<Exception>) exceptionClass.getConstructor(Throwable.class);\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ex2) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (Constructor<Exception>) exceptionClass.getConstructor(String.class);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchMethodException ex3) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\"Service locator exception [\" + exceptionClass.getName() +\n\t\t\t\t\t\t\t\"] neither has a (String, Throwable) constructor nor a (String) constructor\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.ServiceLocatorFactoryBean#getObject()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "Object",
    "signature": "public Object getObject()",
    "source_code": "\tpublic Object getObject() {\n\t\treturn this.proxy;\n\t}"
  },
  "org.springframework.beans.factory.config.ServiceLocatorFactoryBean#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tif (ReflectionUtils.isEqualsMethod(method)) {\n\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\treturn (proxy == args[0]);\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isHashCodeMethod(method)) {\n\t\t\t\t// Use hashCode of service locator proxy.\n\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isToStringMethod(method)) {\n\t\t\t\treturn \"Service locator: \" + serviceLocatorInterface;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn invokeServiceLocatorMethod(method, args);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.config.ServiceLocatorFactoryBean#isSingleton()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "boolean",
    "signature": "public boolean isSingleton()",
    "source_code": "\tpublic boolean isSingleton() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.beans.factory.config.ServiceLocatorFactoryBean#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n\t\tif (!(beanFactory instanceof ListableBeanFactory lbf)) {\n\t\t\tthrow new FatalBeanException(\n\t\t\t\t\t\"ServiceLocatorFactoryBean needs to run in a BeanFactory that is a ListableBeanFactory\");\n\t\t}\n\t\tthis.beanFactory = lbf;\n\t}"
  },
  "org.springframework.beans.factory.config.ServiceLocatorFactoryBean#setServiceLocatorExceptionClass(serviceLocatorExceptionClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the exception class that the service locator should throw if service\n\t * lookup failed. The specified exception class must have a constructor\n\t * with one of the following parameter types: {@code (String, Throwable)}\n\t * or {@code (Throwable)} or {@code (String)}.\n\t * <p>If not specified, subclasses of Spring's BeansException will be thrown,\n\t * for example NoSuchBeanDefinitionException. As those are unchecked, the\n\t * caller does not need to handle them, so it might be acceptable that\n\t * Spring exceptions get thrown as long as they are just handled generically.\n\t * @see #determineServiceLocatorExceptionConstructor\n\t * @see #createServiceLocatorException\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "serviceLocatorExceptionClass"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "void",
    "signature": "public void setServiceLocatorExceptionClass(Class<? extends Exception> serviceLocatorExceptionClass)",
    "source_code": "\tpublic void setServiceLocatorExceptionClass(Class<? extends Exception> serviceLocatorExceptionClass) {\n\t\tthis.serviceLocatorExceptionConstructor =\n\t\t\t\tdetermineServiceLocatorExceptionConstructor(serviceLocatorExceptionClass);\n\t}"
  },
  "org.springframework.beans.factory.config.ServiceLocatorFactoryBean#setServiceLocatorInterface(interfaceType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the service locator interface to use, which must have one or more methods with\n\t * the signatures {@code MyType xxx()} or {@code MyType xxx(MyIdType id)}\n\t * (typically, {@code MyService getService()} or {@code MyService getService(String id)}).\n\t * See the {@link ServiceLocatorFactoryBean class-level Javadoc} for\n\t * information on the semantics of such methods.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "interfaceType"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "void",
    "signature": "public void setServiceLocatorInterface(Class<?> interfaceType)",
    "source_code": "\tpublic void setServiceLocatorInterface(Class<?> interfaceType) {\n\t\tthis.serviceLocatorInterface = interfaceType;\n\t}"
  },
  "org.springframework.beans.factory.config.ServiceLocatorFactoryBean#setServiceMappings(serviceMappings)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set mappings between service ids (passed into the service locator)\n\t * and bean names (in the bean factory). Service ids that are not defined\n\t * here will be treated as bean names as-is.\n\t * <p>The empty string as service id key defines the mapping for {@code null} and\n\t * empty string, and for factory methods without parameter. If not defined,\n\t * a single matching bean will be retrieved from the bean factory.\n\t * @param serviceMappings mappings between service ids and bean names,\n\t * with service ids as keys as bean names as values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "serviceMappings"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "void",
    "signature": "public void setServiceMappings(Properties serviceMappings)",
    "source_code": "\tpublic void setServiceMappings(Properties serviceMappings) {\n\t\tthis.serviceMappings = serviceMappings;\n\t}"
  },
  "org.springframework.beans.factory.config.YamlMapFactoryBean": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Factory for a {@code Map} that reads from a YAML source, preserving the\n * YAML-declared value types and their structure.\n *\n * <p>YAML is a nice human-readable format for configuration, and it has some\n * useful hierarchical properties. It's more or less a superset of JSON, so it\n * has a lot of similar features.\n *\n * <p>If multiple resources are provided the later ones will override entries in\n * the earlier ones hierarchically; that is, all entries with the same nested key\n * of type {@code Map} at any depth are merged. For example:\n *\n * <pre class=\"code\">\n * foo:\n *   bar:\n *    one: two\n * three: four\n * </pre>\n *\n * plus (later in the list)\n *\n * <pre class=\"code\">\n * foo:\n *   bar:\n *    one: 2\n * five: six\n * </pre>\n *\n * results in an effective input of\n *\n * <pre class=\"code\">\n * foo:\n *   bar:\n *    one: 2\n * three: four\n * five: six\n * </pre>\n *\n * Note that the value of \"foo\" in the first document is not simply replaced\n * with the value in the second, but its nested values are merged.\n *\n * <p>Requires SnakeYAML 1.18 or higher, as of Spring Framework 5.0.6.\n *\n * @author Dave Syer\n * @author Juergen Hoeller\n * @since 4.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "signature": "public class YamlMapFactoryBean",
    "source_code": "public class YamlMapFactoryBean extends YamlProcessor implements FactoryBean<Map<String, Object>>, InitializingBean {\n\n\tprivate boolean singleton = true;\n\n\t@Nullable\n\tprivate Map<String, Object> map;\n\n\n\t/**\n\t * Set if a singleton should be created, or a new object on each request\n\t * otherwise. Default is {@code true} (a singleton).\n\t */\n\tpublic void setSingleton(boolean singleton) {\n\t\tthis.singleton = singleton;\n\t}\n\n\t@Override\n\tpublic boolean isSingleton() {\n\t\treturn this.singleton;\n\t}\n\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\tif (isSingleton()) {\n\t\t\tthis.map = createMap();\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Map<String, Object> getObject() {\n\t\treturn (this.map != null ? this.map : createMap());\n\t}\n\n\t@Override\n\tpublic Class<?> getObjectType() {\n\t\treturn Map.class;\n\t}\n\n\n\t/**\n\t * Template method that subclasses may override to construct the object\n\t * returned by this factory.\n\t * <p>Invoked lazily the first time {@link #getObject()} is invoked in\n\t * case of a shared singleton; else, on each {@link #getObject()} call.\n\t * <p>The default implementation returns the merged {@code Map} instance.\n\t * @return the object returned by this factory\n\t * @see #process(MatchCallback)\n\t */\n\tprotected Map<String, Object> createMap() {\n\t\tMap<String, Object> result = new LinkedHashMap<>();\n\t\tprocess((properties, map) -> merge(result, map));\n\t\treturn result;\n\t}\n\n\t@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n\tprivate void merge(Map<String, Object> output, Map<String, Object> map) {\n\t\tmap.forEach((key, value) -> {\n\t\t\tObject existing = output.get(key);\n\t\t\tif (value instanceof Map valueMap && existing instanceof Map existingMap) {\n\t\t\t\tMap<String, Object> result = new LinkedHashMap<>(existingMap);\n\t\t\t\tmerge(result, valueMap);\n\t\t\t\toutput.put(key, result);\n\t\t\t}\n\t\t\telse {\n\t\t\t\toutput.put(key, value);\n\t\t\t}\n\t\t});\n\t}\n\n}"
  },
  "org.springframework.beans.factory.config.YamlMapFactoryBean#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tif (isSingleton()) {\n\t\t\tthis.map = createMap();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.YamlMapFactoryBean#createMap()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that subclasses may override to construct the object\n\t * returned by this factory.\n\t * <p>Invoked lazily the first time {@link #getObject()} is invoked in\n\t * case of a shared singleton; else, on each {@link #getObject()} call.\n\t * <p>The default implementation returns the merged {@code Map} instance.\n\t * @return the object returned by this factory\n\t * @see #process(MatchCallback)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "Object>",
    "signature": "protected Object> createMap()",
    "source_code": "\tprotected Map<String, Object> createMap() {\n\t\tMap<String, Object> result = new LinkedHashMap<>();\n\t\tprocess((properties, map) -> merge(result, map));\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.config.YamlMapFactoryBean#getObject()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "Object>",
    "signature": "public Object> getObject()",
    "source_code": "\tpublic Map<String, Object> getObject() {\n\t\treturn (this.map != null ? this.map : createMap());\n\t}"
  },
  "org.springframework.beans.factory.config.YamlMapFactoryBean#isSingleton()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "boolean",
    "signature": "public boolean isSingleton()",
    "source_code": "\tpublic boolean isSingleton() {\n\t\treturn this.singleton;\n\t}"
  },
  "org.springframework.beans.factory.config.YamlMapFactoryBean#setSingleton(singleton)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set if a singleton should be created, or a new object on each request\n\t * otherwise. Default is {@code true} (a singleton).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "singleton"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "void",
    "signature": "public void setSingleton(boolean singleton)",
    "source_code": "\tpublic void setSingleton(boolean singleton) {\n\t\tthis.singleton = singleton;\n\t}"
  },
  "org.springframework.beans.factory.config.YamlProcessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Base class for YAML factories.\n *\n * <p>Requires SnakeYAML 1.18 or higher, as of Spring Framework 5.0.6.\n *\n * @author Dave Syer\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Brian Clozel\n * @since 4.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "signature": "public class YamlProcessor",
    "source_code": "public abstract class YamlProcessor {\n\n\tprivate final Log logger = LogFactory.getLog(getClass());\n\n\tprivate ResolutionMethod resolutionMethod = ResolutionMethod.OVERRIDE;\n\n\tprivate Resource[] resources = new Resource[0];\n\n\tprivate List<DocumentMatcher> documentMatchers = Collections.emptyList();\n\n\tprivate boolean matchDefault = true;\n\n\tprivate Set<String> supportedTypes = Collections.emptySet();\n\n\n\t/**\n\t * A map of document matchers allowing callers to selectively use only\n\t * some of the documents in a YAML resource. In YAML documents are\n\t * separated by {@code ---} lines, and each document is converted\n\t * to properties before the match is made. E.g.\n\t * <pre class=\"code\">\n\t * environment: dev\n\t * url: https://dev.bar.com\n\t * name: Developer Setup\n\t * ---\n\t * environment: prod\n\t * url:https://foo.bar.com\n\t * name: My Cool App\n\t * </pre>\n\t * when mapped with\n\t * <pre class=\"code\">\n\t * setDocumentMatchers(properties -&gt;\n\t *     (\"prod\".equals(properties.getProperty(\"environment\")) ? MatchStatus.FOUND : MatchStatus.NOT_FOUND));\n\t * </pre>\n\t * would end up as\n\t * <pre class=\"code\">\n\t * environment=prod\n\t * url=https://foo.bar.com\n\t * name=My Cool App\n\t * </pre>\n\t */\n\tpublic void setDocumentMatchers(DocumentMatcher... matchers) {\n\t\tthis.documentMatchers = List.of(matchers);\n\t}\n\n\t/**\n\t * Flag indicating that a document for which all the\n\t * {@link #setDocumentMatchers(DocumentMatcher...) document matchers} abstain will\n\t * nevertheless match. Default is {@code true}.\n\t */\n\tpublic void setMatchDefault(boolean matchDefault) {\n\t\tthis.matchDefault = matchDefault;\n\t}\n\n\t/**\n\t * Method to use for resolving resources. Each resource will be converted to a Map,\n\t * so this property is used to decide which map entries to keep in the final output\n\t * from this factory. Default is {@link ResolutionMethod#OVERRIDE}.\n\t */\n\tpublic void setResolutionMethod(ResolutionMethod resolutionMethod) {\n\t\tAssert.notNull(resolutionMethod, \"ResolutionMethod must not be null\");\n\t\tthis.resolutionMethod = resolutionMethod;\n\t}\n\n\t/**\n\t * Set locations of YAML {@link Resource resources} to be loaded.\n\t * @see ResolutionMethod\n\t */\n\tpublic void setResources(Resource... resources) {\n\t\tthis.resources = resources;\n\t}\n\n\t/**\n\t * Set the supported types that can be loaded from YAML documents.\n\t * <p>If no supported types are configured, only Java standard classes\n\t * (as defined in {@link org.yaml.snakeyaml.constructor.SafeConstructor})\n\t * encountered in YAML documents will be supported.\n\t * If an unsupported type is encountered, an {@link IllegalStateException}\n\t * will be thrown when the corresponding YAML node is processed.\n\t * @param supportedTypes the supported types, or an empty array to clear the\n\t * supported types\n\t * @since 5.1.16\n\t * @see #createYaml()\n\t */\n\tpublic void setSupportedTypes(Class<?>... supportedTypes) {\n\t\tif (ObjectUtils.isEmpty(supportedTypes)) {\n\t\t\tthis.supportedTypes = Collections.emptySet();\n\t\t}\n\t\telse {\n\t\t\tAssert.noNullElements(supportedTypes, \"'supportedTypes' must not contain null elements\");\n\t\t\tthis.supportedTypes = Arrays.stream(supportedTypes).map(Class::getName)\n\t\t\t\t\t.collect(Collectors.toUnmodifiableSet());\n\t\t}\n\t}\n\n\t/**\n\t * Provide an opportunity for subclasses to process the Yaml parsed from the supplied\n\t * resources. Each resource is parsed in turn and the documents inside checked against\n\t * the {@link #setDocumentMatchers(DocumentMatcher...) matchers}. If a document\n\t * matches it is passed into the callback, along with its representation as Properties.\n\t * Depending on the {@link #setResolutionMethod(ResolutionMethod)} not all the\n\t * documents will be parsed.\n\t * @param callback a callback to delegate to once matching documents are found\n\t * @see #createYaml()\n\t */\n\tprotected void process(MatchCallback callback) {\n\t\tYaml yaml = createYaml();\n\t\tfor (Resource resource : this.resources) {\n\t\t\tboolean found = process(callback, yaml, resource);\n\t\t\tif (this.resolutionMethod == ResolutionMethod.FIRST_FOUND && found) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Create the {@link Yaml} instance to use.\n\t * <p>The default implementation sets the \"allowDuplicateKeys\" flag to {@code false},\n\t * enabling built-in duplicate key handling in SnakeYAML 1.18+.\n\t * <p>As of Spring Framework 5.1.16, if custom {@linkplain #setSupportedTypes\n\t * supported types} have been configured, the default implementation creates\n\t * a {@code Yaml} instance that filters out unsupported types encountered in\n\t * YAML documents. If an unsupported type is encountered, an\n\t * {@link IllegalStateException} will be thrown when the node is processed.\n\t * @see LoaderOptions#setAllowDuplicateKeys(boolean)\n\t */\n\tprotected Yaml createYaml() {\n\t\tLoaderOptions loaderOptions = new LoaderOptions();\n\t\tloaderOptions.setAllowDuplicateKeys(false);\n\t\tDumperOptions dumperOptions = new DumperOptions();\n\t\treturn new Yaml(new FilteringConstructor(loaderOptions), new Representer(dumperOptions),\n\t\t\t\tdumperOptions, loaderOptions);\n\t}\n\n\tprivate boolean process(MatchCallback callback, Yaml yaml, Resource resource) {\n\t\tint count = 0;\n\t\ttry {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Loading from YAML: \" + resource);\n\t\t\t}\n\t\t\ttry (Reader reader = new UnicodeReader(resource.getInputStream())) {\n\t\t\t\tfor (Object object : yaml.loadAll(reader)) {\n\t\t\t\t\tif (object != null && process(asMap(object), callback)) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tif (this.resolutionMethod == ResolutionMethod.FIRST_FOUND) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Loaded \" + count + \" document\" + (count > 1 ? \"s\" : \"\") +\n\t\t\t\t\t\t\t\" from YAML resource: \" + resource);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\thandleProcessError(resource, ex);\n\t\t}\n\t\treturn (count > 0);\n\t}\n\n\tprivate void handleProcessError(Resource resource, IOException ex) {\n\t\tif (this.resolutionMethod != ResolutionMethod.FIRST_FOUND &&\n\t\t\t\tthis.resolutionMethod != ResolutionMethod.OVERRIDE_AND_IGNORE) {\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t\tif (logger.isWarnEnabled()) {\n\t\t\tlogger.warn(\"Could not load map from \" + resource + \": \" + ex.getMessage());\n\t\t}\n\t}\n\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tprivate Map<String, Object> asMap(Object object) {\n\t\t// YAML can have numbers as keys\n\t\tMap<String, Object> result = new LinkedHashMap<>();\n\t\tif (!(object instanceof Map map)) {\n\t\t\t// A document can be a text literal\n\t\t\tresult.put(\"document\", object);\n\t\t\treturn result;\n\t\t}\n\n\t\tmap.forEach((key, value) -> {\n\t\t\tif (value instanceof Map) {\n\t\t\t\tvalue = asMap(value);\n\t\t\t}\n\t\t\tif (key instanceof CharSequence) {\n\t\t\t\tresult.put(key.toString(), value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// It has to be a map key in this case\n\t\t\t\tresult.put(\"[\" + key.toString() + \"]\", value);\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}\n\n\tprivate boolean process(Map<String, Object> map, MatchCallback callback) {\n\t\tProperties properties = CollectionFactory.createStringAdaptingProperties();\n\t\tproperties.putAll(getFlattenedMap(map));\n\n\t\tif (this.documentMatchers.isEmpty()) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Merging document (no matchers set): \" + map);\n\t\t\t}\n\t\t\tcallback.process(properties, map);\n\t\t\treturn true;\n\t\t}\n\n\t\tMatchStatus result = MatchStatus.ABSTAIN;\n\t\tfor (DocumentMatcher matcher : this.documentMatchers) {\n\t\t\tMatchStatus match = matcher.matches(properties);\n\t\t\tresult = MatchStatus.getMostSpecific(match, result);\n\t\t\tif (match == MatchStatus.FOUND) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Matched document with document matcher: \" + properties);\n\t\t\t\t}\n\t\t\t\tcallback.process(properties, map);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (result == MatchStatus.ABSTAIN && this.matchDefault) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Matched document with default matcher: \" + map);\n\t\t\t}\n\t\t\tcallback.process(properties, map);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Unmatched document: \" + map);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return a flattened version of the given map, recursively following any nested Map\n\t * or Collection values. Entries from the resulting map retain the same order as the\n\t * source. When called with the Map from a {@link MatchCallback} the result will\n\t * contain the same values as the {@link MatchCallback} Properties.\n\t * @param source the source map\n\t * @return a flattened map\n\t * @since 4.1.3\n\t */\n\tprotected final Map<String, Object> getFlattenedMap(Map<String, Object> source) {\n\t\tMap<String, Object> result = new LinkedHashMap<>();\n\t\tbuildFlattenedMap(result, source, null);\n\t\treturn result;\n\t}\n\n\t@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n\tprivate void buildFlattenedMap(Map<String, Object> result, Map<String, Object> source, @Nullable String path) {\n\t\tsource.forEach((key, value) -> {\n\t\t\tif (StringUtils.hasText(path)) {\n\t\t\t\tif (key.startsWith(\"[\")) {\n\t\t\t\t\tkey = path + key;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tkey = path + '.' + key;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (value instanceof String) {\n\t\t\t\tresult.put(key, value);\n\t\t\t}\n\t\t\telse if (value instanceof Map map) {\n\t\t\t\t// Need a compound key\n\t\t\t\tbuildFlattenedMap(result, map, key);\n\t\t\t}\n\t\t\telse if (value instanceof Collection collection) {\n\t\t\t\t// Need a compound key\n\t\t\t\tif (collection.isEmpty()) {\n\t\t\t\t\tresult.put(key, \"\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tfor (Object object : collection) {\n\t\t\t\t\t\tbuildFlattenedMap(result, Collections.singletonMap(\n\t\t\t\t\t\t\t\t\"[\" + (count++) + \"]\", object), key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.put(key, (value != null ? value : \"\"));\n\t\t\t}\n\t\t});\n\t}\n\n\n\t/**\n\t * Callback interface used to process the YAML parsing results.\n\t */\n\t@FunctionalInterface\n\tpublic interface MatchCallback {\n\n\t\t/**\n\t\t * Process the given representation of the parsing results.\n\t\t * @param properties the properties to process (as a flattened\n\t\t * representation with indexed keys in case of a collection or map)\n\t\t * @param map the result map (preserving the original value structure\n\t\t * in the YAML document)\n\t\t */\n\t\tvoid process(Properties properties, Map<String, Object> map);\n\t}\n\n\n\t/**\n\t * Strategy interface used to test if properties match.\n\t */\n\t@FunctionalInterface\n\tpublic interface DocumentMatcher {\n\n\t\t/**\n\t\t * Test if the given properties match.\n\t\t * @param properties the properties to test\n\t\t * @return the status of the match\n\t\t */\n\t\tMatchStatus matches(Properties properties);\n\t}\n\n\n\t/**\n\t * Status returned from {@link DocumentMatcher#matches(java.util.Properties)}.\n\t */\n\tpublic enum MatchStatus {\n\n\t\t/**\n\t\t * A match was found.\n\t\t */\n\t\tFOUND,\n\n\t\t/**\n\t\t * No match was found.\n\t\t */\n\t\tNOT_FOUND,\n\n\t\t/**\n\t\t * The matcher should not be considered.\n\t\t */\n\t\tABSTAIN;\n\n\t\t/**\n\t\t * Compare two {@link MatchStatus} items, returning the most specific status.\n\t\t */\n\t\tpublic static MatchStatus getMostSpecific(MatchStatus a, MatchStatus b) {\n\t\t\treturn (a.ordinal() < b.ordinal() ? a : b);\n\t\t}\n\t}\n\n\n\t/**\n\t * Method to use for resolving resources.\n\t */\n\tpublic enum ResolutionMethod {\n\n\t\t/**\n\t\t * Replace values from earlier in the list.\n\t\t */\n\t\tOVERRIDE,\n\n\t\t/**\n\t\t * Replace values from earlier in the list, ignoring any failures.\n\t\t */\n\t\tOVERRIDE_AND_IGNORE,\n\n\t\t/**\n\t\t * Take the first resource in the list that exists and use just that.\n\t\t */\n\t\tFIRST_FOUND\n\t}\n\n\n\t/**\n\t * {@link Constructor} that supports filtering of unsupported types.\n\t * <p>If an unsupported type is encountered in a YAML document, an\n\t * {@link IllegalStateException} will be thrown from {@link #getClassForName}.\n\t */\n\tprivate class FilteringConstructor extends Constructor {\n\n\t\tFilteringConstructor(LoaderOptions loaderOptions) {\n\t\t\tsuper(loaderOptions);\n\t\t}\n\n\t\t@Override\n\t\tprotected Class<?> getClassForName(String name) throws ClassNotFoundException {\n\t\t\tAssert.state(YamlProcessor.this.supportedTypes.contains(name),\n\t\t\t\t\t() -> \"Unsupported type encountered in YAML document: \" + name);\n\t\t\treturn super.getClassForName(name);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.beans.factory.config.YamlProcessor#createYaml()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the {@link Yaml} instance to use.\n\t * <p>The default implementation sets the \"allowDuplicateKeys\" flag to {@code false},\n\t * enabling built-in duplicate key handling in SnakeYAML 1.18+.\n\t * <p>As of Spring Framework 5.1.16, if custom {@linkplain #setSupportedTypes\n\t * supported types} have been configured, the default implementation creates\n\t * a {@code Yaml} instance that filters out unsupported types encountered in\n\t * YAML documents. If an unsupported type is encountered, an\n\t * {@link IllegalStateException} will be thrown when the node is processed.\n\t * @see LoaderOptions#setAllowDuplicateKeys(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "Yaml",
    "signature": "protected Yaml createYaml()",
    "source_code": "\tprotected Yaml createYaml() {\n\t\tLoaderOptions loaderOptions = new LoaderOptions();\n\t\tloaderOptions.setAllowDuplicateKeys(false);\n\t\tDumperOptions dumperOptions = new DumperOptions();\n\t\treturn new Yaml(new FilteringConstructor(loaderOptions), new Representer(dumperOptions),\n\t\t\t\tdumperOptions, loaderOptions);\n\t}"
  },
  "org.springframework.beans.factory.config.YamlProcessor#getFlattenedMap(Map<String,source)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a flattened version of the given map, recursively following any nested Map\n\t * or Collection values. Entries from the resulting map retain the same order as the\n\t * source. When called with the Map from a {@link MatchCallback} the result will\n\t * contain the same values as the {@link MatchCallback} Properties.\n\t * @param source the source map\n\t * @return a flattened map\n\t * @since 4.1.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "Object>",
    "signature": "protected Object> getFlattenedMap(Map<String, Object> source)",
    "source_code": "\tprotected final Map<String, Object> getFlattenedMap(Map<String, Object> source) {\n\t\tMap<String, Object> result = new LinkedHashMap<>();\n\t\tbuildFlattenedMap(result, source, null);\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.config.YamlProcessor#getMostSpecific(a,b)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Compare two {@link MatchStatus} items, returning the most specific status.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "a",
      "b"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "MatchStatus",
    "signature": "public MatchStatus getMostSpecific(MatchStatus a, MatchStatus b)",
    "source_code": "\t\tpublic static MatchStatus getMostSpecific(MatchStatus a, MatchStatus b) {\n\t\t\treturn (a.ordinal() < b.ordinal() ? a : b);\n\t\t}"
  },
  "org.springframework.beans.factory.config.YamlProcessor#process(callback)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide an opportunity for subclasses to process the Yaml parsed from the supplied\n\t * resources. Each resource is parsed in turn and the documents inside checked against\n\t * the {@link #setDocumentMatchers(DocumentMatcher...) matchers}. If a document\n\t * matches it is passed into the callback, along with its representation as Properties.\n\t * Depending on the {@link #setResolutionMethod(ResolutionMethod)} not all the\n\t * documents will be parsed.\n\t * @param callback a callback to delegate to once matching documents are found\n\t * @see #createYaml()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "protected void process(MatchCallback callback)",
    "source_code": "\tprotected void process(MatchCallback callback) {\n\t\tYaml yaml = createYaml();\n\t\tfor (Resource resource : this.resources) {\n\t\t\tboolean found = process(callback, yaml, resource);\n\t\t\tif (this.resolutionMethod == ResolutionMethod.FIRST_FOUND && found) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.YamlProcessor#setDocumentMatchers(matchers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A map of document matchers allowing callers to selectively use only\n\t * some of the documents in a YAML resource. In YAML documents are\n\t * separated by {@code ---} lines, and each document is converted\n\t * to properties before the match is made. E.g.\n\t * <pre class=\"code\">\n\t * environment: dev\n\t * url: https://dev.bar.com\n\t * name: Developer Setup\n\t * ---\n\t * environment: prod\n\t * url:https://foo.bar.com\n\t * name: My Cool App\n\t * </pre>\n\t * when mapped with\n\t * <pre class=\"code\">\n\t * setDocumentMatchers(properties -&gt;\n\t *     (\"prod\".equals(properties.getProperty(\"environment\")) ? MatchStatus.FOUND : MatchStatus.NOT_FOUND));\n\t * </pre>\n\t * would end up as\n\t * <pre class=\"code\">\n\t * environment=prod\n\t * url=https://foo.bar.com\n\t * name=My Cool App\n\t * </pre>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "matchers"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void setDocumentMatchers(DocumentMatcher... matchers)",
    "source_code": "\tpublic void setDocumentMatchers(DocumentMatcher... matchers) {\n\t\tthis.documentMatchers = List.of(matchers);\n\t}"
  },
  "org.springframework.beans.factory.config.YamlProcessor#setMatchDefault(matchDefault)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Flag indicating that a document for which all the\n\t * {@link #setDocumentMatchers(DocumentMatcher...) document matchers} abstain will\n\t * nevertheless match. Default is {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "matchDefault"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void setMatchDefault(boolean matchDefault)",
    "source_code": "\tpublic void setMatchDefault(boolean matchDefault) {\n\t\tthis.matchDefault = matchDefault;\n\t}"
  },
  "org.springframework.beans.factory.config.YamlProcessor#setResolutionMethod(resolutionMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Method to use for resolving resources. Each resource will be converted to a Map,\n\t * so this property is used to decide which map entries to keep in the final output\n\t * from this factory. Default is {@link ResolutionMethod#OVERRIDE}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolutionMethod"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "void",
    "signature": "public void setResolutionMethod(ResolutionMethod resolutionMethod)",
    "source_code": "\tpublic void setResolutionMethod(ResolutionMethod resolutionMethod) {\n\t\tAssert.notNull(resolutionMethod, \"ResolutionMethod must not be null\");\n\t\tthis.resolutionMethod = resolutionMethod;\n\t}"
  },
  "org.springframework.beans.factory.config.YamlProcessor#setResources(resources)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set locations of YAML {@link Resource resources} to be loaded.\n\t * @see ResolutionMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resources"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void setResources(Resource... resources)",
    "source_code": "\tpublic void setResources(Resource... resources) {\n\t\tthis.resources = resources;\n\t}"
  },
  "org.springframework.beans.factory.config.YamlProcessor#setSupportedTypes(supportedTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the supported types that can be loaded from YAML documents.\n\t * <p>If no supported types are configured, only Java standard classes\n\t * (as defined in {@link org.yaml.snakeyaml.constructor.SafeConstructor})\n\t * encountered in YAML documents will be supported.\n\t * If an unsupported type is encountered, an {@link IllegalStateException}\n\t * will be thrown when the corresponding YAML node is processed.\n\t * @param supportedTypes the supported types, or an empty array to clear the\n\t * supported types\n\t * @since 5.1.16\n\t * @see #createYaml()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "supportedTypes"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "void",
    "signature": "public void setSupportedTypes(Class<?>... supportedTypes)",
    "source_code": "\tpublic void setSupportedTypes(Class<?>... supportedTypes) {\n\t\tif (ObjectUtils.isEmpty(supportedTypes)) {\n\t\t\tthis.supportedTypes = Collections.emptySet();\n\t\t}\n\t\telse {\n\t\t\tAssert.noNullElements(supportedTypes, \"'supportedTypes' must not contain null elements\");\n\t\t\tthis.supportedTypes = Arrays.stream(supportedTypes).map(Class::getName)\n\t\t\t\t\t.collect(Collectors.toUnmodifiableSet());\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.logger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Logger available to subclasses. */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.beans.factory.parsing.BeanComponentDefinition": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * ComponentDefinition based on a standard BeanDefinition, exposing the given bean\n * definition as well as inner bean definitions and bean references for the given bean.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @since 2.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class BeanComponentDefinition",
    "source_code": "public class BeanComponentDefinition extends BeanDefinitionHolder implements ComponentDefinition {\n\n\tprivate final BeanDefinition[] innerBeanDefinitions;\n\n\tprivate final BeanReference[] beanReferences;\n\n\n\t/**\n\t * Create a new BeanComponentDefinition for the given bean.\n\t * @param beanDefinition the BeanDefinition\n\t * @param beanName the name of the bean\n\t */\n\tpublic BeanComponentDefinition(BeanDefinition beanDefinition, String beanName) {\n\t\tthis(new BeanDefinitionHolder(beanDefinition, beanName));\n\t}\n\n\t/**\n\t * Create a new BeanComponentDefinition for the given bean.\n\t * @param beanDefinition the BeanDefinition\n\t * @param beanName the name of the bean\n\t * @param aliases alias names for the bean, or {@code null} if none\n\t */\n\tpublic BeanComponentDefinition(BeanDefinition beanDefinition, String beanName, @Nullable String[] aliases) {\n\t\tthis(new BeanDefinitionHolder(beanDefinition, beanName, aliases));\n\t}\n\n\t/**\n\t * Create a new BeanComponentDefinition for the given bean.\n\t * @param beanDefinitionHolder the BeanDefinitionHolder encapsulating\n\t * the bean definition as well as the name of the bean\n\t */\n\tpublic BeanComponentDefinition(BeanDefinitionHolder beanDefinitionHolder) {\n\t\tsuper(beanDefinitionHolder);\n\n\t\tList<BeanDefinition> innerBeans = new ArrayList<>();\n\t\tList<BeanReference> references = new ArrayList<>();\n\t\tPropertyValues propertyValues = beanDefinitionHolder.getBeanDefinition().getPropertyValues();\n\t\tfor (PropertyValue propertyValue : propertyValues.getPropertyValues()) {\n\t\t\tObject value = propertyValue.getValue();\n\t\t\tif (value instanceof BeanDefinitionHolder beanDefHolder) {\n\t\t\t\tinnerBeans.add(beanDefHolder.getBeanDefinition());\n\t\t\t}\n\t\t\telse if (value instanceof BeanDefinition beanDef) {\n\t\t\t\tinnerBeans.add(beanDef);\n\t\t\t}\n\t\t\telse if (value instanceof BeanReference beanRef) {\n\t\t\t\treferences.add(beanRef);\n\t\t\t}\n\t\t}\n\t\tthis.innerBeanDefinitions = innerBeans.toArray(new BeanDefinition[0]);\n\t\tthis.beanReferences = references.toArray(new BeanReference[0]);\n\t}\n\n\n\t@Override\n\tpublic String getName() {\n\t\treturn getBeanName();\n\t}\n\n\t@Override\n\tpublic String getDescription() {\n\t\treturn getShortDescription();\n\t}\n\n\t@Override\n\tpublic BeanDefinition[] getBeanDefinitions() {\n\t\treturn new BeanDefinition[] {getBeanDefinition()};\n\t}\n\n\t@Override\n\tpublic BeanDefinition[] getInnerBeanDefinitions() {\n\t\treturn this.innerBeanDefinitions;\n\t}\n\n\t@Override\n\tpublic BeanReference[] getBeanReferences() {\n\t\treturn this.beanReferences;\n\t}\n\n\n\t/**\n\t * This implementation returns this ComponentDefinition's description.\n\t * @see #getDescription()\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn getDescription();\n\t}\n\n\t/**\n\t * This implementation expects the other object to be of type BeanComponentDefinition\n\t * as well, in addition to the superclass's equality requirements.\n\t */\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof BeanComponentDefinition && super.equals(other)));\n\t}\n\n}"
  },
  "org.springframework.beans.factory.parsing.BeanComponentDefinition#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation expects the other object to be of type BeanComponentDefinition\n\t * as well, in addition to the superclass's equality requirements.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof BeanComponentDefinition && super.equals(other)));\n\t}"
  },
  "org.springframework.beans.factory.parsing.BeanComponentDefinition#getBeanDefinitions()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "BeanDefinition[]",
    "signature": "public BeanDefinition[] getBeanDefinitions()",
    "source_code": "\tpublic BeanDefinition[] getBeanDefinitions() {\n\t\treturn new BeanDefinition[] {getBeanDefinition()};\n\t}"
  },
  "org.springframework.beans.factory.parsing.BeanComponentDefinition#getBeanReferences()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "BeanReference[]",
    "signature": "public BeanReference[] getBeanReferences()",
    "source_code": "\tpublic BeanReference[] getBeanReferences() {\n\t\treturn this.beanReferences;\n\t}"
  },
  "org.springframework.beans.factory.parsing.BeanComponentDefinition#getDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "String",
    "signature": "public String getDescription()",
    "source_code": "\tpublic String getDescription() {\n\t\treturn getShortDescription();\n\t}"
  },
  "org.springframework.beans.factory.parsing.BeanComponentDefinition#getInnerBeanDefinitions()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "BeanDefinition[]",
    "signature": "public BeanDefinition[] getInnerBeanDefinitions()",
    "source_code": "\tpublic BeanDefinition[] getInnerBeanDefinitions() {\n\t\treturn this.innerBeanDefinitions;\n\t}"
  },
  "org.springframework.beans.factory.parsing.BeanComponentDefinition#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "\tpublic String getName() {\n\t\treturn getBeanName();\n\t}"
  },
  "org.springframework.beans.factory.parsing.BeanComponentDefinition#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns this ComponentDefinition's description.\n\t * @see #getDescription()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getDescription();\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the underlying BeanDefinition.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof BeanDefinitionResource that &&\n\t\t\t\tthis.beanDefinition.equals(that.beanDefinition)));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#exists()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "boolean",
    "signature": "public boolean exists()",
    "source_code": "\tpublic boolean exists() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBeanDefinition()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the wrapped BeanDefinition object.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "BeanDefinition",
    "signature": "public BeanDefinition getBeanDefinition()",
    "source_code": "\tpublic final BeanDefinition getBeanDefinition() {\n\t\treturn this.beanDefinition;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "String",
    "signature": "public String getDescription()",
    "source_code": "\tpublic String getDescription() {\n\t\treturn \"BeanDefinition defined in \" + this.beanDefinition.getResourceDescription();\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getInputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "InputStream",
    "signature": "public InputStream getInputStream()",
    "source_code": "\tpublic InputStream getInputStream() throws IOException {\n\t\tthrow new FileNotFoundException(\n\t\t\t\t\"Resource cannot be opened because it points to \" + getDescription());\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns the hash code of the underlying BeanDefinition.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.beanDefinition.hashCode();\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isReadable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "boolean",
    "signature": "public boolean isReadable()",
    "source_code": "\tpublic boolean isReadable() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinitionReader": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for bean definition readers which implement\n * the {@link BeanDefinitionReader} interface.\n *\n * <p>Provides common properties like the bean factory to work on\n * and the class loader to use for loading bean classes.\n *\n * @author Juergen Hoeller\n * @author Chris Beams\n * @since 11.12.2003\n * @see BeanDefinitionReaderUtils\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class AbstractBeanDefinitionReader",
    "source_code": "public abstract class AbstractBeanDefinitionReader implements BeanDefinitionReader, EnvironmentCapable {\n\n\t/** Logger available to subclasses. */\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate final BeanDefinitionRegistry registry;\n\n\t@Nullable\n\tprivate ResourceLoader resourceLoader;\n\n\t@Nullable\n\tprivate ClassLoader beanClassLoader;\n\n\tprivate Environment environment;\n\n\tprivate BeanNameGenerator beanNameGenerator = DefaultBeanNameGenerator.INSTANCE;\n\n\n\t/**\n\t * Create a new AbstractBeanDefinitionReader for the given bean factory.\n\t * <p>If the passed-in bean factory does not only implement the BeanDefinitionRegistry\n\t * interface but also the ResourceLoader interface, it will be used as default\n\t * ResourceLoader as well. This will usually be the case for\n\t * {@link org.springframework.context.ApplicationContext} implementations.\n\t * <p>If given a plain BeanDefinitionRegistry, the default ResourceLoader will be a\n\t * {@link org.springframework.core.io.support.PathMatchingResourcePatternResolver}.\n\t * <p>If the passed-in bean factory also implements {@link EnvironmentCapable} its\n\t * environment will be used by this reader.  Otherwise, the reader will initialize and\n\t * use a {@link StandardEnvironment}. All ApplicationContext implementations are\n\t * EnvironmentCapable, while normal BeanFactory implementations are not.\n\t * @param registry the BeanFactory to load bean definitions into,\n\t * in the form of a BeanDefinitionRegistry\n\t * @see #setResourceLoader\n\t * @see #setEnvironment\n\t */\n\tprotected AbstractBeanDefinitionReader(BeanDefinitionRegistry registry) {\n\t\tAssert.notNull(registry, \"BeanDefinitionRegistry must not be null\");\n\t\tthis.registry = registry;\n\n\t\t// Determine ResourceLoader to use.\n\t\tif (this.registry instanceof ResourceLoader _resourceLoader) {\n\t\t\tthis.resourceLoader = _resourceLoader;\n\t\t}\n\t\telse {\n\t\t\tthis.resourceLoader = new PathMatchingResourcePatternResolver();\n\t\t}\n\n\t\t// Inherit Environment if possible\n\t\tif (this.registry instanceof EnvironmentCapable environmentCapable) {\n\t\t\tthis.environment = environmentCapable.getEnvironment();\n\t\t}\n\t\telse {\n\t\t\tthis.environment = new StandardEnvironment();\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic final BeanDefinitionRegistry getRegistry() {\n\t\treturn this.registry;\n\t}\n\n\t/**\n\t * Set the ResourceLoader to use for resource locations.\n\t * If specifying a ResourcePatternResolver, the bean definition reader\n\t * will be capable of resolving resource patterns to Resource arrays.\n\t * <p>Default is PathMatchingResourcePatternResolver, also capable of\n\t * resource pattern resolving through the ResourcePatternResolver interface.\n\t * <p>Setting this to {@code null} suggests that absolute resource loading\n\t * is not available for this bean definition reader.\n\t * @see org.springframework.core.io.support.ResourcePatternResolver\n\t * @see org.springframework.core.io.support.PathMatchingResourcePatternResolver\n\t */\n\tpublic void setResourceLoader(@Nullable ResourceLoader resourceLoader) {\n\t\tthis.resourceLoader = resourceLoader;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic ResourceLoader getResourceLoader() {\n\t\treturn this.resourceLoader;\n\t}\n\n\t/**\n\t * Set the ClassLoader to use for bean classes.\n\t * <p>Default is {@code null}, which suggests to not load bean classes\n\t * eagerly but rather to just register bean definitions with class names,\n\t * with the corresponding Classes to be resolved later (or never).\n\t * @see Thread#getContextClassLoader()\n\t */\n\tpublic void setBeanClassLoader(@Nullable ClassLoader beanClassLoader) {\n\t\tthis.beanClassLoader = beanClassLoader;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic ClassLoader getBeanClassLoader() {\n\t\treturn this.beanClassLoader;\n\t}\n\n\t/**\n\t * Set the Environment to use when reading bean definitions. Most often used\n\t * for evaluating profile information to determine which bean definitions\n\t * should be read and which should be omitted.\n\t */\n\tpublic void setEnvironment(Environment environment) {\n\t\tAssert.notNull(environment, \"Environment must not be null\");\n\t\tthis.environment = environment;\n\t}\n\n\t@Override\n\tpublic Environment getEnvironment() {\n\t\treturn this.environment;\n\t}\n\n\t/**\n\t * Set the BeanNameGenerator to use for anonymous beans\n\t * (without explicit bean name specified).\n\t * <p>Default is a {@link DefaultBeanNameGenerator}.\n\t */\n\tpublic void setBeanNameGenerator(@Nullable BeanNameGenerator beanNameGenerator) {\n\t\tthis.beanNameGenerator = (beanNameGenerator != null ? beanNameGenerator : DefaultBeanNameGenerator.INSTANCE);\n\t}\n\n\t@Override\n\tpublic BeanNameGenerator getBeanNameGenerator() {\n\t\treturn this.beanNameGenerator;\n\t}\n\n\n\t@Override\n\tpublic int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException {\n\t\tAssert.notNull(resources, \"Resource array must not be null\");\n\t\tint count = 0;\n\t\tfor (Resource resource : resources) {\n\t\t\tcount += loadBeanDefinitions(resource);\n\t\t}\n\t\treturn count;\n\t}\n\n\t@Override\n\tpublic int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {\n\t\treturn loadBeanDefinitions(location, null);\n\t}\n\n\t/**\n\t * Load bean definitions from the specified resource location.\n\t * <p>The location can also be a location pattern, provided that the\n\t * ResourceLoader of this bean definition reader is a ResourcePatternResolver.\n\t * @param location the resource location, to be loaded with the ResourceLoader\n\t * (or ResourcePatternResolver) of this bean definition reader\n\t * @param actualResources a Set to be filled with the actual Resource objects\n\t * that have been resolved during the loading process. May be {@code null}\n\t * to indicate that the caller is not interested in those Resource objects.\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t * @see #getResourceLoader()\n\t * @see #loadBeanDefinitions(org.springframework.core.io.Resource)\n\t * @see #loadBeanDefinitions(org.springframework.core.io.Resource[])\n\t */\n\tpublic int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources) throws BeanDefinitionStoreException {\n\t\tResourceLoader resourceLoader = getResourceLoader();\n\t\tif (resourceLoader == null) {\n\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\"Cannot load bean definitions from location [\" + location + \"]: no ResourceLoader available\");\n\t\t}\n\n\t\tif (resourceLoader instanceof ResourcePatternResolver resourcePatternResolver) {\n\t\t\t// Resource pattern matching available.\n\t\t\ttry {\n\t\t\t\tResource[] resources = resourcePatternResolver.getResources(location);\n\t\t\t\tint count = loadBeanDefinitions(resources);\n\t\t\t\tif (actualResources != null) {\n\t\t\t\t\tCollections.addAll(actualResources, resources);\n\t\t\t\t}\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Loaded \" + count + \" bean definitions from location pattern [\" + location + \"]\");\n\t\t\t\t}\n\t\t\t\treturn count;\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\t\"Could not resolve bean definition resource pattern [\" + location + \"]\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Can only load single resources by absolute URL.\n\t\t\tResource resource = resourceLoader.getResource(location);\n\t\t\tint count = loadBeanDefinitions(resource);\n\t\t\tif (actualResources != null) {\n\t\t\t\tactualResources.add(resource);\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Loaded \" + count + \" bean definitions from location [\" + location + \"]\");\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException {\n\t\tAssert.notNull(locations, \"Location array must not be null\");\n\t\tint count = 0;\n\t\tfor (String location : locations) {\n\t\t\tcount += loadBeanDefinitions(location);\n\t\t}\n\t\treturn count;\n\t}\n\n}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinitionReader#getBeanClassLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "ClassLoader",
    "signature": "public ClassLoader getBeanClassLoader()",
    "source_code": "\tpublic ClassLoader getBeanClassLoader() {\n\t\treturn this.beanClassLoader;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinitionReader#getBeanNameGenerator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "BeanNameGenerator",
    "signature": "public BeanNameGenerator getBeanNameGenerator()",
    "source_code": "\tpublic BeanNameGenerator getBeanNameGenerator() {\n\t\treturn this.beanNameGenerator;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinitionReader#getEnvironment()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "Environment",
    "signature": "public Environment getEnvironment()",
    "source_code": "\tpublic Environment getEnvironment() {\n\t\treturn this.environment;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinitionReader#getRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "BeanDefinitionRegistry",
    "signature": "public BeanDefinitionRegistry getRegistry()",
    "source_code": "\tpublic final BeanDefinitionRegistry getRegistry() {\n\t\treturn this.registry;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinitionReader#getResourceLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "ResourceLoader",
    "signature": "public ResourceLoader getResourceLoader()",
    "source_code": "\tpublic ResourceLoader getResourceLoader() {\n\t\treturn this.resourceLoader;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinitionReader#loadBeanDefinitions(location)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "int",
    "signature": "public int loadBeanDefinitions(String location)",
    "source_code": "\tpublic int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {\n\t\treturn loadBeanDefinitions(location, null);\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinitionReader#loadBeanDefinitions(location,actualResources)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load bean definitions from the specified resource location.\n\t * <p>The location can also be a location pattern, provided that the\n\t * ResourceLoader of this bean definition reader is a ResourcePatternResolver.\n\t * @param location the resource location, to be loaded with the ResourceLoader\n\t * (or ResourcePatternResolver) of this bean definition reader\n\t * @param actualResources a Set to be filled with the actual Resource objects\n\t * that have been resolved during the loading process. May be {@code null}\n\t * to indicate that the caller is not interested in those Resource objects.\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t * @see #getResourceLoader()\n\t * @see #loadBeanDefinitions(org.springframework.core.io.Resource)\n\t * @see #loadBeanDefinitions(org.springframework.core.io.Resource[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "actualResources"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "int",
    "signature": "public int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources)",
    "source_code": "\tpublic int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources) throws BeanDefinitionStoreException {\n\t\tResourceLoader resourceLoader = getResourceLoader();\n\t\tif (resourceLoader == null) {\n\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\"Cannot load bean definitions from location [\" + location + \"]: no ResourceLoader available\");\n\t\t}\n\n\t\tif (resourceLoader instanceof ResourcePatternResolver resourcePatternResolver) {\n\t\t\t// Resource pattern matching available.\n\t\t\ttry {\n\t\t\t\tResource[] resources = resourcePatternResolver.getResources(location);\n\t\t\t\tint count = loadBeanDefinitions(resources);\n\t\t\t\tif (actualResources != null) {\n\t\t\t\t\tCollections.addAll(actualResources, resources);\n\t\t\t\t}\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Loaded \" + count + \" bean definitions from location pattern [\" + location + \"]\");\n\t\t\t\t}\n\t\t\t\treturn count;\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\t\"Could not resolve bean definition resource pattern [\" + location + \"]\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Can only load single resources by absolute URL.\n\t\t\tResource resource = resourceLoader.getResource(location);\n\t\t\tint count = loadBeanDefinitions(resource);\n\t\t\tif (actualResources != null) {\n\t\t\t\tactualResources.add(resource);\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Loaded \" + count + \" bean definitions from location [\" + location + \"]\");\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinitionReader#loadBeanDefinitions(locations)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "int",
    "signature": "public int loadBeanDefinitions(String... locations)",
    "source_code": "\tpublic int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException {\n\t\tAssert.notNull(locations, \"Location array must not be null\");\n\t\tint count = 0;\n\t\tfor (String location : locations) {\n\t\t\tcount += loadBeanDefinitions(location);\n\t\t}\n\t\treturn count;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinitionReader#loadBeanDefinitions(resources)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resources"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "int",
    "signature": "public int loadBeanDefinitions(Resource... resources)",
    "source_code": "\tpublic int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException {\n\t\tAssert.notNull(resources, \"Resource array must not be null\");\n\t\tint count = 0;\n\t\tfor (Resource resource : resources) {\n\t\t\tcount += loadBeanDefinitions(resource);\n\t\t}\n\t\treturn count;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinitionReader#setBeanClassLoader(beanClassLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the ClassLoader to use for bean classes.\n\t * <p>Default is {@code null}, which suggests to not load bean classes\n\t * eagerly but rather to just register bean definitions with class names,\n\t * with the corresponding Classes to be resolved later (or never).\n\t * @see Thread#getContextClassLoader()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClassLoader"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "void",
    "signature": "public void setBeanClassLoader(@Nullable ClassLoader beanClassLoader)",
    "source_code": "\tpublic void setBeanClassLoader(@Nullable ClassLoader beanClassLoader) {\n\t\tthis.beanClassLoader = beanClassLoader;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinitionReader#setBeanNameGenerator(beanNameGenerator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the BeanNameGenerator to use for anonymous beans\n\t * (without explicit bean name specified).\n\t * <p>Default is a {@link DefaultBeanNameGenerator}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanNameGenerator"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "void",
    "signature": "public void setBeanNameGenerator(@Nullable BeanNameGenerator beanNameGenerator)",
    "source_code": "\tpublic void setBeanNameGenerator(@Nullable BeanNameGenerator beanNameGenerator) {\n\t\tthis.beanNameGenerator = (beanNameGenerator != null ? beanNameGenerator : DefaultBeanNameGenerator.INSTANCE);\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinitionReader#setEnvironment(environment)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Environment to use when reading bean definitions. Most often used\n\t * for evaluating profile information to determine which bean definitions\n\t * should be read and which should be omitted.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "public void setEnvironment(Environment environment)",
    "source_code": "\tpublic void setEnvironment(Environment environment) {\n\t\tAssert.notNull(environment, \"Environment must not be null\");\n\t\tthis.environment = environment;\n\t}"
  },
  "org.springframework.beans.factory.support.AbstractBeanDefinitionReader#setResourceLoader(resourceLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the ResourceLoader to use for resource locations.\n\t * If specifying a ResourcePatternResolver, the bean definition reader\n\t * will be capable of resolving resource patterns to Resource arrays.\n\t * <p>Default is PathMatchingResourcePatternResolver, also capable of\n\t * resource pattern resolving through the ResourcePatternResolver interface.\n\t * <p>Setting this to {@code null} suggests that absolute resource loading\n\t * is not available for this bean definition reader.\n\t * @see org.springframework.core.io.support.ResourcePatternResolver\n\t * @see org.springframework.core.io.support.PathMatchingResourcePatternResolver\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLoader"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void setResourceLoader(@Nullable ResourceLoader resourceLoader)",
    "source_code": "\tpublic void setResourceLoader(@Nullable ResourceLoader resourceLoader) {\n\t\tthis.resourceLoader = resourceLoader;\n\t}"
  },
  "org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Default object instantiation strategy for use in BeanFactories.\n *\n * <p>Uses CGLIB to generate subclasses dynamically if methods need to be\n * overridden by the container to implement <em>Method Injection</em>.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 1.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "signature": "public class CglibSubclassingInstantiationStrategy",
    "source_code": "public class CglibSubclassingInstantiationStrategy extends SimpleInstantiationStrategy {\n\n\t/**\n\t * Index in the CGLIB callback array for passthrough behavior,\n\t * in which case the subclass won't override the original class.\n\t */\n\tprivate static final int PASSTHROUGH = 0;\n\n\t/**\n\t * Index in the CGLIB callback array for a method that should\n\t * be overridden to provide <em>method lookup</em>.\n\t */\n\tprivate static final int LOOKUP_OVERRIDE = 1;\n\n\t/**\n\t * Index in the CGLIB callback array for a method that should\n\t * be overridden using generic <em>method replacer</em> functionality.\n\t */\n\tprivate static final int METHOD_REPLACER = 2;\n\n\n\t@Override\n\tprotected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {\n\t\treturn instantiateWithMethodInjection(bd, beanName, owner, null);\n\t}\n\n\t@Override\n\tprotected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n\t\t\t@Nullable Constructor<?> ctor, Object... args) {\n\n\t\treturn new CglibSubclassCreator(bd, owner).instantiate(ctor, args);\n\t}\n\n\t@Override\n\tpublic Class<?> getActualBeanClass(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {\n\t\tif (!bd.hasMethodOverrides()) {\n\t\t\treturn super.getActualBeanClass(bd, beanName, owner);\n\t\t}\n\t\treturn new CglibSubclassCreator(bd, owner).createEnhancedSubclass(bd);\n\t}\n\n\n\t/**\n\t * An inner class created for historical reasons to avoid external CGLIB dependency\n\t * in Spring versions earlier than 3.2.\n\t */\n\tprivate static class CglibSubclassCreator {\n\n\t\tprivate static final Class<?>[] CALLBACK_TYPES = new Class<?>[]\n\t\t\t\t{NoOp.class, LookupOverrideMethodInterceptor.class, ReplaceOverrideMethodInterceptor.class};\n\n\t\tprivate final RootBeanDefinition beanDefinition;\n\n\t\tprivate final BeanFactory owner;\n\n\t\tCglibSubclassCreator(RootBeanDefinition beanDefinition, BeanFactory owner) {\n\t\t\tthis.beanDefinition = beanDefinition;\n\t\t\tthis.owner = owner;\n\t\t}\n\n\t\t/**\n\t\t * Create a new instance of a dynamically generated subclass implementing the\n\t\t * required lookups.\n\t\t * @param ctor constructor to use. If this is {@code null}, use the\n\t\t * no-arg constructor (no parameterization, or Setter Injection)\n\t\t * @param args arguments to use for the constructor.\n\t\t * Ignored if the {@code ctor} parameter is {@code null}.\n\t\t * @return new instance of the dynamically generated subclass\n\t\t */\n\t\tpublic Object instantiate(@Nullable Constructor<?> ctor, Object... args) {\n\t\t\tClass<?> subclass = createEnhancedSubclass(this.beanDefinition);\n\t\t\tObject instance;\n\t\t\tif (ctor == null) {\n\t\t\t\tinstance = BeanUtils.instantiateClass(subclass);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tConstructor<?> enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());\n\t\t\t\t\tinstance = enhancedSubclassConstructor.newInstance(args);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new BeanInstantiationException(this.beanDefinition.getBeanClass(),\n\t\t\t\t\t\t\t\"Failed to invoke constructor for CGLIB enhanced subclass [\" + subclass.getName() + \"]\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// SPR-10785: set callbacks directly on the instance instead of in the\n\t\t\t// enhanced class (via the Enhancer) in order to avoid memory leaks.\n\t\t\tFactory factory = (Factory) instance;\n\t\t\tfactory.setCallbacks(new Callback[] {NoOp.INSTANCE,\n\t\t\t\t\tnew LookupOverrideMethodInterceptor(this.beanDefinition, this.owner),\n\t\t\t\t\tnew ReplaceOverrideMethodInterceptor(this.beanDefinition, this.owner)});\n\t\t\treturn instance;\n\t\t}\n\n\t\t/**\n\t\t * Create an enhanced subclass of the bean class for the provided bean\n\t\t * definition, using CGLIB.\n\t\t */\n\t\tpublic Class<?> createEnhancedSubclass(RootBeanDefinition beanDefinition) {\n\t\t\tEnhancer enhancer = new Enhancer();\n\t\t\tenhancer.setSuperclass(beanDefinition.getBeanClass());\n\t\t\tenhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);\n\t\t\tenhancer.setAttemptLoad(true);\n\t\t\tif (this.owner instanceof ConfigurableBeanFactory cbf) {\n\t\t\t\tClassLoader cl = cbf.getBeanClassLoader();\n\t\t\t\tenhancer.setStrategy(new ClassLoaderAwareGeneratorStrategy(cl));\n\t\t\t}\n\t\t\tenhancer.setCallbackFilter(new MethodOverrideCallbackFilter(beanDefinition));\n\t\t\tenhancer.setCallbackTypes(CALLBACK_TYPES);\n\t\t\treturn enhancer.createClass();\n\t\t}\n\t}\n\n\n\t/**\n\t * Class providing hashCode and equals methods required by CGLIB to\n\t * ensure that CGLIB doesn't generate a distinct class per bean.\n\t * Identity is based on class and bean definition.\n\t */\n\tprivate static class CglibIdentitySupport {\n\n\t\tprivate final RootBeanDefinition beanDefinition;\n\n\t\tpublic CglibIdentitySupport(RootBeanDefinition beanDefinition) {\n\t\t\tthis.beanDefinition = beanDefinition;\n\t\t}\n\n\t\tpublic RootBeanDefinition getBeanDefinition() {\n\t\t\treturn this.beanDefinition;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (other != null && getClass() == other.getClass() &&\n\t\t\t\t\tthis.beanDefinition.equals(((CglibIdentitySupport) other).beanDefinition));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn this.beanDefinition.hashCode();\n\t\t}\n\t}\n\n\n\t/**\n\t * CGLIB callback for filtering method interception behavior.\n\t */\n\tprivate static class MethodOverrideCallbackFilter extends CglibIdentitySupport implements CallbackFilter {\n\n\t\tprivate static final Log logger = LogFactory.getLog(MethodOverrideCallbackFilter.class);\n\n\t\tpublic MethodOverrideCallbackFilter(RootBeanDefinition beanDefinition) {\n\t\t\tsuper(beanDefinition);\n\t\t}\n\n\t\t@Override\n\t\tpublic int accept(Method method) {\n\t\t\tMethodOverride methodOverride = getBeanDefinition().getMethodOverrides().getOverride(method);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"MethodOverride for \" + method + \": \" + methodOverride);\n\t\t\t}\n\t\t\tif (methodOverride == null) {\n\t\t\t\treturn PASSTHROUGH;\n\t\t\t}\n\t\t\telse if (methodOverride instanceof LookupOverride) {\n\t\t\t\treturn LOOKUP_OVERRIDE;\n\t\t\t}\n\t\t\telse if (methodOverride instanceof ReplaceOverride) {\n\t\t\t\treturn METHOD_REPLACER;\n\t\t\t}\n\t\t\tthrow new UnsupportedOperationException(\"Unexpected MethodOverride subclass: \" +\n\t\t\t\t\tmethodOverride.getClass().getName());\n\t\t}\n\t}\n\n\n\t/**\n\t * CGLIB MethodInterceptor to override methods, replacing them with an\n\t * implementation that returns a bean looked up in the container.\n\t */\n\tprivate static class LookupOverrideMethodInterceptor extends CglibIdentitySupport implements MethodInterceptor {\n\n\t\tprivate final BeanFactory owner;\n\n\t\tpublic LookupOverrideMethodInterceptor(RootBeanDefinition beanDefinition, BeanFactory owner) {\n\t\t\tsuper(beanDefinition);\n\t\t\tthis.owner = owner;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object intercept(Object obj, Method method, Object[] args, MethodProxy mp) throws Throwable {\n\t\t\t// Cast is safe, as CallbackFilter filters are used selectively.\n\t\t\tLookupOverride lo = (LookupOverride) getBeanDefinition().getMethodOverrides().getOverride(method);\n\t\t\tAssert.state(lo != null, \"LookupOverride not found\");\n\t\t\tObject[] argsToUse = (args.length > 0 ? args : null);  // if no-arg, don't insist on args at all\n\t\t\tif (StringUtils.hasText(lo.getBeanName())) {\n\t\t\t\tObject bean = (argsToUse != null ? this.owner.getBean(lo.getBeanName(), argsToUse) :\n\t\t\t\t\t\tthis.owner.getBean(lo.getBeanName()));\n\t\t\t\t// Detect package-protected NullBean instance through equals(null) check\n\t\t\t\treturn (bean.equals(null) ? null : bean);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Find target bean matching the (potentially generic) method return type\n\t\t\t\tResolvableType genericReturnType = ResolvableType.forMethodReturnType(method);\n\t\t\t\treturn (argsToUse != null ? this.owner.getBeanProvider(genericReturnType).getObject(argsToUse) :\n\t\t\t\t\t\tthis.owner.getBeanProvider(genericReturnType).getObject());\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * CGLIB MethodInterceptor to override methods, replacing them with a call\n\t * to a generic MethodReplacer.\n\t */\n\tprivate static class ReplaceOverrideMethodInterceptor extends CglibIdentitySupport implements MethodInterceptor {\n\n\t\tprivate final BeanFactory owner;\n\n\t\tpublic ReplaceOverrideMethodInterceptor(RootBeanDefinition beanDefinition, BeanFactory owner) {\n\t\t\tsuper(beanDefinition);\n\t\t\tthis.owner = owner;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object intercept(Object obj, Method method, Object[] args, MethodProxy mp) throws Throwable {\n\t\t\tReplaceOverride ro = (ReplaceOverride) getBeanDefinition().getMethodOverrides().getOverride(method);\n\t\t\tAssert.state(ro != null, \"ReplaceOverride not found\");\n\t\t\t// TODO could cache if a singleton for minor performance optimization\n\t\t\tMethodReplacer mr = this.owner.getBean(ro.getMethodReplacerBeanName(), MethodReplacer.class);\n\t\t\treturn mr.reimplement(obj, method, args);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy#accept(method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "int",
    "signature": "public int accept(Method method)",
    "source_code": "\t\tpublic int accept(Method method) {\n\t\t\tMethodOverride methodOverride = getBeanDefinition().getMethodOverrides().getOverride(method);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"MethodOverride for \" + method + \": \" + methodOverride);\n\t\t\t}\n\t\t\tif (methodOverride == null) {\n\t\t\t\treturn PASSTHROUGH;\n\t\t\t}\n\t\t\telse if (methodOverride instanceof LookupOverride) {\n\t\t\t\treturn LOOKUP_OVERRIDE;\n\t\t\t}\n\t\t\telse if (methodOverride instanceof ReplaceOverride) {\n\t\t\t\treturn METHOD_REPLACER;\n\t\t\t}\n\t\t\tthrow new UnsupportedOperationException(\"Unexpected MethodOverride subclass: \" +\n\t\t\t\t\tmethodOverride.getClass().getName());\n\t\t}"
  },
  "org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (other != null && getClass() == other.getClass() &&\n\t\t\t\t\tthis.beanDefinition.equals(((CglibIdentitySupport) other).beanDefinition));\n\t\t}"
  },
  "org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy#getBeanDefinition()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "RootBeanDefinition",
    "signature": "public RootBeanDefinition getBeanDefinition()",
    "source_code": "\t\tpublic RootBeanDefinition getBeanDefinition() {\n\t\t\treturn this.beanDefinition;\n\t\t}"
  },
  "org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn this.beanDefinition.hashCode();\n\t\t}"
  },
  "org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy#instantiate(ctor,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Create a new instance of a dynamically generated subclass implementing the\n\t\t * required lookups.\n\t\t * @param ctor constructor to use. If this is {@code null}, use the\n\t\t * no-arg constructor (no parameterization, or Setter Injection)\n\t\t * @param args arguments to use for the constructor.\n\t\t * Ignored if the {@code ctor} parameter is {@code null}.\n\t\t * @return new instance of the dynamically generated subclass\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ctor",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "Object",
    "signature": "public Object instantiate(@Nullable Constructor<?> ctor, Object... args)",
    "source_code": "\t\tpublic Object instantiate(@Nullable Constructor<?> ctor, Object... args) {\n\t\t\tClass<?> subclass = createEnhancedSubclass(this.beanDefinition);\n\t\t\tObject instance;\n\t\t\tif (ctor == null) {\n\t\t\t\tinstance = BeanUtils.instantiateClass(subclass);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tConstructor<?> enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());\n\t\t\t\t\tinstance = enhancedSubclassConstructor.newInstance(args);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new BeanInstantiationException(this.beanDefinition.getBeanClass(),\n\t\t\t\t\t\t\t\"Failed to invoke constructor for CGLIB enhanced subclass [\" + subclass.getName() + \"]\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// SPR-10785: set callbacks directly on the instance instead of in the\n\t\t\t// enhanced class (via the Enhancer) in order to avoid memory leaks.\n\t\t\tFactory factory = (Factory) instance;\n\t\t\tfactory.setCallbacks(new Callback[] {NoOp.INSTANCE,\n\t\t\t\t\tnew LookupOverrideMethodInterceptor(this.beanDefinition, this.owner),\n\t\t\t\t\tnew ReplaceOverrideMethodInterceptor(this.beanDefinition, this.owner)});\n\t\t\treturn instance;\n\t\t}"
  },
  "org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy#instantiateWithMethodInjection(bd,beanName,owner)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "beanName",
      "owner"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "Object",
    "signature": "protected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)",
    "source_code": "\tprotected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {\n\t\treturn instantiateWithMethodInjection(bd, beanName, owner, null);\n\t}"
  },
  "org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy#instantiateWithMethodInjection(bd,beanName,owner,ctor,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "beanName",
      "owner",
      "ctor",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "Object",
    "signature": "protected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n\t\t\t@Nullable Constructor<?> ctor, Object... args)",
    "source_code": "\tprotected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,"
  },
  "org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy#intercept(obj,method,args,mp)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj",
      "method",
      "args",
      "mp"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "Object",
    "signature": "public Object intercept(Object obj, Method method, Object[] args, MethodProxy mp)",
    "source_code": "\t\tpublic Object intercept(Object obj, Method method, Object[] args, MethodProxy mp) throws Throwable {\n\t\t\tReplaceOverride ro = (ReplaceOverride) getBeanDefinition().getMethodOverrides().getOverride(method);\n\t\t\tAssert.state(ro != null, \"ReplaceOverride not found\");\n\t\t\t// TODO could cache if a singleton for minor performance optimization\n\t\t\tMethodReplacer mr = this.owner.getBean(ro.getMethodReplacerBeanName(), MethodReplacer.class);\n\t\t\treturn mr.reimplement(obj, method, args);\n\t\t}"
  },
  "org.springframework.beans.factory.support.FactoryBeanRegistrySupport": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Support base class for singleton registries which need to handle\n * {@link org.springframework.beans.factory.FactoryBean} instances,\n * integrated with {@link DefaultSingletonBeanRegistry}'s singleton management.\n *\n * <p>Serves as base class for {@link AbstractBeanFactory}.\n *\n * @author Juergen Hoeller\n * @since 2.5.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class FactoryBeanRegistrySupport",
    "source_code": "public abstract class FactoryBeanRegistrySupport extends DefaultSingletonBeanRegistry {\n\n\t/** Cache of singleton objects created by FactoryBeans: FactoryBean name to object. */\n\tprivate final Map<String, Object> factoryBeanObjectCache = new ConcurrentHashMap<>(16);\n\n\n\t/**\n\t * Determine the type for the given FactoryBean.\n\t * @param factoryBean the FactoryBean instance to check\n\t * @return the FactoryBean's object type,\n\t * or {@code null} if the type cannot be determined yet\n\t */\n\t@Nullable\n\tprotected Class<?> getTypeForFactoryBean(FactoryBean<?> factoryBean) {\n\t\ttry {\n\t\t\treturn factoryBean.getObjectType();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// Thrown from the FactoryBean's getObjectType implementation.\n\t\t\tlogger.info(\"FactoryBean threw exception from getObjectType, despite the contract saying \" +\n\t\t\t\t\t\"that it should return null if the type of its object cannot be determined yet\", ex);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Obtain an object to expose from the given FactoryBean, if available\n\t * in cached form. Quick check for minimal synchronization.\n\t * @param beanName the name of the bean\n\t * @return the object obtained from the FactoryBean,\n\t * or {@code null} if not available\n\t */\n\t@Nullable\n\tprotected Object getCachedObjectForFactoryBean(String beanName) {\n\t\treturn this.factoryBeanObjectCache.get(beanName);\n\t}\n\n\t/**\n\t * Obtain an object to expose from the given FactoryBean.\n\t * @param factory the FactoryBean instance\n\t * @param beanName the name of the bean\n\t * @param shouldPostProcess whether the bean is subject to post-processing\n\t * @return the object obtained from the FactoryBean\n\t * @throws BeanCreationException if FactoryBean object creation failed\n\t * @see org.springframework.beans.factory.FactoryBean#getObject()\n\t */\n\tprotected Object getObjectFromFactoryBean(FactoryBean<?> factory, String beanName, boolean shouldPostProcess) {\n\t\tif (factory.isSingleton() && containsSingleton(beanName)) {\n\t\t\tsynchronized (getSingletonMutex()) {\n\t\t\t\tObject object = this.factoryBeanObjectCache.get(beanName);\n\t\t\t\tif (object == null) {\n\t\t\t\t\tobject = doGetObjectFromFactoryBean(factory, beanName);\n\t\t\t\t\t// Only post-process and store if not put there already during getObject() call above\n\t\t\t\t\t// (e.g. because of circular reference processing triggered by custom getBean calls)\n\t\t\t\t\tObject alreadyThere = this.factoryBeanObjectCache.get(beanName);\n\t\t\t\t\tif (alreadyThere != null) {\n\t\t\t\t\t\tobject = alreadyThere;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (shouldPostProcess) {\n\t\t\t\t\t\t\tif (isSingletonCurrentlyInCreation(beanName)) {\n\t\t\t\t\t\t\t\t// Temporarily return non-post-processed object, not storing it yet..\n\t\t\t\t\t\t\t\treturn object;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbeforeSingletonCreation(beanName);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tobject = postProcessObjectFromFactoryBean(object, beanName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t\t\tthrow new BeanCreationException(beanName,\n\t\t\t\t\t\t\t\t\t\t\"Post-processing of FactoryBean's singleton object failed\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\t\tafterSingletonCreation(beanName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (containsSingleton(beanName)) {\n\t\t\t\t\t\t\tthis.factoryBeanObjectCache.put(beanName, object);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn object;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tObject object = doGetObjectFromFactoryBean(factory, beanName);\n\t\t\tif (shouldPostProcess) {\n\t\t\t\ttry {\n\t\t\t\t\tobject = postProcessObjectFromFactoryBean(object, beanName);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new BeanCreationException(beanName, \"Post-processing of FactoryBean's object failed\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn object;\n\t\t}\n\t}\n\n\t/**\n\t * Obtain an object to expose from the given FactoryBean.\n\t * @param factory the FactoryBean instance\n\t * @param beanName the name of the bean\n\t * @return the object obtained from the FactoryBean\n\t * @throws BeanCreationException if FactoryBean object creation failed\n\t * @see org.springframework.beans.factory.FactoryBean#getObject()\n\t */\n\tprivate Object doGetObjectFromFactoryBean(FactoryBean<?> factory, String beanName) throws BeanCreationException {\n\t\tObject object;\n\t\ttry {\n\t\t\tobject = factory.getObject();\n\t\t}\n\t\tcatch (FactoryBeanNotInitializedException ex) {\n\t\t\tthrow new BeanCurrentlyInCreationException(beanName, ex.toString());\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"FactoryBean threw exception on object creation\", ex);\n\t\t}\n\n\t\t// Do not accept a null value for a FactoryBean that's not fully\n\t\t// initialized yet: Many FactoryBeans just return null then.\n\t\tif (object == null) {\n\t\t\tif (isSingletonCurrentlyInCreation(beanName)) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(\n\t\t\t\t\t\tbeanName, \"FactoryBean which is currently in creation returned null from getObject\");\n\t\t\t}\n\t\t\tobject = new NullBean();\n\t\t}\n\t\treturn object;\n\t}\n\n\t/**\n\t * Post-process the given object that has been obtained from the FactoryBean.\n\t * The resulting object will get exposed for bean references.\n\t * <p>The default implementation simply returns the given object as-is.\n\t * Subclasses may override this, for example, to apply post-processors.\n\t * @param object the object obtained from the FactoryBean.\n\t * @param beanName the name of the bean\n\t * @return the object to expose\n\t * @throws org.springframework.beans.BeansException if any post-processing failed\n\t */\n\tprotected Object postProcessObjectFromFactoryBean(Object object, String beanName) throws BeansException {\n\t\treturn object;\n\t}\n\n\t/**\n\t * Get a FactoryBean for the given bean if possible.\n\t * @param beanName the name of the bean\n\t * @param beanInstance the corresponding bean instance\n\t * @return the bean instance as FactoryBean\n\t * @throws BeansException if the given bean cannot be exposed as a FactoryBean\n\t */\n\tprotected FactoryBean<?> getFactoryBean(String beanName, Object beanInstance) throws BeansException {\n\t\tif (!(beanInstance instanceof FactoryBean<?> factoryBean)) {\n\t\t\tthrow new BeanCreationException(beanName,\n\t\t\t\t\t\"Bean instance of type [\" + beanInstance.getClass() + \"] is not a FactoryBean\");\n\t\t}\n\t\treturn factoryBean;\n\t}\n\n\t/**\n\t * Overridden to clear the FactoryBean object cache as well.\n\t */\n\t@Override\n\tprotected void removeSingleton(String beanName) {\n\t\tsynchronized (getSingletonMutex()) {\n\t\t\tsuper.removeSingleton(beanName);\n\t\t\tthis.factoryBeanObjectCache.remove(beanName);\n\t\t}\n\t}\n\n\t/**\n\t * Overridden to clear the FactoryBean object cache as well.\n\t */\n\t@Override\n\tprotected void clearSingletonCache() {\n\t\tsynchronized (getSingletonMutex()) {\n\t\t\tsuper.clearSingletonCache();\n\t\t\tthis.factoryBeanObjectCache.clear();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.beans.factory.support.FactoryBeanRegistrySupport#clearSingletonCache()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Overridden to clear the FactoryBean object cache as well.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "void",
    "signature": "protected void clearSingletonCache()",
    "source_code": "\tprotected void clearSingletonCache() {\n\t\tsynchronized (getSingletonMutex()) {\n\t\t\tsuper.clearSingletonCache();\n\t\t\tthis.factoryBeanObjectCache.clear();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.FactoryBeanRegistrySupport#getCachedObjectForFactoryBean(beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain an object to expose from the given FactoryBean, if available\n\t * in cached form. Quick check for minimal synchronization.\n\t * @param beanName the name of the bean\n\t * @return the object obtained from the FactoryBean,\n\t * or {@code null} if not available\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "Object",
    "signature": "protected Object getCachedObjectForFactoryBean(String beanName)",
    "source_code": "\tprotected Object getCachedObjectForFactoryBean(String beanName) {\n\t\treturn this.factoryBeanObjectCache.get(beanName);\n\t}"
  },
  "org.springframework.beans.factory.support.FactoryBeanRegistrySupport#getObjectFromFactoryBean(factory,beanName,shouldPostProcess)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain an object to expose from the given FactoryBean.\n\t * @param factory the FactoryBean instance\n\t * @param beanName the name of the bean\n\t * @param shouldPostProcess whether the bean is subject to post-processing\n\t * @return the object obtained from the FactoryBean\n\t * @throws BeanCreationException if FactoryBean object creation failed\n\t * @see org.springframework.beans.factory.FactoryBean#getObject()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "factory",
      "beanName",
      "shouldPostProcess"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "Object",
    "signature": "protected Object getObjectFromFactoryBean(FactoryBean<?> factory, String beanName, boolean shouldPostProcess)",
    "source_code": "\tprotected Object getObjectFromFactoryBean(FactoryBean<?> factory, String beanName, boolean shouldPostProcess) {\n\t\tif (factory.isSingleton() && containsSingleton(beanName)) {\n\t\t\tsynchronized (getSingletonMutex()) {\n\t\t\t\tObject object = this.factoryBeanObjectCache.get(beanName);\n\t\t\t\tif (object == null) {\n\t\t\t\t\tobject = doGetObjectFromFactoryBean(factory, beanName);\n\t\t\t\t\t// Only post-process and store if not put there already during getObject() call above\n\t\t\t\t\t// (e.g. because of circular reference processing triggered by custom getBean calls)\n\t\t\t\t\tObject alreadyThere = this.factoryBeanObjectCache.get(beanName);\n\t\t\t\t\tif (alreadyThere != null) {\n\t\t\t\t\t\tobject = alreadyThere;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (shouldPostProcess) {\n\t\t\t\t\t\t\tif (isSingletonCurrentlyInCreation(beanName)) {\n\t\t\t\t\t\t\t\t// Temporarily return non-post-processed object, not storing it yet..\n\t\t\t\t\t\t\t\treturn object;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbeforeSingletonCreation(beanName);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tobject = postProcessObjectFromFactoryBean(object, beanName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t\t\tthrow new BeanCreationException(beanName,\n\t\t\t\t\t\t\t\t\t\t\"Post-processing of FactoryBean's singleton object failed\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\t\tafterSingletonCreation(beanName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (containsSingleton(beanName)) {\n\t\t\t\t\t\t\tthis.factoryBeanObjectCache.put(beanName, object);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn object;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tObject object = doGetObjectFromFactoryBean(factory, beanName);\n\t\t\tif (shouldPostProcess) {\n\t\t\t\ttry {\n\t\t\t\t\tobject = postProcessObjectFromFactoryBean(object, beanName);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new BeanCreationException(beanName, \"Post-processing of FactoryBean's object failed\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn object;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.FactoryBeanRegistrySupport#postProcessObjectFromFactoryBean(object,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Post-process the given object that has been obtained from the FactoryBean.\n\t * The resulting object will get exposed for bean references.\n\t * <p>The default implementation simply returns the given object as-is.\n\t * Subclasses may override this, for example, to apply post-processors.\n\t * @param object the object obtained from the FactoryBean.\n\t * @param beanName the name of the bean\n\t * @return the object to expose\n\t * @throws org.springframework.beans.BeansException if any post-processing failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "Object",
    "signature": "protected Object postProcessObjectFromFactoryBean(Object object, String beanName)",
    "source_code": "\tprotected Object postProcessObjectFromFactoryBean(Object object, String beanName) throws BeansException {\n\t\treturn object;\n\t}"
  },
  "org.springframework.beans.factory.support.FactoryBeanRegistrySupport#removeSingleton(beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Overridden to clear the FactoryBean object cache as well.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "protected void removeSingleton(String beanName)",
    "source_code": "\tprotected void removeSingleton(String beanName) {\n\t\tsynchronized (getSingletonMutex()) {\n\t\t\tsuper.removeSingleton(beanName);\n\t\t\tthis.factoryBeanObjectCache.remove(beanName);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.ManagedProperties": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Tag class which represents a Spring-managed {@link Properties} instance\n * that supports merging of parent/child definitions.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @since 2.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 34
    },
    "signature": "public class ManagedProperties",
    "source_code": "public class ManagedProperties extends Properties implements Mergeable, BeanMetadataElement {\n\n\t@Nullable\n\tprivate Object source;\n\n\tprivate boolean mergeEnabled;\n\n\n\t/**\n\t * Set the configuration source {@code Object} for this metadata element.\n\t * <p>The exact type of the object will depend on the configuration mechanism used.\n\t */\n\tpublic void setSource(@Nullable Object source) {\n\t\tthis.source = source;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object getSource() {\n\t\treturn this.source;\n\t}\n\n\t/**\n\t * Set whether merging should be enabled for this collection,\n\t * in case of a 'parent' collection value being present.\n\t */\n\tpublic void setMergeEnabled(boolean mergeEnabled) {\n\t\tthis.mergeEnabled = mergeEnabled;\n\t}\n\n\t@Override\n\tpublic boolean isMergeEnabled() {\n\t\treturn this.mergeEnabled;\n\t}\n\n\n\t@Override\n\tpublic Object merge(@Nullable Object parent) {\n\t\tif (!this.mergeEnabled) {\n\t\t\tthrow new IllegalStateException(\"Not allowed to merge when the 'mergeEnabled' property is set to 'false'\");\n\t\t}\n\t\tif (parent == null) {\n\t\t\treturn this;\n\t\t}\n\t\tif (!(parent instanceof Properties properties)) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot merge with object of type [\" + parent.getClass() + \"]\");\n\t\t}\n\t\tProperties merged = new ManagedProperties();\n\t\tmerged.putAll(properties);\n\t\tmerged.putAll(this);\n\t\treturn merged;\n\t}\n\n}"
  },
  "org.springframework.beans.factory.support.ManagedProperties#getSource()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "Object",
    "signature": "public Object getSource()",
    "source_code": "\tpublic Object getSource() {\n\t\treturn this.source;\n\t}"
  },
  "org.springframework.beans.factory.support.ManagedProperties#isMergeEnabled()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "boolean",
    "signature": "public boolean isMergeEnabled()",
    "source_code": "\tpublic boolean isMergeEnabled() {\n\t\treturn this.mergeEnabled;\n\t}"
  },
  "org.springframework.beans.factory.support.ManagedProperties#merge(parent)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parent"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "Object",
    "signature": "public Object merge(@Nullable Object parent)",
    "source_code": "\tpublic Object merge(@Nullable Object parent) {\n\t\tif (!this.mergeEnabled) {\n\t\t\tthrow new IllegalStateException(\"Not allowed to merge when the 'mergeEnabled' property is set to 'false'\");\n\t\t}\n\t\tif (parent == null) {\n\t\t\treturn this;\n\t\t}\n\t\tif (!(parent instanceof Properties properties)) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot merge with object of type [\" + parent.getClass() + \"]\");\n\t\t}\n\t\tProperties merged = new ManagedProperties();\n\t\tmerged.putAll(properties);\n\t\tmerged.putAll(this);\n\t\treturn merged;\n\t}"
  },
  "org.springframework.beans.factory.support.ManagedProperties#setMergeEnabled(mergeEnabled)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether merging should be enabled for this collection,\n\t * in case of a 'parent' collection value being present.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergeEnabled"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "void",
    "signature": "public void setMergeEnabled(boolean mergeEnabled)",
    "source_code": "\tpublic void setMergeEnabled(boolean mergeEnabled) {\n\t\tthis.mergeEnabled = mergeEnabled;\n\t}"
  },
  "org.springframework.beans.factory.support.ManagedProperties#setSource(source)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the configuration source {@code Object} for this metadata element.\n\t * <p>The exact type of the object will depend on the configuration mechanism used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "void",
    "signature": "public void setSource(@Nullable Object source)",
    "source_code": "\tpublic void setSource(@Nullable Object source) {\n\t\tthis.source = source;\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A root bean definition represents the merged bean definition that backs\n * a specific bean in a Spring BeanFactory at runtime. It might have been created\n * from multiple original bean definitions that inherit from each other,\n * typically registered as {@link GenericBeanDefinition GenericBeanDefinitions}.\n * A root bean definition is essentially the 'unified' bean definition view at runtime.\n *\n * <p>Root bean definitions may also be used for registering individual bean definitions\n * in the configuration phase. However, since Spring 2.5, the preferred way to register\n * bean definitions programmatically is the {@link GenericBeanDefinition} class.\n * GenericBeanDefinition has the advantage that it allows to dynamically define\n * parent dependencies, not 'hard-coding' the role as a root bean definition.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @see GenericBeanDefinition\n * @see ChildBeanDefinition\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "signature": "public class RootBeanDefinition",
    "source_code": "public class RootBeanDefinition extends AbstractBeanDefinition {\n\n\t@Nullable\n\tprivate BeanDefinitionHolder decoratedDefinition;\n\n\t@Nullable\n\tprivate AnnotatedElement qualifiedElement;\n\n\t/** Determines if the definition needs to be re-merged. */\n\tvolatile boolean stale;\n\n\tboolean allowCaching = true;\n\n\tboolean isFactoryMethodUnique;\n\n\t@Nullable\n\tvolatile ResolvableType targetType;\n\n\t/** Package-visible field for caching the determined Class of a given bean definition. */\n\t@Nullable\n\tvolatile Class<?> resolvedTargetType;\n\n\t/** Package-visible field for caching if the bean is a factory bean. */\n\t@Nullable\n\tvolatile Boolean isFactoryBean;\n\n\t/** Package-visible field for caching the return type of a generically typed factory method. */\n\t@Nullable\n\tvolatile ResolvableType factoryMethodReturnType;\n\n\t/** Package-visible field for caching a unique factory method candidate for introspection. */\n\t@Nullable\n\tvolatile Method factoryMethodToIntrospect;\n\n\t/** Package-visible field for caching a resolved destroy method name (also for inferred). */\n\t@Nullable\n\tvolatile String resolvedDestroyMethodName;\n\n\t/** Common lock for the four constructor fields below. */\n\tfinal Object constructorArgumentLock = new Object();\n\n\t/** Package-visible field for caching the resolved constructor or factory method. */\n\t@Nullable\n\tExecutable resolvedConstructorOrFactoryMethod;\n\n\t/** Package-visible field that marks the constructor arguments as resolved. */\n\tboolean constructorArgumentsResolved = false;\n\n\t/** Package-visible field for caching fully resolved constructor arguments. */\n\t@Nullable\n\tObject[] resolvedConstructorArguments;\n\n\t/** Package-visible field for caching partly prepared constructor arguments. */\n\t@Nullable\n\tObject[] preparedConstructorArguments;\n\n\t/** Common lock for the two post-processing fields below. */\n\tfinal Object postProcessingLock = new Object();\n\n\t/** Package-visible field that indicates MergedBeanDefinitionPostProcessor having been applied. */\n\tboolean postProcessed = false;\n\n\t/** Package-visible field that indicates a before-instantiation post-processor having kicked in. */\n\t@Nullable\n\tvolatile Boolean beforeInstantiationResolved;\n\n\t@Nullable\n\tprivate Set<Member> externallyManagedConfigMembers;\n\n\t@Nullable\n\tprivate Set<String> externallyManagedInitMethods;\n\n\t@Nullable\n\tprivate Set<String> externallyManagedDestroyMethods;\n\n\n\t/**\n\t * Create a new RootBeanDefinition, to be configured through its bean\n\t * properties and configuration methods.\n\t * @see #setBeanClass\n\t * @see #setScope\n\t * @see #setConstructorArgumentValues\n\t * @see #setPropertyValues\n\t */\n\tpublic RootBeanDefinition() {\n\t}\n\n\t/**\n\t * Create a new RootBeanDefinition for a singleton.\n\t * @param beanClass the class of the bean to instantiate\n\t * @see #setBeanClass\n\t */\n\tpublic RootBeanDefinition(@Nullable Class<?> beanClass) {\n\t\tsetBeanClass(beanClass);\n\t}\n\n\t/**\n\t * Create a new RootBeanDefinition for a singleton.\n\t * @param beanType the type of bean to instantiate\n\t * @since 6.0\n\t * @see #setTargetType(ResolvableType)\n\t */\n\tpublic RootBeanDefinition(@Nullable ResolvableType beanType) {\n\t\tsetTargetType(beanType);\n\t}\n\n\t/**\n\t * Create a new RootBeanDefinition for a singleton bean, constructing each instance\n\t * through calling the given supplier (possibly a lambda or method reference).\n\t * @param beanClass the class of the bean to instantiate\n\t * @param instanceSupplier the supplier to construct a bean instance,\n\t * as an alternative to a declaratively specified factory method\n\t * @since 5.0\n\t * @see #setInstanceSupplier\n\t */\n\tpublic <T> RootBeanDefinition(@Nullable Class<T> beanClass, @Nullable Supplier<T> instanceSupplier) {\n\t\tsetBeanClass(beanClass);\n\t\tsetInstanceSupplier(instanceSupplier);\n\t}\n\n\t/**\n\t * Create a new RootBeanDefinition for a scoped bean, constructing each instance\n\t * through calling the given supplier (possibly a lambda or method reference).\n\t * @param beanClass the class of the bean to instantiate\n\t * @param scope the name of the corresponding scope\n\t * @param instanceSupplier the supplier to construct a bean instance,\n\t * as an alternative to a declaratively specified factory method\n\t * @since 5.0\n\t * @see #setInstanceSupplier\n\t */\n\tpublic <T> RootBeanDefinition(@Nullable Class<T> beanClass, String scope, @Nullable Supplier<T> instanceSupplier) {\n\t\tsetBeanClass(beanClass);\n\t\tsetScope(scope);\n\t\tsetInstanceSupplier(instanceSupplier);\n\t}\n\n\t/**\n\t * Create a new RootBeanDefinition for a singleton,\n\t * using the given autowire mode.\n\t * @param beanClass the class of the bean to instantiate\n\t * @param autowireMode by name or type, using the constants in this interface\n\t * @param dependencyCheck whether to perform a dependency check for objects\n\t * (not applicable to autowiring a constructor, thus ignored there)\n\t */\n\tpublic RootBeanDefinition(@Nullable Class<?> beanClass, int autowireMode, boolean dependencyCheck) {\n\t\tsetBeanClass(beanClass);\n\t\tsetAutowireMode(autowireMode);\n\t\tif (dependencyCheck && getResolvedAutowireMode() != AUTOWIRE_CONSTRUCTOR) {\n\t\t\tsetDependencyCheck(DEPENDENCY_CHECK_OBJECTS);\n\t\t}\n\t}\n\n\t/**\n\t * Create a new RootBeanDefinition for a singleton,\n\t * providing constructor arguments and property values.\n\t * @param beanClass the class of the bean to instantiate\n\t * @param cargs the constructor argument values to apply\n\t * @param pvs the property values to apply\n\t */\n\tpublic RootBeanDefinition(@Nullable Class<?> beanClass, @Nullable ConstructorArgumentValues cargs,\n\t\t\t@Nullable MutablePropertyValues pvs) {\n\n\t\tsuper(cargs, pvs);\n\t\tsetBeanClass(beanClass);\n\t}\n\n\t/**\n\t * Create a new RootBeanDefinition for a singleton,\n\t * providing constructor arguments and property values.\n\t * <p>Takes a bean class name to avoid eager loading of the bean class.\n\t * @param beanClassName the name of the class to instantiate\n\t */\n\tpublic RootBeanDefinition(String beanClassName) {\n\t\tsetBeanClassName(beanClassName);\n\t}\n\n\t/**\n\t * Create a new RootBeanDefinition for a singleton,\n\t * providing constructor arguments and property values.\n\t * <p>Takes a bean class name to avoid eager loading of the bean class.\n\t * @param beanClassName the name of the class to instantiate\n\t * @param cargs the constructor argument values to apply\n\t * @param pvs the property values to apply\n\t */\n\tpublic RootBeanDefinition(String beanClassName, ConstructorArgumentValues cargs, MutablePropertyValues pvs) {\n\t\tsuper(cargs, pvs);\n\t\tsetBeanClassName(beanClassName);\n\t}\n\n\t/**\n\t * Create a new RootBeanDefinition as deep copy of the given\n\t * bean definition.\n\t * @param original the original bean definition to copy from\n\t */\n\tpublic RootBeanDefinition(RootBeanDefinition original) {\n\t\tsuper(original);\n\t\tthis.decoratedDefinition = original.decoratedDefinition;\n\t\tthis.qualifiedElement = original.qualifiedElement;\n\t\tthis.allowCaching = original.allowCaching;\n\t\tthis.isFactoryMethodUnique = original.isFactoryMethodUnique;\n\t\tthis.targetType = original.targetType;\n\t\tthis.factoryMethodToIntrospect = original.factoryMethodToIntrospect;\n\t}\n\n\t/**\n\t * Create a new RootBeanDefinition as deep copy of the given\n\t * bean definition.\n\t * @param original the original bean definition to copy from\n\t */\n\tRootBeanDefinition(BeanDefinition original) {\n\t\tsuper(original);\n\t}\n\n\n\t@Override\n\tpublic String getParentName() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void setParentName(@Nullable String parentName) {\n\t\tif (parentName != null) {\n\t\t\tthrow new IllegalArgumentException(\"Root bean cannot be changed into a child bean with parent reference\");\n\t\t}\n\t}\n\n\t/**\n\t * Register a target definition that is being decorated by this bean definition.\n\t */\n\tpublic void setDecoratedDefinition(@Nullable BeanDefinitionHolder decoratedDefinition) {\n\t\tthis.decoratedDefinition = decoratedDefinition;\n\t}\n\n\t/**\n\t * Return the target definition that is being decorated by this bean definition, if any.\n\t */\n\t@Nullable\n\tpublic BeanDefinitionHolder getDecoratedDefinition() {\n\t\treturn this.decoratedDefinition;\n\t}\n\n\t/**\n\t * Specify the {@link AnnotatedElement} defining qualifiers,\n\t * to be used instead of the target class or factory method.\n\t * @since 4.3.3\n\t * @see #setTargetType(ResolvableType)\n\t * @see #getResolvedFactoryMethod()\n\t */\n\tpublic void setQualifiedElement(@Nullable AnnotatedElement qualifiedElement) {\n\t\tthis.qualifiedElement = qualifiedElement;\n\t}\n\n\t/**\n\t * Return the {@link AnnotatedElement} defining qualifiers, if any.\n\t * Otherwise, the factory method and target class will be checked.\n\t * @since 4.3.3\n\t */\n\t@Nullable\n\tpublic AnnotatedElement getQualifiedElement() {\n\t\treturn this.qualifiedElement;\n\t}\n\n\t/**\n\t * Specify a generics-containing target type of this bean definition, if known in advance.\n\t * @since 4.3.3\n\t */\n\tpublic void setTargetType(@Nullable ResolvableType targetType) {\n\t\tthis.targetType = targetType;\n\t}\n\n\t/**\n\t * Specify the target type of this bean definition, if known in advance.\n\t * @since 3.2.2\n\t */\n\tpublic void setTargetType(@Nullable Class<?> targetType) {\n\t\tthis.targetType = (targetType != null ? ResolvableType.forClass(targetType) : null);\n\t}\n\n\t/**\n\t * Return the target type of this bean definition, if known\n\t * (either specified in advance or resolved on first instantiation).\n\t * @since 3.2.2\n\t */\n\t@Nullable\n\tpublic Class<?> getTargetType() {\n\t\tif (this.resolvedTargetType != null) {\n\t\t\treturn this.resolvedTargetType;\n\t\t}\n\t\tResolvableType targetType = this.targetType;\n\t\treturn (targetType != null ? targetType.resolve() : null);\n\t}\n\n\t/**\n\t * Return a {@link ResolvableType} for this bean definition,\n\t * either from runtime-cached type information or from configuration-time\n\t * {@link #setTargetType(ResolvableType)} or {@link #setBeanClass(Class)},\n\t * also considering resolved factory method definitions.\n\t * @since 5.1\n\t * @see #setTargetType(ResolvableType)\n\t * @see #setBeanClass(Class)\n\t * @see #setResolvedFactoryMethod(Method)\n\t */\n\t@Override\n\tpublic ResolvableType getResolvableType() {\n\t\tResolvableType targetType = this.targetType;\n\t\tif (targetType != null) {\n\t\t\treturn targetType;\n\t\t}\n\t\tResolvableType returnType = this.factoryMethodReturnType;\n\t\tif (returnType != null) {\n\t\t\treturn returnType;\n\t\t}\n\t\tMethod factoryMethod = this.factoryMethodToIntrospect;\n\t\tif (factoryMethod != null) {\n\t\t\treturn ResolvableType.forMethodReturnType(factoryMethod);\n\t\t}\n\t\treturn super.getResolvableType();\n\t}\n\n\t/**\n\t * Determine preferred constructors to use for default construction, if any.\n\t * Constructor arguments will be autowired if necessary.\n\t * @return one or more preferred constructors, or {@code null} if none\n\t * (in which case the regular no-arg default constructor will be called)\n\t * @since 5.1\n\t */\n\t@Nullable\n\tpublic Constructor<?>[] getPreferredConstructors() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Specify a factory method name that refers to a non-overloaded method.\n\t */\n\tpublic void setUniqueFactoryMethodName(String name) {\n\t\tAssert.hasText(name, \"Factory method name must not be empty\");\n\t\tsetFactoryMethodName(name);\n\t\tthis.isFactoryMethodUnique = true;\n\t}\n\n\t/**\n\t * Specify a factory method name that refers to an overloaded method.\n\t * @since 5.2\n\t */\n\tpublic void setNonUniqueFactoryMethodName(String name) {\n\t\tAssert.hasText(name, \"Factory method name must not be empty\");\n\t\tsetFactoryMethodName(name);\n\t\tthis.isFactoryMethodUnique = false;\n\t}\n\n\t/**\n\t * Check whether the given candidate qualifies as a factory method.\n\t */\n\tpublic boolean isFactoryMethod(Method candidate) {\n\t\treturn candidate.getName().equals(getFactoryMethodName());\n\t}\n\n\t/**\n\t * Set a resolved Java Method for the factory method on this bean definition.\n\t * @param method the resolved factory method, or {@code null} to reset it\n\t * @since 5.2\n\t */\n\tpublic void setResolvedFactoryMethod(@Nullable Method method) {\n\t\tthis.factoryMethodToIntrospect = method;\n\t\tif (method != null) {\n\t\t\tsetUniqueFactoryMethodName(method.getName());\n\t\t}\n\t}\n\n\t/**\n\t * Return the resolved factory method as a Java Method object, if available.\n\t * @return the factory method, or {@code null} if not found or not resolved yet\n\t */\n\t@Nullable\n\tpublic Method getResolvedFactoryMethod() {\n\t\treturn this.factoryMethodToIntrospect;\n\t}\n\n\t@Override\n\tpublic void setInstanceSupplier(@Nullable Supplier<?> supplier) {\n\t\tsuper.setInstanceSupplier(supplier);\n\t\tMethod factoryMethod = (supplier instanceof InstanceSupplier<?> instanceSupplier ?\n\t\t\t\tinstanceSupplier.getFactoryMethod() : null);\n\t\tif (factoryMethod != null) {\n\t\t\tsetResolvedFactoryMethod(factoryMethod);\n\t\t}\n\t}\n\n\t/**\n\t * Mark this bean definition as post-processed,\n\t * i.e. processed by {@link MergedBeanDefinitionPostProcessor}.\n\t * @since 6.0\n\t */\n\tpublic void markAsPostProcessed() {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\tthis.postProcessed = true;\n\t\t}\n\t}\n\n\t/**\n\t * Register an externally managed configuration method or field.\n\t */\n\tpublic void registerExternallyManagedConfigMember(Member configMember) {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\tif (this.externallyManagedConfigMembers == null) {\n\t\t\t\tthis.externallyManagedConfigMembers = new LinkedHashSet<>(1);\n\t\t\t}\n\t\t\tthis.externallyManagedConfigMembers.add(configMember);\n\t\t}\n\t}\n\n\t/**\n\t * Determine if the given method or field is an externally managed configuration member.\n\t */\n\tpublic boolean isExternallyManagedConfigMember(Member configMember) {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\treturn (this.externallyManagedConfigMembers != null &&\n\t\t\t\t\tthis.externallyManagedConfigMembers.contains(configMember));\n\t\t}\n\t}\n\n\t/**\n\t * Get all externally managed configuration methods and fields (as an immutable Set).\n\t * @since 5.3.11\n\t */\n\tpublic Set<Member> getExternallyManagedConfigMembers() {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\treturn (this.externallyManagedConfigMembers != null ?\n\t\t\t\t\tCollections.unmodifiableSet(new LinkedHashSet<>(this.externallyManagedConfigMembers)) :\n\t\t\t\t\tCollections.emptySet());\n\t\t}\n\t}\n\n\t/**\n\t * Register an externally managed configuration initialization method &mdash;\n\t * for example, a method annotated with JSR-250's\n\t * {@link jakarta.annotation.PostConstruct} annotation.\n\t * <p>The supplied {@code initMethod} may be the\n\t * {@linkplain Method#getName() simple method name} for non-private methods or the\n\t * {@linkplain org.springframework.util.ClassUtils#getQualifiedMethodName(Method)\n\t * qualified method name} for {@code private} methods. A qualified name is\n\t * necessary for {@code private} methods in order to disambiguate between\n\t * multiple private methods with the same name within a class hierarchy.\n\t */\n\tpublic void registerExternallyManagedInitMethod(String initMethod) {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\tif (this.externallyManagedInitMethods == null) {\n\t\t\t\tthis.externallyManagedInitMethods = new LinkedHashSet<>(1);\n\t\t\t}\n\t\t\tthis.externallyManagedInitMethods.add(initMethod);\n\t\t}\n\t}\n\n\t/**\n\t * Determine if the given method name indicates an externally managed\n\t * initialization method.\n\t * <p>See {@link #registerExternallyManagedInitMethod} for details\n\t * regarding the format for the supplied {@code initMethod}.\n\t */\n\tpublic boolean isExternallyManagedInitMethod(String initMethod) {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\treturn (this.externallyManagedInitMethods != null &&\n\t\t\t\t\tthis.externallyManagedInitMethods.contains(initMethod));\n\t\t}\n\t}\n\n\t/**\n\t * Determine if the given method name indicates an externally managed\n\t * initialization method, regardless of method visibility.\n\t * <p>In contrast to {@link #isExternallyManagedInitMethod(String)}, this\n\t * method also returns {@code true} if there is a {@code private} externally\n\t * managed initialization method that has been\n\t * {@linkplain #registerExternallyManagedInitMethod(String) registered}\n\t * using a qualified method name instead of a simple method name.\n\t * @since 5.3.17\n\t */\n\tboolean hasAnyExternallyManagedInitMethod(String initMethod) {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\tif (isExternallyManagedInitMethod(initMethod)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (this.externallyManagedInitMethods != null) {\n\t\t\t\tfor (String candidate : this.externallyManagedInitMethods) {\n\t\t\t\t\tint indexOfDot = candidate.lastIndexOf('.');\n\t\t\t\t\tif (indexOfDot >= 0) {\n\t\t\t\t\t\tString methodName = candidate.substring(indexOfDot + 1);\n\t\t\t\t\t\tif (methodName.equals(initMethod)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Return all externally managed initialization methods (as an immutable Set).\n\t * <p>See {@link #registerExternallyManagedInitMethod} for details\n\t * regarding the format for the initialization methods in the returned set.\n\t * @since 5.3.11\n\t */\n\tpublic Set<String> getExternallyManagedInitMethods() {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\treturn (this.externallyManagedInitMethods != null ?\n\t\t\t\t\tCollections.unmodifiableSet(new LinkedHashSet<>(this.externallyManagedInitMethods)) :\n\t\t\t\t\tCollections.emptySet());\n\t\t}\n\t}\n\n\t/**\n\t * Resolve the inferred destroy method if necessary.\n\t * @since 6.0\n\t */\n\tpublic void resolveDestroyMethodIfNecessary() {\n\t\tsetDestroyMethodNames(DisposableBeanAdapter\n\t\t\t\t.inferDestroyMethodsIfNecessary(getResolvableType().toClass(), this));\n\t}\n\n\t/**\n\t * Register an externally managed configuration destruction method &mdash;\n\t * for example, a method annotated with JSR-250's\n\t * {@link jakarta.annotation.PreDestroy} annotation.\n\t * <p>The supplied {@code destroyMethod} may be the\n\t * {@linkplain Method#getName() simple method name} for non-private methods or the\n\t * {@linkplain org.springframework.util.ClassUtils#getQualifiedMethodName(Method)\n\t * qualified method name} for {@code private} methods. A qualified name is\n\t * necessary for {@code private} methods in order to disambiguate between\n\t * multiple private methods with the same name within a class hierarchy.\n\t */\n\tpublic void registerExternallyManagedDestroyMethod(String destroyMethod) {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\tif (this.externallyManagedDestroyMethods == null) {\n\t\t\t\tthis.externallyManagedDestroyMethods = new LinkedHashSet<>(1);\n\t\t\t}\n\t\t\tthis.externallyManagedDestroyMethods.add(destroyMethod);\n\t\t}\n\t}\n\n\t/**\n\t * Determine if the given method name indicates an externally managed\n\t * destruction method.\n\t * <p>See {@link #registerExternallyManagedDestroyMethod} for details\n\t * regarding the format for the supplied {@code destroyMethod}.\n\t */\n\tpublic boolean isExternallyManagedDestroyMethod(String destroyMethod) {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\treturn (this.externallyManagedDestroyMethods != null &&\n\t\t\t\t\tthis.externallyManagedDestroyMethods.contains(destroyMethod));\n\t\t}\n\t}\n\n\t/**\n\t * Determine if the given method name indicates an externally managed\n\t * destruction method, regardless of method visibility.\n\t * <p>In contrast to {@link #isExternallyManagedDestroyMethod(String)}, this\n\t * method also returns {@code true} if there is a {@code private} externally\n\t * managed destruction method that has been\n\t * {@linkplain #registerExternallyManagedDestroyMethod(String) registered}\n\t * using a qualified method name instead of a simple method name.\n\t * @since 5.3.17\n\t */\n\tboolean hasAnyExternallyManagedDestroyMethod(String destroyMethod) {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\tif (isExternallyManagedDestroyMethod(destroyMethod)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (this.externallyManagedDestroyMethods != null) {\n\t\t\t\tfor (String candidate : this.externallyManagedDestroyMethods) {\n\t\t\t\t\tint indexOfDot = candidate.lastIndexOf('.');\n\t\t\t\t\tif (indexOfDot >= 0) {\n\t\t\t\t\t\tString methodName = candidate.substring(indexOfDot + 1);\n\t\t\t\t\t\tif (methodName.equals(destroyMethod)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Get all externally managed destruction methods (as an immutable Set).\n\t * <p>See {@link #registerExternallyManagedDestroyMethod} for details\n\t * regarding the format for the destruction methods in the returned set.\n\t * @since 5.3.11\n\t */\n\tpublic Set<String> getExternallyManagedDestroyMethods() {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\treturn (this.externallyManagedDestroyMethods != null ?\n\t\t\t\t\tCollections.unmodifiableSet(new LinkedHashSet<>(this.externallyManagedDestroyMethods)) :\n\t\t\t\t\tCollections.emptySet());\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic RootBeanDefinition cloneBeanDefinition() {\n\t\treturn new RootBeanDefinition(this);\n\t}\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof RootBeanDefinition && super.equals(other)));\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Root bean: \" + super.toString();\n\t}\n\n}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#cloneBeanDefinition()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 655
    },
    "return": "RootBeanDefinition",
    "signature": "public RootBeanDefinition cloneBeanDefinition()",
    "source_code": "\tpublic RootBeanDefinition cloneBeanDefinition() {\n\t\treturn new RootBeanDefinition(this);\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 660
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof RootBeanDefinition && super.equals(other)));\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#getDecoratedDefinition()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the target definition that is being decorated by this bean definition, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder getDecoratedDefinition()",
    "source_code": "\tpublic BeanDefinitionHolder getDecoratedDefinition() {\n\t\treturn this.decoratedDefinition;\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#getExternallyManagedConfigMembers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get all externally managed configuration methods and fields (as an immutable Set).\n\t * @since 5.3.11\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 482
    },
    "return": "Set<Member>",
    "signature": "public Set<Member> getExternallyManagedConfigMembers()",
    "source_code": "\tpublic Set<Member> getExternallyManagedConfigMembers() {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\treturn (this.externallyManagedConfigMembers != null ?\n\t\t\t\t\tCollections.unmodifiableSet(new LinkedHashSet<>(this.externallyManagedConfigMembers)) :\n\t\t\t\t\tCollections.emptySet());\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#getExternallyManagedDestroyMethods()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get all externally managed destruction methods (as an immutable Set).\n\t * <p>See {@link #registerExternallyManagedDestroyMethod} for details\n\t * regarding the format for the destruction methods in the returned set.\n\t * @since 5.3.11\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 645
    },
    "return": "Set<String>",
    "signature": "public Set<String> getExternallyManagedDestroyMethods()",
    "source_code": "\tpublic Set<String> getExternallyManagedDestroyMethods() {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\treturn (this.externallyManagedDestroyMethods != null ?\n\t\t\t\t\tCollections.unmodifiableSet(new LinkedHashSet<>(this.externallyManagedDestroyMethods)) :\n\t\t\t\t\tCollections.emptySet());\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#getExternallyManagedInitMethods()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return all externally managed initialization methods (as an immutable Set).\n\t * <p>See {@link #registerExternallyManagedInitMethod} for details\n\t * regarding the format for the initialization methods in the returned set.\n\t * @since 5.3.11\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 559
    },
    "return": "Set<String>",
    "signature": "public Set<String> getExternallyManagedInitMethods()",
    "source_code": "\tpublic Set<String> getExternallyManagedInitMethods() {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\treturn (this.externallyManagedInitMethods != null ?\n\t\t\t\t\tCollections.unmodifiableSet(new LinkedHashSet<>(this.externallyManagedInitMethods)) :\n\t\t\t\t\tCollections.emptySet());\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#getParentName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "String",
    "signature": "public String getParentName()",
    "source_code": "\tpublic String getParentName() {\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#getQualifiedElement()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link AnnotatedElement} defining qualifiers, if any.\n\t * Otherwise, the factory method and target class will be checked.\n\t * @since 4.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "AnnotatedElement",
    "signature": "public AnnotatedElement getQualifiedElement()",
    "source_code": "\tpublic AnnotatedElement getQualifiedElement() {\n\t\treturn this.qualifiedElement;\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#getResolvableType()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for this bean definition,\n\t * either from runtime-cached type information or from configuration-time\n\t * {@link #setTargetType(ResolvableType)} or {@link #setBeanClass(Class)},\n\t * also considering resolved factory method definitions.\n\t * @since 5.1\n\t * @see #setTargetType(ResolvableType)\n\t * @see #setBeanClass(Class)\n\t * @see #setResolvedFactoryMethod(Method)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType getResolvableType()",
    "source_code": "\tpublic ResolvableType getResolvableType() {\n\t\tResolvableType targetType = this.targetType;\n\t\tif (targetType != null) {\n\t\t\treturn targetType;\n\t\t}\n\t\tResolvableType returnType = this.factoryMethodReturnType;\n\t\tif (returnType != null) {\n\t\t\treturn returnType;\n\t\t}\n\t\tMethod factoryMethod = this.factoryMethodToIntrospect;\n\t\tif (factoryMethod != null) {\n\t\t\treturn ResolvableType.forMethodReturnType(factoryMethod);\n\t\t}\n\t\treturn super.getResolvableType();\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#getResolvedFactoryMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the resolved factory method as a Java Method object, if available.\n\t * @return the factory method, or {@code null} if not found or not resolved yet\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 431
    },
    "return": "Method",
    "signature": "public Method getResolvedFactoryMethod()",
    "source_code": "\tpublic Method getResolvedFactoryMethod() {\n\t\treturn this.factoryMethodToIntrospect;\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#isExternallyManagedConfigMember(configMember)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the given method or field is an externally managed configuration member.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configMember"
    ],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "boolean",
    "signature": "public boolean isExternallyManagedConfigMember(Member configMember)",
    "source_code": "\tpublic boolean isExternallyManagedConfigMember(Member configMember) {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\treturn (this.externallyManagedConfigMembers != null &&\n\t\t\t\t\tthis.externallyManagedConfigMembers.contains(configMember));\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#isExternallyManagedDestroyMethod(destroyMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the given method name indicates an externally managed\n\t * destruction method.\n\t * <p>See {@link #registerExternallyManagedDestroyMethod} for details\n\t * regarding the format for the supplied {@code destroyMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destroyMethod"
    ],
    "position": {
      "column": 1,
      "line": 602
    },
    "return": "boolean",
    "signature": "public boolean isExternallyManagedDestroyMethod(String destroyMethod)",
    "source_code": "\tpublic boolean isExternallyManagedDestroyMethod(String destroyMethod) {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\treturn (this.externallyManagedDestroyMethods != null &&\n\t\t\t\t\tthis.externallyManagedDestroyMethods.contains(destroyMethod));\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#isExternallyManagedInitMethod(initMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the given method name indicates an externally managed\n\t * initialization method.\n\t * <p>See {@link #registerExternallyManagedInitMethod} for details\n\t * regarding the format for the supplied {@code initMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "initMethod"
    ],
    "position": {
      "column": 1,
      "line": 516
    },
    "return": "boolean",
    "signature": "public boolean isExternallyManagedInitMethod(String initMethod)",
    "source_code": "\tpublic boolean isExternallyManagedInitMethod(String initMethod) {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\treturn (this.externallyManagedInitMethods != null &&\n\t\t\t\t\tthis.externallyManagedInitMethods.contains(initMethod));\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#isFactoryMethod(candidate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given candidate qualifies as a factory method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "candidate"
    ],
    "position": {
      "column": 1,
      "line": 410
    },
    "return": "boolean",
    "signature": "public boolean isFactoryMethod(Method candidate)",
    "source_code": "\tpublic boolean isFactoryMethod(Method candidate) {\n\t\treturn candidate.getName().equals(getFactoryMethodName());\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#markAsPostProcessed()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Mark this bean definition as post-processed,\n\t * i.e. processed by {@link MergedBeanDefinitionPostProcessor}.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 450
    },
    "return": "void",
    "signature": "public void markAsPostProcessed()",
    "source_code": "\tpublic void markAsPostProcessed() {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\tthis.postProcessed = true;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#registerExternallyManagedConfigMember(configMember)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register an externally managed configuration method or field.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configMember"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "void",
    "signature": "public void registerExternallyManagedConfigMember(Member configMember)",
    "source_code": "\tpublic void registerExternallyManagedConfigMember(Member configMember) {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\tif (this.externallyManagedConfigMembers == null) {\n\t\t\t\tthis.externallyManagedConfigMembers = new LinkedHashSet<>(1);\n\t\t\t}\n\t\t\tthis.externallyManagedConfigMembers.add(configMember);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#registerExternallyManagedDestroyMethod(destroyMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register an externally managed configuration destruction method &mdash;\n\t * for example, a method annotated with JSR-250's\n\t * {@link jakarta.annotation.PreDestroy} annotation.\n\t * <p>The supplied {@code destroyMethod} may be the\n\t * {@linkplain Method#getName() simple method name} for non-private methods or the\n\t * {@linkplain org.springframework.util.ClassUtils#getQualifiedMethodName(Method)\n\t * qualified method name} for {@code private} methods. A qualified name is\n\t * necessary for {@code private} methods in order to disambiguate between\n\t * multiple private methods with the same name within a class hierarchy.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destroyMethod"
    ],
    "position": {
      "column": 1,
      "line": 587
    },
    "return": "void",
    "signature": "public void registerExternallyManagedDestroyMethod(String destroyMethod)",
    "source_code": "\tpublic void registerExternallyManagedDestroyMethod(String destroyMethod) {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\tif (this.externallyManagedDestroyMethods == null) {\n\t\t\t\tthis.externallyManagedDestroyMethods = new LinkedHashSet<>(1);\n\t\t\t}\n\t\t\tthis.externallyManagedDestroyMethods.add(destroyMethod);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#registerExternallyManagedInitMethod(initMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register an externally managed configuration initialization method &mdash;\n\t * for example, a method annotated with JSR-250's\n\t * {@link jakarta.annotation.PostConstruct} annotation.\n\t * <p>The supplied {@code initMethod} may be the\n\t * {@linkplain Method#getName() simple method name} for non-private methods or the\n\t * {@linkplain org.springframework.util.ClassUtils#getQualifiedMethodName(Method)\n\t * qualified method name} for {@code private} methods. A qualified name is\n\t * necessary for {@code private} methods in order to disambiguate between\n\t * multiple private methods with the same name within a class hierarchy.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "initMethod"
    ],
    "position": {
      "column": 1,
      "line": 501
    },
    "return": "void",
    "signature": "public void registerExternallyManagedInitMethod(String initMethod)",
    "source_code": "\tpublic void registerExternallyManagedInitMethod(String initMethod) {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\tif (this.externallyManagedInitMethods == null) {\n\t\t\t\tthis.externallyManagedInitMethods = new LinkedHashSet<>(1);\n\t\t\t}\n\t\t\tthis.externallyManagedInitMethods.add(initMethod);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#resolveDestroyMethodIfNecessary()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the inferred destroy method if necessary.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 571
    },
    "return": "void",
    "signature": "public void resolveDestroyMethodIfNecessary()",
    "source_code": "\tpublic void resolveDestroyMethodIfNecessary() {\n\t\tsetDestroyMethodNames(DisposableBeanAdapter\n\t\t\t\t.inferDestroyMethodsIfNecessary(getResolvableType().toClass(), this));\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#setDecoratedDefinition(decoratedDefinition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a target definition that is being decorated by this bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoratedDefinition"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "void",
    "signature": "public void setDecoratedDefinition(@Nullable BeanDefinitionHolder decoratedDefinition)",
    "source_code": "\tpublic void setDecoratedDefinition(@Nullable BeanDefinitionHolder decoratedDefinition) {\n\t\tthis.decoratedDefinition = decoratedDefinition;\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#setInstanceSupplier(supplier)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "supplier"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "void",
    "signature": "public void setInstanceSupplier(@Nullable Supplier<?> supplier)",
    "source_code": "\tpublic void setInstanceSupplier(@Nullable Supplier<?> supplier) {\n\t\tsuper.setInstanceSupplier(supplier);\n\t\tMethod factoryMethod = (supplier instanceof InstanceSupplier<?> instanceSupplier ?\n\t\t\t\tinstanceSupplier.getFactoryMethod() : null);\n\t\tif (factoryMethod != null) {\n\t\t\tsetResolvedFactoryMethod(factoryMethod);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#setNonUniqueFactoryMethodName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a factory method name that refers to an overloaded method.\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "void",
    "signature": "public void setNonUniqueFactoryMethodName(String name)",
    "source_code": "\tpublic void setNonUniqueFactoryMethodName(String name) {\n\t\tAssert.hasText(name, \"Factory method name must not be empty\");\n\t\tsetFactoryMethodName(name);\n\t\tthis.isFactoryMethodUnique = false;\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#setParentName(parentName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parentName"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "void",
    "signature": "public void setParentName(@Nullable String parentName)",
    "source_code": "\tpublic void setParentName(@Nullable String parentName) {\n\t\tif (parentName != null) {\n\t\t\tthrow new IllegalArgumentException(\"Root bean cannot be changed into a child bean with parent reference\");\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#setQualifiedElement(qualifiedElement)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the {@link AnnotatedElement} defining qualifiers,\n\t * to be used instead of the target class or factory method.\n\t * @since 4.3.3\n\t * @see #setTargetType(ResolvableType)\n\t * @see #getResolvedFactoryMethod()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "qualifiedElement"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "void",
    "signature": "public void setQualifiedElement(@Nullable AnnotatedElement qualifiedElement)",
    "source_code": "\tpublic void setQualifiedElement(@Nullable AnnotatedElement qualifiedElement) {\n\t\tthis.qualifiedElement = qualifiedElement;\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#setResolvedFactoryMethod(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a resolved Java Method for the factory method on this bean definition.\n\t * @param method the resolved factory method, or {@code null} to reset it\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 419
    },
    "return": "void",
    "signature": "public void setResolvedFactoryMethod(@Nullable Method method)",
    "source_code": "\tpublic void setResolvedFactoryMethod(@Nullable Method method) {\n\t\tthis.factoryMethodToIntrospect = method;\n\t\tif (method != null) {\n\t\t\tsetUniqueFactoryMethodName(method.getName());\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#setTargetType(targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the target type of this bean definition, if known in advance.\n\t * @since 3.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "void",
    "signature": "public void setTargetType(@Nullable Class<?> targetType)",
    "source_code": "\tpublic void setTargetType(@Nullable Class<?> targetType) {\n\t\tthis.targetType = (targetType != null ? ResolvableType.forClass(targetType) : null);\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#setUniqueFactoryMethodName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a factory method name that refers to a non-overloaded method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "void",
    "signature": "public void setUniqueFactoryMethodName(String name)",
    "source_code": "\tpublic void setUniqueFactoryMethodName(String name) {\n\t\tAssert.hasText(name, \"Factory method name must not be empty\");\n\t\tsetFactoryMethodName(name);\n\t\tthis.isFactoryMethodUnique = true;\n\t}"
  },
  "org.springframework.beans.factory.support.RootBeanDefinition#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 665
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"Root bean: \" + super.toString();\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Static {@link org.springframework.beans.factory.BeanFactory} implementation\n * which allows one to register existing singleton instances programmatically.\n *\n * <p>Does not have support for prototype beans or aliases.\n *\n * <p>Serves as an example for a simple implementation of the\n * {@link org.springframework.beans.factory.ListableBeanFactory} interface,\n * managing existing bean instances rather than creating new ones based on bean\n * definitions, and not implementing any extended SPI interfaces (such as\n * {@link org.springframework.beans.factory.config.ConfigurableBeanFactory}).\n *\n * <p>For a full-fledged factory based on bean definitions, have a look at\n * {@link DefaultListableBeanFactory}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 06.01.2003\n * @see DefaultListableBeanFactory\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "signature": "public class StaticListableBeanFactory",
    "source_code": "public class StaticListableBeanFactory implements ListableBeanFactory {\n\n\t/** Map from bean name to bean instance. */\n\tprivate final Map<String, Object> beans;\n\n\n\t/**\n\t * Create a regular {@code StaticListableBeanFactory}, to be populated\n\t * with singleton bean instances through {@link #addBean} calls.\n\t */\n\tpublic StaticListableBeanFactory() {\n\t\tthis.beans = new LinkedHashMap<>();\n\t}\n\n\t/**\n\t * Create a {@code StaticListableBeanFactory} wrapping the given {@code Map}.\n\t * <p>Note that the given {@code Map} may be pre-populated with beans;\n\t * or new, still allowing for beans to be registered via {@link #addBean};\n\t * or {@link java.util.Collections#emptyMap()} for a dummy factory which\n\t * enforces operating against an empty set of beans.\n\t * @param beans a {@code Map} for holding this factory's beans, with the\n\t * bean name as key and the corresponding singleton object as value\n\t * @since 4.3\n\t */\n\tpublic StaticListableBeanFactory(Map<String, Object> beans) {\n\t\tAssert.notNull(beans, \"Beans Map must not be null\");\n\t\tthis.beans = beans;\n\t}\n\n\n\t/**\n\t * Add a new singleton bean.\n\t * <p>Will overwrite any existing instance for the given name.\n\t * @param name the name of the bean\n\t * @param bean the bean instance\n\t */\n\tpublic void addBean(String name, Object bean) {\n\t\tthis.beans.put(name, bean);\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of BeanFactory interface\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic Object getBean(String name) throws BeansException {\n\t\tString beanName = BeanFactoryUtils.transformedBeanName(name);\n\t\tObject bean = this.beans.get(beanName);\n\n\t\tif (bean == null) {\n\t\t\tthrow new NoSuchBeanDefinitionException(beanName,\n\t\t\t\t\t\"Defined beans are [\" + StringUtils.collectionToCommaDelimitedString(this.beans.keySet()) + \"]\");\n\t\t}\n\n\t\t// Don't let calling code try to dereference the\n\t\t// bean factory if the bean isn't a factory\n\t\tif (BeanFactoryUtils.isFactoryDereference(name) && !(bean instanceof FactoryBean)) {\n\t\t\tthrow new BeanIsNotAFactoryException(beanName, bean.getClass());\n\t\t}\n\n\t\tif (bean instanceof FactoryBean && !BeanFactoryUtils.isFactoryDereference(name)) {\n\t\t\ttry {\n\t\t\t\tObject exposedObject = ((FactoryBean<?>) bean).getObject();\n\t\t\t\tif (exposedObject == null) {\n\t\t\t\t\tthrow new BeanCreationException(beanName, \"FactoryBean exposed null object\");\n\t\t\t\t}\n\t\t\t\treturn exposedObject;\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new BeanCreationException(beanName, \"FactoryBean threw exception on object creation\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn bean;\n\t\t}\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T getBean(String name, @Nullable Class<T> requiredType) throws BeansException {\n\t\tObject bean = getBean(name);\n\t\tif (requiredType != null && !requiredType.isInstance(bean)) {\n\t\t\tthrow new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n\t\t}\n\t\treturn (T) bean;\n\t}\n\n\t@Override\n\tpublic Object getBean(String name, Object... args) throws BeansException {\n\t\tif (!ObjectUtils.isEmpty(args)) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"StaticListableBeanFactory does not support explicit bean creation arguments\");\n\t\t}\n\t\treturn getBean(name);\n\t}\n\n\t@Override\n\tpublic <T> T getBean(Class<T> requiredType) throws BeansException {\n\t\tString[] beanNames = getBeanNamesForType(requiredType);\n\t\tif (beanNames.length == 1) {\n\t\t\treturn getBean(beanNames[0], requiredType);\n\t\t}\n\t\telse if (beanNames.length > 1) {\n\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, beanNames);\n\t\t}\n\t\telse {\n\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T> T getBean(Class<T> requiredType, Object... args) throws BeansException {\n\t\tif (!ObjectUtils.isEmpty(args)) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"StaticListableBeanFactory does not support explicit bean creation arguments\");\n\t\t}\n\t\treturn getBean(requiredType);\n\t}\n\n\t@Override\n\tpublic <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType) throws BeansException {\n\t\treturn getBeanProvider(ResolvableType.forRawClass(requiredType), true);\n\t}\n\n\t@Override\n\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType) {\n\t\treturn getBeanProvider(requiredType, true);\n\t}\n\n\t@Override\n\tpublic boolean containsBean(String name) {\n\t\treturn this.beans.containsKey(name);\n\t}\n\n\t@Override\n\tpublic boolean isSingleton(String name) throws NoSuchBeanDefinitionException {\n\t\tObject bean = getBean(name);\n\t\t// In case of FactoryBean, return singleton status of created object.\n\t\tif (bean instanceof FactoryBean) {\n\t\t\treturn ((FactoryBean<?>) bean).isSingleton();\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isPrototype(String name) throws NoSuchBeanDefinitionException {\n\t\tObject bean = getBean(name);\n\t\t// In case of FactoryBean, return prototype status of created object.\n\t\treturn ((bean instanceof SmartFactoryBean && ((SmartFactoryBean<?>) bean).isPrototype()) ||\n\t\t\t\t(bean instanceof FactoryBean && !((FactoryBean<?>) bean).isSingleton()));\n\t}\n\n\t@Override\n\tpublic boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException {\n\t\tClass<?> type = getType(name);\n\t\treturn (type != null && typeToMatch.isAssignableFrom(type));\n\t}\n\n\t@Override\n\tpublic boolean isTypeMatch(String name, @Nullable Class<?> typeToMatch) throws NoSuchBeanDefinitionException {\n\t\tClass<?> type = getType(name);\n\t\treturn (typeToMatch == null || (type != null && typeToMatch.isAssignableFrom(type)));\n\t}\n\n\t@Override\n\tpublic Class<?> getType(String name) throws NoSuchBeanDefinitionException {\n\t\treturn getType(name, true);\n\t}\n\n\t@Override\n\tpublic Class<?> getType(String name, boolean allowFactoryBeanInit) throws NoSuchBeanDefinitionException {\n\t\tString beanName = BeanFactoryUtils.transformedBeanName(name);\n\n\t\tObject bean = this.beans.get(beanName);\n\t\tif (bean == null) {\n\t\t\tthrow new NoSuchBeanDefinitionException(beanName,\n\t\t\t\t\t\"Defined beans are [\" + StringUtils.collectionToCommaDelimitedString(this.beans.keySet()) + \"]\");\n\t\t}\n\n\t\tif (bean instanceof FactoryBean && !BeanFactoryUtils.isFactoryDereference(name)) {\n\t\t\t// If it's a FactoryBean, we want to look at what it creates, not the factory class.\n\t\t\treturn ((FactoryBean<?>) bean).getObjectType();\n\t\t}\n\t\treturn bean.getClass();\n\t}\n\n\t@Override\n\tpublic String[] getAliases(String name) {\n\t\treturn new String[0];\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of ListableBeanFactory interface\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic boolean containsBeanDefinition(String name) {\n\t\treturn this.beans.containsKey(name);\n\t}\n\n\t@Override\n\tpublic int getBeanDefinitionCount() {\n\t\treturn this.beans.size();\n\t}\n\n\t@Override\n\tpublic String[] getBeanDefinitionNames() {\n\t\treturn StringUtils.toStringArray(this.beans.keySet());\n\t}\n\n\t@Override\n\tpublic <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType, boolean allowEagerInit) {\n\t\treturn getBeanProvider(ResolvableType.forRawClass(requiredType), allowEagerInit);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit) {\n\t\treturn new ObjectProvider<>() {\n\t\t\t@Override\n\t\t\tpublic T getObject() throws BeansException {\n\t\t\t\tString[] beanNames = getBeanNamesForType(requiredType);\n\t\t\t\tif (beanNames.length == 1) {\n\t\t\t\t\treturn (T) getBean(beanNames[0], requiredType);\n\t\t\t\t}\n\t\t\t\telse if (beanNames.length > 1) {\n\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, beanNames);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic T getObject(Object... args) throws BeansException {\n\t\t\t\tString[] beanNames = getBeanNamesForType(requiredType);\n\t\t\t\tif (beanNames.length == 1) {\n\t\t\t\t\treturn (T) getBean(beanNames[0], args);\n\t\t\t\t}\n\t\t\t\telse if (beanNames.length > 1) {\n\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, beanNames);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T getIfAvailable() throws BeansException {\n\t\t\t\tString[] beanNames = getBeanNamesForType(requiredType);\n\t\t\t\tif (beanNames.length == 1) {\n\t\t\t\t\treturn (T) getBean(beanNames[0]);\n\t\t\t\t}\n\t\t\t\telse if (beanNames.length > 1) {\n\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, beanNames);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T getIfUnique() throws BeansException {\n\t\t\t\tString[] beanNames = getBeanNamesForType(requiredType);\n\t\t\t\tif (beanNames.length == 1) {\n\t\t\t\t\treturn (T) getBean(beanNames[0]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Stream<T> stream() {\n\t\t\t\treturn Arrays.stream(getBeanNamesForType(requiredType)).map(name -> (T) getBean(name));\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Stream<T> orderedStream() {\n\t\t\t\treturn stream().sorted(OrderComparator.INSTANCE);\n\t\t\t}\n\t\t};\n\t}\n\n\t@Override\n\tpublic String[] getBeanNamesForType(@Nullable ResolvableType type) {\n\t\treturn getBeanNamesForType(type, true, true);\n\t}\n\n\t@Override\n\tpublic String[] getBeanNamesForType(@Nullable ResolvableType type,\n\t\t\tboolean includeNonSingletons, boolean allowEagerInit) {\n\n\t\tClass<?> resolved = (type != null ? type.resolve() : null);\n\t\tboolean isFactoryType = resolved != null && FactoryBean.class.isAssignableFrom(resolved);\n\t\tList<String> matches = new ArrayList<>();\n\n\t\tfor (Map.Entry<String, Object> entry : this.beans.entrySet()) {\n\t\t\tString beanName = entry.getKey();\n\t\t\tObject beanInstance = entry.getValue();\n\t\t\tif (beanInstance instanceof FactoryBean<?> factoryBean && !isFactoryType) {\n\t\t\t\tClass<?> objectType = factoryBean.getObjectType();\n\t\t\t\tif ((includeNonSingletons || factoryBean.isSingleton()) &&\n\t\t\t\t\t\tobjectType != null && (type == null || type.isAssignableFrom(objectType))) {\n\t\t\t\t\tmatches.add(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (type == null || type.isInstance(beanInstance)) {\n\t\t\t\t\tmatches.add(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn StringUtils.toStringArray(matches);\n\t}\n\n\t@Override\n\tpublic String[] getBeanNamesForType(@Nullable Class<?> type) {\n\t\treturn getBeanNamesForType(ResolvableType.forClass(type));\n\t}\n\n\t@Override\n\tpublic String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {\n\t\treturn getBeanNamesForType(ResolvableType.forClass(type), includeNonSingletons, allowEagerInit);\n\t}\n\n\t@Override\n\tpublic <T> Map<String, T> getBeansOfType(@Nullable Class<T> type) throws BeansException {\n\t\treturn getBeansOfType(type, true, true);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> Map<String, T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException {\n\n\t\tboolean isFactoryType = (type != null && FactoryBean.class.isAssignableFrom(type));\n\t\tMap<String, T> matches = new LinkedHashMap<>();\n\n\t\tfor (Map.Entry<String, Object> entry : this.beans.entrySet()) {\n\t\t\tString beanName = entry.getKey();\n\t\t\tObject beanInstance = entry.getValue();\n\t\t\t// Is bean a FactoryBean?\n\t\t\tif (beanInstance instanceof FactoryBean<?> factory && !isFactoryType) {\n\t\t\t\t// Match object created by FactoryBean.\n\t\t\t\tClass<?> objectType = factory.getObjectType();\n\t\t\t\tif ((includeNonSingletons || factory.isSingleton()) &&\n\t\t\t\t\t\tobjectType != null && (type == null || type.isAssignableFrom(objectType))) {\n\t\t\t\t\tmatches.put(beanName, getBean(beanName, type));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (type == null || type.isInstance(beanInstance)) {\n\t\t\t\t\t// If type to match is FactoryBean, return FactoryBean itself.\n\t\t\t\t\t// Else, return bean instance.\n\t\t\t\t\tif (isFactoryType) {\n\t\t\t\t\t\tbeanName = FACTORY_BEAN_PREFIX + beanName;\n\t\t\t\t\t}\n\t\t\t\t\tmatches.put(beanName, (T) beanInstance);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn matches;\n\t}\n\n\t@Override\n\tpublic String[] getBeanNamesForAnnotation(Class<? extends Annotation> annotationType) {\n\t\tList<String> results = new ArrayList<>();\n\t\tfor (String beanName : this.beans.keySet()) {\n\t\t\tif (findAnnotationOnBean(beanName, annotationType) != null) {\n\t\t\t\tresults.add(beanName);\n\t\t\t}\n\t\t}\n\t\treturn StringUtils.toStringArray(results);\n\t}\n\n\t@Override\n\tpublic Map<String, Object> getBeansWithAnnotation(Class<? extends Annotation> annotationType)\n\t\t\tthrows BeansException {\n\n\t\tMap<String, Object> results = new LinkedHashMap<>();\n\t\tfor (String beanName : this.beans.keySet()) {\n\t\t\tif (findAnnotationOnBean(beanName, annotationType) != null) {\n\t\t\t\tresults.put(beanName, getBean(beanName));\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\treturn findAnnotationOnBean(beanName, annotationType, true);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic <A extends Annotation> A findAnnotationOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tClass<?> beanType = getType(beanName, allowFactoryBeanInit);\n\t\treturn (beanType != null ? AnnotatedElementUtils.findMergedAnnotation(beanType, annotationType) : null);\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> Set<A> findAllAnnotationsOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit) throws NoSuchBeanDefinitionException {\n\n\t\tClass<?> beanType = getType(beanName, allowFactoryBeanInit);\n\t\treturn (beanType != null ?\n\t\t\t\tAnnotatedElementUtils.findAllMergedAnnotations(beanType, annotationType) : Collections.emptySet());\n\t}\n\n}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#addBean(name,bean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a new singleton bean.\n\t * <p>Will overwrite any existing instance for the given name.\n\t * @param name the name of the bean\n\t * @param bean the bean instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void addBean(String name, Object bean)",
    "source_code": "\tpublic void addBean(String name, Object bean) {\n\t\tthis.beans.put(name, bean);\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#containsBean(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "boolean",
    "signature": "public boolean containsBean(String name)",
    "source_code": "\tpublic boolean containsBean(String name) {\n\t\treturn this.beans.containsKey(name);\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#containsBeanDefinition(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "boolean",
    "signature": "public boolean containsBeanDefinition(String name)",
    "source_code": "\tpublic boolean containsBeanDefinition(String name) {\n\t\treturn this.beans.containsKey(name);\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#findAllAnnotationsOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 476
    },
    "return": "Set<A>",
    "signature": "public Set<A> findAllAnnotationsOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> Set<A> findAllAnnotationsOnBean("
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#findAnnotationOnBean(beanName,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#findAnnotationOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 467
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean("
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#getAliases(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "String[]",
    "signature": "public String[] getAliases(String name)",
    "source_code": "\tpublic String[] getAliases(String name) {\n\t\treturn new String[0];\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#getBean(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "Object",
    "signature": "public Object getBean(String name)",
    "source_code": "\tpublic Object getBean(String name) throws BeansException {\n\t\tString beanName = BeanFactoryUtils.transformedBeanName(name);\n\t\tObject bean = this.beans.get(beanName);\n\n\t\tif (bean == null) {\n\t\t\tthrow new NoSuchBeanDefinitionException(beanName,\n\t\t\t\t\t\"Defined beans are [\" + StringUtils.collectionToCommaDelimitedString(this.beans.keySet()) + \"]\");\n\t\t}\n\n\t\t// Don't let calling code try to dereference the\n\t\t// bean factory if the bean isn't a factory\n\t\tif (BeanFactoryUtils.isFactoryDereference(name) && !(bean instanceof FactoryBean)) {\n\t\t\tthrow new BeanIsNotAFactoryException(beanName, bean.getClass());\n\t\t}\n\n\t\tif (bean instanceof FactoryBean && !BeanFactoryUtils.isFactoryDereference(name)) {\n\t\t\ttry {\n\t\t\t\tObject exposedObject = ((FactoryBean<?>) bean).getObject();\n\t\t\t\tif (exposedObject == null) {\n\t\t\t\t\tthrow new BeanCreationException(beanName, \"FactoryBean exposed null object\");\n\t\t\t\t}\n\t\t\t\treturn exposedObject;\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new BeanCreationException(beanName, \"FactoryBean threw exception on object creation\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn bean;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#getBean(name,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "Object",
    "signature": "public Object getBean(String name, Object... args)",
    "source_code": "\tpublic Object getBean(String name, Object... args) throws BeansException {\n\t\tif (!ObjectUtils.isEmpty(args)) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"StaticListableBeanFactory does not support explicit bean creation arguments\");\n\t\t}\n\t\treturn getBean(name);\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#getBean(name,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "T",
    "signature": "public T getBean(String name, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic <T> T getBean(String name, @Nullable Class<T> requiredType) throws BeansException {\n\t\tObject bean = getBean(name);\n\t\tif (requiredType != null && !requiredType.isInstance(bean)) {\n\t\t\tthrow new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n\t\t}\n\t\treturn (T) bean;\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#getBean(requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "T",
    "signature": "public T getBean(Class<T> requiredType)",
    "source_code": "\tpublic <T> T getBean(Class<T> requiredType) throws BeansException {\n\t\tString[] beanNames = getBeanNamesForType(requiredType);\n\t\tif (beanNames.length == 1) {\n\t\t\treturn getBean(beanNames[0], requiredType);\n\t\t}\n\t\telse if (beanNames.length > 1) {\n\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, beanNames);\n\t\t}\n\t\telse {\n\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#getBean(requiredType,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "T",
    "signature": "public T getBean(Class<T> requiredType, Object... args)",
    "source_code": "\tpublic <T> T getBean(Class<T> requiredType, Object... args) throws BeansException {\n\t\tif (!ObjectUtils.isEmpty(args)) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"StaticListableBeanFactory does not support explicit bean creation arguments\");\n\t\t}\n\t\treturn getBean(requiredType);\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#getBeanDefinitionCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "int",
    "signature": "public int getBeanDefinitionCount()",
    "source_code": "\tpublic int getBeanDefinitionCount() {\n\t\treturn this.beans.size();\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#getBeanDefinitionNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "String[]",
    "signature": "public String[] getBeanDefinitionNames()",
    "source_code": "\tpublic String[] getBeanDefinitionNames() {\n\t\treturn StringUtils.toStringArray(this.beans.keySet());\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#getBeanNamesForAnnotation(annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 434
    },
    "return": "String[]",
    "signature": "public String[] getBeanNamesForAnnotation(Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic String[] getBeanNamesForAnnotation(Class<? extends Annotation> annotationType) {\n\t\tList<String> results = new ArrayList<>();\n\t\tfor (String beanName : this.beans.keySet()) {\n\t\t\tif (findAnnotationOnBean(beanName, annotationType) != null) {\n\t\t\t\tresults.add(beanName);\n\t\t\t}\n\t\t}\n\t\treturn StringUtils.toStringArray(results);\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#getBeanNamesForType(type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "String[]",
    "signature": "public String[] getBeanNamesForType(@Nullable Class<?> type)",
    "source_code": "\tpublic String[] getBeanNamesForType(@Nullable Class<?> type) {\n\t\treturn getBeanNamesForType(ResolvableType.forClass(type));\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#getBeanNamesForType(type,includeNonSingletons,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "String[]",
    "signature": "public String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {\n\t\treturn getBeanNamesForType(ResolvableType.forClass(type), includeNonSingletons, allowEagerInit);\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#getBeanProvider(requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "ObjectProvider<T>",
    "signature": "public ObjectProvider<T> getBeanProvider(ResolvableType requiredType)",
    "source_code": "\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType) {\n\t\treturn getBeanProvider(requiredType, true);\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#getBeanProvider(requiredType,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "ObjectProvider<T>",
    "signature": "public ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit)",
    "source_code": "\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit) {\n\t\treturn new ObjectProvider<>() {\n\t\t\t@Override\n\t\t\tpublic T getObject() throws BeansException {\n\t\t\t\tString[] beanNames = getBeanNamesForType(requiredType);\n\t\t\t\tif (beanNames.length == 1) {\n\t\t\t\t\treturn (T) getBean(beanNames[0], requiredType);\n\t\t\t\t}\n\t\t\t\telse if (beanNames.length > 1) {\n\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, beanNames);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic T getObject(Object... args) throws BeansException {\n\t\t\t\tString[] beanNames = getBeanNamesForType(requiredType);\n\t\t\t\tif (beanNames.length == 1) {\n\t\t\t\t\treturn (T) getBean(beanNames[0], args);\n\t\t\t\t}\n\t\t\t\telse if (beanNames.length > 1) {\n\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, beanNames);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T getIfAvailable() throws BeansException {\n\t\t\t\tString[] beanNames = getBeanNamesForType(requiredType);\n\t\t\t\tif (beanNames.length == 1) {\n\t\t\t\t\treturn (T) getBean(beanNames[0]);\n\t\t\t\t}\n\t\t\t\telse if (beanNames.length > 1) {\n\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, beanNames);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T getIfUnique() throws BeansException {\n\t\t\t\tString[] beanNames = getBeanNamesForType(requiredType);\n\t\t\t\tif (beanNames.length == 1) {\n\t\t\t\t\treturn (T) getBean(beanNames[0]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Stream<T> stream() {\n\t\t\t\treturn Arrays.stream(getBeanNamesForType(requiredType)).map(name -> (T) getBean(name));\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Stream<T> orderedStream() {\n\t\t\t\treturn stream().sorted(OrderComparator.INSTANCE);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#getBeansOfType(type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 395
    },
    "return": "T>",
    "signature": "public T> getBeansOfType(@Nullable Class<T> type)",
    "source_code": "\tpublic <T> Map<String, T> getBeansOfType(@Nullable Class<T> type) throws BeansException {\n\t\treturn getBeansOfType(type, true, true);\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#getBeansOfType(type,includeNonSingletons,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "T>",
    "signature": "public T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic <T> Map<String, T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#getBeansWithAnnotation(annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 445
    },
    "return": "Object>",
    "signature": "public Object> getBeansWithAnnotation(Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic Map<String, Object> getBeansWithAnnotation(Class<? extends Annotation> annotationType)"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#getIfAvailable()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "T",
    "signature": "public T getIfAvailable()",
    "source_code": "\t\t\tpublic T getIfAvailable() throws BeansException {\n\t\t\t\tString[] beanNames = getBeanNamesForType(requiredType);\n\t\t\t\tif (beanNames.length == 1) {\n\t\t\t\t\treturn (T) getBean(beanNames[0]);\n\t\t\t\t}\n\t\t\t\telse if (beanNames.length > 1) {\n\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, beanNames);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#getIfUnique()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "T",
    "signature": "public T getIfUnique()",
    "source_code": "\t\t\tpublic T getIfUnique() throws BeansException {\n\t\t\t\tString[] beanNames = getBeanNamesForType(requiredType);\n\t\t\t\tif (beanNames.length == 1) {\n\t\t\t\t\treturn (T) getBean(beanNames[0]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#getObject()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "T",
    "signature": "public T getObject()",
    "source_code": "\t\t\tpublic T getObject() throws BeansException {\n\t\t\t\tString[] beanNames = getBeanNamesForType(requiredType);\n\t\t\t\tif (beanNames.length == 1) {\n\t\t\t\t\treturn (T) getBean(beanNames[0], requiredType);\n\t\t\t\t}\n\t\t\t\telse if (beanNames.length > 1) {\n\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, beanNames);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#getObject(args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "args"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "T",
    "signature": "public T getObject(Object... args)",
    "source_code": "\t\t\tpublic T getObject(Object... args) throws BeansException {\n\t\t\t\tString[] beanNames = getBeanNamesForType(requiredType);\n\t\t\t\tif (beanNames.length == 1) {\n\t\t\t\t\treturn (T) getBean(beanNames[0], args);\n\t\t\t\t}\n\t\t\t\telse if (beanNames.length > 1) {\n\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, beanNames);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#isPrototype(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "boolean",
    "signature": "public boolean isPrototype(String name)",
    "source_code": "\tpublic boolean isPrototype(String name) throws NoSuchBeanDefinitionException {\n\t\tObject bean = getBean(name);\n\t\t// In case of FactoryBean, return prototype status of created object.\n\t\treturn ((bean instanceof SmartFactoryBean && ((SmartFactoryBean<?>) bean).isPrototype()) ||\n\t\t\t\t(bean instanceof FactoryBean && !((FactoryBean<?>) bean).isSingleton()));\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#isSingleton(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "boolean",
    "signature": "public boolean isSingleton(String name)",
    "source_code": "\tpublic boolean isSingleton(String name) throws NoSuchBeanDefinitionException {\n\t\tObject bean = getBean(name);\n\t\t// In case of FactoryBean, return singleton status of created object.\n\t\tif (bean instanceof FactoryBean) {\n\t\t\treturn ((FactoryBean<?>) bean).isSingleton();\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#isTypeMatch(name,typeToMatch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "typeToMatch"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "boolean",
    "signature": "public boolean isTypeMatch(String name, @Nullable Class<?> typeToMatch)",
    "source_code": "\tpublic boolean isTypeMatch(String name, @Nullable Class<?> typeToMatch) throws NoSuchBeanDefinitionException {\n\t\tClass<?> type = getType(name);\n\t\treturn (typeToMatch == null || (type != null && typeToMatch.isAssignableFrom(type)));\n\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#orderedStream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> orderedStream()",
    "source_code": "\t\t\tpublic Stream<T> orderedStream() {\n\t\t\t\treturn stream().sorted(OrderComparator.INSTANCE);\n\t\t\t}"
  },
  "org.springframework.beans.factory.support.StaticListableBeanFactory#stream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 342
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> stream()",
    "source_code": "\t\t\tpublic Stream<T> stream() {\n\t\t\t\treturn Arrays.stream(getBeanNamesForType(requiredType)).map(name -> (T) getBean(name));\n\t\t\t}"
  },
  "org.springframework.beans.factory.support.logger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Logger available to subclasses. */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.beans.factory.wiring.BeanConfigurerSupport": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Convenient base class for bean configurers that can perform Dependency Injection\n * on objects (however they may be created). Typically subclassed by AspectJ aspects.\n *\n * <p>Subclasses may also need a custom metadata resolution strategy, in the\n * {@link BeanWiringInfoResolver} interface. The default implementation looks for\n * a bean with the same name as the fully-qualified class name. (This is the default\n * name of the bean in a Spring XML file if the '{@code id}' attribute is not used.)\n\n * @author Rob Harrop\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Adrian Colyer\n * @since 2.0\n * @see #setBeanWiringInfoResolver\n * @see ClassNameBeanWiringInfoResolver\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class BeanConfigurerSupport",
    "source_code": "public class BeanConfigurerSupport implements BeanFactoryAware, InitializingBean, DisposableBean {\n\n\t/** Logger available to subclasses. */\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t@Nullable\n\tprivate volatile BeanWiringInfoResolver beanWiringInfoResolver;\n\n\t@Nullable\n\tprivate volatile ConfigurableListableBeanFactory beanFactory;\n\n\n\t/**\n\t * Set the {@link BeanWiringInfoResolver} to use.\n\t * <p>The default behavior is to look for a bean with the same name as the class.\n\t * As an alternative, consider using annotation-driven bean wiring.\n\t * @see ClassNameBeanWiringInfoResolver\n\t * @see org.springframework.beans.factory.annotation.AnnotationBeanWiringInfoResolver\n\t */\n\tpublic void setBeanWiringInfoResolver(BeanWiringInfoResolver beanWiringInfoResolver) {\n\t\tAssert.notNull(beanWiringInfoResolver, \"BeanWiringInfoResolver must not be null\");\n\t\tthis.beanWiringInfoResolver = beanWiringInfoResolver;\n\t}\n\n\t/**\n\t * Set the {@link BeanFactory} in which this aspect must configure beans.\n\t */\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tif (!(beanFactory instanceof ConfigurableListableBeanFactory clbf)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Bean configurer aspect needs to run in a ConfigurableListableBeanFactory: \" + beanFactory);\n\t\t}\n\t\tthis.beanFactory = clbf;\n\t\tif (this.beanWiringInfoResolver == null) {\n\t\t\tthis.beanWiringInfoResolver = createDefaultBeanWiringInfoResolver();\n\t\t}\n\t}\n\n\t/**\n\t * Create the default BeanWiringInfoResolver to be used if none was\n\t * specified explicitly.\n\t * <p>The default implementation builds a {@link ClassNameBeanWiringInfoResolver}.\n\t * @return the default BeanWiringInfoResolver (never {@code null})\n\t */\n\t@Nullable\n\tprotected BeanWiringInfoResolver createDefaultBeanWiringInfoResolver() {\n\t\treturn new ClassNameBeanWiringInfoResolver();\n\t}\n\n\t/**\n\t * Check that a {@link BeanFactory} has been set.\n\t */\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\tAssert.notNull(this.beanFactory, \"BeanFactory must be set\");\n\t}\n\n\t/**\n\t * Release references to the {@link BeanFactory} and\n\t * {@link BeanWiringInfoResolver} when the container is destroyed.\n\t */\n\t@Override\n\tpublic void destroy() {\n\t\tthis.beanFactory = null;\n\t\tthis.beanWiringInfoResolver = null;\n\t}\n\n\n\t/**\n\t * Configure the bean instance.\n\t * <p>Subclasses can override this to provide custom configuration logic.\n\t * Typically called by an aspect, for all bean instances matched by a pointcut.\n\t * @param beanInstance the bean instance to configure (must <b>not</b> be {@code null})\n\t */\n\tpublic void configureBean(Object beanInstance) {\n\t\tif (this.beanFactory == null) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"BeanFactory has not been set on \" + ClassUtils.getShortName(getClass()) + \": \" +\n\t\t\t\t\t\t\"Make sure this configurer runs in a Spring container. Unable to configure bean of type [\" +\n\t\t\t\t\t\tClassUtils.getDescriptiveType(beanInstance) + \"]. Proceeding without injection.\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tBeanWiringInfoResolver bwiResolver = this.beanWiringInfoResolver;\n\t\tAssert.state(bwiResolver != null, \"No BeanWiringInfoResolver available\");\n\t\tBeanWiringInfo bwi = bwiResolver.resolveWiringInfo(beanInstance);\n\t\tif (bwi == null) {\n\t\t\t// Skip the bean if no wiring info given.\n\t\t\treturn;\n\t\t}\n\n\n\t\tConfigurableListableBeanFactory beanFactory = this.beanFactory;\n\t\tAssert.state(beanFactory != null, \"No BeanFactory available\");\n\t\ttry {\n\t\t\tString beanName = bwi.getBeanName();\n\t\t\tif (bwi.indicatesAutowiring() || (bwi.isDefaultBeanName() && beanName != null &&\n\t\t\t\t\t!beanFactory.containsBean(beanName))) {\n\t\t\t\t// Perform autowiring (also applying standard factory / post-processor callbacks).\n\t\t\t\tbeanFactory.autowireBeanProperties(beanInstance, bwi.getAutowireMode(), bwi.getDependencyCheck());\n\t\t\t\tbeanFactory.initializeBean(beanInstance, (beanName != null ? beanName : \"\"));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Perform explicit wiring based on the specified bean definition.\n\t\t\t\tbeanFactory.configureBean(beanInstance, (beanName != null ? beanName : \"\"));\n\t\t\t}\n\t\t}\n\t\tcatch (BeanCreationException ex) {\n\t\t\tThrowable rootCause = ex.getMostSpecificCause();\n\t\t\tif (rootCause instanceof BeanCurrentlyInCreationException bce) {\n\t\t\t\tString bceBeanName = bce.getBeanName();\n\t\t\t\tif (bceBeanName != null && beanFactory.isCurrentlyInCreation(bceBeanName)) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Failed to create target bean '\" + bce.getBeanName() +\n\t\t\t\t\t\t\t\t\"' while configuring object of type [\" + beanInstance.getClass().getName() +\n\t\t\t\t\t\t\t\t\"] - probably due to a circular reference. This is a common startup situation \" +\n\t\t\t\t\t\t\t\t\"and usually not fatal. Proceeding without injection. Original exception: \" + ex);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.beans.factory.wiring.BeanConfigurerSupport#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check that a {@link BeanFactory} has been set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tAssert.notNull(this.beanFactory, \"BeanFactory must be set\");\n\t}"
  },
  "org.springframework.beans.factory.wiring.BeanConfigurerSupport#configureBean(beanInstance)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the bean instance.\n\t * <p>Subclasses can override this to provide custom configuration logic.\n\t * Typically called by an aspect, for all bean instances matched by a pointcut.\n\t * @param beanInstance the bean instance to configure (must <b>not</b> be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanInstance"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void configureBean(Object beanInstance)",
    "source_code": "\tpublic void configureBean(Object beanInstance) {\n\t\tif (this.beanFactory == null) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"BeanFactory has not been set on \" + ClassUtils.getShortName(getClass()) + \": \" +\n\t\t\t\t\t\t\"Make sure this configurer runs in a Spring container. Unable to configure bean of type [\" +\n\t\t\t\t\t\tClassUtils.getDescriptiveType(beanInstance) + \"]. Proceeding without injection.\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tBeanWiringInfoResolver bwiResolver = this.beanWiringInfoResolver;\n\t\tAssert.state(bwiResolver != null, \"No BeanWiringInfoResolver available\");\n\t\tBeanWiringInfo bwi = bwiResolver.resolveWiringInfo(beanInstance);\n\t\tif (bwi == null) {\n\t\t\t// Skip the bean if no wiring info given.\n\t\t\treturn;\n\t\t}\n\n\n\t\tConfigurableListableBeanFactory beanFactory = this.beanFactory;\n\t\tAssert.state(beanFactory != null, \"No BeanFactory available\");\n\t\ttry {\n\t\t\tString beanName = bwi.getBeanName();\n\t\t\tif (bwi.indicatesAutowiring() || (bwi.isDefaultBeanName() && beanName != null &&\n\t\t\t\t\t!beanFactory.containsBean(beanName))) {\n\t\t\t\t// Perform autowiring (also applying standard factory / post-processor callbacks).\n\t\t\t\tbeanFactory.autowireBeanProperties(beanInstance, bwi.getAutowireMode(), bwi.getDependencyCheck());\n\t\t\t\tbeanFactory.initializeBean(beanInstance, (beanName != null ? beanName : \"\"));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Perform explicit wiring based on the specified bean definition.\n\t\t\t\tbeanFactory.configureBean(beanInstance, (beanName != null ? beanName : \"\"));\n\t\t\t}\n\t\t}\n\t\tcatch (BeanCreationException ex) {\n\t\t\tThrowable rootCause = ex.getMostSpecificCause();\n\t\t\tif (rootCause instanceof BeanCurrentlyInCreationException bce) {\n\t\t\t\tString bceBeanName = bce.getBeanName();\n\t\t\t\tif (bceBeanName != null && beanFactory.isCurrentlyInCreation(bceBeanName)) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Failed to create target bean '\" + bce.getBeanName() +\n\t\t\t\t\t\t\t\t\"' while configuring object of type [\" + beanInstance.getClass().getName() +\n\t\t\t\t\t\t\t\t\"] - probably due to a circular reference. This is a common startup situation \" +\n\t\t\t\t\t\t\t\t\"and usually not fatal. Proceeding without injection. Original exception: \" + ex);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.wiring.BeanConfigurerSupport#createDefaultBeanWiringInfoResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the default BeanWiringInfoResolver to be used if none was\n\t * specified explicitly.\n\t * <p>The default implementation builds a {@link ClassNameBeanWiringInfoResolver}.\n\t * @return the default BeanWiringInfoResolver (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "BeanWiringInfoResolver",
    "signature": "protected BeanWiringInfoResolver createDefaultBeanWiringInfoResolver()",
    "source_code": "\tprotected BeanWiringInfoResolver createDefaultBeanWiringInfoResolver() {\n\t\treturn new ClassNameBeanWiringInfoResolver();\n\t}"
  },
  "org.springframework.beans.factory.wiring.BeanConfigurerSupport#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Release references to the {@link BeanFactory} and\n\t * {@link BeanWiringInfoResolver} when the container is destroyed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t\tthis.beanFactory = null;\n\t\tthis.beanWiringInfoResolver = null;\n\t}"
  },
  "org.springframework.beans.factory.wiring.BeanConfigurerSupport#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link BeanFactory} in which this aspect must configure beans.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tif (!(beanFactory instanceof ConfigurableListableBeanFactory clbf)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Bean configurer aspect needs to run in a ConfigurableListableBeanFactory: \" + beanFactory);\n\t\t}\n\t\tthis.beanFactory = clbf;\n\t\tif (this.beanWiringInfoResolver == null) {\n\t\t\tthis.beanWiringInfoResolver = createDefaultBeanWiringInfoResolver();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.wiring.BeanConfigurerSupport#setBeanWiringInfoResolver(beanWiringInfoResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link BeanWiringInfoResolver} to use.\n\t * <p>The default behavior is to look for a bean with the same name as the class.\n\t * As an alternative, consider using annotation-driven bean wiring.\n\t * @see ClassNameBeanWiringInfoResolver\n\t * @see org.springframework.beans.factory.annotation.AnnotationBeanWiringInfoResolver\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanWiringInfoResolver"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void setBeanWiringInfoResolver(BeanWiringInfoResolver beanWiringInfoResolver)",
    "source_code": "\tpublic void setBeanWiringInfoResolver(BeanWiringInfoResolver beanWiringInfoResolver) {\n\t\tAssert.notNull(beanWiringInfoResolver, \"BeanWiringInfoResolver must not be null\");\n\t\tthis.beanWiringInfoResolver = beanWiringInfoResolver;\n\t}"
  },
  "org.springframework.beans.factory.wiring.logger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Logger available to subclasses. */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.beans.factory.xml.DEFAULT_HANDLER_MAPPINGS_LOCATION": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The location to look for the mapping files. Can be present in multiple JAR files.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public String DEFAULT_HANDLER_MAPPINGS_LOCATION",
    "source_code": "\tpublic static final String DEFAULT_HANDLER_MAPPINGS_LOCATION = \"META-INF/spring.handlers\";",
    "type": "String"
  },
  "org.springframework.beans.factory.xml.DefaultNamespaceHandlerResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Default implementation of the {@link NamespaceHandlerResolver} interface.\n * Resolves namespace URIs to implementation classes based on the mappings\n * contained in mapping file.\n *\n * <p>By default, this implementation looks for the mapping file at\n * {@code META-INF/spring.handlers}, but this can be changed using the\n * {@link #DefaultNamespaceHandlerResolver(ClassLoader, String)} constructor.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @since 2.0\n * @see NamespaceHandler\n * @see DefaultBeanDefinitionDocumentReader\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class DefaultNamespaceHandlerResolver",
    "source_code": "public class DefaultNamespaceHandlerResolver implements NamespaceHandlerResolver {\n\n\t/**\n\t * The location to look for the mapping files. Can be present in multiple JAR files.\n\t */\n\tpublic static final String DEFAULT_HANDLER_MAPPINGS_LOCATION = \"META-INF/spring.handlers\";\n\n\n\t/** Logger available to subclasses. */\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t/** ClassLoader to use for NamespaceHandler classes. */\n\t@Nullable\n\tprivate final ClassLoader classLoader;\n\n\t/** Resource location to search for. */\n\tprivate final String handlerMappingsLocation;\n\n\t/** Stores the mappings from namespace URI to NamespaceHandler class name / instance. */\n\t@Nullable\n\tprivate volatile Map<String, Object> handlerMappings;\n\n\n\t/**\n\t * Create a new {@code DefaultNamespaceHandlerResolver} using the\n\t * default mapping file location.\n\t * <p>This constructor will result in the thread context ClassLoader being used\n\t * to load resources.\n\t * @see #DEFAULT_HANDLER_MAPPINGS_LOCATION\n\t */\n\tpublic DefaultNamespaceHandlerResolver() {\n\t\tthis(null, DEFAULT_HANDLER_MAPPINGS_LOCATION);\n\t}\n\n\t/**\n\t * Create a new {@code DefaultNamespaceHandlerResolver} using the\n\t * default mapping file location.\n\t * @param classLoader the {@link ClassLoader} instance used to load mapping resources\n\t * (may be {@code null}, in which case the thread context ClassLoader will be used)\n\t * @see #DEFAULT_HANDLER_MAPPINGS_LOCATION\n\t */\n\tpublic DefaultNamespaceHandlerResolver(@Nullable ClassLoader classLoader) {\n\t\tthis(classLoader, DEFAULT_HANDLER_MAPPINGS_LOCATION);\n\t}\n\n\t/**\n\t * Create a new {@code DefaultNamespaceHandlerResolver} using the\n\t * supplied mapping file location.\n\t * @param classLoader the {@link ClassLoader} instance used to load mapping resources\n\t * may be {@code null}, in which case the thread context ClassLoader will be used\n\t * @param handlerMappingsLocation the mapping file location\n\t */\n\tpublic DefaultNamespaceHandlerResolver(@Nullable ClassLoader classLoader, String handlerMappingsLocation) {\n\t\tAssert.notNull(handlerMappingsLocation, \"Handler mappings location must not be null\");\n\t\tthis.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());\n\t\tthis.handlerMappingsLocation = handlerMappingsLocation;\n\t}\n\n\n\t/**\n\t * Locate the {@link NamespaceHandler} for the supplied namespace URI\n\t * from the configured mappings.\n\t * @param namespaceUri the relevant namespace URI\n\t * @return the located {@link NamespaceHandler}, or {@code null} if none found\n\t */\n\t@Override\n\t@Nullable\n\tpublic NamespaceHandler resolve(String namespaceUri) {\n\t\tMap<String, Object> handlerMappings = getHandlerMappings();\n\t\tObject handlerOrClassName = handlerMappings.get(namespaceUri);\n\t\tif (handlerOrClassName == null) {\n\t\t\treturn null;\n\t\t}\n\t\telse if (handlerOrClassName instanceof NamespaceHandler namespaceHandler) {\n\t\t\treturn namespaceHandler;\n\t\t}\n\t\telse {\n\t\t\tString className = (String) handlerOrClassName;\n\t\t\ttry {\n\t\t\t\tClass<?> handlerClass = ClassUtils.forName(className, this.classLoader);\n\t\t\t\tif (!NamespaceHandler.class.isAssignableFrom(handlerClass)) {\n\t\t\t\t\tthrow new FatalBeanException(\"Class [\" + className + \"] for namespace [\" + namespaceUri +\n\t\t\t\t\t\t\t\"] does not implement the [\" + NamespaceHandler.class.getName() + \"] interface\");\n\t\t\t\t}\n\t\t\t\tNamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);\n\t\t\t\tnamespaceHandler.init();\n\t\t\t\thandlerMappings.put(namespaceUri, namespaceHandler);\n\t\t\t\treturn namespaceHandler;\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\tthrow new FatalBeanException(\"Could not find NamespaceHandler class [\" + className +\n\t\t\t\t\t\t\"] for namespace [\" + namespaceUri + \"]\", ex);\n\t\t\t}\n\t\t\tcatch (LinkageError err) {\n\t\t\t\tthrow new FatalBeanException(\"Unresolvable class definition for NamespaceHandler class [\" +\n\t\t\t\t\t\tclassName + \"] for namespace [\" + namespaceUri + \"]\", err);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Load the specified NamespaceHandler mappings lazily.\n\t */\n\tprivate Map<String, Object> getHandlerMappings() {\n\t\tMap<String, Object> handlerMappings = this.handlerMappings;\n\t\tif (handlerMappings == null) {\n\t\t\tsynchronized (this) {\n\t\t\t\thandlerMappings = this.handlerMappings;\n\t\t\t\tif (handlerMappings == null) {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Loading NamespaceHandler mappings from [\" + this.handlerMappingsLocation + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tProperties mappings =\n\t\t\t\t\t\t\t\tPropertiesLoaderUtils.loadAllProperties(this.handlerMappingsLocation, this.classLoader);\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Loaded NamespaceHandler mappings: \" + mappings);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandlerMappings = new ConcurrentHashMap<>(mappings.size());\n\t\t\t\t\t\tCollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);\n\t\t\t\t\t\tthis.handlerMappings = handlerMappings;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\"Unable to load NamespaceHandler mappings from location [\" + this.handlerMappingsLocation + \"]\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn handlerMappings;\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"NamespaceHandlerResolver using mappings \" + getHandlerMappings();\n\t}\n\n}"
  },
  "org.springframework.beans.factory.xml.DefaultNamespaceHandlerResolver#resolve(namespaceUri)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Locate the {@link NamespaceHandler} for the supplied namespace URI\n\t * from the configured mappings.\n\t * @param namespaceUri the relevant namespace URI\n\t * @return the located {@link NamespaceHandler}, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "namespaceUri"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "NamespaceHandler",
    "signature": "public NamespaceHandler resolve(String namespaceUri)",
    "source_code": "\tpublic NamespaceHandler resolve(String namespaceUri) {\n\t\tMap<String, Object> handlerMappings = getHandlerMappings();\n\t\tObject handlerOrClassName = handlerMappings.get(namespaceUri);\n\t\tif (handlerOrClassName == null) {\n\t\t\treturn null;\n\t\t}\n\t\telse if (handlerOrClassName instanceof NamespaceHandler namespaceHandler) {\n\t\t\treturn namespaceHandler;\n\t\t}\n\t\telse {\n\t\t\tString className = (String) handlerOrClassName;\n\t\t\ttry {\n\t\t\t\tClass<?> handlerClass = ClassUtils.forName(className, this.classLoader);\n\t\t\t\tif (!NamespaceHandler.class.isAssignableFrom(handlerClass)) {\n\t\t\t\t\tthrow new FatalBeanException(\"Class [\" + className + \"] for namespace [\" + namespaceUri +\n\t\t\t\t\t\t\t\"] does not implement the [\" + NamespaceHandler.class.getName() + \"] interface\");\n\t\t\t\t}\n\t\t\t\tNamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);\n\t\t\t\tnamespaceHandler.init();\n\t\t\t\thandlerMappings.put(namespaceUri, namespaceHandler);\n\t\t\t\treturn namespaceHandler;\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\tthrow new FatalBeanException(\"Could not find NamespaceHandler class [\" + className +\n\t\t\t\t\t\t\"] for namespace [\" + namespaceUri + \"]\", ex);\n\t\t\t}\n\t\t\tcatch (LinkageError err) {\n\t\t\t\tthrow new FatalBeanException(\"Unresolvable class definition for NamespaceHandler class [\" +\n\t\t\t\t\t\tclassName + \"] for namespace [\" + namespaceUri + \"]\", err);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.DefaultNamespaceHandlerResolver#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"NamespaceHandlerResolver using mappings \" + getHandlerMappings();\n\t}"
  },
  "org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * XML-specific BeanDefinitionStoreException subclass that wraps a\n * {@link org.xml.sax.SAXException}, typically a {@link org.xml.sax.SAXParseException}\n * which contains information about the error location.\n *\n * @author Juergen Hoeller\n * @since 2.0.2\n * @see #getLineNumber()\n * @see org.xml.sax.SAXParseException\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class XmlBeanDefinitionStoreException",
    "source_code": "public class XmlBeanDefinitionStoreException extends BeanDefinitionStoreException {\n\n\t/**\n\t * Create a new XmlBeanDefinitionStoreException.\n\t * @param resourceDescription description of the resource that the bean definition came from\n\t * @param msg the detail message (used as exception message as-is)\n\t * @param cause the SAXException (typically a SAXParseException) root cause\n\t * @see org.xml.sax.SAXParseException\n\t */\n\tpublic XmlBeanDefinitionStoreException(String resourceDescription, String msg, SAXException cause) {\n\t\tsuper(resourceDescription, msg, cause);\n\t}\n\n\t/**\n\t * Return the line number in the XML resource that failed.\n\t * @return the line number if available (in case of a SAXParseException); -1 else\n\t * @see org.xml.sax.SAXParseException#getLineNumber()\n\t */\n\tpublic int getLineNumber() {\n\t\tThrowable cause = getCause();\n\t\tif (cause instanceof SAXParseException parseEx) {\n\t\t\treturn parseEx.getLineNumber();\n\t\t}\n\t\treturn -1;\n\t}\n\n}"
  },
  "org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException#getLineNumber()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the line number in the XML resource that failed.\n\t * @return the line number if available (in case of a SAXParseException); -1 else\n\t * @see org.xml.sax.SAXParseException#getLineNumber()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "int",
    "signature": "public int getLineNumber()",
    "source_code": "\tpublic int getLineNumber() {\n\t\tThrowable cause = getCause();\n\t\tif (cause instanceof SAXParseException parseEx) {\n\t\t\treturn parseEx.getLineNumber();\n\t\t}\n\t\treturn -1;\n\t}"
  },
  "org.springframework.beans.propertyeditors.CustomNumberEditor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Property editor for any Number subclass such as Short, Integer, Long,\n * BigInteger, Float, Double, BigDecimal. Can use a given NumberFormat for\n * (locale-specific) parsing and rendering, or alternatively the default\n * {@code decode} / {@code valueOf} / {@code toString} methods.\n *\n * <p>This is not meant to be used as system PropertyEditor but rather\n * as locale-specific number editor within custom controller code,\n * parsing user-entered number strings into Number properties of beans\n * and rendering them in the UI form.\n *\n * <p>In web MVC code, this editor will typically be registered with\n * {@code binder.registerCustomEditor} calls.\n *\n * @author Juergen Hoeller\n * @since 06.06.2003\n * @see Number\n * @see java.text.NumberFormat\n * @see org.springframework.validation.DataBinder#registerCustomEditor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class CustomNumberEditor",
    "source_code": "public class CustomNumberEditor extends PropertyEditorSupport {\n\n\tprivate final Class<? extends Number> numberClass;\n\n\t@Nullable\n\tprivate final NumberFormat numberFormat;\n\n\tprivate final boolean allowEmpty;\n\n\n\t/**\n\t * Create a new CustomNumberEditor instance, using the default\n\t * {@code valueOf} methods for parsing and {@code toString}\n\t * methods for rendering.\n\t * <p>The \"allowEmpty\" parameter states if an empty String should\n\t * be allowed for parsing, i.e. get interpreted as {@code null} value.\n\t * Else, an IllegalArgumentException gets thrown in that case.\n\t * @param numberClass the Number subclass to generate\n\t * @param allowEmpty if empty strings should be allowed\n\t * @throws IllegalArgumentException if an invalid numberClass has been specified\n\t * @see org.springframework.util.NumberUtils#parseNumber(String, Class)\n\t * @see Integer#valueOf\n\t * @see Integer#toString\n\t */\n\tpublic CustomNumberEditor(Class<? extends Number> numberClass, boolean allowEmpty) throws IllegalArgumentException {\n\t\tthis(numberClass, null, allowEmpty);\n\t}\n\n\t/**\n\t * Create a new CustomNumberEditor instance, using the given NumberFormat\n\t * for parsing and rendering.\n\t * <p>The allowEmpty parameter states if an empty String should\n\t * be allowed for parsing, i.e. get interpreted as {@code null} value.\n\t * Else, an IllegalArgumentException gets thrown in that case.\n\t * @param numberClass the Number subclass to generate\n\t * @param numberFormat the NumberFormat to use for parsing and rendering\n\t * @param allowEmpty if empty strings should be allowed\n\t * @throws IllegalArgumentException if an invalid numberClass has been specified\n\t * @see org.springframework.util.NumberUtils#parseNumber(String, Class, java.text.NumberFormat)\n\t * @see java.text.NumberFormat#parse\n\t * @see java.text.NumberFormat#format\n\t */\n\tpublic CustomNumberEditor(Class<? extends Number> numberClass,\n\t\t\t@Nullable NumberFormat numberFormat, boolean allowEmpty) throws IllegalArgumentException {\n\n\t\tif (!Number.class.isAssignableFrom(numberClass)) {\n\t\t\tthrow new IllegalArgumentException(\"Property class must be a subclass of Number\");\n\t\t}\n\t\tthis.numberClass = numberClass;\n\t\tthis.numberFormat = numberFormat;\n\t\tthis.allowEmpty = allowEmpty;\n\t}\n\n\n\t/**\n\t * Parse the Number from the given text, using the specified NumberFormat.\n\t */\n\t@Override\n\tpublic void setAsText(String text) throws IllegalArgumentException {\n\t\tif (this.allowEmpty && !StringUtils.hasText(text)) {\n\t\t\t// Treat empty String as null value.\n\t\t\tsetValue(null);\n\t\t}\n\t\telse if (this.numberFormat != null) {\n\t\t\t// Use given NumberFormat for parsing text.\n\t\t\tsetValue(NumberUtils.parseNumber(text, this.numberClass, this.numberFormat));\n\t\t}\n\t\telse {\n\t\t\t// Use default valueOf methods for parsing text.\n\t\t\tsetValue(NumberUtils.parseNumber(text, this.numberClass));\n\t\t}\n\t}\n\n\t/**\n\t * Coerce a Number value into the required target class, if necessary.\n\t */\n\t@Override\n\tpublic void setValue(@Nullable Object value) {\n\t\tif (value instanceof Number num) {\n\t\t\tsuper.setValue(NumberUtils.convertNumberToTargetClass(num, this.numberClass));\n\t\t}\n\t\telse {\n\t\t\tsuper.setValue(value);\n\t\t}\n\t}\n\n\t/**\n\t * Format the Number as String, using the specified NumberFormat.\n\t */\n\t@Override\n\tpublic String getAsText() {\n\t\tObject value = getValue();\n\t\tif (value == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tif (this.numberFormat != null) {\n\t\t\t// Use NumberFormat for rendering value.\n\t\t\treturn this.numberFormat.format(value);\n\t\t}\n\t\telse {\n\t\t\t// Use toString method for rendering value.\n\t\t\treturn value.toString();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.beans.propertyeditors.CustomNumberEditor#getAsText()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Format the Number as String, using the specified NumberFormat.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "String",
    "signature": "public String getAsText()",
    "source_code": "\tpublic String getAsText() {\n\t\tObject value = getValue();\n\t\tif (value == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tif (this.numberFormat != null) {\n\t\t\t// Use NumberFormat for rendering value.\n\t\t\treturn this.numberFormat.format(value);\n\t\t}\n\t\telse {\n\t\t\t// Use toString method for rendering value.\n\t\t\treturn value.toString();\n\t\t}\n\t}"
  },
  "org.springframework.beans.propertyeditors.CustomNumberEditor#setAsText(text)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the Number from the given text, using the specified NumberFormat.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "void",
    "signature": "public void setAsText(String text)",
    "source_code": "\tpublic void setAsText(String text) throws IllegalArgumentException {\n\t\tif (this.allowEmpty && !StringUtils.hasText(text)) {\n\t\t\t// Treat empty String as null value.\n\t\t\tsetValue(null);\n\t\t}\n\t\telse if (this.numberFormat != null) {\n\t\t\t// Use given NumberFormat for parsing text.\n\t\t\tsetValue(NumberUtils.parseNumber(text, this.numberClass, this.numberFormat));\n\t\t}\n\t\telse {\n\t\t\t// Use default valueOf methods for parsing text.\n\t\t\tsetValue(NumberUtils.parseNumber(text, this.numberClass));\n\t\t}\n\t}"
  },
  "org.springframework.beans.propertyeditors.CustomNumberEditor#setValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Coerce a Number value into the required target class, if necessary.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "public void setValue(@Nullable Object value)",
    "source_code": "\tpublic void setValue(@Nullable Object value) {\n\t\tif (value instanceof Number num) {\n\t\t\tsuper.setValue(NumberUtils.convertNumberToTargetClass(num, this.numberClass));\n\t\t}\n\t\telse {\n\t\t\tsuper.setValue(value);\n\t\t}\n\t}"
  },
  "org.springframework.beans.propertyeditors.PropertiesEditor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Custom {@link java.beans.PropertyEditor} for {@link Properties} objects.\n *\n * <p>Handles conversion from content {@link String} to {@code Properties} object.\n * Also handles {@link Map} to {@code Properties} conversion, for populating\n * a {@code Properties} object via XML \"map\" entries.\n *\n * <p>The required format is defined in the standard {@code Properties}\n * documentation. Each property must be on a new line.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @see java.util.Properties#load\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class PropertiesEditor",
    "source_code": "public class PropertiesEditor extends PropertyEditorSupport {\n\n\t/**\n\t * Convert {@link String} into {@link Properties}, considering it as\n\t * properties content.\n\t * @param text the text to be so converted\n\t */\n\t@Override\n\tpublic void setAsText(@Nullable String text) throws IllegalArgumentException {\n\t\tProperties props = new Properties();\n\t\tif (text != null) {\n\t\t\ttry {\n\t\t\t\t// Must use the ISO-8859-1 encoding because Properties.load(stream) expects it.\n\t\t\t\tprops.load(new ByteArrayInputStream(text.getBytes(StandardCharsets.ISO_8859_1)));\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\t// Should never happen.\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Failed to parse [\" + text + \"] into Properties\", ex);\n\t\t\t}\n\t\t}\n\t\tsetValue(props);\n\t}\n\n\t/**\n\t * Take {@link Properties} as-is; convert {@link Map} into {@code Properties}.\n\t */\n\t@Override\n\tpublic void setValue(Object value) {\n\t\tif (!(value instanceof Properties) && value instanceof Map<?, ?> map) {\n\t\t\tProperties props = new Properties();\n\t\t\tprops.putAll(map);\n\t\t\tsuper.setValue(props);\n\t\t}\n\t\telse {\n\t\t\tsuper.setValue(value);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.beans.propertyeditors.PropertiesEditor#setAsText(text)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert {@link String} into {@link Properties}, considering it as\n\t * properties content.\n\t * @param text the text to be so converted\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "return": "void",
    "signature": "public void setAsText(@Nullable String text)",
    "source_code": "\tpublic void setAsText(@Nullable String text) throws IllegalArgumentException {\n\t\tProperties props = new Properties();\n\t\tif (text != null) {\n\t\t\ttry {\n\t\t\t\t// Must use the ISO-8859-1 encoding because Properties.load(stream) expects it.\n\t\t\t\tprops.load(new ByteArrayInputStream(text.getBytes(StandardCharsets.ISO_8859_1)));\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\t// Should never happen.\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Failed to parse [\" + text + \"] into Properties\", ex);\n\t\t\t}\n\t\t}\n\t\tsetValue(props);\n\t}"
  },
  "org.springframework.beans.propertyeditors.PropertiesEditor#setValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Take {@link Properties} as-is; convert {@link Map} into {@code Properties}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "public void setValue(Object value)",
    "source_code": "\tpublic void setValue(Object value) {\n\t\tif (!(value instanceof Properties) && value instanceof Map<?, ?> map) {\n\t\t\tProperties props = new Properties();\n\t\t\tprops.putAll(map);\n\t\t\tsuper.setValue(props);\n\t\t}\n\t\telse {\n\t\t\tsuper.setValue(value);\n\t\t}\n\t}"
  },
  "org.springframework.beans.support.ArgumentConvertingMethodInvoker": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Subclass of {@link MethodInvoker} that tries to convert the given\n * arguments for the actual target method via a {@link TypeConverter}.\n *\n * <p>Supports flexible argument conversions, in particular for\n * invoking a specific overloaded method.\n *\n * @author Juergen Hoeller\n * @since 1.1\n * @see org.springframework.beans.BeanWrapperImpl#convertIfNecessary\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class ArgumentConvertingMethodInvoker",
    "source_code": "public class ArgumentConvertingMethodInvoker extends MethodInvoker {\n\n\t@Nullable\n\tprivate TypeConverter typeConverter;\n\n\tprivate boolean useDefaultConverter = true;\n\n\n\t/**\n\t * Set a TypeConverter to use for argument type conversion.\n\t * <p>Default is a {@link org.springframework.beans.SimpleTypeConverter}.\n\t * Can be overridden with any TypeConverter implementation, typically\n\t * a pre-configured SimpleTypeConverter or a BeanWrapperImpl instance.\n\t * @see org.springframework.beans.SimpleTypeConverter\n\t * @see org.springframework.beans.BeanWrapperImpl\n\t */\n\tpublic void setTypeConverter(@Nullable TypeConverter typeConverter) {\n\t\tthis.typeConverter = typeConverter;\n\t\tthis.useDefaultConverter = (typeConverter == null);\n\t}\n\n\t/**\n\t * Return the TypeConverter used for argument type conversion.\n\t * <p>Can be cast to {@link org.springframework.beans.PropertyEditorRegistry}\n\t * if direct access to the underlying PropertyEditors is desired\n\t * (provided that the present TypeConverter actually implements the\n\t * PropertyEditorRegistry interface).\n\t */\n\t@Nullable\n\tpublic TypeConverter getTypeConverter() {\n\t\tif (this.typeConverter == null && this.useDefaultConverter) {\n\t\t\tthis.typeConverter = getDefaultTypeConverter();\n\t\t}\n\t\treturn this.typeConverter;\n\t}\n\n\t/**\n\t * Obtain the default TypeConverter for this method invoker.\n\t * <p>Called if no explicit TypeConverter has been specified.\n\t * The default implementation builds a\n\t * {@link org.springframework.beans.SimpleTypeConverter}.\n\t * Can be overridden in subclasses.\n\t */\n\tprotected TypeConverter getDefaultTypeConverter() {\n\t\treturn new SimpleTypeConverter();\n\t}\n\n\t/**\n\t * Register the given custom property editor for all properties of the given type.\n\t * <p>Typically used in conjunction with the default\n\t * {@link org.springframework.beans.SimpleTypeConverter}; will work with any\n\t * TypeConverter that implements the PropertyEditorRegistry interface as well.\n\t * @param requiredType type of the property\n\t * @param propertyEditor editor to register\n\t * @see #setTypeConverter\n\t * @see org.springframework.beans.PropertyEditorRegistry#registerCustomEditor\n\t */\n\tpublic void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor) {\n\t\tTypeConverter converter = getTypeConverter();\n\t\tif (!(converter instanceof PropertyEditorRegistry registry)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"TypeConverter does not implement PropertyEditorRegistry interface: \" + converter);\n\t\t}\n\t\tregistry.registerCustomEditor(requiredType, propertyEditor);\n\t}\n\n\n\t/**\n\t * This implementation looks for a method with matching parameter types.\n\t * @see #doFindMatchingMethod\n\t */\n\t@Override\n\tprotected Method findMatchingMethod() {\n\t\tMethod matchingMethod = super.findMatchingMethod();\n\t\t// Second pass: look for method where arguments can be converted to parameter types.\n\t\tif (matchingMethod == null) {\n\t\t\t// Interpret argument array as individual method arguments.\n\t\t\tmatchingMethod = doFindMatchingMethod(getArguments());\n\t\t}\n\t\tif (matchingMethod == null) {\n\t\t\t// Interpret argument array as single method argument of array type.\n\t\t\tmatchingMethod = doFindMatchingMethod(new Object[] {getArguments()});\n\t\t}\n\t\treturn matchingMethod;\n\t}\n\n\t/**\n\t * Actually find a method with matching parameter type, i.e. where each\n\t * argument value is assignable to the corresponding parameter type.\n\t * @param arguments the argument values to match against method parameters\n\t * @return a matching method, or {@code null} if none\n\t */\n\t@Nullable\n\tprotected Method doFindMatchingMethod(Object[] arguments) {\n\t\tTypeConverter converter = getTypeConverter();\n\t\tif (converter != null) {\n\t\t\tString targetMethod = getTargetMethod();\n\t\t\tMethod matchingMethod = null;\n\t\t\tint argCount = arguments.length;\n\t\t\tClass<?> targetClass = getTargetClass();\n\t\t\tAssert.state(targetClass != null, \"No target class set\");\n\t\t\tMethod[] candidates = ReflectionUtils.getAllDeclaredMethods(targetClass);\n\t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n\t\t\tObject[] argumentsToUse = null;\n\t\t\tfor (Method candidate : candidates) {\n\t\t\t\tif (candidate.getName().equals(targetMethod)) {\n\t\t\t\t\t// Check if the inspected method has the correct number of parameters.\n\t\t\t\t\tint parameterCount = candidate.getParameterCount();\n\t\t\t\t\tif (parameterCount == argCount) {\n\t\t\t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n\t\t\t\t\t\tObject[] convertedArguments = new Object[argCount];\n\t\t\t\t\t\tboolean match = true;\n\t\t\t\t\t\tfor (int j = 0; j < argCount && match; j++) {\n\t\t\t\t\t\t\t// Verify that the supplied argument is assignable to the method parameter.\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tconvertedArguments[j] = converter.convertIfNecessary(arguments[j], paramTypes[j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\t\t\t\t\t// Ignore -> simply doesn't match.\n\t\t\t\t\t\t\t\tmatch = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tint typeDiffWeight = getTypeDifferenceWeight(paramTypes, convertedArguments);\n\t\t\t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n\t\t\t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n\t\t\t\t\t\t\t\tmatchingMethod = candidate;\n\t\t\t\t\t\t\t\targumentsToUse = convertedArguments;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (matchingMethod != null) {\n\t\t\t\tsetArguments(argumentsToUse);\n\t\t\t\treturn matchingMethod;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n}"
  },
  "org.springframework.beans.support.ArgumentConvertingMethodInvoker#doFindMatchingMethod(arguments)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually find a method with matching parameter type, i.e. where each\n\t * argument value is assignable to the corresponding parameter type.\n\t * @param arguments the argument values to match against method parameters\n\t * @return a matching method, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "Method",
    "signature": "protected Method doFindMatchingMethod(Object[] arguments)",
    "source_code": "\tprotected Method doFindMatchingMethod(Object[] arguments) {\n\t\tTypeConverter converter = getTypeConverter();\n\t\tif (converter != null) {\n\t\t\tString targetMethod = getTargetMethod();\n\t\t\tMethod matchingMethod = null;\n\t\t\tint argCount = arguments.length;\n\t\t\tClass<?> targetClass = getTargetClass();\n\t\t\tAssert.state(targetClass != null, \"No target class set\");\n\t\t\tMethod[] candidates = ReflectionUtils.getAllDeclaredMethods(targetClass);\n\t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n\t\t\tObject[] argumentsToUse = null;\n\t\t\tfor (Method candidate : candidates) {\n\t\t\t\tif (candidate.getName().equals(targetMethod)) {\n\t\t\t\t\t// Check if the inspected method has the correct number of parameters.\n\t\t\t\t\tint parameterCount = candidate.getParameterCount();\n\t\t\t\t\tif (parameterCount == argCount) {\n\t\t\t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n\t\t\t\t\t\tObject[] convertedArguments = new Object[argCount];\n\t\t\t\t\t\tboolean match = true;\n\t\t\t\t\t\tfor (int j = 0; j < argCount && match; j++) {\n\t\t\t\t\t\t\t// Verify that the supplied argument is assignable to the method parameter.\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tconvertedArguments[j] = converter.convertIfNecessary(arguments[j], paramTypes[j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\t\t\t\t\t// Ignore -> simply doesn't match.\n\t\t\t\t\t\t\t\tmatch = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tint typeDiffWeight = getTypeDifferenceWeight(paramTypes, convertedArguments);\n\t\t\t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n\t\t\t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n\t\t\t\t\t\t\t\tmatchingMethod = candidate;\n\t\t\t\t\t\t\t\targumentsToUse = convertedArguments;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (matchingMethod != null) {\n\t\t\t\tsetArguments(argumentsToUse);\n\t\t\t\treturn matchingMethod;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.support.ArgumentConvertingMethodInvoker#findMatchingMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation looks for a method with matching parameter types.\n\t * @see #doFindMatchingMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "Method",
    "signature": "protected Method findMatchingMethod()",
    "source_code": "\tprotected Method findMatchingMethod() {\n\t\tMethod matchingMethod = super.findMatchingMethod();\n\t\t// Second pass: look for method where arguments can be converted to parameter types.\n\t\tif (matchingMethod == null) {\n\t\t\t// Interpret argument array as individual method arguments.\n\t\t\tmatchingMethod = doFindMatchingMethod(getArguments());\n\t\t}\n\t\tif (matchingMethod == null) {\n\t\t\t// Interpret argument array as single method argument of array type.\n\t\t\tmatchingMethod = doFindMatchingMethod(new Object[] {getArguments()});\n\t\t}\n\t\treturn matchingMethod;\n\t}"
  },
  "org.springframework.beans.support.ArgumentConvertingMethodInvoker#getDefaultTypeConverter()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the default TypeConverter for this method invoker.\n\t * <p>Called if no explicit TypeConverter has been specified.\n\t * The default implementation builds a\n\t * {@link org.springframework.beans.SimpleTypeConverter}.\n\t * Can be overridden in subclasses.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "TypeConverter",
    "signature": "protected TypeConverter getDefaultTypeConverter()",
    "source_code": "\tprotected TypeConverter getDefaultTypeConverter() {\n\t\treturn new SimpleTypeConverter();\n\t}"
  },
  "org.springframework.beans.support.ArgumentConvertingMethodInvoker#getTypeConverter()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the TypeConverter used for argument type conversion.\n\t * <p>Can be cast to {@link org.springframework.beans.PropertyEditorRegistry}\n\t * if direct access to the underlying PropertyEditors is desired\n\t * (provided that the present TypeConverter actually implements the\n\t * PropertyEditorRegistry interface).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "TypeConverter",
    "signature": "public TypeConverter getTypeConverter()",
    "source_code": "\tpublic TypeConverter getTypeConverter() {\n\t\tif (this.typeConverter == null && this.useDefaultConverter) {\n\t\t\tthis.typeConverter = getDefaultTypeConverter();\n\t\t}\n\t\treturn this.typeConverter;\n\t}"
  },
  "org.springframework.beans.support.ArgumentConvertingMethodInvoker#registerCustomEditor(requiredType,propertyEditor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given custom property editor for all properties of the given type.\n\t * <p>Typically used in conjunction with the default\n\t * {@link org.springframework.beans.SimpleTypeConverter}; will work with any\n\t * TypeConverter that implements the PropertyEditorRegistry interface as well.\n\t * @param requiredType type of the property\n\t * @param propertyEditor editor to register\n\t * @see #setTypeConverter\n\t * @see org.springframework.beans.PropertyEditorRegistry#registerCustomEditor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "propertyEditor"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor)",
    "source_code": "\tpublic void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor) {\n\t\tTypeConverter converter = getTypeConverter();\n\t\tif (!(converter instanceof PropertyEditorRegistry registry)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"TypeConverter does not implement PropertyEditorRegistry interface: \" + converter);\n\t\t}\n\t\tregistry.registerCustomEditor(requiredType, propertyEditor);\n\t}"
  },
  "org.springframework.beans.support.ArgumentConvertingMethodInvoker#setTypeConverter(typeConverter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a TypeConverter to use for argument type conversion.\n\t * <p>Default is a {@link org.springframework.beans.SimpleTypeConverter}.\n\t * Can be overridden with any TypeConverter implementation, typically\n\t * a pre-configured SimpleTypeConverter or a BeanWrapperImpl instance.\n\t * @see org.springframework.beans.SimpleTypeConverter\n\t * @see org.springframework.beans.BeanWrapperImpl\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "void",
    "signature": "public void setTypeConverter(@Nullable TypeConverter typeConverter)",
    "source_code": "\tpublic void setTypeConverter(@Nullable TypeConverter typeConverter) {\n\t\tthis.typeConverter = typeConverter;\n\t\tthis.useDefaultConverter = (typeConverter == null);\n\t}"
  },
  "org.springframework.beans.support.PropertyComparator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * PropertyComparator performs a comparison of two beans,\n * evaluating the specified bean property via a BeanWrapper.\n *\n * @author Juergen Hoeller\n * @author Jean-Pierre Pawlak\n * @since 19.05.2003\n * @param <T> the type of objects that may be compared by this comparator\n * @see org.springframework.beans.BeanWrapper\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "signature": "public class PropertyComparator",
    "source_code": "public class PropertyComparator<T> implements Comparator<T> {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate final SortDefinition sortDefinition;\n\n\n\t/**\n\t * Create a new PropertyComparator for the given SortDefinition.\n\t * @see MutableSortDefinition\n\t */\n\tpublic PropertyComparator(SortDefinition sortDefinition) {\n\t\tthis.sortDefinition = sortDefinition;\n\t}\n\n\t/**\n\t * Create a PropertyComparator for the given settings.\n\t * @param property the property to compare\n\t * @param ignoreCase whether upper and lower case in String values should be ignored\n\t * @param ascending whether to sort ascending (true) or descending (false)\n\t */\n\tpublic PropertyComparator(String property, boolean ignoreCase, boolean ascending) {\n\t\tthis.sortDefinition = new MutableSortDefinition(property, ignoreCase, ascending);\n\t}\n\n\t/**\n\t * Return the SortDefinition that this comparator uses.\n\t */\n\tpublic final SortDefinition getSortDefinition() {\n\t\treturn this.sortDefinition;\n\t}\n\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic int compare(T o1, T o2) {\n\t\tObject v1 = getPropertyValue(o1);\n\t\tObject v2 = getPropertyValue(o2);\n\t\tif (this.sortDefinition.isIgnoreCase() && (v1 instanceof String text1) && (v2 instanceof String text2)) {\n\t\t\tv1 = text1.toLowerCase();\n\t\t\tv2 = text2.toLowerCase();\n\t\t}\n\n\t\tint result;\n\n\t\t// Put an object with null property at the end of the sort result.\n\t\ttry {\n\t\t\tif (v1 != null) {\n\t\t\t\tresult = (v2 != null ? ((Comparable<Object>) v1).compareTo(v2) : -1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = (v2 != null ? 1 : 0);\n\t\t\t}\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Could not sort objects [\" + o1 + \"] and [\" + o2 + \"]\", ex);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn (this.sortDefinition.isAscending() ? result : -result);\n\t}\n\n\t/**\n\t * Get the SortDefinition's property value for the given object.\n\t * @param obj the object to get the property value for\n\t * @return the property value\n\t */\n\t@Nullable\n\tprivate Object getPropertyValue(Object obj) {\n\t\t// If a nested property cannot be read, simply return null\n\t\t// (similar to JSTL EL). If the property doesn't exist in the\n\t\t// first place, let the exception through.\n\t\ttry {\n\t\t\tBeanWrapperImpl beanWrapper = new BeanWrapperImpl(false);\n\t\t\tbeanWrapper.setWrappedInstance(obj);\n\t\t\treturn beanWrapper.getPropertyValue(this.sortDefinition.getProperty());\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tlogger.debug(\"PropertyComparator could not access property - treating as null for sorting\", ex);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * Sort the given List according to the given sort definition.\n\t * <p>Note: Contained objects have to provide the given property\n\t * in the form of a bean property, i.e. a getXXX method.\n\t * @param source the input List\n\t * @param sortDefinition the parameters to sort by\n\t * @throws java.lang.IllegalArgumentException in case of a missing propertyName\n\t */\n\tpublic static void sort(List<?> source, SortDefinition sortDefinition) throws BeansException {\n\t\tif (StringUtils.hasText(sortDefinition.getProperty())) {\n\t\t\tsource.sort(new PropertyComparator<>(sortDefinition));\n\t\t}\n\t}\n\n\t/**\n\t * Sort the given source according to the given sort definition.\n\t * <p>Note: Contained objects have to provide the given property\n\t * in the form of a bean property, i.e. a getXXX method.\n\t * @param source input source\n\t * @param sortDefinition the parameters to sort by\n\t * @throws java.lang.IllegalArgumentException in case of a missing propertyName\n\t */\n\tpublic static void sort(Object[] source, SortDefinition sortDefinition) throws BeansException {\n\t\tif (StringUtils.hasText(sortDefinition.getProperty())) {\n\t\t\tArrays.sort(source, new PropertyComparator<>(sortDefinition));\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.beans.support.PropertyComparator#compare(o1,o2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o1",
      "o2"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "int",
    "signature": "public int compare(T o1, T o2)",
    "source_code": "\tpublic int compare(T o1, T o2) {\n\t\tObject v1 = getPropertyValue(o1);\n\t\tObject v2 = getPropertyValue(o2);\n\t\tif (this.sortDefinition.isIgnoreCase() && (v1 instanceof String text1) && (v2 instanceof String text2)) {\n\t\t\tv1 = text1.toLowerCase();\n\t\t\tv2 = text2.toLowerCase();\n\t\t}\n\n\t\tint result;\n\n\t\t// Put an object with null property at the end of the sort result.\n\t\ttry {\n\t\t\tif (v1 != null) {\n\t\t\t\tresult = (v2 != null ? ((Comparable<Object>) v1).compareTo(v2) : -1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = (v2 != null ? 1 : 0);\n\t\t\t}\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Could not sort objects [\" + o1 + \"] and [\" + o2 + \"]\", ex);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn (this.sortDefinition.isAscending() ? result : -result);\n\t}"
  },
  "org.springframework.beans.support.PropertyComparator#getSortDefinition()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the SortDefinition that this comparator uses.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "SortDefinition",
    "signature": "public SortDefinition getSortDefinition()",
    "source_code": "\tpublic final SortDefinition getSortDefinition() {\n\t\treturn this.sortDefinition;\n\t}"
  },
  "org.springframework.beans.support.PropertyComparator#sort(source,sortDefinition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Sort the given source according to the given sort definition.\n\t * <p>Note: Contained objects have to provide the given property\n\t * in the form of a bean property, i.e. a getXXX method.\n\t * @param source input source\n\t * @param sortDefinition the parameters to sort by\n\t * @throws java.lang.IllegalArgumentException in case of a missing propertyName\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "sortDefinition"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void sort(Object[] source, SortDefinition sortDefinition)",
    "source_code": "\tpublic static void sort(Object[] source, SortDefinition sortDefinition) throws BeansException {\n\t\tif (StringUtils.hasText(sortDefinition.getProperty())) {\n\t\t\tArrays.sort(source, new PropertyComparator<>(sortDefinition));\n\t\t}\n\t}"
  },
  "org.springframework.beans.support.ResourceEditorRegistrar": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * PropertyEditorRegistrar implementation that populates a given\n * {@link org.springframework.beans.PropertyEditorRegistry}\n * (typically a {@link org.springframework.beans.BeanWrapper} used for bean\n * creation within an {@link org.springframework.context.ApplicationContext})\n * with resource editors. Used by\n * {@link org.springframework.context.support.AbstractApplicationContext}.\n *\n * @author Juergen Hoeller\n * @author Chris Beams\n * @since 2.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "signature": "public class ResourceEditorRegistrar",
    "source_code": "public class ResourceEditorRegistrar implements PropertyEditorRegistrar {\n\n\tprivate final PropertyResolver propertyResolver;\n\n\tprivate final ResourceLoader resourceLoader;\n\n\n\t/**\n\t * Create a new ResourceEditorRegistrar for the given {@link ResourceLoader}\n\t * and {@link PropertyResolver}.\n\t * @param resourceLoader the ResourceLoader (or ResourcePatternResolver)\n\t * to create editors for (usually an ApplicationContext)\n\t * @param propertyResolver the PropertyResolver (usually an Environment)\n\t * @see org.springframework.core.env.Environment\n\t * @see org.springframework.core.io.support.ResourcePatternResolver\n\t * @see org.springframework.context.ApplicationContext\n\t */\n\tpublic ResourceEditorRegistrar(ResourceLoader resourceLoader, PropertyResolver propertyResolver) {\n\t\tthis.resourceLoader = resourceLoader;\n\t\tthis.propertyResolver = propertyResolver;\n\t}\n\n\n\t/**\n\t * Populate the given {@code registry} with the following resource editors:\n\t * ResourceEditor, InputStreamEditor, InputSourceEditor, FileEditor, URLEditor,\n\t * URIEditor, ClassEditor, ClassArrayEditor.\n\t * <p>If this registrar has been configured with a {@link ResourcePatternResolver},\n\t * a ResourceArrayPropertyEditor will be registered as well.\n\t * @see org.springframework.core.io.ResourceEditor\n\t * @see org.springframework.beans.propertyeditors.InputStreamEditor\n\t * @see org.springframework.beans.propertyeditors.InputSourceEditor\n\t * @see org.springframework.beans.propertyeditors.FileEditor\n\t * @see org.springframework.beans.propertyeditors.URLEditor\n\t * @see org.springframework.beans.propertyeditors.URIEditor\n\t * @see org.springframework.beans.propertyeditors.ClassEditor\n\t * @see org.springframework.beans.propertyeditors.ClassArrayEditor\n\t * @see org.springframework.core.io.support.ResourceArrayPropertyEditor\n\t */\n\t@Override\n\tpublic void registerCustomEditors(PropertyEditorRegistry registry) {\n\t\tResourceEditor baseEditor = new ResourceEditor(this.resourceLoader, this.propertyResolver);\n\t\tdoRegisterEditor(registry, Resource.class, baseEditor);\n\t\tdoRegisterEditor(registry, ContextResource.class, baseEditor);\n\t\tdoRegisterEditor(registry, WritableResource.class, baseEditor);\n\t\tdoRegisterEditor(registry, InputStream.class, new InputStreamEditor(baseEditor));\n\t\tdoRegisterEditor(registry, InputSource.class, new InputSourceEditor(baseEditor));\n\t\tdoRegisterEditor(registry, File.class, new FileEditor(baseEditor));\n\t\tdoRegisterEditor(registry, Path.class, new PathEditor(baseEditor));\n\t\tdoRegisterEditor(registry, Reader.class, new ReaderEditor(baseEditor));\n\t\tdoRegisterEditor(registry, URL.class, new URLEditor(baseEditor));\n\n\t\tClassLoader classLoader = this.resourceLoader.getClassLoader();\n\t\tdoRegisterEditor(registry, URI.class, new URIEditor(classLoader));\n\t\tdoRegisterEditor(registry, Class.class, new ClassEditor(classLoader));\n\t\tdoRegisterEditor(registry, Class[].class, new ClassArrayEditor(classLoader));\n\n\t\tif (this.resourceLoader instanceof ResourcePatternResolver resourcePatternResolver) {\n\t\t\tdoRegisterEditor(registry, Resource[].class,\n\t\t\t\t\tnew ResourceArrayPropertyEditor(resourcePatternResolver, this.propertyResolver));\n\t\t}\n\t}\n\n\t/**\n\t * Override default editor, if possible (since that's what we really mean to do here);\n\t * otherwise register as a custom editor.\n\t */\n\tprivate void doRegisterEditor(PropertyEditorRegistry registry, Class<?> requiredType, PropertyEditor editor) {\n\t\tif (registry instanceof PropertyEditorRegistrySupport registrySupport) {\n\t\t\tregistrySupport.overrideDefaultEditor(requiredType, editor);\n\t\t}\n\t\telse {\n\t\t\tregistry.registerCustomEditor(requiredType, editor);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.beans.support.ResourceEditorRegistrar#registerCustomEditors(registry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Populate the given {@code registry} with the following resource editors:\n\t * ResourceEditor, InputStreamEditor, InputSourceEditor, FileEditor, URLEditor,\n\t * URIEditor, ClassEditor, ClassArrayEditor.\n\t * <p>If this registrar has been configured with a {@link ResourcePatternResolver},\n\t * a ResourceArrayPropertyEditor will be registered as well.\n\t * @see org.springframework.core.io.ResourceEditor\n\t * @see org.springframework.beans.propertyeditors.InputStreamEditor\n\t * @see org.springframework.beans.propertyeditors.InputSourceEditor\n\t * @see org.springframework.beans.propertyeditors.FileEditor\n\t * @see org.springframework.beans.propertyeditors.URLEditor\n\t * @see org.springframework.beans.propertyeditors.URIEditor\n\t * @see org.springframework.beans.propertyeditors.ClassEditor\n\t * @see org.springframework.beans.propertyeditors.ClassArrayEditor\n\t * @see org.springframework.core.io.support.ResourceArrayPropertyEditor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void registerCustomEditors(PropertyEditorRegistry registry)",
    "source_code": "\tpublic void registerCustomEditors(PropertyEditorRegistry registry) {\n\t\tResourceEditor baseEditor = new ResourceEditor(this.resourceLoader, this.propertyResolver);\n\t\tdoRegisterEditor(registry, Resource.class, baseEditor);\n\t\tdoRegisterEditor(registry, ContextResource.class, baseEditor);\n\t\tdoRegisterEditor(registry, WritableResource.class, baseEditor);\n\t\tdoRegisterEditor(registry, InputStream.class, new InputStreamEditor(baseEditor));\n\t\tdoRegisterEditor(registry, InputSource.class, new InputSourceEditor(baseEditor));\n\t\tdoRegisterEditor(registry, File.class, new FileEditor(baseEditor));\n\t\tdoRegisterEditor(registry, Path.class, new PathEditor(baseEditor));\n\t\tdoRegisterEditor(registry, Reader.class, new ReaderEditor(baseEditor));\n\t\tdoRegisterEditor(registry, URL.class, new URLEditor(baseEditor));\n\n\t\tClassLoader classLoader = this.resourceLoader.getClassLoader();\n\t\tdoRegisterEditor(registry, URI.class, new URIEditor(classLoader));\n\t\tdoRegisterEditor(registry, Class.class, new ClassEditor(classLoader));\n\t\tdoRegisterEditor(registry, Class[].class, new ClassArrayEditor(classLoader));\n\n\t\tif (this.resourceLoader instanceof ResourcePatternResolver resourcePatternResolver) {\n\t\t\tdoRegisterEditor(registry, Resource[].class,\n\t\t\t\t\tnew ResourceArrayPropertyEditor(resourcePatternResolver, this.propertyResolver));\n\t\t}\n\t}"
  },
  "org.springframework.beans.support.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.cache.interceptor.EMPTY": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An empty key.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public SimpleKey EMPTY",
    "source_code": "\tpublic static final SimpleKey EMPTY = new SimpleKey();",
    "type": "SimpleKey"
  },
  "org.springframework.cache.interceptor.SimpleKey": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A simple key as returned from the {@link SimpleKeyGenerator}.\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n * @since 4.0\n * @see SimpleKeyGenerator\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class SimpleKey",
    "source_code": "public class SimpleKey implements Serializable {\n\n\t/**\n\t * An empty key.\n\t */\n\tpublic static final SimpleKey EMPTY = new SimpleKey();\n\n\n\tprivate final Object[] params;\n\n\t// Effectively final, just re-calculated on deserialization\n\tprivate transient int hashCode;\n\n\n\t/**\n\t * Create a new {@link SimpleKey} instance.\n\t * @param elements the elements of the key\n\t */\n\tpublic SimpleKey(Object... elements) {\n\t\tAssert.notNull(elements, \"Elements must not be null\");\n\t\tthis.params = elements.clone();\n\t\t// Pre-calculate hashCode field\n\t\tthis.hashCode = Arrays.deepHashCode(this.params);\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj ||\n\t\t\t\t(obj instanceof SimpleKey that && Arrays.deepEquals(this.params, that.params)));\n\t}\n\n\t@Override\n\tpublic final int hashCode() {\n\t\t// Expose pre-calculated hashCode field\n\t\treturn this.hashCode;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" [\" + StringUtils.arrayToCommaDelimitedString(this.params) + \"]\";\n\t}\n\n\tprivate void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n\t\tois.defaultReadObject();\n\t\t// Re-calculate hashCode field on deserialization\n\t\tthis.hashCode = Arrays.deepHashCode(this.params);\n\t}\n\n}"
  },
  "org.springframework.cache.interceptor.SimpleKey#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj ||\n\t\t\t\t(obj instanceof SimpleKey that && Arrays.deepEquals(this.params, that.params)));\n\t}"
  },
  "org.springframework.cache.interceptor.SimpleKey#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic final int hashCode() {\n\t\t// Expose pre-calculated hashCode field\n\t\treturn this.hashCode;\n\t}"
  },
  "org.springframework.cache.interceptor.SimpleKey#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" [\" + StringUtils.arrayToCommaDelimitedString(this.params) + \"]\";\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 1005
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object obj) {\n\t\t\treturn (this == obj || (obj instanceof SourceClass that &&\n\t\t\t\t\tthis.metadata.getClassName().equals(that.metadata.getClassName())));\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 1005
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof SourceClass &&\n\t\t\t\t\tthis.metadata.getClassName().equals(((SourceClass) other).metadata.getClassName())));\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#getBeanFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "ConfigurableListableBeanFactory",
    "signature": "public ConfigurableListableBeanFactory getBeanFactory()",
    "source_code": "\t\tpublic ConfigurableListableBeanFactory getBeanFactory() {\n\t\t\treturn this.beanFactory;\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#getBeanName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "String",
    "signature": "public String getBeanName()",
    "source_code": "\tpublic String getBeanName() {\n\t\treturn this.beanName;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#getClassLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "ClassLoader",
    "signature": "public ClassLoader getClassLoader()",
    "source_code": "\t\tpublic ClassLoader getClassLoader() {\n\t\t\treturn this.classLoader;\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#getEnvironment()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "Environment",
    "signature": "public Environment getEnvironment()",
    "source_code": "\t\tpublic Environment getEnvironment() {\n\t\t\treturn this.environment;\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#getRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "BeanDefinitionRegistry",
    "signature": "public BeanDefinitionRegistry getRegistry()",
    "source_code": "\t\tpublic BeanDefinitionRegistry getRegistry() {\n\t\t\tAssert.state(this.registry != null, \"No BeanDefinitionRegistry available\");\n\t\t\treturn this.registry;\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#getResourceLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "ResourceLoader",
    "signature": "public ResourceLoader getResourceLoader()",
    "source_code": "\t\tpublic ResourceLoader getResourceLoader() {\n\t\t\treturn this.resourceLoader;\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#isImported()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this configuration class was registered via @{@link Import} or\n\t * automatically registered due to being nested within another configuration class.\n\t * @since 3.1.1\n\t * @see #getImportedBy()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "boolean",
    "signature": "public boolean isImported()",
    "source_code": "\tpublic boolean isImported() {\n\t\treturn !this.importedBy.isEmpty();\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#shouldSkip(metadata)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if an item should be skipped based on {@code @Conditional} annotations.\n\t * The {@link ConfigurationPhase} will be deduced from the type of item (i.e. a\n\t * {@code @Configuration} class will be {@link ConfigurationPhase#PARSE_CONFIGURATION})\n\t * @param metadata the meta data\n\t * @return if the item should be skipped\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadata"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "boolean",
    "signature": "public boolean shouldSkip(AnnotatedTypeMetadata metadata)",
    "source_code": "\tpublic boolean shouldSkip(AnnotatedTypeMetadata metadata) {\n\t\treturn shouldSkip(metadata, null);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#shouldSkip(metadata,phase)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if an item should be skipped based on {@code @Conditional} annotations.\n\t * @param metadata the meta data\n\t * @param phase the phase of the call\n\t * @return if the item should be skipped\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadata",
      "phase"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "boolean",
    "signature": "public boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase)",
    "source_code": "\tpublic boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase) {\n\t\tif (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (phase == null) {\n\t\t\tif (metadata instanceof AnnotationMetadata annotationMetadata &&\n\t\t\t\t\tConfigurationClassUtils.isConfigurationCandidate(annotationMetadata)) {\n\t\t\t\treturn shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);\n\t\t\t}\n\t\t\treturn shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);\n\t\t}\n\n\t\tList<Condition> conditions = new ArrayList<>();\n\t\tfor (String[] conditionClasses : getConditionClasses(metadata)) {\n\t\t\tfor (String conditionClass : conditionClasses) {\n\t\t\t\tCondition condition = getCondition(conditionClass, this.context.getClassLoader());\n\t\t\t\tconditions.add(condition);\n\t\t\t}\n\t\t}\n\n\t\tAnnotationAwareOrderComparator.sort(conditions);\n\n\t\tfor (Condition condition : conditions) {\n\t\t\tConfigurationPhase requiredPhase = null;\n\t\t\tif (condition instanceof ConfigurationCondition configurationCondition) {\n\t\t\t\trequiredPhase = configurationCondition.getConfigurationPhase();\n\t\t\t}\n\t\t\tif ((requiredPhase == null || requiredPhase == phase) && !condition.matches(this.context, metadata)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#validate(problemReporter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "problemReporter"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "void",
    "signature": "public void validate(ProblemReporter problemReporter)",
    "source_code": "\tpublic void validate(ProblemReporter problemReporter) {\n\t\tif (getMetadata().isStatic()) {\n\t\t\t// static @Bean methods have no constraints to validate -> return immediately\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.configurationClass.getMetadata().isAnnotated(Configuration.class.getName())) {\n\t\t\tif (!getMetadata().isOverridable()) {\n\t\t\t\t// instance @Bean methods within @Configuration classes must be overridable to accommodate CGLIB\n\t\t\t\tproblemReporter.error(new NonOverridableMethodError());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.AnnotatedBeanDefinitionReader": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Convenient adapter for programmatic registration of bean classes.\n *\n * <p>This is an alternative to {@link ClassPathBeanDefinitionScanner}, applying\n * the same resolution of annotations but for explicitly registered classes only.\n *\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Sam Brannen\n * @author Phillip Webb\n * @since 3.0\n * @see AnnotationConfigApplicationContext#register\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class AnnotatedBeanDefinitionReader",
    "source_code": "public class AnnotatedBeanDefinitionReader {\n\n\tprivate final BeanDefinitionRegistry registry;\n\n\tprivate BeanNameGenerator beanNameGenerator = AnnotationBeanNameGenerator.INSTANCE;\n\n\tprivate ScopeMetadataResolver scopeMetadataResolver = new AnnotationScopeMetadataResolver();\n\n\tprivate ConditionEvaluator conditionEvaluator;\n\n\n\t/**\n\t * Create a new {@code AnnotatedBeanDefinitionReader} for the given registry.\n\t * <p>If the registry is {@link EnvironmentCapable}, e.g. is an {@code ApplicationContext},\n\t * the {@link Environment} will be inherited, otherwise a new\n\t * {@link StandardEnvironment} will be created and used.\n\t * @param registry the {@code BeanFactory} to load bean definitions into,\n\t * in the form of a {@code BeanDefinitionRegistry}\n\t * @see #AnnotatedBeanDefinitionReader(BeanDefinitionRegistry, Environment)\n\t * @see #setEnvironment(Environment)\n\t */\n\tpublic AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) {\n\t\tthis(registry, getOrCreateEnvironment(registry));\n\t}\n\n\t/**\n\t * Create a new {@code AnnotatedBeanDefinitionReader} for the given registry,\n\t * using the given {@link Environment}.\n\t * @param registry the {@code BeanFactory} to load bean definitions into,\n\t * in the form of a {@code BeanDefinitionRegistry}\n\t * @param environment the {@code Environment} to use when evaluating bean definition\n\t * profiles.\n\t * @since 3.1\n\t */\n\tpublic AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {\n\t\tAssert.notNull(registry, \"BeanDefinitionRegistry must not be null\");\n\t\tAssert.notNull(environment, \"Environment must not be null\");\n\t\tthis.registry = registry;\n\t\tthis.conditionEvaluator = new ConditionEvaluator(registry, environment, null);\n\t\tAnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);\n\t}\n\n\n\t/**\n\t * Get the BeanDefinitionRegistry that this reader operates on.\n\t */\n\tpublic final BeanDefinitionRegistry getRegistry() {\n\t\treturn this.registry;\n\t}\n\n\t/**\n\t * Set the {@code Environment} to use when evaluating whether\n\t * {@link Conditional @Conditional}-annotated component classes should be registered.\n\t * <p>The default is a {@link StandardEnvironment}.\n\t * @see #registerBean(Class, String, Class...)\n\t */\n\tpublic void setEnvironment(Environment environment) {\n\t\tthis.conditionEvaluator = new ConditionEvaluator(this.registry, environment, null);\n\t}\n\n\t/**\n\t * Set the {@code BeanNameGenerator} to use for detected bean classes.\n\t * <p>The default is a {@link AnnotationBeanNameGenerator}.\n\t */\n\tpublic void setBeanNameGenerator(@Nullable BeanNameGenerator beanNameGenerator) {\n\t\tthis.beanNameGenerator =\n\t\t\t\t(beanNameGenerator != null ? beanNameGenerator : AnnotationBeanNameGenerator.INSTANCE);\n\t}\n\n\t/**\n\t * Set the {@code ScopeMetadataResolver} to use for registered component classes.\n\t * <p>The default is an {@link AnnotationScopeMetadataResolver}.\n\t */\n\tpublic void setScopeMetadataResolver(@Nullable ScopeMetadataResolver scopeMetadataResolver) {\n\t\tthis.scopeMetadataResolver =\n\t\t\t\t(scopeMetadataResolver != null ? scopeMetadataResolver : new AnnotationScopeMetadataResolver());\n\t}\n\n\n\t/**\n\t * Register one or more component classes to be processed.\n\t * <p>Calls to {@code register} are idempotent; adding the same\n\t * component class more than once has no additional effect.\n\t * @param componentClasses one or more component classes,\n\t * e.g. {@link Configuration @Configuration} classes\n\t */\n\tpublic void register(Class<?>... componentClasses) {\n\t\tfor (Class<?> componentClass : componentClasses) {\n\t\t\tregisterBean(componentClass);\n\t\t}\n\t}\n\n\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t */\n\tpublic void registerBean(Class<?> beanClass) {\n\t\tdoRegisterBean(beanClass, null, null, null, null);\n\t}\n\n\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @since 5.2\n\t */\n\tpublic void registerBean(Class<?> beanClass, @Nullable String name) {\n\t\tdoRegisterBean(beanClass, name, null, null, null);\n\t}\n\n\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param qualifiers specific qualifier annotations to consider,\n\t * in addition to qualifiers at the bean class level\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void registerBean(Class<?> beanClass, Class<? extends Annotation>... qualifiers) {\n\t\tdoRegisterBean(beanClass, null, qualifiers, null, null);\n\t}\n\n\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @param qualifiers specific qualifier annotations to consider,\n\t * in addition to qualifiers at the bean class level\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void registerBean(Class<?> beanClass, @Nullable String name,\n\t\t\tClass<? extends Annotation>... qualifiers) {\n\n\t\tdoRegisterBean(beanClass, name, qualifiers, null, null);\n\t}\n\n\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations, using the given supplier for obtaining a new\n\t * instance (possibly declared as a lambda expression or method reference).\n\t * @param beanClass the class of the bean\n\t * @param supplier a callback for creating an instance of the bean\n\t * (may be {@code null})\n\t * @since 5.0\n\t */\n\tpublic <T> void registerBean(Class<T> beanClass, @Nullable Supplier<T> supplier) {\n\t\tdoRegisterBean(beanClass, null, null, supplier, null);\n\t}\n\n\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations, using the given supplier for obtaining a new\n\t * instance (possibly declared as a lambda expression or method reference).\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @param supplier a callback for creating an instance of the bean\n\t * (may be {@code null})\n\t * @since 5.0\n\t */\n\tpublic <T> void registerBean(Class<T> beanClass, @Nullable String name, @Nullable Supplier<T> supplier) {\n\t\tdoRegisterBean(beanClass, name, null, supplier, null);\n\t}\n\n\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @param supplier a callback for creating an instance of the bean\n\t * (may be {@code null})\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.2\n\t */\n\tpublic <T> void registerBean(Class<T> beanClass, @Nullable String name, @Nullable Supplier<T> supplier,\n\t\t\tBeanDefinitionCustomizer... customizers) {\n\n\t\tdoRegisterBean(beanClass, name, null, supplier, customizers);\n\t}\n\n\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * @param qualifiers specific qualifier annotations to consider, if any,\n\t * in addition to qualifiers at the bean class level\n\t * @param supplier a callback for creating an instance of the bean\n\t * (may be {@code null})\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.0\n\t */\n\tprivate <T> void doRegisterBean(Class<T> beanClass, @Nullable String name,\n\t\t\t@Nullable Class<? extends Annotation>[] qualifiers, @Nullable Supplier<T> supplier,\n\t\t\t@Nullable BeanDefinitionCustomizer[] customizers) {\n\n\t\tAnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass);\n\t\tif (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {\n\t\t\treturn;\n\t\t}\n\n\t\tabd.setInstanceSupplier(supplier);\n\t\tScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);\n\t\tabd.setScope(scopeMetadata.getScopeName());\n\t\tString beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));\n\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(abd);\n\t\tif (qualifiers != null) {\n\t\t\tfor (Class<? extends Annotation> qualifier : qualifiers) {\n\t\t\t\tif (Primary.class == qualifier) {\n\t\t\t\t\tabd.setPrimary(true);\n\t\t\t\t}\n\t\t\t\telse if (Lazy.class == qualifier) {\n\t\t\t\t\tabd.setLazyInit(true);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tabd.addQualifier(new AutowireCandidateQualifier(qualifier));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (customizers != null) {\n\t\t\tfor (BeanDefinitionCustomizer customizer : customizers) {\n\t\t\t\tcustomizer.customize(abd);\n\t\t\t}\n\t\t}\n\n\t\tBeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);\n\t\tdefinitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);\n\t\tBeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);\n\t}\n\n\n\t/**\n\t * Get the Environment from the given registry if possible, otherwise return a new\n\t * StandardEnvironment.\n\t */\n\tprivate static Environment getOrCreateEnvironment(BeanDefinitionRegistry registry) {\n\t\tAssert.notNull(registry, \"BeanDefinitionRegistry must not be null\");\n\t\tif (registry instanceof EnvironmentCapable environmentCapable) {\n\t\t\treturn environmentCapable.getEnvironment();\n\t\t}\n\t\treturn new StandardEnvironment();\n\t}\n\n}"
  },
  "org.springframework.context.annotation.AnnotatedBeanDefinitionReader#getRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the BeanDefinitionRegistry that this reader operates on.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "BeanDefinitionRegistry",
    "signature": "public BeanDefinitionRegistry getRegistry()",
    "source_code": "\tpublic final BeanDefinitionRegistry getRegistry() {\n\t\treturn this.registry;\n\t}"
  },
  "org.springframework.context.annotation.AnnotatedBeanDefinitionReader#register(componentClasses)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register one or more component classes to be processed.\n\t * <p>Calls to {@code register} are idempotent; adding the same\n\t * component class more than once has no additional effect.\n\t * @param componentClasses one or more component classes,\n\t * e.g. {@link Configuration @Configuration} classes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "componentClasses"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void register(Class<?>... componentClasses)",
    "source_code": "\tpublic void register(Class<?>... componentClasses) {\n\t\tfor (Class<?> componentClass : componentClasses) {\n\t\t\tregisterBean(componentClass);\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.AnnotatedBeanDefinitionReader#registerBean(beanClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "void",
    "signature": "public void registerBean(Class<?> beanClass)",
    "source_code": "\tpublic void registerBean(Class<?> beanClass) {\n\t\tdoRegisterBean(beanClass, null, null, null, null);\n\t}"
  },
  "org.springframework.context.annotation.AnnotatedBeanDefinitionReader#registerBean(beanClass,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "public void registerBean(Class<?> beanClass, @Nullable String name)",
    "source_code": "\tpublic void registerBean(Class<?> beanClass, @Nullable String name) {\n\t\tdoRegisterBean(beanClass, name, null, null, null);\n\t}"
  },
  "org.springframework.context.annotation.AnnotatedBeanDefinitionReader#registerBean(beanClass,name,qualifiers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @param qualifiers specific qualifier annotations to consider,\n\t * in addition to qualifiers at the bean class level\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "name",
      "qualifiers"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void registerBean(Class<?> beanClass, @Nullable String name,\n\t\t\tClass<? extends Annotation>... qualifiers)",
    "source_code": "\tpublic void registerBean(Class<?> beanClass, @Nullable String name,"
  },
  "org.springframework.context.annotation.AnnotatedBeanDefinitionReader#registerBean(beanClass,name,supplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations, using the given supplier for obtaining a new\n\t * instance (possibly declared as a lambda expression or method reference).\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @param supplier a callback for creating an instance of the bean\n\t * (may be {@code null})\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "name",
      "supplier"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, @Nullable String name, @Nullable Supplier<T> supplier)",
    "source_code": "\tpublic <T> void registerBean(Class<T> beanClass, @Nullable String name, @Nullable Supplier<T> supplier) {\n\t\tdoRegisterBean(beanClass, name, null, supplier, null);\n\t}"
  },
  "org.springframework.context.annotation.AnnotatedBeanDefinitionReader#registerBean(beanClass,name,supplier,customizers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @param supplier a callback for creating an instance of the bean\n\t * (may be {@code null})\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "name",
      "supplier",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, @Nullable String name, @Nullable Supplier<T> supplier,\n\t\t\tBeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic <T> void registerBean(Class<T> beanClass, @Nullable String name, @Nullable Supplier<T> supplier,"
  },
  "org.springframework.context.annotation.AnnotatedBeanDefinitionReader#registerBean(beanClass,qualifiers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param qualifiers specific qualifier annotations to consider,\n\t * in addition to qualifiers at the bean class level\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "qualifiers"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "void",
    "signature": "public void registerBean(Class<?> beanClass, Class<? extends Annotation>... qualifiers)",
    "source_code": "\tpublic void registerBean(Class<?> beanClass, Class<? extends Annotation>... qualifiers) {\n\t\tdoRegisterBean(beanClass, null, qualifiers, null, null);\n\t}"
  },
  "org.springframework.context.annotation.AnnotatedBeanDefinitionReader#registerBean(beanClass,supplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations, using the given supplier for obtaining a new\n\t * instance (possibly declared as a lambda expression or method reference).\n\t * @param beanClass the class of the bean\n\t * @param supplier a callback for creating an instance of the bean\n\t * (may be {@code null})\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "supplier"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, @Nullable Supplier<T> supplier)",
    "source_code": "\tpublic <T> void registerBean(Class<T> beanClass, @Nullable Supplier<T> supplier) {\n\t\tdoRegisterBean(beanClass, null, null, supplier, null);\n\t}"
  },
  "org.springframework.context.annotation.AnnotatedBeanDefinitionReader#setBeanNameGenerator(beanNameGenerator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@code BeanNameGenerator} to use for detected bean classes.\n\t * <p>The default is a {@link AnnotationBeanNameGenerator}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanNameGenerator"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void setBeanNameGenerator(@Nullable BeanNameGenerator beanNameGenerator)",
    "source_code": "\tpublic void setBeanNameGenerator(@Nullable BeanNameGenerator beanNameGenerator) {\n\t\tthis.beanNameGenerator =\n\t\t\t\t(beanNameGenerator != null ? beanNameGenerator : AnnotationBeanNameGenerator.INSTANCE);\n\t}"
  },
  "org.springframework.context.annotation.AnnotatedBeanDefinitionReader#setEnvironment(environment)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@code Environment} to use when evaluating whether\n\t * {@link Conditional @Conditional}-annotated component classes should be registered.\n\t * <p>The default is a {@link StandardEnvironment}.\n\t * @see #registerBean(Class, String, Class...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void setEnvironment(Environment environment)",
    "source_code": "\tpublic void setEnvironment(Environment environment) {\n\t\tthis.conditionEvaluator = new ConditionEvaluator(this.registry, environment, null);\n\t}"
  },
  "org.springframework.context.annotation.AnnotatedBeanDefinitionReader#setScopeMetadataResolver(scopeMetadataResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@code ScopeMetadataResolver} to use for registered component classes.\n\t * <p>The default is an {@link AnnotationScopeMetadataResolver}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scopeMetadataResolver"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void setScopeMetadataResolver(@Nullable ScopeMetadataResolver scopeMetadataResolver)",
    "source_code": "\tpublic void setScopeMetadataResolver(@Nullable ScopeMetadataResolver scopeMetadataResolver) {\n\t\tthis.scopeMetadataResolver =\n\t\t\t\t(scopeMetadataResolver != null ? scopeMetadataResolver : new AnnotationScopeMetadataResolver());\n\t}"
  },
  "org.springframework.context.annotation.ClassPathBeanDefinitionScanner": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A bean definition scanner that detects bean candidates on the classpath,\n * registering corresponding bean definitions with a given registry ({@code BeanFactory}\n * or {@code ApplicationContext}).\n *\n * <p>Candidate classes are detected through configurable type filters. The\n * default filters include classes that are annotated with Spring's\n * {@link org.springframework.stereotype.Component @Component},\n * {@link org.springframework.stereotype.Repository @Repository},\n * {@link org.springframework.stereotype.Service @Service}, or\n * {@link org.springframework.stereotype.Controller @Controller} stereotype.\n *\n * <p>Also supports Jakarta EE's {@link jakarta.annotation.ManagedBean} and\n * JSR-330's {@link jakarta.inject.Named} annotations, if available.\n *\n * @author Mark Fisher\n * @author Juergen Hoeller\n * @author Chris Beams\n * @since 2.5\n * @see AnnotationConfigApplicationContext#scan\n * @see org.springframework.stereotype.Component\n * @see org.springframework.stereotype.Repository\n * @see org.springframework.stereotype.Service\n * @see org.springframework.stereotype.Controller\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "signature": "public class ClassPathBeanDefinitionScanner",
    "source_code": "public class ClassPathBeanDefinitionScanner extends ClassPathScanningCandidateComponentProvider {\n\n\tprivate final BeanDefinitionRegistry registry;\n\n\tprivate BeanDefinitionDefaults beanDefinitionDefaults = new BeanDefinitionDefaults();\n\n\t@Nullable\n\tprivate String[] autowireCandidatePatterns;\n\n\tprivate BeanNameGenerator beanNameGenerator = AnnotationBeanNameGenerator.INSTANCE;\n\n\tprivate ScopeMetadataResolver scopeMetadataResolver = new AnnotationScopeMetadataResolver();\n\n\tprivate boolean includeAnnotationConfig = true;\n\n\n\t/**\n\t * Create a new {@code ClassPathBeanDefinitionScanner} for the given bean factory.\n\t * @param registry the {@code BeanFactory} to load bean definitions into, in the form\n\t * of a {@code BeanDefinitionRegistry}\n\t */\n\tpublic ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry) {\n\t\tthis(registry, true);\n\t}\n\n\t/**\n\t * Create a new {@code ClassPathBeanDefinitionScanner} for the given bean factory.\n\t * <p>If the passed-in bean factory does not only implement the\n\t * {@code BeanDefinitionRegistry} interface but also the {@code ResourceLoader}\n\t * interface, it will be used as default {@code ResourceLoader} as well. This will\n\t * usually be the case for {@link org.springframework.context.ApplicationContext}\n\t * implementations.\n\t * <p>If given a plain {@code BeanDefinitionRegistry}, the default {@code ResourceLoader}\n\t * will be a {@link org.springframework.core.io.support.PathMatchingResourcePatternResolver}.\n\t * <p>If the passed-in bean factory also implements {@link EnvironmentCapable} its\n\t * environment will be used by this reader.  Otherwise, the reader will initialize and\n\t * use a {@link org.springframework.core.env.StandardEnvironment}. All\n\t * {@code ApplicationContext} implementations are {@code EnvironmentCapable}, while\n\t * normal {@code BeanFactory} implementations are not.\n\t * @param registry the {@code BeanFactory} to load bean definitions into, in the form\n\t * of a {@code BeanDefinitionRegistry}\n\t * @param useDefaultFilters whether to include the default filters for the\n\t * {@link org.springframework.stereotype.Component @Component},\n\t * {@link org.springframework.stereotype.Repository @Repository},\n\t * {@link org.springframework.stereotype.Service @Service}, and\n\t * {@link org.springframework.stereotype.Controller @Controller} stereotype annotations\n\t * @see #setResourceLoader\n\t * @see #setEnvironment\n\t */\n\tpublic ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters) {\n\t\tthis(registry, useDefaultFilters, getOrCreateEnvironment(registry));\n\t}\n\n\t/**\n\t * Create a new {@code ClassPathBeanDefinitionScanner} for the given bean factory and\n\t * using the given {@link Environment} when evaluating bean definition profile metadata.\n\t * <p>If the passed-in bean factory does not only implement the {@code\n\t * BeanDefinitionRegistry} interface but also the {@link ResourceLoader} interface, it\n\t * will be used as default {@code ResourceLoader} as well. This will usually be the\n\t * case for {@link org.springframework.context.ApplicationContext} implementations.\n\t * <p>If given a plain {@code BeanDefinitionRegistry}, the default {@code ResourceLoader}\n\t * will be a {@link org.springframework.core.io.support.PathMatchingResourcePatternResolver}.\n\t * @param registry the {@code BeanFactory} to load bean definitions into, in the form\n\t * of a {@code BeanDefinitionRegistry}\n\t * @param useDefaultFilters whether to include the default filters for the\n\t * {@link org.springframework.stereotype.Component @Component},\n\t * {@link org.springframework.stereotype.Repository @Repository},\n\t * {@link org.springframework.stereotype.Service @Service}, and\n\t * {@link org.springframework.stereotype.Controller @Controller} stereotype annotations\n\t * @param environment the Spring {@link Environment} to use when evaluating bean\n\t * definition profile metadata\n\t * @since 3.1\n\t * @see #setResourceLoader\n\t */\n\tpublic ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters,\n\t\t\tEnvironment environment) {\n\n\t\tthis(registry, useDefaultFilters, environment,\n\t\t\t\t(registry instanceof ResourceLoader resourceLoader ? resourceLoader : null));\n\t}\n\n\t/**\n\t * Create a new {@code ClassPathBeanDefinitionScanner} for the given bean factory and\n\t * using the given {@link Environment} when evaluating bean definition profile metadata.\n\t * @param registry the {@code BeanFactory} to load bean definitions into, in the form\n\t * of a {@code BeanDefinitionRegistry}\n\t * @param useDefaultFilters whether to include the default filters for the\n\t * {@link org.springframework.stereotype.Component @Component},\n\t * {@link org.springframework.stereotype.Repository @Repository},\n\t * {@link org.springframework.stereotype.Service @Service}, and\n\t * {@link org.springframework.stereotype.Controller @Controller} stereotype annotations\n\t * @param environment the Spring {@link Environment} to use when evaluating bean\n\t * definition profile metadata\n\t * @param resourceLoader the {@link ResourceLoader} to use\n\t * @since 4.3.6\n\t */\n\tpublic ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters,\n\t\t\tEnvironment environment, @Nullable ResourceLoader resourceLoader) {\n\n\t\tAssert.notNull(registry, \"BeanDefinitionRegistry must not be null\");\n\t\tthis.registry = registry;\n\n\t\tif (useDefaultFilters) {\n\t\t\tregisterDefaultFilters();\n\t\t}\n\t\tsetEnvironment(environment);\n\t\tsetResourceLoader(resourceLoader);\n\t}\n\n\n\t/**\n\t * Return the BeanDefinitionRegistry that this scanner operates on.\n\t */\n\t@Override\n\tpublic final BeanDefinitionRegistry getRegistry() {\n\t\treturn this.registry;\n\t}\n\n\t/**\n\t * Set the defaults to use for detected beans.\n\t * @see BeanDefinitionDefaults\n\t */\n\tpublic void setBeanDefinitionDefaults(@Nullable BeanDefinitionDefaults beanDefinitionDefaults) {\n\t\tthis.beanDefinitionDefaults =\n\t\t\t\t(beanDefinitionDefaults != null ? beanDefinitionDefaults : new BeanDefinitionDefaults());\n\t}\n\n\t/**\n\t * Return the defaults to use for detected beans (never {@code null}).\n\t * @since 4.1\n\t */\n\tpublic BeanDefinitionDefaults getBeanDefinitionDefaults() {\n\t\treturn this.beanDefinitionDefaults;\n\t}\n\n\t/**\n\t * Set the name-matching patterns for determining autowire candidates.\n\t * @param autowireCandidatePatterns the patterns to match against\n\t */\n\tpublic void setAutowireCandidatePatterns(@Nullable String... autowireCandidatePatterns) {\n\t\tthis.autowireCandidatePatterns = autowireCandidatePatterns;\n\t}\n\n\t/**\n\t * Set the BeanNameGenerator to use for detected bean classes.\n\t * <p>Default is a {@link AnnotationBeanNameGenerator}.\n\t */\n\tpublic void setBeanNameGenerator(@Nullable BeanNameGenerator beanNameGenerator) {\n\t\tthis.beanNameGenerator =\n\t\t\t\t(beanNameGenerator != null ? beanNameGenerator : AnnotationBeanNameGenerator.INSTANCE);\n\t}\n\n\t/**\n\t * Set the ScopeMetadataResolver to use for detected bean classes.\n\t * Note that this will override any custom \"scopedProxyMode\" setting.\n\t * <p>The default is an {@link AnnotationScopeMetadataResolver}.\n\t * @see #setScopedProxyMode\n\t */\n\tpublic void setScopeMetadataResolver(@Nullable ScopeMetadataResolver scopeMetadataResolver) {\n\t\tthis.scopeMetadataResolver =\n\t\t\t\t(scopeMetadataResolver != null ? scopeMetadataResolver : new AnnotationScopeMetadataResolver());\n\t}\n\n\t/**\n\t * Specify the proxy behavior for non-singleton scoped beans.\n\t * Note that this will override any custom \"scopeMetadataResolver\" setting.\n\t * <p>The default is {@link ScopedProxyMode#NO}.\n\t * @see #setScopeMetadataResolver\n\t */\n\tpublic void setScopedProxyMode(ScopedProxyMode scopedProxyMode) {\n\t\tthis.scopeMetadataResolver = new AnnotationScopeMetadataResolver(scopedProxyMode);\n\t}\n\n\t/**\n\t * Specify whether to register annotation config post-processors.\n\t * <p>The default is to register the post-processors. Turn this off\n\t * to be able to ignore the annotations or to process them differently.\n\t */\n\tpublic void setIncludeAnnotationConfig(boolean includeAnnotationConfig) {\n\t\tthis.includeAnnotationConfig = includeAnnotationConfig;\n\t}\n\n\n\t/**\n\t * Perform a scan within the specified base packages.\n\t * @param basePackages the packages to check for annotated classes\n\t * @return number of beans registered\n\t */\n\tpublic int scan(String... basePackages) {\n\t\tint beanCountAtScanStart = this.registry.getBeanDefinitionCount();\n\n\t\tdoScan(basePackages);\n\n\t\t// Register annotation config processors, if necessary.\n\t\tif (this.includeAnnotationConfig) {\n\t\t\tAnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);\n\t\t}\n\n\t\treturn (this.registry.getBeanDefinitionCount() - beanCountAtScanStart);\n\t}\n\n\t/**\n\t * Perform a scan within the specified base packages,\n\t * returning the registered bean definitions.\n\t * <p>This method does <i>not</i> register an annotation config processor\n\t * but rather leaves this up to the caller.\n\t * @param basePackages the packages to check for annotated classes\n\t * @return set of beans registered if any for tooling registration purposes (never {@code null})\n\t */\n\tprotected Set<BeanDefinitionHolder> doScan(String... basePackages) {\n\t\tAssert.notEmpty(basePackages, \"At least one base package must be specified\");\n\t\tSet<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();\n\t\tfor (String basePackage : basePackages) {\n\t\t\tSet<BeanDefinition> candidates = findCandidateComponents(basePackage);\n\t\t\tfor (BeanDefinition candidate : candidates) {\n\t\t\t\tScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);\n\t\t\t\tcandidate.setScope(scopeMetadata.getScopeName());\n\t\t\t\tString beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);\n\t\t\t\tif (candidate instanceof AbstractBeanDefinition abstractBeanDefinition) {\n\t\t\t\t\tpostProcessBeanDefinition(abstractBeanDefinition, beanName);\n\t\t\t\t}\n\t\t\t\tif (candidate instanceof AnnotatedBeanDefinition annotatedBeanDefinition) {\n\t\t\t\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(annotatedBeanDefinition);\n\t\t\t\t}\n\t\t\t\tif (checkCandidate(beanName, candidate)) {\n\t\t\t\t\tBeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);\n\t\t\t\t\tdefinitionHolder =\n\t\t\t\t\t\t\tAnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);\n\t\t\t\t\tbeanDefinitions.add(definitionHolder);\n\t\t\t\t\tregisterBeanDefinition(definitionHolder, this.registry);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn beanDefinitions;\n\t}\n\n\t/**\n\t * Apply further settings to the given bean definition,\n\t * beyond the contents retrieved from scanning the component class.\n\t * @param beanDefinition the scanned bean definition\n\t * @param beanName the generated bean name for the given bean\n\t */\n\tprotected void postProcessBeanDefinition(AbstractBeanDefinition beanDefinition, String beanName) {\n\t\tbeanDefinition.applyDefaults(this.beanDefinitionDefaults);\n\t\tif (this.autowireCandidatePatterns != null) {\n\t\t\tbeanDefinition.setAutowireCandidate(PatternMatchUtils.simpleMatch(this.autowireCandidatePatterns, beanName));\n\t\t}\n\t}\n\n\t/**\n\t * Register the specified bean with the given registry.\n\t * <p>Can be overridden in subclasses, e.g. to adapt the registration\n\t * process or to register further bean definitions for each scanned bean.\n\t * @param definitionHolder the bean definition plus bean name for the bean\n\t * @param registry the BeanDefinitionRegistry to register the bean with\n\t */\n\tprotected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {\n\t\tBeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);\n\t}\n\n\n\t/**\n\t * Check the given candidate's bean name, determining whether the corresponding\n\t * bean definition needs to be registered or conflicts with an existing definition.\n\t * @param beanName the suggested name for the bean\n\t * @param beanDefinition the corresponding bean definition\n\t * @return {@code true} if the bean can be registered as-is;\n\t * {@code false} if it should be skipped because there is an\n\t * existing, compatible bean definition for the specified name\n\t * @throws ConflictingBeanDefinitionException if an existing, incompatible\n\t * bean definition has been found for the specified name\n\t */\n\tprotected boolean checkCandidate(String beanName, BeanDefinition beanDefinition) throws IllegalStateException {\n\t\tif (!this.registry.containsBeanDefinition(beanName)) {\n\t\t\treturn true;\n\t\t}\n\t\tBeanDefinition existingDef = this.registry.getBeanDefinition(beanName);\n\t\tBeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition();\n\t\tif (originatingDef != null) {\n\t\t\texistingDef = originatingDef;\n\t\t}\n\t\tif (isCompatible(beanDefinition, existingDef)) {\n\t\t\treturn false;\n\t\t}\n\t\tthrow new ConflictingBeanDefinitionException(\"Annotation-specified bean name '\" + beanName +\n\t\t\t\t\"' for bean class [\" + beanDefinition.getBeanClassName() + \"] conflicts with existing, \" +\n\t\t\t\t\"non-compatible bean definition of same name and class [\" + existingDef.getBeanClassName() + \"]\");\n\t}\n\n\t/**\n\t * Determine whether the given new bean definition is compatible with\n\t * the given existing bean definition.\n\t * <p>The default implementation considers them as compatible when the existing\n\t * bean definition comes from the same source or from a non-scanning source.\n\t * @param newDefinition the new bean definition, originated from scanning\n\t * @param existingDefinition the existing bean definition, potentially an\n\t * explicitly defined one or a previously generated one from scanning\n\t * @return whether the definitions are considered as compatible, with the\n\t * new definition to be skipped in favor of the existing definition\n\t */\n\tprotected boolean isCompatible(BeanDefinition newDefinition, BeanDefinition existingDefinition) {\n\t\treturn (!(existingDefinition instanceof ScannedGenericBeanDefinition) ||  // explicitly registered overriding bean\n\t\t\t\t(newDefinition.getSource() != null && newDefinition.getSource().equals(existingDefinition.getSource())) ||  // scanned same file twice\n\t\t\t\tnewDefinition.equals(existingDefinition));  // scanned equivalent class twice\n\t}\n\n\n\t/**\n\t * Get the Environment from the given registry if possible, otherwise return a new\n\t * StandardEnvironment.\n\t */\n\tprivate static Environment getOrCreateEnvironment(BeanDefinitionRegistry registry) {\n\t\tAssert.notNull(registry, \"BeanDefinitionRegistry must not be null\");\n\t\tif (registry instanceof EnvironmentCapable environmentCapable) {\n\t\t\treturn environmentCapable.getEnvironment();\n\t\t}\n\t\treturn new StandardEnvironment();\n\t}\n\n}"
  },
  "org.springframework.context.annotation.ClassPathBeanDefinitionScanner#checkCandidate(beanName,beanDefinition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check the given candidate's bean name, determining whether the corresponding\n\t * bean definition needs to be registered or conflicts with an existing definition.\n\t * @param beanName the suggested name for the bean\n\t * @param beanDefinition the corresponding bean definition\n\t * @return {@code true} if the bean can be registered as-is;\n\t * {@code false} if it should be skipped because there is an\n\t * existing, compatible bean definition for the specified name\n\t * @throws ConflictingBeanDefinitionException if an existing, incompatible\n\t * bean definition has been found for the specified name\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "boolean",
    "signature": "protected boolean checkCandidate(String beanName, BeanDefinition beanDefinition)",
    "source_code": "\tprotected boolean checkCandidate(String beanName, BeanDefinition beanDefinition) throws IllegalStateException {\n\t\tif (!this.registry.containsBeanDefinition(beanName)) {\n\t\t\treturn true;\n\t\t}\n\t\tBeanDefinition existingDef = this.registry.getBeanDefinition(beanName);\n\t\tBeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition();\n\t\tif (originatingDef != null) {\n\t\t\texistingDef = originatingDef;\n\t\t}\n\t\tif (isCompatible(beanDefinition, existingDef)) {\n\t\t\treturn false;\n\t\t}\n\t\tthrow new ConflictingBeanDefinitionException(\"Annotation-specified bean name '\" + beanName +\n\t\t\t\t\"' for bean class [\" + beanDefinition.getBeanClassName() + \"] conflicts with existing, \" +\n\t\t\t\t\"non-compatible bean definition of same name and class [\" + existingDef.getBeanClassName() + \"]\");\n\t}"
  },
  "org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan(basePackages)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a scan within the specified base packages,\n\t * returning the registered bean definitions.\n\t * <p>This method does <i>not</i> register an annotation config processor\n\t * but rather leaves this up to the caller.\n\t * @param basePackages the packages to check for annotated classes\n\t * @return set of beans registered if any for tooling registration purposes (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "basePackages"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "Set<BeanDefinitionHolder>",
    "signature": "protected Set<BeanDefinitionHolder> doScan(String... basePackages)",
    "source_code": "\tprotected Set<BeanDefinitionHolder> doScan(String... basePackages) {\n\t\tAssert.notEmpty(basePackages, \"At least one base package must be specified\");\n\t\tSet<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();\n\t\tfor (String basePackage : basePackages) {\n\t\t\tSet<BeanDefinition> candidates = findCandidateComponents(basePackage);\n\t\t\tfor (BeanDefinition candidate : candidates) {\n\t\t\t\tScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);\n\t\t\t\tcandidate.setScope(scopeMetadata.getScopeName());\n\t\t\t\tString beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);\n\t\t\t\tif (candidate instanceof AbstractBeanDefinition abstractBeanDefinition) {\n\t\t\t\t\tpostProcessBeanDefinition(abstractBeanDefinition, beanName);\n\t\t\t\t}\n\t\t\t\tif (candidate instanceof AnnotatedBeanDefinition annotatedBeanDefinition) {\n\t\t\t\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(annotatedBeanDefinition);\n\t\t\t\t}\n\t\t\t\tif (checkCandidate(beanName, candidate)) {\n\t\t\t\t\tBeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);\n\t\t\t\t\tdefinitionHolder =\n\t\t\t\t\t\t\tAnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);\n\t\t\t\t\tbeanDefinitions.add(definitionHolder);\n\t\t\t\t\tregisterBeanDefinition(definitionHolder, this.registry);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn beanDefinitions;\n\t}"
  },
  "org.springframework.context.annotation.ClassPathBeanDefinitionScanner#getBeanDefinitionDefaults()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the defaults to use for detected beans (never {@code null}).\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "BeanDefinitionDefaults",
    "signature": "public BeanDefinitionDefaults getBeanDefinitionDefaults()",
    "source_code": "\tpublic BeanDefinitionDefaults getBeanDefinitionDefaults() {\n\t\treturn this.beanDefinitionDefaults;\n\t}"
  },
  "org.springframework.context.annotation.ClassPathBeanDefinitionScanner#getRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the BeanDefinitionRegistry that this scanner operates on.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "BeanDefinitionRegistry",
    "signature": "public BeanDefinitionRegistry getRegistry()",
    "source_code": "\tpublic final BeanDefinitionRegistry getRegistry() {\n\t\treturn this.registry;\n\t}"
  },
  "org.springframework.context.annotation.ClassPathBeanDefinitionScanner#isCompatible(newDefinition,existingDefinition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given new bean definition is compatible with\n\t * the given existing bean definition.\n\t * <p>The default implementation considers them as compatible when the existing\n\t * bean definition comes from the same source or from a non-scanning source.\n\t * @param newDefinition the new bean definition, originated from scanning\n\t * @param existingDefinition the existing bean definition, potentially an\n\t * explicitly defined one or a previously generated one from scanning\n\t * @return whether the definitions are considered as compatible, with the\n\t * new definition to be skipped in favor of the existing definition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "newDefinition",
      "existingDefinition"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "boolean",
    "signature": "protected boolean isCompatible(BeanDefinition newDefinition, BeanDefinition existingDefinition)",
    "source_code": "\tprotected boolean isCompatible(BeanDefinition newDefinition, BeanDefinition existingDefinition) {\n\t\treturn (!(existingDefinition instanceof ScannedGenericBeanDefinition) ||  // explicitly registered overriding bean\n\t\t\t\t(newDefinition.getSource() != null && newDefinition.getSource().equals(existingDefinition.getSource())) ||  // scanned same file twice\n\t\t\t\tnewDefinition.equals(existingDefinition));  // scanned equivalent class twice\n\t}"
  },
  "org.springframework.context.annotation.ClassPathBeanDefinitionScanner#postProcessBeanDefinition(beanDefinition,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply further settings to the given bean definition,\n\t * beyond the contents retrieved from scanning the component class.\n\t * @param beanDefinition the scanned bean definition\n\t * @param beanName the generated bean name for the given bean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanDefinition",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "void",
    "signature": "protected void postProcessBeanDefinition(AbstractBeanDefinition beanDefinition, String beanName)",
    "source_code": "\tprotected void postProcessBeanDefinition(AbstractBeanDefinition beanDefinition, String beanName) {\n\t\tbeanDefinition.applyDefaults(this.beanDefinitionDefaults);\n\t\tif (this.autowireCandidatePatterns != null) {\n\t\t\tbeanDefinition.setAutowireCandidate(PatternMatchUtils.simpleMatch(this.autowireCandidatePatterns, beanName));\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.ClassPathBeanDefinitionScanner#registerBeanDefinition(definitionHolder,registry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified bean with the given registry.\n\t * <p>Can be overridden in subclasses, e.g. to adapt the registration\n\t * process or to register further bean definitions for each scanned bean.\n\t * @param definitionHolder the bean definition plus bean name for the bean\n\t * @param registry the BeanDefinitionRegistry to register the bean with\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "definitionHolder",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "void",
    "signature": "protected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)",
    "source_code": "\tprotected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {\n\t\tBeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);\n\t}"
  },
  "org.springframework.context.annotation.ClassPathBeanDefinitionScanner#scan(basePackages)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a scan within the specified base packages.\n\t * @param basePackages the packages to check for annotated classes\n\t * @return number of beans registered\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "basePackages"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "int",
    "signature": "public int scan(String... basePackages)",
    "source_code": "\tpublic int scan(String... basePackages) {\n\t\tint beanCountAtScanStart = this.registry.getBeanDefinitionCount();\n\n\t\tdoScan(basePackages);\n\n\t\t// Register annotation config processors, if necessary.\n\t\tif (this.includeAnnotationConfig) {\n\t\t\tAnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);\n\t\t}\n\n\t\treturn (this.registry.getBeanDefinitionCount() - beanCountAtScanStart);\n\t}"
  },
  "org.springframework.context.annotation.ClassPathBeanDefinitionScanner#setAutowireCandidatePatterns(autowireCandidatePatterns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name-matching patterns for determining autowire candidates.\n\t * @param autowireCandidatePatterns the patterns to match against\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "autowireCandidatePatterns"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void setAutowireCandidatePatterns(@Nullable String... autowireCandidatePatterns)",
    "source_code": "\tpublic void setAutowireCandidatePatterns(@Nullable String... autowireCandidatePatterns) {\n\t\tthis.autowireCandidatePatterns = autowireCandidatePatterns;\n\t}"
  },
  "org.springframework.context.annotation.ClassPathBeanDefinitionScanner#setBeanDefinitionDefaults(beanDefinitionDefaults)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the defaults to use for detected beans.\n\t * @see BeanDefinitionDefaults\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinitionDefaults"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "public void setBeanDefinitionDefaults(@Nullable BeanDefinitionDefaults beanDefinitionDefaults)",
    "source_code": "\tpublic void setBeanDefinitionDefaults(@Nullable BeanDefinitionDefaults beanDefinitionDefaults) {\n\t\tthis.beanDefinitionDefaults =\n\t\t\t\t(beanDefinitionDefaults != null ? beanDefinitionDefaults : new BeanDefinitionDefaults());\n\t}"
  },
  "org.springframework.context.annotation.ClassPathBeanDefinitionScanner#setBeanNameGenerator(beanNameGenerator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the BeanNameGenerator to use for detected bean classes.\n\t * <p>Default is a {@link AnnotationBeanNameGenerator}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanNameGenerator"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "public void setBeanNameGenerator(@Nullable BeanNameGenerator beanNameGenerator)",
    "source_code": "\tpublic void setBeanNameGenerator(@Nullable BeanNameGenerator beanNameGenerator) {\n\t\tthis.beanNameGenerator =\n\t\t\t\t(beanNameGenerator != null ? beanNameGenerator : AnnotationBeanNameGenerator.INSTANCE);\n\t}"
  },
  "org.springframework.context.annotation.ClassPathBeanDefinitionScanner#setIncludeAnnotationConfig(includeAnnotationConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to register annotation config post-processors.\n\t * <p>The default is to register the post-processors. Turn this off\n\t * to be able to ignore the annotations or to process them differently.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "includeAnnotationConfig"
    ],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "void",
    "signature": "public void setIncludeAnnotationConfig(boolean includeAnnotationConfig)",
    "source_code": "\tpublic void setIncludeAnnotationConfig(boolean includeAnnotationConfig) {\n\t\tthis.includeAnnotationConfig = includeAnnotationConfig;\n\t}"
  },
  "org.springframework.context.annotation.ClassPathBeanDefinitionScanner#setScopeMetadataResolver(scopeMetadataResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the ScopeMetadataResolver to use for detected bean classes.\n\t * Note that this will override any custom \"scopedProxyMode\" setting.\n\t * <p>The default is an {@link AnnotationScopeMetadataResolver}.\n\t * @see #setScopedProxyMode\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scopeMetadataResolver"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void setScopeMetadataResolver(@Nullable ScopeMetadataResolver scopeMetadataResolver)",
    "source_code": "\tpublic void setScopeMetadataResolver(@Nullable ScopeMetadataResolver scopeMetadataResolver) {\n\t\tthis.scopeMetadataResolver =\n\t\t\t\t(scopeMetadataResolver != null ? scopeMetadataResolver : new AnnotationScopeMetadataResolver());\n\t}"
  },
  "org.springframework.context.annotation.ClassPathBeanDefinitionScanner#setScopedProxyMode(scopedProxyMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the proxy behavior for non-singleton scoped beans.\n\t * Note that this will override any custom \"scopeMetadataResolver\" setting.\n\t * <p>The default is {@link ScopedProxyMode#NO}.\n\t * @see #setScopeMetadataResolver\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scopedProxyMode"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "void",
    "signature": "public void setScopedProxyMode(ScopedProxyMode scopedProxyMode)",
    "source_code": "\tpublic void setScopedProxyMode(ScopedProxyMode scopedProxyMode) {\n\t\tthis.scopeMetadataResolver = new AnnotationScopeMetadataResolver(scopedProxyMode);\n\t}"
  },
  "org.springframework.context.annotation.ImportAwareAotBeanPostProcessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@link BeanPostProcessor} that honours {@link ImportAware} callback using\n * a mapping computed at build time.\n *\n * @author Stephane Nicoll\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class ImportAwareAotBeanPostProcessor",
    "source_code": "public final class ImportAwareAotBeanPostProcessor implements BeanPostProcessor, PriorityOrdered {\n\n\tprivate final MetadataReaderFactory metadataReaderFactory;\n\n\tprivate final Map<String, String> importsMapping;\n\n\n\tpublic ImportAwareAotBeanPostProcessor(Map<String, String> importsMapping) {\n\t\tthis.metadataReaderFactory = new CachingMetadataReaderFactory();\n\t\tthis.importsMapping = Map.copyOf(importsMapping);\n\t}\n\n\n\t@Override\n\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) {\n\t\tif (bean instanceof ImportAware importAware) {\n\t\t\tsetAnnotationMetadata(importAware);\n\t\t}\n\t\treturn bean;\n\t}\n\n\t@Override\n\tpublic int getOrder() {\n\t\treturn Ordered.LOWEST_PRECEDENCE;  // match priority of original post processor\n\t}\n\n\tprivate void setAnnotationMetadata(ImportAware instance) {\n\t\tString importingClass = getImportingClassFor(instance);\n\t\tif (importingClass == null) {\n\t\t\treturn; // import aware configuration class not imported\n\t\t}\n\t\ttry {\n\t\t\tMetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(importingClass);\n\t\t\tinstance.setImportMetadata(metadataReader.getAnnotationMetadata());\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalStateException(String.format(\"Failed to read metadata for '%s'\", importingClass), ex);\n\t\t}\n\t}\n\n\t@Nullable\n\tprivate String getImportingClassFor(ImportAware instance) {\n\t\tString target = ClassUtils.getUserClass(instance).getName();\n\t\treturn this.importsMapping.get(target);\n\t}\n\n}"
  },
  "org.springframework.context.annotation.ImportAwareAotBeanPostProcessor#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic int getOrder() {\n\t\treturn Ordered.LOWEST_PRECEDENCE;  // match priority of original post processor\n\t}"
  },
  "org.springframework.context.annotation.ImportAwareAotBeanPostProcessor#postProcessBeforeInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) {\n\t\tif (bean instanceof ImportAware importAware) {\n\t\t\tsetAnnotationMetadata(importAware);\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.core.codec.SseLinesState": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "signature": "public class SseLinesState",
    "source_code": "\tpublic static class SseLinesState {\n\n\t\tprivate static final Charset CHARSET = StandardCharsets.UTF_8;\n\n\t\tprivate static final ResolvableType ELEMENT_TYPE = ResolvableType.forClass(String.class);\n\n\n\t\t@Param(\"10240\")\n\t\tint totalSize;\n\n\t\t@Param(\"2000\")\n\t\tint chunkSize;\n\n\t\tList<DataBuffer> chunks;\n\n\t\tStringDecoder decoder = StringDecoder.textPlainOnly(Arrays.asList(\"\\r\\n\", \"\\n\"), false);\n\n\t\tMimeType mimeType = new MimeType(\"text\", \"plain\", CHARSET);\n\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void setup() {\n\t\t\tString eventTemplate = \"\"\"\n\t\t\t\t\tid:$1\n\t\t\t\t\tevent:some-event\n\t\t\t\t\t:some-comment-$1-aa\n\t\t\t\t\t:some-comment-$1-bb\n\t\t\t\t\tdata:abcdefg-$1-hijklmnop-$1-qrstuvw-$1-xyz-$1\n\n\t\t\t\t\t\"\"\";\n\n\t\t\tint eventLength = String.format(eventTemplate, String.format(\"%05d\", 1)).length();\n\t\t\tint eventCount = this.totalSize / eventLength;\n\t\t\tDataBufferFactory bufferFactory = new DefaultDataBufferFactory();\n\n\t\t\tthis.chunks = Flux.range(1, eventCount)\n\t\t\t\t\t.map(index -> String.format(eventTemplate, String.format(\"%05d\", index)))\n\t\t\t\t\t.buffer(this.chunkSize > eventLength ? this.chunkSize / eventLength : 1)\n\t\t\t\t\t.map(strings -> String.join(\"\", strings))\n\t\t\t\t\t.map(chunk -> {\n\t\t\t\t\t\tbyte[] bytes = chunk.getBytes(CHARSET);\n\t\t\t\t\t\tDataBuffer buffer = bufferFactory.allocateBuffer(bytes.length);\n\t\t\t\t\t\tbuffer.write(bytes);\n\t\t\t\t\t\treturn buffer;\n\t\t\t\t\t})\n\t\t\t\t\t.collectList()\n\t\t\t\t\t.block();\n\t\t}\n\n\t\tpublic Flux<String> parseLines() {\n\t\t\tFlux<DataBuffer> input = Flux.fromIterable(this.chunks).doOnNext(DataBufferUtils::retain);\n\t\t\treturn this.decoder.decode(input, ELEMENT_TYPE, this.mimeType, Collections.emptyMap());\n\t\t}\n\t}"
  },
  "org.springframework.core.codec.StringDecoderBenchmark": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Benchmarks for {@link DataBufferUtils}.\n *\n * @author Rossen Stoyanchev\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class StringDecoderBenchmark",
    "source_code": "public class StringDecoderBenchmark {\n\n\t@Benchmark\n\tpublic void parseSseLines(SseLinesState state, Blackhole blackhole) {\n\t\tblackhole.consume(state.parseLines().blockLast());\n\t}\n\n\n\t@State(Scope.Benchmark)\n\t@SuppressWarnings({\"NotNullFieldNotInitialized\", \"ConstantConditions\"})\n\tpublic static class SseLinesState {\n\n\t\tprivate static final Charset CHARSET = StandardCharsets.UTF_8;\n\n\t\tprivate static final ResolvableType ELEMENT_TYPE = ResolvableType.forClass(String.class);\n\n\n\t\t@Param(\"10240\")\n\t\tint totalSize;\n\n\t\t@Param(\"2000\")\n\t\tint chunkSize;\n\n\t\tList<DataBuffer> chunks;\n\n\t\tStringDecoder decoder = StringDecoder.textPlainOnly(Arrays.asList(\"\\r\\n\", \"\\n\"), false);\n\n\t\tMimeType mimeType = new MimeType(\"text\", \"plain\", CHARSET);\n\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void setup() {\n\t\t\tString eventTemplate = \"\"\"\n\t\t\t\t\tid:$1\n\t\t\t\t\tevent:some-event\n\t\t\t\t\t:some-comment-$1-aa\n\t\t\t\t\t:some-comment-$1-bb\n\t\t\t\t\tdata:abcdefg-$1-hijklmnop-$1-qrstuvw-$1-xyz-$1\n\n\t\t\t\t\t\"\"\";\n\n\t\t\tint eventLength = String.format(eventTemplate, String.format(\"%05d\", 1)).length();\n\t\t\tint eventCount = this.totalSize / eventLength;\n\t\t\tDataBufferFactory bufferFactory = new DefaultDataBufferFactory();\n\n\t\t\tthis.chunks = Flux.range(1, eventCount)\n\t\t\t\t\t.map(index -> String.format(eventTemplate, String.format(\"%05d\", index)))\n\t\t\t\t\t.buffer(this.chunkSize > eventLength ? this.chunkSize / eventLength : 1)\n\t\t\t\t\t.map(strings -> String.join(\"\", strings))\n\t\t\t\t\t.map(chunk -> {\n\t\t\t\t\t\tbyte[] bytes = chunk.getBytes(CHARSET);\n\t\t\t\t\t\tDataBuffer buffer = bufferFactory.allocateBuffer(bytes.length);\n\t\t\t\t\t\tbuffer.write(bytes);\n\t\t\t\t\t\treturn buffer;\n\t\t\t\t\t})\n\t\t\t\t\t.collectList()\n\t\t\t\t\t.block();\n\t\t}\n\n\t\tpublic Flux<String> parseLines() {\n\t\t\tFlux<DataBuffer> input = Flux.fromIterable(this.chunks).doOnNext(DataBufferUtils::retain);\n\t\t\treturn this.decoder.decode(input, ELEMENT_TYPE, this.mimeType, Collections.emptyMap());\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.core.codec.StringDecoderBenchmark#parseLines()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "Flux<String>",
    "signature": "public Flux<String> parseLines()",
    "source_code": "\t\tpublic Flux<String> parseLines() {\n\t\t\tFlux<DataBuffer> input = Flux.fromIterable(this.chunks).doOnNext(DataBufferUtils::retain);\n\t\t\treturn this.decoder.decode(input, ELEMENT_TYPE, this.mimeType, Collections.emptyMap());\n\t\t}"
  },
  "org.springframework.core.codec.StringDecoderBenchmark#parseSseLines(state,blackhole)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "state",
      "blackhole"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "void",
    "signature": "public void parseSseLines(SseLinesState state, Blackhole blackhole)",
    "source_code": "\tpublic void parseSseLines(SseLinesState state, Blackhole blackhole) {\n\t\tblackhole.consume(state.parseLines().blockLast());\n\t}"
  },
  "org.springframework.core.codec.StringDecoderBenchmark#setup()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "void",
    "signature": "public void setup()",
    "source_code": "\t\tpublic void setup() {\n\t\t\tString eventTemplate = \"\"\"\n\t\t\t\t\tid:$1\n\t\t\t\t\tevent:some-event\n\t\t\t\t\t:some-comment-$1-aa\n\t\t\t\t\t:some-comment-$1-bb\n\t\t\t\t\tdata:abcdefg-$1-hijklmnop-$1-qrstuvw-$1-xyz-$1\n\n\t\t\t\t\t\"\"\";\n\n\t\t\tint eventLength = String.format(eventTemplate, String.format(\"%05d\", 1)).length();\n\t\t\tint eventCount = this.totalSize / eventLength;\n\t\t\tDataBufferFactory bufferFactory = new DefaultDataBufferFactory();\n\n\t\t\tthis.chunks = Flux.range(1, eventCount)\n\t\t\t\t\t.map(index -> String.format(eventTemplate, String.format(\"%05d\", index)))\n\t\t\t\t\t.buffer(this.chunkSize > eventLength ? this.chunkSize / eventLength : 1)\n\t\t\t\t\t.map(strings -> String.join(\"\", strings))\n\t\t\t\t\t.map(chunk -> {\n\t\t\t\t\t\tbyte[] bytes = chunk.getBytes(CHARSET);\n\t\t\t\t\t\tDataBuffer buffer = bufferFactory.allocateBuffer(bytes.length);\n\t\t\t\t\t\tbuffer.write(bytes);\n\t\t\t\t\t\treturn buffer;\n\t\t\t\t\t})\n\t\t\t\t\t.collectList()\n\t\t\t\t\t.block();\n\t\t}"
  },
  "org.springframework.core.io.FileSystemResource#getContentAsByteArray()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "byte[]",
    "signature": "public byte[] getContentAsByteArray()",
    "source_code": "\tpublic byte[] getContentAsByteArray() throws IOException {\n\t\ttry {\n\t\t\treturn Files.readAllBytes(this.filePath);\n\t\t}\n\t\tcatch (NoSuchFileException ex) {\n\t\t\tthrow new FileNotFoundException(ex.getMessage());\n\t\t}\n\t}"
  },
  "org.springframework.core.io.FileSystemResource#getContentAsString(charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "String",
    "signature": "public String getContentAsString(Charset charset)",
    "source_code": "\tpublic String getContentAsString(Charset charset) throws IOException {\n\t\ttry {\n\t\t\treturn Files.readString(this.filePath, charset);\n\t\t}\n\t\tcatch (NoSuchFileException ex) {\n\t\t\tthrow new FileNotFoundException(ex.getMessage());\n\t\t}\n\t}"
  },
  "org.springframework.core.io.buffer.DataBufferUtils#completed(read,attachment)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "read",
      "attachment"
    ],
    "position": {
      "column": 1,
      "line": 998
    },
    "return": "void",
    "signature": "public void completed(Integer read, Attachment attachment)",
    "source_code": "\t\tpublic void completed(Integer read, Attachment attachment) {\n\t\t\tattachment.iterator().close();\n\t\t\tDataBuffer dataBuffer = attachment.dataBuffer();\n\n\t\t\tif (this.state.get().equals(State.DISPOSED)) {\n\t\t\t\trelease(dataBuffer);\n\t\t\t\tcloseChannel(this.channel);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (read == -1) {\n\t\t\t\trelease(dataBuffer);\n\t\t\t\tcloseChannel(this.channel);\n\t\t\t\tthis.state.set(State.DISPOSED);\n\t\t\t\tthis.sink.complete();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.position.addAndGet(read);\n\t\t\tdataBuffer.writePosition(read);\n\t\t\tthis.sink.next(dataBuffer);\n\n\t\t\t// Stay in READING mode if there is demand\n\t\t\tif (this.sink.requestedFromDownstream() > 0) {\n\t\t\t\tread();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Release READING mode and then try again in case of concurrent \"request\"\n\t\t\tif (this.state.compareAndSet(State.READING, State.IDLE)) {\n\t\t\t\ttryRead();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.io.buffer.DataBufferUtils#completed(read,byteBuffer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "read",
      "byteBuffer"
    ],
    "position": {
      "column": 1,
      "line": 988
    },
    "return": "void",
    "signature": "public void completed(Integer read, ByteBuffer byteBuffer)",
    "source_code": "\t\tpublic void completed(Integer read, ByteBuffer byteBuffer) {\n\t\t\tif (this.state.get().equals(State.DISPOSED)) {\n\t\t\t\tcloseChannel(this.channel);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (read == -1) {\n\t\t\t\tcloseChannel(this.channel);\n\t\t\t\tthis.state.set(State.DISPOSED);\n\t\t\t\tthis.sink.complete();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.position.addAndGet(read);\n\n\t\t\tbyteBuffer.flip();\n\t\t\tDataBuffer dataBuffer = this.dataBufferFactory.wrap(byteBuffer);\n\t\t\tthis.sink.next(dataBuffer);\n\n\t\t\t// Stay in READING mode if there is demand\n\t\t\tif (this.sink.requestedFromDownstream() > 0) {\n\t\t\t\tread();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Release READING mode and then try again in case of concurrent \"request\"\n\t\t\tif (this.state.compareAndSet(State.READING, State.IDLE)) {\n\t\t\t\ttryRead();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.io.buffer.DataBufferUtils#completed(written,attachment)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "written",
      "attachment"
    ],
    "position": {
      "column": 1,
      "line": 1161
    },
    "return": "void",
    "signature": "public void completed(Integer written, Attachment attachment)",
    "source_code": "\t\tpublic void completed(Integer written, Attachment attachment) {\n\t\t\tDataBuffer.ByteBufferIterator iterator = attachment.iterator();\n\t\t\titerator.close();\n\n\t\t\tlong pos = this.position.addAndGet(written);\n\t\t\tByteBuffer byteBuffer = attachment.byteBuffer();\n\n\t\t\tif (byteBuffer.hasRemaining()) {\n\t\t\t\tthis.channel.write(byteBuffer, pos, attachment, this);\n\t\t\t}\n\t\t\telse if (iterator.hasNext()) {\n\t\t\t\tByteBuffer next = iterator.next();\n\t\t\t\tthis.channel.write(next, pos, attachment, this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.sink.next(attachment.dataBuffer());\n\t\t\t\tthis.writing.set(false);\n\n\t\t\t\tThrowable throwable = this.error.get();\n\t\t\t\tif (throwable != null) {\n\t\t\t\t\tthis.sink.error(throwable);\n\t\t\t\t}\n\t\t\t\telse if (this.completed.get()) {\n\t\t\t\t\tthis.sink.complete();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trequest(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.io.buffer.DataBufferUtils#completed(written,byteBuffer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "written",
      "byteBuffer"
    ],
    "position": {
      "column": 1,
      "line": 1138
    },
    "return": "void",
    "signature": "public void completed(Integer written, ByteBuffer byteBuffer)",
    "source_code": "\t\tpublic void completed(Integer written, ByteBuffer byteBuffer) {\n\t\t\tlong pos = this.position.addAndGet(written);\n\t\t\tif (byteBuffer.hasRemaining()) {\n\t\t\t\tthis.channel.write(byteBuffer, pos, byteBuffer, this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsinkDataBuffer();\n\n\t\t\tThrowable throwable = this.error.get();\n\t\t\tif (throwable != null) {\n\t\t\t\tthis.sink.error(throwable);\n\t\t\t}\n\t\t\telse if (this.completed.get()) {\n\t\t\t\tthis.sink.complete();\n\t\t\t}\n\t\t\telse {\n\t\t\t\trequest(1);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.io.buffer.DataBufferUtils#failed(exc,attachment)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exc",
      "attachment"
    ],
    "position": {
      "column": 1,
      "line": 1193
    },
    "return": "void",
    "signature": "public void failed(Throwable exc, Attachment attachment)",
    "source_code": "\t\tpublic void failed(Throwable exc, Attachment attachment) {\n\t\t\tattachment.iterator().close();\n\n\t\t\tthis.sink.next(attachment.dataBuffer());\n\t\t\tthis.writing.set(false);\n\n\t\t\tthis.sink.error(exc);\n\t\t}"
  },
  "org.springframework.core.io.buffer.DataBufferUtils#failed(exc,byteBuffer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exc",
      "byteBuffer"
    ],
    "position": {
      "column": 1,
      "line": 1159
    },
    "return": "void",
    "signature": "public void failed(Throwable exc, ByteBuffer byteBuffer)",
    "source_code": "\t\tpublic void failed(Throwable exc, ByteBuffer byteBuffer) {\n\t\t\tsinkDataBuffer();\n\t\t\tthis.sink.error(exc);\n\t\t}"
  },
  "org.springframework.core.io.buffer.DataBufferUtils#hookOnNext(value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1111
    },
    "return": "void",
    "signature": "protected void hookOnNext(DataBuffer value)",
    "source_code": "\t\tprotected void hookOnNext(DataBuffer value) {\n\t\t\tif (!this.dataBuffer.compareAndSet(null, value)) {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t\tByteBuffer byteBuffer = value.toByteBuffer();\n\t\t\tthis.channel.write(byteBuffer, this.position.get(), byteBuffer, this);\n\t\t}"
  },
  "org.springframework.core.io.buffer.DefaultDataBuffer#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 574
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\t\tpublic void close() {\n\t\t}"
  },
  "org.springframework.core.io.buffer.DefaultDataBuffer#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 558
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.hasNext;\n\t\t}"
  },
  "org.springframework.core.io.buffer.DefaultDataBuffer#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer next()",
    "source_code": "\t\tpublic ByteBuffer next() {\n\t\t\tif (!this.hasNext) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.hasNext = false;\n\t\t\t\treturn this.buffer;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.io.buffer.DefaultDataBuffer#toByteBuffer(srcPos,dest,destPos,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "srcPos",
      "dest",
      "destPos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "void",
    "signature": "public void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length)",
    "source_code": "\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\tcheckIndex(srcPos, length);\n\t\tAssert.notNull(dest, \"Dest must not be null\");\n\n\t\tdest = dest.duplicate().clear();\n\t\tdest.put(destPos, this.byteBuffer, srcPos, length);\n\t}"
  },
  "org.springframework.core.io.buffer.DefaultDataBuffer#write(dataBuffers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataBuffers"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "DefaultDataBuffer",
    "signature": "public DefaultDataBuffer write(DataBuffer... dataBuffers)",
    "source_code": "\tpublic DefaultDataBuffer write(DataBuffer... dataBuffers) {\n\t\tif (!ObjectUtils.isEmpty(dataBuffers)) {\n\t\t\tByteBuffer[] byteBuffers = new ByteBuffer[dataBuffers.length];\n\t\t\tfor (int i = 0; i < dataBuffers.length; i++) {\n\t\t\t\tbyteBuffers[i] = ByteBuffer.allocate(dataBuffers[i].readableByteCount());\n\t\t\t\tdataBuffers[i].toByteBuffer(byteBuffers[i]);\n\t\t\t}\n\t\t\twrite(byteBuffers);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.Netty5DataBuffer#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.next != null;\n\t\t}"
  },
  "org.springframework.core.io.buffer.Netty5DataBuffer#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 380
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer next()",
    "source_code": "\t\tpublic ByteBuffer next() {\n\t\t\tif (this.next != null) {\n\t\t\t\tByteBuffer result;\n\t\t\t\tif (this.readable) {\n\t\t\t\t\tresult = this.next.readableBuffer();\n\t\t\t\t\tthis.next = this.next.nextReadable();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult = this.next.writableBuffer();\n\t\t\t\t\tthis.next = this.next.nextWritable();\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.io.buffer.Netty5DataBuffer#readableByteBuffers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "ByteBufferIterator",
    "signature": "public ByteBufferIterator readableByteBuffers()",
    "source_code": "\tpublic ByteBufferIterator readableByteBuffers() {\n\t\treturn new BufferComponentIterator<>(this.buffer.forEachComponent(), true);\n\t}"
  },
  "org.springframework.core.io.buffer.Netty5DataBuffer#toByteBuffer(srcPos,dest,destPos,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "srcPos",
      "dest",
      "destPos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "void",
    "signature": "public void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length)",
    "source_code": "\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\tthis.buffer.copyInto(srcPos, dest, destPos, length);\n\t}"
  },
  "org.springframework.core.io.buffer.Netty5DataBuffer#writableByteBuffers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "ByteBufferIterator",
    "signature": "public ByteBufferIterator writableByteBuffers()",
    "source_code": "\tpublic ByteBufferIterator writableByteBuffers() {\n\t\treturn new BufferComponentIterator<>(this.buffer.forEachComponent(), false);\n\t}"
  },
  "org.springframework.core.io.buffer.Netty5DataBuffer#write(dataBuffers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataBuffers"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "Netty5DataBuffer",
    "signature": "public Netty5DataBuffer write(DataBuffer... dataBuffers)",
    "source_code": "\tpublic Netty5DataBuffer write(DataBuffer... dataBuffers) {\n\t\tif (!ObjectUtils.isEmpty(dataBuffers)) {\n\t\t\tif (hasNetty5DataBuffers(dataBuffers)) {\n\t\t\t\tBuffer[] nativeBuffers = new Buffer[dataBuffers.length];\n\t\t\t\tfor (int i = 0; i < dataBuffers.length; i++) {\n\t\t\t\t\tnativeBuffers[i] = ((Netty5DataBuffer) dataBuffers[i]).getNativeBuffer();\n\t\t\t\t}\n\t\t\t\treturn write(nativeBuffers);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tByteBuffer[] byteBuffers = new ByteBuffer[dataBuffers.length];\n\t\t\t\tfor (int i = 0; i < dataBuffers.length; i++) {\n\t\t\t\t\tbyteBuffers[i] = ByteBuffer.allocate(dataBuffers[i].readableByteCount());\n\t\t\t\t\tdataBuffers[i].toByteBuffer(byteBuffers[i]);\n\t\t\t\t}\n\t\t\t\treturn write(byteBuffers);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBufferFactory#toByteBuf(buffer)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the given Netty {@link DataBuffer} as a {@link ByteBuf}.\n\t * <p>Returns the {@linkplain NettyDataBuffer#getNativeBuffer() native buffer}\n\t * if {@code buffer} is a {@link NettyDataBuffer}; returns\n\t * {@link Unpooled#wrappedBuffer(ByteBuffer)} otherwise.\n\t * @param buffer the {@code DataBuffer} to return a {@code ByteBuf} for\n\t * @return the netty {@code ByteBuf}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "buffer"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "ByteBuf",
    "signature": "public ByteBuf toByteBuf(DataBuffer buffer)",
    "source_code": "\tpublic static ByteBuf toByteBuf(DataBuffer buffer) {\n\t\tif (buffer instanceof NettyDataBuffer nettyDataBuffer) {\n\t\t\treturn nettyDataBuffer.getNativeBuffer();\n\t\t}\n\t\telse {\n\t\t\treturn Unpooled.wrappedBuffer(buffer.toByteBuffer());\n\t\t}\n\t}"
  },
  "org.springframework.core.io.buffer.NettyDataBufferFactory#toByteBuf(dataBuffer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the given Netty {@link DataBuffer} as a {@link ByteBuf}.\n\t * <p>Returns the {@linkplain NettyDataBuffer#getNativeBuffer() native buffer}\n\t * if {@code dataBuffer} is a {@link NettyDataBuffer}; returns\n\t * {@link Unpooled#wrappedBuffer(ByteBuffer)} otherwise.\n\t * @param dataBuffer the {@code DataBuffer} to return a {@code ByteBuf} for\n\t * @return the netty {@code ByteBuf}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataBuffer"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "ByteBuf",
    "signature": "public ByteBuf toByteBuf(DataBuffer dataBuffer)",
    "source_code": "\tpublic static ByteBuf toByteBuf(DataBuffer dataBuffer) {\n\t\tif (dataBuffer instanceof NettyDataBuffer nettyDataBuffer) {\n\t\t\treturn nettyDataBuffer.getNativeBuffer();\n\t\t}\n\t\telse {\n\t\t\tByteBuffer byteBuffer = ByteBuffer.allocate(dataBuffer.readableByteCount());\n\t\t\tdataBuffer.toByteBuffer(byteBuffer);\n\t\t\treturn Unpooled.wrappedBuffer(byteBuffer);\n\t\t}\n\t}"
  },
  "org.springframework.core.io.support.EncodedResource#getContentAsString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the contents of the specified resource as a string, using the specified\n\t * {@link #getCharset() Charset} or {@linkplain #getEncoding() encoding} (if any).\n\t * @throws IOException if opening the resource failed\n\t * @since 6.0.5\n\t * @see Resource#getContentAsString(Charset)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "String",
    "signature": "public String getContentAsString()",
    "source_code": "\tpublic String getContentAsString() throws IOException {\n\t\tCharset charset;\n\t\tif (this.charset != null) {\n\t\t\tcharset = this.charset;\n\t\t}\n\t\telse if (this.encoding != null) {\n\t\t\tcharset = Charset.forName(this.encoding);\n\t\t}\n\t\telse {\n\t\t\tcharset = Charset.defaultCharset();\n\t\t}\n\t\treturn this.resource.getContentAsString(charset);\n\t}"
  },
  "org.springframework.expression.spel.ClinitAdder": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Interface used to generate {@code clinit} static initializer blocks.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 962
    },
    "signature": "public interface ClinitAdder",
    "source_code": "\tpublic interface ClinitAdder {\n\n\t\tvoid generateCode(MethodVisitor mv, CodeFlow codeflow);\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Manages the class being generated by the compilation process.\n *\n * <p>Records intermediate compilation state as the bytecode is generated.\n * Also includes various bytecode generation helper functions.\n *\n * @author Andy Clement\n * @author Juergen Hoeller\n * @since 4.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class CodeFlow",
    "source_code": "public class CodeFlow implements Opcodes {\n\n\t/**\n\t * Name of the class being generated. Typically used when generating code\n\t * that accesses freshly generated fields on the generated type.\n\t */\n\tprivate final String className;\n\n\t/**\n\t * The current class being generated.\n\t */\n\tprivate final ClassWriter classWriter;\n\n\t/**\n\t * Record the type of what is on top of the bytecode stack (i.e. the type of the\n\t * output from the previous expression component). New scopes are used to evaluate\n\t * sub-expressions like the expressions for the argument values in a method invocation\n\t * expression.\n\t */\n\tprivate final Deque<List<String>> compilationScopes;\n\n\t/**\n\t * As SpEL AST nodes are called to generate code for the main evaluation method\n\t * they can register to add a field to this class. Any registered FieldAdders\n\t * will be called after the main evaluation function has finished being generated.\n\t */\n\t@Nullable\n\tprivate List<FieldAdder> fieldAdders;\n\n\t/**\n\t * As SpEL AST nodes are called to generate code for the main evaluation method\n\t * they can register to add code to a static initializer in the class. Any\n\t * registered ClinitAdders will be called after the main evaluation function\n\t * has finished being generated.\n\t */\n\t@Nullable\n\tprivate List<ClinitAdder> clinitAdders;\n\n\t/**\n\t * When code generation requires holding a value in a class level field, this\n\t * is used to track the next available field id (used as a name suffix).\n\t */\n\tprivate int nextFieldId = 1;\n\n\t/**\n\t * When code generation requires an intermediate variable within a method,\n\t * this method records the next available variable (variable 0 is 'this').\n\t */\n\tprivate int nextFreeVariableId = 1;\n\n\n\t/**\n\t * Construct a new {@code CodeFlow} for the given class.\n\t * @param className the name of the class\n\t * @param classWriter the corresponding ASM {@code ClassWriter}\n\t */\n\tpublic CodeFlow(String className, ClassWriter classWriter) {\n\t\tthis.className = className;\n\t\tthis.classWriter = classWriter;\n\t\tthis.compilationScopes = new ArrayDeque<>();\n\t\tthis.compilationScopes.add(new ArrayList<String>());\n\t}\n\n\n\t/**\n\t * Push the byte code to load the target (i.e. what was passed as the first argument\n\t * to CompiledExpression.getValue(target, context))\n\t * @param mv the method visitor into which the load instruction should be inserted\n\t */\n\tpublic void loadTarget(MethodVisitor mv) {\n\t\tmv.visitVarInsn(ALOAD, 1);\n\t}\n\n\t/**\n\t * Push the bytecode to load the EvaluationContext (the second parameter passed to\n\t * the compiled expression method).\n\t * @param mv the method visitor into which the load instruction should be inserted\n\t * @since 4.3.4\n\t */\n\tpublic void loadEvaluationContext(MethodVisitor mv) {\n\t\tmv.visitVarInsn(ALOAD, 2);\n\t}\n\n\t/**\n\t * Record the descriptor for the most recently evaluated expression element.\n\t * @param descriptor type descriptor for most recently evaluated element\n\t */\n\tpublic void pushDescriptor(@Nullable String descriptor) {\n\t\tif (descriptor != null) {\n\t\t\tthis.compilationScopes.element().add(descriptor);\n\t\t}\n\t}\n\n\t/**\n\t * Enter a new compilation scope, usually due to nested expression evaluation. For\n\t * example when the arguments for a method invocation expression are being evaluated,\n\t * each argument will be evaluated in a new scope.\n\t */\n\tpublic void enterCompilationScope() {\n\t\tthis.compilationScopes.push(new ArrayList<>());\n\t}\n\n\t/**\n\t * Exit a compilation scope, usually after a nested expression has been evaluated. For\n\t * example after an argument for a method invocation has been evaluated this method\n\t * returns us to the previous (outer) scope.\n\t */\n\tpublic void exitCompilationScope() {\n\t\tthis.compilationScopes.pop();\n\t}\n\n\t/**\n\t * Return the descriptor for the item currently on top of the stack (in the current scope).\n\t */\n\t@Nullable\n\tpublic String lastDescriptor() {\n\t\treturn CollectionUtils.lastElement(this.compilationScopes.peek());\n\t}\n\n\t/**\n\t * If the codeflow shows the last expression evaluated to java.lang.Boolean then\n\t * insert the necessary instructions to unbox that to a boolean primitive.\n\t * @param mv the method visitor into which new instructions should be inserted\n\t */\n\tpublic void unboxBooleanIfNecessary(MethodVisitor mv) {\n\t\tif (\"Ljava/lang/Boolean\".equals(lastDescriptor())) {\n\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Boolean\", \"booleanValue\", \"()Z\", false);\n\t\t}\n\t}\n\n\t/**\n\t * Called after the main expression evaluation method has been generated, this\n\t * method will call back any registered FieldAdders or ClinitAdders to add any\n\t * extra information to the class representing the compiled expression.\n\t */\n\tpublic void finish() {\n\t\tif (this.fieldAdders != null) {\n\t\t\tfor (FieldAdder fieldAdder : this.fieldAdders) {\n\t\t\t\tfieldAdder.generateField(this.classWriter, this);\n\t\t\t}\n\t\t}\n\t\tif (this.clinitAdders != null) {\n\t\t\tMethodVisitor mv = this.classWriter.visitMethod(ACC_PUBLIC | ACC_STATIC, \"<clinit>\", \"()V\", null, null);\n\t\t\tmv.visitCode();\n\t\t\tthis.nextFreeVariableId = 0;  // to 0 because there is no 'this' in a clinit\n\t\t\tfor (ClinitAdder clinitAdder : this.clinitAdders) {\n\t\t\t\tclinitAdder.generateCode(mv, this);\n\t\t\t}\n\t\t\tmv.visitInsn(RETURN);\n\t\t\tmv.visitMaxs(0,0);  // not supplied due to COMPUTE_MAXS\n\t\t\tmv.visitEnd();\n\t\t}\n\t}\n\n\t/**\n\t * Register a FieldAdder which will add a new field to the generated\n\t * class to support the code produced by an AST node's primary\n\t * generateCode() method.\n\t */\n\tpublic void registerNewField(FieldAdder fieldAdder) {\n\t\tif (this.fieldAdders == null) {\n\t\t\tthis.fieldAdders = new ArrayList<>();\n\t\t}\n\t\tthis.fieldAdders.add(fieldAdder);\n\t}\n\n\t/**\n\t * Register a ClinitAdder which will add code to the static\n\t * initializer in the generated class to support the code\n\t * produced by an AST node's primary generateCode() method.\n\t */\n\tpublic void registerNewClinit(ClinitAdder clinitAdder) {\n\t\tif (this.clinitAdders == null) {\n\t\t\tthis.clinitAdders = new ArrayList<>();\n\t\t}\n\t\tthis.clinitAdders.add(clinitAdder);\n\t}\n\n\tpublic int nextFieldId() {\n\t\treturn this.nextFieldId++;\n\t}\n\n\tpublic int nextFreeVariableId() {\n\t\treturn this.nextFreeVariableId++;\n\t}\n\n\tpublic String getClassName() {\n\t\treturn this.className;\n\t}\n\n\n\t/**\n\t * Insert any necessary cast and value call to convert from a boxed type to a\n\t * primitive value.\n\t * @param mv the method visitor into which instructions should be inserted\n\t * @param ch the primitive type desired as output\n\t * @param stackDescriptor the descriptor of the type on top of the stack\n\t */\n\tpublic static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor) {\n\t\tif (stackDescriptor == null) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (ch) {\n\t\t\tcase 'Z' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Boolean\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Boolean\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Boolean\", \"booleanValue\", \"()Z\", false);\n\t\t\t}\n\t\t\tcase 'B' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Byte\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Byte\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Byte\", \"byteValue\", \"()B\", false);\n\t\t\t}\n\t\t\tcase 'C' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Character\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Character\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Character\", \"charValue\", \"()C\", false);\n\t\t\t}\n\t\t\tcase 'D' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Double\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Double\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Double\", \"doubleValue\", \"()D\", false);\n\t\t\t}\n\t\t\tcase 'F' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Float\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Float\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Float\", \"floatValue\", \"()F\", false);\n\t\t\t}\n\t\t\tcase 'I' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Integer\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Integer\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Integer\", \"intValue\", \"()I\", false);\n\t\t\t}\n\t\t\tcase 'J' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Long\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Long\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Long\", \"longValue\", \"()J\", false);\n\t\t\t}\n\t\t\tcase 'S' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Short\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Short\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Short\", \"shortValue\", \"()S\", false);\n\t\t\t}\n\t\t\tdefault ->\n\t\t\t\tthrow new IllegalArgumentException(\"Unboxing should not be attempted for descriptor '\" + ch + \"'\");\n\t\t}\n\t}\n\n\t/**\n\t * For numbers, use the appropriate method on the number to convert it to the primitive type requested.\n\t * @param mv the method visitor into which instructions should be inserted\n\t * @param targetDescriptor the primitive type desired as output\n\t * @param stackDescriptor the descriptor of the type on top of the stack\n\t */\n\tpublic static void insertUnboxNumberInsns(\n\t\t\tMethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor) {\n\n\t\tif (stackDescriptor == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (targetDescriptor) {\n\t\t\tcase 'D' -> {\n\t\t\t\tif (stackDescriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Number\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Number\", \"doubleValue\", \"()D\", false);\n\t\t\t}\n\t\t\tcase 'F' -> {\n\t\t\t\tif (stackDescriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Number\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Number\", \"floatValue\", \"()F\", false);\n\t\t\t}\n\t\t\tcase 'J' -> {\n\t\t\t\tif (stackDescriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Number\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Number\", \"longValue\", \"()J\", false);\n\t\t\t}\n\t\t\tcase 'I' -> {\n\t\t\t\tif (stackDescriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Number\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Number\", \"intValue\", \"()I\", false);\n\t\t\t}\n\t\t\t// does not handle Z, B, C, S\n\t\t\tdefault ->\n\t\t\t\tthrow new IllegalArgumentException(\"Unboxing should not be attempted for descriptor '\" + targetDescriptor + \"'\");\n\t\t}\n\t}\n\n\t/**\n\t * Insert any necessary numeric conversion bytecodes based upon what is on the\n\t * stack and the desired target type.\n\t * @param mv the method visitor into which instructions should be placed\n\t * @param targetDescriptor the (primitive) descriptor of the target type\n\t * @param stackDescriptor the descriptor of the operand on top of the stack\n\t */\n\tpublic static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {\n\t\tif (!CodeFlow.isPrimitive(stackDescriptor)) {\n\t\t\treturn;\n\t\t}\n\t\tchar stackTop = stackDescriptor.charAt(0);\n\t\tswitch (stackTop){\n\t\t\tcase 'I', 'B', 'S', 'C' -> {\n\t\t\t\tswitch (targetDescriptor) {\n\t\t\t\t\tcase 'D' -> mv.visitInsn(I2D);\n\t\t\t\t\tcase 'F' -> mv.visitInsn(I2F);\n\t\t\t\t\tcase 'J' -> mv.visitInsn(I2L);\n\t\t\t\t\tcase 'I' -> { /* no-op */ }\n\t\t\t\t\tdefault ->\n\t\t\t\t\t\tthrow new IllegalStateException(\"Cannot get from \" + stackTop + \" to \" + targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 'J' -> {\n\t\t\t\tswitch (targetDescriptor) {\n\t\t\t\t\tcase 'D' -> mv.visitInsn(L2D);\n\t\t\t\t\tcase 'F' -> mv.visitInsn(L2F);\n\t\t\t\t\tcase 'J' -> { /* no-op */ }\n\t\t\t\t\tcase 'I' -> mv.visitInsn(L2I);\n\t\t\t\t\tdefault ->\n\t\t\t\t\t\tthrow new IllegalStateException(\"Cannot get from \" + stackTop + \" to \" + targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 'F' -> {\n\t\t\t\tswitch (targetDescriptor) {\n\t\t\t\t\tcase 'D' -> mv.visitInsn(F2D);\n\t\t\t\t\tcase 'F' -> { /* no-op */ }\n\t\t\t\t\tcase 'J' -> mv.visitInsn(F2L);\n\t\t\t\t\tcase 'I' -> mv.visitInsn(F2I);\n\t\t\t\t\tdefault ->\n\t\t\t\t\t\tthrow new IllegalStateException(\"Cannot get from \" + stackTop + \" to \" + targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 'D' -> {\n\t\t\t\tswitch (targetDescriptor) {\n\t\t\t\t\tcase 'D' -> { /* no-op */ }\n\t\t\t\t\tcase 'F' -> mv.visitInsn(D2F);\n\t\t\t\t\tcase 'J' -> mv.visitInsn(D2L);\n\t\t\t\t\tcase 'I' -> mv.visitInsn(D2I);\n\t\t\t\t\tdefault ->\n\t\t\t\t\t\tthrow new IllegalStateException(\"Cannot get from \" + stackDescriptor + \" to \" + targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Create the JVM signature descriptor for a method. This consists of the descriptors\n\t * for the method parameters surrounded with parentheses, followed by the\n\t * descriptor for the return type. Note the descriptors here are JVM descriptors,\n\t * unlike the other descriptor forms the compiler is using which do not include the\n\t * trailing semicolon.\n\t * @param method the method\n\t * @return a String signature descriptor (e.g. \"(ILjava/lang/String;)V\")\n\t */\n\tpublic static String createSignatureDescriptor(Method method) {\n\t\tClass<?>[] params = method.getParameterTypes();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append('(');\n\t\tfor (Class<?> param : params) {\n\t\t\tsb.append(toJvmDescriptor(param));\n\t\t}\n\t\tsb.append(')');\n\t\tsb.append(toJvmDescriptor(method.getReturnType()));\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * Create the JVM signature descriptor for a constructor. This consists of the\n\t * descriptors for the constructor parameters surrounded with parentheses, followed by\n\t * the descriptor for the return type, which is always \"V\". Note the\n\t * descriptors here are JVM descriptors, unlike the other descriptor forms the\n\t * compiler is using which do not include the trailing semicolon.\n\t * @param ctor the constructor\n\t * @return a String signature descriptor (e.g. \"(ILjava/lang/String;)V\")\n\t */\n\tpublic static String createSignatureDescriptor(Constructor<?> ctor) {\n\t\tClass<?>[] params = ctor.getParameterTypes();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append('(');\n\t\tfor (Class<?> param : params) {\n\t\t\tsb.append(toJvmDescriptor(param));\n\t\t}\n\t\tsb.append(\")V\");\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * Determine the JVM descriptor for a specified class. Unlike the other descriptors\n\t * used in the compilation process, this is the one the JVM wants, so this one\n\t * includes any necessary trailing semicolon (e.g. Ljava/lang/String; rather than\n\t * Ljava/lang/String)\n\t * @param clazz a class\n\t * @return the JVM descriptor for the class\n\t */\n\tpublic static String toJvmDescriptor(Class<?> clazz) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif (clazz.isArray()) {\n\t\t\twhile (clazz.isArray()) {\n\t\t\t\tsb.append('[');\n\t\t\t\tclazz = clazz.getComponentType();\n\t\t\t}\n\t\t}\n\t\tif (clazz.isPrimitive()) {\n\t\t\tif (clazz == Boolean.TYPE) {\n\t\t\t\tsb.append('Z');\n\t\t\t}\n\t\t\telse if (clazz == Byte.TYPE) {\n\t\t\t\tsb.append('B');\n\t\t\t}\n\t\t\telse if (clazz == Character.TYPE) {\n\t\t\t\tsb.append('C');\n\t\t\t}\n\t\t\telse if (clazz == Double.TYPE) {\n\t\t\t\tsb.append('D');\n\t\t\t}\n\t\t\telse if (clazz == Float.TYPE) {\n\t\t\t\tsb.append('F');\n\t\t\t}\n\t\t\telse if (clazz == Integer.TYPE) {\n\t\t\t\tsb.append('I');\n\t\t\t}\n\t\t\telse if (clazz == Long.TYPE) {\n\t\t\t\tsb.append('J');\n\t\t\t}\n\t\t\telse if (clazz == Short.TYPE) {\n\t\t\t\tsb.append('S');\n\t\t\t}\n\t\t\telse if (clazz == Void.TYPE) {\n\t\t\t\tsb.append('V');\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsb.append('L');\n\t\t\tsb.append(clazz.getName().replace('.', '/'));\n\t\t\tsb.append(';');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * Determine the descriptor for an object instance (or {@code null}).\n\t * @param value an object (possibly {@code null})\n\t * @return the type descriptor for the object\n\t * (descriptor is \"Ljava/lang/Object\" for {@code null} value)\n\t */\n\tpublic static String toDescriptorFromObject(@Nullable Object value) {\n\t\tif (value == null) {\n\t\t\treturn \"Ljava/lang/Object\";\n\t\t}\n\t\telse {\n\t\t\treturn toDescriptor(value.getClass());\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether the descriptor is for a boolean primitive or boolean reference type.\n\t * @param descriptor type descriptor\n\t * @return {@code true} if the descriptor is boolean compatible\n\t */\n\tpublic static boolean isBooleanCompatible(@Nullable String descriptor) {\n\t\treturn (descriptor != null && (descriptor.equals(\"Z\") || descriptor.equals(\"Ljava/lang/Boolean\")));\n\t}\n\n\t/**\n\t * Determine whether the descriptor is for a primitive type.\n\t * @param descriptor type descriptor\n\t * @return {@code true} if a primitive type\n\t */\n\tpublic static boolean isPrimitive(@Nullable String descriptor) {\n\t\treturn (descriptor != null && descriptor.length() == 1);\n\t}\n\n\t/**\n\t * Determine whether the descriptor is for a primitive array (e.g. \"[[I\").\n\t * @param descriptor the descriptor for a possible primitive array\n\t * @return {@code true} if the descriptor a primitive array\n\t */\n\tpublic static boolean isPrimitiveArray(@Nullable String descriptor) {\n\t\tif (descriptor == null) {\n\t\t\treturn false;\n\t\t}\n\t\tboolean primitive = true;\n\t\tfor (int i = 0, max = descriptor.length(); i < max; i++) {\n\t\t\tchar ch = descriptor.charAt(i);\n\t\t\tif (ch == '[') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprimitive = (ch != 'L');\n\t\t\tbreak;\n\t\t}\n\t\treturn primitive;\n\t}\n\n\t/**\n\t * Determine whether boxing/unboxing can get from one type to the other.\n\t * <p>Assumes at least one of the types is in boxed form (i.e. single char descriptor).\n\t * @return {@code true} if it is possible to get (via boxing) from one descriptor to the other\n\t */\n\tpublic static boolean areBoxingCompatible(String desc1, String desc2) {\n\t\tif (desc1.equals(desc2)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (desc1.length() == 1) {\n\t\t\treturn checkPairs(desc1, desc2);\n\t\t}\n\t\telse if (desc2.length() == 1) {\n\t\t\treturn checkPairs(desc2, desc1);\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static boolean checkPairs(String desc1, String desc2) {\n\t\treturn switch (desc1) {\n\t\t\tcase \"Z\" -> desc2.equals(\"Ljava/lang/Boolean\");\n\t\t\tcase \"D\" -> desc2.equals(\"Ljava/lang/Double\");\n\t\t\tcase \"F\" -> desc2.equals(\"Ljava/lang/Float\");\n\t\t\tcase \"I\" -> desc2.equals(\"Ljava/lang/Integer\");\n\t\t\tcase \"J\" -> desc2.equals(\"Ljava/lang/Long\");\n\t\t\tdefault -> false;\n\t\t};\n\t}\n\n\t/**\n\t * Determine if the supplied descriptor is for a supported number type or boolean. The\n\t * compilation process only (currently) supports certain number types. These are\n\t * double, float, long and int.\n\t * @param descriptor the descriptor for a type\n\t * @return {@code true} if the descriptor is for a supported numeric type or boolean\n\t */\n\tpublic static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor) {\n\t\tif (descriptor == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (\"Z\".equals(descriptor) || descriptor.equals(\"Ljava/lang/Boolean\"));\n\t}\n\n\t/**\n\t * Determine if the supplied descriptor is for a supported number. The compilation\n\t * process only (currently) supports certain number types. These are double, float,\n\t * long and int.\n\t * @param descriptor the descriptor for a type\n\t * @return {@code true} if the descriptor is for a supported numeric type\n\t */\n\tpublic static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor) {\n\t\tif (descriptor == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (descriptor.length() == 1) {\n\t\t\treturn \"DFIJ\".contains(descriptor);\n\t\t}\n\t\tif (descriptor.startsWith(\"Ljava/lang/\")) {\n\t\t\tString name = descriptor.substring(\"Ljava/lang/\".length());\n\t\t\treturn (name.equals(\"Double\") || name.equals(\"Float\") || name.equals(\"Integer\") || name.equals(\"Long\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine whether the given number is to be considered as an integer\n\t * for the purposes of a numeric operation at the bytecode level.\n\t * @param number the number to check\n\t * @return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte}\n\t */\n\tpublic static boolean isIntegerForNumericOp(Number number) {\n\t\treturn (number instanceof Integer || number instanceof Short || number instanceof Byte);\n\t}\n\n\t/**\n\t * Convert a type descriptor to the single character primitive descriptor.\n\t * @param descriptor a descriptor for a type that should have a primitive representation\n\t * @return the single character descriptor for a primitive input descriptor\n\t */\n\tpublic static char toPrimitiveTargetDesc(String descriptor) {\n\t\tif (descriptor.length() == 1) {\n\t\t\treturn descriptor.charAt(0);\n\t\t}\n\t\treturn switch (descriptor) {\n\t\t\tcase \"Ljava/lang/Double\" -> 'D';\n\t\t\tcase \"Ljava/lang/Float\" -> 'F';\n\t\t\tcase \"Ljava/lang/Integer\" -> 'I';\n\t\t\tcase \"Ljava/lang/Long\" -> 'J';\n\t\t\tcase \"Ljava/lang/Boolean\" -> 'Z';\n\t\t\tcase \"Ljava/lang/Character\" -> 'C';\n\t\t\tcase \"Ljava/lang/Byte\" -> 'B';\n\t\t\tcase \"Ljava/lang/Short\" -> 'S';\n\t\t\tdefault -> throw new IllegalStateException(\"No primitive for '\" + descriptor + \"'\");\n\t\t};\n\t}\n\n\t/**\n\t * Insert the appropriate CHECKCAST instruction for the supplied descriptor.\n\t * @param mv the method visitor into which the instruction should be inserted\n\t * @param descriptor the descriptor of the type to cast to\n\t */\n\tpublic static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor) {\n\t\tif (descriptor != null && descriptor.length() != 1) {\n\t\t\tif (descriptor.charAt(0) == '[') {\n\t\t\t\tif (isPrimitiveArray(descriptor)) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor + \";\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!descriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\t// This is chopping off the 'L' to leave us with \"java/lang/String\"\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor.substring(1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Determine the appropriate boxing instruction for a specific type (if it needs\n\t * boxing) and insert the instruction into the supplied visitor.\n\t * @param mv the method visitor for the new instructions\n\t * @param descriptor the descriptor of a type that may or may not need boxing\n\t */\n\tpublic static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor) {\n\t\tif (descriptor != null && descriptor.length() == 1) {\n\t\t\tinsertBoxIfNecessary(mv, descriptor.charAt(0));\n\t\t}\n\t}\n\n\t/**\n\t * Determine the appropriate boxing instruction for a specific type (if it needs\n\t * boxing) and insert the instruction into the supplied visitor.\n\t * @param mv the method visitor for the new instructions\n\t * @param ch the descriptor of the type that might need boxing\n\t */\n\tpublic static void insertBoxIfNecessary(MethodVisitor mv, char ch) {\n\t\tswitch (ch) {\n\t\t\tcase 'Z' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Boolean\", \"valueOf\", \"(Z)Ljava/lang/Boolean;\", false);\n\t\t\tcase 'B' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Byte\", \"valueOf\", \"(B)Ljava/lang/Byte;\", false);\n\t\t\tcase 'C' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Character\", \"valueOf\", \"(C)Ljava/lang/Character;\", false);\n\t\t\tcase 'D' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Double\", \"valueOf\", \"(D)Ljava/lang/Double;\", false);\n\t\t\tcase 'F' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Float\", \"valueOf\", \"(F)Ljava/lang/Float;\", false);\n\t\t\tcase 'I' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Integer\", \"valueOf\", \"(I)Ljava/lang/Integer;\", false);\n\t\t\tcase 'J' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Long\", \"valueOf\", \"(J)Ljava/lang/Long;\", false);\n\t\t\tcase 'S' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Short\", \"valueOf\", \"(S)Ljava/lang/Short;\", false);\n\t\t\tcase 'L', 'V', '[' -> {\n\t\t\t\t// no box needed\n\t\t\t}\n\t\t\tdefault -> throw new IllegalArgumentException(\"Boxing should not be attempted for descriptor '\" + ch + \"'\");\n\t\t}\n\t}\n\n\t/**\n\t * Deduce the descriptor for a type. Descriptors are like JVM type names but missing the\n\t * trailing ';' so for Object the descriptor is \"Ljava/lang/Object\" for int it is \"I\".\n\t * @param type the type (may be primitive) for which to determine the descriptor\n\t * @return the descriptor\n\t */\n\tpublic static String toDescriptor(Class<?> type) {\n\t\tString name = type.getName();\n\t\tif (type.isPrimitive()) {\n\t\t\tswitch (name.length()) {\n\t\t\t\tcase 3:\n\t\t\t\t\treturn \"I\";\n\t\t\t\tcase 4:\n\t\t\t\t\treturn switch (name) {\n\t\t\t\t\t\tcase \"byte\" -> \"B\";\n\t\t\t\t\t\tcase \"char\" -> \"C\";\n\t\t\t\t\t\tcase \"long\" -> \"J\";\n\t\t\t\t\t\tcase \"void\" -> \"V\";\n\t\t\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unknown primitive type: \" + name);\n\t\t\t\t\t};\n\t\t\t\tcase 5:\n\t\t\t\t\tif (name.equals(\"float\")) {\n\t\t\t\t\t\treturn \"F\";\n\t\t\t\t\t}\n\t\t\t\t\telse if (name.equals(\"short\")) {\n\t\t\t\t\t\treturn \"S\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tif (name.equals(\"double\")) {\n\t\t\t\t\t\treturn \"D\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tif (name.equals(\"boolean\")) {\n\t\t\t\t\t\treturn \"Z\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: throw new IllegalArgumentException(\"Unknown primitive type: \" + name);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (name.charAt(0) != '[') {\n\t\t\t\treturn \"L\" + type.getName().replace('.', '/');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (name.endsWith(\";\")) {\n\t\t\t\t\treturn name.substring(0, name.length() - 1).replace('.', '/');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn name;  // array has primitive component type\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Create an array of descriptors representing the parameter types for the supplied\n\t * method. Returns a zero sized array if there are no parameters.\n\t * @param method a Method\n\t * @return a String array of descriptors, one entry for each method parameter\n\t */\n\tpublic static String[] toParamDescriptors(Method method) {\n\t\treturn toDescriptors(method.getParameterTypes());\n\t}\n\n\t/**\n\t * Create an array of descriptors representing the parameter types for the supplied\n\t * constructor. Returns a zero sized array if there are no parameters.\n\t * @param ctor a Constructor\n\t * @return a String array of descriptors, one entry for each constructor parameter\n\t */\n\tpublic static String[] toParamDescriptors(Constructor<?> ctor) {\n\t\treturn toDescriptors(ctor.getParameterTypes());\n\t}\n\n\t/**\n\t * Create an array of descriptors from an array of classes.\n\t * @param types the input array of classes\n\t * @return an array of descriptors\n\t */\n\tpublic static String[] toDescriptors(Class<?>[] types) {\n\t\tint typesCount = types.length;\n\t\tString[] descriptors = new String[typesCount];\n\t\tfor (int p = 0; p < typesCount; p++) {\n\t\t\tdescriptors[p] = toDescriptor(types[p]);\n\t\t}\n\t\treturn descriptors;\n\t}\n\n\t/**\n\t * Create the optimal instruction for loading a number on the stack.\n\t * @param mv where to insert the bytecode\n\t * @param value the value to be loaded\n\t */\n\tpublic static void insertOptimalLoad(MethodVisitor mv, int value) {\n\t\tif (value < 6) {\n\t\t\tmv.visitInsn(ICONST_0+value);\n\t\t}\n\t\telse if (value < Byte.MAX_VALUE) {\n\t\t\tmv.visitIntInsn(BIPUSH, value);\n\t\t}\n\t\telse if (value < Short.MAX_VALUE) {\n\t\t\tmv.visitIntInsn(SIPUSH, value);\n\t\t}\n\t\telse {\n\t\t\tmv.visitLdcInsn(value);\n\t\t}\n\t}\n\n\t/**\n\t * Produce appropriate bytecode to store a stack item in an array. The\n\t * instruction to use varies depending on whether the type\n\t * is a primitive or reference type.\n\t * @param mv where to insert the bytecode\n\t * @param arrayElementType the type of the array elements\n\t */\n\tpublic static void insertArrayStore(MethodVisitor mv, String arrayElementType) {\n\t\tif (arrayElementType.length() == 1) {\n\t\t\tswitch (arrayElementType.charAt(0)) {\n\t\t\t\tcase 'B', 'Z' -> mv.visitInsn(BASTORE);\n\t\t\t\tcase 'I' -> mv.visitInsn(IASTORE);\n\t\t\t\tcase 'J' -> mv.visitInsn(LASTORE);\n\t\t\t\tcase 'F' -> mv.visitInsn(FASTORE);\n\t\t\t\tcase 'D' -> mv.visitInsn(DASTORE);\n\t\t\t\tcase 'C' -> mv.visitInsn(CASTORE);\n\t\t\t\tcase 'S' -> mv.visitInsn(SASTORE);\n\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected array type \" + arrayElementType.charAt(0));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmv.visitInsn(AASTORE);\n\t\t}\n\t}\n\n\t/**\n\t * Determine the appropriate T tag to use for the NEWARRAY bytecode.\n\t * @param arrayType the array primitive component type\n\t * @return the T tag to use for NEWARRAY\n\t */\n\tpublic static int arrayCodeFor(String arrayType) {\n\t\treturn switch (arrayType.charAt(0)) {\n\t\t\tcase 'I' -> T_INT;\n\t\t\tcase 'J' -> T_LONG;\n\t\t\tcase 'F' -> T_FLOAT;\n\t\t\tcase 'D' -> T_DOUBLE;\n\t\t\tcase 'B' -> T_BYTE;\n\t\t\tcase 'C' -> T_CHAR;\n\t\t\tcase 'S' -> T_SHORT;\n\t\t\tcase 'Z' -> T_BOOLEAN;\n\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected array type \" + arrayType.charAt(0));\n\t\t};\n\t}\n\n\t/**\n\t * Return if the supplied array type has a core component reference type.\n\t */\n\tpublic static boolean isReferenceTypeArray(String arrayType) {\n\t\tint length = arrayType.length();\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tchar ch = arrayType.charAt(i);\n\t\t\tif (ch == '[') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn (ch == 'L');\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Produce the correct bytecode to build an array. The opcode to use and the\n\t * signature to pass along with the opcode can vary depending on the signature\n\t * of the array type.\n\t * @param mv the method visitor into which code should be inserted\n\t * @param size the size of the array\n\t * @param arrayType the type of the array\n\t */\n\tpublic static void insertNewArrayCode(MethodVisitor mv, int size, String arrayType) {\n\t\tinsertOptimalLoad(mv, size);\n\t\tif (arrayType.length() == 1) {\n\t\t\tmv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arrayType));\n\t\t}\n\t\telse {\n\t\t\tif (arrayType.charAt(0) == '[') {\n\t\t\t\t// Handling the nested array case here.\n\t\t\t\t// If vararg is [[I then we want [I and not [I;\n\t\t\t\tif (CodeFlow.isReferenceTypeArray(arrayType)) {\n\t\t\t\t\tmv.visitTypeInsn(ANEWARRAY, arrayType + \";\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmv.visitTypeInsn(ANEWARRAY, arrayType);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmv.visitTypeInsn(ANEWARRAY, arrayType.substring(1));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * For use in mathematical operators, handles converting from a (possibly boxed)\n\t * number on the stack to a primitive numeric type.\n\t * <p>For example, from an Integer to a double, just need to call 'Number.doubleValue()'\n\t * but from an int to a double, need to use the bytecode 'i2d'.\n\t * @param mv the method visitor when instructions should be appended\n\t * @param stackDescriptor a descriptor of the operand on the stack\n\t * @param targetDescriptor a primitive type descriptor\n\t */\n\tpublic static void insertNumericUnboxOrPrimitiveTypeCoercion(\n\t\t\tMethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor) {\n\n\t\tif (!CodeFlow.isPrimitive(stackDescriptor)) {\n\t\t\tCodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor);\n\t\t}\n\t\telse {\n\t\t\tCodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor);\n\t\t}\n\t}\n\n\tpublic static String toBoxedDescriptor(String primitiveDescriptor) {\n\t\treturn switch (primitiveDescriptor.charAt(0)) {\n\t\t\tcase 'I' -> \"Ljava/lang/Integer\";\n\t\t\tcase 'J' -> \"Ljava/lang/Long\";\n\t\t\tcase 'F' -> \"Ljava/lang/Float\";\n\t\t\tcase 'D' -> \"Ljava/lang/Double\";\n\t\t\tcase 'B' -> \"Ljava/lang/Byte\";\n\t\t\tcase 'C' -> \"Ljava/lang/Character\";\n\t\t\tcase 'S' -> \"Ljava/lang/Short\";\n\t\t\tcase 'Z' -> \"Ljava/lang/Boolean\";\n\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected non primitive descriptor \" + primitiveDescriptor);\n\t\t};\n\t}\n\n\n\t/**\n\t * Interface used to generate fields.\n\t */\n\t@FunctionalInterface\n\tpublic interface FieldAdder {\n\n\t\tvoid generateField(ClassWriter cw, CodeFlow codeflow);\n\t}\n\n\n\t/**\n\t * Interface used to generate {@code clinit} static initializer blocks.\n\t */\n\t@FunctionalInterface\n\tpublic interface ClinitAdder {\n\n\t\tvoid generateCode(MethodVisitor mv, CodeFlow codeflow);\n\t}\n\n}"
  },
  "org.springframework.expression.spel.CodeFlow#areBoxingCompatible(desc1,desc2)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether boxing/unboxing can get from one type to the other.\n\t * <p>Assumes at least one of the types is in boxed form (i.e. single char descriptor).\n\t * @return {@code true} if it is possible to get (via boxing) from one descriptor to the other\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "desc1",
      "desc2"
    ],
    "position": {
      "column": 1,
      "line": 552
    },
    "return": "boolean",
    "signature": "public boolean areBoxingCompatible(String desc1, String desc2)",
    "source_code": "\tpublic static boolean areBoxingCompatible(String desc1, String desc2) {\n\t\tif (desc1.equals(desc2)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (desc1.length() == 1) {\n\t\t\treturn checkPairs(desc1, desc2);\n\t\t}\n\t\telse if (desc2.length() == 1) {\n\t\t\treturn checkPairs(desc2, desc1);\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#arrayCodeFor(arrayType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the appropriate T tag to use for the NEWARRAY bytecode.\n\t * @param arrayType the array primitive component type\n\t * @return the T tag to use for NEWARRAY\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "arrayType"
    ],
    "position": {
      "column": 1,
      "line": 854
    },
    "return": "int",
    "signature": "public int arrayCodeFor(String arrayType)",
    "source_code": "\tpublic static int arrayCodeFor(String arrayType) {\n\t\treturn switch (arrayType.charAt(0)) {\n\t\t\tcase 'I' -> T_INT;\n\t\t\tcase 'J' -> T_LONG;\n\t\t\tcase 'F' -> T_FLOAT;\n\t\t\tcase 'D' -> T_DOUBLE;\n\t\t\tcase 'B' -> T_BYTE;\n\t\t\tcase 'C' -> T_CHAR;\n\t\t\tcase 'S' -> T_SHORT;\n\t\t\tcase 'Z' -> T_BOOLEAN;\n\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected array type \" + arrayType.charAt(0));\n\t\t};\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#createSignatureDescriptor(ctor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the JVM signature descriptor for a constructor. This consists of the\n\t * descriptors for the constructor parameters surrounded with parentheses, followed by\n\t * the descriptor for the return type, which is always \"V\". Note the\n\t * descriptors here are JVM descriptors, unlike the other descriptor forms the\n\t * compiler is using which do not include the trailing semicolon.\n\t * @param ctor the constructor\n\t * @return a String signature descriptor (e.g. \"(ILjava/lang/String;)V\")\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ctor"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "String",
    "signature": "public String createSignatureDescriptor(Constructor<?> ctor)",
    "source_code": "\tpublic static String createSignatureDescriptor(Constructor<?> ctor) {\n\t\tClass<?>[] params = ctor.getParameterTypes();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append('(');\n\t\tfor (Class<?> param : params) {\n\t\t\tsb.append(toJvmDescriptor(param));\n\t\t}\n\t\tsb.append(\")V\");\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#createSignatureDescriptor(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the JVM signature descriptor for a method. This consists of the descriptors\n\t * for the method parameters surrounded with parentheses, followed by the\n\t * descriptor for the return type. Note the descriptors here are JVM descriptors,\n\t * unlike the other descriptor forms the compiler is using which do not include the\n\t * trailing semicolon.\n\t * @param method the method\n\t * @return a String signature descriptor (e.g. \"(ILjava/lang/String;)V\")\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "String",
    "signature": "public String createSignatureDescriptor(Method method)",
    "source_code": "\tpublic static String createSignatureDescriptor(Method method) {\n\t\tClass<?>[] params = method.getParameterTypes();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append('(');\n\t\tfor (Class<?> param : params) {\n\t\t\tsb.append(toJvmDescriptor(param));\n\t\t}\n\t\tsb.append(')');\n\t\tsb.append(toJvmDescriptor(method.getReturnType()));\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#enterCompilationScope()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Enter a new compilation scope, usually due to nested expression evaluation. For\n\t * example when the arguments for a method invocation expression are being evaluated,\n\t * each argument will be evaluated in a new scope.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "public void enterCompilationScope()",
    "source_code": "\tpublic void enterCompilationScope() {\n\t\tthis.compilationScopes.push(new ArrayList<>());\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#exitCompilationScope()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Exit a compilation scope, usually after a nested expression has been evaluated. For\n\t * example after an argument for a method invocation has been evaluated this method\n\t * returns us to the previous (outer) scope.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void exitCompilationScope()",
    "source_code": "\tpublic void exitCompilationScope() {\n\t\tthis.compilationScopes.pop();\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#finish()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Called after the main expression evaluation method has been generated, this\n\t * method will call back any registered FieldAdders or ClinitAdders to add any\n\t * extra information to the class representing the compiled expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "void",
    "signature": "public void finish()",
    "source_code": "\tpublic void finish() {\n\t\tif (this.fieldAdders != null) {\n\t\t\tfor (FieldAdder fieldAdder : this.fieldAdders) {\n\t\t\t\tfieldAdder.generateField(this.classWriter, this);\n\t\t\t}\n\t\t}\n\t\tif (this.clinitAdders != null) {\n\t\t\tMethodVisitor mv = this.classWriter.visitMethod(ACC_PUBLIC | ACC_STATIC, \"<clinit>\", \"()V\", null, null);\n\t\t\tmv.visitCode();\n\t\t\tthis.nextFreeVariableId = 0;  // to 0 because there is no 'this' in a clinit\n\t\t\tfor (ClinitAdder clinitAdder : this.clinitAdders) {\n\t\t\t\tclinitAdder.generateCode(mv, this);\n\t\t\t}\n\t\t\tmv.visitInsn(RETURN);\n\t\t\tmv.visitMaxs(0,0);  // not supplied due to COMPUTE_MAXS\n\t\t\tmv.visitEnd();\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#getClassName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "String",
    "signature": "public String getClassName()",
    "source_code": "\tpublic String getClassName() {\n\t\treturn this.className;\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#insertAnyNecessaryTypeConversionBytecodes(mv,targetDescriptor,stackDescriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Insert any necessary numeric conversion bytecodes based upon what is on the\n\t * stack and the desired target type.\n\t * @param mv the method visitor into which instructions should be placed\n\t * @param targetDescriptor the (primitive) descriptor of the target type\n\t * @param stackDescriptor the descriptor of the operand on top of the stack\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "targetDescriptor",
      "stackDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "void",
    "signature": "public void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor)",
    "source_code": "\tpublic static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {\n\t\tif (!CodeFlow.isPrimitive(stackDescriptor)) {\n\t\t\treturn;\n\t\t}\n\t\tchar stackTop = stackDescriptor.charAt(0);\n\t\tswitch (stackTop){\n\t\t\tcase 'I', 'B', 'S', 'C' -> {\n\t\t\t\tswitch (targetDescriptor) {\n\t\t\t\t\tcase 'D' -> mv.visitInsn(I2D);\n\t\t\t\t\tcase 'F' -> mv.visitInsn(I2F);\n\t\t\t\t\tcase 'J' -> mv.visitInsn(I2L);\n\t\t\t\t\tcase 'I' -> { /* no-op */ }\n\t\t\t\t\tdefault ->\n\t\t\t\t\t\tthrow new IllegalStateException(\"Cannot get from \" + stackTop + \" to \" + targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 'J' -> {\n\t\t\t\tswitch (targetDescriptor) {\n\t\t\t\t\tcase 'D' -> mv.visitInsn(L2D);\n\t\t\t\t\tcase 'F' -> mv.visitInsn(L2F);\n\t\t\t\t\tcase 'J' -> { /* no-op */ }\n\t\t\t\t\tcase 'I' -> mv.visitInsn(L2I);\n\t\t\t\t\tdefault ->\n\t\t\t\t\t\tthrow new IllegalStateException(\"Cannot get from \" + stackTop + \" to \" + targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 'F' -> {\n\t\t\t\tswitch (targetDescriptor) {\n\t\t\t\t\tcase 'D' -> mv.visitInsn(F2D);\n\t\t\t\t\tcase 'F' -> { /* no-op */ }\n\t\t\t\t\tcase 'J' -> mv.visitInsn(F2L);\n\t\t\t\t\tcase 'I' -> mv.visitInsn(F2I);\n\t\t\t\t\tdefault ->\n\t\t\t\t\t\tthrow new IllegalStateException(\"Cannot get from \" + stackTop + \" to \" + targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 'D' -> {\n\t\t\t\tswitch (targetDescriptor) {\n\t\t\t\t\tcase 'D' -> { /* no-op */ }\n\t\t\t\t\tcase 'F' -> mv.visitInsn(D2F);\n\t\t\t\t\tcase 'J' -> mv.visitInsn(D2L);\n\t\t\t\t\tcase 'I' -> mv.visitInsn(D2I);\n\t\t\t\t\tdefault ->\n\t\t\t\t\t\tthrow new IllegalStateException(\"Cannot get from \" + stackDescriptor + \" to \" + targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#insertArrayStore(mv,arrayElementType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Produce appropriate bytecode to store a stack item in an array. The\n\t * instruction to use varies depending on whether the type\n\t * is a primitive or reference type.\n\t * @param mv where to insert the bytecode\n\t * @param arrayElementType the type of the array elements\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "arrayElementType"
    ],
    "position": {
      "column": 1,
      "line": 831
    },
    "return": "void",
    "signature": "public void insertArrayStore(MethodVisitor mv, String arrayElementType)",
    "source_code": "\tpublic static void insertArrayStore(MethodVisitor mv, String arrayElementType) {\n\t\tif (arrayElementType.length() == 1) {\n\t\t\tswitch (arrayElementType.charAt(0)) {\n\t\t\t\tcase 'B', 'Z' -> mv.visitInsn(BASTORE);\n\t\t\t\tcase 'I' -> mv.visitInsn(IASTORE);\n\t\t\t\tcase 'J' -> mv.visitInsn(LASTORE);\n\t\t\t\tcase 'F' -> mv.visitInsn(FASTORE);\n\t\t\t\tcase 'D' -> mv.visitInsn(DASTORE);\n\t\t\t\tcase 'C' -> mv.visitInsn(CASTORE);\n\t\t\t\tcase 'S' -> mv.visitInsn(SASTORE);\n\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected array type \" + arrayElementType.charAt(0));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmv.visitInsn(AASTORE);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#insertBoxIfNecessary(mv,ch)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the appropriate boxing instruction for a specific type (if it needs\n\t * boxing) and insert the instruction into the supplied visitor.\n\t * @param mv the method visitor for the new instructions\n\t * @param ch the descriptor of the type that might need boxing\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "ch"
    ],
    "position": {
      "column": 1,
      "line": 688
    },
    "return": "void",
    "signature": "public void insertBoxIfNecessary(MethodVisitor mv, char ch)",
    "source_code": "\tpublic static void insertBoxIfNecessary(MethodVisitor mv, char ch) {\n\t\tswitch (ch) {\n\t\t\tcase 'Z' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Boolean\", \"valueOf\", \"(Z)Ljava/lang/Boolean;\", false);\n\t\t\tcase 'B' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Byte\", \"valueOf\", \"(B)Ljava/lang/Byte;\", false);\n\t\t\tcase 'C' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Character\", \"valueOf\", \"(C)Ljava/lang/Character;\", false);\n\t\t\tcase 'D' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Double\", \"valueOf\", \"(D)Ljava/lang/Double;\", false);\n\t\t\tcase 'F' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Float\", \"valueOf\", \"(F)Ljava/lang/Float;\", false);\n\t\t\tcase 'I' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Integer\", \"valueOf\", \"(I)Ljava/lang/Integer;\", false);\n\t\t\tcase 'J' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Long\", \"valueOf\", \"(J)Ljava/lang/Long;\", false);\n\t\t\tcase 'S' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Short\", \"valueOf\", \"(S)Ljava/lang/Short;\", false);\n\t\t\tcase 'L', 'V', '[' -> {\n\t\t\t\t// no box needed\n\t\t\t}\n\t\t\tdefault -> throw new IllegalArgumentException(\"Boxing should not be attempted for descriptor '\" + ch + \"'\");\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#insertBoxIfNecessary(mv,descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the appropriate boxing instruction for a specific type (if it needs\n\t * boxing) and insert the instruction into the supplied visitor.\n\t * @param mv the method visitor for the new instructions\n\t * @param descriptor the descriptor of a type that may or may not need boxing\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 676
    },
    "return": "void",
    "signature": "public void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor)",
    "source_code": "\tpublic static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor) {\n\t\tif (descriptor != null && descriptor.length() == 1) {\n\t\t\tinsertBoxIfNecessary(mv, descriptor.charAt(0));\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#insertCheckCast(mv,descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Insert the appropriate CHECKCAST instruction for the supplied descriptor.\n\t * @param mv the method visitor into which the instruction should be inserted\n\t * @param descriptor the descriptor of the type to cast to\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 651
    },
    "return": "void",
    "signature": "public void insertCheckCast(MethodVisitor mv, @Nullable String descriptor)",
    "source_code": "\tpublic static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor) {\n\t\tif (descriptor != null && descriptor.length() != 1) {\n\t\t\tif (descriptor.charAt(0) == '[') {\n\t\t\t\tif (isPrimitiveArray(descriptor)) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor + \";\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!descriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\t// This is chopping off the 'L' to leave us with \"java/lang/String\"\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor.substring(1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#insertNewArrayCode(mv,size,arrayType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Produce the correct bytecode to build an array. The opcode to use and the\n\t * signature to pass along with the opcode can vary depending on the signature\n\t * of the array type.\n\t * @param mv the method visitor into which code should be inserted\n\t * @param size the size of the array\n\t * @param arrayType the type of the array\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "size",
      "arrayType"
    ],
    "position": {
      "column": 1,
      "line": 891
    },
    "return": "void",
    "signature": "public void insertNewArrayCode(MethodVisitor mv, int size, String arrayType)",
    "source_code": "\tpublic static void insertNewArrayCode(MethodVisitor mv, int size, String arrayType) {\n\t\tinsertOptimalLoad(mv, size);\n\t\tif (arrayType.length() == 1) {\n\t\t\tmv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arrayType));\n\t\t}\n\t\telse {\n\t\t\tif (arrayType.charAt(0) == '[') {\n\t\t\t\t// Handling the nested array case here.\n\t\t\t\t// If vararg is [[I then we want [I and not [I;\n\t\t\t\tif (CodeFlow.isReferenceTypeArray(arrayType)) {\n\t\t\t\t\tmv.visitTypeInsn(ANEWARRAY, arrayType + \";\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmv.visitTypeInsn(ANEWARRAY, arrayType);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmv.visitTypeInsn(ANEWARRAY, arrayType.substring(1));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#insertNumericUnboxOrPrimitiveTypeCoercion(mv,stackDescriptor,targetDescriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * For use in mathematical operators, handles converting from a (possibly boxed)\n\t * number on the stack to a primitive numeric type.\n\t * <p>For example, from an Integer to a double, just need to call 'Number.doubleValue()'\n\t * but from an int to a double, need to use the bytecode 'i2d'.\n\t * @param mv the method visitor when instructions should be appended\n\t * @param stackDescriptor a descriptor of the operand on the stack\n\t * @param targetDescriptor a primitive type descriptor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "stackDescriptor",
      "targetDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 922
    },
    "return": "void",
    "signature": "public void insertNumericUnboxOrPrimitiveTypeCoercion(MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor)",
    "source_code": "\tpublic static void insertNumericUnboxOrPrimitiveTypeCoercion("
  },
  "org.springframework.expression.spel.CodeFlow#insertOptimalLoad(mv,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the optimal instruction for loading a number on the stack.\n\t * @param mv where to insert the bytecode\n\t * @param value the value to be loaded\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 809
    },
    "return": "void",
    "signature": "public void insertOptimalLoad(MethodVisitor mv, int value)",
    "source_code": "\tpublic static void insertOptimalLoad(MethodVisitor mv, int value) {\n\t\tif (value < 6) {\n\t\t\tmv.visitInsn(ICONST_0+value);\n\t\t}\n\t\telse if (value < Byte.MAX_VALUE) {\n\t\t\tmv.visitIntInsn(BIPUSH, value);\n\t\t}\n\t\telse if (value < Short.MAX_VALUE) {\n\t\t\tmv.visitIntInsn(SIPUSH, value);\n\t\t}\n\t\telse {\n\t\t\tmv.visitLdcInsn(value);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#insertUnboxInsns(mv,ch,stackDescriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Insert any necessary cast and value call to convert from a boxed type to a\n\t * primitive value.\n\t * @param mv the method visitor into which instructions should be inserted\n\t * @param ch the primitive type desired as output\n\t * @param stackDescriptor the descriptor of the type on top of the stack\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "ch",
      "stackDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "void",
    "signature": "public void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor)",
    "source_code": "\tpublic static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor) {\n\t\tif (stackDescriptor == null) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (ch) {\n\t\t\tcase 'Z' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Boolean\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Boolean\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Boolean\", \"booleanValue\", \"()Z\", false);\n\t\t\t}\n\t\t\tcase 'B' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Byte\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Byte\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Byte\", \"byteValue\", \"()B\", false);\n\t\t\t}\n\t\t\tcase 'C' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Character\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Character\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Character\", \"charValue\", \"()C\", false);\n\t\t\t}\n\t\t\tcase 'D' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Double\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Double\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Double\", \"doubleValue\", \"()D\", false);\n\t\t\t}\n\t\t\tcase 'F' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Float\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Float\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Float\", \"floatValue\", \"()F\", false);\n\t\t\t}\n\t\t\tcase 'I' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Integer\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Integer\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Integer\", \"intValue\", \"()I\", false);\n\t\t\t}\n\t\t\tcase 'J' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Long\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Long\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Long\", \"longValue\", \"()J\", false);\n\t\t\t}\n\t\t\tcase 'S' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Short\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Short\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Short\", \"shortValue\", \"()S\", false);\n\t\t\t}\n\t\t\tdefault ->\n\t\t\t\tthrow new IllegalArgumentException(\"Unboxing should not be attempted for descriptor '\" + ch + \"'\");\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#insertUnboxNumberInsns(mv,targetDescriptor,stackDescriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * For numbers, use the appropriate method on the number to convert it to the primitive type requested.\n\t * @param mv the method visitor into which instructions should be inserted\n\t * @param targetDescriptor the primitive type desired as output\n\t * @param stackDescriptor the descriptor of the type on top of the stack\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "targetDescriptor",
      "stackDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "void",
    "signature": "public void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor)",
    "source_code": "\tpublic static void insertUnboxNumberInsns("
  },
  "org.springframework.expression.spel.CodeFlow#isBooleanCompatible(descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the descriptor is for a boolean primitive or boolean reference type.\n\t * @param descriptor type descriptor\n\t * @return {@code true} if the descriptor is boolean compatible\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 513
    },
    "return": "boolean",
    "signature": "public boolean isBooleanCompatible(@Nullable String descriptor)",
    "source_code": "\tpublic static boolean isBooleanCompatible(@Nullable String descriptor) {\n\t\treturn (descriptor != null && (descriptor.equals(\"Z\") || descriptor.equals(\"Ljava/lang/Boolean\")));\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#isIntegerForNumericOp(number)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given number is to be considered as an integer\n\t * for the purposes of a numeric operation at the bytecode level.\n\t * @param number the number to check\n\t * @return {@code true} if it is an {@link Integer}, {@link Short} or {@link Byte}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "number"
    ],
    "position": {
      "column": 1,
      "line": 620
    },
    "return": "boolean",
    "signature": "public boolean isIntegerForNumericOp(Number number)",
    "source_code": "\tpublic static boolean isIntegerForNumericOp(Number number) {\n\t\treturn (number instanceof Integer || number instanceof Short || number instanceof Byte);\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#isPrimitive(descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the descriptor is for a primitive type.\n\t * @param descriptor type descriptor\n\t * @return {@code true} if a primitive type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 522
    },
    "return": "boolean",
    "signature": "public boolean isPrimitive(@Nullable String descriptor)",
    "source_code": "\tpublic static boolean isPrimitive(@Nullable String descriptor) {\n\t\treturn (descriptor != null && descriptor.length() == 1);\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#isPrimitiveArray(descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the descriptor is for a primitive array (e.g. \"[[I\").\n\t * @param descriptor the descriptor for a possible primitive array\n\t * @return {@code true} if the descriptor a primitive array\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 531
    },
    "return": "boolean",
    "signature": "public boolean isPrimitiveArray(@Nullable String descriptor)",
    "source_code": "\tpublic static boolean isPrimitiveArray(@Nullable String descriptor) {\n\t\tif (descriptor == null) {\n\t\t\treturn false;\n\t\t}\n\t\tboolean primitive = true;\n\t\tfor (int i = 0, max = descriptor.length(); i < max; i++) {\n\t\t\tchar ch = descriptor.charAt(i);\n\t\t\tif (ch == '[') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprimitive = (ch != 'L');\n\t\t\tbreak;\n\t\t}\n\t\treturn primitive;\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#isPrimitiveOrUnboxableSupportedNumber(descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied descriptor is for a supported number. The compilation\n\t * process only (currently) supports certain number types. These are double, float,\n\t * long and int.\n\t * @param descriptor the descriptor for a type\n\t * @return {@code true} if the descriptor is for a supported numeric type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 600
    },
    "return": "boolean",
    "signature": "public boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor)",
    "source_code": "\tpublic static boolean isPrimitiveOrUnboxableSupportedNumber(@Nullable String descriptor) {\n\t\tif (descriptor == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (descriptor.length() == 1) {\n\t\t\treturn \"DFIJ\".contains(descriptor);\n\t\t}\n\t\tif (descriptor.startsWith(\"Ljava/lang/\")) {\n\t\t\tString name = descriptor.substring(\"Ljava/lang/\".length());\n\t\t\treturn (name.equals(\"Double\") || name.equals(\"Float\") || name.equals(\"Integer\") || name.equals(\"Long\"));\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#isPrimitiveOrUnboxableSupportedNumberOrBoolean(descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied descriptor is for a supported number type or boolean. The\n\t * compilation process only (currently) supports certain number types. These are\n\t * double, float, long and int.\n\t * @param descriptor the descriptor for a type\n\t * @return {@code true} if the descriptor is for a supported numeric type or boolean\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 583
    },
    "return": "boolean",
    "signature": "public boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor)",
    "source_code": "\tpublic static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(@Nullable String descriptor) {\n\t\tif (descriptor == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (isPrimitiveOrUnboxableSupportedNumber(descriptor)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (\"Z\".equals(descriptor) || descriptor.equals(\"Ljava/lang/Boolean\"));\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#isReferenceTypeArray(arrayType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return if the supplied array type has a core component reference type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "arrayType"
    ],
    "position": {
      "column": 1,
      "line": 871
    },
    "return": "boolean",
    "signature": "public boolean isReferenceTypeArray(String arrayType)",
    "source_code": "\tpublic static boolean isReferenceTypeArray(String arrayType) {\n\t\tint length = arrayType.length();\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tchar ch = arrayType.charAt(i);\n\t\t\tif (ch == '[') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn (ch == 'L');\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#lastDescriptor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the descriptor for the item currently on top of the stack (in the current scope).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "String",
    "signature": "public String lastDescriptor()",
    "source_code": "\tpublic String lastDescriptor() {\n\t\treturn CollectionUtils.lastElement(this.compilationScopes.peek());\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#loadEvaluationContext(mv)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Push the bytecode to load the EvaluationContext (the second parameter passed to\n\t * the compiled expression method).\n\t * @param mv the method visitor into which the load instruction should be inserted\n\t * @since 4.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void loadEvaluationContext(MethodVisitor mv)",
    "source_code": "\tpublic void loadEvaluationContext(MethodVisitor mv) {\n\t\tmv.visitVarInsn(ALOAD, 2);\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#loadTarget(mv)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Push the byte code to load the target (i.e. what was passed as the first argument\n\t * to CompiledExpression.getValue(target, context))\n\t * @param mv the method visitor into which the load instruction should be inserted\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void loadTarget(MethodVisitor mv)",
    "source_code": "\tpublic void loadTarget(MethodVisitor mv) {\n\t\tmv.visitVarInsn(ALOAD, 1);\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#nextFieldId()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "int",
    "signature": "public int nextFieldId()",
    "source_code": "\tpublic int nextFieldId() {\n\t\treturn this.nextFieldId++;\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#nextFreeVariableId()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "int",
    "signature": "public int nextFreeVariableId()",
    "source_code": "\tpublic int nextFreeVariableId() {\n\t\treturn this.nextFreeVariableId++;\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#pushDescriptor(descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Record the descriptor for the most recently evaluated expression element.\n\t * @param descriptor type descriptor for most recently evaluated element\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "void",
    "signature": "public void pushDescriptor(@Nullable String descriptor)",
    "source_code": "\tpublic void pushDescriptor(@Nullable String descriptor) {\n\t\tif (descriptor != null) {\n\t\t\tthis.compilationScopes.element().add(descriptor);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#registerNewClinit(clinitAdder)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a ClinitAdder which will add code to the static\n\t * initializer in the generated class to support the code\n\t * produced by an AST node's primary generateCode() method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clinitAdder"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "void",
    "signature": "public void registerNewClinit(ClinitAdder clinitAdder)",
    "source_code": "\tpublic void registerNewClinit(ClinitAdder clinitAdder) {\n\t\tif (this.clinitAdders == null) {\n\t\t\tthis.clinitAdders = new ArrayList<>();\n\t\t}\n\t\tthis.clinitAdders.add(clinitAdder);\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#registerNewField(fieldAdder)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a FieldAdder which will add a new field to the generated\n\t * class to support the code produced by an AST node's primary\n\t * generateCode() method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fieldAdder"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "void",
    "signature": "public void registerNewField(FieldAdder fieldAdder)",
    "source_code": "\tpublic void registerNewField(FieldAdder fieldAdder) {\n\t\tif (this.fieldAdders == null) {\n\t\t\tthis.fieldAdders = new ArrayList<>();\n\t\t}\n\t\tthis.fieldAdders.add(fieldAdder);\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#toBoxedDescriptor(primitiveDescriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "primitiveDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 933
    },
    "return": "String",
    "signature": "public String toBoxedDescriptor(String primitiveDescriptor)",
    "source_code": "\tpublic static String toBoxedDescriptor(String primitiveDescriptor) {\n\t\treturn switch (primitiveDescriptor.charAt(0)) {\n\t\t\tcase 'I' -> \"Ljava/lang/Integer\";\n\t\t\tcase 'J' -> \"Ljava/lang/Long\";\n\t\t\tcase 'F' -> \"Ljava/lang/Float\";\n\t\t\tcase 'D' -> \"Ljava/lang/Double\";\n\t\t\tcase 'B' -> \"Ljava/lang/Byte\";\n\t\t\tcase 'C' -> \"Ljava/lang/Character\";\n\t\t\tcase 'S' -> \"Ljava/lang/Short\";\n\t\t\tcase 'Z' -> \"Ljava/lang/Boolean\";\n\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected non primitive descriptor \" + primitiveDescriptor);\n\t\t};\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#toDescriptor(type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Deduce the descriptor for a type. Descriptors are like JVM type names but missing the\n\t * trailing ';' so for Object the descriptor is \"Ljava/lang/Object\" for int it is \"I\".\n\t * @param type the type (may be primitive) for which to determine the descriptor\n\t * @return the descriptor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 719
    },
    "return": "String",
    "signature": "public String toDescriptor(Class<?> type)",
    "source_code": "\tpublic static String toDescriptor(Class<?> type) {\n\t\tString name = type.getName();\n\t\tif (type.isPrimitive()) {\n\t\t\tswitch (name.length()) {\n\t\t\t\tcase 3:\n\t\t\t\t\treturn \"I\";\n\t\t\t\tcase 4:\n\t\t\t\t\treturn switch (name) {\n\t\t\t\t\t\tcase \"byte\" -> \"B\";\n\t\t\t\t\t\tcase \"char\" -> \"C\";\n\t\t\t\t\t\tcase \"long\" -> \"J\";\n\t\t\t\t\t\tcase \"void\" -> \"V\";\n\t\t\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unknown primitive type: \" + name);\n\t\t\t\t\t};\n\t\t\t\tcase 5:\n\t\t\t\t\tif (name.equals(\"float\")) {\n\t\t\t\t\t\treturn \"F\";\n\t\t\t\t\t}\n\t\t\t\t\telse if (name.equals(\"short\")) {\n\t\t\t\t\t\treturn \"S\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tif (name.equals(\"double\")) {\n\t\t\t\t\t\treturn \"D\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tif (name.equals(\"boolean\")) {\n\t\t\t\t\t\treturn \"Z\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: throw new IllegalArgumentException(\"Unknown primitive type: \" + name);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (name.charAt(0) != '[') {\n\t\t\t\treturn \"L\" + type.getName().replace('.', '/');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (name.endsWith(\";\")) {\n\t\t\t\t\treturn name.substring(0, name.length() - 1).replace('.', '/');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn name;  // array has primitive component type\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"\";\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#toDescriptorFromObject(value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the descriptor for an object instance (or {@code null}).\n\t * @param value an object (possibly {@code null})\n\t * @return the type descriptor for the object\n\t * (descriptor is \"Ljava/lang/Object\" for {@code null} value)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 499
    },
    "return": "String",
    "signature": "public String toDescriptorFromObject(@Nullable Object value)",
    "source_code": "\tpublic static String toDescriptorFromObject(@Nullable Object value) {\n\t\tif (value == null) {\n\t\t\treturn \"Ljava/lang/Object\";\n\t\t}\n\t\telse {\n\t\t\treturn toDescriptor(value.getClass());\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#toDescriptors(types)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an array of descriptors from an array of classes.\n\t * @param types the input array of classes\n\t * @return an array of descriptors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "types"
    ],
    "position": {
      "column": 1,
      "line": 795
    },
    "return": "String[]",
    "signature": "public String[] toDescriptors(Class<?>[] types)",
    "source_code": "\tpublic static String[] toDescriptors(Class<?>[] types) {\n\t\tint typesCount = types.length;\n\t\tString[] descriptors = new String[typesCount];\n\t\tfor (int p = 0; p < typesCount; p++) {\n\t\t\tdescriptors[p] = toDescriptor(types[p]);\n\t\t}\n\t\treturn descriptors;\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#toJvmDescriptor(clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the JVM descriptor for a specified class. Unlike the other descriptors\n\t * used in the compilation process, this is the one the JVM wants, so this one\n\t * includes any necessary trailing semicolon (e.g. Ljava/lang/String; rather than\n\t * Ljava/lang/String)\n\t * @param clazz a class\n\t * @return the JVM descriptor for the class\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 448
    },
    "return": "String",
    "signature": "public String toJvmDescriptor(Class<?> clazz)",
    "source_code": "\tpublic static String toJvmDescriptor(Class<?> clazz) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif (clazz.isArray()) {\n\t\t\twhile (clazz.isArray()) {\n\t\t\t\tsb.append('[');\n\t\t\t\tclazz = clazz.getComponentType();\n\t\t\t}\n\t\t}\n\t\tif (clazz.isPrimitive()) {\n\t\t\tif (clazz == Boolean.TYPE) {\n\t\t\t\tsb.append('Z');\n\t\t\t}\n\t\t\telse if (clazz == Byte.TYPE) {\n\t\t\t\tsb.append('B');\n\t\t\t}\n\t\t\telse if (clazz == Character.TYPE) {\n\t\t\t\tsb.append('C');\n\t\t\t}\n\t\t\telse if (clazz == Double.TYPE) {\n\t\t\t\tsb.append('D');\n\t\t\t}\n\t\t\telse if (clazz == Float.TYPE) {\n\t\t\t\tsb.append('F');\n\t\t\t}\n\t\t\telse if (clazz == Integer.TYPE) {\n\t\t\t\tsb.append('I');\n\t\t\t}\n\t\t\telse if (clazz == Long.TYPE) {\n\t\t\t\tsb.append('J');\n\t\t\t}\n\t\t\telse if (clazz == Short.TYPE) {\n\t\t\t\tsb.append('S');\n\t\t\t}\n\t\t\telse if (clazz == Void.TYPE) {\n\t\t\t\tsb.append('V');\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsb.append('L');\n\t\t\tsb.append(clazz.getName().replace('.', '/'));\n\t\t\tsb.append(';');\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#toParamDescriptors(ctor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an array of descriptors representing the parameter types for the supplied\n\t * constructor. Returns a zero sized array if there are no parameters.\n\t * @param ctor a Constructor\n\t * @return a String array of descriptors, one entry for each constructor parameter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ctor"
    ],
    "position": {
      "column": 1,
      "line": 786
    },
    "return": "String[]",
    "signature": "public String[] toParamDescriptors(Constructor<?> ctor)",
    "source_code": "\tpublic static String[] toParamDescriptors(Constructor<?> ctor) {\n\t\treturn toDescriptors(ctor.getParameterTypes());\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#toParamDescriptors(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an array of descriptors representing the parameter types for the supplied\n\t * method. Returns a zero sized array if there are no parameters.\n\t * @param method a Method\n\t * @return a String array of descriptors, one entry for each method parameter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 776
    },
    "return": "String[]",
    "signature": "public String[] toParamDescriptors(Method method)",
    "source_code": "\tpublic static String[] toParamDescriptors(Method method) {\n\t\treturn toDescriptors(method.getParameterTypes());\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#toPrimitiveTargetDesc(descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a type descriptor to the single character primitive descriptor.\n\t * @param descriptor a descriptor for a type that should have a primitive representation\n\t * @return the single character descriptor for a primitive input descriptor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 629
    },
    "return": "char",
    "signature": "public char toPrimitiveTargetDesc(String descriptor)",
    "source_code": "\tpublic static char toPrimitiveTargetDesc(String descriptor) {\n\t\tif (descriptor.length() == 1) {\n\t\t\treturn descriptor.charAt(0);\n\t\t}\n\t\treturn switch (descriptor) {\n\t\t\tcase \"Ljava/lang/Double\" -> 'D';\n\t\t\tcase \"Ljava/lang/Float\" -> 'F';\n\t\t\tcase \"Ljava/lang/Integer\" -> 'I';\n\t\t\tcase \"Ljava/lang/Long\" -> 'J';\n\t\t\tcase \"Ljava/lang/Boolean\" -> 'Z';\n\t\t\tcase \"Ljava/lang/Character\" -> 'C';\n\t\t\tcase \"Ljava/lang/Byte\" -> 'B';\n\t\t\tcase \"Ljava/lang/Short\" -> 'S';\n\t\t\tdefault -> throw new IllegalStateException(\"No primitive for '\" + descriptor + \"'\");\n\t\t};\n\t}"
  },
  "org.springframework.expression.spel.CodeFlow#unboxBooleanIfNecessary(mv)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * If the codeflow shows the last expression evaluated to java.lang.Boolean then\n\t * insert the necessary instructions to unbox that to a boolean primitive.\n\t * @param mv the method visitor into which new instructions should be inserted\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "void",
    "signature": "public void unboxBooleanIfNecessary(MethodVisitor mv)",
    "source_code": "\tpublic void unboxBooleanIfNecessary(MethodVisitor mv) {\n\t\tif (\"Ljava/lang/Boolean\".equals(lastDescriptor())) {\n\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Boolean\", \"booleanValue\", \"()Z\", false);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.FieldAdder": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Interface used to generate fields.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 952
    },
    "signature": "public interface FieldAdder",
    "source_code": "\tpublic interface FieldAdder {\n\n\t\tvoid generateField(ClassWriter cw, CodeFlow codeflow);\n\t}"
  },
  "org.springframework.http.ResponseEntity#ofNullable(body)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A shortcut for creating a {@code ResponseEntity} with the given body\n\t * and the {@linkplain HttpStatus#OK OK} status, or an empty body and a\n\t * {@linkplain HttpStatus#NOT_FOUND NOT FOUND} status in case of a\n\t * {@code null} parameter.\n\t * @return the created {@code ResponseEntity}\n\t * @since 6.0.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> ofNullable(@Nullable T body)",
    "source_code": "\tpublic static <T> ResponseEntity<T> ofNullable(@Nullable T body) {\n\t\tif (body == null) {\n\t\t\treturn notFound().build();\n\t\t}\n\t\treturn ResponseEntity.ok(body);\n\t}"
  },
  "org.springframework.http.client.reactive.HttpComponentsClientHttpConnector#completed(result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "void",
    "signature": "public void completed(Void result)",
    "source_code": "\t\tpublic void completed(Void result) {\n\t\t\tthis.sink.success();\n\t\t}"
  },
  "org.springframework.http.codec.json.Jackson2CodecSupport#getMediaTypesForProblemDetail()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the supported media type(s) for {@link ProblemDetail}.\n\t * By default, an empty list, unless overridden in subclasses.\n\t * @since 6.0.5\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "List<MimeType>",
    "signature": "protected List<MimeType> getMediaTypesForProblemDetail()",
    "source_code": "\tprotected List<MimeType> getMediaTypesForProblemDetail() {\n\t\treturn Collections.emptyList();\n\t}"
  },
  "org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter#getMediaTypesForProblemDetail()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the supported media type(s) for {@link ProblemDetail}.\n\t * By default, an empty list, unless overridden in subclasses.\n\t * @since 6.0.5\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "List<MediaType>",
    "signature": "protected List<MediaType> getMediaTypesForProblemDetail()",
    "source_code": "\tprotected List<MediaType> getMediaTypesForProblemDetail() {\n\t\treturn Collections.emptyList();\n\t}"
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link RowMapper} implementation that converts a row into a new instance\n * of the specified mapped target class. The mapped target class must be a\n * top-level class or {@code static} nested class, and it must have a default or\n * no-arg constructor.\n *\n * <p>Column values are mapped based on matching the column name (as obtained from\n * result set meta-data) to public setters in the target class for the corresponding\n * properties. The names are matched either directly or by transforming a name\n * separating the parts with underscores to the same name using \"camel\" case.\n *\n * <p>Mapping is provided for properties in the target class for many common types &mdash;\n * for example: String, boolean, Boolean, byte, Byte, short, Short, int, Integer,\n * long, Long, float, Float, double, Double, BigDecimal, {@code java.util.Date}, etc.\n *\n * <p>To facilitate mapping between columns and properties that don't have matching\n * names, try using column aliases in the SQL statement like\n * {@code \"select fname as first_name from customer\"}, where {@code first_name}\n * can be mapped to a {@code setFirstName(String)} method in the target class.\n *\n * <p>For a {@code NULL} value read from the database, an attempt will be made to\n * call the corresponding setter method with {@code null}, but in the case of\n * Java primitives this will result in a {@link TypeMismatchException} by default.\n * To ignore {@code NULL} database values for all primitive properties in the\n * target class, set the {@code primitivesDefaultedForNullValue} flag to\n * {@code true}. See {@link #setPrimitivesDefaultedForNullValue(boolean)} for\n * details.\n *\n * <p>If you need to map to a target class which has a <em>data class</em> constructor\n * &mdash; for example, a Java {@code record} or a Kotlin {@code data} class &mdash;\n * use {@link DataClassRowMapper} instead.\n *\n * <p>Please note that this class is designed to provide convenience rather than\n * high performance. For best performance, consider using a custom {@code RowMapper}\n * implementation.\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 2.5\n * @param <T> the result type\n * @see DataClassRowMapper\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "signature": "public class BeanPropertyRowMapper",
    "source_code": "public class BeanPropertyRowMapper<T> implements RowMapper<T> {\n\n\t/** Logger available to subclasses. */\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t/** The class we are mapping to. */\n\t@Nullable\n\tprivate Class<T> mappedClass;\n\n\t/** Whether we're strictly validating. */\n\tprivate boolean checkFullyPopulated = false;\n\n\t/**\n\t * Whether {@code NULL} database values should be ignored for primitive\n\t * properties in the target class.\n\t * @see #setPrimitivesDefaultedForNullValue(boolean)\n\t */\n\tprivate boolean primitivesDefaultedForNullValue = false;\n\n\t/** ConversionService for binding JDBC values to bean properties. */\n\t@Nullable\n\tprivate ConversionService conversionService = DefaultConversionService.getSharedInstance();\n\n\t/** Map of the properties we provide mapping for. */\n\t@Nullable\n\tprivate Map<String, PropertyDescriptor> mappedProperties;\n\n\t/** Set of bean property names we provide mapping for. */\n\t@Nullable\n\tprivate Set<String> mappedPropertyNames;\n\n\n\t/**\n\t * Create a new {@code BeanPropertyRowMapper} for bean-style configuration.\n\t * @see #setMappedClass\n\t * @see #setCheckFullyPopulated\n\t */\n\tpublic BeanPropertyRowMapper() {\n\t}\n\n\t/**\n\t * Create a new {@code BeanPropertyRowMapper}, accepting unpopulated\n\t * properties in the target bean.\n\t * @param mappedClass the class that each row should be mapped to\n\t */\n\tpublic BeanPropertyRowMapper(Class<T> mappedClass) {\n\t\tinitialize(mappedClass);\n\t}\n\n\t/**\n\t * Create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param checkFullyPopulated whether we're strictly validating that\n\t * all bean properties have been mapped from corresponding database columns\n\t */\n\tpublic BeanPropertyRowMapper(Class<T> mappedClass, boolean checkFullyPopulated) {\n\t\tinitialize(mappedClass);\n\t\tthis.checkFullyPopulated = checkFullyPopulated;\n\t}\n\n\n\t/**\n\t * Set the class that each row should be mapped to.\n\t */\n\tpublic void setMappedClass(Class<T> mappedClass) {\n\t\tif (this.mappedClass == null) {\n\t\t\tinitialize(mappedClass);\n\t\t}\n\t\telse {\n\t\t\tif (this.mappedClass != mappedClass) {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\"The mapped class can not be reassigned to map to \" +\n\t\t\t\t\t\tmappedClass + \" since it is already providing mapping for \" + this.mappedClass);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the class that we are mapping to.\n\t */\n\t@Nullable\n\tpublic final Class<T> getMappedClass() {\n\t\treturn this.mappedClass;\n\t}\n\n\t/**\n\t * Set whether we're strictly validating that all bean properties have been mapped\n\t * from corresponding database columns.\n\t * <p>Default is {@code false}, accepting unpopulated properties in the target bean.\n\t */\n\tpublic void setCheckFullyPopulated(boolean checkFullyPopulated) {\n\t\tthis.checkFullyPopulated = checkFullyPopulated;\n\t}\n\n\t/**\n\t * Return whether we're strictly validating that all bean properties have been\n\t * mapped from corresponding database columns.\n\t */\n\tpublic boolean isCheckFullyPopulated() {\n\t\treturn this.checkFullyPopulated;\n\t}\n\n\t/**\n\t * Set whether a {@code NULL} database column value should be ignored when\n\t * mapping to a corresponding primitive property in the target class.\n\t * <p>Default is {@code false}, throwing an exception when nulls are mapped\n\t * to Java primitives.\n\t * <p>If this flag is set to {@code true} and you use an <em>ignored</em>\n\t * primitive property value from the mapped bean to update the database, the\n\t * value in the database will be changed from {@code NULL} to the current value\n\t * of that primitive property. That value may be the property's initial value\n\t * (potentially Java's default value for the respective primitive type), or\n\t * it may be some other value set for the property in the default constructor\n\t * (or initialization block) or as a side effect of setting some other property\n\t * in the mapped bean.\n\t */\n\tpublic void setPrimitivesDefaultedForNullValue(boolean primitivesDefaultedForNullValue) {\n\t\tthis.primitivesDefaultedForNullValue = primitivesDefaultedForNullValue;\n\t}\n\n\t/**\n\t * Get the value of the {@code primitivesDefaultedForNullValue} flag.\n\t * @see #setPrimitivesDefaultedForNullValue(boolean)\n\t */\n\tpublic boolean isPrimitivesDefaultedForNullValue() {\n\t\treturn this.primitivesDefaultedForNullValue;\n\t}\n\n\t/**\n\t * Set a {@link ConversionService} for binding JDBC values to bean properties,\n\t * or {@code null} for none.\n\t * <p>Default is a {@link DefaultConversionService}, as of Spring 4.3. This\n\t * provides support for {@code java.time} conversion and other special types.\n\t * @since 4.3\n\t * @see #initBeanWrapper(BeanWrapper)\n\t */\n\tpublic void setConversionService(@Nullable ConversionService conversionService) {\n\t\tthis.conversionService = conversionService;\n\t}\n\n\t/**\n\t * Return a {@link ConversionService} for binding JDBC values to bean properties,\n\t * or {@code null} if none.\n\t * @since 4.3\n\t */\n\t@Nullable\n\tpublic ConversionService getConversionService() {\n\t\treturn this.conversionService;\n\t}\n\n\n\t/**\n\t * Initialize the mapping meta-data for the given class.\n\t * @param mappedClass the mapped class\n\t */\n\tprotected void initialize(Class<T> mappedClass) {\n\t\tthis.mappedClass = mappedClass;\n\t\tthis.mappedProperties = new HashMap<>();\n\t\tthis.mappedPropertyNames = new HashSet<>();\n\n\t\tfor (PropertyDescriptor pd : BeanUtils.getPropertyDescriptors(mappedClass)) {\n\t\t\tif (pd.getWriteMethod() != null) {\n\t\t\t\tString lowerCaseName = lowerCaseName(pd.getName());\n\t\t\t\tthis.mappedProperties.put(lowerCaseName, pd);\n\t\t\t\tString underscoreName = underscoreName(pd.getName());\n\t\t\t\tif (!lowerCaseName.equals(underscoreName)) {\n\t\t\t\t\tthis.mappedProperties.put(underscoreName, pd);\n\t\t\t\t}\n\t\t\t\tthis.mappedPropertyNames.add(pd.getName());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Remove the specified property from the mapped properties.\n\t * @param propertyName the property name (as used by property descriptors)\n\t * @since 5.3.9\n\t */\n\tprotected void suppressProperty(String propertyName) {\n\t\tif (this.mappedProperties != null) {\n\t\t\tthis.mappedProperties.remove(lowerCaseName(propertyName));\n\t\t\tthis.mappedProperties.remove(underscoreName(propertyName));\n\t\t}\n\t}\n\n\t/**\n\t * Convert the given name to lower case.\n\t * By default, conversions will happen within the US locale.\n\t * @param name the original name\n\t * @return the converted name\n\t * @since 4.2\n\t */\n\tprotected String lowerCaseName(String name) {\n\t\treturn name.toLowerCase(Locale.US);\n\t}\n\n\t/**\n\t * Convert a name in camelCase to an underscored name in lower case.\n\t * Any upper case letters are converted to lower case with a preceding underscore.\n\t * @param name the original name\n\t * @return the converted name\n\t * @since 4.2\n\t * @see #lowerCaseName\n\t */\n\tprotected String underscoreName(String name) {\n\t\tif (!StringUtils.hasLength(name)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(Character.toLowerCase(name.charAt(0)));\n\t\tfor (int i = 1; i < name.length(); i++) {\n\t\t\tchar c = name.charAt(i);\n\t\t\tif (Character.isUpperCase(c)) {\n\t\t\t\tresult.append('_').append(Character.toLowerCase(c));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(c);\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}\n\n\n\t/**\n\t * Extract the values for all columns in the current row.\n\t * <p>Utilizes public setters and result set meta-data.\n\t * @see java.sql.ResultSetMetaData\n\t */\n\t@Override\n\tpublic T mapRow(ResultSet rs, int rowNumber) throws SQLException {\n\t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n\t\tinitBeanWrapper(bw);\n\n\t\tT mappedObject = constructMappedInstance(rs, bw);\n\t\tbw.setBeanInstance(mappedObject);\n\n\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\tint columnCount = rsmd.getColumnCount();\n\t\tSet<String> populatedProperties = (isCheckFullyPopulated() ? new HashSet<>() : null);\n\n\t\tfor (int index = 1; index <= columnCount; index++) {\n\t\t\tString column = JdbcUtils.lookupColumnName(rsmd, index);\n\t\t\tString property = lowerCaseName(StringUtils.delete(column, \" \"));\n\t\t\tPropertyDescriptor pd = (this.mappedProperties != null ? this.mappedProperties.get(property) : null);\n\t\t\tif (pd != null) {\n\t\t\t\ttry {\n\t\t\t\t\tObject value = getColumnValue(rs, index, pd);\n\t\t\t\t\tif (rowNumber == 0 && logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Mapping column '\" + column + \"' to property '\" + pd.getName() +\n\t\t\t\t\t\t\t\t\"' of type '\" + ClassUtils.getQualifiedName(pd.getPropertyType()) + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbw.setPropertyValue(pd.getName(), value);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\t\t\tif (value == null && this.primitivesDefaultedForNullValue) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tString propertyType = ClassUtils.getQualifiedName(pd.getPropertyType());\n\t\t\t\t\t\t\t\tlogger.debug(\"\"\"\n\t\t\t\t\t\t\t\t\t\tIgnoring intercepted TypeMismatchException for row %d and column '%s' \\\n\t\t\t\t\t\t\t\t\t\twith null value when setting property '%s' of type '%s' on object: %s\"\n\t\t\t\t\t\t\t\t\t\t\"\"\".formatted(rowNumber, column, pd.getName(), propertyType, mappedObject), ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (populatedProperties != null) {\n\t\t\t\t\t\tpopulatedProperties.add(pd.getName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NotWritablePropertyException ex) {\n\t\t\t\t\tthrow new DataRetrievalFailureException(\n\t\t\t\t\t\t\t\"Unable to map column '\" + column + \"' to property '\" + pd.getName() + \"'\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (populatedProperties != null && !populatedProperties.equals(this.mappedPropertyNames)) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\"Given ResultSet does not contain all properties \" +\n\t\t\t\t\t\"necessary to populate object of \" + this.mappedClass + \": \" + this.mappedPropertyNames);\n\t\t}\n\n\t\treturn mappedObject;\n\t}\n\n\t/**\n\t * Construct an instance of the mapped class for the current row.\n\t * @param rs the ResultSet to map (pre-initialized for the current row)\n\t * @param tc a TypeConverter with this RowMapper's conversion service\n\t * @return a corresponding instance of the mapped class\n\t * @throws SQLException if an SQLException is encountered\n\t * @since 5.3\n\t */\n\tprotected T constructMappedInstance(ResultSet rs, TypeConverter tc) throws SQLException  {\n\t\tAssert.state(this.mappedClass != null, \"Mapped class was not specified\");\n\t\treturn BeanUtils.instantiateClass(this.mappedClass);\n\t}\n\n\t/**\n\t * Initialize the given BeanWrapper to be used for row mapping.\n\t * To be called for each row.\n\t * <p>The default implementation applies the configured {@link ConversionService},\n\t * if any. Can be overridden in subclasses.\n\t * @param bw the BeanWrapper to initialize\n\t * @see #getConversionService()\n\t * @see BeanWrapper#setConversionService\n\t */\n\tprotected void initBeanWrapper(BeanWrapper bw) {\n\t\tConversionService cs = getConversionService();\n\t\tif (cs != null) {\n\t\t\tbw.setConversionService(cs);\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve a JDBC object value for the specified column.\n\t * <p>The default implementation delegates to\n\t * {@link #getColumnValue(ResultSet, int, Class)}.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @param pd the bean property that each result object is expected to match\n\t * @return the Object value\n\t * @throws SQLException in case of extraction failure\n\t * @see #getColumnValue(ResultSet, int, Class)\n\t */\n\t@Nullable\n\tprotected Object getColumnValue(ResultSet rs, int index, PropertyDescriptor pd) throws SQLException {\n\t\treturn JdbcUtils.getResultSetValue(rs, index, pd.getPropertyType());\n\t}\n\n\t/**\n\t * Retrieve a JDBC object value for the specified column.\n\t * <p>The default implementation calls\n\t * {@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}.\n\t * Subclasses may override this to check specific value types upfront,\n\t * or to post-process values return from {@code getResultSetValue}.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @param paramType the target parameter type\n\t * @return the Object value\n\t * @throws SQLException in case of extraction failure\n\t * @since 5.3\n\t * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)\n\t */\n\t@Nullable\n\tprotected Object getColumnValue(ResultSet rs, int index, Class<?> paramType) throws SQLException {\n\t\treturn JdbcUtils.getResultSetValue(rs, index, paramType);\n\t}\n\n\n\t/**\n\t * Static factory method to create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @see #newInstance(Class, ConversionService)\n\t */\n\tpublic static <T> BeanPropertyRowMapper<T> newInstance(Class<T> mappedClass) {\n\t\treturn new BeanPropertyRowMapper<>(mappedClass);\n\t}\n\n\t/**\n\t * Static factory method to create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param conversionService the {@link ConversionService} for binding\n\t * JDBC values to bean properties, or {@code null} for none\n\t * @since 5.2.3\n\t * @see #newInstance(Class)\n\t * @see #setConversionService\n\t */\n\tpublic static <T> BeanPropertyRowMapper<T> newInstance(\n\t\t\tClass<T> mappedClass, @Nullable ConversionService conversionService) {\n\n\t\tBeanPropertyRowMapper<T> rowMapper = newInstance(mappedClass);\n\t\trowMapper.setConversionService(conversionService);\n\t\treturn rowMapper;\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper#constructMappedInstance(rs,tc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Construct an instance of the mapped class for the current row.\n\t * @param rs the ResultSet to map (pre-initialized for the current row)\n\t * @param tc a TypeConverter with this RowMapper's conversion service\n\t * @return a corresponding instance of the mapped class\n\t * @throws SQLException if an SQLException is encountered\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "tc"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "T",
    "signature": "protected T constructMappedInstance(ResultSet rs, TypeConverter tc)",
    "source_code": "\tprotected T constructMappedInstance(ResultSet rs, TypeConverter tc) throws SQLException  {\n\t\tAssert.state(this.mappedClass != null, \"Mapped class was not specified\");\n\t\treturn BeanUtils.instantiateClass(this.mappedClass);\n\t}"
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper#getColumnValue(rs,index,paramType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC object value for the specified column.\n\t * <p>The default implementation calls\n\t * {@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}.\n\t * Subclasses may override this to check specific value types upfront,\n\t * or to post-process values return from {@code getResultSetValue}.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @param paramType the target parameter type\n\t * @return the Object value\n\t * @throws SQLException in case of extraction failure\n\t * @since 5.3\n\t * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "index",
      "paramType"
    ],
    "position": {
      "column": 1,
      "line": 438
    },
    "return": "Object",
    "signature": "protected Object getColumnValue(ResultSet rs, int index, Class<?> paramType)",
    "source_code": "\tprotected Object getColumnValue(ResultSet rs, int index, Class<?> paramType) throws SQLException {\n\t\treturn JdbcUtils.getResultSetValue(rs, index, paramType);\n\t}"
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper#getColumnValue(rs,index,pd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC object value for the specified column.\n\t * <p>The default implementation delegates to\n\t * {@link #getColumnValue(ResultSet, int, Class)}.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @param pd the bean property that each result object is expected to match\n\t * @return the Object value\n\t * @throws SQLException in case of extraction failure\n\t * @see #getColumnValue(ResultSet, int, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "index",
      "pd"
    ],
    "position": {
      "column": 1,
      "line": 419
    },
    "return": "Object",
    "signature": "protected Object getColumnValue(ResultSet rs, int index, PropertyDescriptor pd)",
    "source_code": "\tprotected Object getColumnValue(ResultSet rs, int index, PropertyDescriptor pd) throws SQLException {\n\t\treturn JdbcUtils.getResultSetValue(rs, index, pd.getPropertyType());\n\t}"
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper#getConversionService()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ConversionService} for binding JDBC values to bean properties,\n\t * or {@code null} if none.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "ConversionService",
    "signature": "public ConversionService getConversionService()",
    "source_code": "\tpublic ConversionService getConversionService() {\n\t\treturn this.conversionService;\n\t}"
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper#getMappedClass()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the class that we are mapping to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "Class<T>",
    "signature": "public Class<T> getMappedClass()",
    "source_code": "\tpublic final Class<T> getMappedClass() {\n\t\treturn this.mappedClass;\n\t}"
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper#initBeanWrapper(bw)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the given BeanWrapper to be used for row mapping.\n\t * To be called for each row.\n\t * <p>The default implementation applies the configured {@link ConversionService},\n\t * if any. Can be overridden in subclasses.\n\t * @param bw the BeanWrapper to initialize\n\t * @see #getConversionService()\n\t * @see BeanWrapper#setConversionService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bw"
    ],
    "position": {
      "column": 1,
      "line": 400
    },
    "return": "void",
    "signature": "protected void initBeanWrapper(BeanWrapper bw)",
    "source_code": "\tprotected void initBeanWrapper(BeanWrapper bw) {\n\t\tConversionService cs = getConversionService();\n\t\tif (cs != null) {\n\t\t\tbw.setConversionService(cs);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper#initialize(mappedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the mapping meta-data for the given class.\n\t * @param mappedClass the mapped class\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mappedClass"
    ],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "void",
    "signature": "protected void initialize(Class<T> mappedClass)",
    "source_code": "\tprotected void initialize(Class<T> mappedClass) {\n\t\tthis.mappedClass = mappedClass;\n\t\tthis.mappedProperties = new HashMap<>();\n\t\tthis.mappedPropertyNames = new HashSet<>();\n\n\t\tfor (PropertyDescriptor pd : BeanUtils.getPropertyDescriptors(mappedClass)) {\n\t\t\tif (pd.getWriteMethod() != null) {\n\t\t\t\tString lowerCaseName = lowerCaseName(pd.getName());\n\t\t\t\tthis.mappedProperties.put(lowerCaseName, pd);\n\t\t\t\tString underscoreName = underscoreName(pd.getName());\n\t\t\t\tif (!lowerCaseName.equals(underscoreName)) {\n\t\t\t\t\tthis.mappedProperties.put(underscoreName, pd);\n\t\t\t\t}\n\t\t\t\tthis.mappedPropertyNames.add(pd.getName());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper#isCheckFullyPopulated()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether we're strictly validating that all bean properties have been\n\t * mapped from corresponding database columns.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "boolean",
    "signature": "public boolean isCheckFullyPopulated()",
    "source_code": "\tpublic boolean isCheckFullyPopulated() {\n\t\treturn this.checkFullyPopulated;\n\t}"
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper#isPrimitivesDefaultedForNullValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the {@code primitivesDefaultedForNullValue} flag.\n\t * @see #setPrimitivesDefaultedForNullValue(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "boolean",
    "signature": "public boolean isPrimitivesDefaultedForNullValue()",
    "source_code": "\tpublic boolean isPrimitivesDefaultedForNullValue() {\n\t\treturn this.primitivesDefaultedForNullValue;\n\t}"
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper#lowerCaseName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given name to lower case.\n\t * By default, conversions will happen within the US locale.\n\t * @param name the original name\n\t * @return the converted name\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "String",
    "signature": "protected String lowerCaseName(String name)",
    "source_code": "\tprotected String lowerCaseName(String name) {\n\t\treturn name.toLowerCase(Locale.US);\n\t}"
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper#mapRow(rs,rowNumber)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract the values for all columns in the current row.\n\t * <p>Utilizes public setters and result set meta-data.\n\t * @see java.sql.ResultSetMetaData\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "rowNumber"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "T",
    "signature": "public T mapRow(ResultSet rs, int rowNumber)",
    "source_code": "\tpublic T mapRow(ResultSet rs, int rowNumber) throws SQLException {\n\t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n\t\tinitBeanWrapper(bw);\n\n\t\tT mappedObject = constructMappedInstance(rs, bw);\n\t\tbw.setBeanInstance(mappedObject);\n\n\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\tint columnCount = rsmd.getColumnCount();\n\t\tSet<String> populatedProperties = (isCheckFullyPopulated() ? new HashSet<>() : null);\n\n\t\tfor (int index = 1; index <= columnCount; index++) {\n\t\t\tString column = JdbcUtils.lookupColumnName(rsmd, index);\n\t\t\tString property = lowerCaseName(StringUtils.delete(column, \" \"));\n\t\t\tPropertyDescriptor pd = (this.mappedProperties != null ? this.mappedProperties.get(property) : null);\n\t\t\tif (pd != null) {\n\t\t\t\ttry {\n\t\t\t\t\tObject value = getColumnValue(rs, index, pd);\n\t\t\t\t\tif (rowNumber == 0 && logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Mapping column '\" + column + \"' to property '\" + pd.getName() +\n\t\t\t\t\t\t\t\t\"' of type '\" + ClassUtils.getQualifiedName(pd.getPropertyType()) + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbw.setPropertyValue(pd.getName(), value);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\t\t\tif (value == null && this.primitivesDefaultedForNullValue) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tString propertyType = ClassUtils.getQualifiedName(pd.getPropertyType());\n\t\t\t\t\t\t\t\tlogger.debug(\"\"\"\n\t\t\t\t\t\t\t\t\t\tIgnoring intercepted TypeMismatchException for row %d and column '%s' \\\n\t\t\t\t\t\t\t\t\t\twith null value when setting property '%s' of type '%s' on object: %s\"\n\t\t\t\t\t\t\t\t\t\t\"\"\".formatted(rowNumber, column, pd.getName(), propertyType, mappedObject), ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (populatedProperties != null) {\n\t\t\t\t\t\tpopulatedProperties.add(pd.getName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NotWritablePropertyException ex) {\n\t\t\t\t\tthrow new DataRetrievalFailureException(\n\t\t\t\t\t\t\t\"Unable to map column '\" + column + \"' to property '\" + pd.getName() + \"'\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (populatedProperties != null && !populatedProperties.equals(this.mappedPropertyNames)) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\"Given ResultSet does not contain all properties \" +\n\t\t\t\t\t\"necessary to populate object of \" + this.mappedClass + \": \" + this.mappedPropertyNames);\n\t\t}\n\n\t\treturn mappedObject;\n\t}"
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper#newInstance(mappedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @see #newInstance(Class, ConversionService)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass"
    ],
    "position": {
      "column": 1,
      "line": 448
    },
    "return": "BeanPropertyRowMapper<T>",
    "signature": "public BeanPropertyRowMapper<T> newInstance(Class<T> mappedClass)",
    "source_code": "\tpublic static <T> BeanPropertyRowMapper<T> newInstance(Class<T> mappedClass) {\n\t\treturn new BeanPropertyRowMapper<>(mappedClass);\n\t}"
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper#newInstance(mappedClass,conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param conversionService the {@link ConversionService} for binding\n\t * JDBC values to bean properties, or {@code null} for none\n\t * @since 5.2.3\n\t * @see #newInstance(Class)\n\t * @see #setConversionService\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 461
    },
    "return": "BeanPropertyRowMapper<T>",
    "signature": "public BeanPropertyRowMapper<T> newInstance(Class<T> mappedClass, @Nullable ConversionService conversionService)",
    "source_code": "\tpublic static <T> BeanPropertyRowMapper<T> newInstance("
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper#setCheckFullyPopulated(checkFullyPopulated)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether we're strictly validating that all bean properties have been mapped\n\t * from corresponding database columns.\n\t * <p>Default is {@code false}, accepting unpopulated properties in the target bean.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "checkFullyPopulated"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "void",
    "signature": "public void setCheckFullyPopulated(boolean checkFullyPopulated)",
    "source_code": "\tpublic void setCheckFullyPopulated(boolean checkFullyPopulated) {\n\t\tthis.checkFullyPopulated = checkFullyPopulated;\n\t}"
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper#setConversionService(conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a {@link ConversionService} for binding JDBC values to bean properties,\n\t * or {@code null} for none.\n\t * <p>Default is a {@link DefaultConversionService}, as of Spring 4.3. This\n\t * provides support for {@code java.time} conversion and other special types.\n\t * @since 4.3\n\t * @see #initBeanWrapper(BeanWrapper)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "void",
    "signature": "public void setConversionService(@Nullable ConversionService conversionService)",
    "source_code": "\tpublic void setConversionService(@Nullable ConversionService conversionService) {\n\t\tthis.conversionService = conversionService;\n\t}"
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper#setMappedClass(mappedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the class that each row should be mapped to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "void",
    "signature": "public void setMappedClass(Class<T> mappedClass)",
    "source_code": "\tpublic void setMappedClass(Class<T> mappedClass) {\n\t\tif (this.mappedClass == null) {\n\t\t\tinitialize(mappedClass);\n\t\t}\n\t\telse {\n\t\t\tif (this.mappedClass != mappedClass) {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\"The mapped class can not be reassigned to map to \" +\n\t\t\t\t\t\tmappedClass + \" since it is already providing mapping for \" + this.mappedClass);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper#setPrimitivesDefaultedForNullValue(primitivesDefaultedForNullValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether a {@code NULL} database column value should be ignored when\n\t * mapping to a corresponding primitive property in the target class.\n\t * <p>Default is {@code false}, throwing an exception when nulls are mapped\n\t * to Java primitives.\n\t * <p>If this flag is set to {@code true} and you use an <em>ignored</em>\n\t * primitive property value from the mapped bean to update the database, the\n\t * value in the database will be changed from {@code NULL} to the current value\n\t * of that primitive property. That value may be the property's initial value\n\t * (potentially Java's default value for the respective primitive type), or\n\t * it may be some other value set for the property in the default constructor\n\t * (or initialization block) or as a side effect of setting some other property\n\t * in the mapped bean.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "primitivesDefaultedForNullValue"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "void",
    "signature": "public void setPrimitivesDefaultedForNullValue(boolean primitivesDefaultedForNullValue)",
    "source_code": "\tpublic void setPrimitivesDefaultedForNullValue(boolean primitivesDefaultedForNullValue) {\n\t\tthis.primitivesDefaultedForNullValue = primitivesDefaultedForNullValue;\n\t}"
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper#suppressProperty(propertyName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Remove the specified property from the mapped properties.\n\t * @param propertyName the property name (as used by property descriptors)\n\t * @since 5.3.9\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "void",
    "signature": "protected void suppressProperty(String propertyName)",
    "source_code": "\tprotected void suppressProperty(String propertyName) {\n\t\tif (this.mappedProperties != null) {\n\t\t\tthis.mappedProperties.remove(lowerCaseName(propertyName));\n\t\t\tthis.mappedProperties.remove(underscoreName(propertyName));\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.BeanPropertyRowMapper#underscoreName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a name in camelCase to an underscored name in lower case.\n\t * Any upper case letters are converted to lower case with a preceding underscore.\n\t * @param name the original name\n\t * @return the converted name\n\t * @since 4.2\n\t * @see #lowerCaseName\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "String",
    "signature": "protected String underscoreName(String name)",
    "source_code": "\tprotected String underscoreName(String name) {\n\t\tif (!StringUtils.hasLength(name)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(Character.toLowerCase(name.charAt(0)));\n\t\tfor (int i = 1; i < name.length(); i++) {\n\t\t\tchar c = name.charAt(i);\n\t\t\tif (Character.isUpperCase(c)) {\n\t\t\t\tresult.append('_').append(Character.toLowerCase(c));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(c);\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}"
  },
  "org.springframework.jdbc.core.logger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Logger available to subclasses. */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.jms.JmsException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Base class for exception thrown by the framework whenever it\n * encounters a problem related to JMS.\n *\n * @author Mark Pollack\n * @author Juergen Hoeller\n * @since 1.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 33
    },
    "signature": "public class JmsException",
    "source_code": "public abstract class JmsException extends NestedRuntimeException {\n\n\t/**\n\t * Constructor that takes a message.\n\t * @param msg the detail message\n\t */\n\tpublic JmsException(String msg) {\n\t\tsuper(msg);\n\t}\n\n\t/**\n\t * Constructor that takes a message and a root cause.\n\t * @param msg the detail message\n\t * @param cause the cause of the exception. This argument is generally\n\t * expected to be a proper subclass of {@link jakarta.jms.JMSException},\n\t * but can also be a JNDI NamingException or the like.\n\t */\n\tpublic JmsException(String msg, @Nullable Throwable cause) {\n\t\tsuper(msg, cause);\n\t}\n\n\t/**\n\t * Constructor that takes a plain root cause, intended for\n\t * subclasses mirroring corresponding {@code jakarta.jms} exceptions.\n\t * @param cause the cause of the exception. This argument is generally\n\t * expected to be a proper subclass of {@link jakarta.jms.JMSException}.\n\t */\n\tpublic JmsException(@Nullable Throwable cause) {\n\t\tsuper(cause != null ? cause.getMessage() : null, cause);\n\t}\n\n\n\t/**\n\t * Convenience method to get the vendor specific error code if\n\t * the root cause was an instance of JMSException.\n\t * @return a string specifying the vendor-specific error code if the\n\t * root cause is an instance of JMSException, or {@code null}\n\t */\n\t@Nullable\n\tpublic String getErrorCode() {\n\t\tThrowable cause = getCause();\n\t\tif (cause instanceof JMSException jmsException) {\n\t\t\treturn jmsException.getErrorCode();\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Return the detail message, including the message from the linked exception\n\t * if there is one.\n\t * @see jakarta.jms.JMSException#getLinkedException()\n\t */\n\t@Override\n\t@Nullable\n\tpublic String getMessage() {\n\t\tString message = super.getMessage();\n\t\tThrowable cause = getCause();\n\t\tif (cause instanceof JMSException jmsException) {\n\t\t\tException linkedEx = jmsException.getLinkedException();\n\t\t\tif (linkedEx != null) {\n\t\t\t\tString linkedMessage = linkedEx.getMessage();\n\t\t\t\tString causeMessage = cause.getMessage();\n\t\t\t\tif (linkedMessage != null && (causeMessage == null || !causeMessage.contains(linkedMessage))) {\n\t\t\t\t\tmessage = message + \"; nested exception is \" + linkedEx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn message;\n\t}\n\n}"
  },
  "org.springframework.jms.JmsException#getErrorCode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method to get the vendor specific error code if\n\t * the root cause was an instance of JMSException.\n\t * @return a string specifying the vendor-specific error code if the\n\t * root cause is an instance of JMSException, or {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "String",
    "signature": "public String getErrorCode()",
    "source_code": "\tpublic String getErrorCode() {\n\t\tThrowable cause = getCause();\n\t\tif (cause instanceof JMSException jmsException) {\n\t\t\treturn jmsException.getErrorCode();\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.jms.JmsException#getMessage()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the detail message, including the message from the linked exception\n\t * if there is one.\n\t * @see jakarta.jms.JMSException#getLinkedException()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "String",
    "signature": "public String getMessage()",
    "source_code": "\tpublic String getMessage() {\n\t\tString message = super.getMessage();\n\t\tThrowable cause = getCause();\n\t\tif (cause instanceof JMSException jmsException) {\n\t\t\tException linkedEx = jmsException.getLinkedException();\n\t\t\tif (linkedEx != null) {\n\t\t\t\tString linkedMessage = linkedEx.getMessage();\n\t\t\t\tString causeMessage = cause.getMessage();\n\t\t\t\tif (linkedMessage != null && (causeMessage == null || !causeMessage.contains(linkedMessage))) {\n\t\t\t\t\tmessage = message + \"; nested exception is \" + linkedEx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Bean post-processor that registers methods annotated with {@link JmsListener}\n * to be invoked by a JMS message listener container created under the cover\n * by a {@link org.springframework.jms.config.JmsListenerContainerFactory}\n * according to the attributes of the annotation.\n *\n * <p>Annotated methods can use flexible arguments as defined by {@link JmsListener}.\n *\n * <p>This post-processor is automatically registered by Spring's\n * {@code <jms:annotation-driven>} XML element, and also by the {@link EnableJms}\n * annotation.\n *\n * <p>Autodetects any {@link JmsListenerConfigurer} instances in the container,\n * allowing for customization of the registry to be used, the default container\n * factory or for fine-grained control over endpoints registration. See the\n * {@link EnableJms} javadocs for complete usage details.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 4.1\n * @see JmsListener\n * @see EnableJms\n * @see JmsListenerConfigurer\n * @see JmsListenerEndpointRegistrar\n * @see JmsListenerEndpointRegistry\n * @see org.springframework.jms.config.JmsListenerEndpoint\n * @see MethodJmsListenerEndpoint\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "signature": "public class JmsListenerAnnotationBeanPostProcessor",
    "source_code": "public class JmsListenerAnnotationBeanPostProcessor"
  },
  "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor#afterSingletonsInstantiated()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "public void afterSingletonsInstantiated()",
    "source_code": "\tpublic void afterSingletonsInstantiated() {\n\t\t// Remove resolved singleton classes from cache\n\t\tthis.nonAnnotatedClasses.clear();\n\n\t\tif (this.beanFactory instanceof ListableBeanFactory lbf) {\n\t\t\t// Apply JmsListenerConfigurer beans from the BeanFactory, if any\n\t\t\tMap<String, JmsListenerConfigurer> beans = lbf.getBeansOfType(JmsListenerConfigurer.class);\n\t\t\tList<JmsListenerConfigurer> configurers = new ArrayList<>(beans.values());\n\t\t\tAnnotationAwareOrderComparator.sort(configurers);\n\t\t\tfor (JmsListenerConfigurer configurer : configurers) {\n\t\t\t\tconfigurer.configureJmsListeners(this.registrar);\n\t\t\t}\n\t\t}\n\n\t\tif (this.containerFactoryBeanName != null) {\n\t\t\tthis.registrar.setContainerFactoryBeanName(this.containerFactoryBeanName);\n\t\t}\n\n\t\tif (this.registrar.getEndpointRegistry() == null) {\n\t\t\t// Determine JmsListenerEndpointRegistry bean from the BeanFactory\n\t\t\tif (this.endpointRegistry == null) {\n\t\t\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to find endpoint registry by bean name\");\n\t\t\t\tthis.endpointRegistry = this.beanFactory.getBean(\n\t\t\t\t\t\tJmsListenerConfigUtils.JMS_LISTENER_ENDPOINT_REGISTRY_BEAN_NAME, JmsListenerEndpointRegistry.class);\n\t\t\t}\n\t\t\tthis.registrar.setEndpointRegistry(this.endpointRegistry);\n\t\t}\n\n\n\t\t// Set the custom handler method factory once resolved by the configurer\n\t\tMessageHandlerMethodFactory handlerMethodFactory = this.registrar.getMessageHandlerMethodFactory();\n\t\tif (handlerMethodFactory != null) {\n\t\t\tthis.messageHandlerMethodFactory.setMessageHandlerMethodFactory(handlerMethodFactory);\n\t\t}\n\n\t\t// Actually register all listeners\n\t\tthis.registrar.afterPropertiesSet();\n\t}"
  },
  "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor#createInvocableHandlerMethod(bean,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "InvocableHandlerMethod",
    "signature": "public InvocableHandlerMethod createInvocableHandlerMethod(Object bean, Method method)",
    "source_code": "\t\tpublic InvocableHandlerMethod createInvocableHandlerMethod(Object bean, Method method) {\n\t\t\treturn getMessageHandlerMethodFactory().createInvocableHandlerMethod(bean, method);\n\t\t}"
  },
  "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor#createMethodJmsListenerEndpoint()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate an empty {@link MethodJmsListenerEndpoint} for further\n\t * configuration with provided parameters in {@link #processJmsListener}.\n\t * @return a new {@code MethodJmsListenerEndpoint} or subclass thereof\n\t * @since 4.1.9\n\t * @see MethodJmsListenerEndpoint#createMessageListenerInstance()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "MethodJmsListenerEndpoint",
    "signature": "protected MethodJmsListenerEndpoint createMethodJmsListenerEndpoint()",
    "source_code": "\tprotected MethodJmsListenerEndpoint createMethodJmsListenerEndpoint() {\n\t\treturn new MethodJmsListenerEndpoint();\n\t}"
  },
  "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic int getOrder() {\n\t\treturn LOWEST_PRECEDENCE;\n\t}"
  },
  "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor#postProcessAfterInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (bean instanceof AopInfrastructureBean || bean instanceof JmsListenerContainerFactory ||\n\t\t\t\tbean instanceof JmsListenerEndpointRegistry) {\n\t\t\t// Ignore AOP infrastructure such as scoped proxies.\n\t\t\treturn bean;\n\t\t}\n\n\t\tClass<?> targetClass = AopProxyUtils.ultimateTargetClass(bean);\n\t\tif (!this.nonAnnotatedClasses.contains(targetClass) &&\n\t\t\t\tAnnotationUtils.isCandidateClass(targetClass, JmsListener.class)) {\n\t\t\tMap<Method, Set<JmsListener>> annotatedMethods = MethodIntrospector.selectMethods(targetClass,\n\t\t\t\t\t(MethodIntrospector.MetadataLookup<Set<JmsListener>>) method -> {\n\t\t\t\t\t\tSet<JmsListener> listenerMethods = AnnotatedElementUtils.getMergedRepeatableAnnotations(\n\t\t\t\t\t\t\t\tmethod, JmsListener.class, JmsListeners.class);\n\t\t\t\t\t\treturn (!listenerMethods.isEmpty() ? listenerMethods : null);\n\t\t\t\t\t});\n\t\t\tif (annotatedMethods.isEmpty()) {\n\t\t\t\tthis.nonAnnotatedClasses.add(targetClass);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"No @JmsListener annotations found on bean type: \" + targetClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Non-empty set of methods\n\t\t\t\tannotatedMethods.forEach((method, listeners) ->\n\t\t\t\t\t\tlisteners.forEach(listener -> processJmsListener(listener, method, bean)));\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(annotatedMethods.size() + \" @JmsListener methods processed on bean '\" + beanName +\n\t\t\t\t\t\t\t\"': \" + annotatedMethods);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor#postProcessBeforeInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t}"
  },
  "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor#processJmsListener(jmsListener,mostSpecificMethod,bean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given {@link JmsListener} annotation on the given method,\n\t * registering a corresponding endpoint for the given bean instance.\n\t * @param jmsListener the annotation to process\n\t * @param mostSpecificMethod the annotated method\n\t * @param bean the instance to invoke the method on\n\t * @see #createMethodJmsListenerEndpoint()\n\t * @see JmsListenerEndpointRegistrar#registerEndpoint\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jmsListener",
      "mostSpecificMethod",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "protected void processJmsListener(JmsListener jmsListener, Method mostSpecificMethod, Object bean)",
    "source_code": "\tprotected void processJmsListener(JmsListener jmsListener, Method mostSpecificMethod, Object bean) {\n\t\tMethod invocableMethod = AopUtils.selectInvocableMethod(mostSpecificMethod, bean.getClass());\n\n\t\tMethodJmsListenerEndpoint endpoint = createMethodJmsListenerEndpoint();\n\t\tendpoint.setBean(bean);\n\t\tendpoint.setMethod(invocableMethod);\n\t\tendpoint.setMostSpecificMethod(mostSpecificMethod);\n\t\tendpoint.setMessageHandlerMethodFactory(this.messageHandlerMethodFactory);\n\t\tendpoint.setEmbeddedValueResolver(this.embeddedValueResolver);\n\t\tendpoint.setBeanFactory(this.beanFactory);\n\t\tendpoint.setId(getEndpointId(jmsListener));\n\t\tendpoint.setDestination(resolve(jmsListener.destination()));\n\t\tif (StringUtils.hasText(jmsListener.selector())) {\n\t\t\tendpoint.setSelector(resolve(jmsListener.selector()));\n\t\t}\n\t\tif (StringUtils.hasText(jmsListener.subscription())) {\n\t\t\tendpoint.setSubscription(resolve(jmsListener.subscription()));\n\t\t}\n\t\tif (StringUtils.hasText(jmsListener.concurrency())) {\n\t\t\tendpoint.setConcurrency(resolve(jmsListener.concurrency()));\n\t\t}\n\n\t\tJmsListenerContainerFactory<?> factory = null;\n\t\tString containerFactoryBeanName = resolve(jmsListener.containerFactory());\n\t\tif (StringUtils.hasText(containerFactoryBeanName)) {\n\t\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to obtain container factory by bean name\");\n\t\t\ttry {\n\t\t\t\tfactory = this.beanFactory.getBean(containerFactoryBeanName, JmsListenerContainerFactory.class);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\tthrow new BeanInitializationException(\"Could not register JMS listener endpoint on [\" +\n\t\t\t\t\t\tmostSpecificMethod + \"], no \" + JmsListenerContainerFactory.class.getSimpleName() +\n\t\t\t\t\t\t\" with id '\" + containerFactoryBeanName + \"' was found in the application context\", ex);\n\t\t\t}\n\t\t}\n\n\t\tthis.registrar.registerEndpoint(endpoint, factory);\n\t}"
  },
  "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Making a {@link BeanFactory} available is optional; if not set,\n\t * {@link JmsListenerConfigurer} beans won't get autodetected and an\n\t * {@link #setEndpointRegistry endpoint registry} has to be explicitly configured.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tif (beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tthis.embeddedValueResolver = new EmbeddedValueResolver(cbf);\n\t\t}\n\t\tthis.registrar.setBeanFactory(beanFactory);\n\t}"
  },
  "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor#setContainerFactoryBeanName(containerFactoryBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the {@link JmsListenerContainerFactory} to use by default.\n\t * <p>If none is specified, \"jmsListenerContainerFactory\" is assumed to be defined.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "containerFactoryBeanName"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "public void setContainerFactoryBeanName(String containerFactoryBeanName)",
    "source_code": "\tpublic void setContainerFactoryBeanName(String containerFactoryBeanName) {\n\t\tthis.containerFactoryBeanName = containerFactoryBeanName;\n\t}"
  },
  "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor#setEndpointRegistry(endpointRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link JmsListenerEndpointRegistry} that will hold the created\n\t * endpoint and manage the lifecycle of the related listener container.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpointRegistry"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "public void setEndpointRegistry(JmsListenerEndpointRegistry endpointRegistry)",
    "source_code": "\tpublic void setEndpointRegistry(JmsListenerEndpointRegistry endpointRegistry) {\n\t\tthis.endpointRegistry = endpointRegistry;\n\t}"
  },
  "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor#setMessageHandlerMethodFactory(messageHandlerMethodFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageHandlerMethodFactory"
    ],
    "position": {
      "column": 1,
      "line": 344
    },
    "return": "void",
    "signature": "public void setMessageHandlerMethodFactory(MessageHandlerMethodFactory messageHandlerMethodFactory)",
    "source_code": "\t\tpublic void setMessageHandlerMethodFactory(MessageHandlerMethodFactory messageHandlerMethodFactory) {\n\t\t\tthis.messageHandlerMethodFactory = messageHandlerMethodFactory;\n\t\t}"
  },
  "org.springframework.jms.annotation.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.jms.config.AbstractJmsListenerEndpoint": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Base model for a JMS listener endpoint.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 4.1\n * @see MethodJmsListenerEndpoint\n * @see SimpleJmsListenerEndpoint\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class AbstractJmsListenerEndpoint",
    "source_code": "public abstract class AbstractJmsListenerEndpoint implements JmsListenerEndpoint {\n\n\tprivate String id = \"\";\n\n\t@Nullable\n\tprivate String destination;\n\n\t@Nullable\n\tprivate String subscription;\n\n\t@Nullable\n\tprivate String selector;\n\n\t@Nullable\n\tprivate String concurrency;\n\n\n\t/**\n\t * Set a custom id for this endpoint.\n\t */\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\t/**\n\t * Return the id of this endpoint (possibly generated).\n\t */\n\t@Override\n\tpublic String getId() {\n\t\treturn this.id;\n\t}\n\n\t/**\n\t * Set the name of the destination for this endpoint.\n\t */\n\tpublic void setDestination(@Nullable String destination) {\n\t\tthis.destination = destination;\n\t}\n\n\t/**\n\t * Return the name of the destination for this endpoint.\n\t */\n\t@Nullable\n\tpublic String getDestination() {\n\t\treturn this.destination;\n\t}\n\n\t/**\n\t * Set the name for the durable subscription.\n\t */\n\tpublic void setSubscription(@Nullable String subscription) {\n\t\tthis.subscription = subscription;\n\t}\n\n\t/**\n\t * Return the name for the durable subscription, if any.\n\t */\n\t@Nullable\n\tpublic String getSubscription() {\n\t\treturn this.subscription;\n\t}\n\n\t/**\n\t * Set the JMS message selector expression.\n\t * <p>See the JMS specification for a detailed definition of selector expressions.\n\t */\n\tpublic void setSelector(@Nullable String selector) {\n\t\tthis.selector = selector;\n\t}\n\n\t/**\n\t * Return the JMS message selector expression, if any.\n\t */\n\t@Nullable\n\tpublic String getSelector() {\n\t\treturn this.selector;\n\t}\n\n\t/**\n\t * Set a concurrency for the listener, if any.\n\t * <p>The concurrency limits can be a \"lower-upper\" String, e.g. \"5-10\", or a simple\n\t * upper limit String, e.g. \"10\" (the lower limit will be 1 in this case).\n\t * <p>The underlying container may or may not support all features. For instance, it\n\t * may not be able to scale: in that case only the upper value is used.\n\t */\n\tpublic void setConcurrency(@Nullable String concurrency) {\n\t\tthis.concurrency = concurrency;\n\t}\n\n\t/**\n\t * Return the concurrency for the listener, if any.\n\t */\n\t@Nullable\n\tpublic String getConcurrency() {\n\t\treturn this.concurrency;\n\t}\n\n\n\t@Override\n\tpublic void setupListenerContainer(MessageListenerContainer listenerContainer) {\n\t\tif (listenerContainer instanceof AbstractMessageListenerContainer abstractContainer) {\n\t\t\tsetupJmsListenerContainer(abstractContainer);\n\t\t}\n\t\telse {\n\t\t\tnew JcaEndpointConfigurer().configureEndpoint(listenerContainer);\n\t\t}\n\t}\n\n\tprivate void setupJmsListenerContainer(AbstractMessageListenerContainer listenerContainer) {\n\t\tif (StringUtils.hasText(getId())) {\n\t\t\tlistenerContainer.setBeanName(getId());\n\t\t}\n\t\tif (getDestination() != null) {\n\t\t\tlistenerContainer.setDestinationName(getDestination());\n\t\t}\n\t\tif (getSubscription() != null) {\n\t\t\tlistenerContainer.setSubscriptionName(getSubscription());\n\t\t}\n\t\tif (getSelector() != null) {\n\t\t\tlistenerContainer.setMessageSelector(getSelector());\n\t\t}\n\t\tif (getConcurrency() != null) {\n\t\t\tlistenerContainer.setConcurrency(getConcurrency());\n\t\t}\n\t\tsetupMessageListener(listenerContainer);\n\t}\n\n\t/**\n\t * Create a {@link MessageListener} that is able to serve this endpoint for the\n\t * specified container.\n\t */\n\tprotected abstract MessageListener createMessageListener(MessageListenerContainer container);\n\n\tprivate void setupMessageListener(MessageListenerContainer container) {\n\t\tcontainer.setupMessageListener(createMessageListener(container));\n\t}\n\n\t/**\n\t * Return a description for this endpoint.\n\t * <p>Available to subclasses, for inclusion in their {@code toString()} result.\n\t */\n\tprotected StringBuilder getEndpointDescription() {\n\t\tStringBuilder result = new StringBuilder();\n\t\treturn result.append(getClass().getSimpleName()).append('[').append(this.id).append(\"] destination=\").\n\t\t\t\tappend(this.destination).append(\"' | subscription='\").append(this.subscription).\n\t\t\t\tappend(\" | selector='\").append(this.selector).append('\\'');\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getEndpointDescription().toString();\n\t}\n\n\n\t/**\n\t * Inner class to avoid a hard dependency on the JCA API.\n\t */\n\tprivate class JcaEndpointConfigurer {\n\n\t\tpublic void configureEndpoint(Object listenerContainer) {\n\t\t\tif (listenerContainer instanceof JmsMessageEndpointManager endpointManager) {\n\t\t\t\tsetupJcaMessageContainer(endpointManager);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Could not configure endpoint with the specified container '\" +\n\t\t\t\t\t\tlistenerContainer + \"' Only JMS (\" + AbstractMessageListenerContainer.class.getName() +\n\t\t\t\t\t\t\" subclass) or JCA (\" + JmsMessageEndpointManager.class.getName() + \") are supported.\");\n\t\t\t}\n\t\t}\n\n\t\tprivate void setupJcaMessageContainer(JmsMessageEndpointManager container) {\n\t\t\tJmsActivationSpecConfig activationSpecConfig = container.getActivationSpecConfig();\n\t\t\tif (activationSpecConfig == null) {\n\t\t\t\tactivationSpecConfig = new JmsActivationSpecConfig();\n\t\t\t\tcontainer.setActivationSpecConfig(activationSpecConfig);\n\t\t\t}\n\t\t\tif (getDestination() != null) {\n\t\t\t\tactivationSpecConfig.setDestinationName(getDestination());\n\t\t\t}\n\t\t\tif (getSubscription() != null) {\n\t\t\t\tactivationSpecConfig.setSubscriptionName(getSubscription());\n\t\t\t}\n\t\t\tif (getSelector() != null) {\n\t\t\t\tactivationSpecConfig.setMessageSelector(getSelector());\n\t\t\t}\n\t\t\tif (getConcurrency() != null) {\n\t\t\t\tactivationSpecConfig.setConcurrency(getConcurrency());\n\t\t\t}\n\t\t\tsetupMessageListener(container);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jms.config.AbstractJmsListenerEndpoint#configureEndpoint(listenerContainer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "listenerContainer"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "void",
    "signature": "public void configureEndpoint(Object listenerContainer)",
    "source_code": "\t\tpublic void configureEndpoint(Object listenerContainer) {\n\t\t\tif (listenerContainer instanceof JmsMessageEndpointManager endpointManager) {\n\t\t\t\tsetupJcaMessageContainer(endpointManager);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Could not configure endpoint with the specified container '\" +\n\t\t\t\t\t\tlistenerContainer + \"' Only JMS (\" + AbstractMessageListenerContainer.class.getName() +\n\t\t\t\t\t\t\" subclass) or JCA (\" + JmsMessageEndpointManager.class.getName() + \") are supported.\");\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jms.config.AbstractJmsListenerEndpoint#createMessageListener(container)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link MessageListener} that is able to serve this endpoint for the\n\t * specified container.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "container"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "MessageListener",
    "signature": "protected MessageListener createMessageListener(MessageListenerContainer container)",
    "source_code": "\tprotected abstract MessageListener createMessageListener(MessageListenerContainer container);"
  },
  "org.springframework.jms.config.AbstractJmsListenerEndpoint#getConcurrency()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the concurrency for the listener, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "String",
    "signature": "public String getConcurrency()",
    "source_code": "\tpublic String getConcurrency() {\n\t\treturn this.concurrency;\n\t}"
  },
  "org.springframework.jms.config.AbstractJmsListenerEndpoint#getDestination()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the destination for this endpoint.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "String",
    "signature": "public String getDestination()",
    "source_code": "\tpublic String getDestination() {\n\t\treturn this.destination;\n\t}"
  },
  "org.springframework.jms.config.AbstractJmsListenerEndpoint#getEndpointDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a description for this endpoint.\n\t * <p>Available to subclasses, for inclusion in their {@code toString()} result.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "StringBuilder",
    "signature": "protected StringBuilder getEndpointDescription()",
    "source_code": "\tprotected StringBuilder getEndpointDescription() {\n\t\tStringBuilder result = new StringBuilder();\n\t\treturn result.append(getClass().getSimpleName()).append('[').append(this.id).append(\"] destination=\").\n\t\t\t\tappend(this.destination).append(\"' | subscription='\").append(this.subscription).\n\t\t\t\tappend(\" | selector='\").append(this.selector).append('\\'');\n\t}"
  },
  "org.springframework.jms.config.AbstractJmsListenerEndpoint#getId()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the id of this endpoint (possibly generated).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "String",
    "signature": "public String getId()",
    "source_code": "\tpublic String getId() {\n\t\treturn this.id;\n\t}"
  },
  "org.springframework.jms.config.AbstractJmsListenerEndpoint#getSelector()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JMS message selector expression, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "String",
    "signature": "public String getSelector()",
    "source_code": "\tpublic String getSelector() {\n\t\treturn this.selector;\n\t}"
  },
  "org.springframework.jms.config.AbstractJmsListenerEndpoint#getSubscription()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name for the durable subscription, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "String",
    "signature": "public String getSubscription()",
    "source_code": "\tpublic String getSubscription() {\n\t\treturn this.subscription;\n\t}"
  },
  "org.springframework.jms.config.AbstractJmsListenerEndpoint#setConcurrency(concurrency)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a concurrency for the listener, if any.\n\t * <p>The concurrency limits can be a \"lower-upper\" String, e.g. \"5-10\", or a simple\n\t * upper limit String, e.g. \"10\" (the lower limit will be 1 in this case).\n\t * <p>The underlying container may or may not support all features. For instance, it\n\t * may not be able to scale: in that case only the upper value is used.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "concurrency"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void setConcurrency(@Nullable String concurrency)",
    "source_code": "\tpublic void setConcurrency(@Nullable String concurrency) {\n\t\tthis.concurrency = concurrency;\n\t}"
  },
  "org.springframework.jms.config.AbstractJmsListenerEndpoint#setDestination(destination)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the destination for this endpoint.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "public void setDestination(@Nullable String destination)",
    "source_code": "\tpublic void setDestination(@Nullable String destination) {\n\t\tthis.destination = destination;\n\t}"
  },
  "org.springframework.jms.config.AbstractJmsListenerEndpoint#setId(id)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a custom id for this endpoint.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "id"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "void",
    "signature": "public void setId(String id)",
    "source_code": "\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}"
  },
  "org.springframework.jms.config.AbstractJmsListenerEndpoint#setSelector(selector)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JMS message selector expression.\n\t * <p>See the JMS specification for a detailed definition of selector expressions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "selector"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void setSelector(@Nullable String selector)",
    "source_code": "\tpublic void setSelector(@Nullable String selector) {\n\t\tthis.selector = selector;\n\t}"
  },
  "org.springframework.jms.config.AbstractJmsListenerEndpoint#setSubscription(subscription)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name for the durable subscription.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void setSubscription(@Nullable String subscription)",
    "source_code": "\tpublic void setSubscription(@Nullable String subscription) {\n\t\tthis.subscription = subscription;\n\t}"
  },
  "org.springframework.jms.config.AbstractJmsListenerEndpoint#setupListenerContainer(listenerContainer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "listenerContainer"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "public void setupListenerContainer(MessageListenerContainer listenerContainer)",
    "source_code": "\tpublic void setupListenerContainer(MessageListenerContainer listenerContainer) {\n\t\tif (listenerContainer instanceof AbstractMessageListenerContainer abstractContainer) {\n\t\t\tsetupJmsListenerContainer(abstractContainer);\n\t\t}\n\t\telse {\n\t\t\tnew JcaEndpointConfigurer().configureEndpoint(listenerContainer);\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.AbstractJmsListenerEndpoint#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getEndpointDescription().toString();\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Helper bean for registering {@link JmsListenerEndpoint} with a {@link JmsListenerEndpointRegistry}.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 4.1\n * @see org.springframework.jms.annotation.JmsListenerConfigurer\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class JmsListenerEndpointRegistrar",
    "source_code": "public class JmsListenerEndpointRegistrar implements BeanFactoryAware, InitializingBean {\n\n\t@Nullable\n\tprivate JmsListenerEndpointRegistry endpointRegistry;\n\n\t@Nullable\n\tprivate MessageHandlerMethodFactory messageHandlerMethodFactory;\n\n\t@Nullable\n\tprivate JmsListenerContainerFactory<?> containerFactory;\n\n\t@Nullable\n\tprivate String containerFactoryBeanName;\n\n\t@Nullable\n\tprivate BeanFactory beanFactory;\n\n\tprivate final List<JmsListenerEndpointDescriptor> endpointDescriptors = new ArrayList<>();\n\n\tprivate boolean startImmediately;\n\n\tprivate Object mutex = this.endpointDescriptors;\n\n\n\t/**\n\t * Set the {@link JmsListenerEndpointRegistry} instance to use.\n\t */\n\tpublic void setEndpointRegistry(@Nullable JmsListenerEndpointRegistry endpointRegistry) {\n\t\tthis.endpointRegistry = endpointRegistry;\n\t}\n\n\t/**\n\t * Return the {@link JmsListenerEndpointRegistry} instance for this\n\t * registrar, may be {@code null}.\n\t */\n\t@Nullable\n\tpublic JmsListenerEndpointRegistry getEndpointRegistry() {\n\t\treturn this.endpointRegistry;\n\t}\n\n\t/**\n\t * Set the {@link MessageHandlerMethodFactory} to use to configure the message\n\t * listener responsible to serve an endpoint detected by this processor.\n\t * <p>By default, {@link DefaultMessageHandlerMethodFactory} is used and it\n\t * can be configured further to support additional method arguments\n\t * or to customize conversion and validation support. See\n\t * {@link DefaultMessageHandlerMethodFactory} javadoc for more details.\n\t */\n\tpublic void setMessageHandlerMethodFactory(@Nullable MessageHandlerMethodFactory messageHandlerMethodFactory) {\n\t\tthis.messageHandlerMethodFactory = messageHandlerMethodFactory;\n\t}\n\n\t/**\n\t * Return the custom {@link MessageHandlerMethodFactory} to use, if any.\n\t */\n\t@Nullable\n\tpublic MessageHandlerMethodFactory getMessageHandlerMethodFactory() {\n\t\treturn this.messageHandlerMethodFactory;\n\t}\n\n\t/**\n\t * Set the {@link JmsListenerContainerFactory} to use in case a {@link JmsListenerEndpoint}\n\t * is registered with a {@code null} container factory.\n\t * <p>Alternatively, the bean name of the {@link JmsListenerContainerFactory} to use\n\t * can be specified for a lazy lookup, see {@link #setContainerFactoryBeanName}.\n\t */\n\tpublic void setContainerFactory(JmsListenerContainerFactory<?> containerFactory) {\n\t\tthis.containerFactory = containerFactory;\n\t}\n\n\t/**\n\t * Set the bean name of the {@link JmsListenerContainerFactory} to use in case\n\t * a {@link JmsListenerEndpoint} is registered with a {@code null} container factory.\n\t * Alternatively, the container factory instance can be registered directly:\n\t * see {@link #setContainerFactory(JmsListenerContainerFactory)}.\n\t * @see #setBeanFactory\n\t */\n\tpublic void setContainerFactoryBeanName(String containerFactoryBeanName) {\n\t\tthis.containerFactoryBeanName = containerFactoryBeanName;\n\t}\n\n\t/**\n\t * A {@link BeanFactory} only needs to be available in conjunction with\n\t * {@link #setContainerFactoryBeanName}.\n\t */\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tif (beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tthis.mutex = cbf.getSingletonMutex();\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\tregisterAllEndpoints();\n\t}\n\n\tprotected void registerAllEndpoints() {\n\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\tsynchronized (this.mutex) {\n\t\t\tfor (JmsListenerEndpointDescriptor descriptor : this.endpointDescriptors) {\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(\n\t\t\t\t\t\tdescriptor.endpoint, resolveContainerFactory(descriptor));\n\t\t\t}\n\t\t\tthis.startImmediately = true;  // trigger immediate startup\n\t\t}\n\t}\n\n\tprivate JmsListenerContainerFactory<?> resolveContainerFactory(JmsListenerEndpointDescriptor descriptor) {\n\t\tif (descriptor.containerFactory != null) {\n\t\t\treturn descriptor.containerFactory;\n\t\t}\n\t\telse if (this.containerFactory != null) {\n\t\t\treturn this.containerFactory;\n\t\t}\n\t\telse if (this.containerFactoryBeanName != null) {\n\t\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to obtain container factory by bean name\");\n\t\t\t// Consider changing this if live change of the factory is required...\n\t\t\tthis.containerFactory = this.beanFactory.getBean(\n\t\t\t\t\tthis.containerFactoryBeanName, JmsListenerContainerFactory.class);\n\t\t\treturn this.containerFactory;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Could not resolve the \" +\n\t\t\t\t\tJmsListenerContainerFactory.class.getSimpleName() + \" to use for [\" +\n\t\t\t\t\tdescriptor.endpoint + \"] no factory was given and no default is set.\");\n\t\t}\n\t}\n\n\t/**\n\t * Register a new {@link JmsListenerEndpoint} alongside the\n\t * {@link JmsListenerContainerFactory} to use to create the underlying container.\n\t * <p>The {@code factory} may be {@code null} if the default factory should be\n\t * used for the supplied endpoint.\n\t */\n\tpublic void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory) {\n\t\tAssert.notNull(endpoint, \"Endpoint must not be null\");\n\t\tAssert.hasText(endpoint.getId(), \"Endpoint id must be set\");\n\n\t\t// Factory may be null, we defer the resolution right before actually creating the container\n\t\tJmsListenerEndpointDescriptor descriptor = new JmsListenerEndpointDescriptor(endpoint, factory);\n\n\t\tsynchronized (this.mutex) {\n\t\t\tif (this.startImmediately) {  // register and start immediately\n\t\t\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(descriptor.endpoint,\n\t\t\t\t\t\tresolveContainerFactory(descriptor), true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.endpointDescriptors.add(descriptor);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Register a new {@link JmsListenerEndpoint} using the default\n\t * {@link JmsListenerContainerFactory} to create the underlying container.\n\t * @see #setContainerFactory(JmsListenerContainerFactory)\n\t * @see #registerEndpoint(JmsListenerEndpoint, JmsListenerContainerFactory)\n\t */\n\tpublic void registerEndpoint(JmsListenerEndpoint endpoint) {\n\t\tregisterEndpoint(endpoint, null);\n\t}\n\n\n\tprivate static class JmsListenerEndpointDescriptor {\n\n\t\tpublic final JmsListenerEndpoint endpoint;\n\n\t\t@Nullable\n\t\tpublic final JmsListenerContainerFactory<?> containerFactory;\n\n\t\tpublic JmsListenerEndpointDescriptor(JmsListenerEndpoint endpoint,\n\t\t\t\t@Nullable JmsListenerContainerFactory<?> containerFactory) {\n\n\t\t\tthis.endpoint = endpoint;\n\t\t\tthis.containerFactory = containerFactory;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tregisterAllEndpoints();\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#getEndpointRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link JmsListenerEndpointRegistry} instance for this\n\t * registrar, may be {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "JmsListenerEndpointRegistry",
    "signature": "public JmsListenerEndpointRegistry getEndpointRegistry()",
    "source_code": "\tpublic JmsListenerEndpointRegistry getEndpointRegistry() {\n\t\treturn this.endpointRegistry;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#getMessageHandlerMethodFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the custom {@link MessageHandlerMethodFactory} to use, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "MessageHandlerMethodFactory",
    "signature": "public MessageHandlerMethodFactory getMessageHandlerMethodFactory()",
    "source_code": "\tpublic MessageHandlerMethodFactory getMessageHandlerMethodFactory() {\n\t\treturn this.messageHandlerMethodFactory;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#registerAllEndpoints()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "protected void registerAllEndpoints()",
    "source_code": "\tprotected void registerAllEndpoints() {\n\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\tsynchronized (this.mutex) {\n\t\t\tfor (JmsListenerEndpointDescriptor descriptor : this.endpointDescriptors) {\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(\n\t\t\t\t\t\tdescriptor.endpoint, resolveContainerFactory(descriptor));\n\t\t\t}\n\t\t\tthis.startImmediately = true;  // trigger immediate startup\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#registerEndpoint(endpoint)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a new {@link JmsListenerEndpoint} using the default\n\t * {@link JmsListenerContainerFactory} to create the underlying container.\n\t * @see #setContainerFactory(JmsListenerContainerFactory)\n\t * @see #registerEndpoint(JmsListenerEndpoint, JmsListenerContainerFactory)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "void",
    "signature": "public void registerEndpoint(JmsListenerEndpoint endpoint)",
    "source_code": "\tpublic void registerEndpoint(JmsListenerEndpoint endpoint) {\n\t\tregisterEndpoint(endpoint, null);\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#registerEndpoint(endpoint,factory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a new {@link JmsListenerEndpoint} alongside the\n\t * {@link JmsListenerContainerFactory} to use to create the underlying container.\n\t * <p>The {@code factory} may be {@code null} if the default factory should be\n\t * used for the supplied endpoint.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "void",
    "signature": "public void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory)",
    "source_code": "\tpublic void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory) {\n\t\tAssert.notNull(endpoint, \"Endpoint must not be null\");\n\t\tAssert.hasText(endpoint.getId(), \"Endpoint id must be set\");\n\n\t\t// Factory may be null, we defer the resolution right before actually creating the container\n\t\tJmsListenerEndpointDescriptor descriptor = new JmsListenerEndpointDescriptor(endpoint, factory);\n\n\t\tsynchronized (this.mutex) {\n\t\t\tif (this.startImmediately) {  // register and start immediately\n\t\t\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(descriptor.endpoint,\n\t\t\t\t\t\tresolveContainerFactory(descriptor), true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.endpointDescriptors.add(descriptor);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A {@link BeanFactory} only needs to be available in conjunction with\n\t * {@link #setContainerFactoryBeanName}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tif (beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tthis.mutex = cbf.getSingletonMutex();\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#setContainerFactory(containerFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link JmsListenerContainerFactory} to use in case a {@link JmsListenerEndpoint}\n\t * is registered with a {@code null} container factory.\n\t * <p>Alternatively, the bean name of the {@link JmsListenerContainerFactory} to use\n\t * can be specified for a lazy lookup, see {@link #setContainerFactoryBeanName}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "containerFactory"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void setContainerFactory(JmsListenerContainerFactory<?> containerFactory)",
    "source_code": "\tpublic void setContainerFactory(JmsListenerContainerFactory<?> containerFactory) {\n\t\tthis.containerFactory = containerFactory;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#setContainerFactoryBeanName(containerFactoryBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the bean name of the {@link JmsListenerContainerFactory} to use in case\n\t * a {@link JmsListenerEndpoint} is registered with a {@code null} container factory.\n\t * Alternatively, the container factory instance can be registered directly:\n\t * see {@link #setContainerFactory(JmsListenerContainerFactory)}.\n\t * @see #setBeanFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "containerFactoryBeanName"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void setContainerFactoryBeanName(String containerFactoryBeanName)",
    "source_code": "\tpublic void setContainerFactoryBeanName(String containerFactoryBeanName) {\n\t\tthis.containerFactoryBeanName = containerFactoryBeanName;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#setEndpointRegistry(endpointRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link JmsListenerEndpointRegistry} instance to use.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpointRegistry"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void setEndpointRegistry(@Nullable JmsListenerEndpointRegistry endpointRegistry)",
    "source_code": "\tpublic void setEndpointRegistry(@Nullable JmsListenerEndpointRegistry endpointRegistry) {\n\t\tthis.endpointRegistry = endpointRegistry;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistrar#setMessageHandlerMethodFactory(messageHandlerMethodFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link MessageHandlerMethodFactory} to use to configure the message\n\t * listener responsible to serve an endpoint detected by this processor.\n\t * <p>By default, {@link DefaultMessageHandlerMethodFactory} is used and it\n\t * can be configured further to support additional method arguments\n\t * or to customize conversion and validation support. See\n\t * {@link DefaultMessageHandlerMethodFactory} javadoc for more details.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageHandlerMethodFactory"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void setMessageHandlerMethodFactory(@Nullable MessageHandlerMethodFactory messageHandlerMethodFactory)",
    "source_code": "\tpublic void setMessageHandlerMethodFactory(@Nullable MessageHandlerMethodFactory messageHandlerMethodFactory) {\n\t\tthis.messageHandlerMethodFactory = messageHandlerMethodFactory;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistry": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Creates the necessary {@link MessageListenerContainer} instances for the\n * registered {@linkplain JmsListenerEndpoint endpoints}. Also manages the\n * lifecycle of the listener containers, in particular within the lifecycle\n * of the application context.\n *\n * <p>Contrary to {@link MessageListenerContainer MessageListenerContainers}\n * created manually, listener containers managed by registry are not beans\n * in the application context and are not candidates for autowiring.\n * Use {@link #getListenerContainers()} if you need to access this registry's\n * listener containers for management purposes. If you need to access to a\n * specific message listener container, use {@link #getListenerContainer(String)}\n * with the id of the endpoint.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 4.1\n * @see JmsListenerEndpoint\n * @see MessageListenerContainer\n * @see JmsListenerContainerFactory\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "signature": "public class JmsListenerEndpointRegistry",
    "source_code": "public class JmsListenerEndpointRegistry implements DisposableBean, SmartLifecycle,"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistry#createListenerContainer(endpoint,factory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create and start a new container using the specified factory.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "endpoint",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "MessageListenerContainer",
    "signature": "protected MessageListenerContainer createListenerContainer(JmsListenerEndpoint endpoint,\n\t\t\tJmsListenerContainerFactory<?> factory)",
    "source_code": "\tprotected MessageListenerContainer createListenerContainer(JmsListenerEndpoint endpoint,"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistry#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t\tfor (MessageListenerContainer listenerContainer : getListenerContainers()) {\n\t\t\tif (listenerContainer instanceof DisposableBean disposableBean) {\n\t\t\t\ttry {\n\t\t\t\t\tdisposableBean.destroy();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tlogger.warn(\"Failed to destroy message listener container\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistry#getListenerContainer(id)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link MessageListenerContainer} with the specified id or\n\t * {@code null} if no such container exists.\n\t * @param id the id of the container\n\t * @return the container or {@code null} if no container with that id exists\n\t * @see JmsListenerEndpoint#getId()\n\t * @see #getListenerContainerIds()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "id"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "MessageListenerContainer",
    "signature": "public MessageListenerContainer getListenerContainer(String id)",
    "source_code": "\tpublic MessageListenerContainer getListenerContainer(String id) {\n\t\tAssert.notNull(id, \"Container identifier must not be null\");\n\t\treturn this.listenerContainers.get(id);\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistry#getListenerContainerIds()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the ids of the managed {@link MessageListenerContainer} instance(s).\n\t * @since 4.2.3\n\t * @see #getListenerContainer(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "Set<String>",
    "signature": "public Set<String> getListenerContainerIds()",
    "source_code": "\tpublic Set<String> getListenerContainerIds() {\n\t\treturn Collections.unmodifiableSet(this.listenerContainers.keySet());\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistry#getListenerContainers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the managed {@link MessageListenerContainer} instance(s).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "Collection<MessageListenerContainer>",
    "signature": "public Collection<MessageListenerContainer> getListenerContainers()",
    "source_code": "\tpublic Collection<MessageListenerContainer> getListenerContainers() {\n\t\treturn Collections.unmodifiableCollection(this.listenerContainers.values());\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistry#getPhase()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "int",
    "signature": "public int getPhase()",
    "source_code": "\tpublic int getPhase() {\n\t\treturn this.phase;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistry#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() {\n\t\tfor (MessageListenerContainer listenerContainer : getListenerContainers()) {\n\t\t\tif (listenerContainer.isRunning()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistry#onApplicationEvent(event)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void onApplicationEvent(ContextRefreshedEvent event)",
    "source_code": "\tpublic void onApplicationEvent(ContextRefreshedEvent event) {\n\t\tif (event.getApplicationContext() == this.applicationContext) {\n\t\t\tthis.contextRefreshed = true;\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistry#registerListenerContainer(endpoint,factory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a message listener container for the given {@link JmsListenerEndpoint}.\n\t * <p>This create the necessary infrastructure to honor that endpoint\n\t * with regard to its configuration.\n\t * @param endpoint the endpoint to add\n\t * @param factory the listener factory to use\n\t * @see #registerListenerContainer(JmsListenerEndpoint, JmsListenerContainerFactory, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void registerListenerContainer(JmsListenerEndpoint endpoint, JmsListenerContainerFactory<?> factory)",
    "source_code": "\tpublic void registerListenerContainer(JmsListenerEndpoint endpoint, JmsListenerContainerFactory<?> factory) {\n\t\tregisterListenerContainer(endpoint, factory, false);\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistry#registerListenerContainer(endpoint,factory,startImmediately)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a message listener container for the given {@link JmsListenerEndpoint}.\n\t * <p>This create the necessary infrastructure to honor that endpoint\n\t * with regard to its configuration.\n\t * <p>The {@code startImmediately} flag determines if the container should be\n\t * started immediately.\n\t * @param endpoint the endpoint to add\n\t * @param factory the listener factory to use\n\t * @param startImmediately start the container immediately if necessary\n\t * @see #getListenerContainers()\n\t * @see #getListenerContainer(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint",
      "factory",
      "startImmediately"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "public void registerListenerContainer(JmsListenerEndpoint endpoint, JmsListenerContainerFactory<?> factory,\n\t\t\tboolean startImmediately)",
    "source_code": "\tpublic void registerListenerContainer(JmsListenerEndpoint endpoint, JmsListenerContainerFactory<?> factory,"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistry#run()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "void",
    "signature": "public void run()",
    "source_code": "\t\tpublic void run() {\n\t\t\tif (this.count.decrementAndGet() == 0) {\n\t\t\t\tthis.finishCallback.run();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistry#setApplicationContext(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void setApplicationContext(ApplicationContext applicationContext)",
    "source_code": "\tpublic void setApplicationContext(ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistry#start()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() {\n\t\tfor (MessageListenerContainer listenerContainer : getListenerContainers()) {\n\t\t\tstartIfNecessary(listenerContainer);\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistry#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() {\n\t\tfor (MessageListenerContainer listenerContainer : getListenerContainers()) {\n\t\t\tlistenerContainer.stop();\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.JmsListenerEndpointRegistry#stop(callback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "void",
    "signature": "public void stop(Runnable callback)",
    "source_code": "\tpublic void stop(Runnable callback) {\n\t\tCollection<MessageListenerContainer> listenerContainers = getListenerContainers();\n\t\tAggregatingCallback aggregatingCallback = new AggregatingCallback(listenerContainers.size(), callback);\n\t\tfor (MessageListenerContainer listenerContainer : listenerContainers) {\n\t\t\tlistenerContainer.stop(aggregatingCallback);\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.MethodJmsListenerEndpoint": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@link JmsListenerEndpoint} providing the method to invoke to process\n * an incoming message for this endpoint.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 4.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class MethodJmsListenerEndpoint",
    "source_code": "public class MethodJmsListenerEndpoint extends AbstractJmsListenerEndpoint implements BeanFactoryAware {\n\n\t@Nullable\n\tprivate Object bean;\n\n\t@Nullable\n\tprivate Method method;\n\n\t@Nullable\n\tprivate Method mostSpecificMethod;\n\n\t@Nullable\n\tprivate MessageHandlerMethodFactory messageHandlerMethodFactory;\n\n\t@Nullable\n\tprivate StringValueResolver embeddedValueResolver;\n\n\n\t/**\n\t * Set the actual bean instance to invoke this endpoint method on.\n\t */\n\tpublic void setBean(@Nullable Object bean) {\n\t\tthis.bean = bean;\n\t}\n\n\t@Nullable\n\tpublic Object getBean() {\n\t\treturn this.bean;\n\t}\n\n\t/**\n\t * Set the method to invoke for processing a message managed by this endpoint.\n\t */\n\tpublic void setMethod(@Nullable Method method) {\n\t\tthis.method = method;\n\t}\n\n\t@Nullable\n\tpublic Method getMethod() {\n\t\treturn this.method;\n\t}\n\n\t/**\n\t * Set the most specific method known for this endpoint's declaration.\n\t * <p>In case of a proxy, this will be the method on the target class\n\t * (if annotated itself, that is, if not just annotated in an interface).\n\t * @since 4.2.3\n\t */\n\tpublic void setMostSpecificMethod(@Nullable Method mostSpecificMethod) {\n\t\tthis.mostSpecificMethod = mostSpecificMethod;\n\t}\n\n\t@Nullable\n\tpublic Method getMostSpecificMethod() {\n\t\tif (this.mostSpecificMethod != null) {\n\t\t\treturn this.mostSpecificMethod;\n\t\t}\n\t\tMethod method = getMethod();\n\t\tif (method != null) {\n\t\t\tObject bean = getBean();\n\t\t\tif (AopUtils.isAopProxy(bean)) {\n\t\t\t\tClass<?> targetClass = AopProxyUtils.ultimateTargetClass(bean);\n\t\t\t\tmethod = AopUtils.getMostSpecificMethod(method, targetClass);\n\t\t\t}\n\t\t}\n\t\treturn method;\n\t}\n\n\t/**\n\t * Set the {@link MessageHandlerMethodFactory} to use to build the\n\t * {@link InvocableHandlerMethod} responsible to manage the invocation\n\t * of this endpoint.\n\t */\n\tpublic void setMessageHandlerMethodFactory(MessageHandlerMethodFactory messageHandlerMethodFactory) {\n\t\tthis.messageHandlerMethodFactory = messageHandlerMethodFactory;\n\t}\n\n\t/**\n\t * Set a value resolver for embedded placeholders and expressions.\n\t */\n\tpublic void setEmbeddedValueResolver(@Nullable StringValueResolver embeddedValueResolver) {\n\t\tthis.embeddedValueResolver = embeddedValueResolver;\n\t}\n\n\t/**\n\t * Set the {@link BeanFactory} to use to resolve expressions (may be {@code null}).\n\t */\n\t@Override\n\tpublic void setBeanFactory(@Nullable BeanFactory beanFactory) {\n\t\tif (this.embeddedValueResolver == null && beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tthis.embeddedValueResolver = new EmbeddedValueResolver(cbf);\n\t\t}\n\t}\n\n\n\t@Override\n\tprotected MessagingMessageListenerAdapter createMessageListener(MessageListenerContainer container) {\n\t\tAssert.state(this.messageHandlerMethodFactory != null,\n\t\t\t\t\"Could not create message listener - MessageHandlerMethodFactory not set\");\n\t\tMessagingMessageListenerAdapter messageListener = createMessageListenerInstance();\n\t\tObject bean = getBean();\n\t\tMethod method = getMethod();\n\t\tAssert.state(bean != null && method != null, \"No bean+method set on endpoint\");\n\t\tInvocableHandlerMethod invocableHandlerMethod =\n\t\t\t\tthis.messageHandlerMethodFactory.createInvocableHandlerMethod(bean, method);\n\t\tmessageListener.setHandlerMethod(invocableHandlerMethod);\n\t\tString responseDestination = getDefaultResponseDestination();\n\t\tif (StringUtils.hasText(responseDestination)) {\n\t\t\tif (container.isReplyPubSubDomain()) {\n\t\t\t\tmessageListener.setDefaultResponseTopicName(responseDestination);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmessageListener.setDefaultResponseQueueName(responseDestination);\n\t\t\t}\n\t\t}\n\t\tQosSettings responseQosSettings = container.getReplyQosSettings();\n\t\tif (responseQosSettings != null) {\n\t\t\tmessageListener.setResponseQosSettings(responseQosSettings);\n\t\t}\n\t\tMessageConverter messageConverter = container.getMessageConverter();\n\t\tif (messageConverter != null) {\n\t\t\tmessageListener.setMessageConverter(messageConverter);\n\t\t}\n\t\tDestinationResolver destinationResolver = container.getDestinationResolver();\n\t\tif (destinationResolver != null) {\n\t\t\tmessageListener.setDestinationResolver(destinationResolver);\n\t\t}\n\t\treturn messageListener;\n\t}\n\n\t/**\n\t * Create an empty {@link MessagingMessageListenerAdapter} instance.\n\t * @return a new {@code MessagingMessageListenerAdapter} or subclass thereof\n\t */\n\tprotected MessagingMessageListenerAdapter createMessageListenerInstance() {\n\t\treturn new MessagingMessageListenerAdapter();\n\t}\n\n\t/**\n\t * Return the default response destination, if any.\n\t */\n\t@Nullable\n\tprotected String getDefaultResponseDestination() {\n\t\tMethod specificMethod = getMostSpecificMethod();\n\t\tif (specificMethod == null) {\n\t\t\treturn null;\n\t\t}\n\t\tSendTo ann = getSendTo(specificMethod);\n\t\tif (ann != null) {\n\t\t\tObject[] destinations = ann.value();\n\t\t\tif (destinations.length != 1) {\n\t\t\t\tthrow new IllegalStateException(\"Invalid @\" + SendTo.class.getSimpleName() + \" annotation on '\" +\n\t\t\t\t\t\tspecificMethod + \"' one destination must be set (got \" + Arrays.toString(destinations) + \")\");\n\t\t\t}\n\t\t\treturn resolve((String) destinations[0]);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Nullable\n\tprivate SendTo getSendTo(Method specificMethod) {\n\t\tSendTo ann = AnnotatedElementUtils.findMergedAnnotation(specificMethod, SendTo.class);\n\t\tif (ann == null) {\n\t\t\tann = AnnotatedElementUtils.findMergedAnnotation(specificMethod.getDeclaringClass(), SendTo.class);\n\t\t}\n\t\treturn ann;\n\t}\n\n\t@Nullable\n\tprivate String resolve(String value) {\n\t\treturn (this.embeddedValueResolver != null ? this.embeddedValueResolver.resolveStringValue(value) : value);\n\t}\n\n\n\t@Override\n\tprotected StringBuilder getEndpointDescription() {\n\t\treturn super.getEndpointDescription()\n\t\t\t\t.append(\" | bean='\").append(this.bean).append('\\'')\n\t\t\t\t.append(\" | method='\").append(this.method).append('\\'');\n\t}\n\n}"
  },
  "org.springframework.jms.config.MethodJmsListenerEndpoint#createMessageListener(container)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "container"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "MessagingMessageListenerAdapter",
    "signature": "protected MessagingMessageListenerAdapter createMessageListener(MessageListenerContainer container)",
    "source_code": "\tprotected MessagingMessageListenerAdapter createMessageListener(MessageListenerContainer container) {\n\t\tAssert.state(this.messageHandlerMethodFactory != null,\n\t\t\t\t\"Could not create message listener - MessageHandlerMethodFactory not set\");\n\t\tMessagingMessageListenerAdapter messageListener = createMessageListenerInstance();\n\t\tObject bean = getBean();\n\t\tMethod method = getMethod();\n\t\tAssert.state(bean != null && method != null, \"No bean+method set on endpoint\");\n\t\tInvocableHandlerMethod invocableHandlerMethod =\n\t\t\t\tthis.messageHandlerMethodFactory.createInvocableHandlerMethod(bean, method);\n\t\tmessageListener.setHandlerMethod(invocableHandlerMethod);\n\t\tString responseDestination = getDefaultResponseDestination();\n\t\tif (StringUtils.hasText(responseDestination)) {\n\t\t\tif (container.isReplyPubSubDomain()) {\n\t\t\t\tmessageListener.setDefaultResponseTopicName(responseDestination);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmessageListener.setDefaultResponseQueueName(responseDestination);\n\t\t\t}\n\t\t}\n\t\tQosSettings responseQosSettings = container.getReplyQosSettings();\n\t\tif (responseQosSettings != null) {\n\t\t\tmessageListener.setResponseQosSettings(responseQosSettings);\n\t\t}\n\t\tMessageConverter messageConverter = container.getMessageConverter();\n\t\tif (messageConverter != null) {\n\t\t\tmessageListener.setMessageConverter(messageConverter);\n\t\t}\n\t\tDestinationResolver destinationResolver = container.getDestinationResolver();\n\t\tif (destinationResolver != null) {\n\t\t\tmessageListener.setDestinationResolver(destinationResolver);\n\t\t}\n\t\treturn messageListener;\n\t}"
  },
  "org.springframework.jms.config.MethodJmsListenerEndpoint#createMessageListenerInstance()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an empty {@link MessagingMessageListenerAdapter} instance.\n\t * @return a new {@code MessagingMessageListenerAdapter} or subclass thereof\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "MessagingMessageListenerAdapter",
    "signature": "protected MessagingMessageListenerAdapter createMessageListenerInstance()",
    "source_code": "\tprotected MessagingMessageListenerAdapter createMessageListenerInstance() {\n\t\treturn new MessagingMessageListenerAdapter();\n\t}"
  },
  "org.springframework.jms.config.MethodJmsListenerEndpoint#getBean()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "Object",
    "signature": "public Object getBean()",
    "source_code": "\tpublic Object getBean() {\n\t\treturn this.bean;\n\t}"
  },
  "org.springframework.jms.config.MethodJmsListenerEndpoint#getDefaultResponseDestination()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the default response destination, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "String",
    "signature": "protected String getDefaultResponseDestination()",
    "source_code": "\tprotected String getDefaultResponseDestination() {\n\t\tMethod specificMethod = getMostSpecificMethod();\n\t\tif (specificMethod == null) {\n\t\t\treturn null;\n\t\t}\n\t\tSendTo ann = getSendTo(specificMethod);\n\t\tif (ann != null) {\n\t\t\tObject[] destinations = ann.value();\n\t\t\tif (destinations.length != 1) {\n\t\t\t\tthrow new IllegalStateException(\"Invalid @\" + SendTo.class.getSimpleName() + \" annotation on '\" +\n\t\t\t\t\t\tspecificMethod + \"' one destination must be set (got \" + Arrays.toString(destinations) + \")\");\n\t\t\t}\n\t\t\treturn resolve((String) destinations[0]);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.jms.config.MethodJmsListenerEndpoint#getEndpointDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "StringBuilder",
    "signature": "protected StringBuilder getEndpointDescription()",
    "source_code": "\tprotected StringBuilder getEndpointDescription() {\n\t\treturn super.getEndpointDescription()\n\t\t\t\t.append(\" | bean='\").append(this.bean).append('\\'')\n\t\t\t\t.append(\" | method='\").append(this.method).append('\\'');\n\t}"
  },
  "org.springframework.jms.config.MethodJmsListenerEndpoint#getMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "Method",
    "signature": "public Method getMethod()",
    "source_code": "\tpublic Method getMethod() {\n\t\treturn this.method;\n\t}"
  },
  "org.springframework.jms.config.MethodJmsListenerEndpoint#getMostSpecificMethod()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "Method",
    "signature": "public Method getMostSpecificMethod()",
    "source_code": "\tpublic Method getMostSpecificMethod() {\n\t\tif (this.mostSpecificMethod != null) {\n\t\t\treturn this.mostSpecificMethod;\n\t\t}\n\t\tMethod method = getMethod();\n\t\tif (method != null) {\n\t\t\tObject bean = getBean();\n\t\t\tif (AopUtils.isAopProxy(bean)) {\n\t\t\t\tClass<?> targetClass = AopProxyUtils.ultimateTargetClass(bean);\n\t\t\t\tmethod = AopUtils.getMostSpecificMethod(method, targetClass);\n\t\t\t}\n\t\t}\n\t\treturn method;\n\t}"
  },
  "org.springframework.jms.config.MethodJmsListenerEndpoint#setBean(bean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the actual bean instance to invoke this endpoint method on.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "public void setBean(@Nullable Object bean)",
    "source_code": "\tpublic void setBean(@Nullable Object bean) {\n\t\tthis.bean = bean;\n\t}"
  },
  "org.springframework.jms.config.MethodJmsListenerEndpoint#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link BeanFactory} to use to resolve expressions (may be {@code null}).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void setBeanFactory(@Nullable BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(@Nullable BeanFactory beanFactory) {\n\t\tif (this.embeddedValueResolver == null && beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tthis.embeddedValueResolver = new EmbeddedValueResolver(cbf);\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.MethodJmsListenerEndpoint#setEmbeddedValueResolver(embeddedValueResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a value resolver for embedded placeholders and expressions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "embeddedValueResolver"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void setEmbeddedValueResolver(@Nullable StringValueResolver embeddedValueResolver)",
    "source_code": "\tpublic void setEmbeddedValueResolver(@Nullable StringValueResolver embeddedValueResolver) {\n\t\tthis.embeddedValueResolver = embeddedValueResolver;\n\t}"
  },
  "org.springframework.jms.config.MethodJmsListenerEndpoint#setMessageHandlerMethodFactory(messageHandlerMethodFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link MessageHandlerMethodFactory} to use to build the\n\t * {@link InvocableHandlerMethod} responsible to manage the invocation\n\t * of this endpoint.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageHandlerMethodFactory"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "public void setMessageHandlerMethodFactory(MessageHandlerMethodFactory messageHandlerMethodFactory)",
    "source_code": "\tpublic void setMessageHandlerMethodFactory(MessageHandlerMethodFactory messageHandlerMethodFactory) {\n\t\tthis.messageHandlerMethodFactory = messageHandlerMethodFactory;\n\t}"
  },
  "org.springframework.jms.config.MethodJmsListenerEndpoint#setMethod(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the method to invoke for processing a message managed by this endpoint.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void setMethod(@Nullable Method method)",
    "source_code": "\tpublic void setMethod(@Nullable Method method) {\n\t\tthis.method = method;\n\t}"
  },
  "org.springframework.jms.config.MethodJmsListenerEndpoint#setMostSpecificMethod(mostSpecificMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the most specific method known for this endpoint's declaration.\n\t * <p>In case of a proxy, this will be the method on the target class\n\t * (if annotated itself, that is, if not just annotated in an interface).\n\t * @since 4.2.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mostSpecificMethod"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void setMostSpecificMethod(@Nullable Method mostSpecificMethod)",
    "source_code": "\tpublic void setMostSpecificMethod(@Nullable Method mostSpecificMethod) {\n\t\tthis.mostSpecificMethod = mostSpecificMethod;\n\t}"
  },
  "org.springframework.jms.config.endpoint": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "signature": "public JmsListenerEndpoint endpoint",
    "source_code": "\t\tpublic final JmsListenerEndpoint endpoint;",
    "type": "JmsListenerEndpoint"
  },
  "org.springframework.jms.config.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.jms.connection.<unknown>#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\tpublic void close() throws JMSException {\n\t\t// It's a cached MessageConsumer...\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getMessageListener()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "MessageListener",
    "signature": "public MessageListener getMessageListener()",
    "source_code": "\tpublic MessageListener getMessageListener() throws JMSException {\n\t\treturn this.target.getMessageListener();\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getMessageSelector()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "String",
    "signature": "public String getMessageSelector()",
    "source_code": "\tpublic String getMessageSelector() throws JMSException {\n\t\treturn this.target.getMessageSelector();\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getNoLocal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "boolean",
    "signature": "public boolean getNoLocal()",
    "source_code": "\tpublic boolean getNoLocal() throws JMSException {\n\t\treturn (this.target instanceof TopicSubscriber subscriber && subscriber.getNoLocal());\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getQueue()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "Queue",
    "signature": "public Queue getQueue()",
    "source_code": "\tpublic Queue getQueue() throws JMSException {\n\t\treturn (this.target instanceof QueueReceiver receiver ? receiver.getQueue() : null);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getTopic()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "Topic",
    "signature": "public Topic getTopic()",
    "source_code": "\tpublic Topic getTopic() throws JMSException {\n\t\treturn (this.target instanceof TopicSubscriber subscriber ? subscriber.getTopic() : null);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#receive()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "Message",
    "signature": "public Message receive()",
    "source_code": "\tpublic Message receive() throws JMSException {\n\t\treturn this.target.receive();\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#receive(timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "Message",
    "signature": "public Message receive(long timeout)",
    "source_code": "\tpublic Message receive(long timeout) throws JMSException {\n\t\treturn this.target.receive(timeout);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#receiveNoWait()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "Message",
    "signature": "public Message receiveNoWait()",
    "source_code": "\tpublic Message receiveNoWait() throws JMSException {\n\t\treturn this.target.receiveNoWait();\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#setMessageListener(messageListener)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageListener"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "void",
    "signature": "public void setMessageListener(MessageListener messageListener)",
    "source_code": "\tpublic void setMessageListener(MessageListener messageListener) throws JMSException {\n\t\tthis.target.setMessageListener(messageListener);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"Cached JMS MessageConsumer: \" + this.target;\n\t}"
  },
  "org.springframework.jms.connection.CachingConnectionFactory#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 562
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\t\tpublic boolean equals(@Nullable Object obj) {\n\t\t\t// Effectively checking object equality as well as toString equality.\n\t\t\t// On WebSphere MQ, Destination objects do not implement equals...\n\t\t\treturn (this == obj || (obj instanceof DestinationCacheKey otherKey &&\n\t\t\t\t\tdestinationEquals(otherKey)));\n\t\t}"
  },
  "org.springframework.jms.connection.ConnectionFactoryUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Helper class for managing a JMS {@link jakarta.jms.ConnectionFactory}, in particular\n * for obtaining transactional JMS resources for a given ConnectionFactory.\n *\n * <p>Mainly for internal use within the framework. Used by\n * {@link org.springframework.jms.core.JmsTemplate} as well as\n * {@link org.springframework.jms.listener.DefaultMessageListenerContainer}.\n *\n * @author Juergen Hoeller\n * @since 2.0\n * @see SmartConnectionFactory\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class ConnectionFactoryUtils",
    "source_code": "public abstract class ConnectionFactoryUtils {\n\n\tprivate static final Log logger = LogFactory.getLog(ConnectionFactoryUtils.class);\n\n\n\t/**\n\t * Release the given Connection, stopping it (if necessary) and eventually closing it.\n\t * <p>Checks {@link SmartConnectionFactory#shouldStop}, if available.\n\t * This is essentially a more sophisticated version of\n\t * {@link org.springframework.jms.support.JmsUtils#closeConnection}.\n\t * @param con the Connection to release\n\t * (if this is {@code null}, the call will be ignored)\n\t * @param cf the ConnectionFactory that the Connection was obtained from\n\t * (may be {@code null})\n\t * @param started whether the Connection might have been started by the application\n\t * @see SmartConnectionFactory#shouldStop\n\t * @see org.springframework.jms.support.JmsUtils#closeConnection\n\t */\n\tpublic static void releaseConnection(@Nullable Connection con, @Nullable ConnectionFactory cf, boolean started) {\n\t\tif (con == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (started && cf instanceof SmartConnectionFactory smartFactory && smartFactory.shouldStop(con)) {\n\t\t\ttry {\n\t\t\t\tcon.stop();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.debug(\"Could not stop JMS Connection before closing it\", ex);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tcon.close();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.debug(\"Could not close JMS Connection\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Return the innermost target Session of the given Session. If the given\n\t * Session is a proxy, it will be unwrapped until a non-proxy Session is\n\t * found. Otherwise, the passed-in Session will be returned as-is.\n\t * @param session the Session proxy to unwrap\n\t * @return the innermost target Session, or the passed-in one if no proxy\n\t * @see SessionProxy#getTargetSession()\n\t */\n\tpublic static Session getTargetSession(Session session) {\n\t\tSession sessionToUse = session;\n\t\twhile (sessionToUse instanceof SessionProxy sessionProxy) {\n\t\t\tsessionToUse = sessionProxy.getTargetSession();\n\t\t}\n\t\treturn sessionToUse;\n\t}\n\n\n\n\t/**\n\t * Determine whether the given JMS Session is transactional, that is,\n\t * bound to the current thread by Spring's transaction facilities.\n\t * @param session the JMS Session to check\n\t * @param cf the JMS ConnectionFactory that the Session originated from\n\t * @return whether the Session is transactional\n\t */\n\tpublic static boolean isSessionTransactional(@Nullable Session session, @Nullable ConnectionFactory cf) {\n\t\tif (session == null || cf == null) {\n\t\t\treturn false;\n\t\t}\n\t\tJmsResourceHolder resourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(cf);\n\t\treturn (resourceHolder != null && resourceHolder.containsSession(session));\n\t}\n\n\n\t/**\n\t * Obtain a JMS Session that is synchronized with the current transaction, if any.\n\t * @param cf the ConnectionFactory to obtain a Session for\n\t * @param existingCon the existing JMS Connection to obtain a Session for\n\t * (may be {@code null})\n\t * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction\n\t * that is synchronized with a Spring-managed transaction (where the main transaction\n\t * might be a JDBC-based one for a specific DataSource, for example), with the JMS\n\t * transaction committing right after the main transaction. If not allowed, the given\n\t * ConnectionFactory needs to handle transaction enlistment underneath the covers.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */\n\t@Nullable\n\tpublic static Session getTransactionalSession(final ConnectionFactory cf,\n\t\t\t@Nullable final Connection existingCon, final boolean synchedLocalTransactionAllowed)\n\t\t\tthrows JMSException {\n\n\t\treturn doGetTransactionalSession(cf, new ResourceFactory() {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Session getSession(JmsResourceHolder holder) {\n\t\t\t\treturn holder.getSession(Session.class, existingCon);\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Connection getConnection(JmsResourceHolder holder) {\n\t\t\t\treturn (existingCon != null ? existingCon : holder.getConnection());\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Connection createConnection() throws JMSException {\n\t\t\t\treturn cf.createConnection();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Session createSession(Connection con) throws JMSException {\n\t\t\t\treturn con.createSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean isSynchedLocalTransactionAllowed() {\n\t\t\t\treturn synchedLocalTransactionAllowed;\n\t\t\t}\n\t\t}, true);\n\t}\n\n\t/**\n\t * Obtain a JMS QueueSession that is synchronized with the current transaction, if any.\n\t * <p>Mainly intended for use with the JMS 1.0.2 API.\n\t * @param cf the ConnectionFactory to obtain a Session for\n\t * @param existingCon the existing JMS Connection to obtain a Session for\n\t * (may be {@code null})\n\t * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction\n\t * that is synchronized with a Spring-managed transaction (where the main transaction\n\t * might be a JDBC-based one for a specific DataSource, for example), with the JMS\n\t * transaction committing right after the main transaction. If not allowed, the given\n\t * ConnectionFactory needs to handle transaction enlistment underneath the covers.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */\n\t@Nullable\n\tpublic static QueueSession getTransactionalQueueSession(final QueueConnectionFactory cf,\n\t\t\t@Nullable final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed)\n\t\t\tthrows JMSException {\n\n\t\treturn (QueueSession) doGetTransactionalSession(cf, new ResourceFactory() {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Session getSession(JmsResourceHolder holder) {\n\t\t\t\treturn holder.getSession(QueueSession.class, existingCon);\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Connection getConnection(JmsResourceHolder holder) {\n\t\t\t\treturn (existingCon != null ? existingCon : holder.getConnection(QueueConnection.class));\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Connection createConnection() throws JMSException {\n\t\t\t\treturn cf.createQueueConnection();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Session createSession(Connection con) throws JMSException {\n\t\t\t\treturn ((QueueConnection) con).createQueueSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean isSynchedLocalTransactionAllowed() {\n\t\t\t\treturn synchedLocalTransactionAllowed;\n\t\t\t}\n\t\t}, true);\n\t}\n\n\t/**\n\t * Obtain a JMS TopicSession that is synchronized with the current transaction, if any.\n\t * <p>Mainly intended for use with the JMS 1.0.2 API.\n\t * @param cf the ConnectionFactory to obtain a Session for\n\t * @param existingCon the existing JMS Connection to obtain a Session for\n\t * (may be {@code null})\n\t * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction\n\t * that is synchronized with a Spring-managed transaction (where the main transaction\n\t * might be a JDBC-based one for a specific DataSource, for example), with the JMS\n\t * transaction committing right after the main transaction. If not allowed, the given\n\t * ConnectionFactory needs to handle transaction enlistment underneath the covers.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */\n\t@Nullable\n\tpublic static TopicSession getTransactionalTopicSession(final TopicConnectionFactory cf,\n\t\t\t@Nullable final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed)\n\t\t\tthrows JMSException {\n\n\t\treturn (TopicSession) doGetTransactionalSession(cf, new ResourceFactory() {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Session getSession(JmsResourceHolder holder) {\n\t\t\t\treturn holder.getSession(TopicSession.class, existingCon);\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Connection getConnection(JmsResourceHolder holder) {\n\t\t\t\treturn (existingCon != null ? existingCon : holder.getConnection(TopicConnection.class));\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Connection createConnection() throws JMSException {\n\t\t\t\treturn cf.createTopicConnection();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Session createSession(Connection con) throws JMSException {\n\t\t\t\treturn ((TopicConnection) con).createTopicSession(\n\t\t\t\t\t\tsynchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean isSynchedLocalTransactionAllowed() {\n\t\t\t\treturn synchedLocalTransactionAllowed;\n\t\t\t}\n\t\t}, true);\n\t}\n\n\t/**\n\t * Obtain a JMS Session that is synchronized with the current transaction, if any.\n\t * <p>This {@code doGetTransactionalSession} variant always starts the underlying\n\t * JMS Connection, assuming that the Session will be used for receiving messages.\n\t * @param connectionFactory the JMS ConnectionFactory to bind for\n\t * (used as TransactionSynchronizationManager key)\n\t * @param resourceFactory the ResourceFactory to use for extracting or creating\n\t * JMS resources\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t * @see #doGetTransactionalSession(jakarta.jms.ConnectionFactory, ResourceFactory, boolean)\n\t */\n\t@Nullable\n\tpublic static Session doGetTransactionalSession(\n\t\t\tConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException {\n\n\t\treturn doGetTransactionalSession(connectionFactory, resourceFactory, true);\n\t}\n\n\t/**\n\t * Obtain a JMS Session that is synchronized with the current transaction, if any.\n\t * @param connectionFactory the JMS ConnectionFactory to bind for\n\t * (used as TransactionSynchronizationManager key)\n\t * @param resourceFactory the ResourceFactory to use for extracting or creating\n\t * JMS resources\n\t * @param startConnection whether the underlying JMS Connection approach should be\n\t * started in order to allow for receiving messages. Note that a reused Connection\n\t * may already have been started before, even if this flag is {@code false}.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */\n\t@Nullable\n\tpublic static Session doGetTransactionalSession(\n\t\t\tConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection)\n\t\t\tthrows JMSException {\n\n\t\tAssert.notNull(connectionFactory, \"ConnectionFactory must not be null\");\n\t\tAssert.notNull(resourceFactory, \"ResourceFactory must not be null\");\n\n\t\tJmsResourceHolder resourceHolder =\n\t\t\t\t(JmsResourceHolder) TransactionSynchronizationManager.getResource(connectionFactory);\n\t\tif (resourceHolder != null) {\n\t\t\tSession session = resourceFactory.getSession(resourceHolder);\n\t\t\tif (session != null) {\n\t\t\t\tif (startConnection) {\n\t\t\t\t\tConnection con = resourceFactory.getConnection(resourceHolder);\n\t\t\t\t\tif (con != null) {\n\t\t\t\t\t\tcon.start();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn session;\n\t\t\t}\n\t\t\tif (resourceHolder.isFrozen()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tif (!TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\treturn null;\n\t\t}\n\t\tJmsResourceHolder resourceHolderToUse = resourceHolder;\n\t\tif (resourceHolderToUse == null) {\n\t\t\tresourceHolderToUse = new JmsResourceHolder(connectionFactory);\n\t\t}\n\t\tConnection con = resourceFactory.getConnection(resourceHolderToUse);\n\t\tSession session = null;\n\t\ttry {\n\t\t\tboolean isExistingCon = (con != null);\n\t\t\tif (!isExistingCon) {\n\t\t\t\tcon = resourceFactory.createConnection();\n\t\t\t\tresourceHolderToUse.addConnection(con);\n\t\t\t}\n\t\t\tsession = resourceFactory.createSession(con);\n\t\t\tresourceHolderToUse.addSession(session, con);\n\t\t\tif (startConnection) {\n\t\t\t\tcon.start();\n\t\t\t}\n\t\t}\n\t\tcatch (JMSException ex) {\n\t\t\tif (session != null) {\n\t\t\t\ttry {\n\t\t\t\t\tsession.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (con != null) {\n\t\t\t\ttry {\n\t\t\t\t\tcon.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t\tif (resourceHolderToUse != resourceHolder) {\n\t\t\tTransactionSynchronizationManager.registerSynchronization(\n\t\t\t\t\tnew JmsResourceSynchronization(resourceHolderToUse, connectionFactory,\n\t\t\t\t\t\t\tresourceFactory.isSynchedLocalTransactionAllowed()));\n\t\t\tresourceHolderToUse.setSynchronizedWithTransaction(true);\n\t\t\tTransactionSynchronizationManager.bindResource(connectionFactory, resourceHolderToUse);\n\t\t}\n\t\treturn session;\n\t}\n\n\n\t/**\n\t * Callback interface for resource creation.\n\t * Serving as argument for the {@code doGetTransactionalSession} method.\n\t */\n\tpublic interface ResourceFactory {\n\n\t\t/**\n\t\t * Fetch an appropriate Session from the given JmsResourceHolder.\n\t\t * @param holder the JmsResourceHolder\n\t\t * @return an appropriate Session fetched from the holder,\n\t\t * or {@code null} if none found\n\t\t */\n\t\t@Nullable\n\t\tSession getSession(JmsResourceHolder holder);\n\n\t\t/**\n\t\t * Fetch an appropriate Connection from the given JmsResourceHolder.\n\t\t * @param holder the JmsResourceHolder\n\t\t * @return an appropriate Connection fetched from the holder,\n\t\t * or {@code null} if none found\n\t\t */\n\t\t@Nullable\n\t\tConnection getConnection(JmsResourceHolder holder);\n\n\t\t/**\n\t\t * Create a new JMS Connection for registration with a JmsResourceHolder.\n\t\t * @return the new JMS Connection\n\t\t * @throws JMSException if thrown by JMS API methods\n\t\t */\n\t\tConnection createConnection() throws JMSException;\n\n\t\t/**\n\t\t * Create a new JMS Session for registration with a JmsResourceHolder.\n\t\t * @param con the JMS Connection to create a Session for\n\t\t * @return the new JMS Session\n\t\t * @throws JMSException if thrown by JMS API methods\n\t\t */\n\t\tSession createSession(Connection con) throws JMSException;\n\n\t\t/**\n\t\t * Return whether to allow for a local JMS transaction that is synchronized with\n\t\t * a Spring-managed transaction (where the main transaction might be a JDBC-based\n\t\t * one for a specific DataSource, for example), with the JMS transaction\n\t\t * committing right after the main transaction.\n\t\t * @return whether to allow for synchronizing a local JMS transaction\n\t\t */\n\t\tboolean isSynchedLocalTransactionAllowed();\n\t}\n\n\n\t/**\n\t * Callback for resource cleanup at the end of a non-native JMS transaction\n\t * (e.g. when participating in a JtaTransactionManager transaction).\n\t * @see org.springframework.transaction.jta.JtaTransactionManager\n\t */\n\tprivate static class JmsResourceSynchronization extends ResourceHolderSynchronization<JmsResourceHolder, Object> {\n\n\t\tprivate final boolean transacted;\n\n\t\tpublic JmsResourceSynchronization(JmsResourceHolder resourceHolder, Object resourceKey, boolean transacted) {\n\t\t\tsuper(resourceHolder, resourceKey);\n\t\t\tthis.transacted = transacted;\n\t\t}\n\n\t\t@Override\n\t\tprotected boolean shouldReleaseBeforeCompletion() {\n\t\t\treturn !this.transacted;\n\t\t}\n\n\t\t@Override\n\t\tprotected void processResourceAfterCommit(JmsResourceHolder resourceHolder) {\n\t\t\ttry {\n\t\t\t\tresourceHolder.commitAll();\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tthrow new SynchedLocalTransactionFailedException(\"Local JMS transaction failed to commit\", ex);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected void releaseResource(JmsResourceHolder resourceHolder, Object resourceKey) {\n\t\t\tresourceHolder.closeAll();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jms.connection.ConnectionFactoryUtils#createConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "Connection",
    "signature": "public Connection createConnection()",
    "source_code": "\t\t\tpublic Connection createConnection() throws JMSException {\n\t\t\t\treturn cf.createTopicConnection();\n\t\t\t}"
  },
  "org.springframework.jms.connection.ConnectionFactoryUtils#createSession(con)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con"
    ],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "Session",
    "signature": "public Session createSession(Connection con)",
    "source_code": "\t\t\tpublic Session createSession(Connection con) throws JMSException {\n\t\t\t\treturn ((TopicConnection) con).createTopicSession(\n\t\t\t\t\t\tsynchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE);\n\t\t\t}"
  },
  "org.springframework.jms.connection.ConnectionFactoryUtils#doGetTransactionalSession(connectionFactory,resourceFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS Session that is synchronized with the current transaction, if any.\n\t * <p>This {@code doGetTransactionalSession} variant always starts the underlying\n\t * JMS Connection, assuming that the Session will be used for receiving messages.\n\t * @param connectionFactory the JMS ConnectionFactory to bind for\n\t * (used as TransactionSynchronizationManager key)\n\t * @param resourceFactory the ResourceFactory to use for extracting or creating\n\t * JMS resources\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t * @see #doGetTransactionalSession(jakarta.jms.ConnectionFactory, ResourceFactory, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connectionFactory",
      "resourceFactory"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "Session",
    "signature": "public Session doGetTransactionalSession(ConnectionFactory connectionFactory, ResourceFactory resourceFactory)",
    "source_code": "\tpublic static Session doGetTransactionalSession("
  },
  "org.springframework.jms.connection.ConnectionFactoryUtils#doGetTransactionalSession(connectionFactory,resourceFactory,startConnection)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS Session that is synchronized with the current transaction, if any.\n\t * @param connectionFactory the JMS ConnectionFactory to bind for\n\t * (used as TransactionSynchronizationManager key)\n\t * @param resourceFactory the ResourceFactory to use for extracting or creating\n\t * JMS resources\n\t * @param startConnection whether the underlying JMS Connection approach should be\n\t * started in order to allow for receiving messages. Note that a reused Connection\n\t * may already have been started before, even if this flag is {@code false}.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connectionFactory",
      "resourceFactory",
      "startConnection"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "Session",
    "signature": "public Session doGetTransactionalSession(ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection)",
    "source_code": "\tpublic static Session doGetTransactionalSession("
  },
  "org.springframework.jms.connection.ConnectionFactoryUtils#getConnection(holder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "holder"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "Connection",
    "signature": "public Connection getConnection(JmsResourceHolder holder)",
    "source_code": "\t\t\tpublic Connection getConnection(JmsResourceHolder holder) {\n\t\t\t\treturn (existingCon != null ? existingCon : holder.getConnection(TopicConnection.class));\n\t\t\t}"
  },
  "org.springframework.jms.connection.ConnectionFactoryUtils#getSession(holder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "holder"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "Session",
    "signature": "public Session getSession(JmsResourceHolder holder)",
    "source_code": "\t\t\tpublic Session getSession(JmsResourceHolder holder) {\n\t\t\t\treturn holder.getSession(TopicSession.class, existingCon);\n\t\t\t}"
  },
  "org.springframework.jms.connection.ConnectionFactoryUtils#getTargetSession(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the innermost target Session of the given Session. If the given\n\t * Session is a proxy, it will be unwrapped until a non-proxy Session is\n\t * found. Otherwise, the passed-in Session will be returned as-is.\n\t * @param session the Session proxy to unwrap\n\t * @return the innermost target Session, or the passed-in one if no proxy\n\t * @see SessionProxy#getTargetSession()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "Session",
    "signature": "public Session getTargetSession(Session session)",
    "source_code": "\tpublic static Session getTargetSession(Session session) {\n\t\tSession sessionToUse = session;\n\t\twhile (sessionToUse instanceof SessionProxy sessionProxy) {\n\t\t\tsessionToUse = sessionProxy.getTargetSession();\n\t\t}\n\t\treturn sessionToUse;\n\t}"
  },
  "org.springframework.jms.connection.ConnectionFactoryUtils#getTransactionalQueueSession(cf,existingCon,synchedLocalTransactionAllowed)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS QueueSession that is synchronized with the current transaction, if any.\n\t * <p>Mainly intended for use with the JMS 1.0.2 API.\n\t * @param cf the ConnectionFactory to obtain a Session for\n\t * @param existingCon the existing JMS Connection to obtain a Session for\n\t * (may be {@code null})\n\t * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction\n\t * that is synchronized with a Spring-managed transaction (where the main transaction\n\t * might be a JDBC-based one for a specific DataSource, for example), with the JMS\n\t * transaction committing right after the main transaction. If not allowed, the given\n\t * ConnectionFactory needs to handle transaction enlistment underneath the covers.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cf",
      "existingCon",
      "synchedLocalTransactionAllowed"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "QueueSession",
    "signature": "public QueueSession getTransactionalQueueSession(final QueueConnectionFactory cf,\n\t\t\t@Nullable final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed)",
    "source_code": "\tpublic static QueueSession getTransactionalQueueSession(final QueueConnectionFactory cf,"
  },
  "org.springframework.jms.connection.ConnectionFactoryUtils#getTransactionalSession(cf,existingCon,synchedLocalTransactionAllowed)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS Session that is synchronized with the current transaction, if any.\n\t * @param cf the ConnectionFactory to obtain a Session for\n\t * @param existingCon the existing JMS Connection to obtain a Session for\n\t * (may be {@code null})\n\t * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction\n\t * that is synchronized with a Spring-managed transaction (where the main transaction\n\t * might be a JDBC-based one for a specific DataSource, for example), with the JMS\n\t * transaction committing right after the main transaction. If not allowed, the given\n\t * ConnectionFactory needs to handle transaction enlistment underneath the covers.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cf",
      "existingCon",
      "synchedLocalTransactionAllowed"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "Session",
    "signature": "public Session getTransactionalSession(final ConnectionFactory cf,\n\t\t\t@Nullable final Connection existingCon, final boolean synchedLocalTransactionAllowed)",
    "source_code": "\tpublic static Session getTransactionalSession(final ConnectionFactory cf,"
  },
  "org.springframework.jms.connection.ConnectionFactoryUtils#getTransactionalTopicSession(cf,existingCon,synchedLocalTransactionAllowed)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS TopicSession that is synchronized with the current transaction, if any.\n\t * <p>Mainly intended for use with the JMS 1.0.2 API.\n\t * @param cf the ConnectionFactory to obtain a Session for\n\t * @param existingCon the existing JMS Connection to obtain a Session for\n\t * (may be {@code null})\n\t * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction\n\t * that is synchronized with a Spring-managed transaction (where the main transaction\n\t * might be a JDBC-based one for a specific DataSource, for example), with the JMS\n\t * transaction committing right after the main transaction. If not allowed, the given\n\t * ConnectionFactory needs to handle transaction enlistment underneath the covers.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cf",
      "existingCon",
      "synchedLocalTransactionAllowed"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "TopicSession",
    "signature": "public TopicSession getTransactionalTopicSession(final TopicConnectionFactory cf,\n\t\t\t@Nullable final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed)",
    "source_code": "\tpublic static TopicSession getTransactionalTopicSession(final TopicConnectionFactory cf,"
  },
  "org.springframework.jms.connection.ConnectionFactoryUtils#isSessionTransactional(session,cf)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given JMS Session is transactional, that is,\n\t * bound to the current thread by Spring's transaction facilities.\n\t * @param session the JMS Session to check\n\t * @param cf the JMS ConnectionFactory that the Session originated from\n\t * @return whether the Session is transactional\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "boolean",
    "signature": "public boolean isSessionTransactional(@Nullable Session session, @Nullable ConnectionFactory cf)",
    "source_code": "\tpublic static boolean isSessionTransactional(@Nullable Session session, @Nullable ConnectionFactory cf) {\n\t\tif (session == null || cf == null) {\n\t\t\treturn false;\n\t\t}\n\t\tJmsResourceHolder resourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(cf);\n\t\treturn (resourceHolder != null && resourceHolder.containsSession(session));\n\t}"
  },
  "org.springframework.jms.connection.ConnectionFactoryUtils#isSynchedLocalTransactionAllowed()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "boolean",
    "signature": "public boolean isSynchedLocalTransactionAllowed()",
    "source_code": "\t\t\tpublic boolean isSynchedLocalTransactionAllowed() {\n\t\t\t\treturn synchedLocalTransactionAllowed;\n\t\t\t}"
  },
  "org.springframework.jms.connection.ConnectionFactoryUtils#processResourceAfterCommit(resourceHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourceHolder"
    ],
    "position": {
      "column": 1,
      "line": 433
    },
    "return": "void",
    "signature": "protected void processResourceAfterCommit(JmsResourceHolder resourceHolder)",
    "source_code": "\t\tprotected void processResourceAfterCommit(JmsResourceHolder resourceHolder) {\n\t\t\ttry {\n\t\t\t\tresourceHolder.commitAll();\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tthrow new SynchedLocalTransactionFailedException(\"Local JMS transaction failed to commit\", ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jms.connection.ConnectionFactoryUtils#releaseConnection(con,cf,started)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Release the given Connection, stopping it (if necessary) and eventually closing it.\n\t * <p>Checks {@link SmartConnectionFactory#shouldStop}, if available.\n\t * This is essentially a more sophisticated version of\n\t * {@link org.springframework.jms.support.JmsUtils#closeConnection}.\n\t * @param con the Connection to release\n\t * (if this is {@code null}, the call will be ignored)\n\t * @param cf the ConnectionFactory that the Connection was obtained from\n\t * (may be {@code null})\n\t * @param started whether the Connection might have been started by the application\n\t * @see SmartConnectionFactory#shouldStop\n\t * @see org.springframework.jms.support.JmsUtils#closeConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "cf",
      "started"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "public void releaseConnection(@Nullable Connection con, @Nullable ConnectionFactory cf, boolean started)",
    "source_code": "\tpublic static void releaseConnection(@Nullable Connection con, @Nullable ConnectionFactory cf, boolean started) {\n\t\tif (con == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (started && cf instanceof SmartConnectionFactory smartFactory && smartFactory.shouldStop(con)) {\n\t\t\ttry {\n\t\t\t\tcon.stop();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.debug(\"Could not stop JMS Connection before closing it\", ex);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tcon.close();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.debug(\"Could not close JMS Connection\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.ConnectionFactoryUtils#releaseResource(resourceHolder,resourceKey)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourceHolder",
      "resourceKey"
    ],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "void",
    "signature": "protected void releaseResource(JmsResourceHolder resourceHolder, Object resourceKey)",
    "source_code": "\t\tprotected void releaseResource(JmsResourceHolder resourceHolder, Object resourceKey) {\n\t\t\tresourceHolder.closeAll();\n\t\t}"
  },
  "org.springframework.jms.connection.ConnectionFactoryUtils#shouldReleaseBeforeCompletion()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 428
    },
    "return": "boolean",
    "signature": "protected boolean shouldReleaseBeforeCompletion()",
    "source_code": "\t\tprotected boolean shouldReleaseBeforeCompletion() {\n\t\t\treturn !this.transacted;\n\t\t}"
  },
  "org.springframework.jms.connection.DelegatingConnectionFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link jakarta.jms.ConnectionFactory} implementation that delegates all calls\n * to a given target {@link jakarta.jms.ConnectionFactory}, adapting specific\n * {@code create(Queue/Topic)Connection} calls to the target ConnectionFactory\n * if necessary (e.g. when running JMS 1.0.2 API based code against a generic\n * JMS 1.1 ConnectionFactory, such as ActiveMQ's PooledConnectionFactory).\n *\n * <p>As of Spring Framework 5, this class supports JMS 2.0 {@code JMSContext}\n * calls and therefore requires the JMS 2.0 API to be present at runtime.\n * It may nevertheless run against a JMS 1.1 driver (bound to the JMS 2.0 API)\n * as long as no actual JMS 2.0 calls are triggered by the application's setup.\n *\n * <p>This class allows for being subclassed, with subclasses overriding only\n * those methods (such as {@link #createConnection()}) that should not simply\n * delegate to the target ConnectionFactory.\n *\n * <p>Can also be defined as-is, wrapping a specific target ConnectionFactory,\n * using the \"shouldStopConnections\" flag to indicate whether Connections\n * obtained from the target factory are supposed to be stopped before closed.\n * The latter may be necessary for some connection pools that simply return\n * released connections to the pool, not stopping them while they sit in the pool.\n *\n * @author Juergen Hoeller\n * @since 2.0.2\n * @see #createConnection()\n * @see #setShouldStopConnections\n * @see ConnectionFactoryUtils#releaseConnection\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public class DelegatingConnectionFactory",
    "source_code": "public class DelegatingConnectionFactory"
  },
  "org.springframework.jms.connection.DelegatingConnectionFactory#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tif (getTargetConnectionFactory() == null) {\n\t\t\tthrow new IllegalArgumentException(\"'targetConnectionFactory' is required\");\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.DelegatingConnectionFactory#createConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "Connection",
    "signature": "public Connection createConnection()",
    "source_code": "\tpublic Connection createConnection() throws JMSException {\n\t\treturn obtainTargetConnectionFactory().createConnection();\n\t}"
  },
  "org.springframework.jms.connection.DelegatingConnectionFactory#createConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "Connection",
    "signature": "public Connection createConnection(String username, String password)",
    "source_code": "\tpublic Connection createConnection(String username, String password) throws JMSException {\n\t\treturn obtainTargetConnectionFactory().createConnection(username, password);\n\t}"
  },
  "org.springframework.jms.connection.DelegatingConnectionFactory#createContext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "JMSContext",
    "signature": "public JMSContext createContext()",
    "source_code": "\tpublic JMSContext createContext() {\n\t\treturn obtainTargetConnectionFactory().createContext();\n\t}"
  },
  "org.springframework.jms.connection.DelegatingConnectionFactory#createContext(sessionMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionMode"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "JMSContext",
    "signature": "public JMSContext createContext(int sessionMode)",
    "source_code": "\tpublic JMSContext createContext(int sessionMode) {\n\t\treturn obtainTargetConnectionFactory().createContext(sessionMode);\n\t}"
  },
  "org.springframework.jms.connection.DelegatingConnectionFactory#createContext(userName,password)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userName",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "JMSContext",
    "signature": "public JMSContext createContext(String userName, String password)",
    "source_code": "\tpublic JMSContext createContext(String userName, String password) {\n\t\treturn obtainTargetConnectionFactory().createContext(userName, password);\n\t}"
  },
  "org.springframework.jms.connection.DelegatingConnectionFactory#createContext(userName,password,sessionMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userName",
      "password",
      "sessionMode"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "JMSContext",
    "signature": "public JMSContext createContext(String userName, String password, int sessionMode)",
    "source_code": "\tpublic JMSContext createContext(String userName, String password, int sessionMode) {\n\t\treturn obtainTargetConnectionFactory().createContext(userName, password, sessionMode);\n\t}"
  },
  "org.springframework.jms.connection.DelegatingConnectionFactory#createQueueConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "QueueConnection",
    "signature": "public QueueConnection createQueueConnection()",
    "source_code": "\tpublic QueueConnection createQueueConnection() throws JMSException {\n\t\tConnectionFactory target = obtainTargetConnectionFactory();\n\t\tif (target instanceof QueueConnectionFactory queueFactory) {\n\t\t\treturn queueFactory.createQueueConnection();\n\t\t}\n\t\telse {\n\t\t\tConnection con = target.createConnection();\n\t\t\tif (!(con instanceof QueueConnection queueConnection)) {\n\t\t\t\tthrow new jakarta.jms.IllegalStateException(\"'targetConnectionFactory' is not a QueueConnectionFactory\");\n\t\t\t}\n\t\t\treturn queueConnection;\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.DelegatingConnectionFactory#createQueueConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "QueueConnection",
    "signature": "public QueueConnection createQueueConnection(String username, String password)",
    "source_code": "\tpublic QueueConnection createQueueConnection(String username, String password) throws JMSException {\n\t\tConnectionFactory target = obtainTargetConnectionFactory();\n\t\tif (target instanceof QueueConnectionFactory queueFactory) {\n\t\t\treturn queueFactory.createQueueConnection(username, password);\n\t\t}\n\t\telse {\n\t\t\tConnection con = target.createConnection(username, password);\n\t\t\tif (!(con instanceof QueueConnection queueConnection)) {\n\t\t\t\tthrow new jakarta.jms.IllegalStateException(\"'targetConnectionFactory' is not a QueueConnectionFactory\");\n\t\t\t}\n\t\t\treturn queueConnection;\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.DelegatingConnectionFactory#createTopicConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "TopicConnection",
    "signature": "public TopicConnection createTopicConnection()",
    "source_code": "\tpublic TopicConnection createTopicConnection() throws JMSException {\n\t\tConnectionFactory target = obtainTargetConnectionFactory();\n\t\tif (target instanceof TopicConnectionFactory topicFactory) {\n\t\t\treturn topicFactory.createTopicConnection();\n\t\t}\n\t\telse {\n\t\t\tConnection con = target.createConnection();\n\t\t\tif (!(con instanceof TopicConnection topicConnection)) {\n\t\t\t\tthrow new jakarta.jms.IllegalStateException(\"'targetConnectionFactory' is not a TopicConnectionFactory\");\n\t\t\t}\n\t\t\treturn topicConnection;\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.DelegatingConnectionFactory#createTopicConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "TopicConnection",
    "signature": "public TopicConnection createTopicConnection(String username, String password)",
    "source_code": "\tpublic TopicConnection createTopicConnection(String username, String password) throws JMSException {\n\t\tConnectionFactory target = obtainTargetConnectionFactory();\n\t\tif (target instanceof TopicConnectionFactory topicFactory) {\n\t\t\treturn topicFactory.createTopicConnection(username, password);\n\t\t}\n\t\telse {\n\t\t\tConnection con = target.createConnection(username, password);\n\t\t\tif (!(con instanceof TopicConnection topicConnection)) {\n\t\t\t\tthrow new jakarta.jms.IllegalStateException(\"'targetConnectionFactory' is not a TopicConnectionFactory\");\n\t\t\t}\n\t\t\treturn topicConnection;\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.DelegatingConnectionFactory#getTargetConnectionFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the target ConnectionFactory that this ConnectionFactory delegates to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "ConnectionFactory",
    "signature": "public ConnectionFactory getTargetConnectionFactory()",
    "source_code": "\tpublic ConnectionFactory getTargetConnectionFactory() {\n\t\treturn this.targetConnectionFactory;\n\t}"
  },
  "org.springframework.jms.connection.DelegatingConnectionFactory#setShouldStopConnections(shouldStopConnections)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicate whether Connections obtained from the target factory are supposed\n\t * to be stopped before closed (\"true\") or simply closed (\"false\").\n\t * An extra stop call may be necessary for some connection pools that simply return\n\t * released connections to the pool, not stopping them while they sit in the pool.\n\t * <p>Default is \"false\", simply closing Connections.\n\t * @see ConnectionFactoryUtils#releaseConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "shouldStopConnections"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void setShouldStopConnections(boolean shouldStopConnections)",
    "source_code": "\tpublic void setShouldStopConnections(boolean shouldStopConnections) {\n\t\tthis.shouldStopConnections = shouldStopConnections;\n\t}"
  },
  "org.springframework.jms.connection.DelegatingConnectionFactory#setTargetConnectionFactory(targetConnectionFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the target ConnectionFactory that this ConnectionFactory should delegate to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetConnectionFactory"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "public void setTargetConnectionFactory(@Nullable ConnectionFactory targetConnectionFactory)",
    "source_code": "\tpublic void setTargetConnectionFactory(@Nullable ConnectionFactory targetConnectionFactory) {\n\t\tthis.targetConnectionFactory = targetConnectionFactory;\n\t}"
  },
  "org.springframework.jms.connection.DelegatingConnectionFactory#shouldStop(con)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "boolean",
    "signature": "public boolean shouldStop(Connection con)",
    "source_code": "\tpublic boolean shouldStop(Connection con) {\n\t\treturn this.shouldStopConnections;\n\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link org.springframework.transaction.PlatformTransactionManager} implementation\n * for a single JMS {@link jakarta.jms.ConnectionFactory}. Binds a JMS\n * Connection/Session pair from the specified ConnectionFactory to the thread,\n * potentially allowing for one thread-bound Session per ConnectionFactory.\n *\n * <p>This local strategy is an alternative to executing JMS operations within\n * JTA transactions. Its advantage is that it is able to work in any environment,\n * for example a standalone application or a test suite, with any message broker\n * as target. However, this strategy is <i>not</i> able to provide XA transactions,\n * for example in order to share transactions between messaging and database access.\n * A full JTA/XA setup is required for XA transactions, typically using Spring's\n * {@link org.springframework.transaction.jta.JtaTransactionManager} as strategy.\n *\n * <p>Application code is required to retrieve the transactional JMS Session via\n * {@link ConnectionFactoryUtils#getTransactionalSession} instead of a standard\n * Jakarta EE-style {@link ConnectionFactory#createConnection()} call with subsequent\n * Session creation. Spring's {@link org.springframework.jms.core.JmsTemplate}\n * will autodetect a thread-bound Session and automatically participate in it.\n *\n * <p>Alternatively, you can allow application code to work with the standard\n * Jakarta EE-style lookup pattern on a ConnectionFactory, for example for legacy code\n * that is not aware of Spring at all. In that case, define a\n * {@link TransactionAwareConnectionFactoryProxy} for your target ConnectionFactory,\n * which will automatically participate in Spring-managed transactions.\n *\n * <p><b>The use of {@link CachingConnectionFactory} as a target for this\n * transaction manager is strongly recommended.</b> CachingConnectionFactory\n * uses a single JMS Connection for all JMS access in order to avoid the overhead\n * of repeated Connection creation, as well as maintaining a cache of Sessions.\n * Each transaction will then share the same JMS Connection, while still using\n * its own individual JMS Session.\n *\n * <p>The use of a <i>raw</i> target ConnectionFactory would not only be inefficient\n * because of the lack of resource reuse. It might also lead to strange effects\n * when your JMS driver doesn't accept {@code MessageProducer.close()} calls\n * and/or {@code MessageConsumer.close()} calls before {@code Session.commit()},\n * with the latter supposed to commit all the messages that have been sent through the\n * producer handle and received through the consumer handle. As a safe general solution,\n * always pass in a {@link CachingConnectionFactory} into this transaction manager's\n * {@link #setConnectionFactory \"connectionFactory\"} property.\n *\n * <p>Transaction synchronization is turned off by default, as this manager might\n * be used alongside a datastore-based Spring transaction manager such as the\n * JDBC {@link org.springframework.jdbc.datasource.DataSourceTransactionManager},\n * which has stronger needs for synchronization.\n *\n * @author Juergen Hoeller\n * @since 1.1\n * @see ConnectionFactoryUtils#getTransactionalSession\n * @see TransactionAwareConnectionFactoryProxy\n * @see org.springframework.jms.core.JmsTemplate\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "signature": "public class JmsTransactionManager",
    "source_code": "public class JmsTransactionManager extends AbstractPlatformTransactionManager"
  },
  "org.springframework.jms.connection.JmsTransactionManager#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Make sure the ConnectionFactory has been set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tif (getConnectionFactory() == null) {\n\t\t\tthrow new IllegalArgumentException(\"Property 'connectionFactory' is required\");\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#createConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS Connection via this template's ConnectionFactory.\n\t * <p>This implementation uses JMS 1.1 API.\n\t * @return the new JMS Connection\n\t * @throws jakarta.jms.JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 329
    },
    "return": "Connection",
    "signature": "protected Connection createConnection()",
    "source_code": "\tprotected Connection createConnection() throws JMSException {\n\t\treturn obtainConnectionFactory().createConnection();\n\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#createSession(con)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS Session for the given Connection.\n\t * <p>This implementation uses JMS 1.1 API.\n\t * @param con the JMS Connection to create a Session for\n\t * @return the new JMS Session\n\t * @throws jakarta.jms.JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "Session",
    "signature": "protected Session createSession(Connection con)",
    "source_code": "\tprotected Session createSession(Connection con) throws JMSException {\n\t\treturn con.createSession(true, Session.AUTO_ACKNOWLEDGE);\n\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#doBegin(transaction,definition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "void",
    "signature": "protected void doBegin(Object transaction, TransactionDefinition definition)",
    "source_code": "\tprotected void doBegin(Object transaction, TransactionDefinition definition) {\n\t\tif (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {\n\t\t\tthrow new InvalidIsolationLevelException(\"JMS does not support an isolation level concept\");\n\t\t}\n\n\t\tConnectionFactory connectionFactory = obtainConnectionFactory();\n\t\tJmsTransactionObject txObject = (JmsTransactionObject) transaction;\n\t\tConnection con = null;\n\t\tSession session = null;\n\t\ttry {\n\t\t\tJmsResourceHolder resourceHolder;\n\t\t\tif (this.lazyResourceRetrieval) {\n\t\t\t\tresourceHolder = new LazyJmsResourceHolder(connectionFactory);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcon = createConnection();\n\t\t\t\tsession = createSession(con);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Created JMS transaction on Session [\" + session + \"] from Connection [\" + con + \"]\");\n\t\t\t\t}\n\t\t\t\tresourceHolder = new JmsResourceHolder(connectionFactory, con, session);\n\t\t\t}\n\t\t\tresourceHolder.setSynchronizedWithTransaction(true);\n\t\t\tint timeout = determineTimeout(definition);\n\t\t\tif (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\t\tresourceHolder.setTimeoutInSeconds(timeout);\n\t\t\t}\n\t\t\ttxObject.setResourceHolder(resourceHolder);\n\t\t\tTransactionSynchronizationManager.bindResource(connectionFactory, resourceHolder);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (session != null) {\n\t\t\t\ttry {\n\t\t\t\t\tsession.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (con != null) {\n\t\t\t\ttry {\n\t\t\t\t\tcon.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new CannotCreateTransactionException(\"Could not create JMS transaction\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#doCleanupAfterCompletion(transaction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "void",
    "signature": "protected void doCleanupAfterCompletion(Object transaction)",
    "source_code": "\tprotected void doCleanupAfterCompletion(Object transaction) {\n\t\tJmsTransactionObject txObject = (JmsTransactionObject) transaction;\n\t\tTransactionSynchronizationManager.unbindResource(obtainConnectionFactory());\n\t\ttxObject.getResourceHolder().closeAll();\n\t\ttxObject.getResourceHolder().clear();\n\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#doCommit(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "protected void doCommit(DefaultTransactionStatus status)",
    "source_code": "\tprotected void doCommit(DefaultTransactionStatus status) {\n\t\tJmsTransactionObject txObject = (JmsTransactionObject) status.getTransaction();\n\t\tSession session = txObject.getResourceHolder().getOriginalSession();\n\t\tif (session != null) {\n\t\t\ttry {\n\t\t\t\tif (status.isDebug()) {\n\t\t\t\t\tlogger.debug(\"Committing JMS transaction on Session [\" + session + \"]\");\n\t\t\t\t}\n\t\t\t\tsession.commit();\n\t\t\t}\n\t\t\tcatch (TransactionRolledBackException ex) {\n\t\t\t\tthrow new UnexpectedRollbackException(\"JMS transaction rolled back\", ex);\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tthrow new TransactionSystemException(\"Could not commit JMS transaction\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#doGetTransaction()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "Object",
    "signature": "protected Object doGetTransaction()",
    "source_code": "\tprotected Object doGetTransaction() {\n\t\tJmsTransactionObject txObject = new JmsTransactionObject();\n\t\ttxObject.setResourceHolder(\n\t\t\t\t(JmsResourceHolder) TransactionSynchronizationManager.getResource(obtainConnectionFactory()));\n\t\treturn txObject;\n\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#doResume(transaction,suspendedResources)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "protected void doResume(@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected void doResume(@Nullable Object transaction, Object suspendedResources) {\n\t\tTransactionSynchronizationManager.bindResource(obtainConnectionFactory(), suspendedResources);\n\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#doRollback(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "void",
    "signature": "protected void doRollback(DefaultTransactionStatus status)",
    "source_code": "\tprotected void doRollback(DefaultTransactionStatus status) {\n\t\tJmsTransactionObject txObject = (JmsTransactionObject) status.getTransaction();\n\t\tSession session = txObject.getResourceHolder().getOriginalSession();\n\t\tif (session != null) {\n\t\t\ttry {\n\t\t\t\tif (status.isDebug()) {\n\t\t\t\t\tlogger.debug(\"Rolling back JMS transaction on Session [\" + session + \"]\");\n\t\t\t\t}\n\t\t\t\tsession.rollback();\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tthrow new TransactionSystemException(\"Could not roll back JMS transaction\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#doSetRollbackOnly(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "void",
    "signature": "protected void doSetRollbackOnly(DefaultTransactionStatus status)",
    "source_code": "\tprotected void doSetRollbackOnly(DefaultTransactionStatus status) {\n\t\tJmsTransactionObject txObject = (JmsTransactionObject) status.getTransaction();\n\t\ttxObject.getResourceHolder().setRollbackOnly();\n\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#doSuspend(transaction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "Object",
    "signature": "protected Object doSuspend(Object transaction)",
    "source_code": "\tprotected Object doSuspend(Object transaction) {\n\t\tJmsTransactionObject txObject = (JmsTransactionObject) transaction;\n\t\ttxObject.setResourceHolder(null);\n\t\treturn TransactionSynchronizationManager.unbindResource(obtainConnectionFactory());\n\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#flush()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 453
    },
    "return": "void",
    "signature": "public void flush()",
    "source_code": "\t\tpublic void flush() {\n\t\t\t// no-op\n\t\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#getConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 361
    },
    "return": "Connection",
    "signature": "public Connection getConnection()",
    "source_code": "\t\tpublic Connection getConnection() {\n\t\t\tinitializeConnection();\n\t\t\treturn super.getConnection();\n\t\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#getConnection(connectionType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connectionType"
    ],
    "position": {
      "column": 1,
      "line": 368
    },
    "return": "C",
    "signature": "public C getConnection(Class<C> connectionType)",
    "source_code": "\t\tpublic <C extends Connection> C getConnection(Class<C> connectionType) {\n\t\t\tinitializeConnection();\n\t\t\treturn super.getConnection(connectionType);\n\t\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#getConnectionFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JMS ConnectionFactory that this instance should manage transactions for.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "ConnectionFactory",
    "signature": "public ConnectionFactory getConnectionFactory()",
    "source_code": "\tpublic ConnectionFactory getConnectionFactory() {\n\t\treturn this.connectionFactory;\n\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#getResourceFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "Object",
    "signature": "public Object getResourceFactory()",
    "source_code": "\tpublic Object getResourceFactory() {\n\t\treturn obtainConnectionFactory();\n\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#getResourceHolder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 438
    },
    "return": "JmsResourceHolder",
    "signature": "public JmsResourceHolder getResourceHolder()",
    "source_code": "\t\tpublic JmsResourceHolder getResourceHolder() {\n\t\t\tAssert.state(this.resourceHolder != null, \"No JmsResourceHolder available\");\n\t\t\treturn this.resourceHolder;\n\t\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#getSession()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "Session",
    "signature": "public Session getSession()",
    "source_code": "\t\tpublic Session getSession() {\n\t\t\tinitializeSession();\n\t\t\treturn super.getSession();\n\t\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#getSession(sessionType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionType"
    ],
    "position": {
      "column": 1,
      "line": 382
    },
    "return": "S",
    "signature": "public S getSession(Class<S> sessionType)",
    "source_code": "\t\tpublic <S extends Session> S getSession(Class<S> sessionType) {\n\t\t\tinitializeSession();\n\t\t\treturn super.getSession(sessionType);\n\t\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#getSession(sessionType,connection)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionType",
      "connection"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "S",
    "signature": "public S getSession(Class<S> sessionType, @Nullable Connection connection)",
    "source_code": "\t\tpublic <S extends Session> S getSession(Class<S> sessionType, @Nullable Connection connection) {\n\t\t\tinitializeSession();\n\t\t\treturn super.getSession(sessionType, connection);\n\t\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#hasResourceHolder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "boolean",
    "signature": "public boolean hasResourceHolder()",
    "source_code": "\t\tpublic boolean hasResourceHolder() {\n\t\t\treturn (this.resourceHolder != null);\n\t\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#isExistingTransaction(transaction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "boolean",
    "signature": "protected boolean isExistingTransaction(Object transaction)",
    "source_code": "\tprotected boolean isExistingTransaction(Object transaction) {\n\t\tJmsTransactionObject txObject = (JmsTransactionObject) transaction;\n\t\treturn txObject.hasResourceHolder();\n\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#isRollbackOnly()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 448
    },
    "return": "boolean",
    "signature": "public boolean isRollbackOnly()",
    "source_code": "\t\tpublic boolean isRollbackOnly() {\n\t\t\treturn (this.resourceHolder != null && this.resourceHolder.isRollbackOnly());\n\t\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#obtainConnectionFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the ConnectionFactory for actual use.\n\t * @return the ConnectionFactory (never {@code null})\n\t * @throws IllegalStateException in case of no ConnectionFactory set\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "ConnectionFactory",
    "signature": "protected ConnectionFactory obtainConnectionFactory()",
    "source_code": "\tprotected final ConnectionFactory obtainConnectionFactory() {\n\t\tConnectionFactory connectionFactory = getConnectionFactory();\n\t\tAssert.state(connectionFactory != null, \"No ConnectionFactory set\");\n\t\treturn connectionFactory;\n\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#setConnectionFactory(cf)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JMS ConnectionFactory that this instance should manage transactions for.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void setConnectionFactory(@Nullable ConnectionFactory cf)",
    "source_code": "\tpublic void setConnectionFactory(@Nullable ConnectionFactory cf) {\n\t\tif (cf instanceof TransactionAwareConnectionFactoryProxy txAwareCFP) {\n\t\t\t// If we got a TransactionAwareConnectionFactoryProxy, we need to perform transactions\n\t\t\t// for its underlying target ConnectionFactory, else JMS access code won't see\n\t\t\t// properly exposed transactions (i.e. transactions for the target ConnectionFactory).\n\t\t\tthis.connectionFactory = txAwareCFP.getTargetConnectionFactory();\n\t\t}\n\t\telse {\n\t\t\tthis.connectionFactory = cf;\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#setLazyResourceRetrieval(lazyResourceRetrieval)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether this transaction manager should lazily retrieve a JMS\n\t * Connection and Session on access within a transaction ({@code true}).\n\t * By default, it will eagerly create a JMS Connection and Session at\n\t * transaction begin ({@code false}).\n\t * @since 5.1.6\n\t * @see JmsResourceHolder#getConnection()\n\t * @see JmsResourceHolder#getSession()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lazyResourceRetrieval"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "public void setLazyResourceRetrieval(boolean lazyResourceRetrieval)",
    "source_code": "\tpublic void setLazyResourceRetrieval(boolean lazyResourceRetrieval) {\n\t\tthis.lazyResourceRetrieval = lazyResourceRetrieval;\n\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#setResourceHolder(resourceHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceHolder"
    ],
    "position": {
      "column": 1,
      "line": 434
    },
    "return": "void",
    "signature": "public void setResourceHolder(@Nullable JmsResourceHolder resourceHolder)",
    "source_code": "\t\tpublic void setResourceHolder(@Nullable JmsResourceHolder resourceHolder) {\n\t\t\tthis.resourceHolder = resourceHolder;\n\t\t}"
  },
  "org.springframework.jms.connection.ResourceFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Callback interface for resource creation.\n\t * Serving as argument for the {@code doGetTransactionalSession} method.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 367
    },
    "signature": "public interface ResourceFactory",
    "source_code": "\tpublic interface ResourceFactory {\n\n\t\t/**\n\t\t * Fetch an appropriate Session from the given JmsResourceHolder.\n\t\t * @param holder the JmsResourceHolder\n\t\t * @return an appropriate Session fetched from the holder,\n\t\t * or {@code null} if none found\n\t\t */\n\t\t@Nullable\n\t\tSession getSession(JmsResourceHolder holder);\n\n\t\t/**\n\t\t * Fetch an appropriate Connection from the given JmsResourceHolder.\n\t\t * @param holder the JmsResourceHolder\n\t\t * @return an appropriate Connection fetched from the holder,\n\t\t * or {@code null} if none found\n\t\t */\n\t\t@Nullable\n\t\tConnection getConnection(JmsResourceHolder holder);\n\n\t\t/**\n\t\t * Create a new JMS Connection for registration with a JmsResourceHolder.\n\t\t * @return the new JMS Connection\n\t\t * @throws JMSException if thrown by JMS API methods\n\t\t */\n\t\tConnection createConnection() throws JMSException;\n\n\t\t/**\n\t\t * Create a new JMS Session for registration with a JmsResourceHolder.\n\t\t * @param con the JMS Connection to create a Session for\n\t\t * @return the new JMS Session\n\t\t * @throws JMSException if thrown by JMS API methods\n\t\t */\n\t\tSession createSession(Connection con) throws JMSException;\n\n\t\t/**\n\t\t * Return whether to allow for a local JMS transaction that is synchronized with\n\t\t * a Spring-managed transaction (where the main transaction might be a JDBC-based\n\t\t * one for a specific DataSource, for example), with the JMS transaction\n\t\t * committing right after the main transaction.\n\t\t * @return whether to allow for synchronizing a local JMS transaction\n\t\t */\n\t\tboolean isSynchedLocalTransactionAllowed();\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A JMS ConnectionFactory adapter that returns the same Connection\n * from all {@link #createConnection()} calls, and ignores calls to\n * {@link jakarta.jms.Connection#close()}. According to the JMS Connection\n * model, this is perfectly thread-safe (in contrast to e.g. JDBC). The\n * shared Connection can be automatically recovered in case of an Exception.\n *\n * <p>You can either pass in a specific JMS Connection directly or let this\n * factory lazily create a Connection via a given target ConnectionFactory.\n * This factory generally works with JMS 1.1 as well as the JMS 1.0.2 API.\n *\n * <p>Note that when using the JMS 1.0.2 API, this ConnectionFactory will switch\n * into queue/topic mode according to the JMS API methods used at runtime:\n * {@code createQueueConnection} and {@code createTopicConnection} will\n * lead to queue/topic mode, respectively; generic {@code createConnection}\n * calls will lead to a JMS 1.1 connection which is able to serve both modes.\n *\n * <p>As of Spring Framework 5, this class supports JMS 2.0 {@code JMSContext}\n * calls and therefore requires the JMS 2.0 API to be present at runtime.\n * It may nevertheless run against a JMS 1.1 driver (bound to the JMS 2.0 API)\n * as long as no actual JMS 2.0 calls are triggered by the application's setup.\n *\n * <p>Useful for testing and standalone environments in order to keep using the\n * same Connection for multiple {@link org.springframework.jms.core.JmsTemplate}\n * calls, without having a pooling ConnectionFactory underneath. This may span\n * any number of transactions, even concurrently executing transactions.\n *\n * <p>Note that Spring's message listener containers support the use of\n * a shared Connection within each listener container instance. Using\n * SingleConnectionFactory in combination only really makes sense for\n * sharing a single JMS Connection <i>across multiple listener containers</i>.\n *\n * @author Juergen Hoeller\n * @author Mark Pollack\n * @since 1.1\n * @see org.springframework.jms.core.JmsTemplate\n * @see org.springframework.jms.listener.SimpleMessageListenerContainer\n * @see org.springframework.jms.listener.DefaultMessageListenerContainer#setCacheLevel\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "signature": "public class SingleConnectionFactory",
    "source_code": "public class SingleConnectionFactory implements ConnectionFactory, QueueConnectionFactory,"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Make sure a Connection or ConnectionFactory has been set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tif (this.connection == null && getTargetConnectionFactory() == null) {\n\t\t\tthrow new IllegalArgumentException(\"Target Connection or ConnectionFactory is required\");\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#closeConnection(con)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close the given Connection.\n\t * @param con the Connection to close\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con"
    ],
    "position": {
      "column": 1,
      "line": 490
    },
    "return": "void",
    "signature": "protected void closeConnection(Connection con)",
    "source_code": "\tprotected void closeConnection(Connection con) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Closing shared JMS Connection: \" + con);\n\t\t}\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tif (this.startedCount > 0) {\n\t\t\t\t\tcon.stop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tcon.close();\n\t\t\t}\n\t\t}\n\t\tcatch (jakarta.jms.IllegalStateException ex) {\n\t\t\tlogger.debug(\"Ignoring Connection state exception - assuming already closed: \" + ex);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.warn(\"Could not close shared JMS Connection\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#createConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "Connection",
    "signature": "public Connection createConnection()",
    "source_code": "\tpublic Connection createConnection() throws JMSException {\n\t\treturn getSharedConnectionProxy(getConnection());\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#createConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "Connection",
    "signature": "public Connection createConnection(String username, String password)",
    "source_code": "\tpublic Connection createConnection(String username, String password) throws JMSException {\n\t\tthrow new jakarta.jms.IllegalStateException(\n\t\t\t\t\"SingleConnectionFactory does not support custom username and password\");\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#createContext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "JMSContext",
    "signature": "public JMSContext createContext()",
    "source_code": "\tpublic JMSContext createContext() {\n\t\treturn obtainTargetConnectionFactory().createContext();\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#createContext(sessionMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionMode"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "JMSContext",
    "signature": "public JMSContext createContext(int sessionMode)",
    "source_code": "\tpublic JMSContext createContext(int sessionMode) {\n\t\treturn obtainTargetConnectionFactory().createContext(sessionMode);\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#createContext(userName,password)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userName",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "JMSContext",
    "signature": "public JMSContext createContext(String userName, String password)",
    "source_code": "\tpublic JMSContext createContext(String userName, String password) {\n\t\treturn obtainTargetConnectionFactory().createContext(userName, password);\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#createContext(userName,password,sessionMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userName",
      "password",
      "sessionMode"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "JMSContext",
    "signature": "public JMSContext createContext(String userName, String password, int sessionMode)",
    "source_code": "\tpublic JMSContext createContext(String userName, String password, int sessionMode) {\n\t\treturn obtainTargetConnectionFactory().createContext(userName, password, sessionMode);\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#createQueueConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "QueueConnection",
    "signature": "public QueueConnection createQueueConnection()",
    "source_code": "\tpublic QueueConnection createQueueConnection() throws JMSException {\n\t\tConnection con;\n\t\tsynchronized (this.connectionMonitor) {\n\t\t\tthis.pubSubMode = Boolean.FALSE;\n\t\t\tcon = createConnection();\n\t\t}\n\t\tif (!(con instanceof QueueConnection queueConnection)) {\n\t\t\tthrow new jakarta.jms.IllegalStateException(\n\t\t\t\t\t\"This SingleConnectionFactory does not hold a QueueConnection but rather: \" + con);\n\t\t}\n\t\treturn queueConnection;\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#createQueueConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "QueueConnection",
    "signature": "public QueueConnection createQueueConnection(String username, String password)",
    "source_code": "\tpublic QueueConnection createQueueConnection(String username, String password) throws JMSException {\n\t\tthrow new jakarta.jms.IllegalStateException(\n\t\t\t\t\"SingleConnectionFactory does not support custom username and password\");\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#createSession(con,mode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a default Session for this ConnectionFactory,\n\t * adapting to JMS 1.0.2 style queue/topic mode if necessary.\n\t * @param con the JMS Connection to operate on\n\t * @param mode the Session acknowledgement mode\n\t * ({@code Session.TRANSACTED} or one of the common modes)\n\t * @return the newly created Session\n\t * @throws JMSException if thrown by the JMS API\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con",
      "mode"
    ],
    "position": {
      "column": 1,
      "line": 470
    },
    "return": "Session",
    "signature": "protected Session createSession(Connection con, Integer mode)",
    "source_code": "\tprotected Session createSession(Connection con, Integer mode) throws JMSException {\n\t\t// Determine JMS API arguments...\n\t\tboolean transacted = (mode == Session.SESSION_TRANSACTED);\n\t\tint ackMode = (transacted ? Session.AUTO_ACKNOWLEDGE : mode);\n\t\t// Now actually call the appropriate JMS factory method...\n\t\tif (Boolean.FALSE.equals(this.pubSubMode) && con instanceof QueueConnection queueConnection) {\n\t\t\treturn queueConnection.createQueueSession(transacted, ackMode);\n\t\t}\n\t\telse if (Boolean.TRUE.equals(this.pubSubMode) && con instanceof TopicConnection topicConnection) {\n\t\t\treturn topicConnection.createTopicSession(transacted, ackMode);\n\t\t}\n\t\telse {\n\t\t\treturn con.createSession(transacted, ackMode);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#createTopicConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "TopicConnection",
    "signature": "public TopicConnection createTopicConnection()",
    "source_code": "\tpublic TopicConnection createTopicConnection() throws JMSException {\n\t\tConnection con;\n\t\tsynchronized (this.connectionMonitor) {\n\t\t\tthis.pubSubMode = Boolean.TRUE;\n\t\t\tcon = createConnection();\n\t\t}\n\t\tif (!(con instanceof TopicConnection topicConnection)) {\n\t\t\tthrow new jakarta.jms.IllegalStateException(\n\t\t\t\t\t\"This SingleConnectionFactory does not hold a TopicConnection but rather: \" + con);\n\t\t}\n\t\treturn topicConnection;\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#createTopicConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "TopicConnection",
    "signature": "public TopicConnection createTopicConnection(String username, String password)",
    "source_code": "\tpublic TopicConnection createTopicConnection(String username, String password) throws JMSException {\n\t\tthrow new jakarta.jms.IllegalStateException(\n\t\t\t\t\"SingleConnectionFactory does not support custom username and password\");\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close the underlying shared connection.\n\t * The provider of this ConnectionFactory needs to care for proper shutdown.\n\t * <p>As this bean implements DisposableBean, a bean factory will\n\t * automatically invoke this on destruction of its cached singletons.\n\t * @see #resetConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 378
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t\tresetConnection();\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#doCreateConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS Connection via this template's ConnectionFactory.\n\t * @return the new JMS Connection\n\t * @throws jakarta.jms.JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 400
    },
    "return": "Connection",
    "signature": "protected Connection doCreateConnection()",
    "source_code": "\tprotected Connection doCreateConnection() throws JMSException {\n\t\tConnectionFactory cf = getTargetConnectionFactory();\n\t\tif (Boolean.FALSE.equals(this.pubSubMode) && cf instanceof QueueConnectionFactory queueFactory) {\n\t\t\treturn queueFactory.createQueueConnection();\n\t\t}\n\t\telse if (Boolean.TRUE.equals(this.pubSubMode) && cf instanceof TopicConnectionFactory topicFactory) {\n\t\t\treturn topicFactory.createTopicConnection();\n\t\t}\n\t\telse {\n\t\t\treturn obtainTargetConnectionFactory().createConnection();\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#getClientId()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a JMS client ID for the single Connection created and exposed\n\t * by this ConnectionFactory, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "String",
    "signature": "protected String getClientId()",
    "source_code": "\tprotected String getClientId() {\n\t\treturn this.clientId;\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#getConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain an initialized shared Connection.\n\t * @return the Connection (never {@code null})\n\t * @throws jakarta.jms.JMSException if thrown by JMS API methods\n\t * @see #initConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "Connection",
    "signature": "protected Connection getConnection()",
    "source_code": "\tprotected Connection getConnection() throws JMSException {\n\t\tsynchronized (this.connectionMonitor) {\n\t\t\tif (this.connection == null) {\n\t\t\t\tinitConnection();\n\t\t\t}\n\t\t\treturn this.connection;\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#getExceptionListener()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JMS ExceptionListener implementation that should be registered\n\t * with the single Connection created by this factory, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "ExceptionListener",
    "signature": "protected ExceptionListener getExceptionListener()",
    "source_code": "\tprotected ExceptionListener getExceptionListener() {\n\t\treturn this.exceptionListener;\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#getSession(con,mode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for obtaining a (potentially cached) Session.\n\t * <p>The default implementation always returns {@code null}.\n\t * Subclasses may override this for exposing specific Session handles,\n\t * possibly delegating to {@link #createSession} for the creation of raw\n\t * Session objects that will then get wrapped and returned from here.\n\t * @param con the JMS Connection to operate on\n\t * @param mode the Session acknowledgement mode\n\t * ({@code Session.TRANSACTED} or one of the common modes)\n\t * @return the Session to use, or {@code null} to indicate\n\t * creation of a raw standard Session\n\t * @throws JMSException if thrown by the JMS API\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con",
      "mode"
    ],
    "position": {
      "column": 1,
      "line": 457
    },
    "return": "Session",
    "signature": "protected Session getSession(Connection con, Integer mode)",
    "source_code": "\tprotected Session getSession(Connection con, Integer mode) throws JMSException {\n\t\treturn null;\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#getSharedConnectionProxy(target)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Wrap the given Connection with a proxy that delegates every method call to it\n\t * but suppresses close calls. This is useful for allowing application code to\n\t * handle a special framework Connection just like an ordinary Connection from a\n\t * JMS ConnectionFactory.\n\t * @param target the original Connection to wrap\n\t * @return the wrapped Connection\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target"
    ],
    "position": {
      "column": 1,
      "line": 520
    },
    "return": "Connection",
    "signature": "protected Connection getSharedConnectionProxy(Connection target)",
    "source_code": "\tprotected Connection getSharedConnectionProxy(Connection target) {\n\t\tList<Class<?>> classes = new ArrayList<>(3);\n\t\tclasses.add(Connection.class);\n\t\tif (target instanceof QueueConnection) {\n\t\t\tclasses.add(QueueConnection.class);\n\t\t}\n\t\tif (target instanceof TopicConnection) {\n\t\t\tclasses.add(TopicConnection.class);\n\t\t}\n\t\treturn (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(),\n\t\t\t\tClassUtils.toClassArray(classes), new SharedConnectionInvocationHandler());\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#getTargetConnectionFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the target ConnectionFactory which will be used to lazily\n\t * create a single Connection, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "ConnectionFactory",
    "signature": "public ConnectionFactory getTargetConnectionFactory()",
    "source_code": "\tpublic ConnectionFactory getTargetConnectionFactory() {\n\t\treturn this.targetConnectionFactory;\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#initConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the underlying shared Connection.\n\t * <p>Closes and reinitializes the Connection if an underlying\n\t * Connection is present already.\n\t * @throws jakarta.jms.JMSException if thrown by JMS API methods\n\t * @see #prepareConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "void",
    "signature": "public void initConnection()",
    "source_code": "\tpublic void initConnection() throws JMSException {\n\t\tif (getTargetConnectionFactory() == null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"'targetConnectionFactory' is required for lazily initializing a Connection\");\n\t\t}\n\t\tsynchronized (this.connectionMonitor) {\n\t\t\tif (this.connection != null) {\n\t\t\t\tcloseConnection(this.connection);\n\t\t\t}\n\t\t\tthis.connection = doCreateConnection();\n\t\t\tprepareConnection(this.connection);\n\t\t\tif (this.startedCount > 0) {\n\t\t\t\tthis.connection.start();\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Established shared JMS Connection: \" + this.connection);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 546
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\tObject other = args[0];\n\t\t\t\t\tif (proxy == other) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (other == null || !Proxy.isProxyClass(other.getClass())) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tInvocationHandler otherHandler = Proxy.getInvocationHandler(other);\n\t\t\t\t\treturn (otherHandler instanceof SharedConnectionInvocationHandler sharedHandler &&\n\t\t\t\t\t\t\tfactory() == sharedHandler.factory());\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of containing SingleConnectionFactory.\n\t\t\t\t\treturn System.identityHashCode(factory());\n\t\t\t\tcase \"toString\":\n\t\t\t\t\treturn \"Shared JMS Connection: \" + getConnection();\n\t\t\t\tcase \"setClientID\":\n\t\t\t\t\t// Handle setClientID method: throw exception if not compatible.\n\t\t\t\t\tString currentClientId = getConnection().getClientID();\n\t\t\t\t\tif (currentClientId != null && currentClientId.equals(args[0])) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new jakarta.jms.IllegalStateException(\n\t\t\t\t\t\t\t\t\"setClientID call not supported on proxy for shared Connection. \" +\n\t\t\t\t\t\t\t\t\"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n\t\t\t\t\t}\n\t\t\t\tcase \"setExceptionListener\":\n\t\t\t\t\t// Handle setExceptionListener method: add to the chain.\n\t\t\t\t\tsynchronized (connectionMonitor) {\n\t\t\t\t\t\tif (aggregatedExceptionListener != null) {\n\t\t\t\t\t\t\tExceptionListener listener = (ExceptionListener) args[0];\n\t\t\t\t\t\t\tif (listener != this.localExceptionListener) {\n\t\t\t\t\t\t\t\tif (this.localExceptionListener != null) {\n\t\t\t\t\t\t\t\t\taggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (listener != null) {\n\t\t\t\t\t\t\t\t\taggregatedExceptionListener.delegates.add(listener);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.localExceptionListener = listener;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new jakarta.jms.IllegalStateException(\n\t\t\t\t\t\t\t\t\t\"setExceptionListener call not supported on proxy for shared Connection. \" +\n\t\t\t\t\t\t\t\t\t\"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" +\n\t\t\t\t\t\t\t\t\t\"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \" +\n\t\t\t\t\t\t\t\t\t\"which will allow for registering further ExceptionListeners to the recovery chain.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase \"getExceptionListener\":\n\t\t\t\t\tsynchronized (connectionMonitor) {\n\t\t\t\t\t\tif (this.localExceptionListener != null) {\n\t\t\t\t\t\t\treturn this.localExceptionListener;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn getExceptionListener();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase \"start\":\n\t\t\t\t\tlocalStart();\n\t\t\t\t\treturn null;\n\t\t\t\tcase \"stop\":\n\t\t\t\t\tlocalStop();\n\t\t\t\t\treturn null;\n\t\t\t\tcase \"close\":\n\t\t\t\t\tlocalStop();\n\t\t\t\t\tsynchronized (connectionMonitor) {\n\t\t\t\t\t\tif (this.localExceptionListener != null) {\n\t\t\t\t\t\t\tif (aggregatedExceptionListener != null) {\n\t\t\t\t\t\t\t\taggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.localExceptionListener = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\tcase \"createSession\":\n\t\t\t\tcase \"createQueueSession\":\n\t\t\t\tcase \"createTopicSession\":\n\t\t\t\t\t// Default: JMS 2.0 createSession() method\n\t\t\t\t\tInteger mode = Session.AUTO_ACKNOWLEDGE;\n\t\t\t\t\tif (!ObjectUtils.isEmpty(args)) {\n\t\t\t\t\t\tif (args.length == 1) {\n\t\t\t\t\t\t\t// JMS 2.0 createSession(int) method\n\t\t\t\t\t\t\tmode = (Integer) args[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (args.length == 2) {\n\t\t\t\t\t\t\t// JMS 1.1 createSession(boolean, int) method\n\t\t\t\t\t\t\tboolean transacted = (Boolean) args[0];\n\t\t\t\t\t\t\tInteger ackMode = (Integer) args[1];\n\t\t\t\t\t\t\tmode = (transacted ? Session.SESSION_TRANSACTED : ackMode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSession session = getSession(getConnection(), mode);\n\t\t\t\t\tif (session != null) {\n\t\t\t\t\t\tif (!method.getReturnType().isInstance(session)) {\n\t\t\t\t\t\t\tString msg = \"JMS Session does not implement specific domain: \" + session;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tsession.close();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t\t\tlogger.trace(\"Failed to close newly obtained JMS Session\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthrow new jakarta.jms.IllegalStateException(msg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn session;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\treturn method.invoke(getConnection(), args);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#isReconnectOnException()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the single Connection should be renewed when\n\t * a JMSException is reported by the underlying Connection.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "boolean",
    "signature": "protected boolean isReconnectOnException()",
    "source_code": "\tprotected boolean isReconnectOnException() {\n\t\treturn this.reconnectOnException;\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#onException(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 707
    },
    "return": "void",
    "signature": "public void onException(JMSException ex)",
    "source_code": "\t\tpublic void onException(JMSException ex) {\n\t\t\t// Iterate over temporary copy in order to avoid ConcurrentModificationException,\n\t\t\t// since listener invocations may in turn trigger registration of listeners...\n\t\t\tSet<ExceptionListener> copy;\n\t\t\tsynchronized (connectionMonitor) {\n\t\t\t\tcopy = new LinkedHashSet<>(this.delegates);\n\t\t\t}\n\t\t\tfor (ExceptionListener listener : copy) {\n\t\t\t\tlistener.onException(ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#prepareConnection(con)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the given Connection before it is exposed.\n\t * <p>The default implementation applies ExceptionListener and client id.\n\t * Can be overridden in subclasses.\n\t * @param con the Connection to prepare\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setExceptionListener\n\t * @see #setReconnectOnException\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con"
    ],
    "position": {
      "column": 1,
      "line": 422
    },
    "return": "void",
    "signature": "protected void prepareConnection(Connection con)",
    "source_code": "\tprotected void prepareConnection(Connection con) throws JMSException {\n\t\tif (getClientId() != null) {\n\t\t\tcon.setClientID(getClientId());\n\t\t}\n\t\tif (this.aggregatedExceptionListener != null) {\n\t\t\tcon.setExceptionListener(this.aggregatedExceptionListener);\n\t\t}\n\t\telse if (getExceptionListener() != null || isReconnectOnException()) {\n\t\t\tExceptionListener listenerToUse = getExceptionListener();\n\t\t\tif (isReconnectOnException()) {\n\t\t\t\tthis.aggregatedExceptionListener = new AggregatedExceptionListener();\n\t\t\t\tthis.aggregatedExceptionListener.delegates.add(this);\n\t\t\t\tif (listenerToUse != null) {\n\t\t\t\t\tthis.aggregatedExceptionListener.delegates.add(listenerToUse);\n\t\t\t\t}\n\t\t\t\tlistenerToUse = this.aggregatedExceptionListener;\n\t\t\t}\n\t\t\tcon.setExceptionListener(listenerToUse);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#resetConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset the underlying shared Connection, to be reinitialized on next access.\n\t * @see #closeConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "void",
    "signature": "public void resetConnection()",
    "source_code": "\tpublic void resetConnection() {\n\t\tsynchronized (this.connectionMonitor) {\n\t\t\tif (this.connection != null) {\n\t\t\t\tcloseConnection(this.connection);\n\t\t\t}\n\t\t\tthis.connection = null;\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#setClientId(clientId)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a JMS client ID for the single Connection created and exposed\n\t * by this ConnectionFactory.\n\t * <p>Note that client IDs need to be unique among all active Connections\n\t * of the underlying JMS provider. Furthermore, a client ID can only be\n\t * assigned if the original ConnectionFactory hasn't already assigned one.\n\t * @see jakarta.jms.Connection#setClientID\n\t * @see #setTargetConnectionFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientId"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "void",
    "signature": "public void setClientId(@Nullable String clientId)",
    "source_code": "\tpublic void setClientId(@Nullable String clientId) {\n\t\tthis.clientId = clientId;\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#setExceptionListener(exceptionListener)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify an JMS ExceptionListener implementation that should be\n\t * registered with the single Connection created by this factory.\n\t * @see #setReconnectOnException\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exceptionListener"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "void",
    "signature": "public void setExceptionListener(@Nullable ExceptionListener exceptionListener)",
    "source_code": "\tpublic void setExceptionListener(@Nullable ExceptionListener exceptionListener) {\n\t\tthis.exceptionListener = exceptionListener;\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#setReconnectOnException(reconnectOnException)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether the single Connection should be reset (to be subsequently renewed)\n\t * when a JMSException is reported by the underlying Connection.\n\t * <p>Default is \"false\". Switch this to \"true\" to automatically trigger\n\t * recovery based on your JMS provider's exception notifications.\n\t * <p>Internally, this will lead to a special JMS ExceptionListener\n\t * (this SingleConnectionFactory itself) being registered with the\n\t * underlying Connection. This can also be combined with a\n\t * user-specified ExceptionListener, if desired.\n\t * @see #setExceptionListener\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reconnectOnException"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "void",
    "signature": "public void setReconnectOnException(boolean reconnectOnException)",
    "source_code": "\tpublic void setReconnectOnException(boolean reconnectOnException) {\n\t\tthis.reconnectOnException = reconnectOnException;\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#setTargetConnectionFactory(targetConnectionFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the target ConnectionFactory which will be used to lazily\n\t * create a single Connection.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetConnectionFactory"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void setTargetConnectionFactory(@Nullable ConnectionFactory targetConnectionFactory)",
    "source_code": "\tpublic void setTargetConnectionFactory(@Nullable ConnectionFactory targetConnectionFactory) {\n\t\tthis.targetConnectionFactory = targetConnectionFactory;\n\t}"
  },
  "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Proxy for a target JMS {@link jakarta.jms.ConnectionFactory}, adding awareness of\n * Spring-managed transactions. Similar to a transactional JNDI ConnectionFactory\n * as provided by a Jakarta EE application server.\n *\n * <p>Messaging code which should remain unaware of Spring's JMS support can work with\n * this proxy to seamlessly participate in Spring-managed transactions. Note that the\n * transaction manager, for example {@link JmsTransactionManager}, still needs to work\n * with the underlying ConnectionFactory, <i>not</i> with this proxy.\n *\n * <p><b>Make sure that TransactionAwareConnectionFactoryProxy is the outermost\n * ConnectionFactory of a chain of ConnectionFactory proxies/adapters.</b>\n * TransactionAwareConnectionFactoryProxy can delegate either directly to the\n * target factory or to some intermediary adapter like\n * {@link UserCredentialsConnectionFactoryAdapter}.\n *\n * <p>Delegates to {@link ConnectionFactoryUtils} for automatically participating\n * in thread-bound transactions, for example managed by {@link JmsTransactionManager}.\n * {@code createSession} calls and {@code close} calls on returned Sessions\n * will behave properly within a transaction, that is, always work on the transactional\n * Session. If not within a transaction, normal ConnectionFactory behavior applies.\n *\n * <p>Note that transactional JMS Sessions will be registered on a per-Connection\n * basis. To share the same JMS Session across a transaction, make sure that you\n * operate on the same JMS Connection handle - either through reusing the handle\n * or through configuring a {@link SingleConnectionFactory} underneath.\n *\n * <p>Returned transactional Session proxies will implement the {@link SessionProxy}\n * interface to allow for access to the underlying target Session. This is only\n * intended for accessing vendor-specific Session API or for testing purposes\n * (e.g. to perform manual transaction control). For typical application purposes,\n * simply use the standard JMS Session interface.\n *\n * <p>As of Spring Framework 5, this class delegates JMS 2.0 {@code JMSContext}\n * calls and therefore requires the JMS 2.0 API to be present at runtime.\n * It may nevertheless run against a JMS 1.1 driver (bound to the JMS 2.0 API)\n * as long as no actual JMS 2.0 calls are triggered by the application's setup.\n *\n * @author Juergen Hoeller\n * @since 2.0\n * @see UserCredentialsConnectionFactoryAdapter\n * @see SingleConnectionFactory\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "signature": "public class TransactionAwareConnectionFactoryProxy",
    "source_code": "public class TransactionAwareConnectionFactoryProxy"
  },
  "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy#createConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "Connection",
    "signature": "public Connection createConnection()",
    "source_code": "\tpublic Connection createConnection() throws JMSException {\n\t\tConnection targetConnection = getTargetConnectionFactory().createConnection();\n\t\treturn getTransactionAwareConnectionProxy(targetConnection);\n\t}"
  },
  "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy#createConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "Connection",
    "signature": "public Connection createConnection(String username, String password)",
    "source_code": "\tpublic Connection createConnection(String username, String password) throws JMSException {\n\t\tConnection targetConnection = getTargetConnectionFactory().createConnection(username, password);\n\t\treturn getTransactionAwareConnectionProxy(targetConnection);\n\t}"
  },
  "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy#createContext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "JMSContext",
    "signature": "public JMSContext createContext()",
    "source_code": "\tpublic JMSContext createContext() {\n\t\treturn getTargetConnectionFactory().createContext();\n\t}"
  },
  "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy#createContext(sessionMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionMode"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "JMSContext",
    "signature": "public JMSContext createContext(int sessionMode)",
    "source_code": "\tpublic JMSContext createContext(int sessionMode) {\n\t\treturn getTargetConnectionFactory().createContext(sessionMode);\n\t}"
  },
  "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy#createContext(userName,password)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userName",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "JMSContext",
    "signature": "public JMSContext createContext(String userName, String password)",
    "source_code": "\tpublic JMSContext createContext(String userName, String password) {\n\t\treturn getTargetConnectionFactory().createContext(userName, password);\n\t}"
  },
  "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy#createContext(userName,password,sessionMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userName",
      "password",
      "sessionMode"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "JMSContext",
    "signature": "public JMSContext createContext(String userName, String password, int sessionMode)",
    "source_code": "\tpublic JMSContext createContext(String userName, String password, int sessionMode) {\n\t\treturn getTargetConnectionFactory().createContext(userName, password, sessionMode);\n\t}"
  },
  "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy#createQueueConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "QueueConnection",
    "signature": "public QueueConnection createQueueConnection()",
    "source_code": "\tpublic QueueConnection createQueueConnection() throws JMSException {\n\t\tConnectionFactory target = getTargetConnectionFactory();\n\t\tif (!(target instanceof QueueConnectionFactory queueFactory)) {\n\t\t\tthrow new jakarta.jms.IllegalStateException(\"'targetConnectionFactory' is no QueueConnectionFactory\");\n\t\t}\n\t\tQueueConnection targetConnection = queueFactory.createQueueConnection();\n\t\treturn (QueueConnection) getTransactionAwareConnectionProxy(targetConnection);\n\t}"
  },
  "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy#createQueueConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "QueueConnection",
    "signature": "public QueueConnection createQueueConnection(String username, String password)",
    "source_code": "\tpublic QueueConnection createQueueConnection(String username, String password) throws JMSException {\n\t\tConnectionFactory target = getTargetConnectionFactory();\n\t\tif (!(target instanceof QueueConnectionFactory queueFactory)) {\n\t\t\tthrow new jakarta.jms.IllegalStateException(\"'targetConnectionFactory' is no QueueConnectionFactory\");\n\t\t}\n\t\tQueueConnection targetConnection = queueFactory.createQueueConnection(username, password);\n\t\treturn (QueueConnection) getTransactionAwareConnectionProxy(targetConnection);\n\t}"
  },
  "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy#createTopicConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "TopicConnection",
    "signature": "public TopicConnection createTopicConnection()",
    "source_code": "\tpublic TopicConnection createTopicConnection() throws JMSException {\n\t\tConnectionFactory target = getTargetConnectionFactory();\n\t\tif (!(target instanceof TopicConnectionFactory topicFactory)) {\n\t\t\tthrow new jakarta.jms.IllegalStateException(\"'targetConnectionFactory' is no TopicConnectionFactory\");\n\t\t}\n\t\tTopicConnection targetConnection = topicFactory.createTopicConnection();\n\t\treturn (TopicConnection) getTransactionAwareConnectionProxy(targetConnection);\n\t}"
  },
  "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy#createTopicConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "TopicConnection",
    "signature": "public TopicConnection createTopicConnection(String username, String password)",
    "source_code": "\tpublic TopicConnection createTopicConnection(String username, String password) throws JMSException {\n\t\tConnectionFactory target = getTargetConnectionFactory();\n\t\tif (!(target instanceof TopicConnectionFactory topicFactory)) {\n\t\t\tthrow new jakarta.jms.IllegalStateException(\"'targetConnectionFactory' is no TopicConnectionFactory\");\n\t\t}\n\t\tTopicConnection targetConnection = topicFactory.createTopicConnection(username, password);\n\t\treturn (TopicConnection) getTransactionAwareConnectionProxy(targetConnection);\n\t}"
  },
  "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy#getTargetConnectionFactory()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the target ConnectionFactory that this ConnectionFactory should delegate to.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "ConnectionFactory",
    "signature": "protected ConnectionFactory getTargetConnectionFactory()",
    "source_code": "\tprotected ConnectionFactory getTargetConnectionFactory() {\n\t\tConnectionFactory target = this.targetConnectionFactory;\n\t\tAssert.state(target != null, \"'targetConnectionFactory' is required\");\n\t\treturn target;\n\t}"
  },
  "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy#getTransactionAwareConnectionProxy(target)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Wrap the given Connection with a proxy that delegates every method call to it\n\t * but handles Session lookup in a transaction-aware fashion.\n\t * @param target the original Connection to wrap\n\t * @return the wrapped Connection\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "Connection",
    "signature": "protected Connection getTransactionAwareConnectionProxy(Connection target)",
    "source_code": "\tprotected Connection getTransactionAwareConnectionProxy(Connection target) {\n\t\tList<Class<?>> classes = new ArrayList<>(3);\n\t\tclasses.add(Connection.class);\n\t\tif (target instanceof QueueConnection) {\n\t\t\tclasses.add(QueueConnection.class);\n\t\t}\n\t\tif (target instanceof TopicConnection) {\n\t\t\tclasses.add(TopicConnection.class);\n\t\t}\n\t\treturn (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(),\n\t\t\t\tClassUtils.toClassArray(classes), new TransactionAwareConnectionInvocationHandler(target));\n\t}"
  },
  "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 329
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on SessionProxy interface coming in...\n\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of Connection proxy.\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\tcase \"commit\":\n\t\t\t\t\tthrow new TransactionInProgressException(\"Commit call not allowed within a managed transaction\");\n\t\t\t\tcase \"rollback\":\n\t\t\t\t\tthrow new TransactionInProgressException(\"Rollback call not allowed within a managed transaction\");\n\t\t\t\tcase \"close\":\n\t\t\t\t\t// Handle close method: not to be closed within a transaction.\n\t\t\t\t\treturn null;\n\t\t\t\tcase \"getTargetSession\":\n\t\t\t\t\t// Handle getTargetSession method: return underlying Session.\n\t\t\t\t\treturn this.target;\n\t\t\t}\n\n\t\t\t// Invoke method on target Session.\n\t\t\ttry {\n\t\t\t\treturn method.invoke(this.target, args);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy#isSynchedLocalTransactionAllowed()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to allow for a local JMS transaction that is synchronized\n\t * with a Spring-managed transaction.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "boolean",
    "signature": "protected boolean isSynchedLocalTransactionAllowed()",
    "source_code": "\tprotected boolean isSynchedLocalTransactionAllowed() {\n\t\treturn this.synchedLocalTransactionAllowed;\n\t}"
  },
  "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy#setSynchedLocalTransactionAllowed(synchedLocalTransactionAllowed)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to allow for a local JMS transaction that is synchronized with a\n\t * Spring-managed transaction (where the main transaction might be a JDBC-based\n\t * one for a specific DataSource, for example), with the JMS transaction committing\n\t * right after the main transaction. If not allowed, the given ConnectionFactory\n\t * needs to handle transaction enlistment underneath the covers.\n\t * <p>Default is \"false\": If not within a managed transaction that encompasses\n\t * the underlying JMS ConnectionFactory, standard Sessions will be returned.\n\t * Turn this flag on to allow participation in any Spring-managed transaction,\n\t * with a local JMS transaction synchronized with the main transaction.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "synchedLocalTransactionAllowed"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void setSynchedLocalTransactionAllowed(boolean synchedLocalTransactionAllowed)",
    "source_code": "\tpublic void setSynchedLocalTransactionAllowed(boolean synchedLocalTransactionAllowed) {\n\t\tthis.synchedLocalTransactionAllowed = synchedLocalTransactionAllowed;\n\t}"
  },
  "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy#setTargetConnectionFactory(targetConnectionFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the target ConnectionFactory that this ConnectionFactory should delegate to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetConnectionFactory"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void setTargetConnectionFactory(ConnectionFactory targetConnectionFactory)",
    "source_code": "\tpublic final void setTargetConnectionFactory(ConnectionFactory targetConnectionFactory) {\n\t\tAssert.notNull(targetConnectionFactory, \"'targetConnectionFactory' must not be null\");\n\t\tthis.targetConnectionFactory = targetConnectionFactory;\n\t}"
  },
  "org.springframework.jms.connection.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.jms.connection.target": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "protected MessageConsumer target",
    "source_code": "\tprotected final MessageConsumer target;",
    "type": "MessageConsumer"
  },
  "org.springframework.jms.core.JmsTemplate": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Helper class that simplifies synchronous JMS access code.\n *\n * <p>If you want to use dynamic destination creation, you must specify\n * the type of JMS destination to create, using the \"pubSubDomain\" property.\n * For other operations, this is not necessary. Point-to-Point (Queues) is the default\n * domain.\n *\n * <p>Default settings for JMS Sessions are \"not transacted\" and \"auto-acknowledge\".\n * As defined by the Jakarta EE specification, the transaction and acknowledgement\n * parameters are ignored when a JMS Session is created inside an active\n * transaction, no matter if a JTA transaction or a Spring-managed transaction.\n * To configure them for native JMS usage, specify appropriate values for\n * the \"sessionTransacted\" and \"sessionAcknowledgeMode\" bean properties.\n *\n * <p>This template uses a\n * {@link org.springframework.jms.support.destination.DynamicDestinationResolver}\n * and a {@link org.springframework.jms.support.converter.SimpleMessageConverter}\n * as default strategies for resolving a destination name or converting a message,\n * respectively. These defaults can be overridden through the \"destinationResolver\"\n * and \"messageConverter\" bean properties.\n *\n * <p><b>NOTE: The {@code ConnectionFactory} used with this template should\n * return pooled Connections (or a single shared Connection) as well as pooled\n * Sessions and MessageProducers. Otherwise, performance of ad-hoc JMS operations\n * is going to suffer.</b> The simplest option is to use the Spring-provided\n * {@link org.springframework.jms.connection.SingleConnectionFactory} as a\n * decorator for your target {@code ConnectionFactory}, reusing a single\n * JMS Connection in a thread-safe fashion; this is often good enough for the\n * purpose of sending messages via this template. In a Jakarta EE environment,\n * make sure that the {@code ConnectionFactory} is obtained from the\n * application's environment naming context via JNDI; application servers\n * typically expose pooled, transaction-aware factories there.\n *\n * @author Mark Pollack\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @since 1.1\n * @see #setConnectionFactory\n * @see #setPubSubDomain\n * @see #setDestinationResolver\n * @see #setMessageConverter\n * @see jakarta.jms.MessageProducer\n * @see jakarta.jms.MessageConsumer\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "signature": "public class JmsTemplate",
    "source_code": "public class JmsTemplate extends JmsDestinationAccessor implements JmsOperations {\n\n\t/** Internal ResourceFactory adapter for interacting with ConnectionFactoryUtils. */\n\tprivate final JmsTemplateResourceFactory transactionalResourceFactory = new JmsTemplateResourceFactory();\n\n\n\t@Nullable\n\tprivate Object defaultDestination;\n\n\t@Nullable\n\tprivate MessageConverter messageConverter;\n\n\n\tprivate boolean messageIdEnabled = true;\n\n\tprivate boolean messageTimestampEnabled = true;\n\n\tprivate boolean pubSubNoLocal = false;\n\n\tprivate long receiveTimeout = RECEIVE_TIMEOUT_INDEFINITE_WAIT;\n\n\tprivate long deliveryDelay = -1;\n\n\n\tprivate boolean explicitQosEnabled = false;\n\n\tprivate int deliveryMode = Message.DEFAULT_DELIVERY_MODE;\n\n\tprivate int priority = Message.DEFAULT_PRIORITY;\n\n\tprivate long timeToLive = Message.DEFAULT_TIME_TO_LIVE;\n\n\n\t/**\n\t * Create a new JmsTemplate for bean-style usage.\n\t * <p>Note: The ConnectionFactory has to be set before using the instance.\n\t * This constructor can be used to prepare a JmsTemplate via a BeanFactory,\n\t * typically setting the ConnectionFactory via setConnectionFactory.\n\t * @see #setConnectionFactory\n\t */\n\tpublic JmsTemplate() {\n\t\tinitDefaultStrategies();\n\t}\n\n\t/**\n\t * Create a new JmsTemplate, given a ConnectionFactory.\n\t * @param connectionFactory the ConnectionFactory to obtain Connections from\n\t */\n\tpublic JmsTemplate(ConnectionFactory connectionFactory) {\n\t\tthis();\n\t\tsetConnectionFactory(connectionFactory);\n\t\tafterPropertiesSet();\n\t}\n\n\t/**\n\t * Initialize the default implementations for the template's strategies:\n\t * DynamicDestinationResolver and SimpleMessageConverter.\n\t * @see #setDestinationResolver\n\t * @see #setMessageConverter\n\t * @see org.springframework.jms.support.destination.DynamicDestinationResolver\n\t * @see org.springframework.jms.support.converter.SimpleMessageConverter\n\t */\n\tprotected void initDefaultStrategies() {\n\t\tsetMessageConverter(new SimpleMessageConverter());\n\t}\n\n\n\t/**\n\t * Set the destination to be used on send/receive operations that do not\n\t * have a destination parameter.\n\t * <p>Alternatively, specify a \"defaultDestinationName\", to be\n\t * dynamically resolved via the DestinationResolver.\n\t * @see #send(MessageCreator)\n\t * @see #convertAndSend(Object)\n\t * @see #convertAndSend(Object, MessagePostProcessor)\n\t * @see #setDefaultDestinationName(String)\n\t */\n\tpublic void setDefaultDestination(@Nullable Destination destination) {\n\t\tthis.defaultDestination = destination;\n\t}\n\n\t/**\n\t * Return the destination to be used on send/receive operations that do not\n\t * have a destination parameter.\n\t */\n\t@Nullable\n\tpublic Destination getDefaultDestination() {\n\t\treturn (this.defaultDestination instanceof Destination dest ? dest : null);\n\t}\n\n\t@Nullable\n\tprivate Queue getDefaultQueue() {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null && !(defaultDestination instanceof Queue)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"'defaultDestination' does not correspond to a Queue. Check configuration of JmsTemplate.\");\n\t\t}\n\t\treturn (Queue) defaultDestination;\n\t}\n\n\t/**\n\t * Set the destination name to be used on send/receive operations that\n\t * do not have a destination parameter. The specified name will be\n\t * dynamically resolved via the DestinationResolver.\n\t * <p>Alternatively, specify a JMS Destination object as \"defaultDestination\".\n\t * @see #send(MessageCreator)\n\t * @see #convertAndSend(Object)\n\t * @see #convertAndSend(Object, MessagePostProcessor)\n\t * @see #setDestinationResolver\n\t * @see #setDefaultDestination(jakarta.jms.Destination)\n\t */\n\tpublic void setDefaultDestinationName(@Nullable String destinationName) {\n\t\tthis.defaultDestination = destinationName;\n\t}\n\n\t/**\n\t * Return the destination name to be used on send/receive operations that\n\t * do not have a destination parameter.\n\t */\n\t@Nullable\n\tpublic String getDefaultDestinationName() {\n\t\treturn (this.defaultDestination instanceof String name ? name : null);\n\t}\n\n\tprivate String getRequiredDefaultDestinationName() throws IllegalStateException {\n\t\tString name = getDefaultDestinationName();\n\t\tif (name == null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"No 'defaultDestination' or 'defaultDestinationName' specified. Check configuration of JmsTemplate.\");\n\t\t}\n\t\treturn name;\n\t}\n\n\t/**\n\t * Set the message converter for this template. Used to resolve\n\t * Object parameters to convertAndSend methods and Object results\n\t * from receiveAndConvert methods.\n\t * <p>The default converter is a SimpleMessageConverter, which is able\n\t * to handle BytesMessages, TextMessages and ObjectMessages.\n\t * @see #convertAndSend\n\t * @see #receiveAndConvert\n\t * @see org.springframework.jms.support.converter.SimpleMessageConverter\n\t */\n\tpublic void setMessageConverter(@Nullable MessageConverter messageConverter) {\n\t\tthis.messageConverter = messageConverter;\n\t}\n\n\t/**\n\t * Return the message converter for this template.\n\t */\n\t@Nullable\n\tpublic MessageConverter getMessageConverter() {\n\t\treturn this.messageConverter;\n\t}\n\n\tprivate MessageConverter getRequiredMessageConverter() throws IllegalStateException {\n\t\tMessageConverter converter = getMessageConverter();\n\t\tif (converter == null) {\n\t\t\tthrow new IllegalStateException(\"No 'messageConverter' specified. Check configuration of JmsTemplate.\");\n\t\t}\n\t\treturn converter;\n\t}\n\n\n\t/**\n\t * Set whether message IDs are enabled. Default is \"true\".\n\t * <p>This is only a hint to the JMS producer.\n\t * See the JMS javadocs for details.\n\t * @see jakarta.jms.MessageProducer#setDisableMessageID\n\t */\n\tpublic void setMessageIdEnabled(boolean messageIdEnabled) {\n\t\tthis.messageIdEnabled = messageIdEnabled;\n\t}\n\n\t/**\n\t * Return whether message IDs are enabled.\n\t */\n\tpublic boolean isMessageIdEnabled() {\n\t\treturn this.messageIdEnabled;\n\t}\n\n\t/**\n\t * Set whether message timestamps are enabled. Default is \"true\".\n\t * <p>This is only a hint to the JMS producer.\n\t * See the JMS javadocs for details.\n\t * @see jakarta.jms.MessageProducer#setDisableMessageTimestamp\n\t */\n\tpublic void setMessageTimestampEnabled(boolean messageTimestampEnabled) {\n\t\tthis.messageTimestampEnabled = messageTimestampEnabled;\n\t}\n\n\t/**\n\t * Return whether message timestamps are enabled.\n\t */\n\tpublic boolean isMessageTimestampEnabled() {\n\t\treturn this.messageTimestampEnabled;\n\t}\n\n\t/**\n\t * Set whether to inhibit the delivery of messages published by its own connection.\n\t * Default is \"false\".\n\t * @see jakarta.jms.Session#createConsumer(jakarta.jms.Destination, String, boolean)\n\t */\n\tpublic void setPubSubNoLocal(boolean pubSubNoLocal) {\n\t\tthis.pubSubNoLocal = pubSubNoLocal;\n\t}\n\n\t/**\n\t * Return whether to inhibit the delivery of messages published by its own connection.\n\t */\n\tpublic boolean isPubSubNoLocal() {\n\t\treturn this.pubSubNoLocal;\n\t}\n\n\t/**\n\t * Set the timeout to use for receive calls (in milliseconds).\n\t * <p>The default is {@link #RECEIVE_TIMEOUT_INDEFINITE_WAIT}, which indicates\n\t * a blocking receive without timeout.\n\t * <p>Specify {@link #RECEIVE_TIMEOUT_NO_WAIT} (or any other negative value)\n\t * to indicate that a receive operation should check if a message is\n\t * immediately available without blocking.\n\t * @see #receiveFromConsumer(MessageConsumer, long)\n\t * @see jakarta.jms.MessageConsumer#receive(long)\n\t * @see jakarta.jms.MessageConsumer#receiveNoWait()\n\t * @see jakarta.jms.MessageConsumer#receive()\n\t */\n\tpublic void setReceiveTimeout(long receiveTimeout) {\n\t\tthis.receiveTimeout = receiveTimeout;\n\t}\n\n\t/**\n\t * Return the timeout to use for receive calls (in milliseconds).\n\t */\n\tpublic long getReceiveTimeout() {\n\t\treturn this.receiveTimeout;\n\t}\n\n\t/**\n\t * Set the delivery delay to use for send calls (in milliseconds).\n\t * <p>The default is -1 (no delivery delay passed on to the broker).\n\t * Note that this feature requires JMS 2.0.\n\t */\n\tpublic void setDeliveryDelay(long deliveryDelay) {\n\t\tthis.deliveryDelay = deliveryDelay;\n\t}\n\n\t/**\n\t * Return the delivery delay to use for send calls (in milliseconds).\n\t */\n\tpublic long getDeliveryDelay() {\n\t\treturn this.deliveryDelay;\n\t}\n\n\n\t/**\n\t * Set if the QOS values (deliveryMode, priority, timeToLive)\n\t * should be used for sending a message.\n\t * @see #setDeliveryMode\n\t * @see #setPriority\n\t * @see #setTimeToLive\n\t */\n\tpublic void setExplicitQosEnabled(boolean explicitQosEnabled) {\n\t\tthis.explicitQosEnabled = explicitQosEnabled;\n\t}\n\n\t/**\n\t * If \"true\", then the values of deliveryMode, priority, and timeToLive\n\t * will be used when sending a message. Otherwise, the default values,\n\t * that may be set administratively, will be used.\n\t * @return true if overriding default values of QOS parameters\n\t * (deliveryMode, priority, and timeToLive)\n\t * @see #setDeliveryMode\n\t * @see #setPriority\n\t * @see #setTimeToLive\n\t */\n\tpublic boolean isExplicitQosEnabled() {\n\t\treturn this.explicitQosEnabled;\n\t}\n\n\t/**\n\t * Set the {@link QosSettings} to use when sending a message.\n\t * @param settings the deliveryMode, priority, and timeToLive settings to use\n\t * @since 5.0\n\t * @see #setExplicitQosEnabled(boolean)\n\t * @see #setDeliveryMode(int)\n\t * @see #setPriority(int)\n\t * @see #setTimeToLive(long)\n\t */\n\tpublic void setQosSettings(QosSettings settings) {\n\t\tAssert.notNull(settings, \"Settings must not be null\");\n\t\tsetExplicitQosEnabled(true);\n\t\tsetDeliveryMode(settings.getDeliveryMode());\n\t\tsetPriority(settings.getPriority());\n\t\tsetTimeToLive(settings.getTimeToLive());\n\t}\n\n\t/**\n\t * Set whether message delivery should be persistent or non-persistent,\n\t * specified as boolean value (\"true\" or \"false\"). This will set the delivery\n\t * mode accordingly, to either \"PERSISTENT\" (2) or \"NON_PERSISTENT\" (1).\n\t * <p>Default is \"true\" a.k.a. delivery mode \"PERSISTENT\".\n\t * @see #setDeliveryMode(int)\n\t * @see jakarta.jms.DeliveryMode#PERSISTENT\n\t * @see jakarta.jms.DeliveryMode#NON_PERSISTENT\n\t */\n\tpublic void setDeliveryPersistent(boolean deliveryPersistent) {\n\t\tthis.deliveryMode = (deliveryPersistent ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT);\n\t}\n\n\t/**\n\t * Set the delivery mode to use when sending a message.\n\t * Default is the JMS Message default: \"PERSISTENT\".\n\t * <p>Since a default value may be defined administratively,\n\t * this is only used when \"isExplicitQosEnabled\" equals \"true\".\n\t * @param deliveryMode the delivery mode to use\n\t * @see #isExplicitQosEnabled\n\t * @see jakarta.jms.DeliveryMode#PERSISTENT\n\t * @see jakarta.jms.DeliveryMode#NON_PERSISTENT\n\t * @see jakarta.jms.Message#DEFAULT_DELIVERY_MODE\n\t * @see jakarta.jms.MessageProducer#send(jakarta.jms.Message, int, int, long)\n\t */\n\tpublic void setDeliveryMode(int deliveryMode) {\n\t\tthis.deliveryMode = deliveryMode;\n\t}\n\n\t/**\n\t * Return the delivery mode to use when sending a message.\n\t */\n\tpublic int getDeliveryMode() {\n\t\treturn this.deliveryMode;\n\t}\n\n\t/**\n\t * Set the priority of a message when sending.\n\t * <p>Since a default value may be defined administratively,\n\t * this is only used when \"isExplicitQosEnabled\" equals \"true\".\n\t * @see #isExplicitQosEnabled\n\t * @see jakarta.jms.Message#DEFAULT_PRIORITY\n\t * @see jakarta.jms.MessageProducer#send(jakarta.jms.Message, int, int, long)\n\t */\n\tpublic void setPriority(int priority) {\n\t\tthis.priority = priority;\n\t}\n\n\t/**\n\t * Return the priority of a message when sending.\n\t */\n\tpublic int getPriority() {\n\t\treturn this.priority;\n\t}\n\n\t/**\n\t * Set the time-to-live of the message when sending.\n\t * <p>Since a default value may be defined administratively,\n\t * this is only used when \"isExplicitQosEnabled\" equals \"true\".\n\t * @param timeToLive the message's lifetime (in milliseconds)\n\t * @see #isExplicitQosEnabled\n\t * @see jakarta.jms.Message#DEFAULT_TIME_TO_LIVE\n\t * @see jakarta.jms.MessageProducer#send(jakarta.jms.Message, int, int, long)\n\t */\n\tpublic void setTimeToLive(long timeToLive) {\n\t\tthis.timeToLive = timeToLive;\n\t}\n\n\t/**\n\t * Return the time-to-live of the message when sending.\n\t */\n\tpublic long getTimeToLive() {\n\t\treturn this.timeToLive;\n\t}\n\n\n\t//---------------------------------------------------------------------------------------\n\t// JmsOperations execute methods\n\t//---------------------------------------------------------------------------------------\n\n\t@Override\n\t@Nullable\n\tpublic <T> T execute(SessionCallback<T> action) throws JmsException {\n\t\treturn execute(action, false);\n\t}\n\n\t/**\n\t * Execute the action specified by the given action object within a\n\t * JMS Session. Generalized version of {@code execute(SessionCallback)},\n\t * allowing the JMS Connection to be started on the fly.\n\t * <p>Use {@code execute(SessionCallback)} for the general case.\n\t * Starting the JMS Connection is just necessary for receiving messages,\n\t * which is preferably achieved through the {@code receive} methods.\n\t * @param action callback object that exposes the Session\n\t * @param startConnection whether to start the Connection\n\t * @return the result object from working with the Session\n\t * @throws JmsException if there is any problem\n\t * @see #execute(SessionCallback)\n\t * @see #receive\n\t */\n\t@Nullable\n\tpublic <T> T execute(SessionCallback<T> action, boolean startConnection) throws JmsException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\tConnection conToClose = null;\n\t\tSession sessionToClose = null;\n\t\ttry {\n\t\t\tSession sessionToUse = ConnectionFactoryUtils.doGetTransactionalSession(\n\t\t\t\t\tobtainConnectionFactory(), this.transactionalResourceFactory, startConnection);\n\t\t\tif (sessionToUse == null) {\n\t\t\t\tconToClose = createConnection();\n\t\t\t\tsessionToClose = createSession(conToClose);\n\t\t\t\tif (startConnection) {\n\t\t\t\t\tconToClose.start();\n\t\t\t\t}\n\t\t\t\tsessionToUse = sessionToClose;\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Executing callback on JMS Session: \" + sessionToUse);\n\t\t\t}\n\t\t\treturn action.doInJms(sessionToUse);\n\t\t}\n\t\tcatch (JMSException ex) {\n\t\t\tthrow convertJmsAccessException(ex);\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeSession(sessionToClose);\n\t\t\tConnectionFactoryUtils.releaseConnection(conToClose, getConnectionFactory(), startConnection);\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic <T> T execute(ProducerCallback<T> action) throws JmsException {\n\t\tString defaultDestinationName = getDefaultDestinationName();\n\t\tif (defaultDestinationName != null) {\n\t\t\treturn execute(defaultDestinationName, action);\n\t\t}\n\t\telse {\n\t\t\treturn execute(getDefaultDestination(), action);\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic <T> T execute(final @Nullable Destination destination, final ProducerCallback<T> action) throws JmsException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tMessageProducer producer = createProducer(session, destination);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, producer);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t\t}\n\t\t}, false);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic <T> T execute(final String destinationName, final ProducerCallback<T> action) throws JmsException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\tMessageProducer producer = createProducer(session, destination);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, producer);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t\t}\n\t\t}, false);\n\t}\n\n\n\t//---------------------------------------------------------------------------------------\n\t// Convenience methods for sending messages\n\t//---------------------------------------------------------------------------------------\n\n\t@Override\n\tpublic void send(MessageCreator messageCreator) throws JmsException {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\tsend(defaultDestination, messageCreator);\n\t\t}\n\t\telse {\n\t\t\tsend(getRequiredDefaultDestinationName(), messageCreator);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void send(final Destination destination, final MessageCreator messageCreator) throws JmsException {\n\t\texecute(session -> {\n\t\t\tdoSend(session, destination, messageCreator);\n\t\t\treturn null;\n\t\t}, false);\n\t}\n\n\t@Override\n\tpublic void send(final String destinationName, final MessageCreator messageCreator) throws JmsException {\n\t\texecute(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\tdoSend(session, destination, messageCreator);\n\t\t\treturn null;\n\t\t}, false);\n\t}\n\n\t/**\n\t * Send the given JMS message.\n\t * @param session the JMS Session to operate on\n\t * @param destination the JMS Destination to send to\n\t * @param messageCreator callback to create a JMS Message\n\t * @throws JMSException if thrown by JMS API methods\n\t */\n\tprotected void doSend(Session session, Destination destination, MessageCreator messageCreator)\n\t\t\tthrows JMSException {\n\n\t\tAssert.notNull(messageCreator, \"MessageCreator must not be null\");\n\t\tMessageProducer producer = createProducer(session, destination);\n\t\ttry {\n\t\t\tMessage message = messageCreator.createMessage(session);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Sending created message: \" + message);\n\t\t\t}\n\t\t\tdoSend(producer, message);\n\t\t\t// Check commit - avoid commit call within a JTA transaction.\n\t\t\tif (session.getTransacted() && isSessionLocallyTransacted(session)) {\n\t\t\t\t// Transacted session created by this template -> commit.\n\t\t\t\tJmsUtils.commitIfNecessary(session);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t}\n\t}\n\n\t/**\n\t * Actually send the given JMS message.\n\t * @param producer the JMS MessageProducer to send with\n\t * @param message the JMS Message to send\n\t * @throws JMSException if thrown by JMS API methods\n\t */\n\tprotected void doSend(MessageProducer producer, Message message) throws JMSException {\n\t\tif (this.deliveryDelay >= 0) {\n\t\t\tproducer.setDeliveryDelay(this.deliveryDelay);\n\t\t}\n\t\tif (isExplicitQosEnabled()) {\n\t\t\tproducer.send(message, getDeliveryMode(), getPriority(), getTimeToLive());\n\t\t}\n\t\telse {\n\t\t\tproducer.send(message);\n\t\t}\n\t}\n\n\n\t//---------------------------------------------------------------------------------------\n\t// Convenience methods for sending auto-converted messages\n\t//---------------------------------------------------------------------------------------\n\n\t@Override\n\tpublic void convertAndSend(Object message) throws JmsException {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\tconvertAndSend(defaultDestination, message);\n\t\t}\n\t\telse {\n\t\t\tconvertAndSend(getRequiredDefaultDestinationName(), message);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void convertAndSend(Destination destination, final Object message) throws JmsException {\n\t\tsend(destination, session -> getRequiredMessageConverter().toMessage(message, session));\n\t}\n\n\t@Override\n\tpublic void convertAndSend(String destinationName, final Object message) throws JmsException {\n\t\tsend(destinationName, session -> getRequiredMessageConverter().toMessage(message, session));\n\t}\n\n\t@Override\n\tpublic void convertAndSend(Object message, MessagePostProcessor postProcessor) throws JmsException {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\tconvertAndSend(defaultDestination, message, postProcessor);\n\t\t}\n\t\telse {\n\t\t\tconvertAndSend(getRequiredDefaultDestinationName(), message, postProcessor);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void convertAndSend(\n\t\t\tDestination destination, final Object message, final MessagePostProcessor postProcessor)\n\t\t\tthrows JmsException {\n\n\t\tsend(destination, session -> {\n\t\t\tMessage msg = getRequiredMessageConverter().toMessage(message, session);\n\t\t\treturn postProcessor.postProcessMessage(msg);\n\t\t});\n\t}\n\n\t@Override\n\tpublic void convertAndSend(\n\t\t\tString destinationName, final Object message, final MessagePostProcessor postProcessor)\n\t\tthrows JmsException {\n\n\t\tsend(destinationName, session -> {\n\t\t\tMessage msg = getRequiredMessageConverter().toMessage(message, session);\n\t\t\treturn postProcessor.postProcessMessage(msg);\n\t\t});\n\t}\n\n\n\t//---------------------------------------------------------------------------------------\n\t// Convenience methods for receiving messages\n\t//---------------------------------------------------------------------------------------\n\n\t@Override\n\t@Nullable\n\tpublic Message receive() throws JmsException {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\treturn receive(defaultDestination);\n\t\t}\n\t\telse {\n\t\t\treturn receive(getRequiredDefaultDestinationName());\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Message receive(Destination destination) throws JmsException {\n\t\treturn receiveSelected(destination, null);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Message receive(String destinationName) throws JmsException {\n\t\treturn receiveSelected(destinationName, null);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Message receiveSelected(String messageSelector) throws JmsException {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\treturn receiveSelected(defaultDestination, messageSelector);\n\t\t}\n\t\telse {\n\t\t\treturn receiveSelected(getRequiredDefaultDestinationName(), messageSelector);\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Message receiveSelected(final Destination destination, @Nullable final String messageSelector) throws JmsException {\n\t\treturn execute(session -> doReceive(session, destination, messageSelector), true);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Message receiveSelected(final String destinationName, @Nullable final String messageSelector) throws JmsException {\n\t\treturn execute(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\treturn doReceive(session, destination, messageSelector);\n\t\t}, true);\n\t}\n\n\t/**\n\t * Receive a JMS message.\n\t * @param session the JMS Session to operate on\n\t * @param destination the JMS Destination to receive from\n\t * @param messageSelector the message selector for this consumer (can be {@code null})\n\t * @return the JMS Message received, or {@code null} if none\n\t * @throws JMSException if thrown by JMS API methods\n\t */\n\t@Nullable\n\tprotected Message doReceive(Session session, Destination destination, @Nullable String messageSelector)\n\t\t\tthrows JMSException {\n\n\t\treturn doReceive(session, createConsumer(session, destination, messageSelector));\n\t}\n\n\t/**\n\t * Actually receive a JMS message.\n\t * @param session the JMS Session to operate on\n\t * @param consumer the JMS MessageConsumer to receive with\n\t * @return the JMS Message received, or {@code null} if none\n\t * @throws JMSException if thrown by JMS API methods\n\t */\n\t@Nullable\n\tprotected Message doReceive(Session session, MessageConsumer consumer) throws JMSException {\n\t\ttry {\n\t\t\t// Use transaction timeout (if available).\n\t\t\tlong timeout = getReceiveTimeout();\n\t\t\tConnectionFactory connectionFactory = getConnectionFactory();\n\t\t\tJmsResourceHolder resourceHolder = null;\n\t\t\tif (connectionFactory != null) {\n\t\t\t\tresourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(connectionFactory);\n\t\t\t}\n\t\t\tif (resourceHolder != null && resourceHolder.hasTimeout()) {\n\t\t\t\ttimeout = Math.min(timeout, resourceHolder.getTimeToLiveInMillis());\n\t\t\t}\n\t\t\tMessage message = receiveFromConsumer(consumer, timeout);\n\t\t\tif (session.getTransacted()) {\n\t\t\t\t// Commit necessary - but avoid commit call within a JTA transaction.\n\t\t\t\tif (isSessionLocallyTransacted(session)) {\n\t\t\t\t\t// Transacted session created by this template -> commit.\n\t\t\t\t\tJmsUtils.commitIfNecessary(session);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (isClientAcknowledge(session)) {\n\t\t\t\t// Manually acknowledge message, if any.\n\t\t\t\tif (message != null) {\n\t\t\t\t\tmessage.acknowledge();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn message;\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageConsumer(consumer);\n\t\t}\n\t}\n\n\n\t//---------------------------------------------------------------------------------------\n\t// Convenience methods for receiving auto-converted messages\n\t//---------------------------------------------------------------------------------------\n\n\t@Override\n\t@Nullable\n\tpublic Object receiveAndConvert() throws JmsException {\n\t\treturn doConvertFromMessage(receive());\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object receiveAndConvert(Destination destination) throws JmsException {\n\t\treturn doConvertFromMessage(receive(destination));\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object receiveAndConvert(String destinationName) throws JmsException {\n\t\treturn doConvertFromMessage(receive(destinationName));\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object receiveSelectedAndConvert(String messageSelector) throws JmsException {\n\t\treturn doConvertFromMessage(receiveSelected(messageSelector));\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object receiveSelectedAndConvert(Destination destination, String messageSelector) throws JmsException {\n\t\treturn doConvertFromMessage(receiveSelected(destination, messageSelector));\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object receiveSelectedAndConvert(String destinationName, String messageSelector) throws JmsException {\n\t\treturn doConvertFromMessage(receiveSelected(destinationName, messageSelector));\n\t}\n\n\t/**\n\t * Extract the content from the given JMS message.\n\t * @param message the JMS Message to convert (can be {@code null})\n\t * @return the content of the message, or {@code null} if none\n\t */\n\t@Nullable\n\tprotected Object doConvertFromMessage(@Nullable Message message) {\n\t\tif (message != null) {\n\t\t\ttry {\n\t\t\t\treturn getRequiredMessageConverter().fromMessage(message);\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tthrow convertJmsAccessException(ex);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t//---------------------------------------------------------------------------------------\n\t// Convenience methods for sending messages to and receiving the reply from a destination\n\t//---------------------------------------------------------------------------------------\n\n\t@Override\n\t@Nullable\n\tpublic Message sendAndReceive(MessageCreator messageCreator) throws JmsException {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\treturn sendAndReceive(defaultDestination, messageCreator);\n\t\t}\n\t\telse {\n\t\t\treturn sendAndReceive(getRequiredDefaultDestinationName(), messageCreator);\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Message sendAndReceive(final Destination destination, final MessageCreator messageCreator) throws JmsException {\n\t\treturn executeLocal(session -> doSendAndReceive(session, destination, messageCreator), true);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Message sendAndReceive(final String destinationName, final MessageCreator messageCreator) throws JmsException {\n\t\treturn executeLocal(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\treturn doSendAndReceive(session, destination, messageCreator);\n\t\t}, true);\n\t}\n\n\t/**\n\t * Send a request message to the given {@link Destination} and block until\n\t * a reply has been received on a temporary queue created on-the-fly.\n\t * <p>Return the response message or {@code null} if no message has\n\t * @throws JMSException if thrown by JMS API methods\n\t */\n\t@Nullable\n\tprotected Message doSendAndReceive(Session session, Destination destination, MessageCreator messageCreator)\n\t\t\tthrows JMSException {\n\n\t\tAssert.notNull(messageCreator, \"MessageCreator must not be null\");\n\t\tTemporaryQueue responseQueue = null;\n\t\tMessageProducer producer = null;\n\t\tMessageConsumer consumer = null;\n\t\ttry {\n\t\t\tMessage requestMessage = messageCreator.createMessage(session);\n\t\t\tresponseQueue = session.createTemporaryQueue();\n\t\t\tproducer = session.createProducer(destination);\n\t\t\tconsumer = session.createConsumer(responseQueue);\n\t\t\trequestMessage.setJMSReplyTo(responseQueue);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Sending created message: \" + requestMessage);\n\t\t\t}\n\t\t\tdoSend(producer, requestMessage);\n\t\t\treturn receiveFromConsumer(consumer, getReceiveTimeout());\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageConsumer(consumer);\n\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t\tif (responseQueue != null) {\n\t\t\t\tresponseQueue.delete();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A variant of {@link #execute(SessionCallback, boolean)} that explicitly\n\t * creates a non-transactional {@link Session}. The given {@link SessionCallback}\n\t * does not participate in an existing transaction.\n\t */\n\t@Nullable\n\tprivate <T> T executeLocal(SessionCallback<T> action, boolean startConnection) throws JmsException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\tConnection con = null;\n\t\tSession session = null;\n\t\ttry {\n\t\t\tcon = createConnection();\n\t\t\tsession = con.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\t\t\tif (startConnection) {\n\t\t\t\tcon.start();\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Executing callback on JMS Session: \" + session);\n\t\t\t}\n\t\t\treturn action.doInJms(session);\n\t\t}\n\t\tcatch (JMSException ex) {\n\t\t\tthrow convertJmsAccessException(ex);\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeSession(session);\n\t\t\tConnectionFactoryUtils.releaseConnection(con, getConnectionFactory(), startConnection);\n\t\t}\n\t}\n\n\n\t//---------------------------------------------------------------------------------------\n\t// Convenience methods for browsing messages\n\t//---------------------------------------------------------------------------------------\n\n\t@Override\n\t@Nullable\n\tpublic <T> T browse(BrowserCallback<T> action) throws JmsException {\n\t\tQueue defaultQueue = getDefaultQueue();\n\t\tif (defaultQueue != null) {\n\t\t\treturn browse(defaultQueue, action);\n\t\t}\n\t\telse {\n\t\t\treturn browse(getRequiredDefaultDestinationName(), action);\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic <T> T browse(Queue queue, BrowserCallback<T> action) throws JmsException {\n\t\treturn browseSelected(queue, null, action);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic <T> T browse(String queueName, BrowserCallback<T> action) throws JmsException {\n\t\treturn browseSelected(queueName, null, action);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic <T> T browseSelected(String messageSelector, BrowserCallback<T> action) throws JmsException {\n\t\tQueue defaultQueue = getDefaultQueue();\n\t\tif (defaultQueue != null) {\n\t\t\treturn browseSelected(defaultQueue, messageSelector, action);\n\t\t}\n\t\telse {\n\t\t\treturn browseSelected(getRequiredDefaultDestinationName(), messageSelector, action);\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic <T> T browseSelected(final Queue queue, @Nullable final String messageSelector, final BrowserCallback<T> action)\n\t\t\tthrows JmsException {\n\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tQueueBrowser browser = createBrowser(session, queue, messageSelector);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, browser);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeQueueBrowser(browser);\n\t\t\t}\n\t\t}, true);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic <T> T browseSelected(final String queueName, @Nullable final String messageSelector, final BrowserCallback<T> action)\n\t\t\tthrows JmsException {\n\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tQueue queue = (Queue) getDestinationResolver().resolveDestinationName(session, queueName, false);\n\t\t\tQueueBrowser browser = createBrowser(session, queue, messageSelector);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, browser);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeQueueBrowser(browser);\n\t\t\t}\n\t\t}, true);\n\t}\n\n\n\t/**\n\t * Fetch an appropriate Connection from the given JmsResourceHolder.\n\t * <p>This implementation accepts any JMS 1.1 Connection.\n\t * @param holder the JmsResourceHolder\n\t * @return an appropriate Connection fetched from the holder,\n\t * or {@code null} if none found\n\t */\n\t@Nullable\n\tprotected Connection getConnection(JmsResourceHolder holder) {\n\t\treturn holder.getConnection();\n\t}\n\n\t/**\n\t * Fetch an appropriate Session from the given JmsResourceHolder.\n\t * <p>This implementation accepts any JMS 1.1 Session.\n\t * @param holder the JmsResourceHolder\n\t * @return an appropriate Session fetched from the holder,\n\t * or {@code null} if none found\n\t */\n\t@Nullable\n\tprotected Session getSession(JmsResourceHolder holder) {\n\t\treturn holder.getSession();\n\t}\n\n\t/**\n\t * Check whether the given Session is locally transacted, that is, whether\n\t * its transaction is managed by this listener container's Session handling\n\t * and not by an external transaction coordinator.\n\t * <p>Note: The Session's own transacted flag will already have been checked\n\t * before. This method is about finding out whether the Session's transaction\n\t * is local or externally coordinated.\n\t * @param session the Session to check\n\t * @return whether the given Session is locally transacted\n\t * @see #isSessionTransacted()\n\t * @see org.springframework.jms.connection.ConnectionFactoryUtils#isSessionTransactional\n\t */\n\tprotected boolean isSessionLocallyTransacted(Session session) {\n\t\treturn isSessionTransacted() &&\n\t\t\t\t!ConnectionFactoryUtils.isSessionTransactional(session, getConnectionFactory());\n\t}\n\n\t/**\n\t * Create a JMS MessageProducer for the given Session and Destination,\n\t * configuring it to disable message ids and/or timestamps (if necessary).\n\t * <p>Delegates to {@link #doCreateProducer} for creation of the raw\n\t * JMS MessageProducer.\n\t * @param session the JMS Session to create a MessageProducer for\n\t * @param destination the JMS Destination to create a MessageProducer for\n\t * @return the new JMS MessageProducer\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setMessageIdEnabled\n\t * @see #setMessageTimestampEnabled\n\t */\n\tprotected MessageProducer createProducer(Session session, @Nullable Destination destination) throws JMSException {\n\t\tMessageProducer producer = doCreateProducer(session, destination);\n\t\tif (!isMessageIdEnabled()) {\n\t\t\tproducer.setDisableMessageID(true);\n\t\t}\n\t\tif (!isMessageTimestampEnabled()) {\n\t\t\tproducer.setDisableMessageTimestamp(true);\n\t\t}\n\t\treturn producer;\n\t}\n\n\t/**\n\t * Create a raw JMS MessageProducer for the given Session and Destination.\n\t * <p>This implementation uses JMS 1.1 API.\n\t * @param session the JMS Session to create a MessageProducer for\n\t * @param destination the JMS Destination to create a MessageProducer for\n\t * @return the new JMS MessageProducer\n\t * @throws JMSException if thrown by JMS API methods\n\t */\n\tprotected MessageProducer doCreateProducer(Session session, @Nullable Destination destination) throws JMSException {\n\t\treturn session.createProducer(destination);\n\t}\n\n\t/**\n\t * Create a JMS MessageConsumer for the given Session and Destination.\n\t * <p>This implementation uses JMS 1.1 API.\n\t * @param session the JMS Session to create a MessageConsumer for\n\t * @param destination the JMS Destination to create a MessageConsumer for\n\t * @param messageSelector the message selector for this consumer (can be {@code null})\n\t * @return the new JMS MessageConsumer\n\t * @throws JMSException if thrown by JMS API methods\n\t */\n\tprotected MessageConsumer createConsumer(Session session, Destination destination, @Nullable String messageSelector)\n\t\t\tthrows JMSException {\n\n\t\t// Only pass in the NoLocal flag in case of a Topic:\n\t\t// Some JMS providers, such as WebSphere MQ 6.0, throw IllegalStateException\n\t\t// in case of the NoLocal flag being specified for a Queue.\n\t\tif (isPubSubDomain()) {\n\t\t\treturn session.createConsumer(destination, messageSelector, isPubSubNoLocal());\n\t\t}\n\t\telse {\n\t\t\treturn session.createConsumer(destination, messageSelector);\n\t\t}\n\t}\n\n\t/**\n\t * Create a JMS MessageProducer for the given Session and Destination,\n\t * configuring it to disable message ids and/or timestamps (if necessary).\n\t * <p>Delegates to {@link #doCreateProducer} for creation of the raw\n\t * JMS MessageProducer.\n\t * @param session the JMS Session to create a QueueBrowser for\n\t * @param queue the JMS Queue to create a QueueBrowser for\n\t * @param messageSelector the message selector for this consumer (can be {@code null})\n\t * @return the new JMS QueueBrowser\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setMessageIdEnabled\n\t * @see #setMessageTimestampEnabled\n\t */\n\tprotected QueueBrowser createBrowser(Session session, Queue queue, @Nullable String messageSelector)\n\t\t\tthrows JMSException {\n\n\t\treturn session.createBrowser(queue, messageSelector);\n\t}\n\n\n\t/**\n\t * ResourceFactory implementation that delegates to this template's protected callback methods.\n\t */\n\tprivate class JmsTemplateResourceFactory implements ConnectionFactoryUtils.ResourceFactory {\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Connection getConnection(JmsResourceHolder holder) {\n\t\t\treturn JmsTemplate.this.getConnection(holder);\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Session getSession(JmsResourceHolder holder) {\n\t\t\treturn JmsTemplate.this.getSession(holder);\n\t\t}\n\n\t\t@Override\n\t\tpublic Connection createConnection() throws JMSException {\n\t\t\treturn JmsTemplate.this.createConnection();\n\t\t}\n\n\t\t@Override\n\t\tpublic Session createSession(Connection con) throws JMSException {\n\t\t\treturn JmsTemplate.this.createSession(con);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isSynchedLocalTransactionAllowed() {\n\t\t\treturn JmsTemplate.this.isSessionTransacted();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jms.core.JmsTemplate#browse(action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "action"
    ],
    "position": {
      "column": 1,
      "line": 972
    },
    "return": "T",
    "signature": "public T browse(BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browse(BrowserCallback<T> action) throws JmsException {\n\t\tQueue defaultQueue = getDefaultQueue();\n\t\tif (defaultQueue != null) {\n\t\t\treturn browse(defaultQueue, action);\n\t\t}\n\t\telse {\n\t\t\treturn browse(getRequiredDefaultDestinationName(), action);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#browse(queue,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queue",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 984
    },
    "return": "T",
    "signature": "public T browse(Queue queue, BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browse(Queue queue, BrowserCallback<T> action) throws JmsException {\n\t\treturn browseSelected(queue, null, action);\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#browse(queueName,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queueName",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 990
    },
    "return": "T",
    "signature": "public T browse(String queueName, BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browse(String queueName, BrowserCallback<T> action) throws JmsException {\n\t\treturn browseSelected(queueName, null, action);\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#browseSelected(messageSelector,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSelector",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 996
    },
    "return": "T",
    "signature": "public T browseSelected(String messageSelector, BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browseSelected(String messageSelector, BrowserCallback<T> action) throws JmsException {\n\t\tQueue defaultQueue = getDefaultQueue();\n\t\tif (defaultQueue != null) {\n\t\t\treturn browseSelected(defaultQueue, messageSelector, action);\n\t\t}\n\t\telse {\n\t\t\treturn browseSelected(getRequiredDefaultDestinationName(), messageSelector, action);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#browseSelected(queue,messageSelector,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queue",
      "messageSelector",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1008
    },
    "return": "T",
    "signature": "public T browseSelected(final Queue queue, @Nullable final String messageSelector, final BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browseSelected(final Queue queue, @Nullable final String messageSelector, final BrowserCallback<T> action)"
  },
  "org.springframework.jms.core.JmsTemplate#browseSelected(queueName,messageSelector,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queueName",
      "messageSelector",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1025
    },
    "return": "T",
    "signature": "public T browseSelected(final String queueName, @Nullable final String messageSelector, final BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browseSelected(final String queueName, @Nullable final String messageSelector, final BrowserCallback<T> action)"
  },
  "org.springframework.jms.core.JmsTemplate#convertAndSend(destination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 655
    },
    "return": "void",
    "signature": "public void convertAndSend(Destination destination, final Object message)",
    "source_code": "\tpublic void convertAndSend(Destination destination, final Object message) throws JmsException {\n\t\tsend(destination, session -> getRequiredMessageConverter().toMessage(message, session));\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#convertAndSend(destination,message,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "message",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 676
    },
    "return": "void",
    "signature": "public void convertAndSend(Destination destination, final Object message, final MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend("
  },
  "org.springframework.jms.core.JmsTemplate#convertAndSend(destinationName,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 660
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, final Object message)",
    "source_code": "\tpublic void convertAndSend(String destinationName, final Object message) throws JmsException {\n\t\tsend(destinationName, session -> getRequiredMessageConverter().toMessage(message, session));\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#convertAndSend(destinationName,message,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "message",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 687
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, final Object message, final MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend("
  },
  "org.springframework.jms.core.JmsTemplate#convertAndSend(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 644
    },
    "return": "void",
    "signature": "public void convertAndSend(Object message)",
    "source_code": "\tpublic void convertAndSend(Object message) throws JmsException {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\tconvertAndSend(defaultDestination, message);\n\t\t}\n\t\telse {\n\t\t\tconvertAndSend(getRequiredDefaultDestinationName(), message);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#convertAndSend(message,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 665
    },
    "return": "void",
    "signature": "public void convertAndSend(Object message, MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(Object message, MessagePostProcessor postProcessor) throws JmsException {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\tconvertAndSend(defaultDestination, message, postProcessor);\n\t\t}\n\t\telse {\n\t\t\tconvertAndSend(getRequiredDefaultDestinationName(), message, postProcessor);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#createBrowser(session,queue,messageSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MessageProducer for the given Session and Destination,\n\t * configuring it to disable message ids and/or timestamps (if necessary).\n\t * <p>Delegates to {@link #doCreateProducer} for creation of the raw\n\t * JMS MessageProducer.\n\t * @param session the JMS Session to create a QueueBrowser for\n\t * @param queue the JMS Queue to create a QueueBrowser for\n\t * @param messageSelector the message selector for this consumer (can be {@code null})\n\t * @return the new JMS QueueBrowser\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setMessageIdEnabled\n\t * @see #setMessageTimestampEnabled\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "queue",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 1154
    },
    "return": "QueueBrowser",
    "signature": "protected QueueBrowser createBrowser(Session session, Queue queue, @Nullable String messageSelector)",
    "source_code": "\tprotected QueueBrowser createBrowser(Session session, Queue queue, @Nullable String messageSelector)"
  },
  "org.springframework.jms.core.JmsTemplate#createConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1179
    },
    "return": "Connection",
    "signature": "public Connection createConnection()",
    "source_code": "\t\tpublic Connection createConnection() throws JMSException {\n\t\t\treturn JmsTemplate.this.createConnection();\n\t\t}"
  },
  "org.springframework.jms.core.JmsTemplate#createConsumer(session,destination,messageSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MessageConsumer for the given Session and Destination.\n\t * <p>This implementation uses JMS 1.1 API.\n\t * @param session the JMS Session to create a MessageConsumer for\n\t * @param destination the JMS Destination to create a MessageConsumer for\n\t * @param messageSelector the message selector for this consumer (can be {@code null})\n\t * @return the new JMS MessageConsumer\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 1127
    },
    "return": "MessageConsumer",
    "signature": "protected MessageConsumer createConsumer(Session session, Destination destination, @Nullable String messageSelector)",
    "source_code": "\tprotected MessageConsumer createConsumer(Session session, Destination destination, @Nullable String messageSelector)"
  },
  "org.springframework.jms.core.JmsTemplate#createProducer(session,destination)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MessageProducer for the given Session and Destination,\n\t * configuring it to disable message ids and/or timestamps (if necessary).\n\t * <p>Delegates to {@link #doCreateProducer} for creation of the raw\n\t * JMS MessageProducer.\n\t * @param session the JMS Session to create a MessageProducer for\n\t * @param destination the JMS Destination to create a MessageProducer for\n\t * @return the new JMS MessageProducer\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setMessageIdEnabled\n\t * @see #setMessageTimestampEnabled\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 1095
    },
    "return": "MessageProducer",
    "signature": "protected MessageProducer createProducer(Session session, @Nullable Destination destination)",
    "source_code": "\tprotected MessageProducer createProducer(Session session, @Nullable Destination destination) throws JMSException {\n\t\tMessageProducer producer = doCreateProducer(session, destination);\n\t\tif (!isMessageIdEnabled()) {\n\t\t\tproducer.setDisableMessageID(true);\n\t\t}\n\t\tif (!isMessageTimestampEnabled()) {\n\t\t\tproducer.setDisableMessageTimestamp(true);\n\t\t}\n\t\treturn producer;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#createSession(con)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con"
    ],
    "position": {
      "column": 1,
      "line": 1184
    },
    "return": "Session",
    "signature": "public Session createSession(Connection con)",
    "source_code": "\t\tpublic Session createSession(Connection con) throws JMSException {\n\t\t\treturn JmsTemplate.this.createSession(con);\n\t\t}"
  },
  "org.springframework.jms.core.JmsTemplate#doConvertFromMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract the content from the given JMS message.\n\t * @param message the JMS Message to convert (can be {@code null})\n\t * @return the content of the message, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 856
    },
    "return": "Object",
    "signature": "protected Object doConvertFromMessage(@Nullable Message message)",
    "source_code": "\tprotected Object doConvertFromMessage(@Nullable Message message) {\n\t\tif (message != null) {\n\t\t\ttry {\n\t\t\t\treturn getRequiredMessageConverter().fromMessage(message);\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tthrow convertJmsAccessException(ex);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#doCreateProducer(session,destination)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a raw JMS MessageProducer for the given Session and Destination.\n\t * <p>This implementation uses JMS 1.1 API.\n\t * @param session the JMS Session to create a MessageProducer for\n\t * @param destination the JMS Destination to create a MessageProducer for\n\t * @return the new JMS MessageProducer\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 1114
    },
    "return": "MessageProducer",
    "signature": "protected MessageProducer doCreateProducer(Session session, @Nullable Destination destination)",
    "source_code": "\tprotected MessageProducer doCreateProducer(Session session, @Nullable Destination destination) throws JMSException {\n\t\treturn session.createProducer(destination);\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#doReceive(session,consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually receive a JMS message.\n\t * @param session the JMS Session to operate on\n\t * @param consumer the JMS MessageConsumer to receive with\n\t * @return the JMS Message received, or {@code null} if none\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 776
    },
    "return": "Message",
    "signature": "protected Message doReceive(Session session, MessageConsumer consumer)",
    "source_code": "\tprotected Message doReceive(Session session, MessageConsumer consumer) throws JMSException {\n\t\ttry {\n\t\t\t// Use transaction timeout (if available).\n\t\t\tlong timeout = getReceiveTimeout();\n\t\t\tConnectionFactory connectionFactory = getConnectionFactory();\n\t\t\tJmsResourceHolder resourceHolder = null;\n\t\t\tif (connectionFactory != null) {\n\t\t\t\tresourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(connectionFactory);\n\t\t\t}\n\t\t\tif (resourceHolder != null && resourceHolder.hasTimeout()) {\n\t\t\t\ttimeout = Math.min(timeout, resourceHolder.getTimeToLiveInMillis());\n\t\t\t}\n\t\t\tMessage message = receiveFromConsumer(consumer, timeout);\n\t\t\tif (session.getTransacted()) {\n\t\t\t\t// Commit necessary - but avoid commit call within a JTA transaction.\n\t\t\t\tif (isSessionLocallyTransacted(session)) {\n\t\t\t\t\t// Transacted session created by this template -> commit.\n\t\t\t\t\tJmsUtils.commitIfNecessary(session);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (isClientAcknowledge(session)) {\n\t\t\t\t// Manually acknowledge message, if any.\n\t\t\t\tif (message != null) {\n\t\t\t\t\tmessage.acknowledge();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn message;\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageConsumer(consumer);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#doReceive(session,destination,messageSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Receive a JMS message.\n\t * @param session the JMS Session to operate on\n\t * @param destination the JMS Destination to receive from\n\t * @param messageSelector the message selector for this consumer (can be {@code null})\n\t * @return the JMS Message received, or {@code null} if none\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 762
    },
    "return": "Message",
    "signature": "protected Message doReceive(Session session, Destination destination, @Nullable String messageSelector)",
    "source_code": "\tprotected Message doReceive(Session session, Destination destination, @Nullable String messageSelector)"
  },
  "org.springframework.jms.core.JmsTemplate#doSend(producer,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually send the given JMS message.\n\t * @param producer the JMS MessageProducer to send with\n\t * @param message the JMS Message to send\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "producer",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 626
    },
    "return": "void",
    "signature": "protected void doSend(MessageProducer producer, Message message)",
    "source_code": "\tprotected void doSend(MessageProducer producer, Message message) throws JMSException {\n\t\tif (this.deliveryDelay >= 0) {\n\t\t\tproducer.setDeliveryDelay(this.deliveryDelay);\n\t\t}\n\t\tif (isExplicitQosEnabled()) {\n\t\t\tproducer.send(message, getDeliveryMode(), getPriority(), getTimeToLive());\n\t\t}\n\t\telse {\n\t\t\tproducer.send(message);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#doSend(session,destination,messageCreator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Send the given JMS message.\n\t * @param session the JMS Session to operate on\n\t * @param destination the JMS Destination to send to\n\t * @param messageCreator callback to create a JMS Message\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 598
    },
    "return": "void",
    "signature": "protected void doSend(Session session, Destination destination, MessageCreator messageCreator)",
    "source_code": "\tprotected void doSend(Session session, Destination destination, MessageCreator messageCreator)"
  },
  "org.springframework.jms.core.JmsTemplate#doSendAndReceive(session,destination,messageCreator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Send a request message to the given {@link Destination} and block until\n\t * a reply has been received on a temporary queue created on-the-fly.\n\t * <p>Return the response message or {@code null} if no message has\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 907
    },
    "return": "Message",
    "signature": "protected Message doSendAndReceive(Session session, Destination destination, MessageCreator messageCreator)",
    "source_code": "\tprotected Message doSendAndReceive(Session session, Destination destination, MessageCreator messageCreator)"
  },
  "org.springframework.jms.core.JmsTemplate#execute(action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "action"
    ],
    "position": {
      "column": 1,
      "line": 517
    },
    "return": "T",
    "signature": "public T execute(ProducerCallback<T> action)",
    "source_code": "\tpublic <T> T execute(ProducerCallback<T> action) throws JmsException {\n\t\tString defaultDestinationName = getDefaultDestinationName();\n\t\tif (defaultDestinationName != null) {\n\t\t\treturn execute(defaultDestinationName, action);\n\t\t}\n\t\telse {\n\t\t\treturn execute(getDefaultDestination(), action);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#execute(action,startConnection)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the action specified by the given action object within a\n\t * JMS Session. Generalized version of {@code execute(SessionCallback)},\n\t * allowing the JMS Connection to be started on the fly.\n\t * <p>Use {@code execute(SessionCallback)} for the general case.\n\t * Starting the JMS Connection is just necessary for receiving messages,\n\t * which is preferably achieved through the {@code receive} methods.\n\t * @param action callback object that exposes the Session\n\t * @param startConnection whether to start the Connection\n\t * @return the result object from working with the Session\n\t * @throws JmsException if there is any problem\n\t * @see #execute(SessionCallback)\n\t * @see #receive\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "action",
      "startConnection"
    ],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "T",
    "signature": "public T execute(SessionCallback<T> action, boolean startConnection)",
    "source_code": "\tpublic <T> T execute(SessionCallback<T> action, boolean startConnection) throws JmsException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\tConnection conToClose = null;\n\t\tSession sessionToClose = null;\n\t\ttry {\n\t\t\tSession sessionToUse = ConnectionFactoryUtils.doGetTransactionalSession(\n\t\t\t\t\tobtainConnectionFactory(), this.transactionalResourceFactory, startConnection);\n\t\t\tif (sessionToUse == null) {\n\t\t\t\tconToClose = createConnection();\n\t\t\t\tsessionToClose = createSession(conToClose);\n\t\t\t\tif (startConnection) {\n\t\t\t\t\tconToClose.start();\n\t\t\t\t}\n\t\t\t\tsessionToUse = sessionToClose;\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Executing callback on JMS Session: \" + sessionToUse);\n\t\t\t}\n\t\t\treturn action.doInJms(sessionToUse);\n\t\t}\n\t\tcatch (JMSException ex) {\n\t\t\tthrow convertJmsAccessException(ex);\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeSession(sessionToClose);\n\t\t\tConnectionFactoryUtils.releaseConnection(conToClose, getConnectionFactory(), startConnection);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#execute(destination,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 529
    },
    "return": "T",
    "signature": "public T execute(final @Nullable Destination destination, final ProducerCallback<T> action)",
    "source_code": "\tpublic <T> T execute(final @Nullable Destination destination, final ProducerCallback<T> action) throws JmsException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tMessageProducer producer = createProducer(session, destination);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, producer);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t\t}\n\t\t}, false);\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#execute(destinationName,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "T",
    "signature": "public T execute(final String destinationName, final ProducerCallback<T> action)",
    "source_code": "\tpublic <T> T execute(final String destinationName, final ProducerCallback<T> action) throws JmsException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\tMessageProducer producer = createProducer(session, destination);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, producer);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t\t}\n\t\t}, false);\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#getConnection(holder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "holder"
    ],
    "position": {
      "column": 1,
      "line": 1168
    },
    "return": "Connection",
    "signature": "public Connection getConnection(JmsResourceHolder holder)",
    "source_code": "\t\tpublic Connection getConnection(JmsResourceHolder holder) {\n\t\t\treturn JmsTemplate.this.getConnection(holder);\n\t\t}"
  },
  "org.springframework.jms.core.JmsTemplate#getDefaultDestination()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the destination to be used on send/receive operations that do not\n\t * have a destination parameter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "Destination",
    "signature": "public Destination getDefaultDestination()",
    "source_code": "\tpublic Destination getDefaultDestination() {\n\t\treturn (this.defaultDestination instanceof Destination dest ? dest : null);\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#getDefaultDestinationName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the destination name to be used on send/receive operations that\n\t * do not have a destination parameter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "String",
    "signature": "public String getDefaultDestinationName()",
    "source_code": "\tpublic String getDefaultDestinationName() {\n\t\treturn (this.defaultDestination instanceof String name ? name : null);\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#getDeliveryDelay()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the delivery delay to use for send calls (in milliseconds).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 338
    },
    "return": "long",
    "signature": "public long getDeliveryDelay()",
    "source_code": "\tpublic long getDeliveryDelay() {\n\t\treturn this.deliveryDelay;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#getDeliveryMode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the delivery mode to use when sending a message.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "int",
    "signature": "public int getDeliveryMode()",
    "source_code": "\tpublic int getDeliveryMode() {\n\t\treturn this.deliveryMode;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#getMessageConverter()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the message converter for this template.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "MessageConverter",
    "signature": "public MessageConverter getMessageConverter()",
    "source_code": "\tpublic MessageConverter getMessageConverter() {\n\t\treturn this.messageConverter;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#getPriority()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the priority of a message when sending.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "int",
    "signature": "public int getPriority()",
    "source_code": "\tpublic int getPriority() {\n\t\treturn this.priority;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#getReceiveTimeout()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the timeout to use for receive calls (in milliseconds).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "long",
    "signature": "public long getReceiveTimeout()",
    "source_code": "\tpublic long getReceiveTimeout() {\n\t\treturn this.receiveTimeout;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#getSession(holder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "holder"
    ],
    "position": {
      "column": 1,
      "line": 1174
    },
    "return": "Session",
    "signature": "public Session getSession(JmsResourceHolder holder)",
    "source_code": "\t\tpublic Session getSession(JmsResourceHolder holder) {\n\t\t\treturn JmsTemplate.this.getSession(holder);\n\t\t}"
  },
  "org.springframework.jms.core.JmsTemplate#getTimeToLive()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the time-to-live of the message when sending.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 456
    },
    "return": "long",
    "signature": "public long getTimeToLive()",
    "source_code": "\tpublic long getTimeToLive() {\n\t\treturn this.timeToLive;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#initDefaultStrategies()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the default implementations for the template's strategies:\n\t * DynamicDestinationResolver and SimpleMessageConverter.\n\t * @see #setDestinationResolver\n\t * @see #setMessageConverter\n\t * @see org.springframework.jms.support.destination.DynamicDestinationResolver\n\t * @see org.springframework.jms.support.converter.SimpleMessageConverter\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "void",
    "signature": "protected void initDefaultStrategies()",
    "source_code": "\tprotected void initDefaultStrategies() {\n\t\tsetMessageConverter(new SimpleMessageConverter());\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#isExplicitQosEnabled()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * If \"true\", then the values of deliveryMode, priority, and timeToLive\n\t * will be used when sending a message. Otherwise, the default values,\n\t * that may be set administratively, will be used.\n\t * @return true if overriding default values of QOS parameters\n\t * (deliveryMode, priority, and timeToLive)\n\t * @see #setDeliveryMode\n\t * @see #setPriority\n\t * @see #setTimeToLive\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 364
    },
    "return": "boolean",
    "signature": "public boolean isExplicitQosEnabled()",
    "source_code": "\tpublic boolean isExplicitQosEnabled() {\n\t\treturn this.explicitQosEnabled;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#isMessageIdEnabled()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether message IDs are enabled.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "boolean",
    "signature": "public boolean isMessageIdEnabled()",
    "source_code": "\tpublic boolean isMessageIdEnabled() {\n\t\treturn this.messageIdEnabled;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#isMessageTimestampEnabled()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether message timestamps are enabled.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "boolean",
    "signature": "public boolean isMessageTimestampEnabled()",
    "source_code": "\tpublic boolean isMessageTimestampEnabled() {\n\t\treturn this.messageTimestampEnabled;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#isPubSubNoLocal()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to inhibit the delivery of messages published by its own connection.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "boolean",
    "signature": "public boolean isPubSubNoLocal()",
    "source_code": "\tpublic boolean isPubSubNoLocal() {\n\t\treturn this.pubSubNoLocal;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#isSessionLocallyTransacted(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given Session is locally transacted, that is, whether\n\t * its transaction is managed by this listener container's Session handling\n\t * and not by an external transaction coordinator.\n\t * <p>Note: The Session's own transacted flag will already have been checked\n\t * before. This method is about finding out whether the Session's transaction\n\t * is local or externally coordinated.\n\t * @param session the Session to check\n\t * @return whether the given Session is locally transacted\n\t * @see #isSessionTransacted()\n\t * @see org.springframework.jms.connection.ConnectionFactoryUtils#isSessionTransactional\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 1078
    },
    "return": "boolean",
    "signature": "protected boolean isSessionLocallyTransacted(Session session)",
    "source_code": "\tprotected boolean isSessionLocallyTransacted(Session session) {\n\t\treturn isSessionTransacted() &&\n\t\t\t\t!ConnectionFactoryUtils.isSessionTransactional(session, getConnectionFactory());\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#isSynchedLocalTransactionAllowed()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1189
    },
    "return": "boolean",
    "signature": "public boolean isSynchedLocalTransactionAllowed()",
    "source_code": "\t\tpublic boolean isSynchedLocalTransactionAllowed() {\n\t\t\treturn JmsTemplate.this.isSessionTransacted();\n\t\t}"
  },
  "org.springframework.jms.core.JmsTemplate#receive()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 704
    },
    "return": "Message",
    "signature": "public Message receive()",
    "source_code": "\tpublic Message receive() throws JmsException {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\treturn receive(defaultDestination);\n\t\t}\n\t\telse {\n\t\t\treturn receive(getRequiredDefaultDestinationName());\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#receive(destination)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 716
    },
    "return": "Message",
    "signature": "public Message receive(Destination destination)",
    "source_code": "\tpublic Message receive(Destination destination) throws JmsException {\n\t\treturn receiveSelected(destination, null);\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#receive(destinationName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName"
    ],
    "position": {
      "column": 1,
      "line": 722
    },
    "return": "Message",
    "signature": "public Message receive(String destinationName)",
    "source_code": "\tpublic Message receive(String destinationName) throws JmsException {\n\t\treturn receiveSelected(destinationName, null);\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#receiveAndConvert()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 816
    },
    "return": "Object",
    "signature": "public Object receiveAndConvert()",
    "source_code": "\tpublic Object receiveAndConvert() throws JmsException {\n\t\treturn doConvertFromMessage(receive());\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#receiveAndConvert(destination)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 822
    },
    "return": "Object",
    "signature": "public Object receiveAndConvert(Destination destination)",
    "source_code": "\tpublic Object receiveAndConvert(Destination destination) throws JmsException {\n\t\treturn doConvertFromMessage(receive(destination));\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#receiveAndConvert(destinationName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName"
    ],
    "position": {
      "column": 1,
      "line": 828
    },
    "return": "Object",
    "signature": "public Object receiveAndConvert(String destinationName)",
    "source_code": "\tpublic Object receiveAndConvert(String destinationName) throws JmsException {\n\t\treturn doConvertFromMessage(receive(destinationName));\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#receiveSelected(destination,messageSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 740
    },
    "return": "Message",
    "signature": "public Message receiveSelected(final Destination destination, @Nullable final String messageSelector)",
    "source_code": "\tpublic Message receiveSelected(final Destination destination, @Nullable final String messageSelector) throws JmsException {\n\t\treturn execute(session -> doReceive(session, destination, messageSelector), true);\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#receiveSelected(destinationName,messageSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 746
    },
    "return": "Message",
    "signature": "public Message receiveSelected(final String destinationName, @Nullable final String messageSelector)",
    "source_code": "\tpublic Message receiveSelected(final String destinationName, @Nullable final String messageSelector) throws JmsException {\n\t\treturn execute(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\treturn doReceive(session, destination, messageSelector);\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#receiveSelected(messageSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 728
    },
    "return": "Message",
    "signature": "public Message receiveSelected(String messageSelector)",
    "source_code": "\tpublic Message receiveSelected(String messageSelector) throws JmsException {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\treturn receiveSelected(defaultDestination, messageSelector);\n\t\t}\n\t\telse {\n\t\t\treturn receiveSelected(getRequiredDefaultDestinationName(), messageSelector);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#receiveSelectedAndConvert(destination,messageSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 840
    },
    "return": "Object",
    "signature": "public Object receiveSelectedAndConvert(Destination destination, String messageSelector)",
    "source_code": "\tpublic Object receiveSelectedAndConvert(Destination destination, String messageSelector) throws JmsException {\n\t\treturn doConvertFromMessage(receiveSelected(destination, messageSelector));\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#receiveSelectedAndConvert(destinationName,messageSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 846
    },
    "return": "Object",
    "signature": "public Object receiveSelectedAndConvert(String destinationName, String messageSelector)",
    "source_code": "\tpublic Object receiveSelectedAndConvert(String destinationName, String messageSelector) throws JmsException {\n\t\treturn doConvertFromMessage(receiveSelected(destinationName, messageSelector));\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#receiveSelectedAndConvert(messageSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 834
    },
    "return": "Object",
    "signature": "public Object receiveSelectedAndConvert(String messageSelector)",
    "source_code": "\tpublic Object receiveSelectedAndConvert(String messageSelector) throws JmsException {\n\t\treturn doConvertFromMessage(receiveSelected(messageSelector));\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#send(destination,messageCreator)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 575
    },
    "return": "void",
    "signature": "public void send(final Destination destination, final MessageCreator messageCreator)",
    "source_code": "\tpublic void send(final Destination destination, final MessageCreator messageCreator) throws JmsException {\n\t\texecute(session -> {\n\t\t\tdoSend(session, destination, messageCreator);\n\t\t\treturn null;\n\t\t}, false);\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#send(destinationName,messageCreator)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 583
    },
    "return": "void",
    "signature": "public void send(final String destinationName, final MessageCreator messageCreator)",
    "source_code": "\tpublic void send(final String destinationName, final MessageCreator messageCreator) throws JmsException {\n\t\texecute(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\tdoSend(session, destination, messageCreator);\n\t\t\treturn null;\n\t\t}, false);\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#send(messageCreator)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 564
    },
    "return": "void",
    "signature": "public void send(MessageCreator messageCreator)",
    "source_code": "\tpublic void send(MessageCreator messageCreator) throws JmsException {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\tsend(defaultDestination, messageCreator);\n\t\t}\n\t\telse {\n\t\t\tsend(getRequiredDefaultDestinationName(), messageCreator);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#sendAndReceive(destination,messageCreator)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 887
    },
    "return": "Message",
    "signature": "public Message sendAndReceive(final Destination destination, final MessageCreator messageCreator)",
    "source_code": "\tpublic Message sendAndReceive(final Destination destination, final MessageCreator messageCreator) throws JmsException {\n\t\treturn executeLocal(session -> doSendAndReceive(session, destination, messageCreator), true);\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#sendAndReceive(destinationName,messageCreator)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 893
    },
    "return": "Message",
    "signature": "public Message sendAndReceive(final String destinationName, final MessageCreator messageCreator)",
    "source_code": "\tpublic Message sendAndReceive(final String destinationName, final MessageCreator messageCreator) throws JmsException {\n\t\treturn executeLocal(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\treturn doSendAndReceive(session, destination, messageCreator);\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#sendAndReceive(messageCreator)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 875
    },
    "return": "Message",
    "signature": "public Message sendAndReceive(MessageCreator messageCreator)",
    "source_code": "\tpublic Message sendAndReceive(MessageCreator messageCreator) throws JmsException {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\treturn sendAndReceive(defaultDestination, messageCreator);\n\t\t}\n\t\telse {\n\t\t\treturn sendAndReceive(getRequiredDefaultDestinationName(), messageCreator);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#setDefaultDestination(destination)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the destination to be used on send/receive operations that do not\n\t * have a destination parameter.\n\t * <p>Alternatively, specify a \"defaultDestinationName\", to be\n\t * dynamically resolved via the DestinationResolver.\n\t * @see #send(MessageCreator)\n\t * @see #convertAndSend(Object)\n\t * @see #convertAndSend(Object, MessagePostProcessor)\n\t * @see #setDefaultDestinationName(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "void",
    "signature": "public void setDefaultDestination(@Nullable Destination destination)",
    "source_code": "\tpublic void setDefaultDestination(@Nullable Destination destination) {\n\t\tthis.defaultDestination = destination;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#setDefaultDestinationName(destinationName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the destination name to be used on send/receive operations that\n\t * do not have a destination parameter. The specified name will be\n\t * dynamically resolved via the DestinationResolver.\n\t * <p>Alternatively, specify a JMS Destination object as \"defaultDestination\".\n\t * @see #send(MessageCreator)\n\t * @see #convertAndSend(Object)\n\t * @see #convertAndSend(Object, MessagePostProcessor)\n\t * @see #setDestinationResolver\n\t * @see #setDefaultDestination(jakarta.jms.Destination)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "void",
    "signature": "public void setDefaultDestinationName(@Nullable String destinationName)",
    "source_code": "\tpublic void setDefaultDestinationName(@Nullable String destinationName) {\n\t\tthis.defaultDestination = destinationName;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#setDeliveryDelay(deliveryDelay)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the delivery delay to use for send calls (in milliseconds).\n\t * <p>The default is -1 (no delivery delay passed on to the broker).\n\t * Note that this feature requires JMS 2.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "deliveryDelay"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "void",
    "signature": "public void setDeliveryDelay(long deliveryDelay)",
    "source_code": "\tpublic void setDeliveryDelay(long deliveryDelay) {\n\t\tthis.deliveryDelay = deliveryDelay;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#setDeliveryMode(deliveryMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the delivery mode to use when sending a message.\n\t * Default is the JMS Message default: \"PERSISTENT\".\n\t * <p>Since a default value may be defined administratively,\n\t * this is only used when \"isExplicitQosEnabled\" equals \"true\".\n\t * @param deliveryMode the delivery mode to use\n\t * @see #isExplicitQosEnabled\n\t * @see jakarta.jms.DeliveryMode#PERSISTENT\n\t * @see jakarta.jms.DeliveryMode#NON_PERSISTENT\n\t * @see jakarta.jms.Message#DEFAULT_DELIVERY_MODE\n\t * @see jakarta.jms.MessageProducer#send(jakarta.jms.Message, int, int, long)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "deliveryMode"
    ],
    "position": {
      "column": 1,
      "line": 410
    },
    "return": "void",
    "signature": "public void setDeliveryMode(int deliveryMode)",
    "source_code": "\tpublic void setDeliveryMode(int deliveryMode) {\n\t\tthis.deliveryMode = deliveryMode;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#setDeliveryPersistent(deliveryPersistent)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether message delivery should be persistent or non-persistent,\n\t * specified as boolean value (\"true\" or \"false\"). This will set the delivery\n\t * mode accordingly, to either \"PERSISTENT\" (2) or \"NON_PERSISTENT\" (1).\n\t * <p>Default is \"true\" a.k.a. delivery mode \"PERSISTENT\".\n\t * @see #setDeliveryMode(int)\n\t * @see jakarta.jms.DeliveryMode#PERSISTENT\n\t * @see jakarta.jms.DeliveryMode#NON_PERSISTENT\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "deliveryPersistent"
    ],
    "position": {
      "column": 1,
      "line": 394
    },
    "return": "void",
    "signature": "public void setDeliveryPersistent(boolean deliveryPersistent)",
    "source_code": "\tpublic void setDeliveryPersistent(boolean deliveryPersistent) {\n\t\tthis.deliveryMode = (deliveryPersistent ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT);\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#setExplicitQosEnabled(explicitQosEnabled)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set if the QOS values (deliveryMode, priority, timeToLive)\n\t * should be used for sending a message.\n\t * @see #setDeliveryMode\n\t * @see #setPriority\n\t * @see #setTimeToLive\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "explicitQosEnabled"
    ],
    "position": {
      "column": 1,
      "line": 350
    },
    "return": "void",
    "signature": "public void setExplicitQosEnabled(boolean explicitQosEnabled)",
    "source_code": "\tpublic void setExplicitQosEnabled(boolean explicitQosEnabled) {\n\t\tthis.explicitQosEnabled = explicitQosEnabled;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#setMessageConverter(messageConverter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the message converter for this template. Used to resolve\n\t * Object parameters to convertAndSend methods and Object results\n\t * from receiveAndConvert methods.\n\t * <p>The default converter is a SimpleMessageConverter, which is able\n\t * to handle BytesMessages, TextMessages and ObjectMessages.\n\t * @see #convertAndSend\n\t * @see #receiveAndConvert\n\t * @see org.springframework.jms.support.converter.SimpleMessageConverter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageConverter"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "void",
    "signature": "public void setMessageConverter(@Nullable MessageConverter messageConverter)",
    "source_code": "\tpublic void setMessageConverter(@Nullable MessageConverter messageConverter) {\n\t\tthis.messageConverter = messageConverter;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#setMessageIdEnabled(messageIdEnabled)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether message IDs are enabled. Default is \"true\".\n\t * <p>This is only a hint to the JMS producer.\n\t * See the JMS javadocs for details.\n\t * @see jakarta.jms.MessageProducer#setDisableMessageID\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageIdEnabled"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "void",
    "signature": "public void setMessageIdEnabled(boolean messageIdEnabled)",
    "source_code": "\tpublic void setMessageIdEnabled(boolean messageIdEnabled) {\n\t\tthis.messageIdEnabled = messageIdEnabled;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#setMessageTimestampEnabled(messageTimestampEnabled)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether message timestamps are enabled. Default is \"true\".\n\t * <p>This is only a hint to the JMS producer.\n\t * See the JMS javadocs for details.\n\t * @see jakarta.jms.MessageProducer#setDisableMessageTimestamp\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageTimestampEnabled"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "void",
    "signature": "public void setMessageTimestampEnabled(boolean messageTimestampEnabled)",
    "source_code": "\tpublic void setMessageTimestampEnabled(boolean messageTimestampEnabled) {\n\t\tthis.messageTimestampEnabled = messageTimestampEnabled;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#setPriority(priority)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the priority of a message when sending.\n\t * <p>Since a default value may be defined administratively,\n\t * this is only used when \"isExplicitQosEnabled\" equals \"true\".\n\t * @see #isExplicitQosEnabled\n\t * @see jakarta.jms.Message#DEFAULT_PRIORITY\n\t * @see jakarta.jms.MessageProducer#send(jakarta.jms.Message, int, int, long)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "priority"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "void",
    "signature": "public void setPriority(int priority)",
    "source_code": "\tpublic void setPriority(int priority) {\n\t\tthis.priority = priority;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#setPubSubNoLocal(pubSubNoLocal)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to inhibit the delivery of messages published by its own connection.\n\t * Default is \"false\".\n\t * @see jakarta.jms.Session#createConsumer(jakarta.jms.Destination, String, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pubSubNoLocal"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "void",
    "signature": "public void setPubSubNoLocal(boolean pubSubNoLocal)",
    "source_code": "\tpublic void setPubSubNoLocal(boolean pubSubNoLocal) {\n\t\tthis.pubSubNoLocal = pubSubNoLocal;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#setQosSettings(settings)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link QosSettings} to use when sending a message.\n\t * @param settings the deliveryMode, priority, and timeToLive settings to use\n\t * @since 5.0\n\t * @see #setExplicitQosEnabled(boolean)\n\t * @see #setDeliveryMode(int)\n\t * @see #setPriority(int)\n\t * @see #setTimeToLive(long)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "settings"
    ],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "void",
    "signature": "public void setQosSettings(QosSettings settings)",
    "source_code": "\tpublic void setQosSettings(QosSettings settings) {\n\t\tAssert.notNull(settings, \"Settings must not be null\");\n\t\tsetExplicitQosEnabled(true);\n\t\tsetDeliveryMode(settings.getDeliveryMode());\n\t\tsetPriority(settings.getPriority());\n\t\tsetTimeToLive(settings.getTimeToLive());\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#setReceiveTimeout(receiveTimeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the timeout to use for receive calls (in milliseconds).\n\t * <p>The default is {@link #RECEIVE_TIMEOUT_INDEFINITE_WAIT}, which indicates\n\t * a blocking receive without timeout.\n\t * <p>Specify {@link #RECEIVE_TIMEOUT_NO_WAIT} (or any other negative value)\n\t * to indicate that a receive operation should check if a message is\n\t * immediately available without blocking.\n\t * @see #receiveFromConsumer(MessageConsumer, long)\n\t * @see jakarta.jms.MessageConsumer#receive(long)\n\t * @see jakarta.jms.MessageConsumer#receiveNoWait()\n\t * @see jakarta.jms.MessageConsumer#receive()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "receiveTimeout"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "void",
    "signature": "public void setReceiveTimeout(long receiveTimeout)",
    "source_code": "\tpublic void setReceiveTimeout(long receiveTimeout) {\n\t\tthis.receiveTimeout = receiveTimeout;\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#setTimeToLive(timeToLive)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the time-to-live of the message when sending.\n\t * <p>Since a default value may be defined administratively,\n\t * this is only used when \"isExplicitQosEnabled\" equals \"true\".\n\t * @param timeToLive the message's lifetime (in milliseconds)\n\t * @see #isExplicitQosEnabled\n\t * @see jakarta.jms.Message#DEFAULT_TIME_TO_LIVE\n\t * @see jakarta.jms.MessageProducer#send(jakarta.jms.Message, int, int, long)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeToLive"
    ],
    "position": {
      "column": 1,
      "line": 449
    },
    "return": "void",
    "signature": "public void setTimeToLive(long timeToLive)",
    "source_code": "\tpublic void setTimeToLive(long timeToLive) {\n\t\tthis.timeToLive = timeToLive;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for Spring message listener container implementations.\n * Can either host a standard JMS {@link jakarta.jms.MessageListener} or Spring's\n * {@link SessionAwareMessageListener} for actual message processing.\n *\n * <p>Usually holds a single JMS {@link Connection} that all listeners are supposed\n * to be registered on, which is the standard JMS way of managing listener sessions.\n * Can alternatively also be used with a fresh Connection per listener, for Jakarta EE\n * style XA-aware JMS messaging. The actual registration process is up to concrete\n * subclasses.\n *\n * <p><b>NOTE:</b> The default behavior of this message listener container is to\n * <b>never</b> propagate an exception thrown by a message listener up to the JMS\n * provider. Instead, it will log any such exception at the error level.\n * This means that from the perspective of the attendant JMS provider no such\n * listener will ever fail. However, if error handling is necessary, then\n * any implementation of the {@link ErrorHandler} strategy may be provided to\n * the {@link #setErrorHandler(ErrorHandler)} method. Note that JMSExceptions\n * <b>will</b> be passed to the ErrorHandler in addition to (but after) being\n * passed to an {@link ExceptionListener}, if one has been provided.\n *\n * <p>The listener container offers the following message acknowledgment options:\n * <ul>\n * <li>\"sessionAcknowledgeMode\" set to \"AUTO_ACKNOWLEDGE\" (default):\n * This mode is container-dependent: For {@link DefaultMessageListenerContainer},\n * it means automatic message acknowledgment <i>before</i> listener execution, with\n * no redelivery in case of an exception and no redelivery in case of other listener\n * execution interruptions either. For {@link SimpleMessageListenerContainer},\n * it means automatic message acknowledgment <i>after</i> listener execution, with\n * no redelivery in case of a user exception thrown but potential redelivery in case\n * of the JVM dying during listener execution. In order to consistently arrange for\n * redelivery with any container variant, consider \"CLIENT_ACKNOWLEDGE\" mode or -\n * preferably - setting \"sessionTransacted\" to \"true\" instead.\n * <li>\"sessionAcknowledgeMode\" set to \"DUPS_OK_ACKNOWLEDGE\":\n * <i>Lazy</i> message acknowledgment during ({@link DefaultMessageListenerContainer})\n * or shortly after ({@link SimpleMessageListenerContainer}) listener execution;\n * no redelivery in case of a user exception thrown but potential redelivery in case\n * of the JVM dying during listener execution. In order to consistently arrange for\n * redelivery with any container variant, consider \"CLIENT_ACKNOWLEDGE\" mode or -\n * preferably - setting \"sessionTransacted\" to \"true\" instead.\n * <li>\"sessionAcknowledgeMode\" set to \"CLIENT_ACKNOWLEDGE\":\n * Automatic message acknowledgment <i>after</i> successful listener execution;\n * best-effort redelivery in case of a user exception thrown as well as in case\n * of other listener execution interruptions (such as the JVM dying).\n * <li>\"sessionTransacted\" set to \"true\":\n * Transactional acknowledgment after successful listener execution;\n * <i>guaranteed redelivery</i> in case of a user exception thrown as well as\n * in case of other listener execution interruptions (such as the JVM dying).\n * </ul>\n *\n * <p>There are two solutions to the duplicate message processing problem:\n * <ul>\n * <li>Either add <i>duplicate message detection</i> to your listener, in the\n * form of a business entity existence check or a protocol table check. This\n * usually just needs to be done in case of the JMSRedelivered flag being\n * set on the incoming message (otherwise just process straightforwardly).\n * Note that with \"sessionTransacted\" set to \"true\", duplicate messages will\n * only appear in case of the JVM dying at the most unfortunate point possible\n * (i.e. after your business logic executed but before the JMS part got committed),\n * so duplicate message detection is just there to cover a corner case.\n * <li>Or wrap your <i>entire processing with an XA transaction</i>, covering the\n * reception of the JMS message as well as the execution of the business logic in\n * your message listener (including database operations etc). This is only\n * supported by {@link DefaultMessageListenerContainer}, through specifying\n * an external \"transactionManager\" (typically a\n * {@link org.springframework.transaction.jta.JtaTransactionManager}, with\n * a corresponding XA-aware JMS {@link jakarta.jms.ConnectionFactory} passed in\n * as \"connectionFactory\").\n * </ul>\n * Note that XA transaction coordination adds significant runtime overhead,\n * so it might be feasible to avoid it unless absolutely necessary.\n *\n * <p><b>Recommendations:</b>\n * <ul>\n * <li>The general recommendation is to set \"sessionTransacted\" to \"true\",\n * typically in combination with local database transactions triggered by the\n * listener implementation, through Spring's standard transaction facilities.\n * This will work nicely in Tomcat or in a standalone environment, often\n * combined with custom duplicate message detection (if it is unacceptable\n * to ever process the same message twice).\n * <li>Alternatively, specify a\n * {@link org.springframework.transaction.jta.JtaTransactionManager} as\n * \"transactionManager\" for a fully XA-aware JMS provider - typically when\n * running on a Jakarta EE server, but also for other environments with a JTA\n * transaction manager present. This will give full \"exactly-once\" guarantees\n * without custom duplicate message checks, at the price of additional\n * runtime processing overhead.\n * </ul>\n *\n * <p>Note that the \"sessionTransacted\" flag is strongly recommended over\n * {@link org.springframework.jms.connection.JmsTransactionManager}, provided\n * that transactions do not need to be managed externally. As a consequence,\n * set the transaction manager only if you are using JTA or if you need to\n * synchronize with custom external transaction arrangements.\n *\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @since 2.0\n * @see #setMessageListener\n * @see jakarta.jms.MessageListener\n * @see SessionAwareMessageListener\n * @see #handleListenerException\n * @see DefaultMessageListenerContainer\n * @see SimpleMessageListenerContainer\n * @see org.springframework.jms.listener.endpoint.JmsMessageEndpointManager\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "signature": "public class AbstractMessageListenerContainer",
    "source_code": "public abstract class AbstractMessageListenerContainer extends AbstractJmsListeningContainer"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#checkMessageListener(messageListener)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check the given message listener, throwing an exception\n\t * if it does not correspond to a supported listener type.\n\t * <p>By default, only a standard JMS {@link MessageListener} object or a\n\t * Spring {@link SessionAwareMessageListener} object will be accepted.\n\t * @param messageListener the message listener object to check\n\t * @throws IllegalArgumentException if the supplied listener is not a\n\t * {@link MessageListener} or a {@link SessionAwareMessageListener}\n\t * @see jakarta.jms.MessageListener\n\t * @see SessionAwareMessageListener\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "messageListener"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "void",
    "signature": "protected void checkMessageListener(@Nullable Object messageListener)",
    "source_code": "\tprotected void checkMessageListener(@Nullable Object messageListener) {\n\t\tif (messageListener != null && !(messageListener instanceof MessageListener ||\n\t\t\t\tmessageListener instanceof SessionAwareMessageListener)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Message listener needs to be of type [\" + MessageListener.class.getName() +\n\t\t\t\t\t\"] or [\" + SessionAwareMessageListener.class.getName() + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#commitIfNecessary(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a commit or message acknowledgement, as appropriate.\n\t * @param session the JMS Session to commit\n\t * @param message the Message to acknowledge\n\t * @throws jakarta.jms.JMSException in case of commit failure\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 770
    },
    "return": "void",
    "signature": "protected void commitIfNecessary(Session session, @Nullable Message message)",
    "source_code": "\tprotected void commitIfNecessary(Session session, @Nullable Message message) throws JMSException {\n\t\t// Commit session or acknowledge message.\n\t\tif (session.getTransacted()) {\n\t\t\t// Commit necessary - but avoid commit call within a JTA transaction.\n\t\t\tif (isSessionLocallyTransacted(session)) {\n\t\t\t\t// Transacted session created by this container -> commit.\n\t\t\t\tJmsUtils.commitIfNecessary(session);\n\t\t\t}\n\t\t}\n\t\telse if (message != null && isClientAcknowledge(session)) {\n\t\t\tmessage.acknowledge();\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#createConsumer(session,destination)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MessageConsumer for the given Session and Destination.\n\t * <p>This implementation uses JMS 1.1 API.\n\t * @param session the JMS Session to create a MessageConsumer for\n\t * @param destination the JMS Destination to create a MessageConsumer for\n\t * @return the new JMS MessageConsumer\n\t * @throws jakarta.jms.JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 855
    },
    "return": "MessageConsumer",
    "signature": "protected MessageConsumer createConsumer(Session session, Destination destination)",
    "source_code": "\tprotected MessageConsumer createConsumer(Session session, Destination destination) throws JMSException {\n\t\tif (isPubSubDomain() && destination instanceof Topic topic) {\n\t\t\tif (isSubscriptionShared()) {\n\t\t\t\treturn (isSubscriptionDurable() ?\n\t\t\t\t\t\tsession.createSharedDurableConsumer(topic, getSubscriptionName(), getMessageSelector()) :\n\t\t\t\t\t\tsession.createSharedConsumer(topic, getSubscriptionName(), getMessageSelector()));\n\t\t\t}\n\t\t\telse if (isSubscriptionDurable()) {\n\t\t\t\treturn session.createDurableSubscriber(\n\t\t\t\t\t\ttopic, getSubscriptionName(), getMessageSelector(), isPubSubNoLocal());\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Only pass in the NoLocal flag in case of a Topic (pub-sub mode):\n\t\t\t\t// Some JMS providers, such as WebSphere MQ 6.0, throw IllegalStateException\n\t\t\t\t// in case of the NoLocal flag being specified for a Queue.\n\t\t\t\treturn session.createConsumer(destination, getMessageSelector(), isPubSubNoLocal());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn session.createConsumer(destination, getMessageSelector());\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#doExecuteListener(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the specified listener,\n\t * committing or rolling back the transaction afterwards (if necessary).\n\t * @param session the JMS Session to operate on\n\t * @param message the received JMS Message\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #invokeListener\n\t * @see #commitIfNecessary\n\t * @see #rollbackOnExceptionIfNecessary\n\t * @see #convertJmsAccessException\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 663
    },
    "return": "void",
    "signature": "protected void doExecuteListener(Session session, Message message)",
    "source_code": "\tprotected void doExecuteListener(Session session, Message message) throws JMSException {\n\t\tif (!isAcceptMessagesWhileStopping() && !isRunning()) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Rejecting received message because of the listener container \" +\n\t\t\t\t\t\t\"having been stopped in the meantime: \" + message);\n\t\t\t}\n\t\t\trollbackIfNecessary(session);\n\t\t\tthrow new MessageRejectedWhileStoppingException();\n\t\t}\n\n\t\ttry {\n\t\t\tinvokeListener(session, message);\n\t\t}\n\t\tcatch (JMSException | RuntimeException | Error ex) {\n\t\t\trollbackOnExceptionIfNecessary(session, ex);\n\t\t\tthrow ex;\n\t\t}\n\t\tcommitIfNecessary(session, message);\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#doInvokeListener(listener,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified listener as standard JMS MessageListener.\n\t * <p>Default implementation performs a plain invocation of the\n\t * {@code onMessage} method.\n\t * @param listener the JMS MessageListener to invoke\n\t * @param message the received JMS Message\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see jakarta.jms.MessageListener#onMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "listener",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 760
    },
    "return": "void",
    "signature": "protected void doInvokeListener(MessageListener listener, Message message)",
    "source_code": "\tprotected void doInvokeListener(MessageListener listener, Message message) throws JMSException {\n\t\tlistener.onMessage(message);\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#doInvokeListener(listener,session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified listener as Spring SessionAwareMessageListener,\n\t * exposing a new JMS Session (potentially with its own transaction)\n\t * to the listener if demanded.\n\t * @param listener the Spring SessionAwareMessageListener to invoke\n\t * @param session the JMS Session to operate on\n\t * @param message the received JMS Message\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see SessionAwareMessageListener\n\t * @see #setExposeListenerSession\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "listener",
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 722
    },
    "return": "void",
    "signature": "protected void doInvokeListener(SessionAwareMessageListener listener, Session session, Message message)",
    "source_code": "\tprotected void doInvokeListener(SessionAwareMessageListener listener, Session session, Message message)"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#executeListener(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the specified listener,\n\t * committing or rolling back the transaction afterwards (if necessary).\n\t * @param session the JMS Session to operate on\n\t * @param message the received JMS Message\n\t * @see #invokeListener\n\t * @see #commitIfNecessary\n\t * @see #rollbackOnExceptionIfNecessary\n\t * @see #handleListenerException\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 643
    },
    "return": "void",
    "signature": "protected void executeListener(Session session, Message message)",
    "source_code": "\tprotected void executeListener(Session session, Message message) {\n\t\ttry {\n\t\t\tdoExecuteListener(session, message);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\thandleListenerException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#getDefaultSubscriptionName(messageListener)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the default subscription name for the given message listener.\n\t * @param messageListener the message listener object to check\n\t * @return the default subscription name\n\t * @see SubscriptionNameProvider\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "messageListener"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "String",
    "signature": "protected String getDefaultSubscriptionName(Object messageListener)",
    "source_code": "\tprotected String getDefaultSubscriptionName(Object messageListener) {\n\t\tif (messageListener instanceof SubscriptionNameProvider subscriptionNameProvider) {\n\t\t\treturn subscriptionNameProvider.getSubscriptionName();\n\t\t}\n\t\telse {\n\t\t\treturn messageListener.getClass().getName();\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#getDestination()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the destination to receive messages from. Will be {@code null}\n\t * if the configured destination is not an actual {@link Destination} type;\n\t * c.f. {@link #setDestinationName(String) when the destination is a String}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "Destination",
    "signature": "public Destination getDestination()",
    "source_code": "\tpublic Destination getDestination() {\n\t\treturn (this.destination instanceof Destination _destination ? _destination : null);\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#getDestinationDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a descriptive String for this container's JMS destination\n\t * (never {@code null}).\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "String",
    "signature": "protected String getDestinationDescription()",
    "source_code": "\tprotected String getDestinationDescription() {\n\t\tObject destination = this.destination;\n\t\treturn (destination != null ? destination.toString() : \"\");\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#getDestinationName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the destination to receive messages from.\n\t * Will be {@code null} if the configured destination is not a\n\t * {@link String} type; c.f. {@link #setDestination(Destination) when\n\t * it is an actual Destination}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "String",
    "signature": "public String getDestinationName()",
    "source_code": "\tpublic String getDestinationName() {\n\t\treturn (this.destination instanceof String name ? name : null);\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#getDurableSubscriptionName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of a durable subscription to create, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 444
    },
    "return": "String",
    "signature": "public String getDurableSubscriptionName()",
    "source_code": "\tpublic String getDurableSubscriptionName() {\n\t\treturn (this.subscriptionDurable ? this.subscriptionName : null);\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#getErrorHandler()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the ErrorHandler to be invoked in case of any uncaught exceptions thrown\n\t * while processing a Message.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 560
    },
    "return": "ErrorHandler",
    "signature": "public ErrorHandler getErrorHandler()",
    "source_code": "\tpublic ErrorHandler getErrorHandler() {\n\t\treturn this.errorHandler;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#getExceptionListener()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JMS ExceptionListener to notify in case of a JMSException thrown\n\t * by the registered message listener or the invocation infrastructure, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 540
    },
    "return": "ExceptionListener",
    "signature": "public ExceptionListener getExceptionListener()",
    "source_code": "\tpublic ExceptionListener getExceptionListener() {\n\t\treturn this.exceptionListener;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#getMessageConverter()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 523
    },
    "return": "MessageConverter",
    "signature": "public MessageConverter getMessageConverter()",
    "source_code": "\tpublic MessageConverter getMessageConverter() {\n\t\treturn this.messageConverter;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#getMessageListener()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the message listener object to register.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "Object",
    "signature": "public Object getMessageListener()",
    "source_code": "\tpublic Object getMessageListener() {\n\t\treturn this.messageListener;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#getMessageSelector()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JMS message selector expression (or {@code null} if none).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "String",
    "signature": "public String getMessageSelector()",
    "source_code": "\tpublic String getMessageSelector() {\n\t\treturn this.messageSelector;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#getReplyQosSettings()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 509
    },
    "return": "QosSettings",
    "signature": "public QosSettings getReplyQosSettings()",
    "source_code": "\tpublic QosSettings getReplyQosSettings() {\n\t\treturn this.replyQosSettings;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#getSubscriptionName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of a subscription to create, if any.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "String",
    "signature": "public String getSubscriptionName()",
    "source_code": "\tpublic String getSubscriptionName() {\n\t\treturn this.subscriptionName;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#handleListenerException(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the given exception that arose during listener execution.\n\t * <p>The default implementation logs the exception at warn level,\n\t * not propagating it to the JMS provider &mdash; assuming that all handling of\n\t * acknowledgement and/or transactions is done by this listener container.\n\t * This can be overridden in subclasses.\n\t * @param ex the exception to handle\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 886
    },
    "return": "void",
    "signature": "protected void handleListenerException(Throwable ex)",
    "source_code": "\tprotected void handleListenerException(Throwable ex) {\n\t\tif (ex instanceof MessageRejectedWhileStoppingException) {\n\t\t\t// Internal exception - has been handled before.\n\t\t\treturn;\n\t\t}\n\t\tif (ex instanceof JMSException jmsException) {\n\t\t\tinvokeExceptionListener(jmsException);\n\t\t}\n\t\tif (isActive()) {\n\t\t\t// Regular case: failed while active.\n\t\t\t// Invoke ErrorHandler if available.\n\t\t\tinvokeErrorHandler(ex);\n\t\t}\n\t\telse {\n\t\t\t// Rare case: listener thread failed after container shutdown.\n\t\t\t// Log at debug level, to avoid spamming the shutdown log.\n\t\t\tlogger.debug(\"Listener exception after container shutdown\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#invokeErrorHandler(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the registered ErrorHandler, if any. Log at warn level otherwise.\n\t * @param ex the uncaught error that arose during JMS processing.\n\t * @see #setErrorHandler\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 923
    },
    "return": "void",
    "signature": "protected void invokeErrorHandler(Throwable ex)",
    "source_code": "\tprotected void invokeErrorHandler(Throwable ex) {\n\t\tErrorHandler errorHandler = getErrorHandler();\n\t\tif (errorHandler != null) {\n\t\t\terrorHandler.handleError(ex);\n\t\t}\n\t\telse {\n\t\t\tlogger.warn(\"Execution of JMS message listener failed, and no ErrorHandler has been set.\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#invokeExceptionListener(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the registered JMS ExceptionListener, if any.\n\t * @param ex the exception that arose during JMS processing\n\t * @see #setExceptionListener\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 911
    },
    "return": "void",
    "signature": "protected void invokeExceptionListener(JMSException ex)",
    "source_code": "\tprotected void invokeExceptionListener(JMSException ex) {\n\t\tExceptionListener exceptionListener = getExceptionListener();\n\t\tif (exceptionListener != null) {\n\t\t\texceptionListener.onException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#invokeListener(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified listener: either as standard JMS MessageListener\n\t * or (preferably) as Spring SessionAwareMessageListener.\n\t * @param session the JMS Session to operate on\n\t * @param message the received JMS Message\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setMessageListener\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 692
    },
    "return": "void",
    "signature": "protected void invokeListener(Session session, Message message)",
    "source_code": "\tprotected void invokeListener(Session session, Message message) throws JMSException {\n\t\tObject listener = getMessageListener();\n\n\t\tif (listener instanceof SessionAwareMessageListener sessionAwareMessageListener) {\n\t\t\tdoInvokeListener(sessionAwareMessageListener, session, message);\n\t\t}\n\t\telse if (listener instanceof MessageListener msgListener) {\n\t\t\tdoInvokeListener(msgListener, message);\n\t\t}\n\t\telse if (listener != null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Only MessageListener and SessionAwareMessageListener supported: \" + listener);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"No message listener specified - see property 'messageListener'\");\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#isAcceptMessagesWhileStopping()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to accept received messages while the listener container\n\t * in the process of stopping.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 612
    },
    "return": "boolean",
    "signature": "public boolean isAcceptMessagesWhileStopping()",
    "source_code": "\tpublic boolean isAcceptMessagesWhileStopping() {\n\t\treturn this.acceptMessagesWhileStopping;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#isExposeListenerSession()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to expose the listener JMS {@link Session} to a\n\t * registered {@link SessionAwareMessageListener}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 586
    },
    "return": "boolean",
    "signature": "public boolean isExposeListenerSession()",
    "source_code": "\tpublic boolean isExposeListenerSession() {\n\t\treturn this.exposeListenerSession;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#isPubSubNoLocal()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to inhibit the delivery of messages published by its own connection.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 462
    },
    "return": "boolean",
    "signature": "public boolean isPubSubNoLocal()",
    "source_code": "\tpublic boolean isPubSubNoLocal() {\n\t\treturn this.pubSubNoLocal;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#isReplyPubSubDomain()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the Publish/Subscribe domain ({@link jakarta.jms.Topic Topics}) is used\n\t * for replies. Otherwise, the Point-to-Point domain ({@link jakarta.jms.Queue Queues})\n\t * is used.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 487
    },
    "return": "boolean",
    "signature": "public boolean isReplyPubSubDomain()",
    "source_code": "\tpublic boolean isReplyPubSubDomain() {\n\t\tif (this.replyPubSubDomain != null) {\n\t\t\treturn this.replyPubSubDomain;\n\t\t}\n\t\telse {\n\t\t\treturn isPubSubDomain();\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#isSessionLocallyTransacted(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given Session is locally transacted, that is, whether\n\t * its transaction is managed by this listener container's Session handling\n\t * and not by an external transaction coordinator.\n\t * <p>Note: The Session's own transacted flag will already have been checked\n\t * before. This method is about finding out whether the Session's transaction\n\t * is local or externally coordinated.\n\t * @param session the Session to check\n\t * @return whether the given Session is locally transacted\n\t * @see #isSessionTransacted()\n\t * @see org.springframework.jms.connection.ConnectionFactoryUtils#isSessionTransactional\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 843
    },
    "return": "boolean",
    "signature": "protected boolean isSessionLocallyTransacted(Session session)",
    "source_code": "\tprotected boolean isSessionLocallyTransacted(Session session) {\n\t\treturn isSessionTransacted();\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#isSubscriptionDurable()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to make the subscription durable.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 358
    },
    "return": "boolean",
    "signature": "public boolean isSubscriptionDurable()",
    "source_code": "\tpublic boolean isSubscriptionDurable() {\n\t\treturn this.subscriptionDurable;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#isSubscriptionShared()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to make the subscription shared.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "boolean",
    "signature": "public boolean isSubscriptionShared()",
    "source_code": "\tpublic boolean isSubscriptionShared() {\n\t\treturn this.subscriptionShared;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#rollbackIfNecessary(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a rollback, if appropriate.\n\t * @param session the JMS Session to rollback\n\t * @throws jakarta.jms.JMSException in case of a rollback error\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 789
    },
    "return": "void",
    "signature": "protected void rollbackIfNecessary(Session session)",
    "source_code": "\tprotected void rollbackIfNecessary(Session session) throws JMSException {\n\t\tif (session.getTransacted()) {\n\t\t\tif (isSessionLocallyTransacted(session)) {\n\t\t\t\t// Transacted session created by this container -> rollback.\n\t\t\t\tJmsUtils.rollbackIfNecessary(session);\n\t\t\t}\n\t\t}\n\t\telse if (isClientAcknowledge(session)) {\n\t\t\tsession.recover();\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#rollbackOnExceptionIfNecessary(session,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a rollback, handling rollback exceptions properly.\n\t * @param session the JMS Session to rollback\n\t * @param ex the thrown application exception or error\n\t * @throws jakarta.jms.JMSException in case of a rollback error\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 807
    },
    "return": "void",
    "signature": "protected void rollbackOnExceptionIfNecessary(Session session, Throwable ex)",
    "source_code": "\tprotected void rollbackOnExceptionIfNecessary(Session session, Throwable ex) throws JMSException {\n\t\ttry {\n\t\t\tif (session.getTransacted()) {\n\t\t\t\tif (isSessionLocallyTransacted(session)) {\n\t\t\t\t\t// Transacted session created by this container -> rollback.\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Initiating transaction rollback on application exception\", ex);\n\t\t\t\t\t}\n\t\t\t\t\tJmsUtils.rollbackIfNecessary(session);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (isClientAcknowledge(session)) {\n\t\t\t\tsession.recover();\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalStateException ex2) {\n\t\t\tlogger.debug(\"Could not roll back because Session already closed\", ex2);\n\t\t}\n\t\tcatch (JMSException | RuntimeException | Error ex2) {\n\t\t\tlogger.error(\"Application exception overridden by rollback error\", ex);\n\t\t\tthrow ex2;\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setAcceptMessagesWhileStopping(acceptMessagesWhileStopping)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to accept received messages while the listener container\n\t * in the process of stopping.\n\t * <p>Default is \"false\", rejecting such messages through aborting the\n\t * receive attempt. Switch this flag on to fully process such messages\n\t * even in the stopping phase, with the drawback that even newly sent\n\t * messages might still get processed (if coming in before all receive\n\t * timeouts have expired).\n\t * <p><b>NOTE:</b> Aborting receive attempts for such incoming messages\n\t * might lead to the provider's retry count decreasing for the affected\n\t * messages. If you have a high number of concurrent consumers, make sure\n\t * that the number of retries is higher than the number of consumers,\n\t * to be on the safe side for all potential stopping scenarios.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptMessagesWhileStopping"
    ],
    "position": {
      "column": 1,
      "line": 604
    },
    "return": "void",
    "signature": "public void setAcceptMessagesWhileStopping(boolean acceptMessagesWhileStopping)",
    "source_code": "\tpublic void setAcceptMessagesWhileStopping(boolean acceptMessagesWhileStopping) {\n\t\tthis.acceptMessagesWhileStopping = acceptMessagesWhileStopping;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setConcurrency(concurrency)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify concurrency limits.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "concurrency"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "void",
    "signature": "public void setConcurrency(String concurrency)",
    "source_code": "\tpublic abstract void setConcurrency(String concurrency);"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setDestination(destination)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the destination to receive messages from.\n\t * <p>Alternatively, specify a \"destinationName\", to be dynamically\n\t * resolved via the {@link org.springframework.jms.support.destination.DestinationResolver}.\n\t * <p>Note: The destination may be replaced at runtime, with the listener\n\t * container picking up the new destination immediately (works e.g. with\n\t * DefaultMessageListenerContainer, as long as the cache level is less than\n\t * CACHE_CONSUMER). However, this is considered advanced usage; use it with care!\n\t * @see #setDestinationName(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "void",
    "signature": "public void setDestination(@Nullable Destination destination)",
    "source_code": "\tpublic void setDestination(@Nullable Destination destination) {\n\t\tthis.destination = destination;\n\t\tif (destination instanceof Topic && !(destination instanceof Queue)) {\n\t\t\t// Clearly a Topic: let's set the \"pubSubDomain\" flag accordingly.\n\t\t\tsetPubSubDomain(true);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setDestinationName(destinationName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the destination to receive messages from.\n\t * <p>The specified name will be dynamically resolved via the configured\n\t * {@link #setDestinationResolver destination resolver}.\n\t * <p>Alternatively, specify a JMS {@link Destination} object as \"destination\".\n\t * <p>Note: The destination may be replaced at runtime, with the listener\n\t * container picking up the new destination immediately (works e.g. with\n\t * DefaultMessageListenerContainer, as long as the cache level is less than\n\t * CACHE_CONSUMER). However, this is considered advanced usage; use it with care!\n\t * @see #setDestination(jakarta.jms.Destination)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "void",
    "signature": "public void setDestinationName(@Nullable String destinationName)",
    "source_code": "\tpublic void setDestinationName(@Nullable String destinationName) {\n\t\tthis.destination = destinationName;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setDurableSubscriptionName(durableSubscriptionName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of a durable subscription to create. This method switches\n\t * to pub-sub domain mode and activates subscription durability as well.\n\t * <p>The durable subscription name needs to be unique within this client's\n\t * JMS client id. Default is the class name of the specified message listener.\n\t * <p>Note: Only 1 concurrent consumer (which is the default of this\n\t * message listener container) is allowed for each durable subscription,\n\t * except for a shared durable subscription (which requires JMS 2.0).\n\t * @see #setPubSubDomain\n\t * @see #setSubscriptionDurable\n\t * @see #setSubscriptionShared\n\t * @see #setClientId\n\t * @see #setMessageListener\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "durableSubscriptionName"
    ],
    "position": {
      "column": 1,
      "line": 435
    },
    "return": "void",
    "signature": "public void setDurableSubscriptionName(@Nullable String durableSubscriptionName)",
    "source_code": "\tpublic void setDurableSubscriptionName(@Nullable String durableSubscriptionName) {\n\t\tthis.subscriptionName = durableSubscriptionName;\n\t\tthis.subscriptionDurable = (durableSubscriptionName != null);\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setErrorHandler(errorHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the ErrorHandler to be invoked in case of any uncaught exceptions thrown\n\t * while processing a Message.\n\t * <p>By default, there will be <b>no</b> ErrorHandler so that error-level\n\t * logging is the only result.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 550
    },
    "return": "void",
    "signature": "public void setErrorHandler(@Nullable ErrorHandler errorHandler)",
    "source_code": "\tpublic void setErrorHandler(@Nullable ErrorHandler errorHandler) {\n\t\tthis.errorHandler = errorHandler;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setExceptionListener(exceptionListener)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JMS ExceptionListener to notify in case of a JMSException thrown\n\t * by the registered message listener or the invocation infrastructure.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exceptionListener"
    ],
    "position": {
      "column": 1,
      "line": 531
    },
    "return": "void",
    "signature": "public void setExceptionListener(@Nullable ExceptionListener exceptionListener)",
    "source_code": "\tpublic void setExceptionListener(@Nullable ExceptionListener exceptionListener) {\n\t\tthis.exceptionListener = exceptionListener;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setExposeListenerSession(exposeListenerSession)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to expose the listener JMS Session to a registered\n\t * {@link SessionAwareMessageListener} as well as to\n\t * {@link org.springframework.jms.core.JmsTemplate} calls.\n\t * <p>Default is \"true\", reusing the listener's {@link Session}.\n\t * Turn this off to expose a fresh JMS Session fetched from the same\n\t * underlying JMS {@link Connection} instead, which might be necessary\n\t * on some JMS providers.\n\t * <p>Note that Sessions managed by an external transaction manager will\n\t * always get exposed to {@link org.springframework.jms.core.JmsTemplate}\n\t * calls. So in terms of JmsTemplate exposure, this setting only affects\n\t * locally transacted Sessions.\n\t * @see SessionAwareMessageListener\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exposeListenerSession"
    ],
    "position": {
      "column": 1,
      "line": 578
    },
    "return": "void",
    "signature": "public void setExposeListenerSession(boolean exposeListenerSession)",
    "source_code": "\tpublic void setExposeListenerSession(boolean exposeListenerSession) {\n\t\tthis.exposeListenerSession = exposeListenerSession;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setMessageConverter(messageConverter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link MessageConverter} strategy for converting JMS Messages.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageConverter"
    ],
    "position": {
      "column": 1,
      "line": 517
    },
    "return": "void",
    "signature": "public void setMessageConverter(@Nullable MessageConverter messageConverter)",
    "source_code": "\tpublic void setMessageConverter(@Nullable MessageConverter messageConverter) {\n\t\tthis.messageConverter = messageConverter;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setMessageListener(messageListener)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the message listener implementation to register.\n\t * This can be either a standard JMS {@link MessageListener} object\n\t * or a Spring {@link SessionAwareMessageListener} object.\n\t * <p>Note: The message listener may be replaced at runtime, with the listener\n\t * container picking up the new listener object immediately (works e.g. with\n\t * DefaultMessageListenerContainer, as long as the cache level is less than\n\t * CACHE_CONSUMER). However, this is considered advanced usage; use it with care!\n\t * @throws IllegalArgumentException if the supplied listener is not a\n\t * {@link MessageListener} or a {@link SessionAwareMessageListener}\n\t * @see jakarta.jms.MessageListener\n\t * @see SessionAwareMessageListener\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageListener"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "void",
    "signature": "public void setMessageListener(@Nullable Object messageListener)",
    "source_code": "\tpublic void setMessageListener(@Nullable Object messageListener) {\n\t\tcheckMessageListener(messageListener);\n\t\tthis.messageListener = messageListener;\n\t\tif (messageListener != null && this.subscriptionName == null) {\n\t\t\tthis.subscriptionName = getDefaultSubscriptionName(messageListener);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setMessageSelector(messageSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JMS message selector expression (or {@code null} if none).\n\t * Default is none.\n\t * <p>See the JMS specification for a detailed definition of selector expressions.\n\t * <p>Note: The message selector may be replaced at runtime, with the listener\n\t * container picking up the new selector value immediately (works e.g. with\n\t * DefaultMessageListenerContainer, as long as the cache level is less than\n\t * CACHE_CONSUMER). However, this is considered advanced usage; use it with care!\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "void",
    "signature": "public void setMessageSelector(@Nullable String messageSelector)",
    "source_code": "\tpublic void setMessageSelector(@Nullable String messageSelector) {\n\t\tthis.messageSelector = messageSelector;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setPubSubNoLocal(pubSubNoLocal)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to inhibit the delivery of messages published by its own connection.\n\t * Default is \"false\".\n\t * @since 4.1\n\t * @see jakarta.jms.Session#createConsumer(jakarta.jms.Destination, String, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pubSubNoLocal"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "void",
    "signature": "public void setPubSubNoLocal(boolean pubSubNoLocal)",
    "source_code": "\tpublic void setPubSubNoLocal(boolean pubSubNoLocal) {\n\t\tthis.pubSubNoLocal = pubSubNoLocal;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setReplyPubSubDomain(replyPubSubDomain)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the reply destination type. By default, the configured {@code pubSubDomain}\n\t * value is used (see {@link #isPubSubDomain()}).\n\t * <p>This setting primarily indicates what type of destination to resolve if dynamic\n\t * destinations are enabled.\n\t * @param replyPubSubDomain \"true\" for the Publish/Subscribe domain ({@link Topic Topics}),\n\t * \"false\" for the Point-to-Point domain ({@link Queue Queues})\n\t * @since 4.2\n\t * @see #setDestinationResolver\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "replyPubSubDomain"
    ],
    "position": {
      "column": 1,
      "line": 476
    },
    "return": "void",
    "signature": "public void setReplyPubSubDomain(boolean replyPubSubDomain)",
    "source_code": "\tpublic void setReplyPubSubDomain(boolean replyPubSubDomain) {\n\t\tthis.replyPubSubDomain = replyPubSubDomain;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setReplyQosSettings(replyQosSettings)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link QosSettings} to use when sending a reply. Can be set to\n\t * {@code null} to indicate that the broker's defaults should be used.\n\t * @param replyQosSettings the QoS settings to use when sending a reply or {@code null}\n\t * to use the default vas.\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "replyQosSettings"
    ],
    "position": {
      "column": 1,
      "line": 503
    },
    "return": "void",
    "signature": "public void setReplyQosSettings(@Nullable QosSettings replyQosSettings)",
    "source_code": "\tpublic void setReplyQosSettings(@Nullable QosSettings replyQosSettings) {\n\t\tthis.replyQosSettings = replyQosSettings;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setSubscriptionDurable(subscriptionDurable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to make the subscription durable. The durable subscription name\n\t * to be used can be specified through the \"subscriptionName\" property.\n\t * <p>Default is \"false\". Set this to \"true\" to register a durable subscription,\n\t * typically in combination with a \"subscriptionName\" value (unless\n\t * your message listener class name is good enough as subscription name).\n\t * <p>Only makes sense when listening to a topic (pub-sub domain),\n\t * therefore this method switches the \"pubSubDomain\" flag as well.\n\t * @see #setSubscriptionName\n\t * @see #setPubSubDomain\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subscriptionDurable"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "void",
    "signature": "public void setSubscriptionDurable(boolean subscriptionDurable)",
    "source_code": "\tpublic void setSubscriptionDurable(boolean subscriptionDurable) {\n\t\tthis.subscriptionDurable = subscriptionDurable;\n\t\tif (subscriptionDurable) {\n\t\t\tsetPubSubDomain(true);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setSubscriptionName(subscriptionName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of a subscription to create. To be applied in case\n\t * of a topic (pub-sub domain) with a shared or durable subscription.\n\t * <p>The subscription name needs to be unique within this client's\n\t * JMS client id. Default is the class name of the specified message listener.\n\t * <p>Note: Only 1 concurrent consumer (which is the default of this\n\t * message listener container) is allowed for each subscription,\n\t * except for a shared subscription (which requires JMS 2.0).\n\t * @since 4.1\n\t * @see #setPubSubDomain\n\t * @see #setSubscriptionDurable\n\t * @see #setSubscriptionShared\n\t * @see #setClientId\n\t * @see #setMessageListener\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subscriptionName"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "void",
    "signature": "public void setSubscriptionName(@Nullable String subscriptionName)",
    "source_code": "\tpublic void setSubscriptionName(@Nullable String subscriptionName) {\n\t\tthis.subscriptionName = subscriptionName;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setSubscriptionShared(subscriptionShared)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to make the subscription shared. The shared subscription name\n\t * to be used can be specified through the \"subscriptionName\" property.\n\t * <p>Default is \"false\". Set this to \"true\" to register a shared subscription,\n\t * typically in combination with a \"subscriptionName\" value (unless\n\t * your message listener class name is good enough as subscription name).\n\t * Note that shared subscriptions may also be durable, so this flag can\n\t * (and often will) be combined with \"subscriptionDurable\" as well.\n\t * <p>Only makes sense when listening to a topic (pub-sub domain),\n\t * therefore this method switches the \"pubSubDomain\" flag as well.\n\t * <p><b>Requires a JMS 2.0 compatible message broker.</b>\n\t * @since 4.1\n\t * @see #setSubscriptionName\n\t * @see #setSubscriptionDurable\n\t * @see #setPubSubDomain\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subscriptionShared"
    ],
    "position": {
      "column": 1,
      "line": 378
    },
    "return": "void",
    "signature": "public void setSubscriptionShared(boolean subscriptionShared)",
    "source_code": "\tpublic void setSubscriptionShared(boolean subscriptionShared) {\n\t\tthis.subscriptionShared = subscriptionShared;\n\t\tif (subscriptionShared) {\n\t\t\tsetPubSubDomain(true);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setupMessageListener(messageListener)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageListener"
    ],
    "position": {
      "column": 1,
      "line": 624
    },
    "return": "void",
    "signature": "public void setupMessageListener(Object messageListener)",
    "source_code": "\tpublic void setupMessageListener(Object messageListener) {\n\t\tsetMessageListener(messageListener);\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#validateConfiguration()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 617
    },
    "return": "void",
    "signature": "protected void validateConfiguration()",
    "source_code": "\tprotected void validateConfiguration() {\n\t\tif (this.destination == null) {\n\t\t\tthrow new IllegalArgumentException(\"Property 'destination' or 'destinationName' is required\");\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Base class for listener container implementations which are based on polling.\n * Provides support for listener handling based on {@link jakarta.jms.MessageConsumer},\n * optionally participating in externally managed transactions.\n *\n * <p>This listener container variant is built for repeated polling attempts,\n * each invoking the {@link #receiveAndExecute} method. The MessageConsumer used\n * may be reobtained fo reach attempt or cached in between attempts; this is up\n * to the concrete implementation. The receive timeout for each attempt can be\n * configured through the {@link #setReceiveTimeout \"receiveTimeout\"} property.\n *\n * <p>The underlying mechanism is based on standard JMS MessageConsumer handling,\n * which is perfectly compatible with both native JMS and JMS in a Jakarta EE environment.\n * Neither the JMS {@code MessageConsumer.setMessageListener} facility  nor the JMS\n * ServerSessionPool facility is required. A further advantage of this approach is\n * full control over the listening process, allowing for custom scaling and throttling\n * and of concurrent message processing (which is up to concrete subclasses).\n *\n * <p>Message reception and listener execution can automatically be wrapped\n * in transactions through passing a Spring\n * {@link org.springframework.transaction.PlatformTransactionManager} into the\n * {@link #setTransactionManager \"transactionManager\"} property. This will usually\n * be a {@link org.springframework.transaction.jta.JtaTransactionManager} in a\n * Jakarta EE environment, in combination with a JTA-aware JMS ConnectionFactory\n * obtained from JNDI (check your application server's documentation).\n *\n * <p>This base class does not assume any specific mechanism for asynchronous\n * execution of polling invokers. Check out {@link DefaultMessageListenerContainer}\n * for a concrete implementation which is based on Spring's\n * {@link org.springframework.core.task.TaskExecutor} abstraction,\n * including dynamic scaling of concurrent consumers and automatic self recovery.\n *\n * @author Juergen Hoeller\n * @since 2.0.3\n * @see #createListenerConsumer\n * @see #receiveAndExecute\n * @see #setTransactionManager\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public class AbstractPollingMessageListenerContainer",
    "source_code": "public abstract class AbstractPollingMessageListenerContainer extends AbstractMessageListenerContainer {\n\n\t/**\n\t * The default receive timeout: 1000 ms = 1 second.\n\t */\n\tpublic static final long DEFAULT_RECEIVE_TIMEOUT = 1000;\n\n\n\tprivate final MessageListenerContainerResourceFactory transactionalResourceFactory =\n\t\t\tnew MessageListenerContainerResourceFactory();\n\n\tprivate boolean sessionTransactedCalled = false;\n\n\t@Nullable\n\tprivate PlatformTransactionManager transactionManager;\n\n\tprivate final DefaultTransactionDefinition transactionDefinition = new DefaultTransactionDefinition();\n\n\tprivate long receiveTimeout = DEFAULT_RECEIVE_TIMEOUT;\n\n\n\t@Override\n\tpublic void setSessionTransacted(boolean sessionTransacted) {\n\t\tsuper.setSessionTransacted(sessionTransacted);\n\t\tthis.sessionTransactedCalled = true;\n\t}\n\n\t/**\n\t * Specify the Spring {@link org.springframework.transaction.PlatformTransactionManager}\n\t * to use for transactional wrapping of message reception plus listener execution.\n\t * <p>Default is none, not performing any transactional wrapping.\n\t * If specified, this will usually be a Spring\n\t * {@link org.springframework.transaction.jta.JtaTransactionManager} or one\n\t * of its subclasses, in combination with a JTA-aware ConnectionFactory that\n\t * this message listener container obtains its Connections from.\n\t * <p><b>Note: Consider the use of local JMS transactions instead.</b>\n\t * Simply switch the {@link #setSessionTransacted \"sessionTransacted\"} flag\n\t * to \"true\" in order to use a locally transacted JMS Session for the entire\n\t * receive processing, including any Session operations performed by a\n\t * {@link SessionAwareMessageListener} (e.g. sending a response message). This\n\t * allows for fully synchronized Spring transactions based on local JMS\n\t * transactions, similar to what\n\t * {@link org.springframework.jms.connection.JmsTransactionManager} provides. Check\n\t * {@link AbstractMessageListenerContainer}'s javadoc for\n\t * a discussion of transaction choices and message redelivery scenarios.\n\t * @see #setSessionTransacted(boolean)\n\t * @see org.springframework.transaction.jta.JtaTransactionManager\n\t * @see org.springframework.jms.connection.JmsTransactionManager\n\t */\n\tpublic void setTransactionManager(@Nullable PlatformTransactionManager transactionManager) {\n\t\tthis.transactionManager = transactionManager;\n\t}\n\n\t/**\n\t * Return the Spring PlatformTransactionManager to use for transactional\n\t * wrapping of message reception plus listener execution.\n\t */\n\t@Nullable\n\tprotected final PlatformTransactionManager getTransactionManager() {\n\t\treturn this.transactionManager;\n\t}\n\n\t/**\n\t * Specify the transaction name to use for transactional wrapping.\n\t * Default is the bean name of this listener container, if any.\n\t * @see org.springframework.transaction.TransactionDefinition#getName()\n\t */\n\tpublic void setTransactionName(String transactionName) {\n\t\tthis.transactionDefinition.setName(transactionName);\n\t}\n\n\t/**\n\t * Specify the transaction timeout to use for transactional wrapping, in <b>seconds</b>.\n\t * Default is none, using the transaction manager's default timeout.\n\t * @see org.springframework.transaction.TransactionDefinition#getTimeout()\n\t * @see #setReceiveTimeout\n\t */\n\tpublic void setTransactionTimeout(int transactionTimeout) {\n\t\tthis.transactionDefinition.setTimeout(transactionTimeout);\n\t}\n\n\t/**\n\t * Set the timeout to use for receive calls, in <b>milliseconds</b>.\n\t * The default is 1000 ms, that is, 1 second.\n\t * <p><b>NOTE:</b> This value needs to be smaller than the transaction\n\t * timeout used by the transaction manager (in the appropriate unit,\n\t * of course). 0 indicates no timeout at all; however, this is only\n\t * feasible if not running within a transaction manager and generally\n\t * discouraged since such a listener container cannot cleanly shut down.\n\t * A negative value such as -1 indicates a no-wait receive operation.\n\t * @see #receiveFromConsumer(MessageConsumer, long)\n\t * @see jakarta.jms.MessageConsumer#receive(long)\n\t * @see jakarta.jms.MessageConsumer#receiveNoWait()\n\t * @see jakarta.jms.MessageConsumer#receive()\n\t * @see #setTransactionTimeout\n\t */\n\tpublic void setReceiveTimeout(long receiveTimeout) {\n\t\tthis.receiveTimeout = receiveTimeout;\n\t}\n\n\t/**\n\t * Return the receive timeout (ms) configured for this listener container.\n\t * @since 4.2\n\t */\n\tprotected long getReceiveTimeout() {\n\t\treturn this.receiveTimeout;\n\t}\n\n\n\t@Override\n\tpublic void initialize() {\n\t\t// Set sessionTransacted=true in case of a non-JTA transaction manager.\n\t\tif (!this.sessionTransactedCalled &&\n\t\t\t\tthis.transactionManager instanceof ResourceTransactionManager rtm &&\n\t\t\t\t!TransactionSynchronizationUtils.sameResourceFactory(rtm, obtainConnectionFactory())) {\n\t\t\tsuper.setSessionTransacted(true);\n\t\t}\n\n\t\t// Use bean name as default transaction name.\n\t\tif (this.transactionDefinition.getName() == null) {\n\t\t\tString beanName = getBeanName();\n\t\t\tif (beanName != null) {\n\t\t\t\tthis.transactionDefinition.setName(beanName);\n\t\t\t}\n\t\t}\n\n\t\t// Proceed with superclass initialization.\n\t\tsuper.initialize();\n\t}\n\n\n\t/**\n\t * Create a MessageConsumer for the given JMS Session,\n\t * registering a MessageListener for the specified listener.\n\t * @param session the JMS Session to work on\n\t * @return the MessageConsumer\n\t * @throws jakarta.jms.JMSException if thrown by JMS methods\n\t * @see #receiveAndExecute\n\t */\n\tprotected MessageConsumer createListenerConsumer(Session session) throws JMSException {\n\t\tDestination destination = getDestination();\n\t\tif (destination == null) {\n\t\t\tString destinationName = getDestinationName();\n\t\t\tAssert.state(destinationName != null, \"No destination set\");\n\t\t\tdestination = resolveDestinationName(session, destinationName);\n\t\t}\n\t\treturn createConsumer(session, destination);\n\t}\n\n\t/**\n\t * Execute the listener for a message received from the given consumer,\n\t * wrapping the entire operation in an external transaction if demanded.\n\t * @param session the JMS Session to work on\n\t * @param consumer the MessageConsumer to work on\n\t * @return whether a message has been received\n\t * @throws JMSException if thrown by JMS methods\n\t * @see #doReceiveAndExecute\n\t */\n\tprotected boolean receiveAndExecute(\n\t\t\tObject invoker, @Nullable Session session, @Nullable MessageConsumer consumer)\n\t\t\tthrows JMSException {\n\n\t\tif (this.transactionManager != null) {\n\t\t\t// Execute receive within transaction.\n\t\t\tTransactionStatus status = this.transactionManager.getTransaction(this.transactionDefinition);\n\t\t\tboolean messageReceived;\n\t\t\ttry {\n\t\t\t\tmessageReceived = doReceiveAndExecute(invoker, session, consumer, status);\n\t\t\t}\n\t\t\tcatch (JMSException | RuntimeException | Error ex) {\n\t\t\t\trollbackOnException(this.transactionManager, status, ex);\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthis.transactionManager.commit(status);\n\t\t\t}\n\t\t\tcatch (TransactionException ex) {\n\t\t\t\t// Propagate transaction system exceptions as infrastructure problems.\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (RuntimeException ex) {\n\t\t\t\t// Typically a late persistence exception from a listener-used resource\n\t\t\t\t// -> handle it as listener exception, not as an infrastructure problem.\n\t\t\t\t// E.g. a database locking failure should not lead to listener shutdown.\n\t\t\t\thandleListenerException(ex);\n\t\t\t}\n\t\t\treturn messageReceived;\n\t\t}\n\n\t\telse {\n\t\t\t// Execute receive outside of transaction.\n\t\t\treturn doReceiveAndExecute(invoker, session, consumer, null);\n\t\t}\n\t}\n\n\t/**\n\t * Actually execute the listener for a message received from the given consumer,\n\t * fetching all requires resources and invoking the listener.\n\t * @param session the JMS Session to work on\n\t * @param consumer the MessageConsumer to work on\n\t * @param status the TransactionStatus (may be {@code null})\n\t * @return whether a message has been received\n\t * @throws JMSException if thrown by JMS methods\n\t * @see #doExecuteListener(jakarta.jms.Session, jakarta.jms.Message)\n\t */\n\tprotected boolean doReceiveAndExecute(Object invoker, @Nullable Session session,\n\t\t\t@Nullable MessageConsumer consumer, @Nullable TransactionStatus status) throws JMSException {\n\n\t\tConnection conToClose = null;\n\t\tSession sessionToClose = null;\n\t\tMessageConsumer consumerToClose = null;\n\t\ttry {\n\t\t\tSession sessionToUse = session;\n\t\t\tboolean transactional = false;\n\t\t\tif (sessionToUse == null) {\n\t\t\t\tsessionToUse = ConnectionFactoryUtils.doGetTransactionalSession(\n\t\t\t\t\t\tobtainConnectionFactory(), this.transactionalResourceFactory, true);\n\t\t\t\ttransactional = (sessionToUse != null);\n\t\t\t}\n\t\t\tif (sessionToUse == null) {\n\t\t\t\tConnection conToUse;\n\t\t\t\tif (sharedConnectionEnabled()) {\n\t\t\t\t\tconToUse = getSharedConnection();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconToUse = createConnection();\n\t\t\t\t\tconToClose = conToUse;\n\t\t\t\t\tconToUse.start();\n\t\t\t\t}\n\t\t\t\tsessionToUse = createSession(conToUse);\n\t\t\t\tsessionToClose = sessionToUse;\n\t\t\t}\n\t\t\tMessageConsumer consumerToUse = consumer;\n\t\t\tif (consumerToUse == null) {\n\t\t\t\tconsumerToUse = createListenerConsumer(sessionToUse);\n\t\t\t\tconsumerToClose = consumerToUse;\n\t\t\t}\n\t\t\tMessage message = receiveMessage(consumerToUse);\n\t\t\tif (message != null) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Received message of type [\" + message.getClass() + \"] from consumer [\" +\n\t\t\t\t\t\t\tconsumerToUse + \"] of \" + (transactional ? \"transactional \" : \"\") + \"session [\" +\n\t\t\t\t\t\t\tsessionToUse + \"]\");\n\t\t\t\t}\n\t\t\t\tmessageReceived(invoker, sessionToUse);\n\t\t\t\tboolean exposeResource = (!transactional && isExposeListenerSession() &&\n\t\t\t\t\t\t!TransactionSynchronizationManager.hasResource(obtainConnectionFactory()));\n\t\t\t\tif (exposeResource) {\n\t\t\t\t\tTransactionSynchronizationManager.bindResource(\n\t\t\t\t\t\t\tobtainConnectionFactory(), new LocallyExposedJmsResourceHolder(sessionToUse));\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tdoExecuteListener(sessionToUse, message);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tif (status != null) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Rolling back transaction because of listener exception thrown: \" + ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstatus.setRollbackOnly();\n\t\t\t\t\t}\n\t\t\t\t\thandleListenerException(ex);\n\t\t\t\t\t// Rethrow JMSException to indicate an infrastructure problem\n\t\t\t\t\t// that may have to trigger recovery...\n\t\t\t\t\tif (ex instanceof JMSException jmsException) {\n\t\t\t\t\t\tthrow jmsException;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tif (exposeResource) {\n\t\t\t\t\t\tTransactionSynchronizationManager.unbindResource(obtainConnectionFactory());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Indicate that a message has been received.\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Consumer [\" + consumerToUse + \"] of \" + (transactional ? \"transactional \" : \"\") +\n\t\t\t\t\t\t\t\"session [\" + sessionToUse + \"] did not receive a message\");\n\t\t\t\t}\n\t\t\t\tnoMessageReceived(invoker, sessionToUse);\n\t\t\t\t// Nevertheless call commit, in order to reset the transaction timeout (if any).\n\t\t\t\tif (shouldCommitAfterNoMessageReceived(sessionToUse)) {\n\t\t\t\t\tcommitIfNecessary(sessionToUse, null);\n\t\t\t\t}\n\t\t\t\t// Indicate that no message has been received.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageConsumer(consumerToClose);\n\t\t\tJmsUtils.closeSession(sessionToClose);\n\t\t\tConnectionFactoryUtils.releaseConnection(conToClose, getConnectionFactory(), true);\n\t\t}\n\t}\n\n\t/**\n\t * This implementation checks whether the Session is externally synchronized.\n\t * In this case, the Session is not locally transacted, despite the listener\n\t * container's \"sessionTransacted\" flag being set to \"true\".\n\t * @see org.springframework.jms.connection.JmsResourceHolder\n\t */\n\t@Override\n\tprotected boolean isSessionLocallyTransacted(Session session) {\n\t\tif (!super.isSessionLocallyTransacted(session)) {\n\t\t\treturn false;\n\t\t}\n\t\tJmsResourceHolder resourceHolder =\n\t\t\t\t(JmsResourceHolder) TransactionSynchronizationManager.getResource(obtainConnectionFactory());\n\t\treturn (resourceHolder == null || resourceHolder instanceof LocallyExposedJmsResourceHolder ||\n\t\t\t\t!resourceHolder.containsSession(session));\n\t}\n\n\t/**\n\t * Determine whether to trigger a commit after no message has been received.\n\t * This is a good idea on any modern-day JMS provider.\n\t * @param session the current JMS Session which received no message\n\t * @return whether to call {@link #commitIfNecessary} on the given Session\n\t */\n\tprotected boolean shouldCommitAfterNoMessageReceived(Session session) {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Perform a rollback, handling rollback exceptions properly.\n\t * @param status object representing the transaction\n\t * @param ex the thrown listener exception or error\n\t */\n\tprivate void rollbackOnException(PlatformTransactionManager manager, TransactionStatus status, Throwable ex) {\n\t\tlogger.debug(\"Initiating transaction rollback on listener exception\", ex);\n\t\ttry {\n\t\t\tmanager.rollback(status);\n\t\t}\n\t\tcatch (RuntimeException ex2) {\n\t\t\tlogger.error(\"Listener exception overridden by rollback exception\", ex);\n\t\t\tthrow ex2;\n\t\t}\n\t\tcatch (Error err) {\n\t\t\tlogger.error(\"Listener exception overridden by rollback error\", ex);\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t/**\n\t * Receive a message from the given consumer.\n\t * @param consumer the MessageConsumer to use\n\t * @return the Message, or {@code null} if none\n\t * @throws JMSException if thrown by JMS methods\n\t */\n\t@Nullable\n\tprotected Message receiveMessage(MessageConsumer consumer) throws JMSException {\n\t\treturn receiveFromConsumer(consumer, getReceiveTimeout());\n\t}\n\n\t/**\n\t * Template method that gets called right when a new message has been received,\n\t * before attempting to process it. Allows subclasses to react to the event\n\t * of an actual incoming message, for example adapting their consumer count.\n\t * @param invoker the invoker object (passed through)\n\t * @param session the receiving JMS Session\n\t */\n\tprotected void messageReceived(Object invoker, Session session) {\n\t}\n\n\t/**\n\t * Template method that gets called when <i>no</i> message has been received,\n\t * before returning to the receive loop again. Allows subclasses to react to\n\t * the event of no incoming message, for example marking the invoker as idle.\n\t * @param invoker the invoker object (passed through)\n\t * @param session the receiving JMS Session\n\t */\n\tprotected void noMessageReceived(Object invoker, Session session) {\n\t}\n\n\t/**\n\t * Fetch an appropriate Connection from the given JmsResourceHolder.\n\t * <p>This implementation accepts any JMS 1.1 Connection.\n\t * @param holder the JmsResourceHolder\n\t * @return an appropriate Connection fetched from the holder,\n\t * or {@code null} if none found\n\t */\n\t@Nullable\n\tprotected Connection getConnection(JmsResourceHolder holder) {\n\t\treturn holder.getConnection();\n\t}\n\n\t/**\n\t * Fetch an appropriate Session from the given JmsResourceHolder.\n\t * <p>This implementation accepts any JMS 1.1 Session.\n\t * @param holder the JmsResourceHolder\n\t * @return an appropriate Session fetched from the holder,\n\t * or {@code null} if none found\n\t */\n\t@Nullable\n\tprotected Session getSession(JmsResourceHolder holder) {\n\t\treturn holder.getSession();\n\t}\n\n\n\t/**\n\t * ResourceFactory implementation that delegates to this listener container's protected callback methods.\n\t */\n\tprivate class MessageListenerContainerResourceFactory implements ConnectionFactoryUtils.ResourceFactory {\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Connection getConnection(JmsResourceHolder holder) {\n\t\t\treturn AbstractPollingMessageListenerContainer.this.getConnection(holder);\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Session getSession(JmsResourceHolder holder) {\n\t\t\treturn AbstractPollingMessageListenerContainer.this.getSession(holder);\n\t\t}\n\n\t\t@Override\n\t\tpublic Connection createConnection() throws JMSException {\n\t\t\tif (AbstractPollingMessageListenerContainer.this.sharedConnectionEnabled()) {\n\t\t\t\tConnection sharedCon = AbstractPollingMessageListenerContainer.this.getSharedConnection();\n\t\t\t\treturn new SingleConnectionFactory(sharedCon).createConnection();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn AbstractPollingMessageListenerContainer.this.createConnection();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Session createSession(Connection con) throws JMSException {\n\t\t\treturn AbstractPollingMessageListenerContainer.this.createSession(con);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isSynchedLocalTransactionAllowed() {\n\t\t\treturn AbstractPollingMessageListenerContainer.this.isSessionTransacted();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#createConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 496
    },
    "return": "Connection",
    "signature": "public Connection createConnection()",
    "source_code": "\t\tpublic Connection createConnection() throws JMSException {\n\t\t\tif (AbstractPollingMessageListenerContainer.this.sharedConnectionEnabled()) {\n\t\t\t\tConnection sharedCon = AbstractPollingMessageListenerContainer.this.getSharedConnection();\n\t\t\t\treturn new SingleConnectionFactory(sharedCon).createConnection();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn AbstractPollingMessageListenerContainer.this.createConnection();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#createListenerConsumer(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a MessageConsumer for the given JMS Session,\n\t * registering a MessageListener for the specified listener.\n\t * @param session the JMS Session to work on\n\t * @return the MessageConsumer\n\t * @throws jakarta.jms.JMSException if thrown by JMS methods\n\t * @see #receiveAndExecute\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "MessageConsumer",
    "signature": "protected MessageConsumer createListenerConsumer(Session session)",
    "source_code": "\tprotected MessageConsumer createListenerConsumer(Session session) throws JMSException {\n\t\tDestination destination = getDestination();\n\t\tif (destination == null) {\n\t\t\tString destinationName = getDestinationName();\n\t\t\tAssert.state(destinationName != null, \"No destination set\");\n\t\t\tdestination = resolveDestinationName(session, destinationName);\n\t\t}\n\t\treturn createConsumer(session, destination);\n\t}"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#createSession(con)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con"
    ],
    "position": {
      "column": 1,
      "line": 507
    },
    "return": "Session",
    "signature": "public Session createSession(Connection con)",
    "source_code": "\t\tpublic Session createSession(Connection con) throws JMSException {\n\t\t\treturn AbstractPollingMessageListenerContainer.this.createSession(con);\n\t\t}"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#doReceiveAndExecute(invoker,session,consumer,status)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually execute the listener for a message received from the given consumer,\n\t * fetching all requires resources and invoking the listener.\n\t * @param session the JMS Session to work on\n\t * @param consumer the MessageConsumer to work on\n\t * @param status the TransactionStatus (may be {@code null})\n\t * @return whether a message has been received\n\t * @throws JMSException if thrown by JMS methods\n\t * @see #doExecuteListener(jakarta.jms.Session, jakarta.jms.Message)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "session",
      "consumer",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "boolean",
    "signature": "protected boolean doReceiveAndExecute(Object invoker, @Nullable Session session,\n\t\t\t@Nullable MessageConsumer consumer, @Nullable TransactionStatus status)",
    "source_code": "\tprotected boolean doReceiveAndExecute(Object invoker, @Nullable Session session,"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#getConnection(holder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "holder"
    ],
    "position": {
      "column": 1,
      "line": 485
    },
    "return": "Connection",
    "signature": "public Connection getConnection(JmsResourceHolder holder)",
    "source_code": "\t\tpublic Connection getConnection(JmsResourceHolder holder) {\n\t\t\treturn AbstractPollingMessageListenerContainer.this.getConnection(holder);\n\t\t}"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#getReceiveTimeout()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the receive timeout (ms) configured for this listener container.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "long",
    "signature": "protected long getReceiveTimeout()",
    "source_code": "\tprotected long getReceiveTimeout() {\n\t\treturn this.receiveTimeout;\n\t}"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#getSession(holder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "holder"
    ],
    "position": {
      "column": 1,
      "line": 491
    },
    "return": "Session",
    "signature": "public Session getSession(JmsResourceHolder holder)",
    "source_code": "\t\tpublic Session getSession(JmsResourceHolder holder) {\n\t\t\treturn AbstractPollingMessageListenerContainer.this.getSession(holder);\n\t\t}"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#getTransactionManager()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Spring PlatformTransactionManager to use for transactional\n\t * wrapping of message reception plus listener execution.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "PlatformTransactionManager",
    "signature": "protected PlatformTransactionManager getTransactionManager()",
    "source_code": "\tprotected final PlatformTransactionManager getTransactionManager() {\n\t\treturn this.transactionManager;\n\t}"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#initialize()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "void",
    "signature": "public void initialize()",
    "source_code": "\tpublic void initialize() {\n\t\t// Set sessionTransacted=true in case of a non-JTA transaction manager.\n\t\tif (!this.sessionTransactedCalled &&\n\t\t\t\tthis.transactionManager instanceof ResourceTransactionManager rtm &&\n\t\t\t\t!TransactionSynchronizationUtils.sameResourceFactory(rtm, obtainConnectionFactory())) {\n\t\t\tsuper.setSessionTransacted(true);\n\t\t}\n\n\t\t// Use bean name as default transaction name.\n\t\tif (this.transactionDefinition.getName() == null) {\n\t\t\tString beanName = getBeanName();\n\t\t\tif (beanName != null) {\n\t\t\t\tthis.transactionDefinition.setName(beanName);\n\t\t\t}\n\t\t}\n\n\t\t// Proceed with superclass initialization.\n\t\tsuper.initialize();\n\t}"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#isSessionLocallyTransacted(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation checks whether the Session is externally synchronized.\n\t * In this case, the Session is not locally transacted, despite the listener\n\t * container's \"sessionTransacted\" flag being set to \"true\".\n\t * @see org.springframework.jms.connection.JmsResourceHolder\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 382
    },
    "return": "boolean",
    "signature": "protected boolean isSessionLocallyTransacted(Session session)",
    "source_code": "\tprotected boolean isSessionLocallyTransacted(Session session) {\n\t\tif (!super.isSessionLocallyTransacted(session)) {\n\t\t\treturn false;\n\t\t}\n\t\tJmsResourceHolder resourceHolder =\n\t\t\t\t(JmsResourceHolder) TransactionSynchronizationManager.getResource(obtainConnectionFactory());\n\t\treturn (resourceHolder == null || resourceHolder instanceof LocallyExposedJmsResourceHolder ||\n\t\t\t\t!resourceHolder.containsSession(session));\n\t}"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#isSynchedLocalTransactionAllowed()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 512
    },
    "return": "boolean",
    "signature": "public boolean isSynchedLocalTransactionAllowed()",
    "source_code": "\t\tpublic boolean isSynchedLocalTransactionAllowed() {\n\t\t\treturn AbstractPollingMessageListenerContainer.this.isSessionTransacted();\n\t\t}"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#messageReceived(invoker,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that gets called right when a new message has been received,\n\t * before attempting to process it. Allows subclasses to react to the event\n\t * of an actual incoming message, for example adapting their consumer count.\n\t * @param invoker the invoker object (passed through)\n\t * @param session the receiving JMS Session\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 440
    },
    "return": "void",
    "signature": "protected void messageReceived(Object invoker, Session session)",
    "source_code": "\tprotected void messageReceived(Object invoker, Session session) {\n\t}"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#noMessageReceived(invoker,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that gets called when <i>no</i> message has been received,\n\t * before returning to the receive loop again. Allows subclasses to react to\n\t * the event of no incoming message, for example marking the invoker as idle.\n\t * @param invoker the invoker object (passed through)\n\t * @param session the receiving JMS Session\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 450
    },
    "return": "void",
    "signature": "protected void noMessageReceived(Object invoker, Session session)",
    "source_code": "\tprotected void noMessageReceived(Object invoker, Session session) {\n\t}"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#receiveAndExecute(invoker,session,consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the listener for a message received from the given consumer,\n\t * wrapping the entire operation in an external transaction if demanded.\n\t * @param session the JMS Session to work on\n\t * @param consumer the MessageConsumer to work on\n\t * @return whether a message has been received\n\t * @throws JMSException if thrown by JMS methods\n\t * @see #doReceiveAndExecute\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "session",
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "boolean",
    "signature": "protected boolean receiveAndExecute(Object invoker, @Nullable Session session, @Nullable MessageConsumer consumer)",
    "source_code": "\tprotected boolean receiveAndExecute("
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#receiveMessage(consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Receive a message from the given consumer.\n\t * @param consumer the MessageConsumer to use\n\t * @return the Message, or {@code null} if none\n\t * @throws JMSException if thrown by JMS methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "Message",
    "signature": "protected Message receiveMessage(MessageConsumer consumer)",
    "source_code": "\tprotected Message receiveMessage(MessageConsumer consumer) throws JMSException {\n\t\treturn receiveFromConsumer(consumer, getReceiveTimeout());\n\t}"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#setReceiveTimeout(receiveTimeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the timeout to use for receive calls, in <b>milliseconds</b>.\n\t * The default is 1000 ms, that is, 1 second.\n\t * <p><b>NOTE:</b> This value needs to be smaller than the transaction\n\t * timeout used by the transaction manager (in the appropriate unit,\n\t * of course). 0 indicates no timeout at all; however, this is only\n\t * feasible if not running within a transaction manager and generally\n\t * discouraged since such a listener container cannot cleanly shut down.\n\t * A negative value such as -1 indicates a no-wait receive operation.\n\t * @see #receiveFromConsumer(MessageConsumer, long)\n\t * @see jakarta.jms.MessageConsumer#receive(long)\n\t * @see jakarta.jms.MessageConsumer#receiveNoWait()\n\t * @see jakarta.jms.MessageConsumer#receive()\n\t * @see #setTransactionTimeout\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "receiveTimeout"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "void",
    "signature": "public void setReceiveTimeout(long receiveTimeout)",
    "source_code": "\tpublic void setReceiveTimeout(long receiveTimeout) {\n\t\tthis.receiveTimeout = receiveTimeout;\n\t}"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#setSessionTransacted(sessionTransacted)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionTransacted"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void setSessionTransacted(boolean sessionTransacted)",
    "source_code": "\tpublic void setSessionTransacted(boolean sessionTransacted) {\n\t\tsuper.setSessionTransacted(sessionTransacted);\n\t\tthis.sessionTransactedCalled = true;\n\t}"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#setTransactionManager(transactionManager)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the Spring {@link org.springframework.transaction.PlatformTransactionManager}\n\t * to use for transactional wrapping of message reception plus listener execution.\n\t * <p>Default is none, not performing any transactional wrapping.\n\t * If specified, this will usually be a Spring\n\t * {@link org.springframework.transaction.jta.JtaTransactionManager} or one\n\t * of its subclasses, in combination with a JTA-aware ConnectionFactory that\n\t * this message listener container obtains its Connections from.\n\t * <p><b>Note: Consider the use of local JMS transactions instead.</b>\n\t * Simply switch the {@link #setSessionTransacted \"sessionTransacted\"} flag\n\t * to \"true\" in order to use a locally transacted JMS Session for the entire\n\t * receive processing, including any Session operations performed by a\n\t * {@link SessionAwareMessageListener} (e.g. sending a response message). This\n\t * allows for fully synchronized Spring transactions based on local JMS\n\t * transactions, similar to what\n\t * {@link org.springframework.jms.connection.JmsTransactionManager} provides. Check\n\t * {@link AbstractMessageListenerContainer}'s javadoc for\n\t * a discussion of transaction choices and message redelivery scenarios.\n\t * @see #setSessionTransacted(boolean)\n\t * @see org.springframework.transaction.jta.JtaTransactionManager\n\t * @see org.springframework.jms.connection.JmsTransactionManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transactionManager"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void setTransactionManager(@Nullable PlatformTransactionManager transactionManager)",
    "source_code": "\tpublic void setTransactionManager(@Nullable PlatformTransactionManager transactionManager) {\n\t\tthis.transactionManager = transactionManager;\n\t}"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#setTransactionName(transactionName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the transaction name to use for transactional wrapping.\n\t * Default is the bean name of this listener container, if any.\n\t * @see org.springframework.transaction.TransactionDefinition#getName()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transactionName"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "public void setTransactionName(String transactionName)",
    "source_code": "\tpublic void setTransactionName(String transactionName) {\n\t\tthis.transactionDefinition.setName(transactionName);\n\t}"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#setTransactionTimeout(transactionTimeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the transaction timeout to use for transactional wrapping, in <b>seconds</b>.\n\t * Default is none, using the transaction manager's default timeout.\n\t * @see org.springframework.transaction.TransactionDefinition#getTimeout()\n\t * @see #setReceiveTimeout\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transactionTimeout"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "void",
    "signature": "public void setTransactionTimeout(int transactionTimeout)",
    "source_code": "\tpublic void setTransactionTimeout(int transactionTimeout) {\n\t\tthis.transactionDefinition.setTimeout(transactionTimeout);\n\t}"
  },
  "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#shouldCommitAfterNoMessageReceived(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether to trigger a commit after no message has been received.\n\t * This is a good idea on any modern-day JMS provider.\n\t * @param session the current JMS Session which received no message\n\t * @return whether to call {@link #commitIfNecessary} on the given Session\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "boolean",
    "signature": "protected boolean shouldCommitAfterNoMessageReceived(Session session)",
    "source_code": "\tprotected boolean shouldCommitAfterNoMessageReceived(Session session) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.jms.listener.CACHE_AUTO": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Constant that indicates automatic choice of an appropriate caching level\n\t * (depending on the transaction management strategy).\n\t * @see #setCacheLevel\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "signature": "public int CACHE_AUTO",
    "source_code": "\tpublic static final int CACHE_AUTO = 4;",
    "type": "int"
  },
  "org.springframework.jms.listener.CACHE_CONNECTION": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Constant that indicates to cache a shared JMS {@code Connection} for each\n\t * listener thread.\n\t * @see #setCacheLevel\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "signature": "public int CACHE_CONNECTION",
    "source_code": "\tpublic static final int CACHE_CONNECTION = 1;",
    "type": "int"
  },
  "org.springframework.jms.listener.CACHE_CONSUMER": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Constant that indicates to cache a shared JMS {@code Connection}, a JMS\n\t * {@code Session}, and a JMS MessageConsumer for each listener thread.\n\t * @see #setCacheLevel\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "signature": "public int CACHE_CONSUMER",
    "source_code": "\tpublic static final int CACHE_CONSUMER = 3;",
    "type": "int"
  },
  "org.springframework.jms.listener.CACHE_NONE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Constant that indicates to cache no JMS resources at all.\n\t * @see #setCacheLevel\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "signature": "public int CACHE_NONE",
    "source_code": "\tpublic static final int CACHE_NONE = 0;",
    "type": "int"
  },
  "org.springframework.jms.listener.CACHE_SESSION": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Constant that indicates to cache a shared JMS {@code Connection} and a JMS\n\t * {@code Session} for each listener thread.\n\t * @see #setCacheLevel\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "signature": "public int CACHE_SESSION",
    "source_code": "\tpublic static final int CACHE_SESSION = 2;",
    "type": "int"
  },
  "org.springframework.jms.listener.DEFAULT_RECEIVE_TIMEOUT": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The default receive timeout: 1000 ms = 1 second.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "signature": "public long DEFAULT_RECEIVE_TIMEOUT",
    "source_code": "\tpublic static final long DEFAULT_RECEIVE_TIMEOUT = 1000;",
    "type": "long"
  },
  "org.springframework.jms.listener.DEFAULT_RECOVERY_INTERVAL": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The default recovery interval: 5000 ms = 5 seconds.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "signature": "public long DEFAULT_RECOVERY_INTERVAL",
    "source_code": "\tpublic static final long DEFAULT_RECOVERY_INTERVAL = 5000;",
    "type": "long"
  },
  "org.springframework.jms.listener.DEFAULT_THREAD_NAME_PREFIX": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Default thread name prefix: \"DefaultMessageListenerContainer-\".\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "signature": "public String DEFAULT_THREAD_NAME_PREFIX",
    "source_code": "\tpublic static final String DEFAULT_THREAD_NAME_PREFIX =",
    "type": "String"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Message listener container variant that uses plain JMS client APIs, specifically\n * a loop of {@code MessageConsumer.receive()} calls that also allow for\n * transactional reception of messages (registering them with XA transactions).\n * Designed to work in a native JMS environment as well as in a Jakarta EE environment,\n * with only minimal differences in configuration.\n *\n * <p>This is a simple but nevertheless powerful form of message listener container.\n * On startup, it obtains a fixed number of JMS Sessions to invoke the listener,\n * and optionally allows for dynamic adaptation at runtime (up to a maximum number).\n * Like {@link SimpleMessageListenerContainer}, its main advantage is its low level\n * of runtime complexity, in particular the minimal requirements on the JMS provider:\n * not even the JMS {@code ServerSessionPool} facility is required. Beyond that, it is\n * fully self-recovering in case the broker is temporarily unavailable, and allows\n * for stops/restarts as well as runtime changes to its configuration.\n *\n * <p>Actual {@code MessageListener} execution happens in asynchronous work units which are\n * created through Spring's {@link org.springframework.core.task.TaskExecutor TaskExecutor}\n * abstraction. By default, the specified number of invoker tasks will be created\n * on startup, according to the {@link #setConcurrentConsumers \"concurrentConsumers\"}\n * setting. Specify an alternative {@code TaskExecutor} to integrate with an existing\n * thread pool facility (such as a Jakarta EE server's). With a native JMS setup,\n * each of those listener threads is going to use a cached JMS {@code Session} and\n * {@code MessageConsumer} (only refreshed in case of failure), using the JMS provider's\n * resources as efficiently as possible.\n *\n * <p>Message reception and listener execution can automatically be wrapped\n * in transactions by passing a Spring\n * {@link org.springframework.transaction.PlatformTransactionManager} into the\n * {@link #setTransactionManager \"transactionManager\"} property. This will usually\n * be a {@link org.springframework.transaction.jta.JtaTransactionManager} in a\n * Jakarta EE environment, in combination with a JTA-aware JMS {@code ConnectionFactory}\n * obtained from JNDI (check your Jakarta EE server's documentation). Note that this\n * listener container will automatically reobtain all JMS handles for each transaction\n * in case an external transaction manager is specified, for compatibility with\n * all Jakarta EE servers (in particular JBoss). This non-caching behavior can be\n * overridden through the {@link #setCacheLevel \"cacheLevel\"} /\n * {@link #setCacheLevelName \"cacheLevelName\"} property, enforcing caching of\n * the {@code Connection} (or also {@code Session} and {@code MessageConsumer})\n * even if an external transaction manager is involved.\n *\n * <p>Dynamic scaling of the number of concurrent invokers can be activated\n * by specifying a {@link #setMaxConcurrentConsumers \"maxConcurrentConsumers\"}\n * value that is higher than the {@link #setConcurrentConsumers \"concurrentConsumers\"}\n * value. Since the latter's default is 1, you can also simply specify a\n * \"maxConcurrentConsumers\" of e.g. 5, which will lead to dynamic scaling up to\n * 5 concurrent consumers in case of increasing message load, as well as dynamic\n * shrinking back to the standard number of consumers once the load decreases.\n * Consider adapting the {@link #setIdleTaskExecutionLimit \"idleTaskExecutionLimit\"}\n * setting to control the lifespan of each new task, to avoid frequent scaling up\n * and down, in particular if the {@code ConnectionFactory} does not pool JMS\n * {@code Sessions} and/or the {@code TaskExecutor} does not pool threads (check\n * your configuration!). Note that dynamic scaling only really makes sense for a\n * queue in the first place; for a topic, you will typically stick with the default\n * number of 1 consumer, otherwise you'd receive the same message multiple times on\n * the same node.\n *\n * <p><b>Note: Don't use Spring's {@link org.springframework.jms.connection.CachingConnectionFactory}\n * in combination with dynamic scaling.</b> Ideally, don't use it with a message\n * listener container at all, since it is generally preferable to let the\n * listener container itself handle appropriate caching within its lifecycle.\n * Also, stopping and restarting a listener container will only work with an\n * independent, locally cached Connection - not with an externally cached one.\n *\n * <p><b>It is strongly recommended to either set {@link #setSessionTransacted\n * \"sessionTransacted\"} to \"true\" or specify an external {@link #setTransactionManager\n * \"transactionManager\"}.</b> See the {@link AbstractMessageListenerContainer}\n * javadoc for details on acknowledge modes and native transaction options, as\n * well as the {@link AbstractPollingMessageListenerContainer} javadoc for details\n * on configuring an external transaction manager. Note that for the default\n * \"AUTO_ACKNOWLEDGE\" mode, this container applies automatic message acknowledgment\n * before listener execution, with no redelivery in case of an exception.\n *\n * @author Juergen Hoeller\n * @since 2.0\n * @see #setTransactionManager\n * @see #setCacheLevel\n * @see jakarta.jms.MessageConsumer#receive(long)\n * @see SimpleMessageListenerContainer\n * @see org.springframework.jms.listener.endpoint.JmsMessageEndpointManager\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "signature": "public class DefaultMessageListenerContainer",
    "source_code": "public class DefaultMessageListenerContainer extends AbstractPollingMessageListenerContainer {\n\n\t/**\n\t * Default thread name prefix: \"DefaultMessageListenerContainer-\".\n\t */\n\tpublic static final String DEFAULT_THREAD_NAME_PREFIX =\n\t\t\tClassUtils.getShortName(DefaultMessageListenerContainer.class) + \"-\";\n\n\t/**\n\t * The default recovery interval: 5000 ms = 5 seconds.\n\t */\n\tpublic static final long DEFAULT_RECOVERY_INTERVAL = 5000;\n\n\n\t/**\n\t * Constant that indicates to cache no JMS resources at all.\n\t * @see #setCacheLevel\n\t */\n\tpublic static final int CACHE_NONE = 0;\n\n\t/**\n\t * Constant that indicates to cache a shared JMS {@code Connection} for each\n\t * listener thread.\n\t * @see #setCacheLevel\n\t */\n\tpublic static final int CACHE_CONNECTION = 1;\n\n\t/**\n\t * Constant that indicates to cache a shared JMS {@code Connection} and a JMS\n\t * {@code Session} for each listener thread.\n\t * @see #setCacheLevel\n\t */\n\tpublic static final int CACHE_SESSION = 2;\n\n\t/**\n\t * Constant that indicates to cache a shared JMS {@code Connection}, a JMS\n\t * {@code Session}, and a JMS MessageConsumer for each listener thread.\n\t * @see #setCacheLevel\n\t */\n\tpublic static final int CACHE_CONSUMER = 3;\n\n\t/**\n\t * Constant that indicates automatic choice of an appropriate caching level\n\t * (depending on the transaction management strategy).\n\t * @see #setCacheLevel\n\t */\n\tpublic static final int CACHE_AUTO = 4;\n\n\n\tprivate static final Constants constants = new Constants(DefaultMessageListenerContainer.class);\n\n\n\t@Nullable\n\tprivate Executor taskExecutor;\n\n\tprivate BackOff backOff = new FixedBackOff(DEFAULT_RECOVERY_INTERVAL, Long.MAX_VALUE);\n\n\tprivate int cacheLevel = CACHE_AUTO;\n\n\tprivate int concurrentConsumers = 1;\n\n\tprivate int maxConcurrentConsumers = 1;\n\n\tprivate int maxMessagesPerTask = Integer.MIN_VALUE;\n\n\tprivate int idleConsumerLimit = 1;\n\n\tprivate int idleTaskExecutionLimit = 1;\n\n\tprivate int idleReceivesPerTaskLimit = Integer.MIN_VALUE;\n\n\tprivate final Set<AsyncMessageListenerInvoker> scheduledInvokers = new HashSet<>();\n\n\tprivate int activeInvokerCount = 0;\n\n\tprivate int registeredWithDestination = 0;\n\n\tprivate volatile boolean recovering;\n\n\tprivate volatile boolean interrupted;\n\n\t@Nullable\n\tprivate Runnable stopCallback;\n\n\tprivate Object currentRecoveryMarker = new Object();\n\n\tprivate final Object recoveryMonitor = new Object();\n\n\n\t/**\n\t * Set the Spring {@code TaskExecutor} to use for running the listener threads.\n\t * <p>Default is a {@link org.springframework.core.task.SimpleAsyncTaskExecutor},\n\t * starting up a number of new threads, according to the specified number\n\t * of concurrent consumers.\n\t * <p>Specify an alternative {@code TaskExecutor} for integration with an existing\n\t * thread pool. Note that this really only adds value if the threads are\n\t * managed in a specific fashion, for example within a Jakarta EE environment.\n\t * A plain thread pool does not add much value, as this listener container\n\t * will occupy a number of threads for its entire lifetime.\n\t * @see #setConcurrentConsumers\n\t * @see org.springframework.core.task.SimpleAsyncTaskExecutor\n\t */\n\tpublic void setTaskExecutor(Executor taskExecutor) {\n\t\tthis.taskExecutor = taskExecutor;\n\t}\n\n\t/**\n\t * Specify the {@link BackOff} instance to use to compute the interval\n\t * between recovery attempts. If the {@link BackOffExecution} implementation\n\t * returns {@link BackOffExecution#STOP}, this listener container will not further\n\t * attempt to recover.\n\t * <p>The {@link #setRecoveryInterval(long) recovery interval} is ignored\n\t * when this property is set.\n\t * @since 4.1\n\t */\n\tpublic void setBackOff(BackOff backOff) {\n\t\tthis.backOff = backOff;\n\t}\n\n\t/**\n\t * Specify the interval between recovery attempts, in <b>milliseconds</b>.\n\t * The default is 5000 ms, that is, 5 seconds. This is a convenience method\n\t * to create a {@link FixedBackOff} with the specified interval.\n\t * <p>For more recovery options, consider specifying a {@link BackOff}\n\t * instance instead.\n\t * @see #setBackOff(BackOff)\n\t * @see #handleListenerSetupFailure\n\t */\n\tpublic void setRecoveryInterval(long recoveryInterval) {\n\t\tthis.backOff = new FixedBackOff(recoveryInterval, Long.MAX_VALUE);\n\t}\n\n\t/**\n\t * Specify the level of caching that this listener container is allowed to apply,\n\t * in the form of the name of the corresponding constant: e.g. \"CACHE_CONNECTION\".\n\t * @see #setCacheLevel\n\t */\n\tpublic void setCacheLevelName(String constantName) throws IllegalArgumentException {\n\t\tif (!constantName.startsWith(\"CACHE_\")) {\n\t\t\tthrow new IllegalArgumentException(\"Only cache constants allowed\");\n\t\t}\n\t\tsetCacheLevel(constants.asNumber(constantName).intValue());\n\t}\n\n\t/**\n\t * Specify the level of caching that this listener container is allowed to apply.\n\t * <p>Default is {@link #CACHE_NONE} if an external transaction manager has been specified\n\t * (to reobtain all resources freshly within the scope of the external transaction),\n\t * and {@link #CACHE_CONSUMER} otherwise (operating with local JMS resources).\n\t * <p>Some Jakarta EE servers only register their JMS resources with an ongoing XA\n\t * transaction in case of a freshly obtained JMS {@code Connection} and {@code Session},\n\t * which is why this listener container by default does not cache any of those.\n\t * However, depending on the rules of your server with respect to the caching\n\t * of transactional resources, consider switching this setting to at least\n\t * {@link #CACHE_CONNECTION} or {@link #CACHE_SESSION} even in conjunction with an\n\t * external transaction manager.\n\t * @see #CACHE_NONE\n\t * @see #CACHE_CONNECTION\n\t * @see #CACHE_SESSION\n\t * @see #CACHE_CONSUMER\n\t * @see #setCacheLevelName\n\t * @see #setTransactionManager\n\t */\n\tpublic void setCacheLevel(int cacheLevel) {\n\t\tthis.cacheLevel = cacheLevel;\n\t}\n\n\t/**\n\t * Return the level of caching that this listener container is allowed to apply.\n\t */\n\tpublic int getCacheLevel() {\n\t\treturn this.cacheLevel;\n\t}\n\n\n\t/**\n\t * Specify concurrency limits via a \"lower-upper\" String, e.g. \"5-10\", or a simple\n\t * upper limit String, e.g. \"10\" (the lower limit will be 1 in this case).\n\t * <p>This listener container will always hold on to the minimum number of consumers\n\t * ({@link #setConcurrentConsumers}) and will slowly scale up to the maximum number\n\t * of consumers {@link #setMaxConcurrentConsumers} in case of increasing load.\n\t */\n\t@Override\n\tpublic void setConcurrency(String concurrency) {\n\t\ttry {\n\t\t\tint separatorIndex = concurrency.indexOf('-');\n\t\t\tif (separatorIndex != -1) {\n\t\t\t\tsetConcurrentConsumers(Integer.parseInt(concurrency, 0, separatorIndex, 10));\n\t\t\t\tsetMaxConcurrentConsumers(Integer.parseInt(concurrency, separatorIndex + 1, concurrency.length(), 10));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetConcurrentConsumers(1);\n\t\t\t\tsetMaxConcurrentConsumers(Integer.parseInt(concurrency));\n\t\t\t}\n\t\t}\n\t\tcatch (NumberFormatException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid concurrency value [\" + concurrency + \"]: only \" +\n\t\t\t\t\t\"single maximum integer (e.g. \\\"5\\\") and minimum-maximum combo (e.g. \\\"3-5\\\") supported.\");\n\t\t}\n\t}\n\n\t/**\n\t * Specify the number of concurrent consumers to create. Default is 1.\n\t * <p>Specifying a higher value for this setting will increase the standard\n\t * level of scheduled concurrent consumers at runtime: This is effectively\n\t * the minimum number of concurrent consumers which will be scheduled\n\t * at any given time. This is a static setting; for dynamic scaling,\n\t * consider specifying the \"maxConcurrentConsumers\" setting instead.\n\t * <p>Raising the number of concurrent consumers is recommendable in order\n\t * to scale the consumption of messages coming in from a queue. However,\n\t * note that any ordering guarantees are lost once multiple consumers are\n\t * registered. In general, stick with 1 consumer for low-volume queues.\n\t * <p><b>Do not raise the number of concurrent consumers for a topic,\n\t * unless vendor-specific setup measures clearly allow for it.</b>\n\t * With regular setup, this would lead to concurrent consumption\n\t * of the same message, which is hardly ever desirable.\n\t * <p><b>This setting can be modified at runtime, for example through JMX.</b>\n\t * @see #setMaxConcurrentConsumers\n\t */\n\tpublic void setConcurrentConsumers(int concurrentConsumers) {\n\t\tAssert.isTrue(concurrentConsumers > 0, \"'concurrentConsumers' value must be at least 1 (one)\");\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tthis.concurrentConsumers = concurrentConsumers;\n\t\t\tif (this.maxConcurrentConsumers < concurrentConsumers) {\n\t\t\t\tthis.maxConcurrentConsumers = concurrentConsumers;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return the \"concurrentConsumer\" setting.\n\t * <p>This returns the currently configured \"concurrentConsumers\" value;\n\t * the number of currently scheduled/active consumers might differ.\n\t * @see #getScheduledConsumerCount()\n\t * @see #getActiveConsumerCount()\n\t */\n\tpublic final int getConcurrentConsumers() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\treturn this.concurrentConsumers;\n\t\t}\n\t}\n\n\t/**\n\t * Specify the maximum number of concurrent consumers to create. Default is 1.\n\t * <p>If this setting is higher than \"concurrentConsumers\", the listener container\n\t * will dynamically schedule new consumers at runtime, provided that enough\n\t * incoming messages are encountered. Once the load goes down again, the number of\n\t * consumers will be reduced to the standard level (\"concurrentConsumers\") again.\n\t * <p>Raising the number of concurrent consumers is recommendable in order\n\t * to scale the consumption of messages coming in from a queue. However,\n\t * note that any ordering guarantees are lost once multiple consumers are\n\t * registered. In general, stick with 1 consumer for low-volume queues.\n\t * <p><b>Do not raise the number of concurrent consumers for a topic,\n\t * unless vendor-specific setup measures clearly allow for it.</b>\n\t * With regular setup, this would lead to concurrent consumption\n\t * of the same message, which is hardly ever desirable.\n\t * <p><b>This setting can be modified at runtime, for example through JMX.</b>\n\t * @see #setConcurrentConsumers\n\t */\n\tpublic void setMaxConcurrentConsumers(int maxConcurrentConsumers) {\n\t\tAssert.isTrue(maxConcurrentConsumers > 0, \"'maxConcurrentConsumers' value must be at least 1 (one)\");\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tthis.maxConcurrentConsumers = Math.max(maxConcurrentConsumers, this.concurrentConsumers);\n\t\t}\n\t}\n\n\t/**\n\t * Return the \"maxConcurrentConsumer\" setting.\n\t * <p>This returns the currently configured \"maxConcurrentConsumers\" value;\n\t * the number of currently scheduled/active consumers might differ.\n\t * @see #getScheduledConsumerCount()\n\t * @see #getActiveConsumerCount()\n\t */\n\tpublic final int getMaxConcurrentConsumers() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\treturn this.maxConcurrentConsumers;\n\t\t}\n\t}\n\n\t/**\n\t * Specify the maximum number of messages to process in one task.\n\t * More concretely, this limits the number of message reception attempts\n\t * per task, which includes receive iterations that did not actually\n\t * pick up a message until they hit their timeout (see the\n\t * {@link #setReceiveTimeout \"receiveTimeout\"} property).\n\t * <p>Default is unlimited (-1) in case of a standard TaskExecutor,\n\t * reusing the original invoker threads until shutdown (at the\n\t * expense of limited dynamic scheduling).\n\t * <p>In case of a SchedulingTaskExecutor indicating a preference for\n\t * short-lived tasks, the default is 10 instead. Specify a number\n\t * of 10 to 100 messages to balance between rather long-lived and\n\t * rather short-lived tasks here.\n\t * <p>Long-lived tasks avoid frequent thread context switches through\n\t * sticking with the same thread all the way through, while short-lived\n\t * tasks allow thread pools to control the scheduling. Hence, thread\n\t * pools will usually prefer short-lived tasks.\n\t * <p><b>This setting can be modified at runtime, for example through JMX.</b>\n\t * @see #setTaskExecutor\n\t * @see #setReceiveTimeout\n\t * @see org.springframework.scheduling.SchedulingTaskExecutor#prefersShortLivedTasks()\n\t */\n\tpublic void setMaxMessagesPerTask(int maxMessagesPerTask) {\n\t\tAssert.isTrue(maxMessagesPerTask != 0, \"'maxMessagesPerTask' must not be 0\");\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tthis.maxMessagesPerTask = maxMessagesPerTask;\n\t\t}\n\t}\n\n\t/**\n\t * Return the maximum number of messages to process in one task.\n\t */\n\tpublic final int getMaxMessagesPerTask() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\treturn this.maxMessagesPerTask;\n\t\t}\n\t}\n\n\t/**\n\t * Specify the limit for the number of consumers that are allowed to be idle\n\t * at any given time.\n\t * <p>This limit is used by the {@link #scheduleNewInvokerIfAppropriate} method\n\t * to determine if a new invoker should be created. Increasing the limit causes\n\t * invokers to be created more aggressively. This can be useful to ramp up the\n\t * number of invokers faster.\n\t * <p>The default is 1, only scheduling a new invoker (which is likely to\n\t * be idle initially) if none of the existing invokers is currently idle.\n\t */\n\tpublic void setIdleConsumerLimit(int idleConsumerLimit) {\n\t\tAssert.isTrue(idleConsumerLimit > 0, \"'idleConsumerLimit' must be 1 or higher\");\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tthis.idleConsumerLimit = idleConsumerLimit;\n\t\t}\n\t}\n\n\t/**\n\t * Return the limit for the number of idle consumers.\n\t */\n\tpublic final int getIdleConsumerLimit() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\treturn this.idleConsumerLimit;\n\t\t}\n\t}\n\n\t/**\n\t * Specify the limit for idle executions of a consumer task, not having\n\t * received any message within its execution. If this limit is reached,\n\t * the task will shut down and leave receiving to other executing tasks.\n\t * <p>The default is 1, closing idle resources early once a task didn't\n\t * receive a message. This applies to dynamic scheduling only; see the\n\t * {@link #setMaxConcurrentConsumers \"maxConcurrentConsumers\"} setting.\n\t * The minimum number of consumers\n\t * (see {@link #setConcurrentConsumers \"concurrentConsumers\"})\n\t * will be kept around until shutdown in any case.\n\t * <p>Within each task execution, a number of message reception attempts\n\t * (according to the \"maxMessagesPerTask\" setting) will each wait for an incoming\n\t * message (according to the \"receiveTimeout\" setting). If all of those receive\n\t * attempts in a given task return without a message, the task is considered\n\t * idle with respect to received messages. Such a task may still be rescheduled;\n\t * however, once it reached the specified \"idleTaskExecutionLimit\", it will\n\t * shut down (in case of dynamic scaling).\n\t * <p>Raise this limit if you encounter too frequent scaling up and down.\n\t * With this limit being higher, an idle consumer will be kept around longer,\n\t * avoiding the restart of a consumer once a new load of messages comes in.\n\t * Alternatively, specify a higher \"maxMessagesPerTask\" and/or \"receiveTimeout\" value,\n\t * which will also lead to idle consumers being kept around for a longer time\n\t * (while also increasing the average execution time of each scheduled task).\n\t * <p><b>This setting can be modified at runtime, for example through JMX.</b>\n\t * @see #setMaxMessagesPerTask\n\t * @see #setReceiveTimeout\n\t */\n\tpublic void setIdleTaskExecutionLimit(int idleTaskExecutionLimit) {\n\t\tAssert.isTrue(idleTaskExecutionLimit > 0, \"'idleTaskExecutionLimit' must be 1 or higher\");\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tthis.idleTaskExecutionLimit = idleTaskExecutionLimit;\n\t\t}\n\t}\n\n\t/**\n\t * Return the limit for idle executions of a consumer task.\n\t */\n\tpublic final int getIdleTaskExecutionLimit() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\treturn this.idleTaskExecutionLimit;\n\t\t}\n\t}\n\n\t/**\n\t * Marks the consumer as 'idle' after the specified number of idle receives\n\t * have been reached. An idle receive is counted from the moment a null message\n\t * is returned by the receiver after the potential {@link #setReceiveTimeout}\n\t * elapsed. This gives the opportunity to check if the idle task count exceeds\n\t * {@link #setIdleTaskExecutionLimit} and based on that decide if the task needs\n\t * to be re-scheduled or not, saving resources that would otherwise be held.\n\t * <p>This setting differs from {@link #setMaxMessagesPerTask} where the task is\n\t * released and re-scheduled after this limit is reached, no matter if the received\n\t * messages were null or non-null messages. This setting alone can be inflexible\n\t * if one desires to have a large enough batch for each task but requires a\n\t * quick(er) release from the moment there are no more messages to process.\n\t * <p>This setting differs from {@link #setIdleTaskExecutionLimit} where this limit\n\t * decides after how many iterations of being marked as idle, a task is released.\n\t * <p>For example: If {@link #setMaxMessagesPerTask} is set to '500' and\n\t * {@code #setIdleReceivesPerTaskLimit} is set to '60' and {@link #setReceiveTimeout}\n\t * is set to '1000' and {@link #setIdleTaskExecutionLimit} is set to '1', then 500\n\t * messages per task would be processed unless there is a subsequent number of 60\n\t * idle messages received, the task would be marked as idle and released. This also\n\t * means that after the last message was processed, the task would be released after\n\t * 60 seconds as long as no new messages appear.\n\t * @since 5.3.5\n\t * @see #setMaxMessagesPerTask\n\t * @see #setReceiveTimeout\n\t */\n\tpublic void setIdleReceivesPerTaskLimit(int idleReceivesPerTaskLimit) {\n\t\tAssert.isTrue(idleReceivesPerTaskLimit != 0, \"'idleReceivesPerTaskLimit' must not be 0)\");\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tthis.idleReceivesPerTaskLimit = idleReceivesPerTaskLimit;\n\t\t}\n\t}\n\n\t/**\n\t * Return the maximum number of subsequent null messages to receive in a single task\n\t * before marking the consumer as 'idle'.\n\t * @since 5.3.5\n\t */\n\tpublic int getIdleReceivesPerTaskLimit() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\treturn this.idleReceivesPerTaskLimit;\n\t\t}\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Implementation of AbstractMessageListenerContainer's template methods\n\t//-------------------------------------------------------------------------\n\n\t@Override\n\tpublic void initialize() {\n\t\t// Adapt default cache level.\n\t\tif (this.cacheLevel == CACHE_AUTO) {\n\t\t\tthis.cacheLevel = (getTransactionManager() != null ? CACHE_NONE : CACHE_CONSUMER);\n\t\t}\n\n\t\t// Prepare taskExecutor and maxMessagesPerTask.\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tif (this.taskExecutor == null) {\n\t\t\t\tthis.taskExecutor = createDefaultTaskExecutor();\n\t\t\t}\n\t\t\telse if (this.taskExecutor instanceof SchedulingTaskExecutor ste &&\n\t\t\t\t\tste.prefersShortLivedTasks() &&\n\t\t\t\t\tthis.maxMessagesPerTask == Integer.MIN_VALUE) {\n\t\t\t\t// TaskExecutor indicated a preference for short-lived tasks. According to\n\t\t\t\t// setMaxMessagesPerTask javadoc, we'll use 10 message per task in this case\n\t\t\t\t// unless the user specified a custom value.\n\t\t\t\tthis.maxMessagesPerTask = 10;\n\t\t\t}\n\t\t}\n\n\t\t// Proceed with actual listener initialization.\n\t\tsuper.initialize();\n\t}\n\n\t/**\n\t * Creates the specified number of concurrent consumers,\n\t * in the form of a JMS Session plus associated MessageConsumer\n\t * running in a separate thread.\n\t * @see #scheduleNewInvoker\n\t * @see #setTaskExecutor\n\t */\n\t@Override\n\tprotected void doInitialize() throws JMSException {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tfor (int i = 0; i < this.concurrentConsumers; i++) {\n\t\t\t\tscheduleNewInvoker();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Destroy the registered JMS Sessions and associated MessageConsumers.\n\t */\n\t@Override\n\tprotected void doShutdown() throws JMSException {\n\t\tlogger.debug(\"Waiting for shutdown of message listener invokers\");\n\t\ttry {\n\t\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\t\tlong receiveTimeout = getReceiveTimeout();\n\t\t\t\tlong waitStartTime = System.currentTimeMillis();\n\t\t\t\tint waitCount = 0;\n\t\t\t\twhile (this.activeInvokerCount > 0) {\n\t\t\t\t\tif (waitCount > 0 && !isAcceptMessagesWhileStopping() &&\n\t\t\t\t\t\t\tSystem.currentTimeMillis() - waitStartTime >= receiveTimeout) {\n\t\t\t\t\t\t// Unexpectedly some invokers are still active after the receive timeout period\n\t\t\t\t\t\t// -> interrupt remaining receive attempts since we'd reject the messages anyway\n\t\t\t\t\t\tfor (AsyncMessageListenerInvoker scheduledInvoker : this.scheduledInvokers) {\n\t\t\t\t\t\t\tscheduledInvoker.interruptIfNecessary();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Still waiting for shutdown of \" + this.activeInvokerCount +\n\t\t\t\t\t\t\t\t\" message listener invokers (iteration \" + waitCount + \")\");\n\t\t\t\t\t}\n\t\t\t\t\t// Wait for AsyncMessageListenerInvokers to deactivate themselves...\n\t\t\t\t\tif (receiveTimeout > 0) {\n\t\t\t\t\t\tthis.lifecycleMonitor.wait(receiveTimeout);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.lifecycleMonitor.wait();\n\t\t\t\t\t}\n\t\t\t\t\twaitCount++;\n\t\t\t\t}\n\t\t\t\t// Clear remaining scheduled invokers, possibly left over as paused tasks\n\t\t\t\tfor (AsyncMessageListenerInvoker scheduledInvoker : this.scheduledInvokers) {\n\t\t\t\t\tscheduledInvoker.clearResources();\n\t\t\t\t}\n\t\t\t\tthis.scheduledInvokers.clear();\n\t\t\t}\n\t\t}\n\t\tcatch (InterruptedException ex) {\n\t\t\t// Re-interrupt current thread, to allow other threads to react.\n\t\t\tThread.currentThread().interrupt();\n\t\t}\n\t}\n\n\t/**\n\t * Overridden to reset the stop callback, if any.\n\t */\n\t@Override\n\tpublic void start() throws JmsException {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tthis.stopCallback = null;\n\t\t}\n\t\tsuper.start();\n\t}\n\n\t/**\n\t * Stop this listener container, invoking the specific callback\n\t * once all listener processing has actually stopped.\n\t * <p>Note: Further {@code stop(runnable)} calls (before processing\n\t * has actually stopped) will override the specified callback. Only the\n\t * latest specified callback will be invoked.\n\t * <p>If a subsequent {@link #start()} call restarts the listener container\n\t * before it has fully stopped, the callback will not get invoked at all.\n\t * @param callback the callback to invoke once listener processing\n\t * has fully stopped\n\t * @throws JmsException if stopping failed\n\t * @see #stop()\n\t */\n\t@Override\n\tpublic void stop(Runnable callback) throws JmsException {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tif (!isRunning() || this.stopCallback != null) {\n\t\t\t\t// Not started, already stopped, or previous stop attempt in progress\n\t\t\t\t// -> return immediately, no stop process to control anymore.\n\t\t\t\tcallback.run();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.stopCallback = callback;\n\t\t}\n\t\tstop();\n\t}\n\n\t/**\n\t * Return the number of currently scheduled consumers.\n\t * <p>This number will always be between \"concurrentConsumers\" and\n\t * \"maxConcurrentConsumers\", but might be higher than \"activeConsumerCount\"\n\t * (in case some consumers are scheduled but not executing at the moment).\n\t * @see #getConcurrentConsumers()\n\t * @see #getMaxConcurrentConsumers()\n\t * @see #getActiveConsumerCount()\n\t */\n\tpublic final int getScheduledConsumerCount() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\treturn this.scheduledInvokers.size();\n\t\t}\n\t}\n\n\t/**\n\t * Return the number of currently active consumers.\n\t * <p>This number will always be between \"concurrentConsumers\" and\n\t * \"maxConcurrentConsumers\", but might be lower than \"scheduledConsumerCount\"\n\t * (in case some consumers are scheduled but not executing at the moment).\n\t * @see #getConcurrentConsumers()\n\t * @see #getMaxConcurrentConsumers()\n\t * @see #getActiveConsumerCount()\n\t */\n\tpublic final int getActiveConsumerCount() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\treturn this.activeInvokerCount;\n\t\t}\n\t}\n\n\t/**\n\t * Return whether at least one consumer has entered a fixed registration with the\n\t * target destination. This is particularly interesting for the pub-sub case where\n\t * it might be important to have an actual consumer registered that is guaranteed\n\t * not to miss any messages that are just about to be published.\n\t * <p>This method may be polled after a {@link #start()} call, until asynchronous\n\t * registration of consumers has happened which is when the method will start returning\n\t * {@code true} &ndash; provided that the listener container ever actually establishes\n\t * a fixed registration. It will then keep returning {@code true} until shutdown,\n\t * since the container will hold on to at least one consumer registration thereafter.\n\t * <p>Note that a listener container is not bound to having a fixed registration in\n\t * the first place. It may also keep recreating consumers for every invoker execution.\n\t * This particularly depends on the {@link #setCacheLevel cache level} setting:\n\t * only {@link #CACHE_CONSUMER} will lead to a fixed registration.\n\t */\n\tpublic boolean isRegisteredWithDestination() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\treturn (this.registeredWithDestination > 0);\n\t\t}\n\t}\n\n\n\t/**\n\t * Create a default TaskExecutor. Called if no explicit TaskExecutor has been specified.\n\t * <p>The default implementation builds a {@link org.springframework.core.task.SimpleAsyncTaskExecutor}\n\t * with the specified bean name (or the class name, if no bean name specified) as thread name prefix.\n\t * @see org.springframework.core.task.SimpleAsyncTaskExecutor#SimpleAsyncTaskExecutor(String)\n\t */\n\tprotected TaskExecutor createDefaultTaskExecutor() {\n\t\tString beanName = getBeanName();\n\t\tString threadNamePrefix = (beanName != null ? beanName + \"-\" : DEFAULT_THREAD_NAME_PREFIX);\n\t\treturn new SimpleAsyncTaskExecutor(threadNamePrefix);\n\t}\n\n\t/**\n\t * Schedule a new invoker, increasing the total number of scheduled\n\t * invokers for this listener container.\n\t */\n\tprivate void scheduleNewInvoker() {\n\t\tAsyncMessageListenerInvoker invoker = new AsyncMessageListenerInvoker();\n\t\tif (rescheduleTaskIfNecessary(invoker)) {\n\t\t\t// This should always be true, since we're only calling this when active.\n\t\t\tthis.scheduledInvokers.add(invoker);\n\t\t}\n\t}\n\n\t/**\n\t * Use a shared JMS Connection depending on the \"cacheLevel\" setting.\n\t * @see #setCacheLevel\n\t * @see #CACHE_CONNECTION\n\t */\n\t@Override\n\tprotected final boolean sharedConnectionEnabled() {\n\t\treturn (getCacheLevel() >= CACHE_CONNECTION);\n\t}\n\n\t/**\n\t * Re-executes the given task via this listener container's TaskExecutor.\n\t * @see #setTaskExecutor\n\t */\n\t@Override\n\tprotected void doRescheduleTask(Object task) {\n\t\tAssert.state(this.taskExecutor != null, \"No TaskExecutor available\");\n\t\tthis.taskExecutor.execute((Runnable) task);\n\t}\n\n\t/**\n\t * Tries scheduling a new invoker, since we know messages are coming in...\n\t * @see #scheduleNewInvokerIfAppropriate()\n\t */\n\t@Override\n\tprotected void messageReceived(Object invoker, Session session) {\n\t\t((AsyncMessageListenerInvoker) invoker).setIdle(false);\n\t\tscheduleNewInvokerIfAppropriate();\n\t}\n\n\t/**\n\t * Marks the affected invoker as idle.\n\t */\n\t@Override\n\tprotected void noMessageReceived(Object invoker, Session session) {\n\t\t((AsyncMessageListenerInvoker) invoker).setIdle(true);\n\t}\n\n\t/**\n\t * Schedule a new invoker, increasing the total number of scheduled\n\t * invokers for this listener container, but only if the specified\n\t * \"maxConcurrentConsumers\" limit has not been reached yet, and only\n\t * if the specified \"idleConsumerLimit\" has not been reached either.\n\t * <p>Called once a message has been received, in order to scale up while\n\t * processing the message in the invoker that originally received it.\n\t * @see #setTaskExecutor\n\t * @see #getMaxConcurrentConsumers()\n\t * @see #getIdleConsumerLimit()\n\t */\n\tprotected void scheduleNewInvokerIfAppropriate() {\n\t\tif (isRunning()) {\n\t\t\tresumePausedTasks();\n\t\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\t\tif (this.scheduledInvokers.size() < this.maxConcurrentConsumers &&\n\t\t\t\t\t\tgetIdleInvokerCount() < this.idleConsumerLimit) {\n\t\t\t\t\tscheduleNewInvoker();\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Raised scheduled invoker count: \" + this.scheduledInvokers.size());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether the current invoker should be rescheduled,\n\t * given that it might not have received a message in a while.\n\t * @param idleTaskExecutionCount the number of idle executions\n\t * that this invoker task has already accumulated (in a row)\n\t */\n\tprivate boolean shouldRescheduleInvoker(int idleTaskExecutionCount) {\n\t\tboolean superfluous =\n\t\t\t\t(idleTaskExecutionCount >= this.idleTaskExecutionLimit && getIdleInvokerCount() > 1);\n\t\treturn (this.scheduledInvokers.size() <=\n\t\t\t\t(superfluous ? this.concurrentConsumers : this.maxConcurrentConsumers));\n\t}\n\n\t/**\n\t * Determine whether this listener container currently has more\n\t * than one idle instance among its scheduled invokers.\n\t */\n\tprivate int getIdleInvokerCount() {\n\t\tint count = 0;\n\t\tfor (AsyncMessageListenerInvoker invoker : this.scheduledInvokers) {\n\t\t\tif (invoker.isIdle()) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\n\t/**\n\t * Overridden to accept a failure in the initial setup - leaving it up to the\n\t * asynchronous invokers to establish the shared Connection on first access.\n\t * @see #refreshConnectionUntilSuccessful()\n\t */\n\t@Override\n\tprotected void establishSharedConnection() {\n\t\ttry {\n\t\t\tsuper.establishSharedConnection();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (ex instanceof JMSException jmsException) {\n\t\t\t\tinvokeExceptionListener(jmsException);\n\t\t\t}\n\t\t\tlogger.debug(\"Could not establish shared JMS Connection - \" +\n\t\t\t\t\t\"leaving it up to asynchronous invokers to establish a Connection as soon as possible\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * This implementation proceeds even after an exception thrown from\n\t * {@code Connection.start()}, relying on listeners to perform\n\t * appropriate recovery.\n\t */\n\t@Override\n\tprotected void startSharedConnection() {\n\t\ttry {\n\t\t\tsuper.startSharedConnection();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tlogger.debug(\"Connection start failed - relying on listeners to perform recovery\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * This implementation proceeds even after an exception thrown from\n\t * {@code Connection.stop()}, relying on listeners to perform\n\t * appropriate recovery after a restart.\n\t */\n\t@Override\n\tprotected void stopSharedConnection() {\n\t\ttry {\n\t\t\tsuper.stopSharedConnection();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tlogger.debug(\"Connection stop failed - relying on listeners to perform recovery after restart\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Handle the given exception that arose during setup of a listener.\n\t * Called for every such exception in every concurrent listener.\n\t * <p>The default implementation logs the exception at warn level\n\t * if not recovered yet, and at debug level if already recovered.\n\t * Can be overridden in subclasses.\n\t * @param ex the exception to handle\n\t * @param alreadyRecovered whether a previously executing listener\n\t * already recovered from the present listener setup failure\n\t * (this usually indicates a follow-up failure than can be ignored\n\t * other than for debug log purposes)\n\t * @see #recoverAfterListenerSetupFailure()\n\t */\n\tprotected void handleListenerSetupFailure(Throwable ex, boolean alreadyRecovered) {\n\t\tif (ex instanceof JMSException jmsException) {\n\t\t\tinvokeExceptionListener(jmsException);\n\t\t}\n\t\tif (ex instanceof SharedConnectionNotInitializedException) {\n\t\t\tif (!alreadyRecovered) {\n\t\t\t\tlogger.debug(\"JMS message listener invoker needs to establish shared Connection\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Recovery during active operation..\n\t\t\tif (alreadyRecovered) {\n\t\t\t\tlogger.debug(\"Setup of JMS message listener invoker failed - already recovered by other invoker\", ex);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tStringBuilder msg = new StringBuilder();\n\t\t\t\tmsg.append(\"Setup of JMS message listener invoker failed for destination '\");\n\t\t\t\tmsg.append(getDestinationDescription()).append(\"' - trying to recover. Cause: \");\n\t\t\t\tmsg.append(ex instanceof JMSException jmsException ? JmsUtils.buildExceptionMessage(jmsException) :\n\t\t\t\t\t\tex.getMessage());\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.warn(msg, ex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.warn(msg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Recover this listener container after a listener failed to set itself up,\n\t * for example re-establishing the underlying Connection.\n\t * <p>The default implementation delegates to DefaultMessageListenerContainer's\n\t * recovery-capable {@link #refreshConnectionUntilSuccessful()} method, which will\n\t * try to re-establish a Connection to the JMS provider both for the shared\n\t * and the non-shared Connection case.\n\t * @see #refreshConnectionUntilSuccessful()\n\t * @see #refreshDestination()\n\t */\n\tprotected void recoverAfterListenerSetupFailure() {\n\t\tthis.recovering = true;\n\t\ttry {\n\t\t\trefreshConnectionUntilSuccessful();\n\t\t\trefreshDestination();\n\t\t}\n\t\tfinally {\n\t\t\tthis.recovering = false;\n\t\t\tthis.interrupted = false;\n\t\t}\n\t}\n\n\t/**\n\t * Refresh the underlying Connection, not returning before an attempt has been\n\t * successful. Called in case of a shared Connection as well as without shared\n\t * Connection, so either needs to operate on the shared Connection or on a\n\t * temporary Connection that just gets established for validation purposes.\n\t * <p>The default implementation retries until it successfully established a\n\t * Connection, for as long as this message listener container is running.\n\t * Applies the specified recovery interval between retries.\n\t * @see #setRecoveryInterval\n\t * @see #start()\n\t * @see #stop()\n\t */\n\tprotected void refreshConnectionUntilSuccessful() {\n\t\tBackOffExecution execution = this.backOff.start();\n\t\twhile (isRunning()) {\n\t\t\ttry {\n\t\t\t\tif (sharedConnectionEnabled()) {\n\t\t\t\t\trefreshSharedConnection();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tConnection con = createConnection();\n\t\t\t\t\tJmsUtils.closeConnection(con);\n\t\t\t\t}\n\t\t\t\tlogger.debug(\"Successfully refreshed JMS Connection\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (ex instanceof JMSException jmsException) {\n\t\t\t\t\tinvokeExceptionListener(jmsException);\n\t\t\t\t}\n\t\t\t\tStringBuilder msg = new StringBuilder();\n\t\t\t\tmsg.append(\"Could not refresh JMS Connection for destination '\");\n\t\t\t\tmsg.append(getDestinationDescription()).append(\"' - retrying using \");\n\t\t\t\tmsg.append(execution).append(\". Cause: \");\n\t\t\t\tmsg.append(ex instanceof JMSException jmsException ? JmsUtils.buildExceptionMessage(jmsException) :\n\t\t\t\t\t\tex.getMessage());\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.error(msg, ex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.error(msg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!applyBackOffTime(execution)) {\n\t\t\t\tlogger.error(\"Stopping container for destination '\" + getDestinationDescription() +\n\t\t\t\t\t\t\"': back-off policy does not allow for further attempts.\");\n\t\t\t\tstop();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Refresh the JMS destination that this listener container operates on.\n\t * <p>Called after listener setup failure, assuming that a cached Destination\n\t * object might have become invalid (a typical case on WebLogic JMS).\n\t * <p>The default implementation removes the destination from a\n\t * DestinationResolver's cache, in case of a CachingDestinationResolver.\n\t * @see #setDestinationName\n\t * @see org.springframework.jms.support.destination.CachingDestinationResolver\n\t */\n\tprotected void refreshDestination() {\n\t\tString destName = getDestinationName();\n\t\tif (destName != null) {\n\t\t\tDestinationResolver destResolver = getDestinationResolver();\n\t\t\tif (destResolver instanceof CachingDestinationResolver cachingResolver) {\n\t\t\t\tcachingResolver.removeFromCache(destName);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Apply the next back-off time using the specified {@link BackOffExecution}.\n\t * <p>Return {@code true} if the back-off period has been applied and a new\n\t * attempt to recover should be made, {@code false} if no further attempt\n\t * should be made.\n\t * @since 4.1\n\t */\n\tprotected boolean applyBackOffTime(BackOffExecution execution) {\n\t\tif (this.recovering && this.interrupted) {\n\t\t\t// Interrupted right before and still failing... give up.\n\t\t\treturn false;\n\t\t}\n\t\tlong interval = execution.nextBackOff();\n\t\tif (interval == BackOffExecution.STOP) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\t\t\tthis.lifecycleMonitor.wait(interval);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (InterruptedException interEx) {\n\t\t\t\t// Re-interrupt current thread, to allow other threads to react.\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\tif (this.recovering) {\n\t\t\t\t\tthis.interrupted = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Return whether this listener container is currently in a recovery attempt.\n\t * <p>May be used to detect recovery phases but also the end of a recovery phase,\n\t * with {@code isRecovering()} switching to {@code false} after having been found\n\t * to return {@code true} before.\n\t * @see #recoverAfterListenerSetupFailure()\n\t */\n\tpublic final boolean isRecovering() {\n\t\treturn this.recovering;\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Inner classes used as internal adapters\n\t//-------------------------------------------------------------------------\n\n\t/**\n\t * Runnable that performs looped {@code MessageConsumer.receive()} calls.\n\t */\n\tprivate class AsyncMessageListenerInvoker implements SchedulingAwareRunnable {\n\n\t\t@Nullable\n\t\tprivate Session session;\n\n\t\t@Nullable\n\t\tprivate MessageConsumer consumer;\n\n\t\t@Nullable\n\t\tprivate Object lastRecoveryMarker;\n\n\t\tprivate boolean lastMessageSucceeded;\n\n\t\tprivate int idleTaskExecutionCount = 0;\n\n\t\tprivate volatile boolean idle = true;\n\n\t\t@Nullable\n\t\tprivate volatile Thread currentReceiveThread;\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tsynchronized (lifecycleMonitor) {\n\t\t\t\tactiveInvokerCount++;\n\t\t\t\tlifecycleMonitor.notifyAll();\n\t\t\t}\n\t\t\tboolean messageReceived = false;\n\t\t\ttry {\n\t\t\t\tint messageLimit = maxMessagesPerTask;\n\t\t\t\tint idleLimit = idleReceivesPerTaskLimit;\n\t\t\t\tif (messageLimit < 0 && idleLimit < 0) {\n\t\t\t\t\tmessageReceived = executeOngoingLoop();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint messageCount = 0;\n\t\t\t\t\tint idleCount = 0;\n\t\t\t\t\twhile (isRunning() && (messageLimit < 0 || messageCount < messageLimit) &&\n\t\t\t\t\t\t\t(idleLimit < 0 || idleCount < idleLimit)) {\n\t\t\t\t\t\tboolean currentReceived = invokeListener();\n\t\t\t\t\t\tmessageReceived |= currentReceived;\n\t\t\t\t\t\tmessageCount++;\n\t\t\t\t\t\tidleCount = (currentReceived ? 0 : idleCount + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tclearResources();\n\t\t\t\tif (!this.lastMessageSucceeded) {\n\t\t\t\t\t// We failed more than once in a row or on startup -\n\t\t\t\t\t// wait before first recovery attempt.\n\t\t\t\t\twaitBeforeRecoveryAttempt();\n\t\t\t\t}\n\t\t\t\tthis.lastMessageSucceeded = false;\n\t\t\t\tboolean alreadyRecovered = false;\n\t\t\t\tsynchronized (recoveryMonitor) {\n\t\t\t\t\tif (this.lastRecoveryMarker == currentRecoveryMarker) {\n\t\t\t\t\t\thandleListenerSetupFailure(ex, false);\n\t\t\t\t\t\trecoverAfterListenerSetupFailure();\n\t\t\t\t\t\tcurrentRecoveryMarker = new Object();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\talreadyRecovered = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (alreadyRecovered) {\n\t\t\t\t\thandleListenerSetupFailure(ex, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tsynchronized (lifecycleMonitor) {\n\t\t\t\t\tdecreaseActiveInvokerCount();\n\t\t\t\t\tlifecycleMonitor.notifyAll();\n\t\t\t\t}\n\t\t\t\tif (!messageReceived) {\n\t\t\t\t\tthis.idleTaskExecutionCount++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.idleTaskExecutionCount = 0;\n\t\t\t\t}\n\t\t\t\tsynchronized (lifecycleMonitor) {\n\t\t\t\t\tif (!shouldRescheduleInvoker(this.idleTaskExecutionCount) || !rescheduleTaskIfNecessary(this)) {\n\t\t\t\t\t\t// We're shutting down completely.\n\t\t\t\t\t\tscheduledInvokers.remove(this);\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Lowered scheduled invoker count: \" + scheduledInvokers.size());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlifecycleMonitor.notifyAll();\n\t\t\t\t\t\tclearResources();\n\t\t\t\t\t}\n\t\t\t\t\telse if (isRunning()) {\n\t\t\t\t\t\tint nonPausedConsumers = getScheduledConsumerCount() - getPausedTaskCount();\n\t\t\t\t\t\tif (nonPausedConsumers < 1) {\n\t\t\t\t\t\t\tlogger.error(\"All scheduled consumers have been paused, probably due to tasks having been rejected. \" +\n\t\t\t\t\t\t\t\t\t\"Check your thread pool configuration! Manual recovery necessary through a start() call.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (nonPausedConsumers < getConcurrentConsumers()) {\n\t\t\t\t\t\t\tlogger.warn(\"Number of scheduled consumers has dropped below concurrentConsumers limit, probably \" +\n\t\t\t\t\t\t\t\t\t\"due to tasks having been rejected. Check your thread pool configuration! Automatic recovery \" +\n\t\t\t\t\t\t\t\t\t\"to be triggered by remaining consumers.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean executeOngoingLoop() throws JMSException {\n\t\t\tboolean messageReceived = false;\n\t\t\tboolean active = true;\n\t\t\twhile (active) {\n\t\t\t\tsynchronized (lifecycleMonitor) {\n\t\t\t\t\tboolean interrupted = false;\n\t\t\t\t\tboolean wasWaiting = false;\n\t\t\t\t\twhile ((active = isActive()) && !isRunning()) {\n\t\t\t\t\t\tif (interrupted) {\n\t\t\t\t\t\t\tthrow new IllegalStateException(\"Thread was interrupted while waiting for \" +\n\t\t\t\t\t\t\t\t\t\"a restart of the listener container, but container is still stopped\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!wasWaiting) {\n\t\t\t\t\t\t\tdecreaseActiveInvokerCount();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twasWaiting = true;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlifecycleMonitor.wait();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (InterruptedException ex) {\n\t\t\t\t\t\t\t// Re-interrupt current thread, to allow other threads to react.\n\t\t\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t\t\t\tinterrupted = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (wasWaiting) {\n\t\t\t\t\t\tactiveInvokerCount++;\n\t\t\t\t\t}\n\t\t\t\t\tif (scheduledInvokers.size() > maxConcurrentConsumers) {\n\t\t\t\t\t\tactive = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (active) {\n\t\t\t\t\tmessageReceived = (invokeListener() || messageReceived);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn messageReceived;\n\t\t}\n\n\t\tprivate boolean invokeListener() throws JMSException {\n\t\t\tthis.currentReceiveThread = Thread.currentThread();\n\t\t\ttry {\n\t\t\t\tinitResourcesIfNecessary();\n\t\t\t\tboolean messageReceived = receiveAndExecute(this, this.session, this.consumer);\n\t\t\t\tthis.lastMessageSucceeded = true;\n\t\t\t\treturn messageReceived;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.currentReceiveThread = null;\n\t\t\t}\n\t\t}\n\n\t\tprivate void decreaseActiveInvokerCount() {\n\t\t\tactiveInvokerCount--;\n\t\t\tif (stopCallback != null && activeInvokerCount == 0) {\n\t\t\t\tstopCallback.run();\n\t\t\t\tstopCallback = null;\n\t\t\t}\n\t\t}\n\n\t\tprivate void initResourcesIfNecessary() throws JMSException {\n\t\t\tif (getCacheLevel() <= CACHE_CONNECTION) {\n\t\t\t\tupdateRecoveryMarker();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this.session == null && getCacheLevel() >= CACHE_SESSION) {\n\t\t\t\t\tupdateRecoveryMarker();\n\t\t\t\t\tthis.session = createSession(getSharedConnection());\n\t\t\t\t}\n\t\t\t\tif (this.consumer == null && getCacheLevel() >= CACHE_CONSUMER) {\n\t\t\t\t\tthis.consumer = createListenerConsumer(this.session);\n\t\t\t\t\tsynchronized (lifecycleMonitor) {\n\t\t\t\t\t\tregisteredWithDestination++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void updateRecoveryMarker() {\n\t\t\tsynchronized (recoveryMonitor) {\n\t\t\t\tthis.lastRecoveryMarker = currentRecoveryMarker;\n\t\t\t}\n\t\t}\n\n\t\tprivate void interruptIfNecessary() {\n\t\t\tThread currentReceiveThread = this.currentReceiveThread;\n\t\t\tif (currentReceiveThread != null && !currentReceiveThread.isInterrupted()) {\n\t\t\t\tcurrentReceiveThread.interrupt();\n\t\t\t}\n\t\t}\n\n\t\tprivate void clearResources() {\n\t\t\tif (sharedConnectionEnabled()) {\n\t\t\t\tsynchronized (sharedConnectionMonitor) {\n\t\t\t\t\tJmsUtils.closeMessageConsumer(this.consumer);\n\t\t\t\t\tJmsUtils.closeSession(this.session);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tJmsUtils.closeMessageConsumer(this.consumer);\n\t\t\t\tJmsUtils.closeSession(this.session);\n\t\t\t}\n\t\t\tif (this.consumer != null) {\n\t\t\t\tsynchronized (lifecycleMonitor) {\n\t\t\t\t\tregisteredWithDestination--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.consumer = null;\n\t\t\tthis.session = null;\n\t\t}\n\n\t\t/**\n\t\t * Apply the back-off time once. In a regular scenario, the back-off is only applied if we\n\t\t * failed to recover with the broker. This additional wait period avoids a burst retry\n\t\t * scenario when the broker is actually up but something else if failing (i.e. listener\n\t\t * specific).\n\t\t */\n\t\tprivate void waitBeforeRecoveryAttempt() {\n\t\t\tBackOffExecution execution = DefaultMessageListenerContainer.this.backOff.start();\n\t\t\tapplyBackOffTime(execution);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isLongLived() {\n\t\t\treturn (maxMessagesPerTask < 0);\n\t\t}\n\n\t\tpublic void setIdle(boolean idle) {\n\t\t\tthis.idle = idle;\n\t\t}\n\n\t\tpublic boolean isIdle() {\n\t\t\treturn this.idle;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#applyBackOffTime(execution)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the next back-off time using the specified {@link BackOffExecution}.\n\t * <p>Return {@code true} if the back-off period has been applied and a new\n\t * attempt to recover should be made, {@code false} if no further attempt\n\t * should be made.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "execution"
    ],
    "position": {
      "column": 1,
      "line": 1044
    },
    "return": "boolean",
    "signature": "protected boolean applyBackOffTime(BackOffExecution execution)",
    "source_code": "\tprotected boolean applyBackOffTime(BackOffExecution execution) {\n\t\tif (this.recovering && this.interrupted) {\n\t\t\t// Interrupted right before and still failing... give up.\n\t\t\treturn false;\n\t\t}\n\t\tlong interval = execution.nextBackOff();\n\t\tif (interval == BackOffExecution.STOP) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\t\t\tthis.lifecycleMonitor.wait(interval);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (InterruptedException interEx) {\n\t\t\t\t// Re-interrupt current thread, to allow other threads to react.\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\tif (this.recovering) {\n\t\t\t\t\tthis.interrupted = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#createDefaultTaskExecutor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a default TaskExecutor. Called if no explicit TaskExecutor has been specified.\n\t * <p>The default implementation builds a {@link org.springframework.core.task.SimpleAsyncTaskExecutor}\n\t * with the specified bean name (or the class name, if no bean name specified) as thread name prefix.\n\t * @see org.springframework.core.task.SimpleAsyncTaskExecutor#SimpleAsyncTaskExecutor(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 743
    },
    "return": "TaskExecutor",
    "signature": "protected TaskExecutor createDefaultTaskExecutor()",
    "source_code": "\tprotected TaskExecutor createDefaultTaskExecutor() {\n\t\tString beanName = getBeanName();\n\t\tString threadNamePrefix = (beanName != null ? beanName + \"-\" : DEFAULT_THREAD_NAME_PREFIX);\n\t\treturn new SimpleAsyncTaskExecutor(threadNamePrefix);\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#doInitialize()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Creates the specified number of concurrent consumers,\n\t * in the form of a JMS Session plus associated MessageConsumer\n\t * running in a separate thread.\n\t * @see #scheduleNewInvoker\n\t * @see #setTaskExecutor\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 593
    },
    "return": "void",
    "signature": "protected void doInitialize()",
    "source_code": "\tprotected void doInitialize() throws JMSException {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tfor (int i = 0; i < this.concurrentConsumers; i++) {\n\t\t\t\tscheduleNewInvoker();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#doRescheduleTask(task)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Re-executes the given task via this listener container's TaskExecutor.\n\t * @see #setTaskExecutor\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 776
    },
    "return": "void",
    "signature": "protected void doRescheduleTask(Object task)",
    "source_code": "\tprotected void doRescheduleTask(Object task) {\n\t\tAssert.state(this.taskExecutor != null, \"No TaskExecutor available\");\n\t\tthis.taskExecutor.execute((Runnable) task);\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#doShutdown()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Destroy the registered JMS Sessions and associated MessageConsumers.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 605
    },
    "return": "void",
    "signature": "protected void doShutdown()",
    "source_code": "\tprotected void doShutdown() throws JMSException {\n\t\tlogger.debug(\"Waiting for shutdown of message listener invokers\");\n\t\ttry {\n\t\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\t\tlong receiveTimeout = getReceiveTimeout();\n\t\t\t\tlong waitStartTime = System.currentTimeMillis();\n\t\t\t\tint waitCount = 0;\n\t\t\t\twhile (this.activeInvokerCount > 0) {\n\t\t\t\t\tif (waitCount > 0 && !isAcceptMessagesWhileStopping() &&\n\t\t\t\t\t\t\tSystem.currentTimeMillis() - waitStartTime >= receiveTimeout) {\n\t\t\t\t\t\t// Unexpectedly some invokers are still active after the receive timeout period\n\t\t\t\t\t\t// -> interrupt remaining receive attempts since we'd reject the messages anyway\n\t\t\t\t\t\tfor (AsyncMessageListenerInvoker scheduledInvoker : this.scheduledInvokers) {\n\t\t\t\t\t\t\tscheduledInvoker.interruptIfNecessary();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Still waiting for shutdown of \" + this.activeInvokerCount +\n\t\t\t\t\t\t\t\t\" message listener invokers (iteration \" + waitCount + \")\");\n\t\t\t\t\t}\n\t\t\t\t\t// Wait for AsyncMessageListenerInvokers to deactivate themselves...\n\t\t\t\t\tif (receiveTimeout > 0) {\n\t\t\t\t\t\tthis.lifecycleMonitor.wait(receiveTimeout);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.lifecycleMonitor.wait();\n\t\t\t\t\t}\n\t\t\t\t\twaitCount++;\n\t\t\t\t}\n\t\t\t\t// Clear remaining scheduled invokers, possibly left over as paused tasks\n\t\t\t\tfor (AsyncMessageListenerInvoker scheduledInvoker : this.scheduledInvokers) {\n\t\t\t\t\tscheduledInvoker.clearResources();\n\t\t\t\t}\n\t\t\t\tthis.scheduledInvokers.clear();\n\t\t\t}\n\t\t}\n\t\tcatch (InterruptedException ex) {\n\t\t\t// Re-interrupt current thread, to allow other threads to react.\n\t\t\tThread.currentThread().interrupt();\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#establishSharedConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Overridden to accept a failure in the initial setup - leaving it up to the\n\t * asynchronous invokers to establish the shared Connection on first access.\n\t * @see #refreshConnectionUntilSuccessful()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 859
    },
    "return": "void",
    "signature": "protected void establishSharedConnection()",
    "source_code": "\tprotected void establishSharedConnection() {\n\t\ttry {\n\t\t\tsuper.establishSharedConnection();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (ex instanceof JMSException jmsException) {\n\t\t\t\tinvokeExceptionListener(jmsException);\n\t\t\t}\n\t\t\tlogger.debug(\"Could not establish shared JMS Connection - \" +\n\t\t\t\t\t\"leaving it up to asynchronous invokers to establish a Connection as soon as possible\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#getActiveConsumerCount()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the number of currently active consumers.\n\t * <p>This number will always be between \"concurrentConsumers\" and\n\t * \"maxConcurrentConsumers\", but might be lower than \"scheduledConsumerCount\"\n\t * (in case some consumers are scheduled but not executing at the moment).\n\t * @see #getConcurrentConsumers()\n\t * @see #getMaxConcurrentConsumers()\n\t * @see #getActiveConsumerCount()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 709
    },
    "return": "int",
    "signature": "public int getActiveConsumerCount()",
    "source_code": "\tpublic final int getActiveConsumerCount() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\treturn this.activeInvokerCount;\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#getCacheLevel()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the level of caching that this listener container is allowed to apply.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "int",
    "signature": "public int getCacheLevel()",
    "source_code": "\tpublic int getCacheLevel() {\n\t\treturn this.cacheLevel;\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#getConcurrentConsumers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the \"concurrentConsumer\" setting.\n\t * <p>This returns the currently configured \"concurrentConsumers\" value;\n\t * the number of currently scheduled/active consumers might differ.\n\t * @see #getScheduledConsumerCount()\n\t * @see #getActiveConsumerCount()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 361
    },
    "return": "int",
    "signature": "public int getConcurrentConsumers()",
    "source_code": "\tpublic final int getConcurrentConsumers() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\treturn this.concurrentConsumers;\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#getIdleConsumerLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the limit for the number of idle consumers.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 462
    },
    "return": "int",
    "signature": "public int getIdleConsumerLimit()",
    "source_code": "\tpublic final int getIdleConsumerLimit() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\treturn this.idleConsumerLimit;\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#getIdleReceivesPerTaskLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the maximum number of subsequent null messages to receive in a single task\n\t * before marking the consumer as 'idle'.\n\t * @since 5.3.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 548
    },
    "return": "int",
    "signature": "public int getIdleReceivesPerTaskLimit()",
    "source_code": "\tpublic int getIdleReceivesPerTaskLimit() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\treturn this.idleReceivesPerTaskLimit;\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#getIdleTaskExecutionLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the limit for idle executions of a consumer task.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 505
    },
    "return": "int",
    "signature": "public int getIdleTaskExecutionLimit()",
    "source_code": "\tpublic final int getIdleTaskExecutionLimit() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\treturn this.idleTaskExecutionLimit;\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#getMaxConcurrentConsumers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the \"maxConcurrentConsumer\" setting.\n\t * <p>This returns the currently configured \"maxConcurrentConsumers\" value;\n\t * the number of currently scheduled/active consumers might differ.\n\t * @see #getScheduledConsumerCount()\n\t * @see #getActiveConsumerCount()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "int",
    "signature": "public int getMaxConcurrentConsumers()",
    "source_code": "\tpublic final int getMaxConcurrentConsumers() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\treturn this.maxConcurrentConsumers;\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#getMaxMessagesPerTask()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the maximum number of messages to process in one task.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "int",
    "signature": "public int getMaxMessagesPerTask()",
    "source_code": "\tpublic final int getMaxMessagesPerTask() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\treturn this.maxMessagesPerTask;\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#getScheduledConsumerCount()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the number of currently scheduled consumers.\n\t * <p>This number will always be between \"concurrentConsumers\" and\n\t * \"maxConcurrentConsumers\", but might be higher than \"activeConsumerCount\"\n\t * (in case some consumers are scheduled but not executing at the moment).\n\t * @see #getConcurrentConsumers()\n\t * @see #getMaxConcurrentConsumers()\n\t * @see #getActiveConsumerCount()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 694
    },
    "return": "int",
    "signature": "public int getScheduledConsumerCount()",
    "source_code": "\tpublic final int getScheduledConsumerCount() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\treturn this.scheduledInvokers.size();\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#handleListenerSetupFailure(ex,alreadyRecovered)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the given exception that arose during setup of a listener.\n\t * Called for every such exception in every concurrent listener.\n\t * <p>The default implementation logs the exception at warn level\n\t * if not recovered yet, and at debug level if already recovered.\n\t * Can be overridden in subclasses.\n\t * @param ex the exception to handle\n\t * @param alreadyRecovered whether a previously executing listener\n\t * already recovered from the present listener setup failure\n\t * (this usually indicates a follow-up failure than can be ignored\n\t * other than for debug log purposes)\n\t * @see #recoverAfterListenerSetupFailure()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "alreadyRecovered"
    ],
    "position": {
      "column": 1,
      "line": 915
    },
    "return": "void",
    "signature": "protected void handleListenerSetupFailure(Throwable ex, boolean alreadyRecovered)",
    "source_code": "\tprotected void handleListenerSetupFailure(Throwable ex, boolean alreadyRecovered) {\n\t\tif (ex instanceof JMSException jmsException) {\n\t\t\tinvokeExceptionListener(jmsException);\n\t\t}\n\t\tif (ex instanceof SharedConnectionNotInitializedException) {\n\t\t\tif (!alreadyRecovered) {\n\t\t\t\tlogger.debug(\"JMS message listener invoker needs to establish shared Connection\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Recovery during active operation..\n\t\t\tif (alreadyRecovered) {\n\t\t\t\tlogger.debug(\"Setup of JMS message listener invoker failed - already recovered by other invoker\", ex);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tStringBuilder msg = new StringBuilder();\n\t\t\t\tmsg.append(\"Setup of JMS message listener invoker failed for destination '\");\n\t\t\t\tmsg.append(getDestinationDescription()).append(\"' - trying to recover. Cause: \");\n\t\t\t\tmsg.append(ex instanceof JMSException jmsException ? JmsUtils.buildExceptionMessage(jmsException) :\n\t\t\t\t\t\tex.getMessage());\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.warn(msg, ex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.warn(msg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#initialize()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 560
    },
    "return": "void",
    "signature": "public void initialize()",
    "source_code": "\tpublic void initialize() {\n\t\t// Adapt default cache level.\n\t\tif (this.cacheLevel == CACHE_AUTO) {\n\t\t\tthis.cacheLevel = (getTransactionManager() != null ? CACHE_NONE : CACHE_CONSUMER);\n\t\t}\n\n\t\t// Prepare taskExecutor and maxMessagesPerTask.\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tif (this.taskExecutor == null) {\n\t\t\t\tthis.taskExecutor = createDefaultTaskExecutor();\n\t\t\t}\n\t\t\telse if (this.taskExecutor instanceof SchedulingTaskExecutor ste &&\n\t\t\t\t\tste.prefersShortLivedTasks() &&\n\t\t\t\t\tthis.maxMessagesPerTask == Integer.MIN_VALUE) {\n\t\t\t\t// TaskExecutor indicated a preference for short-lived tasks. According to\n\t\t\t\t// setMaxMessagesPerTask javadoc, we'll use 10 message per task in this case\n\t\t\t\t// unless the user specified a custom value.\n\t\t\t\tthis.maxMessagesPerTask = 10;\n\t\t\t}\n\t\t}\n\n\t\t// Proceed with actual listener initialization.\n\t\tsuper.initialize();\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#isIdle()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1325
    },
    "return": "boolean",
    "signature": "public boolean isIdle()",
    "source_code": "\t\tpublic boolean isIdle() {\n\t\t\treturn this.idle;\n\t\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#isLongLived()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1317
    },
    "return": "boolean",
    "signature": "public boolean isLongLived()",
    "source_code": "\t\tpublic boolean isLongLived() {\n\t\t\treturn (maxMessagesPerTask < 0);\n\t\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#isRecovering()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this listener container is currently in a recovery attempt.\n\t * <p>May be used to detect recovery phases but also the end of a recovery phase,\n\t * with {@code isRecovering()} switching to {@code false} after having been found\n\t * to return {@code true} before.\n\t * @see #recoverAfterListenerSetupFailure()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1077
    },
    "return": "boolean",
    "signature": "public boolean isRecovering()",
    "source_code": "\tpublic final boolean isRecovering() {\n\t\treturn this.recovering;\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#isRegisteredWithDestination()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether at least one consumer has entered a fixed registration with the\n\t * target destination. This is particularly interesting for the pub-sub case where\n\t * it might be important to have an actual consumer registered that is guaranteed\n\t * not to miss any messages that are just about to be published.\n\t * <p>This method may be polled after a {@link #start()} call, until asynchronous\n\t * registration of consumers has happened which is when the method will start returning\n\t * {@code true} &ndash; provided that the listener container ever actually establishes\n\t * a fixed registration. It will then keep returning {@code true} until shutdown,\n\t * since the container will hold on to at least one consumer registration thereafter.\n\t * <p>Note that a listener container is not bound to having a fixed registration in\n\t * the first place. It may also keep recreating consumers for every invoker execution.\n\t * This particularly depends on the {@link #setCacheLevel cache level} setting:\n\t * only {@link #CACHE_CONSUMER} will lead to a fixed registration.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 730
    },
    "return": "boolean",
    "signature": "public boolean isRegisteredWithDestination()",
    "source_code": "\tpublic boolean isRegisteredWithDestination() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\treturn (this.registeredWithDestination > 0);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#messageReceived(invoker,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Tries scheduling a new invoker, since we know messages are coming in...\n\t * @see #scheduleNewInvokerIfAppropriate()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 786
    },
    "return": "void",
    "signature": "protected void messageReceived(Object invoker, Session session)",
    "source_code": "\tprotected void messageReceived(Object invoker, Session session) {\n\t\t((AsyncMessageListenerInvoker) invoker).setIdle(false);\n\t\tscheduleNewInvokerIfAppropriate();\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#noMessageReceived(invoker,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Marks the affected invoker as idle.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 795
    },
    "return": "void",
    "signature": "protected void noMessageReceived(Object invoker, Session session)",
    "source_code": "\tprotected void noMessageReceived(Object invoker, Session session) {\n\t\t((AsyncMessageListenerInvoker) invoker).setIdle(true);\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#recoverAfterListenerSetupFailure()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Recover this listener container after a listener failed to set itself up,\n\t * for example re-establishing the underlying Connection.\n\t * <p>The default implementation delegates to DefaultMessageListenerContainer's\n\t * recovery-capable {@link #refreshConnectionUntilSuccessful()} method, which will\n\t * try to re-establish a Connection to the JMS provider both for the shared\n\t * and the non-shared Connection case.\n\t * @see #refreshConnectionUntilSuccessful()\n\t * @see #refreshDestination()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 955
    },
    "return": "void",
    "signature": "protected void recoverAfterListenerSetupFailure()",
    "source_code": "\tprotected void recoverAfterListenerSetupFailure() {\n\t\tthis.recovering = true;\n\t\ttry {\n\t\t\trefreshConnectionUntilSuccessful();\n\t\t\trefreshDestination();\n\t\t}\n\t\tfinally {\n\t\t\tthis.recovering = false;\n\t\t\tthis.interrupted = false;\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#refreshConnectionUntilSuccessful()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Refresh the underlying Connection, not returning before an attempt has been\n\t * successful. Called in case of a shared Connection as well as without shared\n\t * Connection, so either needs to operate on the shared Connection or on a\n\t * temporary Connection that just gets established for validation purposes.\n\t * <p>The default implementation retries until it successfully established a\n\t * Connection, for as long as this message listener container is running.\n\t * Applies the specified recovery interval between retries.\n\t * @see #setRecoveryInterval\n\t * @see #start()\n\t * @see #stop()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 979
    },
    "return": "void",
    "signature": "protected void refreshConnectionUntilSuccessful()",
    "source_code": "\tprotected void refreshConnectionUntilSuccessful() {\n\t\tBackOffExecution execution = this.backOff.start();\n\t\twhile (isRunning()) {\n\t\t\ttry {\n\t\t\t\tif (sharedConnectionEnabled()) {\n\t\t\t\t\trefreshSharedConnection();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tConnection con = createConnection();\n\t\t\t\t\tJmsUtils.closeConnection(con);\n\t\t\t\t}\n\t\t\t\tlogger.debug(\"Successfully refreshed JMS Connection\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (ex instanceof JMSException jmsException) {\n\t\t\t\t\tinvokeExceptionListener(jmsException);\n\t\t\t\t}\n\t\t\t\tStringBuilder msg = new StringBuilder();\n\t\t\t\tmsg.append(\"Could not refresh JMS Connection for destination '\");\n\t\t\t\tmsg.append(getDestinationDescription()).append(\"' - retrying using \");\n\t\t\t\tmsg.append(execution).append(\". Cause: \");\n\t\t\t\tmsg.append(ex instanceof JMSException jmsException ? JmsUtils.buildExceptionMessage(jmsException) :\n\t\t\t\t\t\tex.getMessage());\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.error(msg, ex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.error(msg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!applyBackOffTime(execution)) {\n\t\t\t\tlogger.error(\"Stopping container for destination '\" + getDestinationDescription() +\n\t\t\t\t\t\t\"': back-off policy does not allow for further attempts.\");\n\t\t\t\tstop();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#refreshDestination()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Refresh the JMS destination that this listener container operates on.\n\t * <p>Called after listener setup failure, assuming that a cached Destination\n\t * object might have become invalid (a typical case on WebLogic JMS).\n\t * <p>The default implementation removes the destination from a\n\t * DestinationResolver's cache, in case of a CachingDestinationResolver.\n\t * @see #setDestinationName\n\t * @see org.springframework.jms.support.destination.CachingDestinationResolver\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1027
    },
    "return": "void",
    "signature": "protected void refreshDestination()",
    "source_code": "\tprotected void refreshDestination() {\n\t\tString destName = getDestinationName();\n\t\tif (destName != null) {\n\t\t\tDestinationResolver destResolver = getDestinationResolver();\n\t\t\tif (destResolver instanceof CachingDestinationResolver cachingResolver) {\n\t\t\t\tcachingResolver.removeFromCache(destName);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#run()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1110
    },
    "return": "void",
    "signature": "public void run()",
    "source_code": "\t\tpublic void run() {\n\t\t\tsynchronized (lifecycleMonitor) {\n\t\t\t\tactiveInvokerCount++;\n\t\t\t\tlifecycleMonitor.notifyAll();\n\t\t\t}\n\t\t\tboolean messageReceived = false;\n\t\t\ttry {\n\t\t\t\tint messageLimit = maxMessagesPerTask;\n\t\t\t\tint idleLimit = idleReceivesPerTaskLimit;\n\t\t\t\tif (messageLimit < 0 && idleLimit < 0) {\n\t\t\t\t\tmessageReceived = executeOngoingLoop();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint messageCount = 0;\n\t\t\t\t\tint idleCount = 0;\n\t\t\t\t\twhile (isRunning() && (messageLimit < 0 || messageCount < messageLimit) &&\n\t\t\t\t\t\t\t(idleLimit < 0 || idleCount < idleLimit)) {\n\t\t\t\t\t\tboolean currentReceived = invokeListener();\n\t\t\t\t\t\tmessageReceived |= currentReceived;\n\t\t\t\t\t\tmessageCount++;\n\t\t\t\t\t\tidleCount = (currentReceived ? 0 : idleCount + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tclearResources();\n\t\t\t\tif (!this.lastMessageSucceeded) {\n\t\t\t\t\t// We failed more than once in a row or on startup -\n\t\t\t\t\t// wait before first recovery attempt.\n\t\t\t\t\twaitBeforeRecoveryAttempt();\n\t\t\t\t}\n\t\t\t\tthis.lastMessageSucceeded = false;\n\t\t\t\tboolean alreadyRecovered = false;\n\t\t\t\tsynchronized (recoveryMonitor) {\n\t\t\t\t\tif (this.lastRecoveryMarker == currentRecoveryMarker) {\n\t\t\t\t\t\thandleListenerSetupFailure(ex, false);\n\t\t\t\t\t\trecoverAfterListenerSetupFailure();\n\t\t\t\t\t\tcurrentRecoveryMarker = new Object();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\talreadyRecovered = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (alreadyRecovered) {\n\t\t\t\t\thandleListenerSetupFailure(ex, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tsynchronized (lifecycleMonitor) {\n\t\t\t\t\tdecreaseActiveInvokerCount();\n\t\t\t\t\tlifecycleMonitor.notifyAll();\n\t\t\t\t}\n\t\t\t\tif (!messageReceived) {\n\t\t\t\t\tthis.idleTaskExecutionCount++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.idleTaskExecutionCount = 0;\n\t\t\t\t}\n\t\t\t\tsynchronized (lifecycleMonitor) {\n\t\t\t\t\tif (!shouldRescheduleInvoker(this.idleTaskExecutionCount) || !rescheduleTaskIfNecessary(this)) {\n\t\t\t\t\t\t// We're shutting down completely.\n\t\t\t\t\t\tscheduledInvokers.remove(this);\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Lowered scheduled invoker count: \" + scheduledInvokers.size());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlifecycleMonitor.notifyAll();\n\t\t\t\t\t\tclearResources();\n\t\t\t\t\t}\n\t\t\t\t\telse if (isRunning()) {\n\t\t\t\t\t\tint nonPausedConsumers = getScheduledConsumerCount() - getPausedTaskCount();\n\t\t\t\t\t\tif (nonPausedConsumers < 1) {\n\t\t\t\t\t\t\tlogger.error(\"All scheduled consumers have been paused, probably due to tasks having been rejected. \" +\n\t\t\t\t\t\t\t\t\t\"Check your thread pool configuration! Manual recovery necessary through a start() call.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (nonPausedConsumers < getConcurrentConsumers()) {\n\t\t\t\t\t\t\tlogger.warn(\"Number of scheduled consumers has dropped below concurrentConsumers limit, probably \" +\n\t\t\t\t\t\t\t\t\t\"due to tasks having been rejected. Check your thread pool configuration! Automatic recovery \" +\n\t\t\t\t\t\t\t\t\t\"to be triggered by remaining consumers.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#scheduleNewInvokerIfAppropriate()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Schedule a new invoker, increasing the total number of scheduled\n\t * invokers for this listener container, but only if the specified\n\t * \"maxConcurrentConsumers\" limit has not been reached yet, and only\n\t * if the specified \"idleConsumerLimit\" has not been reached either.\n\t * <p>Called once a message has been received, in order to scale up while\n\t * processing the message in the invoker that originally received it.\n\t * @see #setTaskExecutor\n\t * @see #getMaxConcurrentConsumers()\n\t * @see #getIdleConsumerLimit()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 810
    },
    "return": "void",
    "signature": "protected void scheduleNewInvokerIfAppropriate()",
    "source_code": "\tprotected void scheduleNewInvokerIfAppropriate() {\n\t\tif (isRunning()) {\n\t\t\tresumePausedTasks();\n\t\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\t\tif (this.scheduledInvokers.size() < this.maxConcurrentConsumers &&\n\t\t\t\t\t\tgetIdleInvokerCount() < this.idleConsumerLimit) {\n\t\t\t\t\tscheduleNewInvoker();\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Raised scheduled invoker count: \" + this.scheduledInvokers.size());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#setBackOff(backOff)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the {@link BackOff} instance to use to compute the interval\n\t * between recovery attempts. If the {@link BackOffExecution} implementation\n\t * returns {@link BackOffExecution#STOP}, this listener container will not further\n\t * attempt to recover.\n\t * <p>The {@link #setRecoveryInterval(long) recovery interval} is ignored\n\t * when this property is set.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "backOff"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "void",
    "signature": "public void setBackOff(BackOff backOff)",
    "source_code": "\tpublic void setBackOff(BackOff backOff) {\n\t\tthis.backOff = backOff;\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#setCacheLevel(cacheLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the level of caching that this listener container is allowed to apply.\n\t * <p>Default is {@link #CACHE_NONE} if an external transaction manager has been specified\n\t * (to reobtain all resources freshly within the scope of the external transaction),\n\t * and {@link #CACHE_CONSUMER} otherwise (operating with local JMS resources).\n\t * <p>Some Jakarta EE servers only register their JMS resources with an ongoing XA\n\t * transaction in case of a freshly obtained JMS {@code Connection} and {@code Session},\n\t * which is why this listener container by default does not cache any of those.\n\t * However, depending on the rules of your server with respect to the caching\n\t * of transactional resources, consider switching this setting to at least\n\t * {@link #CACHE_CONNECTION} or {@link #CACHE_SESSION} even in conjunction with an\n\t * external transaction manager.\n\t * @see #CACHE_NONE\n\t * @see #CACHE_CONNECTION\n\t * @see #CACHE_SESSION\n\t * @see #CACHE_CONSUMER\n\t * @see #setCacheLevelName\n\t * @see #setTransactionManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheLevel"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "void",
    "signature": "public void setCacheLevel(int cacheLevel)",
    "source_code": "\tpublic void setCacheLevel(int cacheLevel) {\n\t\tthis.cacheLevel = cacheLevel;\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#setCacheLevelName(constantName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the level of caching that this listener container is allowed to apply,\n\t * in the form of the name of the corresponding constant: e.g. \"CACHE_CONNECTION\".\n\t * @see #setCacheLevel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constantName"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "void",
    "signature": "public void setCacheLevelName(String constantName)",
    "source_code": "\tpublic void setCacheLevelName(String constantName) throws IllegalArgumentException {\n\t\tif (!constantName.startsWith(\"CACHE_\")) {\n\t\t\tthrow new IllegalArgumentException(\"Only cache constants allowed\");\n\t\t}\n\t\tsetCacheLevel(constants.asNumber(constantName).intValue());\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#setConcurrency(concurrency)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify concurrency limits via a \"lower-upper\" String, e.g. \"5-10\", or a simple\n\t * upper limit String, e.g. \"10\" (the lower limit will be 1 in this case).\n\t * <p>This listener container will always hold on to the minimum number of consumers\n\t * ({@link #setConcurrentConsumers}) and will slowly scale up to the maximum number\n\t * of consumers {@link #setMaxConcurrentConsumers} in case of increasing load.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "concurrency"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "void",
    "signature": "public void setConcurrency(String concurrency)",
    "source_code": "\tpublic void setConcurrency(String concurrency) {\n\t\ttry {\n\t\t\tint separatorIndex = concurrency.indexOf('-');\n\t\t\tif (separatorIndex != -1) {\n\t\t\t\tsetConcurrentConsumers(Integer.parseInt(concurrency, 0, separatorIndex, 10));\n\t\t\t\tsetMaxConcurrentConsumers(Integer.parseInt(concurrency, separatorIndex + 1, concurrency.length(), 10));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetConcurrentConsumers(1);\n\t\t\t\tsetMaxConcurrentConsumers(Integer.parseInt(concurrency));\n\t\t\t}\n\t\t}\n\t\tcatch (NumberFormatException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid concurrency value [\" + concurrency + \"]: only \" +\n\t\t\t\t\t\"single maximum integer (e.g. \\\"5\\\") and minimum-maximum combo (e.g. \\\"3-5\\\") supported.\");\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#setConcurrentConsumers(concurrentConsumers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the number of concurrent consumers to create. Default is 1.\n\t * <p>Specifying a higher value for this setting will increase the standard\n\t * level of scheduled concurrent consumers at runtime: This is effectively\n\t * the minimum number of concurrent consumers which will be scheduled\n\t * at any given time. This is a static setting; for dynamic scaling,\n\t * consider specifying the \"maxConcurrentConsumers\" setting instead.\n\t * <p>Raising the number of concurrent consumers is recommendable in order\n\t * to scale the consumption of messages coming in from a queue. However,\n\t * note that any ordering guarantees are lost once multiple consumers are\n\t * registered. In general, stick with 1 consumer for low-volume queues.\n\t * <p><b>Do not raise the number of concurrent consumers for a topic,\n\t * unless vendor-specific setup measures clearly allow for it.</b>\n\t * With regular setup, this would lead to concurrent consumption\n\t * of the same message, which is hardly ever desirable.\n\t * <p><b>This setting can be modified at runtime, for example through JMX.</b>\n\t * @see #setMaxConcurrentConsumers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "concurrentConsumers"
    ],
    "position": {
      "column": 1,
      "line": 344
    },
    "return": "void",
    "signature": "public void setConcurrentConsumers(int concurrentConsumers)",
    "source_code": "\tpublic void setConcurrentConsumers(int concurrentConsumers) {\n\t\tAssert.isTrue(concurrentConsumers > 0, \"'concurrentConsumers' value must be at least 1 (one)\");\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tthis.concurrentConsumers = concurrentConsumers;\n\t\t\tif (this.maxConcurrentConsumers < concurrentConsumers) {\n\t\t\t\tthis.maxConcurrentConsumers = concurrentConsumers;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#setIdle(idle)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "idle"
    ],
    "position": {
      "column": 1,
      "line": 1321
    },
    "return": "void",
    "signature": "public void setIdle(boolean idle)",
    "source_code": "\t\tpublic void setIdle(boolean idle) {\n\t\t\tthis.idle = idle;\n\t\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#setIdleConsumerLimit(idleConsumerLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the limit for the number of consumers that are allowed to be idle\n\t * at any given time.\n\t * <p>This limit is used by the {@link #scheduleNewInvokerIfAppropriate} method\n\t * to determine if a new invoker should be created. Increasing the limit causes\n\t * invokers to be created more aggressively. This can be useful to ramp up the\n\t * number of invokers faster.\n\t * <p>The default is 1, only scheduling a new invoker (which is likely to\n\t * be idle initially) if none of the existing invokers is currently idle.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "idleConsumerLimit"
    ],
    "position": {
      "column": 1,
      "line": 452
    },
    "return": "void",
    "signature": "public void setIdleConsumerLimit(int idleConsumerLimit)",
    "source_code": "\tpublic void setIdleConsumerLimit(int idleConsumerLimit) {\n\t\tAssert.isTrue(idleConsumerLimit > 0, \"'idleConsumerLimit' must be 1 or higher\");\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tthis.idleConsumerLimit = idleConsumerLimit;\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#setIdleReceivesPerTaskLimit(idleReceivesPerTaskLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Marks the consumer as 'idle' after the specified number of idle receives\n\t * have been reached. An idle receive is counted from the moment a null message\n\t * is returned by the receiver after the potential {@link #setReceiveTimeout}\n\t * elapsed. This gives the opportunity to check if the idle task count exceeds\n\t * {@link #setIdleTaskExecutionLimit} and based on that decide if the task needs\n\t * to be re-scheduled or not, saving resources that would otherwise be held.\n\t * <p>This setting differs from {@link #setMaxMessagesPerTask} where the task is\n\t * released and re-scheduled after this limit is reached, no matter if the received\n\t * messages were null or non-null messages. This setting alone can be inflexible\n\t * if one desires to have a large enough batch for each task but requires a\n\t * quick(er) release from the moment there are no more messages to process.\n\t * <p>This setting differs from {@link #setIdleTaskExecutionLimit} where this limit\n\t * decides after how many iterations of being marked as idle, a task is released.\n\t * <p>For example: If {@link #setMaxMessagesPerTask} is set to '500' and\n\t * {@code #setIdleReceivesPerTaskLimit} is set to '60' and {@link #setReceiveTimeout}\n\t * is set to '1000' and {@link #setIdleTaskExecutionLimit} is set to '1', then 500\n\t * messages per task would be processed unless there is a subsequent number of 60\n\t * idle messages received, the task would be marked as idle and released. This also\n\t * means that after the last message was processed, the task would be released after\n\t * 60 seconds as long as no new messages appear.\n\t * @since 5.3.5\n\t * @see #setMaxMessagesPerTask\n\t * @see #setReceiveTimeout\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "idleReceivesPerTaskLimit"
    ],
    "position": {
      "column": 1,
      "line": 536
    },
    "return": "void",
    "signature": "public void setIdleReceivesPerTaskLimit(int idleReceivesPerTaskLimit)",
    "source_code": "\tpublic void setIdleReceivesPerTaskLimit(int idleReceivesPerTaskLimit) {\n\t\tAssert.isTrue(idleReceivesPerTaskLimit != 0, \"'idleReceivesPerTaskLimit' must not be 0)\");\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tthis.idleReceivesPerTaskLimit = idleReceivesPerTaskLimit;\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#setIdleTaskExecutionLimit(idleTaskExecutionLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the limit for idle executions of a consumer task, not having\n\t * received any message within its execution. If this limit is reached,\n\t * the task will shut down and leave receiving to other executing tasks.\n\t * <p>The default is 1, closing idle resources early once a task didn't\n\t * receive a message. This applies to dynamic scheduling only; see the\n\t * {@link #setMaxConcurrentConsumers \"maxConcurrentConsumers\"} setting.\n\t * The minimum number of consumers\n\t * (see {@link #setConcurrentConsumers \"concurrentConsumers\"})\n\t * will be kept around until shutdown in any case.\n\t * <p>Within each task execution, a number of message reception attempts\n\t * (according to the \"maxMessagesPerTask\" setting) will each wait for an incoming\n\t * message (according to the \"receiveTimeout\" setting). If all of those receive\n\t * attempts in a given task return without a message, the task is considered\n\t * idle with respect to received messages. Such a task may still be rescheduled;\n\t * however, once it reached the specified \"idleTaskExecutionLimit\", it will\n\t * shut down (in case of dynamic scaling).\n\t * <p>Raise this limit if you encounter too frequent scaling up and down.\n\t * With this limit being higher, an idle consumer will be kept around longer,\n\t * avoiding the restart of a consumer once a new load of messages comes in.\n\t * Alternatively, specify a higher \"maxMessagesPerTask\" and/or \"receiveTimeout\" value,\n\t * which will also lead to idle consumers being kept around for a longer time\n\t * (while also increasing the average execution time of each scheduled task).\n\t * <p><b>This setting can be modified at runtime, for example through JMX.</b>\n\t * @see #setMaxMessagesPerTask\n\t * @see #setReceiveTimeout\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "idleTaskExecutionLimit"
    ],
    "position": {
      "column": 1,
      "line": 495
    },
    "return": "void",
    "signature": "public void setIdleTaskExecutionLimit(int idleTaskExecutionLimit)",
    "source_code": "\tpublic void setIdleTaskExecutionLimit(int idleTaskExecutionLimit) {\n\t\tAssert.isTrue(idleTaskExecutionLimit > 0, \"'idleTaskExecutionLimit' must be 1 or higher\");\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tthis.idleTaskExecutionLimit = idleTaskExecutionLimit;\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#setMaxConcurrentConsumers(maxConcurrentConsumers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the maximum number of concurrent consumers to create. Default is 1.\n\t * <p>If this setting is higher than \"concurrentConsumers\", the listener container\n\t * will dynamically schedule new consumers at runtime, provided that enough\n\t * incoming messages are encountered. Once the load goes down again, the number of\n\t * consumers will be reduced to the standard level (\"concurrentConsumers\") again.\n\t * <p>Raising the number of concurrent consumers is recommendable in order\n\t * to scale the consumption of messages coming in from a queue. However,\n\t * note that any ordering guarantees are lost once multiple consumers are\n\t * registered. In general, stick with 1 consumer for low-volume queues.\n\t * <p><b>Do not raise the number of concurrent consumers for a topic,\n\t * unless vendor-specific setup measures clearly allow for it.</b>\n\t * With regular setup, this would lead to concurrent consumption\n\t * of the same message, which is hardly ever desirable.\n\t * <p><b>This setting can be modified at runtime, for example through JMX.</b>\n\t * @see #setConcurrentConsumers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "maxConcurrentConsumers"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "void",
    "signature": "public void setMaxConcurrentConsumers(int maxConcurrentConsumers)",
    "source_code": "\tpublic void setMaxConcurrentConsumers(int maxConcurrentConsumers) {\n\t\tAssert.isTrue(maxConcurrentConsumers > 0, \"'maxConcurrentConsumers' value must be at least 1 (one)\");\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tthis.maxConcurrentConsumers = Math.max(maxConcurrentConsumers, this.concurrentConsumers);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#setMaxMessagesPerTask(maxMessagesPerTask)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the maximum number of messages to process in one task.\n\t * More concretely, this limits the number of message reception attempts\n\t * per task, which includes receive iterations that did not actually\n\t * pick up a message until they hit their timeout (see the\n\t * {@link #setReceiveTimeout \"receiveTimeout\"} property).\n\t * <p>Default is unlimited (-1) in case of a standard TaskExecutor,\n\t * reusing the original invoker threads until shutdown (at the\n\t * expense of limited dynamic scheduling).\n\t * <p>In case of a SchedulingTaskExecutor indicating a preference for\n\t * short-lived tasks, the default is 10 instead. Specify a number\n\t * of 10 to 100 messages to balance between rather long-lived and\n\t * rather short-lived tasks here.\n\t * <p>Long-lived tasks avoid frequent thread context switches through\n\t * sticking with the same thread all the way through, while short-lived\n\t * tasks allow thread pools to control the scheduling. Hence, thread\n\t * pools will usually prefer short-lived tasks.\n\t * <p><b>This setting can be modified at runtime, for example through JMX.</b>\n\t * @see #setTaskExecutor\n\t * @see #setReceiveTimeout\n\t * @see org.springframework.scheduling.SchedulingTaskExecutor#prefersShortLivedTasks()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "maxMessagesPerTask"
    ],
    "position": {
      "column": 1,
      "line": 426
    },
    "return": "void",
    "signature": "public void setMaxMessagesPerTask(int maxMessagesPerTask)",
    "source_code": "\tpublic void setMaxMessagesPerTask(int maxMessagesPerTask) {\n\t\tAssert.isTrue(maxMessagesPerTask != 0, \"'maxMessagesPerTask' must not be 0\");\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tthis.maxMessagesPerTask = maxMessagesPerTask;\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#setRecoveryInterval(recoveryInterval)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the interval between recovery attempts, in <b>milliseconds</b>.\n\t * The default is 5000 ms, that is, 5 seconds. This is a convenience method\n\t * to create a {@link FixedBackOff} with the specified interval.\n\t * <p>For more recovery options, consider specifying a {@link BackOff}\n\t * instance instead.\n\t * @see #setBackOff(BackOff)\n\t * @see #handleListenerSetupFailure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "recoveryInterval"
    ],
    "position": {
      "column": 1,
      "line": 253
    },
    "return": "void",
    "signature": "public void setRecoveryInterval(long recoveryInterval)",
    "source_code": "\tpublic void setRecoveryInterval(long recoveryInterval) {\n\t\tthis.backOff = new FixedBackOff(recoveryInterval, Long.MAX_VALUE);\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#setTaskExecutor(taskExecutor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Spring {@code TaskExecutor} to use for running the listener threads.\n\t * <p>Default is a {@link org.springframework.core.task.SimpleAsyncTaskExecutor},\n\t * starting up a number of new threads, according to the specified number\n\t * of concurrent consumers.\n\t * <p>Specify an alternative {@code TaskExecutor} for integration with an existing\n\t * thread pool. Note that this really only adds value if the threads are\n\t * managed in a specific fashion, for example within a Jakarta EE environment.\n\t * A plain thread pool does not add much value, as this listener container\n\t * will occupy a number of threads for its entire lifetime.\n\t * @see #setConcurrentConsumers\n\t * @see org.springframework.core.task.SimpleAsyncTaskExecutor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "taskExecutor"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "void",
    "signature": "public void setTaskExecutor(Executor taskExecutor)",
    "source_code": "\tpublic void setTaskExecutor(Executor taskExecutor) {\n\t\tthis.taskExecutor = taskExecutor;\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#sharedConnectionEnabled()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Use a shared JMS Connection depending on the \"cacheLevel\" setting.\n\t * @see #setCacheLevel\n\t * @see #CACHE_CONNECTION\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 767
    },
    "return": "boolean",
    "signature": "protected boolean sharedConnectionEnabled()",
    "source_code": "\tprotected final boolean sharedConnectionEnabled() {\n\t\treturn (getCacheLevel() >= CACHE_CONNECTION);\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#start()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Overridden to reset the stop callback, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 651
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() throws JmsException {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tthis.stopCallback = null;\n\t\t}\n\t\tsuper.start();\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#startSharedConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation proceeds even after an exception thrown from\n\t * {@code Connection.start()}, relying on listeners to perform\n\t * appropriate recovery.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 878
    },
    "return": "void",
    "signature": "protected void startSharedConnection()",
    "source_code": "\tprotected void startSharedConnection() {\n\t\ttry {\n\t\t\tsuper.startSharedConnection();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tlogger.debug(\"Connection start failed - relying on listeners to perform recovery\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#stop(callback)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Stop this listener container, invoking the specific callback\n\t * once all listener processing has actually stopped.\n\t * <p>Note: Further {@code stop(runnable)} calls (before processing\n\t * has actually stopped) will override the specified callback. Only the\n\t * latest specified callback will be invoked.\n\t * <p>If a subsequent {@link #start()} call restarts the listener container\n\t * before it has fully stopped, the callback will not get invoked at all.\n\t * @param callback the callback to invoke once listener processing\n\t * has fully stopped\n\t * @throws JmsException if stopping failed\n\t * @see #stop()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 672
    },
    "return": "void",
    "signature": "public void stop(Runnable callback)",
    "source_code": "\tpublic void stop(Runnable callback) throws JmsException {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\tif (!isRunning() || this.stopCallback != null) {\n\t\t\t\t// Not started, already stopped, or previous stop attempt in progress\n\t\t\t\t// -> return immediately, no stop process to control anymore.\n\t\t\t\tcallback.run();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.stopCallback = callback;\n\t\t}\n\t\tstop();\n\t}"
  },
  "org.springframework.jms.listener.DefaultMessageListenerContainer#stopSharedConnection()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation proceeds even after an exception thrown from\n\t * {@code Connection.stop()}, relying on listeners to perform\n\t * appropriate recovery after a restart.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 893
    },
    "return": "void",
    "signature": "protected void stopSharedConnection()",
    "source_code": "\tprotected void stopSharedConnection() {\n\t\ttry {\n\t\t\tsuper.stopSharedConnection();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tlogger.debug(\"Connection stop failed - relying on listeners to perform recovery after restart\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapter#getSubscriptionName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a subscription name for this {@code MessageListener} adapter based\n\t * on the following rules.\n\t * <ul>\n\t * <li>If the {@link #setHandlerMethod(InvocableHandlerMethod) handlerMethod}\n\t * has been set, the generated subscription name takes the form of\n\t * {@code handlerMethod.getBeanType().getName() + \".\" + handlerMethod.getMethod().getName()}.</li>\n\t * <li>Otherwise, the generated subscription name is the result of invoking\n\t * {@code getClass().getName()}, which aligns with the default behavior of\n\t * {@link org.springframework.jms.listener.AbstractMessageListenerContainer}.</li>\n\t * </ul>\n\t * @since 5.3.26\n\t * @see SubscriptionNameProvider#getSubscriptionName()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "String",
    "signature": "public String getSubscriptionName()",
    "source_code": "\tpublic String getSubscriptionName() {\n\t\tif (this.handlerMethod != null) {\n\t\t\treturn this.handlerMethod.getBeanType().getName() + \".\" + this.handlerMethod.getMethod().getName();\n\t\t}\n\t\telse {\n\t\t\treturn getClass().getName();\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Extension of the generic JCA 1.5\n * {@link org.springframework.jca.endpoint.GenericMessageEndpointManager},\n * adding JMS-specific support for ActivationSpec configuration.\n *\n * <p>Allows for defining a common {@link JmsActivationSpecConfig} object\n * that gets converted into a provider-specific JCA 1.5 ActivationSpec\n * object for activating the endpoint.\n *\n * <p><b>NOTE:</b> This JCA-based endpoint manager supports standard JMS\n * {@link jakarta.jms.MessageListener} endpoints only. It does <i>not</i> support\n * Spring's {@link org.springframework.jms.listener.SessionAwareMessageListener}\n * variant, simply because the JCA endpoint management contract does not allow\n * for obtaining the current JMS {@link jakarta.jms.Session}.\n *\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @since 2.5\n * @see jakarta.jms.MessageListener\n * @see #setActivationSpecConfig\n * @see JmsActivationSpecConfig\n * @see JmsActivationSpecFactory\n * @see JmsMessageEndpointFactory\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "signature": "public class JmsMessageEndpointManager",
    "source_code": "public class JmsMessageEndpointManager extends GenericMessageEndpointManager"
  },
  "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() throws ResourceException {\n\t\tif (getResourceAdapter() == null) {\n\t\t\tthrow new IllegalArgumentException(\"Property 'resourceAdapter' is required\");\n\t\t}\n\t\tif (this.messageListenerSet) {\n\t\t\tsetMessageEndpointFactory(this.endpointFactory);\n\t\t}\n\t\tif (this.activationSpecConfig != null) {\n\t\t\tsetActivationSpec(\n\t\t\t\t\tthis.activationSpecFactory.createActivationSpec(getResourceAdapter(), this.activationSpecConfig));\n\t\t}\n\n\t\tsuper.afterPropertiesSet();\n\t}"
  },
  "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager#getActivationSpecConfig()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link JmsActivationSpecConfig} object that this endpoint manager\n\t * should use for activating its listener. Return {@code null} if none is set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "JmsActivationSpecConfig",
    "signature": "public JmsActivationSpecConfig getActivationSpecConfig()",
    "source_code": "\tpublic JmsActivationSpecConfig getActivationSpecConfig() {\n\t\treturn this.activationSpecConfig;\n\t}"
  },
  "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager#getDestinationResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "DestinationResolver",
    "signature": "public DestinationResolver getDestinationResolver()",
    "source_code": "\tpublic DestinationResolver getDestinationResolver() {\n\t\tif (this.activationSpecFactory instanceof StandardJmsActivationSpecFactory standardFactory) {\n\t\t\treturn standardFactory.getDestinationResolver();\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager#getMessageConverter()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "MessageConverter",
    "signature": "public MessageConverter getMessageConverter()",
    "source_code": "\tpublic MessageConverter getMessageConverter() {\n\t\tJmsActivationSpecConfig config = getActivationSpecConfig();\n\t\tif (config != null) {\n\t\t\treturn config.getMessageConverter();\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager#getMessageListener()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JMS MessageListener for this endpoint.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "MessageListener",
    "signature": "public MessageListener getMessageListener()",
    "source_code": "\tpublic MessageListener getMessageListener() {\n\t\treturn this.endpointFactory.getMessageListener();\n\t}"
  },
  "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager#getReplyQosSettings()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "QosSettings",
    "signature": "public QosSettings getReplyQosSettings()",
    "source_code": "\tpublic QosSettings getReplyQosSettings() {\n\t\tJmsActivationSpecConfig config = getActivationSpecConfig();\n\t\tif (config != null) {\n\t\t\treturn config.getReplyQosSettings();\n\t\t}\n\t\tthrow new IllegalStateException(\"Could not determine reply qosSettings - no activation spec config is set\");\n\t}"
  },
  "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager#isPubSubDomain()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "boolean",
    "signature": "public boolean isPubSubDomain()",
    "source_code": "\tpublic boolean isPubSubDomain() {\n\t\tJmsActivationSpecConfig config = getActivationSpecConfig();\n\t\tif (config != null) {\n\t\t\treturn config.isPubSubDomain();\n\t\t}\n\t\tthrow new IllegalStateException(\"Could not determine pubSubDomain - no activation spec config is set\");\n\t}"
  },
  "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager#isReplyPubSubDomain()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "boolean",
    "signature": "public boolean isReplyPubSubDomain()",
    "source_code": "\tpublic boolean isReplyPubSubDomain() {\n\t\tJmsActivationSpecConfig config = getActivationSpecConfig();\n\t\tif (config != null) {\n\t\t\treturn config.isReplyPubSubDomain();\n\t\t}\n\t\tthrow new IllegalStateException(\"Could not determine reply pubSubDomain - no activation spec config is set\");\n\t}"
  },
  "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager#setActivationSpecConfig(activationSpecConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the {@link JmsActivationSpecConfig} object that this endpoint manager\n\t * should use for activating its listener.\n\t * <p>This config object will be turned into a concrete JCA 1.5 ActivationSpec\n\t * object through a {@link #setActivationSpecFactory JmsActivationSpecFactory}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "activationSpecConfig"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "public void setActivationSpecConfig(@Nullable JmsActivationSpecConfig activationSpecConfig)",
    "source_code": "\tpublic void setActivationSpecConfig(@Nullable JmsActivationSpecConfig activationSpecConfig) {\n\t\tthis.activationSpecConfig = activationSpecConfig;\n\t}"
  },
  "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager#setActivationSpecFactory(activationSpecFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the factory for concrete JCA 1.5 ActivationSpec objects,\n\t * creating JCA ActivationSpecs based on\n\t * {@link #setActivationSpecConfig JmsActivationSpecConfig} objects.\n\t * <p>This factory is dependent on the concrete JMS provider, e.g. on ActiveMQ.\n\t * The default implementation simply guesses the ActivationSpec class name\n\t * from the provider's class name (e.g. \"ActiveMQResourceAdapter\" &rarr;\n\t * \"ActiveMQActivationSpec\" in the same package), and populates the\n\t * ActivationSpec properties as suggested by the JCA 1.5 specification\n\t * (plus a couple of autodetected vendor-specific properties).\n\t * @see DefaultJmsActivationSpecFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "activationSpecFactory"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void setActivationSpecFactory(@Nullable JmsActivationSpecFactory activationSpecFactory)",
    "source_code": "\tpublic void setActivationSpecFactory(@Nullable JmsActivationSpecFactory activationSpecFactory) {\n\t\tthis.activationSpecFactory =\n\t\t\t\t(activationSpecFactory != null ? activationSpecFactory : new DefaultJmsActivationSpecFactory());\n\t}"
  },
  "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager#setBeanName(beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of this message endpoint. Populated with the bean name\n\t * automatically when defined within Spring's bean factory.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void setBeanName(String beanName)",
    "source_code": "\tpublic void setBeanName(String beanName) {\n\t\tthis.endpointFactory.setBeanName(beanName);\n\t}"
  },
  "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager#setDestinationResolver(destinationResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the DestinationResolver to use for resolving destination names\n\t * into the JCA 1.5 ActivationSpec \"destination\" property.\n\t * <p>If not specified, destination names will simply be passed in as Strings.\n\t * If specified, destination names will be resolved into Destination objects first.\n\t * <p>Note that a DestinationResolver is usually specified on the JmsActivationSpecFactory\n\t * (see {@link StandardJmsActivationSpecFactory#setDestinationResolver}). This is simply\n\t * a shortcut for parameterizing the default JmsActivationSpecFactory; it will replace\n\t * any custom JmsActivationSpecFactory that might have been set before.\n\t * @see StandardJmsActivationSpecFactory#setDestinationResolver\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationResolver"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "void",
    "signature": "public void setDestinationResolver(DestinationResolver destinationResolver)",
    "source_code": "\tpublic void setDestinationResolver(DestinationResolver destinationResolver) {\n\t\tDefaultJmsActivationSpecFactory factory = new DefaultJmsActivationSpecFactory();\n\t\tfactory.setDestinationResolver(destinationResolver);\n\t\tthis.activationSpecFactory = factory;\n\t}"
  },
  "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager#setMessageListener(messageListener)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JMS MessageListener for this endpoint.\n\t * <p>This is a shortcut for configuring a dedicated JmsMessageEndpointFactory.\n\t * @see JmsMessageEndpointFactory#setMessageListener\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageListener"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "public void setMessageListener(MessageListener messageListener)",
    "source_code": "\tpublic void setMessageListener(MessageListener messageListener) {\n\t\tthis.endpointFactory.setMessageListener(messageListener);\n\t\tthis.messageListenerSet = true;\n\t}"
  },
  "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager#setTransactionManager(transactionManager)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the XA transaction manager to use for wrapping endpoint\n\t * invocations, enlisting the endpoint resource in each such transaction.\n\t * <p>The passed-in object may be a transaction manager which implements\n\t * Spring's {@link org.springframework.transaction.jta.TransactionFactory}\n\t * interface, or a plain {@link jakarta.transaction.TransactionManager}.\n\t * <p>If no transaction manager is specified, the endpoint invocation\n\t * will simply not be wrapped in an XA transaction. Consult your\n\t * resource provider's ActivationSpec documentation for the local\n\t * transaction options of your particular provider.\n\t * <p>This is a shortcut for configuring a dedicated JmsMessageEndpointFactory.\n\t * @see JmsMessageEndpointFactory#setTransactionManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "transactionManager"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "public void setTransactionManager(Object transactionManager)",
    "source_code": "\tpublic void setTransactionManager(Object transactionManager) {\n\t\tthis.endpointFactory.setTransactionManager(transactionManager);\n\t}"
  },
  "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager#setupMessageListener(messageListener)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageListener"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "void",
    "signature": "public void setupMessageListener(Object messageListener)",
    "source_code": "\tpublic void setupMessageListener(Object messageListener) {\n\t\tif (messageListener instanceof MessageListener msgListener) {\n\t\t\tsetMessageListener(msgListener);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Unsupported message listener '\" +\n\t\t\t\t\tmessageListener.getClass().getName() + \"': only '\" + MessageListener.class.getName() +\n\t\t\t\t\t\"' type is supported\");\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.JmsUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Generic utility methods for working with JMS. Mainly for internal use\n * within the framework, but also useful for custom JMS access code.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 1.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "signature": "public class JmsUtils",
    "source_code": "public abstract class JmsUtils {\n\n\tprivate static final Log logger = LogFactory.getLog(JmsUtils.class);\n\n\n\t/**\n\t * Close the given JMS Connection and ignore any thrown exception.\n\t * <p>This is useful for typical {@code finally} blocks in manual JMS code.\n\t * @param con the JMS Connection to close (may be {@code null})\n\t */\n\tpublic static void closeConnection(@Nullable Connection con) {\n\t\tcloseConnection(con, false);\n\t}\n\n\t/**\n\t * Close the given JMS Connection and ignore any thrown exception.\n\t * <p>This is useful for typical {@code finally} blocks in manual JMS code.\n\t * @param con the JMS Connection to close (may be {@code null})\n\t * @param stop whether to call {@code stop()} before closing\n\t */\n\tpublic static void closeConnection(@Nullable Connection con, boolean stop) {\n\t\tif (con != null) {\n\t\t\ttry {\n\t\t\t\tif (stop) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcon.stop();\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tcon.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcon.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (jakarta.jms.IllegalStateException ex) {\n\t\t\t\tlogger.debug(\"Ignoring Connection state exception - assuming already closed: \" + ex);\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tlogger.debug(\"Could not close JMS Connection\", ex);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// We don't trust the JMS provider: It might throw RuntimeException or Error.\n\t\t\t\tlogger.debug(\"Unexpected exception on closing JMS Connection\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Close the given JMS Session and ignore any thrown exception.\n\t * <p>This is useful for typical {@code finally} blocks in manual JMS code.\n\t * @param session the JMS Session to close (may be {@code null})\n\t */\n\tpublic static void closeSession(@Nullable Session session) {\n\t\tif (session != null) {\n\t\t\ttry {\n\t\t\t\tsession.close();\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tlogger.trace(\"Could not close JMS Session\", ex);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// We don't trust the JMS provider: It might throw RuntimeException or Error.\n\t\t\t\tlogger.trace(\"Unexpected exception on closing JMS Session\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Close the given JMS MessageProducer and ignore any thrown exception.\n\t * <p>This is useful for typical {@code finally} blocks in manual JMS code.\n\t * @param producer the JMS MessageProducer to close (may be {@code null})\n\t */\n\tpublic static void closeMessageProducer(@Nullable MessageProducer producer) {\n\t\tif (producer != null) {\n\t\t\ttry {\n\t\t\t\tproducer.close();\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tlogger.trace(\"Could not close JMS MessageProducer\", ex);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// We don't trust the JMS provider: It might throw RuntimeException or Error.\n\t\t\t\tlogger.trace(\"Unexpected exception on closing JMS MessageProducer\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Close the given JMS MessageConsumer and ignore any thrown exception.\n\t * <p>This is useful for typical {@code finally} blocks in manual JMS code.\n\t * @param consumer the JMS MessageConsumer to close (may be {@code null})\n\t */\n\tpublic static void closeMessageConsumer(@Nullable MessageConsumer consumer) {\n\t\tif (consumer != null) {\n\t\t\t// Clear interruptions to ensure that the consumer closes successfully...\n\t\t\t// (working around misbehaving JMS providers such as ActiveMQ)\n\t\t\tboolean wasInterrupted = Thread.interrupted();\n\t\t\ttry {\n\t\t\t\tconsumer.close();\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tlogger.trace(\"Could not close JMS MessageConsumer\", ex);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// We don't trust the JMS provider: It might throw RuntimeException or Error.\n\t\t\t\tlogger.trace(\"Unexpected exception on closing JMS MessageConsumer\", ex);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (wasInterrupted) {\n\t\t\t\t\t// Reset the interrupted flag as it was before.\n\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Close the given JMS QueueBrowser and ignore any thrown exception.\n\t * <p>This is useful for typical {@code finally} blocks in manual JMS code.\n\t * @param browser the JMS QueueBrowser to close (may be {@code null})\n\t */\n\tpublic static void closeQueueBrowser(@Nullable QueueBrowser browser) {\n\t\tif (browser != null) {\n\t\t\ttry {\n\t\t\t\tbrowser.close();\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tlogger.trace(\"Could not close JMS QueueBrowser\", ex);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// We don't trust the JMS provider: It might throw RuntimeException or Error.\n\t\t\t\tlogger.trace(\"Unexpected exception on closing JMS QueueBrowser\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Close the given JMS QueueRequestor and ignore any thrown exception.\n\t * <p>This is useful for typical {@code finally} blocks in manual JMS code.\n\t * @param requestor the JMS QueueRequestor to close (may be {@code null})\n\t */\n\tpublic static void closeQueueRequestor(@Nullable QueueRequestor requestor) {\n\t\tif (requestor != null) {\n\t\t\ttry {\n\t\t\t\trequestor.close();\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tlogger.trace(\"Could not close JMS QueueRequestor\", ex);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// We don't trust the JMS provider: It might throw RuntimeException or Error.\n\t\t\t\tlogger.trace(\"Unexpected exception on closing JMS QueueRequestor\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Commit the Session if not within a JTA transaction.\n\t * @param session the JMS Session to commit\n\t * @throws JMSException if committing failed\n\t */\n\tpublic static void commitIfNecessary(Session session) throws JMSException {\n\t\tAssert.notNull(session, \"Session must not be null\");\n\t\ttry {\n\t\t\tsession.commit();\n\t\t}\n\t\tcatch (jakarta.jms.TransactionInProgressException | jakarta.jms.IllegalStateException ex) {\n\t\t\t// Ignore -> can only happen in case of a JTA transaction.\n\t\t}\n\t}\n\n\t/**\n\t * Roll back the Session if not within a JTA transaction.\n\t * @param session the JMS Session to rollback\n\t * @throws JMSException if committing failed\n\t */\n\tpublic static void rollbackIfNecessary(Session session) throws JMSException {\n\t\tAssert.notNull(session, \"Session must not be null\");\n\t\ttry {\n\t\t\tsession.rollback();\n\t\t}\n\t\tcatch (jakarta.jms.TransactionInProgressException | jakarta.jms.IllegalStateException ex) {\n\t\t\t// Ignore -> can only happen in case of a JTA transaction.\n\t\t}\n\t}\n\n\t/**\n\t * Build a descriptive exception message for the given JMSException,\n\t * incorporating a linked exception's message if appropriate.\n\t * @param ex the JMSException to build a message for\n\t * @return the descriptive message String\n\t * @see jakarta.jms.JMSException#getLinkedException()\n\t */\n\tpublic static String buildExceptionMessage(JMSException ex) {\n\t\tString message = ex.getMessage();\n\t\tException linkedEx = ex.getLinkedException();\n\t\tif (linkedEx != null) {\n\t\t\tif (message == null) {\n\t\t\t\tmessage = linkedEx.toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString linkedMessage = linkedEx.getMessage();\n\t\t\t\tif (linkedMessage != null && !message.contains(linkedMessage)) {\n\t\t\t\t\tmessage = message + \"; nested exception is \" + linkedEx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn message;\n\t}\n\n\t/**\n\t * Convert the specified checked {@link jakarta.jms.JMSException JMSException} to a\n\t * Spring runtime {@link org.springframework.jms.JmsException JmsException} equivalent.\n\t * @param ex the original checked JMSException to convert\n\t * @return the Spring runtime JmsException wrapping the given exception\n\t */\n\tpublic static JmsException convertJmsAccessException(JMSException ex) {\n\t\tAssert.notNull(ex, \"JMSException must not be null\");\n\n\t\tif (ex instanceof jakarta.jms.IllegalStateException jakartaISE) {\n\t\t\treturn new org.springframework.jms.IllegalStateException(jakartaISE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.InvalidClientIDException jakartaICIDE) {\n\t\t\treturn new InvalidClientIDException(jakartaICIDE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.InvalidDestinationException jakartaIDE) {\n\t\t\treturn new InvalidDestinationException(jakartaIDE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.InvalidSelectorException jakartaISE) {\n\t\t\treturn new InvalidSelectorException(jakartaISE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.JMSSecurityException jakartaJMSSE) {\n\t\t\treturn new JmsSecurityException(jakartaJMSSE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.MessageEOFException jakartaMEOFE) {\n\t\t\treturn new MessageEOFException(jakartaMEOFE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.MessageFormatException jakartaMFE) {\n\t\t\treturn new MessageFormatException(jakartaMFE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.MessageNotReadableException jakartaMNRE) {\n\t\t\treturn new MessageNotReadableException(jakartaMNRE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.MessageNotWriteableException jakartaMNWE) {\n\t\t\treturn new MessageNotWriteableException(jakartaMNWE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.ResourceAllocationException jakartaRAE) {\n\t\t\treturn new ResourceAllocationException(jakartaRAE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.TransactionInProgressException jakartaTIPE) {\n\t\t\treturn new TransactionInProgressException(jakartaTIPE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.TransactionRolledBackException jakartaTRBE) {\n\t\t\treturn new TransactionRolledBackException(jakartaTRBE);\n\t\t}\n\n\t\t// fallback\n\t\treturn new UncategorizedJmsException(ex);\n\t}\n\n}"
  },
  "org.springframework.jms.support.JmsUtils#buildExceptionMessage(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a descriptive exception message for the given JMSException,\n\t * incorporating a linked exception's message if appropriate.\n\t * @param ex the JMSException to build a message for\n\t * @return the descriptive message String\n\t * @see jakarta.jms.JMSException#getLinkedException()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "String",
    "signature": "public String buildExceptionMessage(JMSException ex)",
    "source_code": "\tpublic static String buildExceptionMessage(JMSException ex) {\n\t\tString message = ex.getMessage();\n\t\tException linkedEx = ex.getLinkedException();\n\t\tif (linkedEx != null) {\n\t\t\tif (message == null) {\n\t\t\t\tmessage = linkedEx.toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString linkedMessage = linkedEx.getMessage();\n\t\t\t\tif (linkedMessage != null && !message.contains(linkedMessage)) {\n\t\t\t\t\tmessage = message + \"; nested exception is \" + linkedEx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.support.JmsUtils#closeConnection(con)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close the given JMS Connection and ignore any thrown exception.\n\t * <p>This is useful for typical {@code finally} blocks in manual JMS code.\n\t * @param con the JMS Connection to close (may be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "void",
    "signature": "public void closeConnection(@Nullable Connection con)",
    "source_code": "\tpublic static void closeConnection(@Nullable Connection con) {\n\t\tcloseConnection(con, false);\n\t}"
  },
  "org.springframework.jms.support.JmsUtils#closeConnection(con,stop)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close the given JMS Connection and ignore any thrown exception.\n\t * <p>This is useful for typical {@code finally} blocks in manual JMS code.\n\t * @param con the JMS Connection to close (may be {@code null})\n\t * @param stop whether to call {@code stop()} before closing\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "stop"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "public void closeConnection(@Nullable Connection con, boolean stop)",
    "source_code": "\tpublic static void closeConnection(@Nullable Connection con, boolean stop) {\n\t\tif (con != null) {\n\t\t\ttry {\n\t\t\t\tif (stop) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcon.stop();\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tcon.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcon.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (jakarta.jms.IllegalStateException ex) {\n\t\t\t\tlogger.debug(\"Ignoring Connection state exception - assuming already closed: \" + ex);\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tlogger.debug(\"Could not close JMS Connection\", ex);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// We don't trust the JMS provider: It might throw RuntimeException or Error.\n\t\t\t\tlogger.debug(\"Unexpected exception on closing JMS Connection\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.JmsUtils#closeMessageConsumer(consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close the given JMS MessageConsumer and ignore any thrown exception.\n\t * <p>This is useful for typical {@code finally} blocks in manual JMS code.\n\t * @param consumer the JMS MessageConsumer to close (may be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "void",
    "signature": "public void closeMessageConsumer(@Nullable MessageConsumer consumer)",
    "source_code": "\tpublic static void closeMessageConsumer(@Nullable MessageConsumer consumer) {\n\t\tif (consumer != null) {\n\t\t\t// Clear interruptions to ensure that the consumer closes successfully...\n\t\t\t// (working around misbehaving JMS providers such as ActiveMQ)\n\t\t\tboolean wasInterrupted = Thread.interrupted();\n\t\t\ttry {\n\t\t\t\tconsumer.close();\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tlogger.trace(\"Could not close JMS MessageConsumer\", ex);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// We don't trust the JMS provider: It might throw RuntimeException or Error.\n\t\t\t\tlogger.trace(\"Unexpected exception on closing JMS MessageConsumer\", ex);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (wasInterrupted) {\n\t\t\t\t\t// Reset the interrupted flag as it was before.\n\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.JmsUtils#closeMessageProducer(producer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close the given JMS MessageProducer and ignore any thrown exception.\n\t * <p>This is useful for typical {@code finally} blocks in manual JMS code.\n\t * @param producer the JMS MessageProducer to close (may be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void closeMessageProducer(@Nullable MessageProducer producer)",
    "source_code": "\tpublic static void closeMessageProducer(@Nullable MessageProducer producer) {\n\t\tif (producer != null) {\n\t\t\ttry {\n\t\t\t\tproducer.close();\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tlogger.trace(\"Could not close JMS MessageProducer\", ex);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// We don't trust the JMS provider: It might throw RuntimeException or Error.\n\t\t\t\tlogger.trace(\"Unexpected exception on closing JMS MessageProducer\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.JmsUtils#closeQueueBrowser(browser)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close the given JMS QueueBrowser and ignore any thrown exception.\n\t * <p>This is useful for typical {@code finally} blocks in manual JMS code.\n\t * @param browser the JMS QueueBrowser to close (may be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "browser"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "void",
    "signature": "public void closeQueueBrowser(@Nullable QueueBrowser browser)",
    "source_code": "\tpublic static void closeQueueBrowser(@Nullable QueueBrowser browser) {\n\t\tif (browser != null) {\n\t\t\ttry {\n\t\t\t\tbrowser.close();\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tlogger.trace(\"Could not close JMS QueueBrowser\", ex);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// We don't trust the JMS provider: It might throw RuntimeException or Error.\n\t\t\t\tlogger.trace(\"Unexpected exception on closing JMS QueueBrowser\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.JmsUtils#closeQueueRequestor(requestor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close the given JMS QueueRequestor and ignore any thrown exception.\n\t * <p>This is useful for typical {@code finally} blocks in manual JMS code.\n\t * @param requestor the JMS QueueRequestor to close (may be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestor"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "void",
    "signature": "public void closeQueueRequestor(@Nullable QueueRequestor requestor)",
    "source_code": "\tpublic static void closeQueueRequestor(@Nullable QueueRequestor requestor) {\n\t\tif (requestor != null) {\n\t\t\ttry {\n\t\t\t\trequestor.close();\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tlogger.trace(\"Could not close JMS QueueRequestor\", ex);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// We don't trust the JMS provider: It might throw RuntimeException or Error.\n\t\t\t\tlogger.trace(\"Unexpected exception on closing JMS QueueRequestor\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.JmsUtils#closeSession(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close the given JMS Session and ignore any thrown exception.\n\t * <p>This is useful for typical {@code finally} blocks in manual JMS code.\n\t * @param session the JMS Session to close (may be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "void",
    "signature": "public void closeSession(@Nullable Session session)",
    "source_code": "\tpublic static void closeSession(@Nullable Session session) {\n\t\tif (session != null) {\n\t\t\ttry {\n\t\t\t\tsession.close();\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tlogger.trace(\"Could not close JMS Session\", ex);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// We don't trust the JMS provider: It might throw RuntimeException or Error.\n\t\t\t\tlogger.trace(\"Unexpected exception on closing JMS Session\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.JmsUtils#commitIfNecessary(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Commit the Session if not within a JTA transaction.\n\t * @param session the JMS Session to commit\n\t * @throws JMSException if committing failed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "public void commitIfNecessary(Session session)",
    "source_code": "\tpublic static void commitIfNecessary(Session session) throws JMSException {\n\t\tAssert.notNull(session, \"Session must not be null\");\n\t\ttry {\n\t\t\tsession.commit();\n\t\t}\n\t\tcatch (jakarta.jms.TransactionInProgressException | jakarta.jms.IllegalStateException ex) {\n\t\t\t// Ignore -> can only happen in case of a JTA transaction.\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.JmsUtils#convertJmsAccessException(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the specified checked {@link jakarta.jms.JMSException JMSException} to a\n\t * Spring runtime {@link org.springframework.jms.JmsException JmsException} equivalent.\n\t * @param ex the original checked JMSException to convert\n\t * @return the Spring runtime JmsException wrapping the given exception\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "JmsException",
    "signature": "public JmsException convertJmsAccessException(JMSException ex)",
    "source_code": "\tpublic static JmsException convertJmsAccessException(JMSException ex) {\n\t\tAssert.notNull(ex, \"JMSException must not be null\");\n\n\t\tif (ex instanceof jakarta.jms.IllegalStateException jakartaISE) {\n\t\t\treturn new org.springframework.jms.IllegalStateException(jakartaISE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.InvalidClientIDException jakartaICIDE) {\n\t\t\treturn new InvalidClientIDException(jakartaICIDE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.InvalidDestinationException jakartaIDE) {\n\t\t\treturn new InvalidDestinationException(jakartaIDE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.InvalidSelectorException jakartaISE) {\n\t\t\treturn new InvalidSelectorException(jakartaISE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.JMSSecurityException jakartaJMSSE) {\n\t\t\treturn new JmsSecurityException(jakartaJMSSE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.MessageEOFException jakartaMEOFE) {\n\t\t\treturn new MessageEOFException(jakartaMEOFE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.MessageFormatException jakartaMFE) {\n\t\t\treturn new MessageFormatException(jakartaMFE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.MessageNotReadableException jakartaMNRE) {\n\t\t\treturn new MessageNotReadableException(jakartaMNRE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.MessageNotWriteableException jakartaMNWE) {\n\t\t\treturn new MessageNotWriteableException(jakartaMNWE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.ResourceAllocationException jakartaRAE) {\n\t\t\treturn new ResourceAllocationException(jakartaRAE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.TransactionInProgressException jakartaTIPE) {\n\t\t\treturn new TransactionInProgressException(jakartaTIPE);\n\t\t}\n\t\tif (ex instanceof jakarta.jms.TransactionRolledBackException jakartaTRBE) {\n\t\t\treturn new TransactionRolledBackException(jakartaTRBE);\n\t\t}\n\n\t\t// fallback\n\t\treturn new UncategorizedJmsException(ex);\n\t}"
  },
  "org.springframework.jms.support.JmsUtils#rollbackIfNecessary(session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Roll back the Session if not within a JTA transaction.\n\t * @param session the JMS Session to rollback\n\t * @throws JMSException if committing failed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "void",
    "signature": "public void rollbackIfNecessary(Session session)",
    "source_code": "\tpublic static void rollbackIfNecessary(Session session) throws JMSException {\n\t\tAssert.notNull(session, \"Session must not be null\");\n\t\ttry {\n\t\t\tsession.rollback();\n\t\t}\n\t\tcatch (jakarta.jms.TransactionInProgressException | jakarta.jms.IllegalStateException ex) {\n\t\t\t// Ignore -> can only happen in case of a JTA transaction.\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.SimpleJmsHeaderMapper": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Simple implementation of {@link JmsHeaderMapper}.\n *\n * <p>This implementation copies JMS API headers (e.g. JMSReplyTo) to and from\n * {@link org.springframework.messaging.Message Messages}. Any user-defined\n * properties will also be copied from a JMS Message to a Message, and any\n * other headers on a Message (beyond the JMS API headers) will likewise\n * be copied to a JMS Message. Those other headers will be copied to the\n * general properties of a JMS Message whereas the JMS API headers are passed\n * to the appropriate setter methods (e.g. setJMSReplyTo).\n *\n * <p>Constants for the JMS API headers are defined in {@link JmsHeaders}.\n * Note that most of the JMS headers are read-only: the JMSDestination,\n * JMSDeliveryMode, JMSExpiration, JMSMessageID, JMSPriority, JMSRedelivered\n * and JMSTimestamp flags are only copied <em>from</em> a JMS Message. Those\n * values will <em>not</em> be passed along from a Message to an outbound\n * JMS Message.\n *\n * @author Mark Fisher\n * @author Gary Russell\n * @author Stephane Nicoll\n * @since 4.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public class SimpleJmsHeaderMapper",
    "source_code": "public class SimpleJmsHeaderMapper extends AbstractHeaderMapper<Message> implements JmsHeaderMapper {\n\n\tprivate static final Set<Class<?>> SUPPORTED_PROPERTY_TYPES = Set.of(Boolean.class, Byte.class,\n\t\t\tDouble.class, Float.class, Integer.class, Long.class, Short.class, String.class, byte[].class);\n\n\n\t@Override\n\tpublic void fromHeaders(MessageHeaders headers, jakarta.jms.Message jmsMessage) {\n\t\ttry {\n\t\t\tObject jmsCorrelationId = headers.get(JmsHeaders.CORRELATION_ID);\n\t\t\tif (jmsCorrelationId instanceof Number) {\n\t\t\t\tjmsCorrelationId = jmsCorrelationId.toString();\n\t\t\t}\n\t\t\tif (jmsCorrelationId instanceof String correlationId) {\n\t\t\t\ttry {\n\t\t\t\t\tjmsMessage.setJMSCorrelationID(correlationId);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tlogger.debug(\"Failed to set JMSCorrelationID - skipping\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tDestination jmsReplyTo = getHeaderIfAvailable(headers, JmsHeaders.REPLY_TO, Destination.class);\n\t\t\tif (jmsReplyTo != null) {\n\t\t\t\ttry {\n\t\t\t\t\tjmsMessage.setJMSReplyTo(jmsReplyTo);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tlogger.debug(\"Failed to set JMSReplyTo - skipping\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tString jmsType = getHeaderIfAvailable(headers, JmsHeaders.TYPE, String.class);\n\t\t\tif (jmsType != null) {\n\t\t\t\ttry {\n\t\t\t\t\tjmsMessage.setJMSType(jmsType);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tlogger.debug(\"Failed to set JMSType - skipping\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Map.Entry<String, Object> entry : headers.entrySet()) {\n\t\t\t\tString headerName = entry.getKey();\n\t\t\t\tif (StringUtils.hasText(headerName) && !headerName.startsWith(JmsHeaders.PREFIX)) {\n\t\t\t\t\tObject value = entry.getValue();\n\t\t\t\t\tif (value != null && SUPPORTED_PROPERTY_TYPES.contains(value.getClass())) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString propertyName = fromHeaderName(headerName);\n\t\t\t\t\t\t\tjmsMessage.setObjectProperty(propertyName, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (headerName.startsWith(\"JMSX\")) {\n\t\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.trace(\"Skipping reserved header '\" + headerName +\n\t\t\t\t\t\t\t\t\t\t\t\"' since it cannot be set by client\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Failed to map message header '\" + headerName + \"' to JMS property\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Error occurred while mapping from MessageHeaders to JMS properties\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic MessageHeaders toHeaders(jakarta.jms.Message jmsMessage) {\n\t\tMap<String, Object> headers = new HashMap<>();\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tString correlationId = jmsMessage.getJMSCorrelationID();\n\t\t\t\tif (correlationId != null) {\n\t\t\t\t\theaders.put(JmsHeaders.CORRELATION_ID, correlationId);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.debug(\"Failed to read JMSCorrelationID property - skipping\", ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tDestination destination = jmsMessage.getJMSDestination();\n\t\t\t\tif (destination != null) {\n\t\t\t\t\theaders.put(JmsHeaders.DESTINATION, destination);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.debug(\"Failed to read JMSDestination property - skipping\", ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tint deliveryMode = jmsMessage.getJMSDeliveryMode();\n\t\t\t\theaders.put(JmsHeaders.DELIVERY_MODE, deliveryMode);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.debug(\"Failed to read JMSDeliveryMode property - skipping\", ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tlong expiration = jmsMessage.getJMSExpiration();\n\t\t\t\theaders.put(JmsHeaders.EXPIRATION, expiration);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.debug(\"Failed to read JMSExpiration property - skipping\", ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tString messageId = jmsMessage.getJMSMessageID();\n\t\t\t\tif (messageId != null) {\n\t\t\t\t\theaders.put(JmsHeaders.MESSAGE_ID, messageId);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.debug(\"Failed to read JMSMessageID property - skipping\", ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\theaders.put(JmsHeaders.PRIORITY, jmsMessage.getJMSPriority());\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.debug(\"Failed to read JMSPriority property - skipping\", ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tDestination replyTo = jmsMessage.getJMSReplyTo();\n\t\t\t\tif (replyTo != null) {\n\t\t\t\t\theaders.put(JmsHeaders.REPLY_TO, replyTo);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.debug(\"Failed to read JMSReplyTo property - skipping\", ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\theaders.put(JmsHeaders.REDELIVERED, jmsMessage.getJMSRedelivered());\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.debug(\"Failed to read JMSRedelivered property - skipping\", ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tString type = jmsMessage.getJMSType();\n\t\t\t\tif (type != null) {\n\t\t\t\t\theaders.put(JmsHeaders.TYPE, type);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.debug(\"Failed to read JMSType property - skipping\", ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\theaders.put(JmsHeaders.TIMESTAMP, jmsMessage.getJMSTimestamp());\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.debug(\"Failed to read JMSTimestamp property - skipping\", ex);\n\t\t\t}\n\n\t\t\tEnumeration<?> jmsPropertyNames = jmsMessage.getPropertyNames();\n\t\t\tif (jmsPropertyNames != null) {\n\t\t\t\twhile (jmsPropertyNames.hasMoreElements()) {\n\t\t\t\t\tString propertyName = jmsPropertyNames.nextElement().toString();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString headerName = toHeaderName(propertyName);\n\t\t\t\t\t\theaders.put(headerName, jmsMessage.getObjectProperty(propertyName));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Error occurred while mapping JMS property '\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"' to Message header\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (JMSException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Error occurred while mapping from JMS properties to MessageHeaders\", ex);\n\t\t\t}\n\t\t}\n\t\treturn new MessageHeaders(headers);\n\t}\n\n\t/**\n\t * Add the outbound prefix if necessary.\n\t * <p>Convert {@link MessageHeaders#CONTENT_TYPE} to {@code content_type} for JMS compliance.\n\t * @see #CONTENT_TYPE_PROPERTY\n\t */\n\t@Override\n\tprotected String fromHeaderName(String headerName) {\n\t\tif (MessageHeaders.CONTENT_TYPE.equals(headerName)) {\n\t\t\treturn CONTENT_TYPE_PROPERTY;\n\t\t}\n\t\treturn super.fromHeaderName(headerName);\n\t}\n\n\t/**\n\t * Add the inbound prefix if necessary.\n\t * <p>Convert the JMS-compliant {@code content_type} to {@link MessageHeaders#CONTENT_TYPE}.\n\t * @see #CONTENT_TYPE_PROPERTY\n\t */\n\t@Override\n\tprotected String toHeaderName(String propertyName) {\n\t\tif (CONTENT_TYPE_PROPERTY.equals(propertyName)) {\n\t\t\treturn MessageHeaders.CONTENT_TYPE;\n\t\t}\n\t\treturn super.toHeaderName(propertyName);\n\t}\n\n}"
  },
  "org.springframework.jms.support.SimpleJmsHeaderMapper#fromHeaderName(headerName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the outbound prefix if necessary.\n\t * <p>Convert {@link MessageHeaders#CONTENT_TYPE} to {@code content_type} for JMS compliance.\n\t * @see #CONTENT_TYPE_PROPERTY\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headerName"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "String",
    "signature": "protected String fromHeaderName(String headerName)",
    "source_code": "\tprotected String fromHeaderName(String headerName) {\n\t\tif (MessageHeaders.CONTENT_TYPE.equals(headerName)) {\n\t\t\treturn CONTENT_TYPE_PROPERTY;\n\t\t}\n\t\treturn super.fromHeaderName(headerName);\n\t}"
  },
  "org.springframework.jms.support.SimpleJmsHeaderMapper#fromHeaders(headers,jmsMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headers",
      "jmsMessage"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "public void fromHeaders(MessageHeaders headers, jakarta.jms.Message jmsMessage)",
    "source_code": "\tpublic void fromHeaders(MessageHeaders headers, jakarta.jms.Message jmsMessage) {\n\t\ttry {\n\t\t\tObject jmsCorrelationId = headers.get(JmsHeaders.CORRELATION_ID);\n\t\t\tif (jmsCorrelationId instanceof Number) {\n\t\t\t\tjmsCorrelationId = jmsCorrelationId.toString();\n\t\t\t}\n\t\t\tif (jmsCorrelationId instanceof String correlationId) {\n\t\t\t\ttry {\n\t\t\t\t\tjmsMessage.setJMSCorrelationID(correlationId);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tlogger.debug(\"Failed to set JMSCorrelationID - skipping\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tDestination jmsReplyTo = getHeaderIfAvailable(headers, JmsHeaders.REPLY_TO, Destination.class);\n\t\t\tif (jmsReplyTo != null) {\n\t\t\t\ttry {\n\t\t\t\t\tjmsMessage.setJMSReplyTo(jmsReplyTo);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tlogger.debug(\"Failed to set JMSReplyTo - skipping\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tString jmsType = getHeaderIfAvailable(headers, JmsHeaders.TYPE, String.class);\n\t\t\tif (jmsType != null) {\n\t\t\t\ttry {\n\t\t\t\t\tjmsMessage.setJMSType(jmsType);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tlogger.debug(\"Failed to set JMSType - skipping\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Map.Entry<String, Object> entry : headers.entrySet()) {\n\t\t\t\tString headerName = entry.getKey();\n\t\t\t\tif (StringUtils.hasText(headerName) && !headerName.startsWith(JmsHeaders.PREFIX)) {\n\t\t\t\t\tObject value = entry.getValue();\n\t\t\t\t\tif (value != null && SUPPORTED_PROPERTY_TYPES.contains(value.getClass())) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString propertyName = fromHeaderName(headerName);\n\t\t\t\t\t\t\tjmsMessage.setObjectProperty(propertyName, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (headerName.startsWith(\"JMSX\")) {\n\t\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.trace(\"Skipping reserved header '\" + headerName +\n\t\t\t\t\t\t\t\t\t\t\t\"' since it cannot be set by client\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Failed to map message header '\" + headerName + \"' to JMS property\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Error occurred while mapping from MessageHeaders to JMS properties\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.SimpleJmsHeaderMapper#toHeaderName(propertyName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the inbound prefix if necessary.\n\t * <p>Convert the JMS-compliant {@code content_type} to {@link MessageHeaders#CONTENT_TYPE}.\n\t * @see #CONTENT_TYPE_PROPERTY\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "String",
    "signature": "protected String toHeaderName(String propertyName)",
    "source_code": "\tprotected String toHeaderName(String propertyName) {\n\t\tif (CONTENT_TYPE_PROPERTY.equals(propertyName)) {\n\t\t\treturn MessageHeaders.CONTENT_TYPE;\n\t\t}\n\t\treturn super.toHeaderName(propertyName);\n\t}"
  },
  "org.springframework.jms.support.SimpleJmsHeaderMapper#toHeaders(jmsMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jmsMessage"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "MessageHeaders",
    "signature": "public MessageHeaders toHeaders(jakarta.jms.Message jmsMessage)",
    "source_code": "\tpublic MessageHeaders toHeaders(jakarta.jms.Message jmsMessage) {\n\t\tMap<String, Object> headers = new HashMap<>();\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tString correlationId = jmsMessage.getJMSCorrelationID();\n\t\t\t\tif (correlationId != null) {\n\t\t\t\t\theaders.put(JmsHeaders.CORRELATION_ID, correlationId);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.debug(\"Failed to read JMSCorrelationID property - skipping\", ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tDestination destination = jmsMessage.getJMSDestination();\n\t\t\t\tif (destination != null) {\n\t\t\t\t\theaders.put(JmsHeaders.DESTINATION, destination);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.debug(\"Failed to read JMSDestination property - skipping\", ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tint deliveryMode = jmsMessage.getJMSDeliveryMode();\n\t\t\t\theaders.put(JmsHeaders.DELIVERY_MODE, deliveryMode);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.debug(\"Failed to read JMSDeliveryMode property - skipping\", ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tlong expiration = jmsMessage.getJMSExpiration();\n\t\t\t\theaders.put(JmsHeaders.EXPIRATION, expiration);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.debug(\"Failed to read JMSExpiration property - skipping\", ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tString messageId = jmsMessage.getJMSMessageID();\n\t\t\t\tif (messageId != null) {\n\t\t\t\t\theaders.put(JmsHeaders.MESSAGE_ID, messageId);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.debug(\"Failed to read JMSMessageID property - skipping\", ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\theaders.put(JmsHeaders.PRIORITY, jmsMessage.getJMSPriority());\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.debug(\"Failed to read JMSPriority property - skipping\", ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tDestination replyTo = jmsMessage.getJMSReplyTo();\n\t\t\t\tif (replyTo != null) {\n\t\t\t\t\theaders.put(JmsHeaders.REPLY_TO, replyTo);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.debug(\"Failed to read JMSReplyTo property - skipping\", ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\theaders.put(JmsHeaders.REDELIVERED, jmsMessage.getJMSRedelivered());\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.debug(\"Failed to read JMSRedelivered property - skipping\", ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tString type = jmsMessage.getJMSType();\n\t\t\t\tif (type != null) {\n\t\t\t\t\theaders.put(JmsHeaders.TYPE, type);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.debug(\"Failed to read JMSType property - skipping\", ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\theaders.put(JmsHeaders.TIMESTAMP, jmsMessage.getJMSTimestamp());\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.debug(\"Failed to read JMSTimestamp property - skipping\", ex);\n\t\t\t}\n\n\t\t\tEnumeration<?> jmsPropertyNames = jmsMessage.getPropertyNames();\n\t\t\tif (jmsPropertyNames != null) {\n\t\t\t\twhile (jmsPropertyNames.hasMoreElements()) {\n\t\t\t\t\tString propertyName = jmsPropertyNames.nextElement().toString();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString headerName = toHeaderName(propertyName);\n\t\t\t\t\t\theaders.put(headerName, jmsMessage.getObjectProperty(propertyName));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Error occurred while mapping JMS property '\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"' to Message header\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (JMSException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Error occurred while mapping from JMS properties to MessageHeaders\", ex);\n\t\t\t}\n\t\t}\n\t\treturn new MessageHeaders(headers);\n\t}"
  },
  "org.springframework.jms.support.converter.SimpleMessageConverter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A simple message converter which is able to handle TextMessages, BytesMessages,\n * MapMessages, and ObjectMessages. Used as default conversion strategy\n * by {@link org.springframework.jms.core.JmsTemplate}, for\n * {@code convertAndSend} and {@code receiveAndConvert} operations.\n *\n * <p>Converts a String to a {@link jakarta.jms.TextMessage}, a byte array to a\n * {@link jakarta.jms.BytesMessage}, a Map to a {@link jakarta.jms.MapMessage}, and\n * a Serializable object to a {@link jakarta.jms.ObjectMessage} (or vice versa).\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 1.1\n * @see org.springframework.jms.core.JmsTemplate#convertAndSend\n * @see org.springframework.jms.core.JmsTemplate#receiveAndConvert\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class SimpleMessageConverter",
    "source_code": "public class SimpleMessageConverter implements MessageConverter {\n\n\t/**\n\t * This implementation creates a TextMessage for a String, a\n\t * BytesMessage for a byte array, a MapMessage for a Map,\n\t * and an ObjectMessage for a Serializable object.\n\t * @see #createMessageForString\n\t * @see #createMessageForByteArray\n\t * @see #createMessageForMap\n\t * @see #createMessageForSerializable\n\t */\n\t@Override\n\tpublic Message toMessage(Object object, Session session) throws JMSException, MessageConversionException {\n\t\tif (object instanceof Message message) {\n\t\t\treturn message;\n\t\t}\n\t\telse if (object instanceof String text) {\n\t\t\treturn createMessageForString(text, session);\n\t\t}\n\t\telse if (object instanceof byte[] bytes) {\n\t\t\treturn createMessageForByteArray(bytes, session);\n\t\t}\n\t\telse if (object instanceof Map<?, ?> map) {\n\t\t\treturn createMessageForMap(map, session);\n\t\t}\n\t\telse if (object instanceof Serializable serializable) {\n\t\t\treturn createMessageForSerializable(serializable, session);\n\t\t}\n\t\telse {\n\t\t\tthrow new MessageConversionException(\"Cannot convert object of type [\" +\n\t\t\t\t\tObjectUtils.nullSafeClassName(object) + \"] to JMS message. Supported message \" +\n\t\t\t\t\t\"payloads are: String, byte array, Map<String,?>, Serializable object.\");\n\t\t}\n\t}\n\n\t/**\n\t * This implementation converts a TextMessage back to a String, a\n\t * ByteMessage back to a byte array, a MapMessage back to a Map,\n\t * and an ObjectMessage back to a Serializable object. Returns\n\t * the plain Message object in case of an unknown message type.\n\t * @see #extractStringFromMessage\n\t * @see #extractByteArrayFromMessage\n\t * @see #extractMapFromMessage\n\t * @see #extractSerializableFromMessage\n\t */\n\t@Override\n\tpublic Object fromMessage(Message message) throws JMSException, MessageConversionException {\n\t\tif (message instanceof TextMessage textMessage) {\n\t\t\treturn extractStringFromMessage(textMessage);\n\t\t}\n\t\telse if (message instanceof BytesMessage bytesMessage) {\n\t\t\treturn extractByteArrayFromMessage(bytesMessage);\n\t\t}\n\t\telse if (message instanceof MapMessage mapMessage) {\n\t\t\treturn extractMapFromMessage(mapMessage);\n\t\t}\n\t\telse if (message instanceof ObjectMessage objectMessage) {\n\t\t\treturn extractSerializableFromMessage(objectMessage);\n\t\t}\n\t\telse {\n\t\t\treturn message;\n\t\t}\n\t}\n\n\n\t/**\n\t * Create a JMS TextMessage for the given String.\n\t * @param text the String to convert\n\t * @param session current JMS session\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @see jakarta.jms.Session#createTextMessage\n\t */\n\tprotected TextMessage createMessageForString(String text, Session session) throws JMSException {\n\t\treturn session.createTextMessage(text);\n\t}\n\n\t/**\n\t * Create a JMS BytesMessage for the given byte array.\n\t * @param bytes the byte array to convert\n\t * @param session current JMS session\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @see jakarta.jms.Session#createBytesMessage\n\t */\n\tprotected BytesMessage createMessageForByteArray(byte[] bytes, Session session) throws JMSException {\n\t\tBytesMessage message = session.createBytesMessage();\n\t\tmessage.writeBytes(bytes);\n\t\treturn message;\n\t}\n\n\t/**\n\t * Create a JMS MapMessage for the given Map.\n\t * @param map the Map to convert\n\t * @param session current JMS session\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @see jakarta.jms.Session#createMapMessage\n\t */\n\tprotected MapMessage createMessageForMap(Map<?, ?> map, Session session) throws JMSException {\n\t\tMapMessage message = session.createMapMessage();\n\t\tfor (Map.Entry<?, ?> entry : map.entrySet()) {\n\t\t\tObject key = entry.getKey();\n\t\t\tif (!(key instanceof String str)) {\n\t\t\t\tthrow new MessageConversionException(\"Cannot convert non-String key of type [\" +\n\t\t\t\t\t\tObjectUtils.nullSafeClassName(key) + \"] to JMS MapMessage entry\");\n\t\t\t}\n\t\t\tmessage.setObject(str, entry.getValue());\n\t\t}\n\t\treturn message;\n\t}\n\n\t/**\n\t * Create a JMS ObjectMessage for the given Serializable object.\n\t * @param object the Serializable object to convert\n\t * @param session current JMS session\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @see jakarta.jms.Session#createObjectMessage\n\t */\n\tprotected ObjectMessage createMessageForSerializable(Serializable object, Session session) throws JMSException {\n\t\treturn session.createObjectMessage(object);\n\t}\n\n\n\t/**\n\t * Extract a String from the given TextMessage.\n\t * @param message the message to convert\n\t * @return the resulting String\n\t * @throws JMSException if thrown by JMS methods\n\t */\n\tprotected String extractStringFromMessage(TextMessage message) throws JMSException {\n\t\treturn message.getText();\n\t}\n\n\t/**\n\t * Extract a byte array from the given {@link BytesMessage}.\n\t * @param message the message to convert\n\t * @return the resulting byte array\n\t * @throws JMSException if thrown by JMS methods\n\t */\n\tprotected byte[] extractByteArrayFromMessage(BytesMessage message) throws JMSException {\n\t\tbyte[] bytes = new byte[(int) message.getBodyLength()];\n\t\tmessage.readBytes(bytes);\n\t\treturn bytes;\n\t}\n\n\t/**\n\t * Extract a Map from the given {@link MapMessage}.\n\t * @param message the message to convert\n\t * @return the resulting Map\n\t * @throws JMSException if thrown by JMS methods\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected Map<String, Object> extractMapFromMessage(MapMessage message) throws JMSException {\n\t\tMap<String, Object> map = new HashMap<>();\n\t\tEnumeration<String> en = message.getMapNames();\n\t\twhile (en.hasMoreElements()) {\n\t\t\tString key = en.nextElement();\n\t\t\tmap.put(key, message.getObject(key));\n\t\t}\n\t\treturn map;\n\t}\n\n\t/**\n\t * Extract a Serializable object from the given {@link ObjectMessage}.\n\t * @param message the message to convert\n\t * @return the resulting Serializable object\n\t * @throws JMSException if thrown by JMS methods\n\t */\n\tprotected Serializable extractSerializableFromMessage(ObjectMessage message) throws JMSException {\n\t\treturn message.getObject();\n\t}\n\n}"
  },
  "org.springframework.jms.support.converter.SimpleMessageConverter#createMessageForByteArray(bytes,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS BytesMessage for the given byte array.\n\t * @param bytes the byte array to convert\n\t * @param session current JMS session\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @see jakarta.jms.Session#createBytesMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bytes",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "BytesMessage",
    "signature": "protected BytesMessage createMessageForByteArray(byte[] bytes, Session session)",
    "source_code": "\tprotected BytesMessage createMessageForByteArray(byte[] bytes, Session session) throws JMSException {\n\t\tBytesMessage message = session.createBytesMessage();\n\t\tmessage.writeBytes(bytes);\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.support.converter.SimpleMessageConverter#createMessageForMap(Map<?,map,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MapMessage for the given Map.\n\t * @param map the Map to convert\n\t * @param session current JMS session\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @see jakarta.jms.Session#createMapMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<?",
      "map",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "MapMessage",
    "signature": "protected MapMessage createMessageForMap(Map<?, ?> map, Session session)",
    "source_code": "\tprotected MapMessage createMessageForMap(Map<?, ?> map, Session session) throws JMSException {\n\t\tMapMessage message = session.createMapMessage();\n\t\tfor (Map.Entry<?, ?> entry : map.entrySet()) {\n\t\t\tObject key = entry.getKey();\n\t\t\tif (!(key instanceof String str)) {\n\t\t\t\tthrow new MessageConversionException(\"Cannot convert non-String key of type [\" +\n\t\t\t\t\t\tObjectUtils.nullSafeClassName(key) + \"] to JMS MapMessage entry\");\n\t\t\t}\n\t\t\tmessage.setObject(str, entry.getValue());\n\t\t}\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.support.converter.SimpleMessageConverter#createMessageForSerializable(object,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS ObjectMessage for the given Serializable object.\n\t * @param object the Serializable object to convert\n\t * @param session current JMS session\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @see jakarta.jms.Session#createObjectMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "ObjectMessage",
    "signature": "protected ObjectMessage createMessageForSerializable(Serializable object, Session session)",
    "source_code": "\tprotected ObjectMessage createMessageForSerializable(Serializable object, Session session) throws JMSException {\n\t\treturn session.createObjectMessage(object);\n\t}"
  },
  "org.springframework.jms.support.converter.SimpleMessageConverter#createMessageForString(text,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS TextMessage for the given String.\n\t * @param text the String to convert\n\t * @param session current JMS session\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @see jakarta.jms.Session#createTextMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "text",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "TextMessage",
    "signature": "protected TextMessage createMessageForString(String text, Session session)",
    "source_code": "\tprotected TextMessage createMessageForString(String text, Session session) throws JMSException {\n\t\treturn session.createTextMessage(text);\n\t}"
  },
  "org.springframework.jms.support.converter.SimpleMessageConverter#extractByteArrayFromMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract a byte array from the given {@link BytesMessage}.\n\t * @param message the message to convert\n\t * @return the resulting byte array\n\t * @throws JMSException if thrown by JMS methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "byte[]",
    "signature": "protected byte[] extractByteArrayFromMessage(BytesMessage message)",
    "source_code": "\tprotected byte[] extractByteArrayFromMessage(BytesMessage message) throws JMSException {\n\t\tbyte[] bytes = new byte[(int) message.getBodyLength()];\n\t\tmessage.readBytes(bytes);\n\t\treturn bytes;\n\t}"
  },
  "org.springframework.jms.support.converter.SimpleMessageConverter#extractMapFromMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract a Map from the given {@link MapMessage}.\n\t * @param message the message to convert\n\t * @return the resulting Map\n\t * @throws JMSException if thrown by JMS methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "Object>",
    "signature": "protected Object> extractMapFromMessage(MapMessage message)",
    "source_code": "\tprotected Map<String, Object> extractMapFromMessage(MapMessage message) throws JMSException {\n\t\tMap<String, Object> map = new HashMap<>();\n\t\tEnumeration<String> en = message.getMapNames();\n\t\twhile (en.hasMoreElements()) {\n\t\t\tString key = en.nextElement();\n\t\t\tmap.put(key, message.getObject(key));\n\t\t}\n\t\treturn map;\n\t}"
  },
  "org.springframework.jms.support.converter.SimpleMessageConverter#extractSerializableFromMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract a Serializable object from the given {@link ObjectMessage}.\n\t * @param message the message to convert\n\t * @return the resulting Serializable object\n\t * @throws JMSException if thrown by JMS methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "Serializable",
    "signature": "protected Serializable extractSerializableFromMessage(ObjectMessage message)",
    "source_code": "\tprotected Serializable extractSerializableFromMessage(ObjectMessage message) throws JMSException {\n\t\treturn message.getObject();\n\t}"
  },
  "org.springframework.jms.support.converter.SimpleMessageConverter#extractStringFromMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract a String from the given TextMessage.\n\t * @param message the message to convert\n\t * @return the resulting String\n\t * @throws JMSException if thrown by JMS methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "String",
    "signature": "protected String extractStringFromMessage(TextMessage message)",
    "source_code": "\tprotected String extractStringFromMessage(TextMessage message) throws JMSException {\n\t\treturn message.getText();\n\t}"
  },
  "org.springframework.jms.support.converter.SimpleMessageConverter#fromMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation converts a TextMessage back to a String, a\n\t * ByteMessage back to a byte array, a MapMessage back to a Map,\n\t * and an ObjectMessage back to a Serializable object. Returns\n\t * the plain Message object in case of an unknown message type.\n\t * @see #extractStringFromMessage\n\t * @see #extractByteArrayFromMessage\n\t * @see #extractMapFromMessage\n\t * @see #extractSerializableFromMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "Object",
    "signature": "public Object fromMessage(Message message)",
    "source_code": "\tpublic Object fromMessage(Message message) throws JMSException, MessageConversionException {\n\t\tif (message instanceof TextMessage textMessage) {\n\t\t\treturn extractStringFromMessage(textMessage);\n\t\t}\n\t\telse if (message instanceof BytesMessage bytesMessage) {\n\t\t\treturn extractByteArrayFromMessage(bytesMessage);\n\t\t}\n\t\telse if (message instanceof MapMessage mapMessage) {\n\t\t\treturn extractMapFromMessage(mapMessage);\n\t\t}\n\t\telse if (message instanceof ObjectMessage objectMessage) {\n\t\t\treturn extractSerializableFromMessage(objectMessage);\n\t\t}\n\t\telse {\n\t\t\treturn message;\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.converter.SimpleMessageConverter#toMessage(object,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation creates a TextMessage for a String, a\n\t * BytesMessage for a byte array, a MapMessage for a Map,\n\t * and an ObjectMessage for a Serializable object.\n\t * @see #createMessageForString\n\t * @see #createMessageForByteArray\n\t * @see #createMessageForMap\n\t * @see #createMessageForSerializable\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "Message",
    "signature": "public Message toMessage(Object object, Session session)",
    "source_code": "\tpublic Message toMessage(Object object, Session session) throws JMSException, MessageConversionException {\n\t\tif (object instanceof Message message) {\n\t\t\treturn message;\n\t\t}\n\t\telse if (object instanceof String text) {\n\t\t\treturn createMessageForString(text, session);\n\t\t}\n\t\telse if (object instanceof byte[] bytes) {\n\t\t\treturn createMessageForByteArray(bytes, session);\n\t\t}\n\t\telse if (object instanceof Map<?, ?> map) {\n\t\t\treturn createMessageForMap(map, session);\n\t\t}\n\t\telse if (object instanceof Serializable serializable) {\n\t\t\treturn createMessageForSerializable(serializable, session);\n\t\t}\n\t\telse {\n\t\t\tthrow new MessageConversionException(\"Cannot convert object of type [\" +\n\t\t\t\t\tObjectUtils.nullSafeClassName(object) + \"] to JMS message. Supported message \" +\n\t\t\t\t\t\"payloads are: String, byte array, Map<String,?>, Serializable object.\");\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.AUTODETECT_ALL": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Autodetection mode indicating that all autodetection mechanisms should be used.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "signature": "public int AUTODETECT_ALL",
    "source_code": "\tpublic static final int AUTODETECT_ALL = AUTODETECT_MBEAN | AUTODETECT_ASSEMBLER;",
    "type": "int"
  },
  "org.springframework.jmx.export.AUTODETECT_ASSEMBLER": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Autodetection mode indicating that only the {@link MBeanInfoAssembler} should be able\n\t * to autodetect beans.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "signature": "public int AUTODETECT_ASSEMBLER",
    "source_code": "\tpublic static final int AUTODETECT_ASSEMBLER = 2;",
    "type": "int"
  },
  "org.springframework.jmx.export.AUTODETECT_MBEAN": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Autodetection mode indicating that only valid MBeans should be autodetected.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "signature": "public int AUTODETECT_MBEAN",
    "source_code": "\tpublic static final int AUTODETECT_MBEAN = 1;",
    "type": "int"
  },
  "org.springframework.jmx.export.AUTODETECT_NONE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Autodetection mode indicating that no autodetection should be used.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "signature": "public int AUTODETECT_NONE",
    "source_code": "\tpublic static final int AUTODETECT_NONE = 0;",
    "type": "int"
  },
  "org.springframework.jmx.export.MBeanExporter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * JMX exporter that allows for exposing any <i>Spring-managed bean</i> to a\n * JMX {@link javax.management.MBeanServer}, without the need to define any\n * JMX-specific information in the bean classes.\n *\n * <p>If a bean implements one of the JMX management interfaces, MBeanExporter can\n * simply register the MBean with the server through its autodetection process.\n *\n * <p>If a bean does not implement one of the JMX management interfaces, MBeanExporter\n * will create the management information using the supplied {@link MBeanInfoAssembler}.\n *\n * <p>A list of {@link MBeanExporterListener MBeanExporterListeners} can be registered\n * via the {@link #setListeners(MBeanExporterListener[]) listeners} property, allowing\n * application code to be notified of MBean registration and unregistration events.\n *\n * <p>This exporter is compatible with MBeans as well as MXBeans.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Rick Evans\n * @author Mark Fisher\n * @author Stephane Nicoll\n * @since 1.2\n * @see #setBeans\n * @see #setAutodetect\n * @see #setAssembler\n * @see #setListeners\n * @see org.springframework.jmx.export.assembler.MBeanInfoAssembler\n * @see MBeanExporterListener\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "signature": "public class MBeanExporter",
    "source_code": "public class MBeanExporter extends MBeanRegistrationSupport implements MBeanExportOperations,"
  },
  "org.springframework.jmx.export.MBeanExporter#adaptMBeanIfPossible(bean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build an adapted MBean for the given bean instance, if possible.\n\t * <p>The default implementation builds a JMX 1.2 StandardMBean\n\t * for the target's MBean/MXBean interface in case of an AOP proxy,\n\t * delegating the interface's management operations to the proxy.\n\t * @param bean the original bean instance\n\t * @return the adapted MBean, or {@code null} if not possible\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 783
    },
    "return": "DynamicMBean",
    "signature": "protected DynamicMBean adaptMBeanIfPossible(Object bean)",
    "source_code": "\tprotected DynamicMBean adaptMBeanIfPossible(Object bean) throws JMException {\n\t\tClass<?> targetClass = AopUtils.getTargetClass(bean);\n\t\tif (targetClass != bean.getClass()) {\n\t\t\tClass<?> ifc = JmxUtils.getMXBeanInterface(targetClass);\n\t\t\tif (ifc != null) {\n\t\t\t\tif (!ifc.isInstance(bean)) {\n\t\t\t\t\tthrow new NotCompliantMBeanException(\"Managed bean [\" + bean +\n\t\t\t\t\t\t\t\"] has a target class with an MXBean interface but does not expose it in the proxy\");\n\t\t\t\t}\n\t\t\t\treturn new StandardMBean(bean, ((Class<Object>) ifc), true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tifc = JmxUtils.getMBeanInterface(targetClass);\n\t\t\t\tif (ifc != null) {\n\t\t\t\t\tif (!ifc.isInstance(bean)) {\n\t\t\t\t\t\tthrow new NotCompliantMBeanException(\"Managed bean [\" + bean +\n\t\t\t\t\t\t\t\t\"] has a target class with an MBean interface but does not expose it in the proxy\");\n\t\t\t\t\t}\n\t\t\t\t\treturn new StandardMBean(bean, ((Class<Object>) ifc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#addExcludedBean(excludedBean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the name of bean that should be excluded from autodetection.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "excludedBean"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "void",
    "signature": "public void addExcludedBean(String excludedBean)",
    "source_code": "\tpublic void addExcludedBean(String excludedBean) {\n\t\tAssert.notNull(excludedBean, \"ExcludedBean must not be null\");\n\t\tthis.excludedBeans.add(excludedBean);\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 419
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\t// If no server was provided then try to find one. This is useful in an environment\n\t\t// where there is already an MBeanServer loaded.\n\t\tif (this.server == null) {\n\t\t\tthis.server = JmxUtils.locateMBeanServer();\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#afterSingletonsInstantiated()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Kick off bean registration automatically after the regular singleton instantiation phase.\n\t * @see #registerBeans()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "void",
    "signature": "public void afterSingletonsInstantiated()",
    "source_code": "\tpublic void afterSingletonsInstantiated() {\n\t\ttry {\n\t\t\tlogger.debug(\"Registering beans for JMX exposure on startup\");\n\t\t\tregisterBeans();\n\t\t\tregisterNotificationListeners();\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\t// Unregister beans already registered by this exporter.\n\t\t\tunregisterNotificationListeners();\n\t\t\tunregisterBeans();\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#createAndConfigureMBean(managedResource,beanKey)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Creates an MBean that is configured with the appropriate management\n\t * interface for the supplied managed resource.\n\t * @param managedResource the resource that is to be exported as an MBean\n\t * @param beanKey the key associated with the managed bean\n\t * @see #createModelMBean()\n\t * @see #getMBeanInfo(Object, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "managedResource",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 816
    },
    "return": "ModelMBean",
    "signature": "protected ModelMBean createAndConfigureMBean(Object managedResource, String beanKey)",
    "source_code": "\tprotected ModelMBean createAndConfigureMBean(Object managedResource, String beanKey)"
  },
  "org.springframework.jmx.export.MBeanExporter#createModelMBean()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance of a class that implements {@code ModelMBean}.\n\t * <p>This method is called to obtain a {@code ModelMBean} instance to\n\t * use when registering a bean. This method is called once per bean during the\n\t * registration phase and must return a new instance of {@code ModelMBean}\n\t * @return a new instance of a class that implements {@code ModelMBean}\n\t * @throws javax.management.MBeanException if creation of the ModelMBean failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 838
    },
    "return": "ModelMBean",
    "signature": "protected ModelMBean createModelMBean()",
    "source_code": "\tprotected ModelMBean createModelMBean() throws MBeanException {\n\t\treturn (this.exposeManagedResourceClassLoader ? new SpringModelMBean() : new RequiredModelMBean());\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Unregisters all beans that this exported has exposed via JMX\n\t * when the enclosing {@code ApplicationContext} is destroyed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 451
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t\tlogger.debug(\"Unregistering JMX-exposed beans on shutdown\");\n\t\tunregisterNotificationListeners();\n\t\tunregisterBeans();\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#getObjectName(bean,beanKey)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the {@code ObjectName} for a bean.\n\t * <p>If the bean implements the {@code SelfNaming} interface, then the\n\t * {@code ObjectName} will be retrieved using {@code SelfNaming.getObjectName()}.\n\t * Otherwise, the configured {@code ObjectNamingStrategy} is used.\n\t * @param bean the name of the bean in the {@code BeanFactory}\n\t * @param beanKey the key associated with the bean in the beans map\n\t * @return the {@code ObjectName} for the supplied bean\n\t * @throws javax.management.MalformedObjectNameException\n\t * if the retrieved {@code ObjectName} is malformed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 750
    },
    "return": "ObjectName",
    "signature": "protected ObjectName getObjectName(Object bean, @Nullable String beanKey)",
    "source_code": "\tprotected ObjectName getObjectName(Object bean, @Nullable String beanKey) throws MalformedObjectNameException {\n\t\tif (bean instanceof SelfNaming) {\n\t\t\treturn ((SelfNaming) bean).getObjectName();\n\t\t}\n\t\telse {\n\t\t\treturn this.namingStrategy.getObjectName(bean, beanKey);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#getTarget()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1101
    },
    "return": "Object",
    "signature": "public Object getTarget()",
    "source_code": "\t\tpublic Object getTarget() {\n\t\t\ttry {\n\t\t\t\treturn super.getTarget();\n\t\t\t}\n\t\t\tcatch (RuntimeException ex) {\n\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"Failed to retrieve target for JMX-exposed bean [\" + this.objectName + \"]: \" + ex);\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#isBeanDefinitionLazyInit(beanFactory,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the specified bean definition should be considered as lazy-init.\n\t * @param beanFactory the bean factory that is supposed to contain the bean definition\n\t * @param beanName the name of the bean to check\n\t * @see org.springframework.beans.factory.config.ConfigurableListableBeanFactory#getBeanDefinition\n\t * @see org.springframework.beans.factory.config.BeanDefinition#isLazyInit\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactory",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "boolean",
    "signature": "protected boolean isBeanDefinitionLazyInit(ListableBeanFactory beanFactory, String beanName)",
    "source_code": "\tprotected boolean isBeanDefinitionLazyInit(ListableBeanFactory beanFactory, String beanName) {\n\t\treturn (beanFactory instanceof ConfigurableListableBeanFactory && beanFactory.containsBeanDefinition(beanName) &&\n\t\t\t\t((ConfigurableListableBeanFactory) beanFactory).getBeanDefinition(beanName).isLazyInit());\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#isMBean(beanClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given bean class qualifies as an MBean as-is.\n\t * <p>The default implementation delegates to {@link JmxUtils#isMBean},\n\t * which checks for {@link javax.management.DynamicMBean} classes as well\n\t * as classes with corresponding \"*MBean\" interface (Standard MBeans)\n\t * or corresponding \"*MXBean\" interface (Java MXBeans).\n\t * @param beanClass the bean class to analyze\n\t * @return whether the class qualifies as an MBean\n\t * @see org.springframework.jmx.support.JmxUtils#isMBean(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass"
    ],
    "position": {
      "column": 1,
      "line": 769
    },
    "return": "boolean",
    "signature": "protected boolean isMBean(@Nullable Class<?> beanClass)",
    "source_code": "\tprotected boolean isMBean(@Nullable Class<?> beanClass) {\n\t\treturn JmxUtils.isMBean(beanClass);\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#onRegister(objectName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Called when an MBean is registered. Notifies all registered\n\t * {@link MBeanExporterListener MBeanExporterListeners} of the registration event.\n\t * <p>Please note that if an {@link MBeanExporterListener} throws a (runtime)\n\t * exception when notified, this will essentially interrupt the notification process\n\t * and any remaining listeners that have yet to be notified will not (obviously)\n\t * receive the {@link MBeanExporterListener#mbeanRegistered(javax.management.ObjectName)}\n\t * callback.\n\t * @param objectName the {@code ObjectName} of the registered MBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "objectName"
    ],
    "position": {
      "column": 1,
      "line": 1012
    },
    "return": "void",
    "signature": "protected void onRegister(ObjectName objectName)",
    "source_code": "\tprotected void onRegister(ObjectName objectName) {\n\t\tnotifyListenersOfRegistration(objectName);\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#onUnregister(objectName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Called when an MBean is unregistered. Notifies all registered\n\t * {@link MBeanExporterListener MBeanExporterListeners} of the unregistration event.\n\t * <p>Please note that if an {@link MBeanExporterListener} throws a (runtime)\n\t * exception when notified, this will essentially interrupt the notification process\n\t * and any remaining listeners that have yet to be notified will not (obviously)\n\t * receive the {@link MBeanExporterListener#mbeanUnregistered(javax.management.ObjectName)}\n\t * callback.\n\t * @param objectName the {@code ObjectName} of the unregistered MBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "objectName"
    ],
    "position": {
      "column": 1,
      "line": 1027
    },
    "return": "void",
    "signature": "protected void onUnregister(ObjectName objectName)",
    "source_code": "\tprotected void onUnregister(ObjectName objectName) {\n\t\tnotifyListenersOfUnregistration(objectName);\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#postProcessTargetObject(targetObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetObject"
    ],
    "position": {
      "column": 1,
      "line": 1114
    },
    "return": "void",
    "signature": "protected void postProcessTargetObject(Object targetObject)",
    "source_code": "\t\tprotected void postProcessTargetObject(Object targetObject) {\n\t\t\tinjectNotificationPublisherIfNecessary(targetObject, this.modelMBean, this.objectName);\n\t\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#registerBeanNameOrInstance(mapValue,beanKey)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register an individual bean with the {@link #setServer MBeanServer}.\n\t * <p>This method is responsible for deciding <strong>how</strong> a bean\n\t * should be exposed to the {@code MBeanServer}. Specifically, if the\n\t * supplied {@code mapValue} is the name of a bean that is configured\n\t * for lazy initialization, then a proxy to the resource is registered with\n\t * the {@code MBeanServer} so that the lazy load behavior is\n\t * honored. If the bean is already an MBean then it will be registered\n\t * directly with the {@code MBeanServer} without any intervention. For\n\t * all other beans or bean names, the resource itself is registered with\n\t * the {@code MBeanServer} directly.\n\t * @param mapValue the value configured for this bean in the beans map;\n\t * may be either the {@code String} name of a bean, or the bean itself\n\t * @param beanKey the key associated with this bean in the beans map\n\t * @return the {@code ObjectName} under which the resource was registered\n\t * @throws MBeanExportException if the export failed\n\t * @see #setBeans\n\t * @see #registerBeanInstance\n\t * @see #registerLazyInit\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapValue",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 588
    },
    "return": "ObjectName",
    "signature": "protected ObjectName registerBeanNameOrInstance(Object mapValue, String beanKey)",
    "source_code": "\tprotected ObjectName registerBeanNameOrInstance(Object mapValue, String beanKey) throws MBeanExportException {\n\t\ttry {\n\t\t\tif (mapValue instanceof String beanName) {\n\t\t\t\t// Bean name pointing to a potentially lazy-init bean in the factory.\n\t\t\t\tif (this.beanFactory == null) {\n\t\t\t\t\tthrow new MBeanExportException(\"Cannot resolve bean names if not running in a BeanFactory\");\n\t\t\t\t}\n\t\t\t\tif (isBeanDefinitionLazyInit(this.beanFactory, beanName)) {\n\t\t\t\t\tObjectName objectName = registerLazyInit(beanName, beanKey);\n\t\t\t\t\treplaceNotificationListenerBeanNameKeysIfNecessary(beanName, objectName);\n\t\t\t\t\treturn objectName;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tObject bean = this.beanFactory.getBean(beanName);\n\t\t\t\t\tObjectName objectName = registerBeanInstance(bean, beanKey);\n\t\t\t\t\treplaceNotificationListenerBeanNameKeysIfNecessary(beanName, objectName);\n\t\t\t\t\treturn objectName;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Plain bean instance -> register it directly.\n\t\t\t\tif (this.beanFactory != null) {\n\t\t\t\t\tMap<String, ?> beansOfSameType =\n\t\t\t\t\t\t\tthis.beanFactory.getBeansOfType(mapValue.getClass(), false, this.allowEagerInit);\n\t\t\t\t\tfor (Map.Entry<String, ?> entry : beansOfSameType.entrySet()) {\n\t\t\t\t\t\tif (entry.getValue() == mapValue) {\n\t\t\t\t\t\t\tString beanName = entry.getKey();\n\t\t\t\t\t\t\tObjectName objectName = registerBeanInstance(mapValue, beanKey);\n\t\t\t\t\t\t\treplaceNotificationListenerBeanNameKeysIfNecessary(beanName, objectName);\n\t\t\t\t\t\t\treturn objectName;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn registerBeanInstance(mapValue, beanKey);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new UnableToRegisterMBeanException(\n\t\t\t\t\t\"Unable to register MBean [\" + mapValue + \"] with key '\" + beanKey + \"'\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#registerBeans()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the defined beans with the {@link MBeanServer}.\n\t * <p>Each bean is exposed to the {@code MBeanServer} via a\n\t * {@code ModelMBean}. The actual implementation of the\n\t * {@code ModelMBean} interface used depends on the implementation of\n\t * the {@code ModelMBeanProvider} interface that is configured. By\n\t * default, the {@code RequiredModelMBean} class that is supplied with\n\t * all JMX implementations is used.\n\t * <p>The management interface produced for each bean is dependent on the\n\t * {@code MBeanInfoAssembler} implementation being used. The\n\t * {@code ObjectName} given to each bean is dependent on the\n\t * implementation of the {@code ObjectNamingStrategy} interface being used.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 523
    },
    "return": "void",
    "signature": "protected void registerBeans()",
    "source_code": "\tprotected void registerBeans() {\n\t\t// The beans property may be null, for example if we are relying solely on autodetection.\n\t\tif (this.beans == null) {\n\t\t\tthis.beans = new HashMap<>();\n\t\t\t// Use AUTODETECT_ALL as default in no beans specified explicitly.\n\t\t\tif (this.autodetectMode == null) {\n\t\t\t\tthis.autodetectMode = AUTODETECT_ALL;\n\t\t\t}\n\t\t}\n\n\t\t// Perform autodetection, if desired.\n\t\tint mode = (this.autodetectMode != null ? this.autodetectMode : AUTODETECT_NONE);\n\t\tif (mode != AUTODETECT_NONE) {\n\t\t\tif (this.beanFactory == null) {\n\t\t\t\tthrow new MBeanExportException(\"Cannot autodetect MBeans if not running in a BeanFactory\");\n\t\t\t}\n\t\t\tif (mode == AUTODETECT_MBEAN || mode == AUTODETECT_ALL) {\n\t\t\t\t// Autodetect any beans that are already MBeans.\n\t\t\t\tlogger.debug(\"Autodetecting user-defined JMX MBeans\");\n\t\t\t\tautodetect(this.beans, (beanClass, beanName) -> isMBean(beanClass));\n\t\t\t}\n\t\t\t// Allow the assembler a chance to vote for bean inclusion.\n\t\t\tif ((mode == AUTODETECT_ASSEMBLER || mode == AUTODETECT_ALL) &&\n\t\t\t\t\tthis.assembler instanceof AutodetectCapableMBeanInfoAssembler) {\n\t\t\t\tautodetect(this.beans, ((AutodetectCapableMBeanInfoAssembler) this.assembler)::includeBean);\n\t\t\t}\n\t\t}\n\n\t\tif (!this.beans.isEmpty()) {\n\t\t\tthis.beans.forEach((beanName, instance) -> registerBeanNameOrInstance(instance, beanName));\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#registerManagedResource(managedResource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "managedResource"
    ],
    "position": {
      "column": 1,
      "line": 463
    },
    "return": "ObjectName",
    "signature": "public ObjectName registerManagedResource(Object managedResource)",
    "source_code": "\tpublic ObjectName registerManagedResource(Object managedResource) throws MBeanExportException {\n\t\tAssert.notNull(managedResource, \"Managed resource must not be null\");\n\t\tObjectName objectName;\n\t\ttry {\n\t\t\tobjectName = getObjectName(managedResource, null);\n\t\t\tif (this.ensureUniqueRuntimeObjectNames) {\n\t\t\t\tobjectName = JmxUtils.appendIdentityToObjectName(objectName, managedResource);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new MBeanExportException(\"Unable to generate ObjectName for MBean [\" + managedResource + \"]\", ex);\n\t\t}\n\t\tregisterManagedResource(managedResource, objectName);\n\t\treturn objectName;\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#registerManagedResource(managedResource,objectName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "managedResource",
      "objectName"
    ],
    "position": {
      "column": 1,
      "line": 480
    },
    "return": "void",
    "signature": "public void registerManagedResource(Object managedResource, ObjectName objectName)",
    "source_code": "\tpublic void registerManagedResource(Object managedResource, ObjectName objectName) throws MBeanExportException {\n\t\tAssert.notNull(managedResource, \"Managed resource must not be null\");\n\t\tAssert.notNull(objectName, \"ObjectName must not be null\");\n\t\ttry {\n\t\t\tif (isMBean(managedResource.getClass())) {\n\t\t\t\tdoRegister(managedResource, objectName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tModelMBean mbean = createAndConfigureMBean(managedResource, managedResource.getClass().getName());\n\t\t\t\tdoRegister(mbean, objectName);\n\t\t\t\tinjectNotificationPublisherIfNecessary(managedResource, mbean, objectName);\n\t\t\t}\n\t\t}\n\t\tcatch (JMException ex) {\n\t\t\tthrow new UnableToRegisterMBeanException(\n\t\t\t\t\t\"Unable to register MBean [\" + managedResource + \"] with object name [\" + objectName + \"]\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#setAllowEagerInit(allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to allow eager initialization of candidate beans\n\t * when autodetecting MBeans in the Spring application context.\n\t * <p>Default is \"false\", respecting lazy-init flags on bean definitions.\n\t * Switch this to \"true\" in order to search lazy-init beans as well,\n\t * including FactoryBean-produced objects that haven't been initialized yet.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "void",
    "signature": "public void setAllowEagerInit(boolean allowEagerInit)",
    "source_code": "\tpublic void setAllowEagerInit(boolean allowEagerInit) {\n\t\tthis.allowEagerInit = allowEagerInit;\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#setAssembler(assembler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the implementation of the {@code MBeanInfoAssembler} interface to use\n\t * for this exporter. Default is a {@code SimpleReflectiveMBeanInfoAssembler}.\n\t * <p>The passed-in assembler can optionally implement the\n\t * {@code AutodetectCapableMBeanInfoAssembler} interface, which enables it\n\t * to participate in the exporter's MBean autodetection process.\n\t * @see org.springframework.jmx.export.assembler.SimpleReflectiveMBeanInfoAssembler\n\t * @see org.springframework.jmx.export.assembler.AutodetectCapableMBeanInfoAssembler\n\t * @see org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler\n\t * @see #setAutodetect\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "assembler"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "void",
    "signature": "public void setAssembler(MBeanInfoAssembler assembler)",
    "source_code": "\tpublic void setAssembler(MBeanInfoAssembler assembler) {\n\t\tthis.assembler = assembler;\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#setAutodetect(autodetect)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to autodetect MBeans in the bean factory that this exporter\n\t * runs in. Will also ask an {@code AutodetectCapableMBeanInfoAssembler}\n\t * if available.\n\t * <p>This feature is turned off by default. Explicitly specify\n\t * {@code true} here to enable autodetection.\n\t * @see #setAssembler\n\t * @see AutodetectCapableMBeanInfoAssembler\n\t * @see #isMBean\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "autodetect"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void setAutodetect(boolean autodetect)",
    "source_code": "\tpublic void setAutodetect(boolean autodetect) {\n\t\tthis.autodetectMode = (autodetect ? AUTODETECT_ALL : AUTODETECT_NONE);\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#setAutodetectMode(autodetectMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the autodetection mode to use.\n\t * @throws IllegalArgumentException if the supplied value is not\n\t * one of the {@code AUTODETECT_} constants\n\t * @see #setAutodetectModeName(String)\n\t * @see #AUTODETECT_ALL\n\t * @see #AUTODETECT_ASSEMBLER\n\t * @see #AUTODETECT_MBEAN\n\t * @see #AUTODETECT_NONE\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "autodetectMode"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "void",
    "signature": "public void setAutodetectMode(int autodetectMode)",
    "source_code": "\tpublic void setAutodetectMode(int autodetectMode) {\n\t\tif (!constants.getValues(CONSTANT_PREFIX_AUTODETECT).contains(autodetectMode)) {\n\t\t\tthrow new IllegalArgumentException(\"Only values of autodetect constants allowed\");\n\t\t}\n\t\tthis.autodetectMode = autodetectMode;\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#setAutodetectModeName(constantName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the autodetection mode to use by name.\n\t * @throws IllegalArgumentException if the supplied value is not resolvable\n\t * to one of the {@code AUTODETECT_} constants or is {@code null}\n\t * @see #setAutodetectMode(int)\n\t * @see #AUTODETECT_ALL\n\t * @see #AUTODETECT_ASSEMBLER\n\t * @see #AUTODETECT_MBEAN\n\t * @see #AUTODETECT_NONE\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constantName"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "void",
    "signature": "public void setAutodetectModeName(String constantName)",
    "source_code": "\tpublic void setAutodetectModeName(String constantName) {\n\t\tif (!constantName.startsWith(CONSTANT_PREFIX_AUTODETECT)) {\n\t\t\tthrow new IllegalArgumentException(\"Only autodetect constants allowed\");\n\t\t}\n\t\tthis.autodetectMode = (Integer) constants.asNumber(constantName);\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#setBeanClassLoader(classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "void",
    "signature": "public void setBeanClassLoader(ClassLoader classLoader)",
    "source_code": "\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\tthis.beanClassLoader = classLoader;\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This callback is only required for resolution of bean names in the\n\t * {@link #setBeans(java.util.Map) \"beans\"} {@link Map} and for\n\t * autodetection of MBeans (in the latter case, a\n\t * {@code ListableBeanFactory} is required).\n\t * @see #setBeans\n\t * @see #setAutodetect\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 404
    },
    "return": "void",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tif (beanFactory instanceof ListableBeanFactory) {\n\t\t\tthis.beanFactory = (ListableBeanFactory) beanFactory;\n\t\t}\n\t\telse {\n\t\t\tlogger.debug(\"MBeanExporter not running in a ListableBeanFactory: autodetection of MBeans not available.\");\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#setBeans(Map<String,beans)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Supply a {@code Map} of beans to be registered with the JMX\n\t * {@code MBeanServer}.\n\t * <p>The String keys are the basis for the creation of JMX object names.\n\t * By default, a JMX {@code ObjectName} will be created straight\n\t * from the given key. This can be customized through specifying a\n\t * custom {@code NamingStrategy}.\n\t * <p>Both bean instances and bean names are allowed as values.\n\t * Bean instances are typically linked in through bean references.\n\t * Bean names will be resolved as beans in the current factory, respecting\n\t * lazy-init markers (that is, not triggering initialization of such beans).\n\t * @param beans a Map with JMX names as keys and bean instances or bean names\n\t * as values\n\t * @see #setNamingStrategy\n\t * @see org.springframework.jmx.export.naming.KeyNamingStrategy\n\t * @see javax.management.ObjectName#ObjectName(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "beans"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void setBeans(Map<String, Object> beans)",
    "source_code": "\tpublic void setBeans(Map<String, Object> beans) {\n\t\tthis.beans = beans;\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#setEnsureUniqueRuntimeObjectNames(ensureUniqueRuntimeObjectNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicates whether Spring should ensure that {@link ObjectName ObjectNames}\n\t * generated by the configured {@link ObjectNamingStrategy} for\n\t * runtime-registered MBeans ({@link #registerManagedResource}) should get\n\t * modified: to ensure uniqueness for every instance of a managed {@code Class}.\n\t * <p>The default value is {@code true}.\n\t * @see #registerManagedResource\n\t * @see JmxUtils#appendIdentityToObjectName(javax.management.ObjectName, Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ensureUniqueRuntimeObjectNames"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "void",
    "signature": "public void setEnsureUniqueRuntimeObjectNames(boolean ensureUniqueRuntimeObjectNames)",
    "source_code": "\tpublic void setEnsureUniqueRuntimeObjectNames(boolean ensureUniqueRuntimeObjectNames) {\n\t\tthis.ensureUniqueRuntimeObjectNames = ensureUniqueRuntimeObjectNames;\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#setExcludedBeans(excludedBeans)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the list of names for beans that should be excluded from autodetection.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "excludedBeans"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "void",
    "signature": "public void setExcludedBeans(String... excludedBeans)",
    "source_code": "\tpublic void setExcludedBeans(String... excludedBeans) {\n\t\tthis.excludedBeans.clear();\n\t\tCollections.addAll(this.excludedBeans, excludedBeans);\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#setExposeManagedResourceClassLoader(exposeManagedResourceClassLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicates whether the managed resource should be exposed on the\n\t * {@link Thread#getContextClassLoader() thread context ClassLoader} before\n\t * allowing any invocations on the MBean to occur.\n\t * <p>The default value is {@code true}, exposing a {@link SpringModelMBean}\n\t * which performs thread context ClassLoader management. Switch this flag off to\n\t * expose a standard JMX {@link javax.management.modelmbean.RequiredModelMBean}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exposeManagedResourceClassLoader"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "void",
    "signature": "public void setExposeManagedResourceClassLoader(boolean exposeManagedResourceClassLoader)",
    "source_code": "\tpublic void setExposeManagedResourceClassLoader(boolean exposeManagedResourceClassLoader) {\n\t\tthis.exposeManagedResourceClassLoader = exposeManagedResourceClassLoader;\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#setListeners(listeners)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@code MBeanExporterListener}s that should be notified\n\t * of MBean registration and unregistration events.\n\t * @see MBeanExporterListener\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "listeners"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "void",
    "signature": "public void setListeners(MBeanExporterListener... listeners)",
    "source_code": "\tpublic void setListeners(MBeanExporterListener... listeners) {\n\t\tthis.listeners = listeners;\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#setModelMBean(modelMBean)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "modelMBean"
    ],
    "position": {
      "column": 1,
      "line": 1091
    },
    "return": "void",
    "signature": "public void setModelMBean(ModelMBean modelMBean)",
    "source_code": "\t\tpublic void setModelMBean(ModelMBean modelMBean) {\n\t\t\tthis.modelMBean = modelMBean;\n\t\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#setNamingStrategy(namingStrategy)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the implementation of the {@code ObjectNamingStrategy} interface\n\t * to use for this exporter. Default is a {@code KeyNamingStrategy}.\n\t * @see org.springframework.jmx.export.naming.KeyNamingStrategy\n\t * @see org.springframework.jmx.export.naming.MetadataNamingStrategy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "namingStrategy"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "void",
    "signature": "public void setNamingStrategy(ObjectNamingStrategy namingStrategy)",
    "source_code": "\tpublic void setNamingStrategy(ObjectNamingStrategy namingStrategy) {\n\t\tthis.namingStrategy = namingStrategy;\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#setNotificationListenerMappings(Map<?,listeners)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link NotificationListener NotificationListeners} to register\n\t * with the {@link javax.management.MBeanServer}.\n\t * <P>The key of each entry in the {@code Map} is a {@link String}\n\t * representation of the {@link javax.management.ObjectName} or the bean\n\t * name of the MBean the listener should be registered for. Specifying an\n\t * asterisk ({@code *}) for a key will cause the listener to be\n\t * associated with all MBeans registered by this class at startup time.\n\t * <p>The value of each entry is the\n\t * {@link javax.management.NotificationListener} to register. For more\n\t * advanced options such as registering\n\t * {@link javax.management.NotificationFilter NotificationFilters} and\n\t * handback objects see {@link #setNotificationListeners(NotificationListenerBean[])}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "listeners"
    ],
    "position": {
      "column": 1,
      "line": 371
    },
    "return": "void",
    "signature": "public void setNotificationListenerMappings(Map<?, ? extends NotificationListener> listeners)",
    "source_code": "\tpublic void setNotificationListenerMappings(Map<?, ? extends NotificationListener> listeners) {\n\t\tAssert.notNull(listeners, \"'listeners' must not be null\");\n\t\tList<NotificationListenerBean> notificationListeners =\n\t\t\t\tnew ArrayList<>(listeners.size());\n\n\t\tlisteners.forEach((key, listener) -> {\n\t\t\t// Get the listener from the map value.\n\t\t\tNotificationListenerBean bean = new NotificationListenerBean(listener);\n\t\t\t// Get the ObjectName from the map key.\n\t\t\tif (key != null && !WILDCARD.equals(key)) {\n\t\t\t\t// This listener is mapped to a specific ObjectName.\n\t\t\t\tbean.setMappedObjectName(key);\n\t\t\t}\n\t\t\tnotificationListeners.add(bean);\n\t\t});\n\n\t\tthis.notificationListeners = notificationListeners.toArray(new NotificationListenerBean[0]);\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#setNotificationListeners(notificationListeners)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link NotificationListenerBean NotificationListenerBeans}\n\t * containing the\n\t * {@link javax.management.NotificationListener NotificationListeners}\n\t * that will be registered with the {@link MBeanServer}.\n\t * @see #setNotificationListenerMappings(java.util.Map)\n\t * @see NotificationListenerBean\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "notificationListeners"
    ],
    "position": {
      "column": 1,
      "line": 353
    },
    "return": "void",
    "signature": "public void setNotificationListeners(NotificationListenerBean... notificationListeners)",
    "source_code": "\tpublic void setNotificationListeners(NotificationListenerBean... notificationListeners) {\n\t\tthis.notificationListeners = notificationListeners;\n\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#setObjectName(objectName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "objectName"
    ],
    "position": {
      "column": 1,
      "line": 1095
    },
    "return": "void",
    "signature": "public void setObjectName(ObjectName objectName)",
    "source_code": "\t\tpublic void setObjectName(ObjectName objectName) {\n\t\t\tthis.objectName = objectName;\n\t\t}"
  },
  "org.springframework.jmx.export.MBeanExporter#unregisterManagedResource(objectName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "objectName"
    ],
    "position": {
      "column": 1,
      "line": 500
    },
    "return": "void",
    "signature": "public void unregisterManagedResource(ObjectName objectName)",
    "source_code": "\tpublic void unregisterManagedResource(ObjectName objectName) {\n\t\tAssert.notNull(objectName, \"ObjectName must not be null\");\n\t\tdoUnregister(objectName);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class for HandlerMethod-based message handling. Provides most of\n * the logic required to discover handler methods at startup, find a matching handler\n * method at runtime for a given message and invoke it.\n *\n * <p>Also supports discovering and invoking exception handling methods to process\n * exceptions raised during message handling.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.0\n * @param <T> the type of the Object that contains information mapping a\n * {@link org.springframework.messaging.handler.HandlerMethod} to incoming messages\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "signature": "public class AbstractMethodMessageHandler",
    "source_code": "public abstract class AbstractMethodMessageHandler<T>"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#accept(result,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 718
    },
    "return": "void",
    "signature": "public void accept(@Nullable Object result, @Nullable Throwable ex)",
    "source_code": "\t\tpublic void accept(@Nullable Object result, @Nullable Throwable ex) {\n\t\t\tif (result != null) {\n\t\t\t\ttry {\n\t\t\t\t\tMethodParameter returnType = this.handlerMethod.getAsyncReturnValueType(result);\n\t\t\t\t\treturnValueHandlers.handleReturnValue(result, returnType, this.message);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable throwable) {\n\t\t\t\t\thandleFailure(throwable);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ex != null) {\n\t\t\t\thandleFailure(ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#afterPropertiesSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "void",
    "signature": "public void afterPropertiesSet()",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tif (this.argumentResolvers.getResolvers().isEmpty()) {\n\t\t\tthis.argumentResolvers.addResolvers(initArgumentResolvers());\n\t\t}\n\n\t\tif (this.returnValueHandlers.getReturnValueHandlers().isEmpty()) {\n\t\t\tthis.returnValueHandlers.addHandlers(initReturnValueHandlers());\n\t\t}\n\t\tLog returnValueLogger = getReturnValueHandlerLogger();\n\t\tif (returnValueLogger != null) {\n\t\t\tthis.returnValueHandlers.setLogger(returnValueLogger);\n\t\t}\n\n\t\tthis.handlerMethodLogger = getHandlerMethodLogger();\n\n\t\tApplicationContext context = getApplicationContext();\n\t\tif (context == null) {\n\t\t\treturn;\n\t\t}\n\t\tfor (String beanName : context.getBeanNamesForType(Object.class)) {\n\t\t\tif (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {\n\t\t\t\tClass<?> beanType = null;\n\t\t\t\ttry {\n\t\t\t\t\tbeanType = context.getType(beanName);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t// An unresolvable bean type, probably from a lazy bean - let's ignore it.\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Could not resolve target class for bean with name '\" + beanName + \"'\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (beanType != null && isHandler(beanType)) {\n\t\t\t\t\tdetectHandlerMethods(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#compare(match1,match2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "match1",
      "match2"
    ],
    "position": {
      "column": 1,
      "line": 700
    },
    "return": "int",
    "signature": "public int compare(Match match1, Match match2)",
    "source_code": "\t\tpublic int compare(Match match1, Match match2) {\n\t\t\treturn this.comparator.compare(match1.mapping, match2.mapping);\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#createExceptionHandlerMethodResolverFor(beanType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanType"
    ],
    "position": {
      "column": 1,
      "line": 658
    },
    "return": "AbstractExceptionHandlerMethodResolver",
    "signature": "protected AbstractExceptionHandlerMethodResolver createExceptionHandlerMethodResolverFor(Class<?> beanType)",
    "source_code": "\tprotected abstract AbstractExceptionHandlerMethodResolver createExceptionHandlerMethodResolverFor("
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#createHandlerMethod(handler,method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a HandlerMethod instance from an Object handler that is either a handler\n\t * instance or a String-based bean name.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod createHandlerMethod(Object handler, Method method)",
    "source_code": "\tprotected HandlerMethod createHandlerMethod(Object handler, Method method) {\n\t\tHandlerMethod handlerMethod;\n\t\tif (handler instanceof String beanName) {\n\t\t\tApplicationContext context = getApplicationContext();\n\t\t\tAssert.state(context != null, \"ApplicationContext is required for resolving handler bean names\");\n\t\t\thandlerMethod = new HandlerMethod(beanName, context.getAutowireCapableBeanFactory(), method);\n\t\t}\n\t\telse {\n\t\t\thandlerMethod = new HandlerMethod(handler, method);\n\t\t}\n\t\treturn handlerMethod;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#detectHandlerMethods(handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Detect if the given handler has any methods that can handle messages and if\n\t * so register it with the extracted mapping information.\n\t * @param handler the handler to check, either an instance of a Spring bean name\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "void",
    "signature": "protected void detectHandlerMethods(final Object handler)",
    "source_code": "\tprotected final void detectHandlerMethods(final Object handler) {\n\t\tClass<?> handlerType;\n\t\tif (handler instanceof String) {\n\t\t\tApplicationContext context = getApplicationContext();\n\t\t\tAssert.state(context != null, \"ApplicationContext is required for resolving handler bean names\");\n\t\t\thandlerType = context.getType((String) handler);\n\t\t}\n\t\telse {\n\t\t\thandlerType = handler.getClass();\n\t\t}\n\n\t\tif (handlerType != null) {\n\t\t\tfinal Class<?> userType = ClassUtils.getUserClass(handlerType);\n\t\t\tMap<Method, T> methods = MethodIntrospector.selectMethods(userType,\n\t\t\t\t\t(MethodIntrospector.MetadataLookup<T>) method -> getMappingForMethod(method, userType));\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(formatMappings(userType, methods));\n\t\t\t}\n\t\t\tmethods.forEach((key, value) -> registerHandlerMethod(handler, key, value));\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#getApplicationContext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext getApplicationContext()",
    "source_code": "\tpublic ApplicationContext getApplicationContext() {\n\t\treturn this.applicationContext;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#getArgumentResolvers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the complete list of argument resolvers.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "List<HandlerMethodArgumentResolver>",
    "signature": "public List<HandlerMethodArgumentResolver> getArgumentResolvers()",
    "source_code": "\tpublic List<HandlerMethodArgumentResolver> getArgumentResolvers() {\n\t\treturn this.argumentResolvers.getResolvers();\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#getCustomArgumentResolvers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured custom argument resolvers, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "List<HandlerMethodArgumentResolver>",
    "signature": "public List<HandlerMethodArgumentResolver> getCustomArgumentResolvers()",
    "source_code": "\tpublic List<HandlerMethodArgumentResolver> getCustomArgumentResolvers() {\n\t\treturn this.customArgumentResolvers;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#getCustomReturnValueHandlers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured custom return value handlers, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "List<HandlerMethodReturnValueHandler>",
    "signature": "public List<HandlerMethodReturnValueHandler> getCustomReturnValueHandlers()",
    "source_code": "\tpublic List<HandlerMethodReturnValueHandler> getCustomReturnValueHandlers() {\n\t\treturn this.customReturnValueHandlers;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#getDestination(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 462
    },
    "return": "String",
    "signature": "protected String getDestination(Message<?> message)",
    "source_code": "\tprotected abstract String getDestination(Message<?> message);"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#getDestinationPrefixes()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured destination prefixes, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "Collection<String>",
    "signature": "public Collection<String> getDestinationPrefixes()",
    "source_code": "\tpublic Collection<String> getDestinationPrefixes() {\n\t\treturn this.destinationPrefixes;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#getDirectLookupDestinations(mapping)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return destinations contained in the mapping that are not patterns and are\n\t * therefore suitable for direct lookups.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 396
    },
    "return": "Set<String>",
    "signature": "protected Set<String> getDirectLookupDestinations(T mapping)",
    "source_code": "\tprotected abstract Set<String> getDirectLookupDestinations(T mapping);"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#getExceptionHandlerMethod(handlerMethod,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find an {@code @MessageExceptionHandler} method for the given exception.\n\t * The default implementation searches methods in the class hierarchy of the\n\t * HandlerMethod first and if not found, it continues searching for additional\n\t * {@code @MessageExceptionHandler} methods among the configured\n\t * {@linkplain org.springframework.messaging.handler.MessagingAdviceBean\n\t * MessagingAdviceBean}, if any.\n\t * @param handlerMethod the method where the exception was raised\n\t * @param exception the raised exception\n\t * @return a method to handle the exception, or {@code null}\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handlerMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 631
    },
    "return": "InvocableHandlerMethod",
    "signature": "protected InvocableHandlerMethod getExceptionHandlerMethod(HandlerMethod handlerMethod, Exception exception)",
    "source_code": "\tprotected InvocableHandlerMethod getExceptionHandlerMethod(HandlerMethod handlerMethod, Exception exception) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Searching methods to handle \" + exception.getClass().getSimpleName());\n\t\t}\n\t\tClass<?> beanType = handlerMethod.getBeanType();\n\t\tAbstractExceptionHandlerMethodResolver resolver = this.exceptionHandlerCache.get(beanType);\n\t\tif (resolver == null) {\n\t\t\tresolver = createExceptionHandlerMethodResolverFor(beanType);\n\t\t\tthis.exceptionHandlerCache.put(beanType, resolver);\n\t\t}\n\t\tMethod method = resolver.resolveMethod(exception);\n\t\tif (method != null) {\n\t\t\treturn new InvocableHandlerMethod(handlerMethod.getBean(), method);\n\t\t}\n\t\tfor (Map.Entry<MessagingAdviceBean, AbstractExceptionHandlerMethodResolver> entry : this.exceptionHandlerAdviceCache.entrySet()) {\n\t\t\tMessagingAdviceBean advice = entry.getKey();\n\t\t\tif (advice.isApplicableToBeanType(beanType)) {\n\t\t\t\tresolver = entry.getValue();\n\t\t\t\tmethod = resolver.resolveMethod(exception);\n\t\t\t\tif (method != null) {\n\t\t\t\t\treturn new InvocableHandlerMethod(advice.resolveBean(), method);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#getHandlerMethodLogger()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a logger to set on {@link InvocableHandlerMethod}.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "Log",
    "signature": "protected Log getHandlerMethodLogger()",
    "source_code": "\tprotected Log getHandlerMethodLogger() {\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#getHandlerMethods()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a map with all handler methods and their mappings.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "HandlerMethod>",
    "signature": "public HandlerMethod> getHandlerMethods()",
    "source_code": "\tpublic Map<T, HandlerMethod> getHandlerMethods() {\n\t\treturn Collections.unmodifiableMap(this.handlerMethods);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#getLookupDestination(destination)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given destination (of an incoming message) matches to\n\t * one of the configured destination prefixes and if so return the remaining\n\t * portion of the destination after the matched prefix.\n\t * <p>If there are no matching prefixes, return {@code null}.\n\t * <p>If there are no destination prefixes, return the destination as is.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 473
    },
    "return": "String",
    "signature": "protected String getLookupDestination(@Nullable String destination)",
    "source_code": "\tprotected String getLookupDestination(@Nullable String destination) {\n\t\tif (destination == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (CollectionUtils.isEmpty(this.destinationPrefixes)) {\n\t\t\treturn destination;\n\t\t}\n\t\tfor (String prefix : this.destinationPrefixes) {\n\t\t\tif (destination.startsWith(prefix)) {\n\t\t\t\treturn destination.substring(prefix.length());\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#getMappingComparator(message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a comparator for sorting matching mappings.\n\t * The returned comparator should sort 'better' matches higher.\n\t * @param message the current Message\n\t * @return the comparator, never {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 554
    },
    "return": "Comparator<T>",
    "signature": "protected Comparator<T> getMappingComparator(Message<?> message)",
    "source_code": "\tprotected abstract Comparator<T> getMappingComparator(Message<?> message);"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#getMappingForMethod(method,handlerType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide the mapping for a handler method.\n\t * @param method the method to provide a mapping for\n\t * @param handlerType the handler type, possibly a subtype of the method's declaring class\n\t * @return the mapping, or {@code null} if the method is not mapped\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "T",
    "signature": "protected T getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected abstract T getMappingForMethod(Method method, Class<?> handlerType);"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#getMatchingMapping(mapping,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if a mapping matches the current message and return a possibly\n\t * new mapping with conditions relevant to the current request.\n\t * @param mapping the mapping to get a match for\n\t * @param message the message being handled\n\t * @return the match or {@code null} if there is no match\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "T",
    "signature": "protected T getMatchingMapping(T mapping, Message<?> message)",
    "source_code": "\tprotected abstract T getMatchingMapping(T mapping, Message<?> message);"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#getReturnValueHandlerLogger()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a logger to set on {@link HandlerMethodReturnValueHandlerComposite}.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 403
    },
    "return": "Log",
    "signature": "protected Log getReturnValueHandlerLogger()",
    "source_code": "\tprotected Log getReturnValueHandlerLogger() {\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#getReturnValueHandlers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the complete list of return value handlers.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "List<HandlerMethodReturnValueHandler>",
    "signature": "public List<HandlerMethodReturnValueHandler> getReturnValueHandlers()",
    "source_code": "\tpublic List<HandlerMethodReturnValueHandler> getReturnValueHandlers() {\n\t\treturn this.returnValueHandlers.getReturnValueHandlers();\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#handleMatch(mapping,handlerMethod,lookupDestination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "handlerMethod",
      "lookupDestination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 556
    },
    "return": "void",
    "signature": "protected void handleMatch(T mapping, HandlerMethod handlerMethod, String lookupDestination, Message<?> message)",
    "source_code": "\tprotected void handleMatch(T mapping, HandlerMethod handlerMethod, String lookupDestination, Message<?> message) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Invoking \" + handlerMethod.getShortLogMessage());\n\t\t}\n\t\thandlerMethod = handlerMethod.createWithResolvedBean();\n\t\tInvocableHandlerMethod invocable = new InvocableHandlerMethod(handlerMethod);\n\t\tif (this.handlerMethodLogger != null) {\n\t\t\tinvocable.setLogger(this.handlerMethodLogger);\n\t\t}\n\t\tinvocable.setMessageMethodArgumentResolvers(this.argumentResolvers);\n\t\ttry {\n\t\t\tObject returnValue = invocable.invoke(message);\n\t\t\tMethodParameter returnType = handlerMethod.getReturnType();\n\t\t\tif (void.class == returnType.getParameterType()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (returnValue != null && this.returnValueHandlers.isAsyncReturnValue(returnValue, returnType)) {\n\t\t\t\tCompletableFuture<?> future = this.returnValueHandlers.toCompletableFuture(returnValue, returnType);\n\t\t\t\tif (future != null) {\n\t\t\t\t\tfuture.whenComplete(new ReturnValueListenableFutureCallback(invocable, message));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.returnValueHandlers.handleReturnValue(returnValue, returnType, message);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tprocessHandlerMethodException(handlerMethod, ex, message);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tException handlingException =\n\t\t\t\t\tnew MessageHandlingException(message, \"Unexpected handler method invocation error\", ex);\n\t\t\tprocessHandlerMethodException(handlerMethod, handlingException, message);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#handleMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "void",
    "signature": "public void handleMessage(Message<?> message)",
    "source_code": "\tpublic void handleMessage(Message<?> message) throws MessagingException {\n\t\tString destination = getDestination(message);\n\t\tif (destination == null) {\n\t\t\treturn;\n\t\t}\n\t\tString lookupDestination = getLookupDestination(destination);\n\t\tif (lookupDestination == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tMessageHeaderAccessor headerAccessor = MessageHeaderAccessor.getMutableAccessor(message);\n\t\theaderAccessor.setHeader(DestinationPatternsMessageCondition.LOOKUP_DESTINATION_HEADER, lookupDestination);\n\t\theaderAccessor.setLeaveMutable(true);\n\t\tmessage = MessageBuilder.createMessage(message.getPayload(), headerAccessor.getMessageHeaders());\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Searching methods to handle \" +\n\t\t\t\t\theaderAccessor.getShortLogMessage(message.getPayload()) +\n\t\t\t\t\t\", lookupDestination='\" + lookupDestination + \"'\");\n\t\t}\n\n\t\thandleMessageInternal(message, lookupDestination);\n\t\theaderAccessor.setImmutable();\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#handleMessageInternal(message,lookupDestination)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "lookupDestination"
    ],
    "position": {
      "column": 1,
      "line": 488
    },
    "return": "void",
    "signature": "protected void handleMessageInternal(Message<?> message, String lookupDestination)",
    "source_code": "\tprotected void handleMessageInternal(Message<?> message, String lookupDestination) {\n\t\tList<Match> matches = new ArrayList<>();\n\n\t\tList<T> mappingsByUrl = this.destinationLookup.get(lookupDestination);\n\t\tif (mappingsByUrl != null) {\n\t\t\taddMatchesToCollection(mappingsByUrl, message, matches);\n\t\t}\n\t\tif (matches.isEmpty()) {\n\t\t\t// No direct hits, go through all mappings\n\t\t\tSet<T> allMappings = this.handlerMethods.keySet();\n\t\t\taddMatchesToCollection(allMappings, message, matches);\n\t\t}\n\t\tif (matches.isEmpty()) {\n\t\t\thandleNoMatch(this.handlerMethods.keySet(), lookupDestination, message);\n\t\t\treturn;\n\t\t}\n\n\t\tComparator<Match> comparator = new MatchComparator(getMappingComparator(message));\n\t\tmatches.sort(comparator);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Found \" + matches.size() + \" handler methods: \" + matches);\n\t\t}\n\n\t\tMatch bestMatch = matches.get(0);\n\t\tif (matches.size() > 1) {\n\t\t\tMatch secondBestMatch = matches.get(1);\n\t\t\tif (comparator.compare(bestMatch, secondBestMatch) == 0) {\n\t\t\t\tMethod m1 = bestMatch.handlerMethod.getMethod();\n\t\t\t\tMethod m2 = secondBestMatch.handlerMethod.getMethod();\n\t\t\t\tthrow new IllegalStateException(\"Ambiguous handler methods mapped for destination '\" +\n\t\t\t\t\t\tlookupDestination + \"': {\" + m1 + \", \" + m2 + \"}\");\n\t\t\t}\n\t\t}\n\n\t\thandleMatch(bestMatch.mapping, bestMatch.handlerMethod, lookupDestination, message);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#handleNoMatch(ts,lookupDestination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ts",
      "lookupDestination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "void",
    "signature": "protected void handleNoMatch(Set<T> ts, String lookupDestination, Message<?> message)",
    "source_code": "\tprotected void handleNoMatch(Set<T> ts, String lookupDestination, Message<?> message) {\n\t\tlogger.debug(\"No matching message handler methods.\");\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#isHandler(beanType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the given bean type should be introspected for messaging handling methods.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanType"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "boolean",
    "signature": "protected boolean isHandler(Class<?> beanType)",
    "source_code": "\tprotected abstract boolean isHandler(Class<?> beanType);"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#processHandlerMethodException(handlerMethod,exception,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handlerMethod",
      "exception",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 592
    },
    "return": "void",
    "signature": "protected void processHandlerMethodException(HandlerMethod handlerMethod, Exception exception, Message<?> message)",
    "source_code": "\tprotected void processHandlerMethodException(HandlerMethod handlerMethod, Exception exception, Message<?> message) {\n\t\tInvocableHandlerMethod invocable = getExceptionHandlerMethod(handlerMethod, exception);\n\t\tif (invocable == null) {\n\t\t\tlogger.error(\"Unhandled exception from message handler method\", exception);\n\t\t\treturn;\n\t\t}\n\t\tinvocable.setMessageMethodArgumentResolvers(this.argumentResolvers);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Invoking \" + invocable.getShortLogMessage());\n\t\t}\n\t\ttry {\n\t\t\tThrowable cause = exception.getCause();\n\t\t\tObject returnValue = (cause != null ?\n\t\t\t\t\tinvocable.invoke(message, exception, cause, handlerMethod) :\n\t\t\t\t\tinvocable.invoke(message, exception, handlerMethod));\n\t\t\tMethodParameter returnType = invocable.getReturnType();\n\t\t\tif (void.class == returnType.getParameterType()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.returnValueHandlers.handleReturnValue(returnValue, returnType, message);\n\t\t}\n\t\tcatch (Throwable ex2) {\n\t\t\tlogger.error(\"Error while processing handler method exception\", ex2);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#registerExceptionHandlerAdvice(bean,resolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can invoke this method to populate the MessagingAdviceBean cache\n\t * (e.g. to support \"global\" {@code @MessageExceptionHandler}).\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 421
    },
    "return": "void",
    "signature": "protected void registerExceptionHandlerAdvice(MessagingAdviceBean bean, AbstractExceptionHandlerMethodResolver resolver)",
    "source_code": "\tprotected void registerExceptionHandlerAdvice("
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#registerHandlerMethod(handler,method,mapping)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a handler method and its unique mapping.\n\t * @param handler the bean name of the handler or the handler instance\n\t * @param method the method to register\n\t * @param mapping the mapping conditions associated with the handler method\n\t * @throws IllegalStateException if another method was already registered\n\t * under the same mapping\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "void",
    "signature": "protected void registerHandlerMethod(Object handler, Method method, T mapping)",
    "source_code": "\tprotected void registerHandlerMethod(Object handler, Method method, T mapping) {\n\t\tAssert.notNull(mapping, \"Mapping must not be null\");\n\t\tHandlerMethod newHandlerMethod = createHandlerMethod(handler, method);\n\t\tHandlerMethod oldHandlerMethod = this.handlerMethods.get(mapping);\n\n\t\tif (oldHandlerMethod != null && !oldHandlerMethod.equals(newHandlerMethod)) {\n\t\t\tthrow new IllegalStateException(\"Ambiguous mapping found. Cannot map '\" + newHandlerMethod.getBean() +\n\t\t\t\t\t\"' bean method \\n\" + newHandlerMethod + \"\\nto \" + mapping + \": There is already '\" +\n\t\t\t\t\toldHandlerMethod.getBean() + \"' bean method\\n\" + oldHandlerMethod + \" mapped.\");\n\t\t}\n\n\t\tthis.handlerMethods.put(mapping, newHandlerMethod);\n\n\t\tfor (String pattern : getDirectLookupDestinations(mapping)) {\n\t\t\tthis.destinationLookup.add(pattern, mapping);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#setApplicationContext(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "void",
    "signature": "public void setApplicationContext(@Nullable ApplicationContext applicationContext)",
    "source_code": "\tpublic void setApplicationContext(@Nullable ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#setArgumentResolvers(argumentResolvers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the complete list of supported argument types, effectively overriding\n\t * the ones configured by default. This is an advanced option; for most use cases\n\t * it should be sufficient to use {@link #setCustomArgumentResolvers}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argumentResolvers"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "void",
    "signature": "public void setArgumentResolvers(@Nullable List<HandlerMethodArgumentResolver> argumentResolvers)",
    "source_code": "\tpublic void setArgumentResolvers(@Nullable List<HandlerMethodArgumentResolver> argumentResolvers) {\n\t\tif (argumentResolvers == null) {\n\t\t\tthis.argumentResolvers.clear();\n\t\t\treturn;\n\t\t}\n\t\tthis.argumentResolvers.addResolvers(argumentResolvers);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#setCustomArgumentResolvers(customArgumentResolvers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Sets the list of custom {@code HandlerMethodArgumentResolver}s that will be used\n\t * after resolvers for supported argument type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "customArgumentResolvers"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "void",
    "signature": "public void setCustomArgumentResolvers(@Nullable List<HandlerMethodArgumentResolver> customArgumentResolvers)",
    "source_code": "\tpublic void setCustomArgumentResolvers(@Nullable List<HandlerMethodArgumentResolver> customArgumentResolvers) {\n\t\tthis.customArgumentResolvers.clear();\n\t\tif (customArgumentResolvers != null) {\n\t\t\tthis.customArgumentResolvers.addAll(customArgumentResolvers);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#setCustomReturnValueHandlers(customReturnValueHandlers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the list of custom {@code HandlerMethodReturnValueHandler}s that will be used\n\t * after return value handlers for known types.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "customReturnValueHandlers"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "void",
    "signature": "public void setCustomReturnValueHandlers(@Nullable List<HandlerMethodReturnValueHandler> customReturnValueHandlers)",
    "source_code": "\tpublic void setCustomReturnValueHandlers(@Nullable List<HandlerMethodReturnValueHandler> customReturnValueHandlers) {\n\t\tthis.customReturnValueHandlers.clear();\n\t\tif (customReturnValueHandlers != null) {\n\t\t\tthis.customReturnValueHandlers.addAll(customReturnValueHandlers);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#setDestinationPrefixes(prefixes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * When this property is configured only messages to destinations matching\n\t * one of the configured prefixes are eligible for handling. When there is a\n\t * match the prefix is removed and only the remaining part of the destination\n\t * is used for method-mapping purposes.\n\t * <p>By default, no prefixes are configured in which case all messages are\n\t * eligible for handling.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "prefixes"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void setDestinationPrefixes(@Nullable Collection<String> prefixes)",
    "source_code": "\tpublic void setDestinationPrefixes(@Nullable Collection<String> prefixes) {\n\t\tthis.destinationPrefixes.clear();\n\t\tif (prefixes != null) {\n\t\t\tfor (String prefix : prefixes) {\n\t\t\t\tprefix = prefix.trim();\n\t\t\t\tthis.destinationPrefixes.add(prefix);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#setReturnValueHandlers(returnValueHandlers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the complete list of supported return value types, effectively overriding\n\t * the ones configured by default. This is an advanced option; for most use cases\n\t * it should be sufficient to use {@link #setCustomReturnValueHandlers}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValueHandlers"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "void",
    "signature": "public void setReturnValueHandlers(@Nullable List<HandlerMethodReturnValueHandler> returnValueHandlers)",
    "source_code": "\tpublic void setReturnValueHandlers(@Nullable List<HandlerMethodReturnValueHandler> returnValueHandlers) {\n\t\tif (returnValueHandlers == null) {\n\t\t\tthis.returnValueHandlers.clear();\n\t\t\treturn;\n\t\t}\n\t\tthis.returnValueHandlers.addHandlers(returnValueHandlers);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 685
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn this.mapping.toString();\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.messaging.rsocket.PayloadUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Static utility methods to create {@link Payload} from {@link DataBuffer}s\n * and vice versa.\n *\n * @author Rossen Stoyanchev\n * @since 5.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class PayloadUtils",
    "source_code": "public abstract class PayloadUtils {\n\n\t/**\n\t * Use this method to slice, retain and wrap the data portion of the\n\t * {@code Payload}, and also to release the {@code Payload}. This assumes\n\t * the Payload metadata has been read by now and ensures downstream code\n\t * need only be aware of {@code DataBuffer}s.\n\t * @param payload the payload to process\n\t * @param bufferFactory the DataBufferFactory to wrap with\n\t * @return the created {@code DataBuffer} instance\n\t */\n\tpublic static DataBuffer retainDataAndReleasePayload(Payload payload, DataBufferFactory bufferFactory) {\n\t\ttry {\n\t\t\tif (bufferFactory instanceof NettyDataBufferFactory) {\n\t\t\t\tByteBuf byteBuf = payload.sliceData().retain();\n\t\t\t\treturn ((NettyDataBufferFactory) bufferFactory).wrap(byteBuf);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn bufferFactory.wrap(payload.getData());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (payload.refCnt() > 0) {\n\t\t\t\tpayload.release();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Create a Payload from the given metadata and data.\n\t * <p>If at least one is {@link NettyDataBuffer} then {@link ByteBufPayload}\n\t * is created with either obtaining the underlying native {@link ByteBuf}\n\t * or using {@link Unpooled#wrappedBuffer(ByteBuffer...)} if necessary.\n\t * Otherwise, if both are {@link DefaultDataBuffer}, then\n\t * {@link DefaultPayload} is created.\n\t * @param data the data part for the payload\n\t * @param metadata the metadata part for the payload\n\t * @return the created payload\n\t */\n\tpublic static Payload createPayload(DataBuffer data, DataBuffer metadata) {\n\t\treturn data instanceof NettyDataBuffer || metadata instanceof NettyDataBuffer ?\n\t\t\t\tByteBufPayload.create(asByteBuf(data), asByteBuf(metadata)) :\n\t\t\t\tDefaultPayload.create(asByteBuffer(data), asByteBuffer(metadata));\n\t}\n\n\t/**\n\t * Create a Payload with data only. The created payload is\n\t * {@link ByteBufPayload} if the input is {@link NettyDataBuffer} or\n\t * otherwise it is {@link DefaultPayload}.\n\t * @param data the data part for the payload\n\t * @return created payload\n\t */\n\tpublic static Payload createPayload(DataBuffer data) {\n\t\treturn data instanceof NettyDataBuffer ?\n\t\t\t\tByteBufPayload.create(asByteBuf(data)) : DefaultPayload.create(asByteBuffer(data));\n\t}\n\n\n\tstatic ByteBuf asByteBuf(DataBuffer buffer) {\n\t\treturn NettyDataBufferFactory.toByteBuf(buffer);\n\t}\n\n\tprivate static ByteBuffer asByteBuffer(DataBuffer dataBuffer) {\n\t\tif (dataBuffer instanceof DefaultDataBuffer defaultDataBuffer) {\n\t\t\treturn defaultDataBuffer.getNativeBuffer();\n\t\t}\n\t\telse {\n\t\t\tByteBuffer byteBuffer = ByteBuffer.allocate(dataBuffer.readableByteCount());\n\t\t\tdataBuffer.toByteBuffer(byteBuffer);\n\t\t\treturn byteBuffer;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.messaging.rsocket.PayloadUtils#createPayload(data)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a Payload with data only. The created payload is\n\t * {@link ByteBufPayload} if the input is {@link NettyDataBuffer} or\n\t * otherwise it is {@link DefaultPayload}.\n\t * @param data the data part for the payload\n\t * @return created payload\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "data"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "Payload",
    "signature": "public Payload createPayload(DataBuffer data)",
    "source_code": "\tpublic static Payload createPayload(DataBuffer data) {\n\t\treturn data instanceof NettyDataBuffer ?\n\t\t\t\tByteBufPayload.create(asByteBuf(data)) : DefaultPayload.create(asByteBuffer(data));\n\t}"
  },
  "org.springframework.messaging.rsocket.PayloadUtils#createPayload(data,metadata)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a Payload from the given metadata and data.\n\t * <p>If at least one is {@link NettyDataBuffer} then {@link ByteBufPayload}\n\t * is created with either obtaining the underlying native {@link ByteBuf}\n\t * or using {@link Unpooled#wrappedBuffer(ByteBuffer...)} if necessary.\n\t * Otherwise, if both are {@link DefaultDataBuffer}, then\n\t * {@link DefaultPayload} is created.\n\t * @param data the data part for the payload\n\t * @param metadata the metadata part for the payload\n\t * @return the created payload\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "data",
      "metadata"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "Payload",
    "signature": "public Payload createPayload(DataBuffer data, DataBuffer metadata)",
    "source_code": "\tpublic static Payload createPayload(DataBuffer data, DataBuffer metadata) {\n\t\treturn data instanceof NettyDataBuffer || metadata instanceof NettyDataBuffer ?\n\t\t\t\tByteBufPayload.create(asByteBuf(data), asByteBuf(metadata)) :\n\t\t\t\tDefaultPayload.create(asByteBuffer(data), asByteBuffer(metadata));\n\t}"
  },
  "org.springframework.messaging.rsocket.PayloadUtils#retainDataAndReleasePayload(payload,bufferFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Use this method to slice, retain and wrap the data portion of the\n\t * {@code Payload}, and also to release the {@code Payload}. This assumes\n\t * the Payload metadata has been read by now and ensures downstream code\n\t * need only be aware of {@code DataBuffer}s.\n\t * @param payload the payload to process\n\t * @param bufferFactory the DataBufferFactory to wrap with\n\t * @return the created {@code DataBuffer} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload",
      "bufferFactory"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer retainDataAndReleasePayload(Payload payload, DataBufferFactory bufferFactory)",
    "source_code": "\tpublic static DataBuffer retainDataAndReleasePayload(Payload payload, DataBufferFactory bufferFactory) {\n\t\ttry {\n\t\t\tif (bufferFactory instanceof NettyDataBufferFactory) {\n\t\t\t\tByteBuf byteBuf = payload.sliceData().retain();\n\t\t\t\treturn ((NettyDataBufferFactory) bufferFactory).wrap(byteBuf);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn bufferFactory.wrap(payload.getData());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (payload.refCnt() > 0) {\n\t\t\t\tpayload.release();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.rsocket.service.<unknown>#registerMethodHints(hints,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "void",
    "signature": "protected void registerMethodHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerMethodHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tfor (Parameter parameter : method.getParameters()) {\n\t\t\t// Also register non-annotated parameters to handle metadata\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints,\n\t\t\t\t\tMethodParameter.forParameter(parameter).getGenericParameterType());\n\t\t}\n\t\tregisterReturnTypeHints(hints, MethodParameter.forExecutable(method, -1));\n\t}"
  },
  "org.springframework.messaging.rsocket.service.<unknown>#registerReflectionHints(hints,element)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "void",
    "signature": "public void registerReflectionHints(ReflectionHints hints, AnnotatedElement element)",
    "source_code": "\tpublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tif (element instanceof Method method) {\n\t\t\tthis.registerMethodHints(hints, method);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.rsocket.service.<unknown>#registerReturnTypeHints(hints,returnTypeParameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "returnTypeParameter"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "protected void registerReturnTypeHints(ReflectionHints hints, MethodParameter returnTypeParameter)",
    "source_code": "\tprotected void registerReturnTypeHints(ReflectionHints hints, MethodParameter returnTypeParameter) {\n\t\tif (!void.class.equals(returnTypeParameter.getParameterType())) {\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, returnTypeParameter.getGenericParameterType());\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.GenericMessage": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An implementation of {@link Message} with a generic payload.\n * Once created, a GenericMessage is immutable.\n *\n * @author Mark Fisher\n * @since 4.0\n * @param <T> the payload type\n * @see MessageBuilder\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "signature": "public class GenericMessage",
    "source_code": "public class GenericMessage<T> implements Message<T>, Serializable {\n\n\tprivate static final long serialVersionUID = 4268801052358035098L;\n\n\t@SuppressWarnings(\"serial\")\n\tprivate final T payload;\n\n\tprivate final MessageHeaders headers;\n\n\n\t/**\n\t * Create a new message with the given payload.\n\t * @param payload the message payload (never {@code null})\n\t */\n\tpublic GenericMessage(T payload) {\n\t\tthis(payload, new MessageHeaders(null));\n\t}\n\n\t/**\n\t * Create a new message with the given payload and headers.\n\t * The content of the given header map is copied.\n\t * @param payload the message payload (never {@code null})\n\t * @param headers message headers to use for initialization\n\t */\n\tpublic GenericMessage(T payload, Map<String, Object> headers) {\n\t\tthis(payload, new MessageHeaders(headers));\n\t}\n\n\t/**\n\t * A constructor with the {@link MessageHeaders} instance to use.\n\t * <p><strong>Note:</strong> the given {@code MessageHeaders} instance is used\n\t * directly in the new message, i.e. it is not copied.\n\t * @param payload the message payload (never {@code null})\n\t * @param headers message headers\n\t */\n\tpublic GenericMessage(T payload, MessageHeaders headers) {\n\t\tAssert.notNull(payload, \"Payload must not be null\");\n\t\tAssert.notNull(headers, \"MessageHeaders must not be null\");\n\t\tthis.payload = payload;\n\t\tthis.headers = headers;\n\t}\n\n\n\t@Override\n\tpublic T getPayload() {\n\t\treturn this.payload;\n\t}\n\n\t@Override\n\tpublic MessageHeaders getHeaders() {\n\t\treturn this.headers;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(other instanceof GenericMessage<?> otherMsg)) {\n\t\t\treturn false;\n\t\t}\n\t\t// Using nullSafeEquals for proper array equals comparisons\n\t\treturn (ObjectUtils.nullSafeEquals(this.payload, otherMsg.payload) && this.headers.equals(otherMsg.headers));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\t// Using nullSafeHashCode for proper array hashCode handling\n\t\treturn (ObjectUtils.nullSafeHashCode(this.payload) * 23 + this.headers.hashCode());\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(getClass().getSimpleName());\n\t\tsb.append(\" [payload=\");\n\t\tif (this.payload instanceof byte[]) {\n\t\t\tsb.append(\"byte[\").append(((byte[]) this.payload).length).append(']');\n\t\t}\n\t\telse {\n\t\t\tsb.append(this.payload);\n\t\t}\n\t\tsb.append(\", headers=\").append(this.headers).append(']');\n\t\treturn sb.toString();\n\t}\n\n}"
  },
  "org.springframework.messaging.support.GenericMessage#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(other instanceof GenericMessage<?> otherMsg)) {\n\t\t\treturn false;\n\t\t}\n\t\t// Using nullSafeEquals for proper array equals comparisons\n\t\treturn (ObjectUtils.nullSafeEquals(this.payload, otherMsg.payload) && this.headers.equals(otherMsg.headers));\n\t}"
  },
  "org.springframework.messaging.support.GenericMessage#getHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "MessageHeaders",
    "signature": "public MessageHeaders getHeaders()",
    "source_code": "\tpublic MessageHeaders getHeaders() {\n\t\treturn this.headers;\n\t}"
  },
  "org.springframework.messaging.support.GenericMessage#getPayload()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "T",
    "signature": "public T getPayload()",
    "source_code": "\tpublic T getPayload() {\n\t\treturn this.payload;\n\t}"
  },
  "org.springframework.messaging.support.GenericMessage#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\t// Using nullSafeHashCode for proper array hashCode handling\n\t\treturn (ObjectUtils.nullSafeHashCode(this.payload) * 23 + this.headers.hashCode());\n\t}"
  },
  "org.springframework.messaging.support.GenericMessage#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(getClass().getSimpleName());\n\t\tsb.append(\" [payload=\");\n\t\tif (this.payload instanceof byte[]) {\n\t\t\tsb.append(\"byte[\").append(((byte[]) this.payload).length).append(']');\n\t\t}\n\t\telse {\n\t\t\tsb.append(this.payload);\n\t\t}\n\t\tsb.append(\", headers=\").append(this.headers).append(']');\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.messaging.support.MessageBuilder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A builder for creating a {@link GenericMessage}\n * (or {@link ErrorMessage} if the payload is of type {@link Throwable}).\n *\n * @author Arjen Poutsma\n * @author Mark Fisher\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 4.0\n * @param <T> the message payload type\n * @see GenericMessage\n * @see ErrorMessage\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class MessageBuilder",
    "source_code": "public final class MessageBuilder<T> {\n\n\tprivate final T payload;\n\n\t@Nullable\n\tprivate final Message<T> providedMessage;\n\n\tprivate MessageHeaderAccessor headerAccessor;\n\n\n\tprivate MessageBuilder(Message<T> providedMessage) {\n\t\tAssert.notNull(providedMessage, \"Message must not be null\");\n\t\tthis.payload = providedMessage.getPayload();\n\t\tthis.providedMessage = providedMessage;\n\t\tthis.headerAccessor = new MessageHeaderAccessor(providedMessage);\n\t}\n\n\tprivate MessageBuilder(T payload, MessageHeaderAccessor accessor) {\n\t\tAssert.notNull(payload, \"Payload must not be null\");\n\t\tAssert.notNull(accessor, \"MessageHeaderAccessor must not be null\");\n\t\tthis.payload = payload;\n\t\tthis.providedMessage = null;\n\t\tthis.headerAccessor = accessor;\n\t}\n\n\n\t/**\n\t * Set the message headers to use by providing a {@code MessageHeaderAccessor}.\n\t * @param accessor the headers to use\n\t */\n\tpublic MessageBuilder<T> setHeaders(MessageHeaderAccessor accessor) {\n\t\tAssert.notNull(accessor, \"MessageHeaderAccessor must not be null\");\n\t\tthis.headerAccessor = accessor;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the value for the given header name. If the provided value is {@code null},\n\t * the header will be removed.\n\t */\n\tpublic MessageBuilder<T> setHeader(String headerName, @Nullable Object headerValue) {\n\t\tthis.headerAccessor.setHeader(headerName, headerValue);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the value for the given header name only if the header name is not already\n\t * associated with a value.\n\t */\n\tpublic MessageBuilder<T> setHeaderIfAbsent(String headerName, Object headerValue) {\n\t\tthis.headerAccessor.setHeaderIfAbsent(headerName, headerValue);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes all headers provided via array of 'headerPatterns'. As the name suggests\n\t * the array may contain simple matching patterns for header names. Supported pattern\n\t * styles are: \"xxx*\", \"*xxx\", \"*xxx*\" and \"xxx*yyy\".\n\t */\n\tpublic MessageBuilder<T> removeHeaders(String... headerPatterns) {\n\t\tthis.headerAccessor.removeHeaders(headerPatterns);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove the value for the given header name.\n\t */\n\tpublic MessageBuilder<T> removeHeader(String headerName) {\n\t\tthis.headerAccessor.removeHeader(headerName);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Copy the name-value pairs from the provided Map. This operation will overwrite any\n\t * existing values. Use {@link #copyHeadersIfAbsent(Map)} to avoid overwriting\n\t * values. Note that the 'id' and 'timestamp' header values will never be overwritten.\n\t */\n\tpublic MessageBuilder<T> copyHeaders(@Nullable Map<String, ?> headersToCopy) {\n\t\tthis.headerAccessor.copyHeaders(headersToCopy);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Copy the name-value pairs from the provided Map. This operation will <em>not</em>\n\t * overwrite any existing values.\n\t */\n\tpublic MessageBuilder<T> copyHeadersIfAbsent(@Nullable Map<String, ?> headersToCopy) {\n\t\tthis.headerAccessor.copyHeadersIfAbsent(headersToCopy);\n\t\treturn this;\n\t}\n\n\tpublic MessageBuilder<T> setReplyChannel(MessageChannel replyChannel) {\n\t\tthis.headerAccessor.setReplyChannel(replyChannel);\n\t\treturn this;\n\t}\n\n\tpublic MessageBuilder<T> setReplyChannelName(String replyChannelName) {\n\t\tthis.headerAccessor.setReplyChannelName(replyChannelName);\n\t\treturn this;\n\t}\n\n\tpublic MessageBuilder<T> setErrorChannel(MessageChannel errorChannel) {\n\t\tthis.headerAccessor.setErrorChannel(errorChannel);\n\t\treturn this;\n\t}\n\n\tpublic MessageBuilder<T> setErrorChannelName(String errorChannelName) {\n\t\tthis.headerAccessor.setErrorChannelName(errorChannelName);\n\t\treturn this;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Message<T> build() {\n\t\tif (this.providedMessage != null && !this.headerAccessor.isModified()) {\n\t\t\treturn this.providedMessage;\n\t\t}\n\t\tMessageHeaders headersToUse = this.headerAccessor.toMessageHeaders();\n\t\tif (this.payload instanceof Throwable throwable) {\n\t\t\tif (this.providedMessage != null && this.providedMessage instanceof ErrorMessage errorMessage) {\n\t\t\t\tMessage<?> message = errorMessage.getOriginalMessage();\n\t\t\t\tif (message != null) {\n\t\t\t\t\treturn (Message<T>) new ErrorMessage(throwable, headersToUse, message);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (Message<T>) new ErrorMessage(throwable, headersToUse);\n\t\t}\n\t\telse {\n\t\t\treturn new GenericMessage<>(this.payload, headersToUse);\n\t\t}\n\t}\n\n\n\t/**\n\t * Create a builder for a new {@link Message} instance pre-populated with all the\n\t * headers copied from the provided message. The payload of the provided Message will\n\t * also be used as the payload for the new message.\n\t * <p>If the provided message is an {@link ErrorMessage}, the\n\t * {@link ErrorMessage#getOriginalMessage() originalMessage} it contains, will be\n\t * passed on to new instance.\n\t * @param message the Message from which the payload and all headers will be copied\n\t */\n\tpublic static <T> MessageBuilder<T> fromMessage(Message<T> message) {\n\t\treturn new MessageBuilder<>(message);\n\t}\n\n\t/**\n\t * Create a new builder for a message with the given payload.\n\t * @param payload the payload\n\t */\n\tpublic static <T> MessageBuilder<T> withPayload(T payload) {\n\t\treturn new MessageBuilder<>(payload, new MessageHeaderAccessor());\n\t}\n\n\t/**\n\t * A shortcut factory method for creating a message with the given payload\n\t * and {@code MessageHeaders}.\n\t * <p><strong>Note:</strong> the given {@code MessageHeaders} instance is used\n\t * directly in the new message, i.e. it is not copied.\n\t * @param payload the payload to use (never {@code null})\n\t * @param messageHeaders the headers to use (never {@code null})\n\t * @return the created message\n\t * @since 4.1\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T> Message<T> createMessage(@Nullable T payload, MessageHeaders messageHeaders) {\n\t\tAssert.notNull(payload, \"Payload must not be null\");\n\t\tAssert.notNull(messageHeaders, \"MessageHeaders must not be null\");\n\t\tif (payload instanceof Throwable throwable) {\n\t\t\treturn (Message<T>) new ErrorMessage(throwable, messageHeaders);\n\t\t}\n\t\telse {\n\t\t\treturn new GenericMessage<>(payload, messageHeaders);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.messaging.support.MessageBuilder#build()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "Message<T>",
    "signature": "public Message<T> build()",
    "source_code": "\tpublic Message<T> build() {\n\t\tif (this.providedMessage != null && !this.headerAccessor.isModified()) {\n\t\t\treturn this.providedMessage;\n\t\t}\n\t\tMessageHeaders headersToUse = this.headerAccessor.toMessageHeaders();\n\t\tif (this.payload instanceof Throwable throwable) {\n\t\t\tif (this.providedMessage != null && this.providedMessage instanceof ErrorMessage errorMessage) {\n\t\t\t\tMessage<?> message = errorMessage.getOriginalMessage();\n\t\t\t\tif (message != null) {\n\t\t\t\t\treturn (Message<T>) new ErrorMessage(throwable, headersToUse, message);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (Message<T>) new ErrorMessage(throwable, headersToUse);\n\t\t}\n\t\telse {\n\t\t\treturn new GenericMessage<>(this.payload, headersToUse);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.MessageBuilder#copyHeaders(Map<String,headersToCopy)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the name-value pairs from the provided Map. This operation will overwrite any\n\t * existing values. Use {@link #copyHeadersIfAbsent(Map)} to avoid overwriting\n\t * values. Note that the 'id' and 'timestamp' header values will never be overwritten.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headersToCopy"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> copyHeaders(@Nullable Map<String, ?> headersToCopy)",
    "source_code": "\tpublic MessageBuilder<T> copyHeaders(@Nullable Map<String, ?> headersToCopy) {\n\t\tthis.headerAccessor.copyHeaders(headersToCopy);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.MessageBuilder#copyHeadersIfAbsent(Map<String,headersToCopy)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the name-value pairs from the provided Map. This operation will <em>not</em>\n\t * overwrite any existing values.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headersToCopy"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> copyHeadersIfAbsent(@Nullable Map<String, ?> headersToCopy)",
    "source_code": "\tpublic MessageBuilder<T> copyHeadersIfAbsent(@Nullable Map<String, ?> headersToCopy) {\n\t\tthis.headerAccessor.copyHeadersIfAbsent(headersToCopy);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.MessageBuilder#createMessage(payload,messageHeaders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A shortcut factory method for creating a message with the given payload\n\t * and {@code MessageHeaders}.\n\t * <p><strong>Note:</strong> the given {@code MessageHeaders} instance is used\n\t * directly in the new message, i.e. it is not copied.\n\t * @param payload the payload to use (never {@code null})\n\t * @param messageHeaders the headers to use (never {@code null})\n\t * @return the created message\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload",
      "messageHeaders"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "Message<T>",
    "signature": "public Message<T> createMessage(@Nullable T payload, MessageHeaders messageHeaders)",
    "source_code": "\tpublic static <T> Message<T> createMessage(@Nullable T payload, MessageHeaders messageHeaders) {\n\t\tAssert.notNull(payload, \"Payload must not be null\");\n\t\tAssert.notNull(messageHeaders, \"MessageHeaders must not be null\");\n\t\tif (payload instanceof Throwable throwable) {\n\t\t\treturn (Message<T>) new ErrorMessage(throwable, messageHeaders);\n\t\t}\n\t\telse {\n\t\t\treturn new GenericMessage<>(payload, messageHeaders);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.MessageBuilder#fromMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder for a new {@link Message} instance pre-populated with all the\n\t * headers copied from the provided message. The payload of the provided Message will\n\t * also be used as the payload for the new message.\n\t * <p>If the provided message is an {@link ErrorMessage}, the\n\t * {@link ErrorMessage#getOriginalMessage() originalMessage} it contains, will be\n\t * passed on to new instance.\n\t * @param message the Message from which the payload and all headers will be copied\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> fromMessage(Message<T> message)",
    "source_code": "\tpublic static <T> MessageBuilder<T> fromMessage(Message<T> message) {\n\t\treturn new MessageBuilder<>(message);\n\t}"
  },
  "org.springframework.messaging.support.MessageBuilder#removeHeader(headerName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Remove the value for the given header name.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> removeHeader(String headerName)",
    "source_code": "\tpublic MessageBuilder<T> removeHeader(String headerName) {\n\t\tthis.headerAccessor.removeHeader(headerName);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.MessageBuilder#removeHeaders(headerPatterns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Removes all headers provided via array of 'headerPatterns'. As the name suggests\n\t * the array may contain simple matching patterns for header names. Supported pattern\n\t * styles are: \"xxx*\", \"*xxx\", \"*xxx*\" and \"xxx*yyy\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerPatterns"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> removeHeaders(String... headerPatterns)",
    "source_code": "\tpublic MessageBuilder<T> removeHeaders(String... headerPatterns) {\n\t\tthis.headerAccessor.removeHeaders(headerPatterns);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.MessageBuilder#setErrorChannel(errorChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorChannel"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> setErrorChannel(MessageChannel errorChannel)",
    "source_code": "\tpublic MessageBuilder<T> setErrorChannel(MessageChannel errorChannel) {\n\t\tthis.headerAccessor.setErrorChannel(errorChannel);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.MessageBuilder#setErrorChannelName(errorChannelName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorChannelName"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> setErrorChannelName(String errorChannelName)",
    "source_code": "\tpublic MessageBuilder<T> setErrorChannelName(String errorChannelName) {\n\t\tthis.headerAccessor.setErrorChannelName(errorChannelName);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.MessageBuilder#setHeader(headerName,headerValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for the given header name. If the provided value is {@code null},\n\t * the header will be removed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> setHeader(String headerName, @Nullable Object headerValue)",
    "source_code": "\tpublic MessageBuilder<T> setHeader(String headerName, @Nullable Object headerValue) {\n\t\tthis.headerAccessor.setHeader(headerName, headerValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.MessageBuilder#setHeaderIfAbsent(headerName,headerValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for the given header name only if the header name is not already\n\t * associated with a value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> setHeaderIfAbsent(String headerName, Object headerValue)",
    "source_code": "\tpublic MessageBuilder<T> setHeaderIfAbsent(String headerName, Object headerValue) {\n\t\tthis.headerAccessor.setHeaderIfAbsent(headerName, headerValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.MessageBuilder#setHeaders(accessor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the message headers to use by providing a {@code MessageHeaderAccessor}.\n\t * @param accessor the headers to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "accessor"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> setHeaders(MessageHeaderAccessor accessor)",
    "source_code": "\tpublic MessageBuilder<T> setHeaders(MessageHeaderAccessor accessor) {\n\t\tAssert.notNull(accessor, \"MessageHeaderAccessor must not be null\");\n\t\tthis.headerAccessor = accessor;\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.MessageBuilder#setReplyChannel(replyChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "replyChannel"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> setReplyChannel(MessageChannel replyChannel)",
    "source_code": "\tpublic MessageBuilder<T> setReplyChannel(MessageChannel replyChannel) {\n\t\tthis.headerAccessor.setReplyChannel(replyChannel);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.MessageBuilder#setReplyChannelName(replyChannelName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "replyChannelName"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> setReplyChannelName(String replyChannelName)",
    "source_code": "\tpublic MessageBuilder<T> setReplyChannelName(String replyChannelName) {\n\t\tthis.headerAccessor.setReplyChannelName(replyChannelName);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.MessageBuilder#withPayload(payload)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new builder for a message with the given payload.\n\t * @param payload the payload\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> withPayload(T payload)",
    "source_code": "\tpublic static <T> MessageBuilder<T> withPayload(T payload) {\n\t\treturn new MessageBuilder<>(payload, new MessageHeaderAccessor());\n\t}"
  },
  "org.springframework.scripting.bsh.BshExecutionException": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Exception to be thrown on script execution failure.\n\t */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "signature": "public class BshExecutionException",
    "source_code": "\tpublic static final class BshExecutionException extends NestedRuntimeException {\n\n\t\tprivate BshExecutionException(EvalError ex) {\n\t\t\tsuper(\"BeanShell script execution failed\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.scripting.bsh.BshScriptUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility methods for handling BeanShell-scripted objects.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @since 2.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class BshScriptUtils",
    "source_code": "public abstract class BshScriptUtils {\n\n\t/**\n\t * Create a new BeanShell-scripted object from the given script source.\n\t * <p>With this {@code createBshObject} variant, the script needs to\n\t * declare a full class or return an actual instance of the scripted object.\n\t * @param scriptSource the script source text\n\t * @return the scripted Java object\n\t * @throws EvalError in case of BeanShell parsing failure\n\t */\n\tpublic static Object createBshObject(String scriptSource) throws EvalError {\n\t\treturn createBshObject(scriptSource, null, null);\n\t}\n\n\t/**\n\t * Create a new BeanShell-scripted object from the given script source,\n\t * using the default ClassLoader.\n\t * <p>The script may either be a simple script that needs a corresponding proxy\n\t * generated (implementing the specified interfaces), or declare a full class\n\t * or return an actual instance of the scripted object (in which case the\n\t * specified interfaces, if any, need to be implemented by that class/instance).\n\t * @param scriptSource the script source text\n\t * @param scriptInterfaces the interfaces that the scripted Java object is\n\t * supposed to implement (may be {@code null} or empty if the script itself\n\t * declares a full class or returns an actual instance of the scripted object)\n\t * @return the scripted Java object\n\t * @throws EvalError in case of BeanShell parsing failure\n\t * @see #createBshObject(String, Class[], ClassLoader)\n\t */\n\tpublic static Object createBshObject(String scriptSource, @Nullable Class<?>... scriptInterfaces) throws EvalError {\n\t\treturn createBshObject(scriptSource, scriptInterfaces, ClassUtils.getDefaultClassLoader());\n\t}\n\n\t/**\n\t * Create a new BeanShell-scripted object from the given script source.\n\t * <p>The script may either be a simple script that needs a corresponding proxy\n\t * generated (implementing the specified interfaces), or declare a full class\n\t * or return an actual instance of the scripted object (in which case the\n\t * specified interfaces, if any, need to be implemented by that class/instance).\n\t * @param scriptSource the script source text\n\t * @param scriptInterfaces the interfaces that the scripted Java object is\n\t * supposed to implement (may be {@code null} or empty if the script itself\n\t * declares a full class or returns an actual instance of the scripted object)\n\t * @param classLoader the ClassLoader to use for evaluating the script\n\t * @return the scripted Java object\n\t * @throws EvalError in case of BeanShell parsing failure\n\t */\n\tpublic static Object createBshObject(String scriptSource, @Nullable Class<?>[] scriptInterfaces, @Nullable ClassLoader classLoader)\n\t\t\tthrows EvalError {\n\n\t\tObject result = evaluateBshScript(scriptSource, scriptInterfaces, classLoader);\n\t\tif (result instanceof Class<?> clazz) {\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(clazz).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalStateException(\"Could not instantiate script class: \" + clazz.getName(), ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/**\n\t * Evaluate the specified BeanShell script based on the given script source,\n\t * returning the Class defined by the script.\n\t * <p>The script may either declare a full class or return an actual instance of\n\t * the scripted object (in which case the Class of the object will be returned).\n\t * In any other case, the returned Class will be {@code null}.\n\t * @param scriptSource the script source text\n\t * @param classLoader the ClassLoader to use for evaluating the script\n\t * @return the scripted Java class, or {@code null} if none could be determined\n\t * @throws EvalError in case of BeanShell parsing failure\n\t */\n\t@Nullable\n\tstatic Class<?> determineBshObjectType(String scriptSource, @Nullable ClassLoader classLoader) throws EvalError {\n\t\tAssert.hasText(scriptSource, \"Script source must not be empty\");\n\t\tInterpreter interpreter = new Interpreter();\n\t\tif (classLoader != null) {\n\t\t\tinterpreter.setClassLoader(classLoader);\n\t\t}\n\t\tObject result = interpreter.eval(scriptSource);\n\t\tif (result instanceof Class) {\n\t\t\treturn (Class<?>) result;\n\t\t}\n\t\telse if (result != null) {\n\t\t\treturn result.getClass();\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Evaluate the specified BeanShell script based on the given script source,\n\t * keeping a returned script Class or script Object as-is.\n\t * <p>The script may either be a simple script that needs a corresponding proxy\n\t * generated (implementing the specified interfaces), or declare a full class\n\t * or return an actual instance of the scripted object (in which case the\n\t * specified interfaces, if any, need to be implemented by that class/instance).\n\t * @param scriptSource the script source text\n\t * @param scriptInterfaces the interfaces that the scripted Java object is\n\t * supposed to implement (may be {@code null} or empty if the script itself\n\t * declares a full class or returns an actual instance of the scripted object)\n\t * @param classLoader the ClassLoader to use for evaluating the script\n\t * @return the scripted Java class or Java object\n\t * @throws EvalError in case of BeanShell parsing failure\n\t */\n\tstatic Object evaluateBshScript(\n\t\t\tString scriptSource, @Nullable Class<?>[] scriptInterfaces, @Nullable ClassLoader classLoader)\n\t\t\tthrows EvalError {\n\n\t\tAssert.hasText(scriptSource, \"Script source must not be empty\");\n\t\tInterpreter interpreter = new Interpreter();\n\t\tinterpreter.setClassLoader(classLoader);\n\t\tObject result = interpreter.eval(scriptSource);\n\t\tif (result != null) {\n\t\t\treturn result;\n\t\t}\n\t\telse {\n\t\t\t// Simple BeanShell script: Let's create a proxy for it, implementing the given interfaces.\n\t\t\tif (ObjectUtils.isEmpty(scriptInterfaces)) {\n\t\t\t\tthrow new IllegalArgumentException(\"Given script requires a script proxy: \" +\n\t\t\t\t\t\t\"At least one script interface is required.\\nScript: \" + scriptSource);\n\t\t\t}\n\t\t\tXThis xt = (XThis) interpreter.eval(\"return this\");\n\t\t\treturn Proxy.newProxyInstance(classLoader, scriptInterfaces, new BshObjectInvocationHandler(xt));\n\t\t}\n\t}\n\n\n\t/**\n\t * InvocationHandler that invokes a BeanShell script method.\n\t */\n\tprivate static class BshObjectInvocationHandler implements InvocationHandler {\n\n\t\tprivate final XThis xt;\n\n\t\tpublic BshObjectInvocationHandler(XThis xt) {\n\t\t\tthis.xt = xt;\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tif (ReflectionUtils.isEqualsMethod(method)) {\n\t\t\t\treturn (isProxyForSameBshObject(args[0]));\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isHashCodeMethod(method)) {\n\t\t\t\treturn this.xt.hashCode();\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isToStringMethod(method)) {\n\t\t\t\treturn \"BeanShell object [\" + this.xt + \"]\";\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tObject result = this.xt.invokeMethod(method.getName(), args);\n\t\t\t\tif (result == Primitive.NULL || result == Primitive.VOID) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (result instanceof Primitive) {\n\t\t\t\t\treturn ((Primitive) result).getValue();\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcatch (EvalError ex) {\n\t\t\t\tthrow new BshExecutionException(ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean isProxyForSameBshObject(Object other) {\n\t\t\tif (!Proxy.isProxyClass(other.getClass())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tInvocationHandler ih = Proxy.getInvocationHandler(other);\n\t\t\treturn (ih instanceof BshObjectInvocationHandler &&\n\t\t\t\t\tthis.xt.equals(((BshObjectInvocationHandler) ih).xt));\n\t\t}\n\t}\n\n\n\t/**\n\t * Exception to be thrown on script execution failure.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tpublic static final class BshExecutionException extends NestedRuntimeException {\n\n\t\tprivate BshExecutionException(EvalError ex) {\n\t\t\tsuper(\"BeanShell script execution failed\", ex);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.scripting.bsh.BshScriptUtils#createBshObject(scriptSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new BeanShell-scripted object from the given script source.\n\t * <p>With this {@code createBshObject} variant, the script needs to\n\t * declare a full class or return an actual instance of the scripted object.\n\t * @param scriptSource the script source text\n\t * @return the scripted Java object\n\t * @throws EvalError in case of BeanShell parsing failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "Object",
    "signature": "public Object createBshObject(String scriptSource)",
    "source_code": "\tpublic static Object createBshObject(String scriptSource) throws EvalError {\n\t\treturn createBshObject(scriptSource, null, null);\n\t}"
  },
  "org.springframework.scripting.bsh.BshScriptUtils#createBshObject(scriptSource,scriptInterfaces)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new BeanShell-scripted object from the given script source,\n\t * using the default ClassLoader.\n\t * <p>The script may either be a simple script that needs a corresponding proxy\n\t * generated (implementing the specified interfaces), or declare a full class\n\t * or return an actual instance of the scripted object (in which case the\n\t * specified interfaces, if any, need to be implemented by that class/instance).\n\t * @param scriptSource the script source text\n\t * @param scriptInterfaces the interfaces that the scripted Java object is\n\t * supposed to implement (may be {@code null} or empty if the script itself\n\t * declares a full class or returns an actual instance of the scripted object)\n\t * @return the scripted Java object\n\t * @throws EvalError in case of BeanShell parsing failure\n\t * @see #createBshObject(String, Class[], ClassLoader)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource",
      "scriptInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "Object",
    "signature": "public Object createBshObject(String scriptSource, @Nullable Class<?>... scriptInterfaces)",
    "source_code": "\tpublic static Object createBshObject(String scriptSource, @Nullable Class<?>... scriptInterfaces) throws EvalError {\n\t\treturn createBshObject(scriptSource, scriptInterfaces, ClassUtils.getDefaultClassLoader());\n\t}"
  },
  "org.springframework.scripting.bsh.BshScriptUtils#createBshObject(scriptSource,scriptInterfaces,classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new BeanShell-scripted object from the given script source.\n\t * <p>The script may either be a simple script that needs a corresponding proxy\n\t * generated (implementing the specified interfaces), or declare a full class\n\t * or return an actual instance of the scripted object (in which case the\n\t * specified interfaces, if any, need to be implemented by that class/instance).\n\t * @param scriptSource the script source text\n\t * @param scriptInterfaces the interfaces that the scripted Java object is\n\t * supposed to implement (may be {@code null} or empty if the script itself\n\t * declares a full class or returns an actual instance of the scripted object)\n\t * @param classLoader the ClassLoader to use for evaluating the script\n\t * @return the scripted Java object\n\t * @throws EvalError in case of BeanShell parsing failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource",
      "scriptInterfaces",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "Object",
    "signature": "public Object createBshObject(String scriptSource, @Nullable Class<?>[] scriptInterfaces, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static Object createBshObject(String scriptSource, @Nullable Class<?>[] scriptInterfaces, @Nullable ClassLoader classLoader)"
  },
  "org.springframework.scripting.bsh.BshScriptUtils#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tif (ReflectionUtils.isEqualsMethod(method)) {\n\t\t\t\treturn (isProxyForSameBshObject(args[0]));\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isHashCodeMethod(method)) {\n\t\t\t\treturn this.xt.hashCode();\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isToStringMethod(method)) {\n\t\t\t\treturn \"BeanShell object [\" + this.xt + \"]\";\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tObject result = this.xt.invokeMethod(method.getName(), args);\n\t\t\t\tif (result == Primitive.NULL || result == Primitive.VOID) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (result instanceof Primitive) {\n\t\t\t\t\treturn ((Primitive) result).getValue();\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcatch (EvalError ex) {\n\t\t\t\tthrow new BshExecutionException(ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.transaction.annotation.TransactionManagementConfigurationSelector": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Selects which implementation of {@link AbstractTransactionManagementConfiguration}\n * should be used based on the value of {@link EnableTransactionManagement#mode} on the\n * importing {@code @Configuration} class.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.1\n * @see EnableTransactionManagement\n * @see ProxyTransactionManagementConfiguration\n * @see TransactionManagementConfigUtils#TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME\n * @see TransactionManagementConfigUtils#JTA_TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class TransactionManagementConfigurationSelector",
    "source_code": "public class TransactionManagementConfigurationSelector extends AdviceModeImportSelector<EnableTransactionManagement> {\n\n\t/**\n\t * Returns {@link ProxyTransactionManagementConfiguration} or\n\t * {@code AspectJ(Jta)TransactionManagementConfiguration} for {@code PROXY}\n\t * and {@code ASPECTJ} values of {@link EnableTransactionManagement#mode()},\n\t * respectively.\n\t */\n\t@Override\n\tprotected String[] selectImports(AdviceMode adviceMode) {\n\t\treturn switch (adviceMode) {\n\t\t\tcase PROXY -> new String[] {AutoProxyRegistrar.class.getName(),\n\t\t\t\t\tProxyTransactionManagementConfiguration.class.getName()};\n\t\t\tcase ASPECTJ -> new String[] {determineTransactionAspectClass()};\n\t\t};\n\t}\n\n\tprivate String determineTransactionAspectClass() {\n\t\treturn (ClassUtils.isPresent(\"jakarta.transaction.Transactional\", getClass().getClassLoader()) ?\n\t\t\t\tTransactionManagementConfigUtils.JTA_TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME :\n\t\t\t\tTransactionManagementConfigUtils.TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME);\n\t}\n\n}"
  },
  "org.springframework.transaction.annotation.TransactionManagementConfigurationSelector#selectImports(adviceMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@link ProxyTransactionManagementConfiguration} or\n\t * {@code AspectJ(Jta)TransactionManagementConfiguration} for {@code PROXY}\n\t * and {@code ASPECTJ} values of {@link EnableTransactionManagement#mode()},\n\t * respectively.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "adviceMode"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "String[]",
    "signature": "protected String[] selectImports(AdviceMode adviceMode)",
    "source_code": "\tprotected String[] selectImports(AdviceMode adviceMode) {\n\t\treturn switch (adviceMode) {\n\t\t\tcase PROXY -> new String[] {AutoProxyRegistrar.class.getName(),\n\t\t\t\t\tProxyTransactionManagementConfiguration.class.getName()};\n\t\t\tcase ASPECTJ -> new String[] {determineTransactionAspectClass()};\n\t\t};\n\t}"
  },
  "org.springframework.ui.context.support.ResourceBundleThemeSource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link ThemeSource} implementation that looks up an individual\n * {@link java.util.ResourceBundle} per theme. The theme name gets\n * interpreted as ResourceBundle basename, supporting a common\n * basename prefix for all themes.\n *\n * @author Jean-Pierre Pawlak\n * @author Juergen Hoeller\n * @see #setBasenamePrefix\n * @see java.util.ResourceBundle\n * @see org.springframework.context.support.ResourceBundleMessageSource\n * @deprecated as of 6.0 in favor of using CSS, without direct replacement\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class ResourceBundleThemeSource",
    "source_code": "public class ResourceBundleThemeSource implements HierarchicalThemeSource, BeanClassLoaderAware {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t@Nullable\n\tprivate ThemeSource parentThemeSource;\n\n\tprivate String basenamePrefix = \"\";\n\n\t@Nullable\n\tprivate String defaultEncoding;\n\n\t@Nullable\n\tprivate Boolean fallbackToSystemLocale;\n\n\t@Nullable\n\tprivate ClassLoader beanClassLoader;\n\n\t/** Map from theme name to Theme instance. */\n\tprivate final Map<String, Theme> themeCache = new ConcurrentHashMap<>();\n\n\n\t@Override\n\tpublic void setParentThemeSource(@Nullable ThemeSource parent) {\n\t\tthis.parentThemeSource = parent;\n\n\t\t// Update existing Theme objects.\n\t\t// Usually there shouldn't be any at the time of this call.\n\t\tsynchronized (this.themeCache) {\n\t\t\tfor (Theme theme : this.themeCache.values()) {\n\t\t\t\tinitParent(theme);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic ThemeSource getParentThemeSource() {\n\t\treturn this.parentThemeSource;\n\t}\n\n\t/**\n\t * Set the prefix that gets applied to the ResourceBundle basenames,\n\t * i.e. the theme names.\n\t * E.g.: basenamePrefix=\"test.\", themeName=\"theme\" &rarr; basename=\"test.theme\".\n\t * <p>Note that ResourceBundle names are effectively classpath locations: As a\n\t * consequence, the JDK's standard ResourceBundle treats dots as package separators.\n\t * This means that \"test.theme\" is effectively equivalent to \"test/theme\",\n\t * just like it is for programmatic {@code java.util.ResourceBundle} usage.\n\t * @see java.util.ResourceBundle#getBundle(String)\n\t */\n\tpublic void setBasenamePrefix(@Nullable String basenamePrefix) {\n\t\tthis.basenamePrefix = (basenamePrefix != null ? basenamePrefix : \"\");\n\t}\n\n\t/**\n\t * Set the default charset to use for parsing resource bundle files.\n\t * <p>{@link ResourceBundleMessageSource}'s default is the\n\t * {@code java.util.ResourceBundle} default encoding: ISO-8859-1.\n\t * @since 4.2\n\t * @see ResourceBundleMessageSource#setDefaultEncoding\n\t */\n\tpublic void setDefaultEncoding(@Nullable String defaultEncoding) {\n\t\tthis.defaultEncoding = defaultEncoding;\n\t}\n\n\t/**\n\t * Set whether to fall back to the system Locale if no files for a\n\t * specific Locale have been found.\n\t * <p>{@link ResourceBundleMessageSource}'s default is \"true\".\n\t * @since 4.2\n\t * @see ResourceBundleMessageSource#setFallbackToSystemLocale\n\t */\n\tpublic void setFallbackToSystemLocale(boolean fallbackToSystemLocale) {\n\t\tthis.fallbackToSystemLocale = fallbackToSystemLocale;\n\t}\n\n\t@Override\n\tpublic void setBeanClassLoader(@Nullable ClassLoader beanClassLoader) {\n\t\tthis.beanClassLoader = beanClassLoader;\n\t}\n\n\n\t/**\n\t * This implementation returns a SimpleTheme instance, holding a\n\t * ResourceBundle-based MessageSource whose basename corresponds to\n\t * the given theme name (prefixed by the configured \"basenamePrefix\").\n\t * <p>SimpleTheme instances are cached per theme name. Use a reloadable\n\t * MessageSource if themes should reflect changes to the underlying files.\n\t * @see #setBasenamePrefix\n\t * @see #createMessageSource\n\t */\n\t@Override\n\t@Nullable\n\tpublic Theme getTheme(String themeName) {\n\t\tTheme theme = this.themeCache.get(themeName);\n\t\tif (theme == null) {\n\t\t\tsynchronized (this.themeCache) {\n\t\t\t\ttheme = this.themeCache.get(themeName);\n\t\t\t\tif (theme == null) {\n\t\t\t\t\tString basename = this.basenamePrefix + themeName;\n\t\t\t\t\tMessageSource messageSource = createMessageSource(basename);\n\t\t\t\t\ttheme = new SimpleTheme(themeName, messageSource);\n\t\t\t\t\tinitParent(theme);\n\t\t\t\t\tthis.themeCache.put(themeName, theme);\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Theme created: name '\" + themeName + \"', basename [\" + basename + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theme;\n\t}\n\n\t/**\n\t * Create a MessageSource for the given basename,\n\t * to be used as MessageSource for the corresponding theme.\n\t * <p>Default implementation creates a ResourceBundleMessageSource.\n\t * for the given basename. A subclass could create a specifically\n\t * configured ReloadableResourceBundleMessageSource, for example.\n\t * @param basename the basename to create a MessageSource for\n\t * @return the MessageSource\n\t * @see org.springframework.context.support.ResourceBundleMessageSource\n\t * @see org.springframework.context.support.ReloadableResourceBundleMessageSource\n\t */\n\tprotected MessageSource createMessageSource(String basename) {\n\t\tResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();\n\t\tmessageSource.setBasename(basename);\n\t\tif (this.defaultEncoding != null) {\n\t\t\tmessageSource.setDefaultEncoding(this.defaultEncoding);\n\t\t}\n\t\tif (this.fallbackToSystemLocale != null) {\n\t\t\tmessageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale);\n\t\t}\n\t\tif (this.beanClassLoader != null) {\n\t\t\tmessageSource.setBeanClassLoader(this.beanClassLoader);\n\t\t}\n\t\treturn messageSource;\n\t}\n\n\t/**\n\t * Initialize the MessageSource of the given theme with the\n\t * one from the corresponding parent of this ThemeSource.\n\t * @param theme the Theme to (re-)initialize\n\t */\n\tprotected void initParent(Theme theme) {\n\t\tif (theme.getMessageSource() instanceof HierarchicalMessageSource messageSource) {\n\t\t\tif (getParentThemeSource() != null && messageSource.getParentMessageSource() == null) {\n\t\t\t\tTheme parentTheme = getParentThemeSource().getTheme(theme.getName());\n\t\t\t\tif (parentTheme != null) {\n\t\t\t\t\tmessageSource.setParentMessageSource(parentTheme.getMessageSource());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.ui.context.support.ResourceBundleThemeSource#createMessageSource(basename)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a MessageSource for the given basename,\n\t * to be used as MessageSource for the corresponding theme.\n\t * <p>Default implementation creates a ResourceBundleMessageSource.\n\t * for the given basename. A subclass could create a specifically\n\t * configured ReloadableResourceBundleMessageSource, for example.\n\t * @param basename the basename to create a MessageSource for\n\t * @return the MessageSource\n\t * @see org.springframework.context.support.ResourceBundleMessageSource\n\t * @see org.springframework.context.support.ReloadableResourceBundleMessageSource\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "basename"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "MessageSource",
    "signature": "protected MessageSource createMessageSource(String basename)",
    "source_code": "\tprotected MessageSource createMessageSource(String basename) {\n\t\tResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();\n\t\tmessageSource.setBasename(basename);\n\t\tif (this.defaultEncoding != null) {\n\t\t\tmessageSource.setDefaultEncoding(this.defaultEncoding);\n\t\t}\n\t\tif (this.fallbackToSystemLocale != null) {\n\t\t\tmessageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale);\n\t\t}\n\t\tif (this.beanClassLoader != null) {\n\t\t\tmessageSource.setBeanClassLoader(this.beanClassLoader);\n\t\t}\n\t\treturn messageSource;\n\t}"
  },
  "org.springframework.ui.context.support.ResourceBundleThemeSource#getParentThemeSource()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "ThemeSource",
    "signature": "public ThemeSource getParentThemeSource()",
    "source_code": "\tpublic ThemeSource getParentThemeSource() {\n\t\treturn this.parentThemeSource;\n\t}"
  },
  "org.springframework.ui.context.support.ResourceBundleThemeSource#getTheme(themeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns a SimpleTheme instance, holding a\n\t * ResourceBundle-based MessageSource whose basename corresponds to\n\t * the given theme name (prefixed by the configured \"basenamePrefix\").\n\t * <p>SimpleTheme instances are cached per theme name. Use a reloadable\n\t * MessageSource if themes should reflect changes to the underlying files.\n\t * @see #setBasenamePrefix\n\t * @see #createMessageSource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "themeName"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "Theme",
    "signature": "public Theme getTheme(String themeName)",
    "source_code": "\tpublic Theme getTheme(String themeName) {\n\t\tTheme theme = this.themeCache.get(themeName);\n\t\tif (theme == null) {\n\t\t\tsynchronized (this.themeCache) {\n\t\t\t\ttheme = this.themeCache.get(themeName);\n\t\t\t\tif (theme == null) {\n\t\t\t\t\tString basename = this.basenamePrefix + themeName;\n\t\t\t\t\tMessageSource messageSource = createMessageSource(basename);\n\t\t\t\t\ttheme = new SimpleTheme(themeName, messageSource);\n\t\t\t\t\tinitParent(theme);\n\t\t\t\t\tthis.themeCache.put(themeName, theme);\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Theme created: name '\" + themeName + \"', basename [\" + basename + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theme;\n\t}"
  },
  "org.springframework.ui.context.support.ResourceBundleThemeSource#initParent(theme)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the MessageSource of the given theme with the\n\t * one from the corresponding parent of this ThemeSource.\n\t * @param theme the Theme to (re-)initialize\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "theme"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "void",
    "signature": "protected void initParent(Theme theme)",
    "source_code": "\tprotected void initParent(Theme theme) {\n\t\tif (theme.getMessageSource() instanceof HierarchicalMessageSource messageSource) {\n\t\t\tif (getParentThemeSource() != null && messageSource.getParentMessageSource() == null) {\n\t\t\t\tTheme parentTheme = getParentThemeSource().getTheme(theme.getName());\n\t\t\t\tif (parentTheme != null) {\n\t\t\t\t\tmessageSource.setParentMessageSource(parentTheme.getMessageSource());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.ui.context.support.ResourceBundleThemeSource#setBasenamePrefix(basenamePrefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the prefix that gets applied to the ResourceBundle basenames,\n\t * i.e. the theme names.\n\t * E.g.: basenamePrefix=\"test.\", themeName=\"theme\" &rarr; basename=\"test.theme\".\n\t * <p>Note that ResourceBundle names are effectively classpath locations: As a\n\t * consequence, the JDK's standard ResourceBundle treats dots as package separators.\n\t * This means that \"test.theme\" is effectively equivalent to \"test/theme\",\n\t * just like it is for programmatic {@code java.util.ResourceBundle} usage.\n\t * @see java.util.ResourceBundle#getBundle(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "basenamePrefix"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void setBasenamePrefix(@Nullable String basenamePrefix)",
    "source_code": "\tpublic void setBasenamePrefix(@Nullable String basenamePrefix) {\n\t\tthis.basenamePrefix = (basenamePrefix != null ? basenamePrefix : \"\");\n\t}"
  },
  "org.springframework.ui.context.support.ResourceBundleThemeSource#setBeanClassLoader(beanClassLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClassLoader"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void setBeanClassLoader(@Nullable ClassLoader beanClassLoader)",
    "source_code": "\tpublic void setBeanClassLoader(@Nullable ClassLoader beanClassLoader) {\n\t\tthis.beanClassLoader = beanClassLoader;\n\t}"
  },
  "org.springframework.ui.context.support.ResourceBundleThemeSource#setDefaultEncoding(defaultEncoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the default charset to use for parsing resource bundle files.\n\t * <p>{@link ResourceBundleMessageSource}'s default is the\n\t * {@code java.util.ResourceBundle} default encoding: ISO-8859-1.\n\t * @since 4.2\n\t * @see ResourceBundleMessageSource#setDefaultEncoding\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultEncoding"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void setDefaultEncoding(@Nullable String defaultEncoding)",
    "source_code": "\tpublic void setDefaultEncoding(@Nullable String defaultEncoding) {\n\t\tthis.defaultEncoding = defaultEncoding;\n\t}"
  },
  "org.springframework.ui.context.support.ResourceBundleThemeSource#setFallbackToSystemLocale(fallbackToSystemLocale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to fall back to the system Locale if no files for a\n\t * specific Locale have been found.\n\t * <p>{@link ResourceBundleMessageSource}'s default is \"true\".\n\t * @since 4.2\n\t * @see ResourceBundleMessageSource#setFallbackToSystemLocale\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fallbackToSystemLocale"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void setFallbackToSystemLocale(boolean fallbackToSystemLocale)",
    "source_code": "\tpublic void setFallbackToSystemLocale(boolean fallbackToSystemLocale) {\n\t\tthis.fallbackToSystemLocale = fallbackToSystemLocale;\n\t}"
  },
  "org.springframework.ui.context.support.ResourceBundleThemeSource#setParentThemeSource(parent)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parent"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "public void setParentThemeSource(@Nullable ThemeSource parent)",
    "source_code": "\tpublic void setParentThemeSource(@Nullable ThemeSource parent) {\n\t\tthis.parentThemeSource = parent;\n\n\t\t// Update existing Theme objects.\n\t\t// Usually there shouldn't be any at the time of this call.\n\t\tsynchronized (this.themeCache) {\n\t\t\tfor (Theme theme : this.themeCache.values()) {\n\t\t\t\tinitParent(theme);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.ui.context.support.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Factory that configures a FreeMarker Configuration. Can be used standalone, but\n * typically you will either use FreeMarkerConfigurationFactoryBean for preparing a\n * Configuration as bean reference, or FreeMarkerConfigurer for web views.\n *\n * <p>The optional \"configLocation\" property sets the location of a FreeMarker\n * properties file, within the current application. FreeMarker properties can be\n * overridden via \"freemarkerSettings\". All of these properties will be set by\n * calling FreeMarker's {@code Configuration.setSettings()} method and are\n * subject to constraints set by FreeMarker.\n *\n * <p>The \"freemarkerVariables\" property can be used to specify a Map of\n * shared variables that will be applied to the Configuration via the\n * {@code setAllSharedVariables()} method. Like {@code setSettings()},\n * these entries are subject to FreeMarker constraints.\n *\n * <p>The simplest way to use this class is to specify a \"templateLoaderPath\";\n * FreeMarker does not need any further configuration then.\n *\n * <p>Note: Spring's FreeMarker support requires FreeMarker 2.3 or higher.\n *\n * @author Darren Davison\n * @author Juergen Hoeller\n * @since 03.03.2004\n * @see #setConfigLocation\n * @see #setFreemarkerSettings\n * @see #setFreemarkerVariables\n * @see #setTemplateLoaderPath\n * @see #createConfiguration\n * @see FreeMarkerConfigurationFactoryBean\n * @see org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer\n * @see freemarker.template.Configuration\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "signature": "public class FreeMarkerConfigurationFactory",
    "source_code": "public class FreeMarkerConfigurationFactory {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t@Nullable\n\tprivate Resource configLocation;\n\n\t@Nullable\n\tprivate Properties freemarkerSettings;\n\n\t@Nullable\n\tprivate Map<String, Object> freemarkerVariables;\n\n\t@Nullable\n\tprivate String defaultEncoding;\n\n\tprivate final List<TemplateLoader> templateLoaders = new ArrayList<>();\n\n\t@Nullable\n\tprivate List<TemplateLoader> preTemplateLoaders;\n\n\t@Nullable\n\tprivate List<TemplateLoader> postTemplateLoaders;\n\n\t@Nullable\n\tprivate String[] templateLoaderPaths;\n\n\tprivate ResourceLoader resourceLoader = new DefaultResourceLoader();\n\n\tprivate boolean preferFileSystemAccess = true;\n\n\n\t/**\n\t * Set the location of the FreeMarker config file.\n\t * Alternatively, you can specify all setting locally.\n\t * @see #setFreemarkerSettings\n\t * @see #setTemplateLoaderPath\n\t */\n\tpublic void setConfigLocation(Resource resource) {\n\t\tthis.configLocation = resource;\n\t}\n\n\t/**\n\t * Set properties that contain well-known FreeMarker keys which will be\n\t * passed to FreeMarker's {@code Configuration.setSettings} method.\n\t * @see freemarker.template.Configuration#setSettings\n\t */\n\tpublic void setFreemarkerSettings(Properties settings) {\n\t\tthis.freemarkerSettings = settings;\n\t}\n\n\t/**\n\t * Set a Map that contains well-known FreeMarker objects which will be passed\n\t * to FreeMarker's {@code Configuration.setAllSharedVariables()} method.\n\t * @see freemarker.template.Configuration#setAllSharedVariables\n\t */\n\tpublic void setFreemarkerVariables(Map<String, Object> variables) {\n\t\tthis.freemarkerVariables = variables;\n\t}\n\n\t/**\n\t * Set the default encoding for the FreeMarker configuration.\n\t * If not specified, FreeMarker will use the platform file encoding.\n\t * <p>Used for template rendering unless there is an explicit encoding specified\n\t * for the rendering process (for example, on Spring's FreeMarkerView).\n\t * @see freemarker.template.Configuration#setDefaultEncoding\n\t * @see org.springframework.web.servlet.view.freemarker.FreeMarkerView#setEncoding\n\t */\n\tpublic void setDefaultEncoding(String defaultEncoding) {\n\t\tthis.defaultEncoding = defaultEncoding;\n\t}\n\n\t/**\n\t * Set a List of {@code TemplateLoader}s that will be used to search\n\t * for templates. For example, one or more custom loaders such as database\n\t * loaders could be configured and injected here.\n\t * <p>The {@link TemplateLoader TemplateLoaders} specified here will be\n\t * registered <i>before</i> the default template loaders that this factory\n\t * registers (such as loaders for specified \"templateLoaderPaths\" or any\n\t * loaders registered in {@link #postProcessTemplateLoaders}).\n\t * @see #setTemplateLoaderPaths\n\t * @see #postProcessTemplateLoaders\n\t */\n\tpublic void setPreTemplateLoaders(TemplateLoader... preTemplateLoaders) {\n\t\tthis.preTemplateLoaders = Arrays.asList(preTemplateLoaders);\n\t}\n\n\t/**\n\t * Set a List of {@code TemplateLoader}s that will be used to search\n\t * for templates. For example, one or more custom loaders such as database\n\t * loaders can be configured.\n\t * <p>The {@link TemplateLoader TemplateLoaders} specified here will be\n\t * registered <i>after</i> the default template loaders that this factory\n\t * registers (such as loaders for specified \"templateLoaderPaths\" or any\n\t * loaders registered in {@link #postProcessTemplateLoaders}).\n\t * @see #setTemplateLoaderPaths\n\t * @see #postProcessTemplateLoaders\n\t */\n\tpublic void setPostTemplateLoaders(TemplateLoader... postTemplateLoaders) {\n\t\tthis.postTemplateLoaders = Arrays.asList(postTemplateLoaders);\n\t}\n\n\t/**\n\t * Set the Freemarker template loader path via a Spring resource location.\n\t * See the \"templateLoaderPaths\" property for details on path handling.\n\t * @see #setTemplateLoaderPaths\n\t */\n\tpublic void setTemplateLoaderPath(String templateLoaderPath) {\n\t\tthis.templateLoaderPaths = new String[] {templateLoaderPath};\n\t}\n\n\t/**\n\t * Set multiple Freemarker template loader paths via Spring resource locations.\n\t * <p>When populated via a String, standard URLs like \"file:\" and \"classpath:\"\n\t * pseudo URLs are supported, as understood by ResourceEditor. Allows for\n\t * relative paths when running in an ApplicationContext.\n\t * <p>Will define a path for the default FreeMarker template loader.\n\t * If a specified resource cannot be resolved to a {@code java.io.File},\n\t * a generic SpringTemplateLoader will be used, without modification detection.\n\t * <p>To enforce the use of SpringTemplateLoader, i.e. to not resolve a path\n\t * as file system resource in any case, turn off the \"preferFileSystemAccess\"\n\t * flag. See the latter's javadoc for details.\n\t * <p>If you wish to specify your own list of TemplateLoaders, do not set this\n\t * property and instead use {@code setTemplateLoaders(List templateLoaders)}\n\t * @see org.springframework.core.io.ResourceEditor\n\t * @see org.springframework.context.ApplicationContext#getResource\n\t * @see freemarker.template.Configuration#setDirectoryForTemplateLoading\n\t * @see SpringTemplateLoader\n\t */\n\tpublic void setTemplateLoaderPaths(String... templateLoaderPaths) {\n\t\tthis.templateLoaderPaths = templateLoaderPaths;\n\t}\n\n\t/**\n\t * Set the Spring ResourceLoader to use for loading FreeMarker template files.\n\t * The default is DefaultResourceLoader. Will get overridden by the\n\t * ApplicationContext if running in a context.\n\t * @see org.springframework.core.io.DefaultResourceLoader\n\t */\n\tpublic void setResourceLoader(ResourceLoader resourceLoader) {\n\t\tthis.resourceLoader = resourceLoader;\n\t}\n\n\t/**\n\t * Return the Spring ResourceLoader to use for loading FreeMarker template files.\n\t */\n\tprotected ResourceLoader getResourceLoader() {\n\t\treturn this.resourceLoader;\n\t}\n\n\t/**\n\t * Set whether to prefer file system access for template loading.\n\t * File system access enables hot detection of template changes.\n\t * <p>If this is enabled, FreeMarkerConfigurationFactory will try to resolve\n\t * the specified \"templateLoaderPath\" as file system resource (which will work\n\t * for expanded class path resources and ServletContext resources too).\n\t * <p>Default is \"true\". Turn this off to always load via SpringTemplateLoader\n\t * (i.e. as stream, without hot detection of template changes), which might\n\t * be necessary if some of your templates reside in an expanded classes\n\t * directory while others reside in jar files.\n\t * @see #setTemplateLoaderPath\n\t */\n\tpublic void setPreferFileSystemAccess(boolean preferFileSystemAccess) {\n\t\tthis.preferFileSystemAccess = preferFileSystemAccess;\n\t}\n\n\t/**\n\t * Return whether to prefer file system access for template loading.\n\t */\n\tprotected boolean isPreferFileSystemAccess() {\n\t\treturn this.preferFileSystemAccess;\n\t}\n\n\n\t/**\n\t * Prepare the FreeMarker Configuration and return it.\n\t * @return the FreeMarker Configuration object\n\t * @throws IOException if the config file wasn't found\n\t * @throws TemplateException on FreeMarker initialization failure\n\t */\n\tpublic Configuration createConfiguration() throws IOException, TemplateException {\n\t\tConfiguration config = newConfiguration();\n\t\tProperties props = new Properties();\n\n\t\t// Load config file if specified.\n\t\tif (this.configLocation != null) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Loading FreeMarker configuration from \" + this.configLocation);\n\t\t\t}\n\t\t\tPropertiesLoaderUtils.fillProperties(props, this.configLocation);\n\t\t}\n\n\t\t// Merge local properties if specified.\n\t\tif (this.freemarkerSettings != null) {\n\t\t\tprops.putAll(this.freemarkerSettings);\n\t\t}\n\n\t\t// FreeMarker will only accept known keys in its setSettings and\n\t\t// setAllSharedVariables methods.\n\t\tif (!props.isEmpty()) {\n\t\t\tconfig.setSettings(props);\n\t\t}\n\n\t\tif (!CollectionUtils.isEmpty(this.freemarkerVariables)) {\n\t\t\tconfig.setAllSharedVariables(new SimpleHash(this.freemarkerVariables, config.getObjectWrapper()));\n\t\t}\n\n\t\tif (this.defaultEncoding != null) {\n\t\t\tconfig.setDefaultEncoding(this.defaultEncoding);\n\t\t}\n\n\t\tList<TemplateLoader> templateLoaders = new ArrayList<>(this.templateLoaders);\n\n\t\t// Register template loaders that are supposed to kick in early.\n\t\tif (this.preTemplateLoaders != null) {\n\t\t\ttemplateLoaders.addAll(this.preTemplateLoaders);\n\t\t}\n\n\t\t// Register default template loaders.\n\t\tif (this.templateLoaderPaths != null) {\n\t\t\tfor (String path : this.templateLoaderPaths) {\n\t\t\t\ttemplateLoaders.add(getTemplateLoaderForPath(path));\n\t\t\t}\n\t\t}\n\t\tpostProcessTemplateLoaders(templateLoaders);\n\n\t\t// Register template loaders that are supposed to kick in late.\n\t\tif (this.postTemplateLoaders != null) {\n\t\t\ttemplateLoaders.addAll(this.postTemplateLoaders);\n\t\t}\n\n\t\tTemplateLoader loader = getAggregateTemplateLoader(templateLoaders);\n\t\tif (loader != null) {\n\t\t\tconfig.setTemplateLoader(loader);\n\t\t}\n\n\t\tpostProcessConfiguration(config);\n\t\treturn config;\n\t}\n\n\t/**\n\t * Return a new Configuration object. Subclasses can override this for custom\n\t * initialization (e.g. specifying a FreeMarker compatibility level which is a\n\t * new feature in FreeMarker 2.3.21), or for using a mock object for testing.\n\t * <p>Called by {@code createConfiguration()}.\n\t * @return the Configuration object\n\t * @throws IOException if a config file wasn't found\n\t * @throws TemplateException on FreeMarker initialization failure\n\t * @see #createConfiguration()\n\t */\n\tprotected Configuration newConfiguration() throws IOException, TemplateException {\n\t\treturn new Configuration(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);\n\t}\n\n\t/**\n\t * Determine a FreeMarker TemplateLoader for the given path.\n\t * <p>Default implementation creates either a FileTemplateLoader or\n\t * a SpringTemplateLoader.\n\t * @param templateLoaderPath the path to load templates from\n\t * @return an appropriate TemplateLoader\n\t * @see freemarker.cache.FileTemplateLoader\n\t * @see SpringTemplateLoader\n\t */\n\tprotected TemplateLoader getTemplateLoaderForPath(String templateLoaderPath) {\n\t\tif (isPreferFileSystemAccess()) {\n\t\t\t// Try to load via the file system, fall back to SpringTemplateLoader\n\t\t\t// (for hot detection of template changes, if possible).\n\t\t\ttry {\n\t\t\t\tResource path = getResourceLoader().getResource(templateLoaderPath);\n\t\t\t\tFile file = path.getFile();  // will fail if not resolvable in the file system\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\"Template loader path [\" + path + \"] resolved to file path [\" + file.getAbsolutePath() + \"]\");\n\t\t\t\t}\n\t\t\t\treturn new FileTemplateLoader(file);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Cannot resolve template loader path [\" + templateLoaderPath +\n\t\t\t\t\t\t\t\"] to [java.io.File]: using SpringTemplateLoader as fallback\", ex);\n\t\t\t\t}\n\t\t\t\treturn new SpringTemplateLoader(getResourceLoader(), templateLoaderPath);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Always load via SpringTemplateLoader (without hot detection of template changes).\n\t\t\tlogger.debug(\"File system access not preferred: using SpringTemplateLoader\");\n\t\t\treturn new SpringTemplateLoader(getResourceLoader(), templateLoaderPath);\n\t\t}\n\t}\n\n\t/**\n\t * To be overridden by subclasses that want to register custom\n\t * TemplateLoader instances after this factory created its default\n\t * template loaders.\n\t * <p>Called by {@code createConfiguration()}. Note that specified\n\t * \"postTemplateLoaders\" will be registered <i>after</i> any loaders\n\t * registered by this callback; as a consequence, they are <i>not</i>\n\t * included in the given List.\n\t * @param templateLoaders the current List of TemplateLoader instances,\n\t * to be modified by a subclass\n\t * @see #createConfiguration()\n\t * @see #setPostTemplateLoaders\n\t */\n\tprotected void postProcessTemplateLoaders(List<TemplateLoader> templateLoaders) {\n\t}\n\n\t/**\n\t * Return a TemplateLoader based on the given TemplateLoader list.\n\t * If more than one TemplateLoader has been registered, a FreeMarker\n\t * MultiTemplateLoader needs to be created.\n\t * @param templateLoaders the final List of TemplateLoader instances\n\t * @return the aggregate TemplateLoader\n\t */\n\t@Nullable\n\tprotected TemplateLoader getAggregateTemplateLoader(List<TemplateLoader> templateLoaders) {\n\t\treturn switch (templateLoaders.size()) {\n\t\t\tcase 0 -> {\n\t\t\t\tlogger.debug(\"No FreeMarker TemplateLoaders specified\");\n\t\t\t\tyield null;\n\t\t\t}\n\t\t\tcase 1 -> templateLoaders.get(0);\n\t\t\tdefault -> {\n\t\t\t\tTemplateLoader[] loaders = templateLoaders.toArray(new TemplateLoader[0]);\n\t\t\t\tyield new MultiTemplateLoader(loaders);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * To be overridden by subclasses that want to perform custom\n\t * post-processing of the Configuration object after this factory\n\t * performed its default initialization.\n\t * <p>Called by {@code createConfiguration()}.\n\t * @param config the current Configuration object\n\t * @throws IOException if a config file wasn't found\n\t * @throws TemplateException on FreeMarker initialization failure\n\t * @see #createConfiguration()\n\t */\n\tprotected void postProcessConfiguration(Configuration config) throws IOException, TemplateException {\n\t}\n\n}"
  },
  "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory#createConfiguration()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the FreeMarker Configuration and return it.\n\t * @return the FreeMarker Configuration object\n\t * @throws IOException if the config file wasn't found\n\t * @throws TemplateException on FreeMarker initialization failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "Configuration",
    "signature": "public Configuration createConfiguration()",
    "source_code": "\tpublic Configuration createConfiguration() throws IOException, TemplateException {\n\t\tConfiguration config = newConfiguration();\n\t\tProperties props = new Properties();\n\n\t\t// Load config file if specified.\n\t\tif (this.configLocation != null) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Loading FreeMarker configuration from \" + this.configLocation);\n\t\t\t}\n\t\t\tPropertiesLoaderUtils.fillProperties(props, this.configLocation);\n\t\t}\n\n\t\t// Merge local properties if specified.\n\t\tif (this.freemarkerSettings != null) {\n\t\t\tprops.putAll(this.freemarkerSettings);\n\t\t}\n\n\t\t// FreeMarker will only accept known keys in its setSettings and\n\t\t// setAllSharedVariables methods.\n\t\tif (!props.isEmpty()) {\n\t\t\tconfig.setSettings(props);\n\t\t}\n\n\t\tif (!CollectionUtils.isEmpty(this.freemarkerVariables)) {\n\t\t\tconfig.setAllSharedVariables(new SimpleHash(this.freemarkerVariables, config.getObjectWrapper()));\n\t\t}\n\n\t\tif (this.defaultEncoding != null) {\n\t\t\tconfig.setDefaultEncoding(this.defaultEncoding);\n\t\t}\n\n\t\tList<TemplateLoader> templateLoaders = new ArrayList<>(this.templateLoaders);\n\n\t\t// Register template loaders that are supposed to kick in early.\n\t\tif (this.preTemplateLoaders != null) {\n\t\t\ttemplateLoaders.addAll(this.preTemplateLoaders);\n\t\t}\n\n\t\t// Register default template loaders.\n\t\tif (this.templateLoaderPaths != null) {\n\t\t\tfor (String path : this.templateLoaderPaths) {\n\t\t\t\ttemplateLoaders.add(getTemplateLoaderForPath(path));\n\t\t\t}\n\t\t}\n\t\tpostProcessTemplateLoaders(templateLoaders);\n\n\t\t// Register template loaders that are supposed to kick in late.\n\t\tif (this.postTemplateLoaders != null) {\n\t\t\ttemplateLoaders.addAll(this.postTemplateLoaders);\n\t\t}\n\n\t\tTemplateLoader loader = getAggregateTemplateLoader(templateLoaders);\n\t\tif (loader != null) {\n\t\t\tconfig.setTemplateLoader(loader);\n\t\t}\n\n\t\tpostProcessConfiguration(config);\n\t\treturn config;\n\t}"
  },
  "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory#getAggregateTemplateLoader(templateLoaders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a TemplateLoader based on the given TemplateLoader list.\n\t * If more than one TemplateLoader has been registered, a FreeMarker\n\t * MultiTemplateLoader needs to be created.\n\t * @param templateLoaders the final List of TemplateLoader instances\n\t * @return the aggregate TemplateLoader\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "templateLoaders"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "TemplateLoader",
    "signature": "protected TemplateLoader getAggregateTemplateLoader(List<TemplateLoader> templateLoaders)",
    "source_code": "\tprotected TemplateLoader getAggregateTemplateLoader(List<TemplateLoader> templateLoaders) {\n\t\treturn switch (templateLoaders.size()) {\n\t\t\tcase 0 -> {\n\t\t\t\tlogger.debug(\"No FreeMarker TemplateLoaders specified\");\n\t\t\t\tyield null;\n\t\t\t}\n\t\t\tcase 1 -> templateLoaders.get(0);\n\t\t\tdefault -> {\n\t\t\t\tTemplateLoader[] loaders = templateLoaders.toArray(new TemplateLoader[0]);\n\t\t\t\tyield new MultiTemplateLoader(loaders);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory#getResourceLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Spring ResourceLoader to use for loading FreeMarker template files.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "ResourceLoader",
    "signature": "protected ResourceLoader getResourceLoader()",
    "source_code": "\tprotected ResourceLoader getResourceLoader() {\n\t\treturn this.resourceLoader;\n\t}"
  },
  "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory#getTemplateLoaderForPath(templateLoaderPath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine a FreeMarker TemplateLoader for the given path.\n\t * <p>Default implementation creates either a FileTemplateLoader or\n\t * a SpringTemplateLoader.\n\t * @param templateLoaderPath the path to load templates from\n\t * @return an appropriate TemplateLoader\n\t * @see freemarker.cache.FileTemplateLoader\n\t * @see SpringTemplateLoader\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "templateLoaderPath"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "TemplateLoader",
    "signature": "protected TemplateLoader getTemplateLoaderForPath(String templateLoaderPath)",
    "source_code": "\tprotected TemplateLoader getTemplateLoaderForPath(String templateLoaderPath) {\n\t\tif (isPreferFileSystemAccess()) {\n\t\t\t// Try to load via the file system, fall back to SpringTemplateLoader\n\t\t\t// (for hot detection of template changes, if possible).\n\t\t\ttry {\n\t\t\t\tResource path = getResourceLoader().getResource(templateLoaderPath);\n\t\t\t\tFile file = path.getFile();  // will fail if not resolvable in the file system\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\"Template loader path [\" + path + \"] resolved to file path [\" + file.getAbsolutePath() + \"]\");\n\t\t\t\t}\n\t\t\t\treturn new FileTemplateLoader(file);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Cannot resolve template loader path [\" + templateLoaderPath +\n\t\t\t\t\t\t\t\"] to [java.io.File]: using SpringTemplateLoader as fallback\", ex);\n\t\t\t\t}\n\t\t\t\treturn new SpringTemplateLoader(getResourceLoader(), templateLoaderPath);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Always load via SpringTemplateLoader (without hot detection of template changes).\n\t\t\tlogger.debug(\"File system access not preferred: using SpringTemplateLoader\");\n\t\t\treturn new SpringTemplateLoader(getResourceLoader(), templateLoaderPath);\n\t\t}\n\t}"
  },
  "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory#isPreferFileSystemAccess()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to prefer file system access for template loading.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "boolean",
    "signature": "protected boolean isPreferFileSystemAccess()",
    "source_code": "\tprotected boolean isPreferFileSystemAccess() {\n\t\treturn this.preferFileSystemAccess;\n\t}"
  },
  "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory#newConfiguration()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new Configuration object. Subclasses can override this for custom\n\t * initialization (e.g. specifying a FreeMarker compatibility level which is a\n\t * new feature in FreeMarker 2.3.21), or for using a mock object for testing.\n\t * <p>Called by {@code createConfiguration()}.\n\t * @return the Configuration object\n\t * @throws IOException if a config file wasn't found\n\t * @throws TemplateException on FreeMarker initialization failure\n\t * @see #createConfiguration()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "Configuration",
    "signature": "protected Configuration newConfiguration()",
    "source_code": "\tprotected Configuration newConfiguration() throws IOException, TemplateException {\n\t\treturn new Configuration(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);\n\t}"
  },
  "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory#postProcessConfiguration(config)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * To be overridden by subclasses that want to perform custom\n\t * post-processing of the Configuration object after this factory\n\t * performed its default initialization.\n\t * <p>Called by {@code createConfiguration()}.\n\t * @param config the current Configuration object\n\t * @throws IOException if a config file wasn't found\n\t * @throws TemplateException on FreeMarker initialization failure\n\t * @see #createConfiguration()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "config"
    ],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "void",
    "signature": "protected void postProcessConfiguration(Configuration config)",
    "source_code": "\tprotected void postProcessConfiguration(Configuration config) throws IOException, TemplateException {\n\t}"
  },
  "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory#postProcessTemplateLoaders(templateLoaders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * To be overridden by subclasses that want to register custom\n\t * TemplateLoader instances after this factory created its default\n\t * template loaders.\n\t * <p>Called by {@code createConfiguration()}. Note that specified\n\t * \"postTemplateLoaders\" will be registered <i>after</i> any loaders\n\t * registered by this callback; as a consequence, they are <i>not</i>\n\t * included in the given List.\n\t * @param templateLoaders the current List of TemplateLoader instances,\n\t * to be modified by a subclass\n\t * @see #createConfiguration()\n\t * @see #setPostTemplateLoaders\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "templateLoaders"
    ],
    "position": {
      "column": 1,
      "line": 380
    },
    "return": "void",
    "signature": "protected void postProcessTemplateLoaders(List<TemplateLoader> templateLoaders)",
    "source_code": "\tprotected void postProcessTemplateLoaders(List<TemplateLoader> templateLoaders) {\n\t}"
  },
  "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory#setConfigLocation(resource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the location of the FreeMarker config file.\n\t * Alternatively, you can specify all setting locally.\n\t * @see #setFreemarkerSettings\n\t * @see #setTemplateLoaderPath\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "void",
    "signature": "public void setConfigLocation(Resource resource)",
    "source_code": "\tpublic void setConfigLocation(Resource resource) {\n\t\tthis.configLocation = resource;\n\t}"
  },
  "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory#setDefaultEncoding(defaultEncoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the default encoding for the FreeMarker configuration.\n\t * If not specified, FreeMarker will use the platform file encoding.\n\t * <p>Used for template rendering unless there is an explicit encoding specified\n\t * for the rendering process (for example, on Spring's FreeMarkerView).\n\t * @see freemarker.template.Configuration#setDefaultEncoding\n\t * @see org.springframework.web.servlet.view.freemarker.FreeMarkerView#setEncoding\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultEncoding"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "void",
    "signature": "public void setDefaultEncoding(String defaultEncoding)",
    "source_code": "\tpublic void setDefaultEncoding(String defaultEncoding) {\n\t\tthis.defaultEncoding = defaultEncoding;\n\t}"
  },
  "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory#setFreemarkerSettings(settings)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set properties that contain well-known FreeMarker keys which will be\n\t * passed to FreeMarker's {@code Configuration.setSettings} method.\n\t * @see freemarker.template.Configuration#setSettings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "settings"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "public void setFreemarkerSettings(Properties settings)",
    "source_code": "\tpublic void setFreemarkerSettings(Properties settings) {\n\t\tthis.freemarkerSettings = settings;\n\t}"
  },
  "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory#setFreemarkerVariables(Map<String,variables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Map that contains well-known FreeMarker objects which will be passed\n\t * to FreeMarker's {@code Configuration.setAllSharedVariables()} method.\n\t * @see freemarker.template.Configuration#setAllSharedVariables\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "variables"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void setFreemarkerVariables(Map<String, Object> variables)",
    "source_code": "\tpublic void setFreemarkerVariables(Map<String, Object> variables) {\n\t\tthis.freemarkerVariables = variables;\n\t}"
  },
  "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory#setPostTemplateLoaders(postTemplateLoaders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a List of {@code TemplateLoader}s that will be used to search\n\t * for templates. For example, one or more custom loaders such as database\n\t * loaders can be configured.\n\t * <p>The {@link TemplateLoader TemplateLoaders} specified here will be\n\t * registered <i>after</i> the default template loaders that this factory\n\t * registers (such as loaders for specified \"templateLoaderPaths\" or any\n\t * loaders registered in {@link #postProcessTemplateLoaders}).\n\t * @see #setTemplateLoaderPaths\n\t * @see #postProcessTemplateLoaders\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "postTemplateLoaders"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "void",
    "signature": "public void setPostTemplateLoaders(TemplateLoader... postTemplateLoaders)",
    "source_code": "\tpublic void setPostTemplateLoaders(TemplateLoader... postTemplateLoaders) {\n\t\tthis.postTemplateLoaders = Arrays.asList(postTemplateLoaders);\n\t}"
  },
  "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory#setPreTemplateLoaders(preTemplateLoaders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a List of {@code TemplateLoader}s that will be used to search\n\t * for templates. For example, one or more custom loaders such as database\n\t * loaders could be configured and injected here.\n\t * <p>The {@link TemplateLoader TemplateLoaders} specified here will be\n\t * registered <i>before</i> the default template loaders that this factory\n\t * registers (such as loaders for specified \"templateLoaderPaths\" or any\n\t * loaders registered in {@link #postProcessTemplateLoaders}).\n\t * @see #setTemplateLoaderPaths\n\t * @see #postProcessTemplateLoaders\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "preTemplateLoaders"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void setPreTemplateLoaders(TemplateLoader... preTemplateLoaders)",
    "source_code": "\tpublic void setPreTemplateLoaders(TemplateLoader... preTemplateLoaders) {\n\t\tthis.preTemplateLoaders = Arrays.asList(preTemplateLoaders);\n\t}"
  },
  "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory#setPreferFileSystemAccess(preferFileSystemAccess)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to prefer file system access for template loading.\n\t * File system access enables hot detection of template changes.\n\t * <p>If this is enabled, FreeMarkerConfigurationFactory will try to resolve\n\t * the specified \"templateLoaderPath\" as file system resource (which will work\n\t * for expanded class path resources and ServletContext resources too).\n\t * <p>Default is \"true\". Turn this off to always load via SpringTemplateLoader\n\t * (i.e. as stream, without hot detection of template changes), which might\n\t * be necessary if some of your templates reside in an expanded classes\n\t * directory while others reside in jar files.\n\t * @see #setTemplateLoaderPath\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "preferFileSystemAccess"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "void",
    "signature": "public void setPreferFileSystemAccess(boolean preferFileSystemAccess)",
    "source_code": "\tpublic void setPreferFileSystemAccess(boolean preferFileSystemAccess) {\n\t\tthis.preferFileSystemAccess = preferFileSystemAccess;\n\t}"
  },
  "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory#setResourceLoader(resourceLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Spring ResourceLoader to use for loading FreeMarker template files.\n\t * The default is DefaultResourceLoader. Will get overridden by the\n\t * ApplicationContext if running in a context.\n\t * @see org.springframework.core.io.DefaultResourceLoader\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLoader"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "public void setResourceLoader(ResourceLoader resourceLoader)",
    "source_code": "\tpublic void setResourceLoader(ResourceLoader resourceLoader) {\n\t\tthis.resourceLoader = resourceLoader;\n\t}"
  },
  "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory#setTemplateLoaderPath(templateLoaderPath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Freemarker template loader path via a Spring resource location.\n\t * See the \"templateLoaderPaths\" property for details on path handling.\n\t * @see #setTemplateLoaderPaths\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "templateLoaderPath"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void setTemplateLoaderPath(String templateLoaderPath)",
    "source_code": "\tpublic void setTemplateLoaderPath(String templateLoaderPath) {\n\t\tthis.templateLoaderPaths = new String[] {templateLoaderPath};\n\t}"
  },
  "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory#setTemplateLoaderPaths(templateLoaderPaths)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set multiple Freemarker template loader paths via Spring resource locations.\n\t * <p>When populated via a String, standard URLs like \"file:\" and \"classpath:\"\n\t * pseudo URLs are supported, as understood by ResourceEditor. Allows for\n\t * relative paths when running in an ApplicationContext.\n\t * <p>Will define a path for the default FreeMarker template loader.\n\t * If a specified resource cannot be resolved to a {@code java.io.File},\n\t * a generic SpringTemplateLoader will be used, without modification detection.\n\t * <p>To enforce the use of SpringTemplateLoader, i.e. to not resolve a path\n\t * as file system resource in any case, turn off the \"preferFileSystemAccess\"\n\t * flag. See the latter's javadoc for details.\n\t * <p>If you wish to specify your own list of TemplateLoaders, do not set this\n\t * property and instead use {@code setTemplateLoaders(List templateLoaders)}\n\t * @see org.springframework.core.io.ResourceEditor\n\t * @see org.springframework.context.ApplicationContext#getResource\n\t * @see freemarker.template.Configuration#setDirectoryForTemplateLoading\n\t * @see SpringTemplateLoader\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "templateLoaderPaths"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "void",
    "signature": "public void setTemplateLoaderPaths(String... templateLoaderPaths)",
    "source_code": "\tpublic void setTemplateLoaderPaths(String... templateLoaderPaths) {\n\t\tthis.templateLoaderPaths = templateLoaderPaths;\n\t}"
  },
  "org.springframework.ui.freemarker.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.util.ALL": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Public constant mime type that includes all media ranges (i.e. \"&#42;/&#42;\").\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "signature": "public MimeType ALL",
    "source_code": "\tpublic static final MimeType ALL;",
    "type": "MimeType"
  },
  "org.springframework.util.ALL_VALUE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A String equivalent of {@link MimeTypeUtils#ALL}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "signature": "public String ALL_VALUE",
    "source_code": "\tpublic static final String ALL_VALUE = \"*/*\";",
    "type": "String"
  },
  "org.springframework.util.APPLICATION_GRAPHQL": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Public constant mime type for {@code application/graphql+json}.\n\t * @since 5.3.19\n\t * @see <a href=\"https://github.com/graphql/graphql-over-http\">GraphQL over HTTP spec</a>\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "signature": "public MimeType APPLICATION_GRAPHQL",
    "source_code": "\tpublic static final MimeType APPLICATION_GRAPHQL;",
    "type": "MimeType"
  },
  "org.springframework.util.APPLICATION_GRAPHQL_VALUE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A String equivalent of {@link MimeTypeUtils#APPLICATION_GRAPHQL}.\n\t * @since 5.3.19\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "signature": "public String APPLICATION_GRAPHQL_VALUE",
    "source_code": "\tpublic static final String APPLICATION_GRAPHQL_VALUE = \"application/graphql+json\";",
    "type": "String"
  },
  "org.springframework.util.APPLICATION_JSON": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Public constant mime type for {@code application/json}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "signature": "public MimeType APPLICATION_JSON",
    "source_code": "\tpublic static final MimeType APPLICATION_JSON;",
    "type": "MimeType"
  },
  "org.springframework.util.APPLICATION_JSON_VALUE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A String equivalent of {@link MimeTypeUtils#APPLICATION_JSON}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "signature": "public String APPLICATION_JSON_VALUE",
    "source_code": "\tpublic static final String APPLICATION_JSON_VALUE = \"application/json\";",
    "type": "String"
  },
  "org.springframework.util.APPLICATION_OCTET_STREAM": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Public constant mime type for {@code application/octet-stream}.\n\t *  */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "signature": "public MimeType APPLICATION_OCTET_STREAM",
    "source_code": "\tpublic static final MimeType APPLICATION_OCTET_STREAM;",
    "type": "MimeType"
  },
  "org.springframework.util.APPLICATION_OCTET_STREAM_VALUE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A String equivalent of {@link MimeTypeUtils#APPLICATION_OCTET_STREAM}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "signature": "public String APPLICATION_OCTET_STREAM_VALUE",
    "source_code": "\tpublic static final String APPLICATION_OCTET_STREAM_VALUE = \"application/octet-stream\";",
    "type": "String"
  },
  "org.springframework.util.APPLICATION_XML": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Public constant mime type for {@code application/xml}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "signature": "public MimeType APPLICATION_XML",
    "source_code": "\tpublic static final MimeType APPLICATION_XML;",
    "type": "MimeType"
  },
  "org.springframework.util.APPLICATION_XML_VALUE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A String equivalent of {@link MimeTypeUtils#APPLICATION_XML}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "signature": "public String APPLICATION_XML_VALUE",
    "source_code": "\tpublic static final String APPLICATION_XML_VALUE = \"application/xml\";",
    "type": "String"
  },
  "org.springframework.util.IMAGE_GIF": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Public constant mime type for {@code image/gif}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "signature": "public MimeType IMAGE_GIF",
    "source_code": "\tpublic static final MimeType IMAGE_GIF;",
    "type": "MimeType"
  },
  "org.springframework.util.IMAGE_GIF_VALUE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A String equivalent of {@link MimeTypeUtils#IMAGE_GIF}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "signature": "public String IMAGE_GIF_VALUE",
    "source_code": "\tpublic static final String IMAGE_GIF_VALUE = \"image/gif\";",
    "type": "String"
  },
  "org.springframework.util.IMAGE_JPEG": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Public constant mime type for {@code image/jpeg}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "signature": "public MimeType IMAGE_JPEG",
    "source_code": "\tpublic static final MimeType IMAGE_JPEG;",
    "type": "MimeType"
  },
  "org.springframework.util.IMAGE_JPEG_VALUE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A String equivalent of {@link MimeTypeUtils#IMAGE_JPEG}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "signature": "public String IMAGE_JPEG_VALUE",
    "source_code": "\tpublic static final String IMAGE_JPEG_VALUE = \"image/jpeg\";",
    "type": "String"
  },
  "org.springframework.util.IMAGE_PNG": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Public constant mime type for {@code image/png}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "signature": "public MimeType IMAGE_PNG",
    "source_code": "\tpublic static final MimeType IMAGE_PNG;",
    "type": "MimeType"
  },
  "org.springframework.util.IMAGE_PNG_VALUE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A String equivalent of {@link MimeTypeUtils#IMAGE_PNG}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "signature": "public String IMAGE_PNG_VALUE",
    "source_code": "\tpublic static final String IMAGE_PNG_VALUE = \"image/png\";",
    "type": "String"
  },
  "org.springframework.util.MimeTypeUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Miscellaneous {@link MimeType} utility methods.\n *\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @author Dimitrios Liapis\n * @author Brian Clozel\n * @author Sam Brannen\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class MimeTypeUtils",
    "source_code": "public abstract class MimeTypeUtils {\n\n\tprivate static final byte[] BOUNDARY_CHARS =\n\t\t\tnew byte[] {'-', '_', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\n\t\t\t\t\t'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A',\n\t\t\t\t\t'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',\n\t\t\t\t\t'V', 'W', 'X', 'Y', 'Z'};\n\n\t/**\n\t * Comparator formally used by {@link #sortBySpecificity(List)}.\n\t * @deprecated As of 6.0, with no direct replacement\n\t */\n\t@SuppressWarnings(\"removal\")\n\t@Deprecated(since = \"6.0\", forRemoval = true)\n\tpublic static final Comparator<MimeType> SPECIFICITY_COMPARATOR = new MimeType.SpecificityComparator<>();\n\n\t/**\n\t * Public constant mime type that includes all media ranges (i.e. \"&#42;/&#42;\").\n\t */\n\tpublic static final MimeType ALL;\n\n\t/**\n\t * A String equivalent of {@link MimeTypeUtils#ALL}.\n\t */\n\tpublic static final String ALL_VALUE = \"*/*\";\n\n\t/**\n\t * Public constant mime type for {@code application/graphql+json}.\n\t * @since 5.3.19\n\t * @see <a href=\"https://github.com/graphql/graphql-over-http\">GraphQL over HTTP spec</a>\n\t */\n\tpublic static final MimeType APPLICATION_GRAPHQL;\n\n\t/**\n\t * A String equivalent of {@link MimeTypeUtils#APPLICATION_GRAPHQL}.\n\t * @since 5.3.19\n\t */\n\tpublic static final String APPLICATION_GRAPHQL_VALUE = \"application/graphql+json\";\n\n\t/**\n\t * Public constant mime type for {@code application/json}.\n\t */\n\tpublic static final MimeType APPLICATION_JSON;\n\n\t/**\n\t * A String equivalent of {@link MimeTypeUtils#APPLICATION_JSON}.\n\t */\n\tpublic static final String APPLICATION_JSON_VALUE = \"application/json\";\n\n\t/**\n\t * Public constant mime type for {@code application/octet-stream}.\n\t *  */\n\tpublic static final MimeType APPLICATION_OCTET_STREAM;\n\n\t/**\n\t * A String equivalent of {@link MimeTypeUtils#APPLICATION_OCTET_STREAM}.\n\t */\n\tpublic static final String APPLICATION_OCTET_STREAM_VALUE = \"application/octet-stream\";\n\n\t/**\n\t * Public constant mime type for {@code application/xml}.\n\t */\n\tpublic static final MimeType APPLICATION_XML;\n\n\t/**\n\t * A String equivalent of {@link MimeTypeUtils#APPLICATION_XML}.\n\t */\n\tpublic static final String APPLICATION_XML_VALUE = \"application/xml\";\n\n\t/**\n\t * Public constant mime type for {@code image/gif}.\n\t */\n\tpublic static final MimeType IMAGE_GIF;\n\n\t/**\n\t * A String equivalent of {@link MimeTypeUtils#IMAGE_GIF}.\n\t */\n\tpublic static final String IMAGE_GIF_VALUE = \"image/gif\";\n\n\t/**\n\t * Public constant mime type for {@code image/jpeg}.\n\t */\n\tpublic static final MimeType IMAGE_JPEG;\n\n\t/**\n\t * A String equivalent of {@link MimeTypeUtils#IMAGE_JPEG}.\n\t */\n\tpublic static final String IMAGE_JPEG_VALUE = \"image/jpeg\";\n\n\t/**\n\t * Public constant mime type for {@code image/png}.\n\t */\n\tpublic static final MimeType IMAGE_PNG;\n\n\t/**\n\t * A String equivalent of {@link MimeTypeUtils#IMAGE_PNG}.\n\t */\n\tpublic static final String IMAGE_PNG_VALUE = \"image/png\";\n\n\t/**\n\t * Public constant mime type for {@code text/html}.\n\t *  */\n\tpublic static final MimeType TEXT_HTML;\n\n\t/**\n\t * A String equivalent of {@link MimeTypeUtils#TEXT_HTML}.\n\t */\n\tpublic static final String TEXT_HTML_VALUE = \"text/html\";\n\n\t/**\n\t * Public constant mime type for {@code text/plain}.\n\t *  */\n\tpublic static final MimeType TEXT_PLAIN;\n\n\t/**\n\t * A String equivalent of {@link MimeTypeUtils#TEXT_PLAIN}.\n\t */\n\tpublic static final String TEXT_PLAIN_VALUE = \"text/plain\";\n\n\t/**\n\t * Public constant mime type for {@code text/xml}.\n\t *  */\n\tpublic static final MimeType TEXT_XML;\n\n\t/**\n\t * A String equivalent of {@link MimeTypeUtils#TEXT_XML}.\n\t */\n\tpublic static final String TEXT_XML_VALUE = \"text/xml\";\n\n\n\tprivate static final ConcurrentLruCache<String, MimeType> cachedMimeTypes =\n\t\t\tnew ConcurrentLruCache<>(64, MimeTypeUtils::parseMimeTypeInternal);\n\n\t@Nullable\n\tprivate static volatile Random random;\n\n\tstatic {\n\t\t// Not using \"parseMimeType\" to avoid static init cost\n\t\tALL = new MimeType(\"*\", \"*\");\n\t\tAPPLICATION_GRAPHQL = new MimeType(\"application\", \"graphql+json\");\n\t\tAPPLICATION_JSON = new MimeType(\"application\", \"json\");\n\t\tAPPLICATION_OCTET_STREAM = new MimeType(\"application\", \"octet-stream\");\n\t\tAPPLICATION_XML = new MimeType(\"application\", \"xml\");\n\t\tIMAGE_GIF = new MimeType(\"image\", \"gif\");\n\t\tIMAGE_JPEG = new MimeType(\"image\", \"jpeg\");\n\t\tIMAGE_PNG = new MimeType(\"image\", \"png\");\n\t\tTEXT_HTML = new MimeType(\"text\", \"html\");\n\t\tTEXT_PLAIN = new MimeType(\"text\", \"plain\");\n\t\tTEXT_XML = new MimeType(\"text\", \"xml\");\n\t}\n\n\n\t/**\n\t * Parse the given String into a single {@code MimeType}.\n\t * Recently parsed {@code MimeType} are cached for further retrieval.\n\t * @param mimeType the string to parse\n\t * @return the mime type\n\t * @throws InvalidMimeTypeException if the string cannot be parsed\n\t */\n\tpublic static MimeType parseMimeType(String mimeType) {\n\t\tif (!StringUtils.hasLength(mimeType)) {\n\t\t\tthrow new InvalidMimeTypeException(mimeType, \"'mimeType' must not be empty\");\n\t\t}\n\t\t// do not cache multipart mime types with random boundaries\n\t\tif (mimeType.startsWith(\"multipart\")) {\n\t\t\treturn parseMimeTypeInternal(mimeType);\n\t\t}\n\t\treturn cachedMimeTypes.get(mimeType);\n\t}\n\n\tprivate static MimeType parseMimeTypeInternal(String mimeType) {\n\t\tint index = mimeType.indexOf(';');\n\t\tString fullType = (index >= 0 ? mimeType.substring(0, index) : mimeType).trim();\n\t\tif (fullType.isEmpty()) {\n\t\t\tthrow new InvalidMimeTypeException(mimeType, \"'mimeType' must not be empty\");\n\t\t}\n\n\t\t// java.net.HttpURLConnection returns a *; q=.2 Accept header\n\t\tif (MimeType.WILDCARD_TYPE.equals(fullType)) {\n\t\t\tfullType = \"*/*\";\n\t\t}\n\t\tint subIndex = fullType.indexOf('/');\n\t\tif (subIndex == -1) {\n\t\t\tthrow new InvalidMimeTypeException(mimeType, \"does not contain '/'\");\n\t\t}\n\t\tif (subIndex == fullType.length() - 1) {\n\t\t\tthrow new InvalidMimeTypeException(mimeType, \"does not contain subtype after '/'\");\n\t\t}\n\t\tString type = fullType.substring(0, subIndex);\n\t\tString subtype = fullType.substring(subIndex + 1);\n\t\tif (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {\n\t\t\tthrow new InvalidMimeTypeException(mimeType, \"wildcard type is legal only in '*/*' (all mime types)\");\n\t\t}\n\n\t\tMap<String, String> parameters = null;\n\t\tdo {\n\t\t\tint nextIndex = index + 1;\n\t\t\tboolean quoted = false;\n\t\t\twhile (nextIndex < mimeType.length()) {\n\t\t\t\tchar ch = mimeType.charAt(nextIndex);\n\t\t\t\tif (ch == ';') {\n\t\t\t\t\tif (!quoted) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (ch == '\"') {\n\t\t\t\t\tquoted = !quoted;\n\t\t\t\t}\n\t\t\t\tnextIndex++;\n\t\t\t}\n\t\t\tString parameter = mimeType.substring(index + 1, nextIndex).trim();\n\t\t\tif (parameter.length() > 0) {\n\t\t\t\tif (parameters == null) {\n\t\t\t\t\tparameters = new LinkedHashMap<>(4);\n\t\t\t\t}\n\t\t\t\tint eqIndex = parameter.indexOf('=');\n\t\t\t\tif (eqIndex >= 0) {\n\t\t\t\t\tString attribute = parameter.substring(0, eqIndex).trim();\n\t\t\t\t\tString value = parameter.substring(eqIndex + 1).trim();\n\t\t\t\t\tparameters.put(attribute, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tindex = nextIndex;\n\t\t}\n\t\twhile (index < mimeType.length());\n\n\t\ttry {\n\t\t\treturn new MimeType(type, subtype, parameters);\n\t\t}\n\t\tcatch (UnsupportedCharsetException ex) {\n\t\t\tthrow new InvalidMimeTypeException(mimeType, \"unsupported charset '\" + ex.getCharsetName() + \"'\");\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tthrow new InvalidMimeTypeException(mimeType, ex.getMessage());\n\t\t}\n\t}\n\n\t/**\n\t * Parse the comma-separated string into a mutable list of {@code MimeType} objects.\n\t * @param mimeTypes the string to parse\n\t * @return the list of mime types\n\t * @throws InvalidMimeTypeException if the string cannot be parsed\n\t */\n\tpublic static List<MimeType> parseMimeTypes(String mimeTypes) {\n\t\tif (!StringUtils.hasLength(mimeTypes)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\treturn tokenize(mimeTypes).stream()\n\t\t\t\t.filter(StringUtils::hasText)\n\t\t\t\t.map(MimeTypeUtils::parseMimeType)\n\t\t\t\t.collect(Collectors.toList());\n\t}\n\n\t/**\n\t * Tokenize the given comma-separated string of {@code MimeType} objects\n\t * into a {@code List<String>}. Unlike simple tokenization by \",\", this\n\t * method takes into account quoted parameters.\n\t * @param mimeTypes the string to tokenize\n\t * @return the list of tokens\n\t * @since 5.1.3\n\t */\n\tpublic static List<String> tokenize(String mimeTypes) {\n\t\tif (!StringUtils.hasLength(mimeTypes)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tList<String> tokens = new ArrayList<>();\n\t\tboolean inQuotes = false;\n\t\tint startIndex = 0;\n\t\tint i = 0;\n\t\twhile (i < mimeTypes.length()) {\n\t\t\tswitch (mimeTypes.charAt(i)) {\n\t\t\t\tcase '\"' -> inQuotes = !inQuotes;\n\t\t\t\tcase ',' -> {\n\t\t\t\t\tif (!inQuotes) {\n\t\t\t\t\t\ttokens.add(mimeTypes.substring(startIndex, i));\n\t\t\t\t\t\tstartIndex = i + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase '\\\\' -> i++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\ttokens.add(mimeTypes.substring(startIndex));\n\t\treturn tokens;\n\t}\n\n\t/**\n\t * Return a string representation of the given list of {@code MimeType} objects.\n\t * @param mimeTypes the string to parse\n\t * @return the list of mime types\n\t * @throws IllegalArgumentException if the String cannot be parsed\n\t */\n\tpublic static String toString(Collection<? extends MimeType> mimeTypes) {\n\t\tStringBuilder builder = new StringBuilder();\n\t\tfor (Iterator<? extends MimeType> iterator = mimeTypes.iterator(); iterator.hasNext();) {\n\t\t\tMimeType mimeType = iterator.next();\n\t\t\tmimeType.appendTo(builder);\n\t\t\tif (iterator.hasNext()) {\n\t\t\t\tbuilder.append(\", \");\n\t\t\t}\n\t\t}\n\t\treturn builder.toString();\n\t}\n\n\t/**\n\t * Sorts the given list of {@code MimeType} objects by\n\t * {@linkplain MimeType#isMoreSpecific(MimeType) specificity}.\n\t *\n\t * <p>Because of the computational cost, this method throws an exception\n\t * when the given list contains too many elements.\n\t * @param mimeTypes the list of mime types to be sorted\n\t * @throws IllegalArgumentException if {@code mimeTypes} contains more\n\t * than 50 elements\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.2\">HTTP 1.1: Semantics\n\t * and Content, section 5.3.2</a>\n\t * @see MimeType#isMoreSpecific(MimeType)\n\t */\n\tpublic static <T extends MimeType> void sortBySpecificity(List<T> mimeTypes) {\n\t\tAssert.notNull(mimeTypes, \"'mimeTypes' must not be null\");\n\t\tAssert.isTrue(mimeTypes.size() <= 50, \"Too many elements\");\n\n\t\tbubbleSort(mimeTypes, MimeType::isLessSpecific);\n\t}\n\n\tstatic <T> void bubbleSort(List<T> list, BiPredicate<? super T, ? super T> swap) {\n\t\tint len = list.size();\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tfor (int j = 1; j < len - i ; j++) {\n\t\t\t\tT prev = list.get(j - 1);\n\t\t\t\tT cur = list.get(j);\n\t\t\t\tif (swap.test(prev, cur)) {\n\t\t\t\t\tlist.set(j, prev);\n\t\t\t\t\tlist.set(j - 1, cur);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Generate a random MIME boundary as bytes, often used in multipart mime types.\n\t */\n\tpublic static byte[] generateMultipartBoundary() {\n\t\tRandom randomToUse = initRandom();\n\t\tbyte[] boundary = new byte[randomToUse.nextInt(11) + 30];\n\t\tfor (int i = 0; i < boundary.length; i++) {\n\t\t\tboundary[i] = BOUNDARY_CHARS[randomToUse.nextInt(BOUNDARY_CHARS.length)];\n\t\t}\n\t\treturn boundary;\n\t}\n\n\t/**\n\t * Lazily initialize the {@link SecureRandom} for {@link #generateMultipartBoundary()}.\n\t */\n\tprivate static Random initRandom() {\n\t\tRandom randomToUse = random;\n\t\tif (randomToUse == null) {\n\t\t\tsynchronized (MimeTypeUtils.class) {\n\t\t\t\trandomToUse = random;\n\t\t\t\tif (randomToUse == null) {\n\t\t\t\t\trandomToUse = new SecureRandom();\n\t\t\t\t\trandom = randomToUse;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn randomToUse;\n\t}\n\n\n\t/**\n\t * Generate a random MIME boundary as String, often used in multipart mime types.\n\t */\n\tpublic static String generateMultipartBoundaryString() {\n\t\treturn new String(generateMultipartBoundary(), StandardCharsets.US_ASCII);\n\t}\n\n}"
  },
  "org.springframework.util.MimeTypeUtils#generateMultipartBoundary()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a random MIME boundary as bytes, often used in multipart mime types.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "byte[]",
    "signature": "public byte[] generateMultipartBoundary()",
    "source_code": "\tpublic static byte[] generateMultipartBoundary() {\n\t\tRandom randomToUse = initRandom();\n\t\tbyte[] boundary = new byte[randomToUse.nextInt(11) + 30];\n\t\tfor (int i = 0; i < boundary.length; i++) {\n\t\t\tboundary[i] = BOUNDARY_CHARS[randomToUse.nextInt(BOUNDARY_CHARS.length)];\n\t\t}\n\t\treturn boundary;\n\t}"
  },
  "org.springframework.util.MimeTypeUtils#generateMultipartBoundaryString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a random MIME boundary as String, often used in multipart mime types.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 418
    },
    "return": "String",
    "signature": "public String generateMultipartBoundaryString()",
    "source_code": "\tpublic static String generateMultipartBoundaryString() {\n\t\treturn new String(generateMultipartBoundary(), StandardCharsets.US_ASCII);\n\t}"
  },
  "org.springframework.util.MimeTypeUtils#parseMimeType(mimeType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given String into a single {@code MimeType}.\n\t * Recently parsed {@code MimeType} are cached for further retrieval.\n\t * @param mimeType the string to parse\n\t * @return the mime type\n\t * @throws InvalidMimeTypeException if the string cannot be parsed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "MimeType",
    "signature": "public MimeType parseMimeType(String mimeType)",
    "source_code": "\tpublic static MimeType parseMimeType(String mimeType) {\n\t\tif (!StringUtils.hasLength(mimeType)) {\n\t\t\tthrow new InvalidMimeTypeException(mimeType, \"'mimeType' must not be empty\");\n\t\t}\n\t\t// do not cache multipart mime types with random boundaries\n\t\tif (mimeType.startsWith(\"multipart\")) {\n\t\t\treturn parseMimeTypeInternal(mimeType);\n\t\t}\n\t\treturn cachedMimeTypes.get(mimeType);\n\t}"
  },
  "org.springframework.util.MimeTypeUtils#parseMimeTypes(mimeTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the comma-separated string into a mutable list of {@code MimeType} objects.\n\t * @param mimeTypes the string to parse\n\t * @return the list of mime types\n\t * @throws InvalidMimeTypeException if the string cannot be parsed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mimeTypes"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "List<MimeType>",
    "signature": "public List<MimeType> parseMimeTypes(String mimeTypes)",
    "source_code": "\tpublic static List<MimeType> parseMimeTypes(String mimeTypes) {\n\t\tif (!StringUtils.hasLength(mimeTypes)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\treturn tokenize(mimeTypes).stream()\n\t\t\t\t.filter(StringUtils::hasText)\n\t\t\t\t.map(MimeTypeUtils::parseMimeType)\n\t\t\t\t.collect(Collectors.toList());\n\t}"
  },
  "org.springframework.util.MimeTypeUtils#sortBySpecificity(mimeTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Sorts the given list of {@code MimeType} objects by\n\t * {@linkplain MimeType#isMoreSpecific(MimeType) specificity}.\n\t *\n\t * <p>Because of the computational cost, this method throws an exception\n\t * when the given list contains too many elements.\n\t * @param mimeTypes the list of mime types to be sorted\n\t * @throws IllegalArgumentException if {@code mimeTypes} contains more\n\t * than 50 elements\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.2\">HTTP 1.1: Semantics\n\t * and Content, section 5.3.2</a>\n\t * @see MimeType#isMoreSpecific(MimeType)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mimeTypes"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "void",
    "signature": "public void sortBySpecificity(List<T> mimeTypes)",
    "source_code": "\tpublic static <T extends MimeType> void sortBySpecificity(List<T> mimeTypes) {\n\t\tAssert.notNull(mimeTypes, \"'mimeTypes' must not be null\");\n\t\tAssert.isTrue(mimeTypes.size() <= 50, \"Too many elements\");\n\n\t\tbubbleSort(mimeTypes, MimeType::isLessSpecific);\n\t}"
  },
  "org.springframework.util.MimeTypeUtils#toString(mimeTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a string representation of the given list of {@code MimeType} objects.\n\t * @param mimeTypes the string to parse\n\t * @return the list of mime types\n\t * @throws IllegalArgumentException if the String cannot be parsed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mimeTypes"
    ],
    "position": {
      "column": 1,
      "line": 338
    },
    "return": "String",
    "signature": "public String toString(Collection<? extends MimeType> mimeTypes)",
    "source_code": "\tpublic static String toString(Collection<? extends MimeType> mimeTypes) {\n\t\tStringBuilder builder = new StringBuilder();\n\t\tfor (Iterator<? extends MimeType> iterator = mimeTypes.iterator(); iterator.hasNext();) {\n\t\t\tMimeType mimeType = iterator.next();\n\t\t\tmimeType.appendTo(builder);\n\t\t\tif (iterator.hasNext()) {\n\t\t\t\tbuilder.append(\", \");\n\t\t\t}\n\t\t}\n\t\treturn builder.toString();\n\t}"
  },
  "org.springframework.util.MimeTypeUtils#tokenize(mimeTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Tokenize the given comma-separated string of {@code MimeType} objects\n\t * into a {@code List<String>}. Unlike simple tokenization by \",\", this\n\t * method takes into account quoted parameters.\n\t * @param mimeTypes the string to tokenize\n\t * @return the list of tokens\n\t * @since 5.1.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mimeTypes"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "List<String>",
    "signature": "public List<String> tokenize(String mimeTypes)",
    "source_code": "\tpublic static List<String> tokenize(String mimeTypes) {\n\t\tif (!StringUtils.hasLength(mimeTypes)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tList<String> tokens = new ArrayList<>();\n\t\tboolean inQuotes = false;\n\t\tint startIndex = 0;\n\t\tint i = 0;\n\t\twhile (i < mimeTypes.length()) {\n\t\t\tswitch (mimeTypes.charAt(i)) {\n\t\t\t\tcase '\"' -> inQuotes = !inQuotes;\n\t\t\t\tcase ',' -> {\n\t\t\t\t\tif (!inQuotes) {\n\t\t\t\t\t\ttokens.add(mimeTypes.substring(startIndex, i));\n\t\t\t\t\t\tstartIndex = i + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase '\\\\' -> i++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\ttokens.add(mimeTypes.substring(startIndex));\n\t\treturn tokens;\n\t}"
  },
  "org.springframework.util.SPECIFICITY_COMPARATOR": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Comparator formally used by {@link #sortBySpecificity(List)}.\n\t * @deprecated As of 6.0, with no direct replacement\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public Comparator<MimeType> SPECIFICITY_COMPARATOR",
    "source_code": "\tpublic static final Comparator<MimeType> SPECIFICITY_COMPARATOR = new MimeType.SpecificityComparator<>();",
    "type": "Comparator<MimeType>"
  },
  "org.springframework.util.TEXT_HTML": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Public constant mime type for {@code text/html}.\n\t *  */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "signature": "public MimeType TEXT_HTML",
    "source_code": "\tpublic static final MimeType TEXT_HTML;",
    "type": "MimeType"
  },
  "org.springframework.util.TEXT_HTML_VALUE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A String equivalent of {@link MimeTypeUtils#TEXT_HTML}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "signature": "public String TEXT_HTML_VALUE",
    "source_code": "\tpublic static final String TEXT_HTML_VALUE = \"text/html\";",
    "type": "String"
  },
  "org.springframework.util.TEXT_PLAIN": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Public constant mime type for {@code text/plain}.\n\t *  */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "signature": "public MimeType TEXT_PLAIN",
    "source_code": "\tpublic static final MimeType TEXT_PLAIN;",
    "type": "MimeType"
  },
  "org.springframework.util.TEXT_PLAIN_VALUE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A String equivalent of {@link MimeTypeUtils#TEXT_PLAIN}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "signature": "public String TEXT_PLAIN_VALUE",
    "source_code": "\tpublic static final String TEXT_PLAIN_VALUE = \"text/plain\";",
    "type": "String"
  },
  "org.springframework.util.TEXT_XML": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Public constant mime type for {@code text/xml}.\n\t *  */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "signature": "public MimeType TEXT_XML",
    "source_code": "\tpublic static final MimeType TEXT_XML;",
    "type": "MimeType"
  },
  "org.springframework.util.TEXT_XML_VALUE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A String equivalent of {@link MimeTypeUtils#TEXT_XML}.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "signature": "public String TEXT_XML_VALUE",
    "source_code": "\tpublic static final String TEXT_XML_VALUE = \"text/xml\";",
    "type": "String"
  },
  "org.springframework.util.concurrent.FutureAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract class that adapts a {@link Future} parameterized over S into a {@code Future}\n * parameterized over T. All methods are delegated to the adaptee, where {@link #get()}\n * and {@link #get(long, TimeUnit)} call {@link #adapt(Object)} on the adaptee's result.\n *\n * @author Arjen Poutsma\n * @since 4.0\n * @param <T> the type of this {@code Future}\n * @param <S> the type of the adaptee's {@code Future}\n * @deprecated as of 6.0, with no concrete replacement\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class FutureAdapter",
    "source_code": "public abstract class FutureAdapter<T, S> implements Future<T> {\n\n\tprivate final Future<S> adaptee;\n\n\t@Nullable\n\tprivate Object result;\n\n\tprivate State state = State.NEW;\n\n\tprivate final Object mutex = new Object();\n\n\n\t/**\n\t * Constructs a new {@code FutureAdapter} with the given adaptee.\n\t * @param adaptee the future to delegate to\n\t */\n\tprotected FutureAdapter(Future<S> adaptee) {\n\t\tAssert.notNull(adaptee, \"Delegate must not be null\");\n\t\tthis.adaptee = adaptee;\n\t}\n\n\n\t/**\n\t * Returns the adaptee.\n\t */\n\tprotected Future<S> getAdaptee() {\n\t\treturn this.adaptee;\n\t}\n\n\t@Override\n\tpublic boolean cancel(boolean mayInterruptIfRunning) {\n\t\treturn this.adaptee.cancel(mayInterruptIfRunning);\n\t}\n\n\t@Override\n\tpublic boolean isCancelled() {\n\t\treturn this.adaptee.isCancelled();\n\t}\n\n\t@Override\n\tpublic boolean isDone() {\n\t\treturn this.adaptee.isDone();\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic T get() throws InterruptedException, ExecutionException {\n\t\treturn adaptInternal(this.adaptee.get());\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n\t\treturn adaptInternal(this.adaptee.get(timeout, unit));\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Nullable\n\tfinal T adaptInternal(S adapteeResult) throws ExecutionException {\n\t\tsynchronized (this.mutex) {\n\t\t\treturn switch (this.state) {\n\t\t\t\tcase SUCCESS -> (T) this.result;\n\t\t\t\tcase FAILURE -> {\n\t\t\t\t\tAssert.state(this.result instanceof ExecutionException, \"Failure without exception\");\n\t\t\t\t\tthrow (ExecutionException) this.result;\n\t\t\t\t}\n\t\t\t\tcase NEW -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tT adapted = adapt(adapteeResult);\n\t\t\t\t\t\tthis.result = adapted;\n\t\t\t\t\t\tthis.state = State.SUCCESS;\n\t\t\t\t\t\tyield adapted;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ExecutionException ex) {\n\t\t\t\t\t\tthis.result = ex;\n\t\t\t\t\t\tthis.state = State.FAILURE;\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tExecutionException execEx = new ExecutionException(ex);\n\t\t\t\t\t\tthis.result = execEx;\n\t\t\t\t\t\tthis.state = State.FAILURE;\n\t\t\t\t\t\tthrow execEx;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Adapts the given adaptee's result into T.\n\t * @return the adapted result\n\t */\n\t@Nullable\n\tprotected abstract T adapt(S adapteeResult) throws ExecutionException;\n\n\n\tprivate enum State {NEW, SUCCESS, FAILURE}\n\n}"
  },
  "org.springframework.util.concurrent.FutureAdapter#adapt(adapteeResult)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adapts the given adaptee's result into T.\n\t * @return the adapted result\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "adapteeResult"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "T",
    "signature": "protected T adapt(S adapteeResult)",
    "source_code": "\tprotected abstract T adapt(S adapteeResult) throws ExecutionException;"
  },
  "org.springframework.util.concurrent.FutureAdapter#cancel(mayInterruptIfRunning)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mayInterruptIfRunning"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "boolean",
    "signature": "public boolean cancel(boolean mayInterruptIfRunning)",
    "source_code": "\tpublic boolean cancel(boolean mayInterruptIfRunning) {\n\t\treturn this.adaptee.cancel(mayInterruptIfRunning);\n\t}"
  },
  "org.springframework.util.concurrent.FutureAdapter#get()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "T",
    "signature": "public T get()",
    "source_code": "\tpublic T get() throws InterruptedException, ExecutionException {\n\t\treturn adaptInternal(this.adaptee.get());\n\t}"
  },
  "org.springframework.util.concurrent.FutureAdapter#get(timeout,unit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "T",
    "signature": "public T get(long timeout, TimeUnit unit)",
    "source_code": "\tpublic T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n\t\treturn adaptInternal(this.adaptee.get(timeout, unit));\n\t}"
  },
  "org.springframework.util.concurrent.FutureAdapter#getAdaptee()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the adaptee.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "Future<S>",
    "signature": "protected Future<S> getAdaptee()",
    "source_code": "\tprotected Future<S> getAdaptee() {\n\t\treturn this.adaptee;\n\t}"
  },
  "org.springframework.util.concurrent.FutureAdapter#isCancelled()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "boolean",
    "signature": "public boolean isCancelled()",
    "source_code": "\tpublic boolean isCancelled() {\n\t\treturn this.adaptee.isCancelled();\n\t}"
  },
  "org.springframework.util.concurrent.FutureAdapter#isDone()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "boolean",
    "signature": "public boolean isDone()",
    "source_code": "\tpublic boolean isDone() {\n\t\treturn this.adaptee.isDone();\n\t}"
  },
  "org.springframework.util.xml.<unknown>#endPrefixMapping(prefix)": {
    "change": "modifier_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * End the prefix mapping for the given prefix.\n\t * @see org.xml.sax.ContentHandler#endPrefixMapping(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "protected void endPrefixMapping(String prefix)",
    "source_code": "\tprotected void endPrefixMapping(String prefix) throws SAXException {\n\t\tif (getContentHandler() != null && this.namespaces.containsKey(prefix)) {\n\t\t\tgetContentHandler().endPrefixMapping(prefix);\n\t\t\tthis.namespaces.remove(prefix);\n\t\t}\n\t}"
  },
  "org.springframework.util.xml.<unknown>#getColumnNumber()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "int",
    "signature": "public int getColumnNumber()",
    "source_code": "\t\tpublic int getColumnNumber() {\n\t\t\treturn this.location.getColumnNumber();\n\t\t}"
  },
  "org.springframework.util.xml.<unknown>#getFeature(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "boolean",
    "signature": "public boolean getFeature(String name)",
    "source_code": "\tpublic boolean getFeature(String name) throws SAXNotRecognizedException, SAXNotSupportedException {\n\t\treturn switch (name) {\n\t\t\tcase NAMESPACES_FEATURE_NAME -> this.namespacesFeature;\n\t\t\tcase NAMESPACE_PREFIXES_FEATURE_NAME -> this.namespacePrefixesFeature;\n\t\t\tcase IS_STANDALONE_FEATURE_NAME -> {\n\t\t\t\tif (this.isStandalone != null) {\n\t\t\t\t\tyield this.isStandalone;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new SAXNotSupportedException(\"startDocument() callback not completed yet\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefault -> super.getFeature(name);\n\t\t};\n\t}"
  },
  "org.springframework.util.xml.<unknown>#getLineNumber()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "int",
    "signature": "public int getLineNumber()",
    "source_code": "\t\tpublic int getLineNumber() {\n\t\t\treturn this.location.getLineNumber();\n\t\t}"
  },
  "org.springframework.util.xml.<unknown>#getPublicId()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "String",
    "signature": "public String getPublicId()",
    "source_code": "\t\tpublic String getPublicId() {\n\t\t\treturn this.location.getPublicId();\n\t\t}"
  },
  "org.springframework.util.xml.<unknown>#getSystemId()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "String",
    "signature": "public String getSystemId()",
    "source_code": "\t\tpublic String getSystemId() {\n\t\t\treturn this.location.getSystemId();\n\t\t}"
  },
  "org.springframework.util.xml.<unknown>#hasNamespacePrefixesFeature()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicates whether the SAX feature {@code http://xml.org/sax/features/namespaces-prefixes} is turned on.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "boolean",
    "signature": "protected boolean hasNamespacePrefixesFeature()",
    "source_code": "\tprotected boolean hasNamespacePrefixesFeature() {\n\t\treturn this.namespacePrefixesFeature;\n\t}"
  },
  "org.springframework.util.xml.<unknown>#hasNamespacesFeature()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicates whether the SAX feature {@code http://xml.org/sax/features/namespaces} is turned on.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "boolean",
    "signature": "protected boolean hasNamespacesFeature()",
    "source_code": "\tprotected boolean hasNamespacesFeature() {\n\t\treturn this.namespacesFeature;\n\t}"
  },
  "org.springframework.util.xml.<unknown>#parse(ignored)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the StAX XML reader passed at construction-time.\n\t * <p><b>NOTE:</b>: The given system identifier is not read, but ignored.\n\t * @param ignored is ignored\n\t * @throws SAXException a SAX exception, possibly wrapping a {@code XMLStreamException}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ignored"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "public void parse(String ignored)",
    "source_code": "\tpublic final void parse(String ignored) throws SAXException {\n\t\tparse();\n\t}"
  },
  "org.springframework.util.xml.<unknown>#parseInternal()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that parses the StAX reader passed at construction-time.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "void",
    "signature": "protected void parseInternal()",
    "source_code": "\tprotected abstract void parseInternal() throws SAXException, XMLStreamException;"
  },
  "org.springframework.util.xml.<unknown>#setFeature(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void setFeature(String name, boolean value)",
    "source_code": "\tpublic void setFeature(String name, boolean value) throws SAXNotRecognizedException, SAXNotSupportedException {\n\t\tif (NAMESPACES_FEATURE_NAME.equals(name)) {\n\t\t\tthis.namespacesFeature = value;\n\t\t}\n\t\telse if (NAMESPACE_PREFIXES_FEATURE_NAME.equals(name)) {\n\t\t\tthis.namespacePrefixesFeature = value;\n\t\t}\n\t\telse {\n\t\t\tsuper.setFeature(name, value);\n\t\t}\n\t}"
  },
  "org.springframework.util.xml.<unknown>#setStandalone(standalone)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "standalone"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "protected void setStandalone(boolean standalone)",
    "source_code": "\tprotected void setStandalone(boolean standalone) {\n\t\tthis.isStandalone = standalone;\n\t}"
  },
  "org.springframework.util.xml.<unknown>#startPrefixMapping(prefix,namespace)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Start the prefix mapping for the given prefix.\n\t * @see org.xml.sax.ContentHandler#startPrefixMapping(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "prefix",
      "namespace"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "protected void startPrefixMapping(@Nullable String prefix, String namespace)",
    "source_code": "\tprotected void startPrefixMapping(@Nullable String prefix, String namespace) throws SAXException {\n\t\tif (getContentHandler() != null && StringUtils.hasLength(namespace)) {\n\t\t\tif (prefix == null) {\n\t\t\t\tprefix = \"\";\n\t\t\t}\n\t\t\tif (!namespace.equals(this.namespaces.get(prefix))) {\n\t\t\t\tgetContentHandler().startPrefixMapping(prefix, namespace);\n\t\t\t\tthis.namespaces.put(prefix, namespace);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.xml.<unknown>#toQualifiedName(qName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a {@code QName} to a qualified name, as used by DOM and SAX.\n\t * The returned string has a format of {@code prefix:localName} if the\n\t * prefix is set, or just {@code localName} if not.\n\t * @param qName the {@code QName}\n\t * @return the qualified name\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "qName"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "String",
    "signature": "protected String toQualifiedName(QName qName)",
    "source_code": "\tprotected String toQualifiedName(QName qName) {\n\t\tString prefix = qName.getPrefix();\n\t\tif (!StringUtils.hasLength(prefix)) {\n\t\t\treturn qName.getLocalPart();\n\t\t}\n\t\telse {\n\t\t\treturn prefix + \":\" + qName.getLocalPart();\n\t\t}\n\t}"
  },
  "org.springframework.validation.DEFAULT_AUTO_GROW_COLLECTION_LIMIT": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Default limit for array and collection growing: 256. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "signature": "public int DEFAULT_AUTO_GROW_COLLECTION_LIMIT",
    "source_code": "\tpublic static final int DEFAULT_AUTO_GROW_COLLECTION_LIMIT = 256;",
    "type": "int"
  },
  "org.springframework.validation.DEFAULT_OBJECT_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Default object name used for binding: \"target\". */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "signature": "public String DEFAULT_OBJECT_NAME",
    "source_code": "\tpublic static final String DEFAULT_OBJECT_NAME = \"target\";",
    "type": "String"
  },
  "org.springframework.validation.DataBinder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Binder that allows for setting property values on a target object, including\n * support for validation and binding result analysis.\n *\n * <p>The binding process can be customized by specifying allowed field patterns,\n * required fields, custom editors, etc.\n *\n * <p><strong>WARNING</strong>: Data binding can lead to security issues by exposing\n * parts of the object graph that are not meant to be accessed or modified by\n * external clients. Therefore, the design and use of data binding should be considered\n * carefully with regard to security. For more details, please refer to the dedicated\n * sections on data binding for\n * <a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-initbinder-model-design\">Spring Web MVC</a> and\n * <a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-initbinder-model-design\">Spring WebFlux</a>\n * in the reference manual.\n *\n * <p>The binding results can be examined via the {@link BindingResult} interface,\n * extending the {@link Errors} interface: see the {@link #getBindingResult()} method.\n * Missing fields and property access exceptions will be converted to {@link FieldError FieldErrors},\n * collected in the Errors instance, using the following error codes:\n *\n * <ul>\n * <li>Missing field error: \"required\"\n * <li>Type mismatch error: \"typeMismatch\"\n * <li>Method invocation error: \"methodInvocation\"\n * </ul>\n *\n * <p>By default, binding errors get resolved through the {@link BindingErrorProcessor}\n * strategy, processing for missing fields and property access exceptions: see the\n * {@link #setBindingErrorProcessor} method. You can override the default strategy\n * if needed, for example to generate different error codes.\n *\n * <p>Custom validation errors can be added afterwards. You will typically want to resolve\n * such error codes into proper user-visible error messages; this can be achieved through\n * resolving each error via a {@link org.springframework.context.MessageSource}, which is\n * able to resolve an {@link ObjectError}/{@link FieldError} through its\n * {@link org.springframework.context.MessageSource#getMessage(org.springframework.context.MessageSourceResolvable, java.util.Locale)}\n * method. The list of message codes can be customized through the {@link MessageCodesResolver}\n * strategy: see the {@link #setMessageCodesResolver} method. {@link DefaultMessageCodesResolver}'s\n * javadoc states details on the default resolution rules.\n *\n * <p>This generic data binder can be used in any kind of environment.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Stephane Nicoll\n * @author Kazuki Shimizu\n * @author Sam Brannen\n * @see #setAllowedFields\n * @see #setRequiredFields\n * @see #registerCustomEditor\n * @see #setMessageCodesResolver\n * @see #setBindingErrorProcessor\n * @see #bind\n * @see #getBindingResult\n * @see DefaultMessageCodesResolver\n * @see DefaultBindingErrorProcessor\n * @see org.springframework.context.MessageSource\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "signature": "public class DataBinder",
    "source_code": "public class DataBinder implements PropertyEditorRegistry, TypeConverter {\n\n\t/** Default object name used for binding: \"target\". */\n\tpublic static final String DEFAULT_OBJECT_NAME = \"target\";\n\n\t/** Default limit for array and collection growing: 256. */\n\tpublic static final int DEFAULT_AUTO_GROW_COLLECTION_LIMIT = 256;\n\n\n\t/**\n\t * We'll create a lot of DataBinder instances: Let's use a static logger.\n\t */\n\tprotected static final Log logger = LogFactory.getLog(DataBinder.class);\n\n\t@Nullable\n\tprivate final Object target;\n\n\tprivate final String objectName;\n\n\t@Nullable\n\tprivate AbstractPropertyBindingResult bindingResult;\n\n\tprivate boolean directFieldAccess = false;\n\n\t@Nullable\n\tprivate SimpleTypeConverter typeConverter;\n\n\tprivate boolean ignoreUnknownFields = true;\n\n\tprivate boolean ignoreInvalidFields = false;\n\n\tprivate boolean autoGrowNestedPaths = true;\n\n\tprivate int autoGrowCollectionLimit = DEFAULT_AUTO_GROW_COLLECTION_LIMIT;\n\n\t@Nullable\n\tprivate String[] allowedFields;\n\n\t@Nullable\n\tprivate String[] disallowedFields;\n\n\t@Nullable\n\tprivate String[] requiredFields;\n\n\t@Nullable\n\tprivate ConversionService conversionService;\n\n\t@Nullable\n\tprivate MessageCodesResolver messageCodesResolver;\n\n\tprivate BindingErrorProcessor bindingErrorProcessor = new DefaultBindingErrorProcessor();\n\n\tprivate final List<Validator> validators = new ArrayList<>();\n\n\n\t/**\n\t * Create a new DataBinder instance, with default object name.\n\t * @param target the target object to bind onto (or {@code null}\n\t * if the binder is just used to convert a plain parameter value)\n\t * @see #DEFAULT_OBJECT_NAME\n\t */\n\tpublic DataBinder(@Nullable Object target) {\n\t\tthis(target, DEFAULT_OBJECT_NAME);\n\t}\n\n\t/**\n\t * Create a new DataBinder instance.\n\t * @param target the target object to bind onto (or {@code null}\n\t * if the binder is just used to convert a plain parameter value)\n\t * @param objectName the name of the target object\n\t */\n\tpublic DataBinder(@Nullable Object target, String objectName) {\n\t\tthis.target = ObjectUtils.unwrapOptional(target);\n\t\tthis.objectName = objectName;\n\t}\n\n\n\t/**\n\t * Return the wrapped target object.\n\t */\n\t@Nullable\n\tpublic Object getTarget() {\n\t\treturn this.target;\n\t}\n\n\t/**\n\t * Return the name of the bound object.\n\t */\n\tpublic String getObjectName() {\n\t\treturn this.objectName;\n\t}\n\n\t/**\n\t * Set whether this binder should attempt to \"auto-grow\" a nested path that contains a null value.\n\t * <p>If \"true\", a null path location will be populated with a default object value and traversed\n\t * instead of resulting in an exception. This flag also enables auto-growth of collection elements\n\t * when accessing an out-of-bounds index.\n\t * <p>Default is \"true\" on a standard DataBinder. Note that since Spring 4.1 this feature is supported\n\t * for bean property access (DataBinder's default mode) and field access.\n\t * @see #initBeanPropertyAccess()\n\t * @see org.springframework.beans.BeanWrapper#setAutoGrowNestedPaths\n\t */\n\tpublic void setAutoGrowNestedPaths(boolean autoGrowNestedPaths) {\n\t\tAssert.state(this.bindingResult == null,\n\t\t\t\t\"DataBinder is already initialized - call setAutoGrowNestedPaths before other configuration methods\");\n\t\tthis.autoGrowNestedPaths = autoGrowNestedPaths;\n\t}\n\n\t/**\n\t * Return whether \"auto-growing\" of nested paths has been activated.\n\t */\n\tpublic boolean isAutoGrowNestedPaths() {\n\t\treturn this.autoGrowNestedPaths;\n\t}\n\n\t/**\n\t * Specify the limit for array and collection auto-growing.\n\t * <p>Default is 256, preventing OutOfMemoryErrors in case of large indexes.\n\t * Raise this limit if your auto-growing needs are unusually high.\n\t * @see #initBeanPropertyAccess()\n\t * @see org.springframework.beans.BeanWrapper#setAutoGrowCollectionLimit\n\t */\n\tpublic void setAutoGrowCollectionLimit(int autoGrowCollectionLimit) {\n\t\tAssert.state(this.bindingResult == null,\n\t\t\t\t\"DataBinder is already initialized - call setAutoGrowCollectionLimit before other configuration methods\");\n\t\tthis.autoGrowCollectionLimit = autoGrowCollectionLimit;\n\t}\n\n\t/**\n\t * Return the current limit for array and collection auto-growing.\n\t */\n\tpublic int getAutoGrowCollectionLimit() {\n\t\treturn this.autoGrowCollectionLimit;\n\t}\n\n\t/**\n\t * Initialize standard JavaBean property access for this DataBinder.\n\t * <p>This is the default; an explicit call just leads to eager initialization.\n\t * @see #initDirectFieldAccess()\n\t * @see #createBeanPropertyBindingResult()\n\t */\n\tpublic void initBeanPropertyAccess() {\n\t\tAssert.state(this.bindingResult == null,\n\t\t\t\t\"DataBinder is already initialized - call initBeanPropertyAccess before other configuration methods\");\n\t\tthis.directFieldAccess = false;\n\t}\n\n\t/**\n\t * Create the {@link AbstractPropertyBindingResult} instance using standard\n\t * JavaBean property access.\n\t * @since 4.2.1\n\t */\n\tprotected AbstractPropertyBindingResult createBeanPropertyBindingResult() {\n\t\tBeanPropertyBindingResult result = new BeanPropertyBindingResult(getTarget(),\n\t\t\t\tgetObjectName(), isAutoGrowNestedPaths(), getAutoGrowCollectionLimit());\n\n\t\tif (this.conversionService != null) {\n\t\t\tresult.initConversion(this.conversionService);\n\t\t}\n\t\tif (this.messageCodesResolver != null) {\n\t\t\tresult.setMessageCodesResolver(this.messageCodesResolver);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Initialize direct field access for this DataBinder,\n\t * as alternative to the default bean property access.\n\t * @see #initBeanPropertyAccess()\n\t * @see #createDirectFieldBindingResult()\n\t */\n\tpublic void initDirectFieldAccess() {\n\t\tAssert.state(this.bindingResult == null,\n\t\t\t\t\"DataBinder is already initialized - call initDirectFieldAccess before other configuration methods\");\n\t\tthis.directFieldAccess = true;\n\t}\n\n\t/**\n\t * Create the {@link AbstractPropertyBindingResult} instance using direct\n\t * field access.\n\t * @since 4.2.1\n\t */\n\tprotected AbstractPropertyBindingResult createDirectFieldBindingResult() {\n\t\tDirectFieldBindingResult result = new DirectFieldBindingResult(getTarget(),\n\t\t\t\tgetObjectName(), isAutoGrowNestedPaths());\n\n\t\tif (this.conversionService != null) {\n\t\t\tresult.initConversion(this.conversionService);\n\t\t}\n\t\tif (this.messageCodesResolver != null) {\n\t\t\tresult.setMessageCodesResolver(this.messageCodesResolver);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Return the internal BindingResult held by this DataBinder,\n\t * as an AbstractPropertyBindingResult.\n\t */\n\tprotected AbstractPropertyBindingResult getInternalBindingResult() {\n\t\tif (this.bindingResult == null) {\n\t\t\tthis.bindingResult = (this.directFieldAccess ?\n\t\t\t\t\tcreateDirectFieldBindingResult(): createBeanPropertyBindingResult());\n\t\t}\n\t\treturn this.bindingResult;\n\t}\n\n\t/**\n\t * Return the underlying PropertyAccessor of this binder's BindingResult.\n\t */\n\tprotected ConfigurablePropertyAccessor getPropertyAccessor() {\n\t\treturn getInternalBindingResult().getPropertyAccessor();\n\t}\n\n\t/**\n\t * Return this binder's underlying SimpleTypeConverter.\n\t */\n\tprotected SimpleTypeConverter getSimpleTypeConverter() {\n\t\tif (this.typeConverter == null) {\n\t\t\tthis.typeConverter = new SimpleTypeConverter();\n\t\t\tif (this.conversionService != null) {\n\t\t\t\tthis.typeConverter.setConversionService(this.conversionService);\n\t\t\t}\n\t\t}\n\t\treturn this.typeConverter;\n\t}\n\n\t/**\n\t * Return the underlying TypeConverter of this binder's BindingResult.\n\t */\n\tprotected PropertyEditorRegistry getPropertyEditorRegistry() {\n\t\tif (getTarget() != null) {\n\t\t\treturn getInternalBindingResult().getPropertyAccessor();\n\t\t}\n\t\telse {\n\t\t\treturn getSimpleTypeConverter();\n\t\t}\n\t}\n\n\t/**\n\t * Return the underlying TypeConverter of this binder's BindingResult.\n\t */\n\tprotected TypeConverter getTypeConverter() {\n\t\tif (getTarget() != null) {\n\t\t\treturn getInternalBindingResult().getPropertyAccessor();\n\t\t}\n\t\telse {\n\t\t\treturn getSimpleTypeConverter();\n\t\t}\n\t}\n\n\t/**\n\t * Return the BindingResult instance created by this DataBinder.\n\t * This allows for convenient access to the binding results after\n\t * a bind operation.\n\t * @return the BindingResult instance, to be treated as BindingResult\n\t * or as Errors instance (Errors is a super-interface of BindingResult)\n\t * @see Errors\n\t * @see #bind\n\t */\n\tpublic BindingResult getBindingResult() {\n\t\treturn getInternalBindingResult();\n\t}\n\n\n\t/**\n\t * Set whether to ignore unknown fields, that is, whether to ignore bind\n\t * parameters that do not have corresponding fields in the target object.\n\t * <p>Default is \"true\". Turn this off to enforce that all bind parameters\n\t * must have a matching field in the target object.\n\t * <p>Note that this setting only applies to <i>binding</i> operations\n\t * on this DataBinder, not to <i>retrieving</i> values via its\n\t * {@link #getBindingResult() BindingResult}.\n\t * @see #bind\n\t */\n\tpublic void setIgnoreUnknownFields(boolean ignoreUnknownFields) {\n\t\tthis.ignoreUnknownFields = ignoreUnknownFields;\n\t}\n\n\t/**\n\t * Return whether to ignore unknown fields when binding.\n\t */\n\tpublic boolean isIgnoreUnknownFields() {\n\t\treturn this.ignoreUnknownFields;\n\t}\n\n\t/**\n\t * Set whether to ignore invalid fields, that is, whether to ignore bind\n\t * parameters that have corresponding fields in the target object which are\n\t * not accessible (for example because of null values in the nested path).\n\t * <p>Default is \"false\". Turn this on to ignore bind parameters for\n\t * nested objects in non-existing parts of the target object graph.\n\t * <p>Note that this setting only applies to <i>binding</i> operations\n\t * on this DataBinder, not to <i>retrieving</i> values via its\n\t * {@link #getBindingResult() BindingResult}.\n\t * @see #bind\n\t */\n\tpublic void setIgnoreInvalidFields(boolean ignoreInvalidFields) {\n\t\tthis.ignoreInvalidFields = ignoreInvalidFields;\n\t}\n\n\t/**\n\t * Return whether to ignore invalid fields when binding.\n\t */\n\tpublic boolean isIgnoreInvalidFields() {\n\t\treturn this.ignoreInvalidFields;\n\t}\n\n\t/**\n\t * Register field patterns that should be allowed for binding.\n\t * <p>Default is all fields.\n\t * <p>Restrict this for example to avoid unwanted modifications by malicious\n\t * users when binding HTTP request parameters.\n\t * <p>Supports {@code \"xxx*\"}, {@code \"*xxx\"}, {@code \"*xxx*\"}, and\n\t * {@code \"xxx*yyy\"} matches (with an arbitrary number of pattern parts), as\n\t * well as direct equality.\n\t * <p>The default implementation of this method stores allowed field patterns\n\t * in {@linkplain PropertyAccessorUtils#canonicalPropertyName(String) canonical}\n\t * form. Subclasses which override this method must therefore take this into\n\t * account.\n\t * <p>More sophisticated matching can be implemented by overriding the\n\t * {@link #isAllowed} method.\n\t * <p>Alternatively, specify a list of <i>disallowed</i> field patterns.\n\t * @param allowedFields array of allowed field patterns\n\t * @see #setDisallowedFields\n\t * @see #isAllowed(String)\n\t */\n\tpublic void setAllowedFields(@Nullable String... allowedFields) {\n\t\tthis.allowedFields = PropertyAccessorUtils.canonicalPropertyNames(allowedFields);\n\t}\n\n\t/**\n\t * Return the field patterns that should be allowed for binding.\n\t * @return array of allowed field patterns\n\t * @see #setAllowedFields(String...)\n\t */\n\t@Nullable\n\tpublic String[] getAllowedFields() {\n\t\treturn this.allowedFields;\n\t}\n\n\t/**\n\t * Register field patterns that should <i>not</i> be allowed for binding.\n\t * <p>Default is none.\n\t * <p>Mark fields as disallowed, for example to avoid unwanted\n\t * modifications by malicious users when binding HTTP request parameters.\n\t * <p>Supports {@code \"xxx*\"}, {@code \"*xxx\"}, {@code \"*xxx*\"}, and\n\t * {@code \"xxx*yyy\"} matches (with an arbitrary number of pattern parts), as\n\t * well as direct equality.\n\t * <p>The default implementation of this method stores disallowed field patterns\n\t * in {@linkplain PropertyAccessorUtils#canonicalPropertyName(String) canonical}\n\t * form. As of Spring Framework 5.2.21, the default implementation also transforms\n\t * disallowed field patterns to {@linkplain String#toLowerCase() lowercase} to\n\t * support case-insensitive pattern matching in {@link #isAllowed}. Subclasses\n\t * which override this method must therefore take both of these transformations\n\t * into account.\n\t * <p>More sophisticated matching can be implemented by overriding the\n\t * {@link #isAllowed} method.\n\t * <p>Alternatively, specify a list of <i>allowed</i> field patterns.\n\t * @param disallowedFields array of disallowed field patterns\n\t * @see #setAllowedFields\n\t * @see #isAllowed(String)\n\t */\n\tpublic void setDisallowedFields(@Nullable String... disallowedFields) {\n\t\tif (disallowedFields == null) {\n\t\t\tthis.disallowedFields = null;\n\t\t}\n\t\telse {\n\t\t\tString[] fieldPatterns = new String[disallowedFields.length];\n\t\t\tfor (int i = 0; i < fieldPatterns.length; i++) {\n\t\t\t\tfieldPatterns[i] = PropertyAccessorUtils.canonicalPropertyName(disallowedFields[i]).toLowerCase();\n\t\t\t}\n\t\t\tthis.disallowedFields = fieldPatterns;\n\t\t}\n\t}\n\n\t/**\n\t * Return the field patterns that should <i>not</i> be allowed for binding.\n\t * @return array of disallowed field patterns\n\t * @see #setDisallowedFields(String...)\n\t */\n\t@Nullable\n\tpublic String[] getDisallowedFields() {\n\t\treturn this.disallowedFields;\n\t}\n\n\t/**\n\t * Register fields that are required for each binding process.\n\t * <p>If one of the specified fields is not contained in the list of\n\t * incoming property values, a corresponding \"missing field\" error\n\t * will be created, with error code \"required\" (by the default\n\t * binding error processor).\n\t * @param requiredFields array of field names\n\t * @see #setBindingErrorProcessor\n\t * @see DefaultBindingErrorProcessor#MISSING_FIELD_ERROR_CODE\n\t */\n\tpublic void setRequiredFields(@Nullable String... requiredFields) {\n\t\tthis.requiredFields = PropertyAccessorUtils.canonicalPropertyNames(requiredFields);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"DataBinder requires binding of required fields [\" +\n\t\t\t\t\tStringUtils.arrayToCommaDelimitedString(requiredFields) + \"]\");\n\t\t}\n\t}\n\n\t/**\n\t * Return the fields that are required for each binding process.\n\t * @return array of field names\n\t */\n\t@Nullable\n\tpublic String[] getRequiredFields() {\n\t\treturn this.requiredFields;\n\t}\n\n\t/**\n\t * Set the strategy to use for resolving errors into message codes.\n\t * Applies the given strategy to the underlying errors holder.\n\t * <p>Default is a DefaultMessageCodesResolver.\n\t * @see BeanPropertyBindingResult#setMessageCodesResolver\n\t * @see DefaultMessageCodesResolver\n\t */\n\tpublic void setMessageCodesResolver(@Nullable MessageCodesResolver messageCodesResolver) {\n\t\tAssert.state(this.messageCodesResolver == null, \"DataBinder is already initialized with MessageCodesResolver\");\n\t\tthis.messageCodesResolver = messageCodesResolver;\n\t\tif (this.bindingResult != null && messageCodesResolver != null) {\n\t\t\tthis.bindingResult.setMessageCodesResolver(messageCodesResolver);\n\t\t}\n\t}\n\n\t/**\n\t * Set the strategy to use for processing binding errors, that is,\n\t * required field errors and {@code PropertyAccessException}s.\n\t * <p>Default is a DefaultBindingErrorProcessor.\n\t * @see DefaultBindingErrorProcessor\n\t */\n\tpublic void setBindingErrorProcessor(BindingErrorProcessor bindingErrorProcessor) {\n\t\tAssert.notNull(bindingErrorProcessor, \"BindingErrorProcessor must not be null\");\n\t\tthis.bindingErrorProcessor = bindingErrorProcessor;\n\t}\n\n\t/**\n\t * Return the strategy for processing binding errors.\n\t */\n\tpublic BindingErrorProcessor getBindingErrorProcessor() {\n\t\treturn this.bindingErrorProcessor;\n\t}\n\n\t/**\n\t * Set the Validator to apply after each binding step.\n\t * @see #addValidators(Validator...)\n\t * @see #replaceValidators(Validator...)\n\t */\n\tpublic void setValidator(@Nullable Validator validator) {\n\t\tassertValidators(validator);\n\t\tthis.validators.clear();\n\t\tif (validator != null) {\n\t\t\tthis.validators.add(validator);\n\t\t}\n\t}\n\n\tprivate void assertValidators(Validator... validators) {\n\t\tObject target = getTarget();\n\t\tfor (Validator validator : validators) {\n\t\t\tif (validator != null && (target != null && !validator.supports(target.getClass()))) {\n\t\t\t\tthrow new IllegalStateException(\"Invalid target for Validator [\" + validator + \"]: \" + target);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Add Validators to apply after each binding step.\n\t * @see #setValidator(Validator)\n\t * @see #replaceValidators(Validator...)\n\t */\n\tpublic void addValidators(Validator... validators) {\n\t\tassertValidators(validators);\n\t\tthis.validators.addAll(Arrays.asList(validators));\n\t}\n\n\t/**\n\t * Replace the Validators to apply after each binding step.\n\t * @see #setValidator(Validator)\n\t * @see #addValidators(Validator...)\n\t */\n\tpublic void replaceValidators(Validator... validators) {\n\t\tassertValidators(validators);\n\t\tthis.validators.clear();\n\t\tthis.validators.addAll(Arrays.asList(validators));\n\t}\n\n\t/**\n\t * Return the primary Validator to apply after each binding step, if any.\n\t */\n\t@Nullable\n\tpublic Validator getValidator() {\n\t\treturn (!this.validators.isEmpty() ? this.validators.get(0) : null);\n\t}\n\n\t/**\n\t * Return the Validators to apply after data binding.\n\t */\n\tpublic List<Validator> getValidators() {\n\t\treturn Collections.unmodifiableList(this.validators);\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of PropertyEditorRegistry/TypeConverter interface\n\t//---------------------------------------------------------------------\n\n\t/**\n\t * Specify a {@link ConversionService} to use for converting\n\t * property values, as an alternative to JavaBeans PropertyEditors.\n\t */\n\tpublic void setConversionService(@Nullable ConversionService conversionService) {\n\t\tAssert.state(this.conversionService == null, \"DataBinder is already initialized with ConversionService\");\n\t\tthis.conversionService = conversionService;\n\t\tif (this.bindingResult != null && conversionService != null) {\n\t\t\tthis.bindingResult.initConversion(conversionService);\n\t\t}\n\t}\n\n\t/**\n\t * Return the associated ConversionService, if any.\n\t */\n\t@Nullable\n\tpublic ConversionService getConversionService() {\n\t\treturn this.conversionService;\n\t}\n\n\t/**\n\t * Add a custom formatter, applying it to all fields matching the\n\t * {@link Formatter}-declared type.\n\t * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.\n\t * @param formatter the formatter to add, generically declared for a specific type\n\t * @since 4.2\n\t * @see #registerCustomEditor(Class, PropertyEditor)\n\t */\n\tpublic void addCustomFormatter(Formatter<?> formatter) {\n\t\tFormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);\n\t\tgetPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter);\n\t}\n\n\t/**\n\t * Add a custom formatter for the field type specified in {@link Formatter} class,\n\t * applying it to the specified fields only, if any, or otherwise to all fields.\n\t * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.\n\t * @param formatter the formatter to add, generically declared for a specific type\n\t * @param fields the fields to apply the formatter to, or none if to be applied to all\n\t * @since 4.2\n\t * @see #registerCustomEditor(Class, String, PropertyEditor)\n\t */\n\tpublic void addCustomFormatter(Formatter<?> formatter, String... fields) {\n\t\tFormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);\n\t\tClass<?> fieldType = adapter.getFieldType();\n\t\tif (ObjectUtils.isEmpty(fields)) {\n\t\t\tgetPropertyEditorRegistry().registerCustomEditor(fieldType, adapter);\n\t\t}\n\t\telse {\n\t\t\tfor (String field : fields) {\n\t\t\t\tgetPropertyEditorRegistry().registerCustomEditor(fieldType, field, adapter);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Add a custom formatter, applying it to the specified field types only, if any,\n\t * or otherwise to all fields matching the {@link Formatter}-declared type.\n\t * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.\n\t * @param formatter the formatter to add (does not need to generically declare a\n\t * field type if field types are explicitly specified as parameters)\n\t * @param fieldTypes the field types to apply the formatter to, or none if to be\n\t * derived from the given {@link Formatter} implementation class\n\t * @since 4.2\n\t * @see #registerCustomEditor(Class, PropertyEditor)\n\t */\n\tpublic void addCustomFormatter(Formatter<?> formatter, Class<?>... fieldTypes) {\n\t\tFormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);\n\t\tif (ObjectUtils.isEmpty(fieldTypes)) {\n\t\t\tgetPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter);\n\t\t}\n\t\telse {\n\t\t\tfor (Class<?> fieldType : fieldTypes) {\n\t\t\t\tgetPropertyEditorRegistry().registerCustomEditor(fieldType, adapter);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor) {\n\t\tgetPropertyEditorRegistry().registerCustomEditor(requiredType, propertyEditor);\n\t}\n\n\t@Override\n\tpublic void registerCustomEditor(@Nullable Class<?> requiredType, @Nullable String field, PropertyEditor propertyEditor) {\n\t\tgetPropertyEditorRegistry().registerCustomEditor(requiredType, field, propertyEditor);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic PropertyEditor findCustomEditor(@Nullable Class<?> requiredType, @Nullable String propertyPath) {\n\t\treturn getPropertyEditorRegistry().findCustomEditor(requiredType, propertyPath);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType) throws TypeMismatchException {\n\t\treturn getTypeConverter().convertIfNecessary(value, requiredType);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable MethodParameter methodParam) throws TypeMismatchException {\n\n\t\treturn getTypeConverter().convertIfNecessary(value, requiredType, methodParam);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field)\n\t\t\tthrows TypeMismatchException {\n\n\t\treturn getTypeConverter().convertIfNecessary(value, requiredType, field);\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable TypeDescriptor typeDescriptor) throws TypeMismatchException {\n\n\t\treturn getTypeConverter().convertIfNecessary(value, requiredType, typeDescriptor);\n\t}\n\n\n\t/**\n\t * Bind the given property values to this binder's target.\n\t * <p>This call can create field errors, representing basic binding\n\t * errors like a required field (code \"required\"), or type mismatch\n\t * between value and bean property (code \"typeMismatch\").\n\t * <p>Note that the given PropertyValues should be a throwaway instance:\n\t * For efficiency, it will be modified to just contain allowed fields if it\n\t * implements the MutablePropertyValues interface; else, an internal mutable\n\t * copy will be created for this purpose. Pass in a copy of the PropertyValues\n\t * if you want your original instance to stay unmodified in any case.\n\t * @param pvs property values to bind\n\t * @see #doBind(org.springframework.beans.MutablePropertyValues)\n\t */\n\tpublic void bind(PropertyValues pvs) {\n\t\tMutablePropertyValues mpvs = (pvs instanceof MutablePropertyValues ?\n\t\t\t\t(MutablePropertyValues) pvs : new MutablePropertyValues(pvs));\n\t\tdoBind(mpvs);\n\t}\n\n\t/**\n\t * Actual implementation of the binding process, working with the\n\t * passed-in MutablePropertyValues instance.\n\t * @param mpvs the property values to bind,\n\t * as MutablePropertyValues instance\n\t * @see #checkAllowedFields\n\t * @see #checkRequiredFields\n\t * @see #applyPropertyValues\n\t */\n\tprotected void doBind(MutablePropertyValues mpvs) {\n\t\tcheckAllowedFields(mpvs);\n\t\tcheckRequiredFields(mpvs);\n\t\tapplyPropertyValues(mpvs);\n\t}\n\n\t/**\n\t * Check the given property values against the allowed fields,\n\t * removing values for fields that are not allowed.\n\t * @param mpvs the property values to be bound (can be modified)\n\t * @see #getAllowedFields\n\t * @see #isAllowed(String)\n\t */\n\tprotected void checkAllowedFields(MutablePropertyValues mpvs) {\n\t\tPropertyValue[] pvs = mpvs.getPropertyValues();\n\t\tfor (PropertyValue pv : pvs) {\n\t\t\tString field = PropertyAccessorUtils.canonicalPropertyName(pv.getName());\n\t\t\tif (!isAllowed(field)) {\n\t\t\t\tmpvs.removePropertyValue(pv);\n\t\t\t\tgetBindingResult().recordSuppressedField(field);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Field [\" + field + \"] has been removed from PropertyValues \" +\n\t\t\t\t\t\t\t\"and will not be bound, because it has not been found in the list of allowed fields\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Determine if the given field is allowed for binding.\n\t * <p>Invoked for each passed-in property value.\n\t * <p>Checks for {@code \"xxx*\"}, {@code \"*xxx\"}, {@code \"*xxx*\"}, and\n\t * {@code \"xxx*yyy\"} matches (with an arbitrary number of pattern parts), as\n\t * well as direct equality, in the configured lists of allowed field patterns\n\t * and disallowed field patterns.\n\t * <p>Matching against allowed field patterns is case-sensitive; whereas,\n\t * matching against disallowed field patterns is case-insensitive.\n\t * <p>A field matching a disallowed pattern will not be accepted even if it\n\t * also happens to match a pattern in the allowed list.\n\t * <p>Can be overridden in subclasses, but care must be taken to honor the\n\t * aforementioned contract.\n\t * @param field the field to check\n\t * @return {@code true} if the field is allowed\n\t * @see #setAllowedFields\n\t * @see #setDisallowedFields\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */\n\tprotected boolean isAllowed(String field) {\n\t\tString[] allowed = getAllowedFields();\n\t\tString[] disallowed = getDisallowedFields();\n\t\treturn ((ObjectUtils.isEmpty(allowed) || PatternMatchUtils.simpleMatch(allowed, field)) &&\n\t\t\t\t(ObjectUtils.isEmpty(disallowed) || !PatternMatchUtils.simpleMatch(disallowed, field.toLowerCase())));\n\t}\n\n\t/**\n\t * Check the given property values against the required fields,\n\t * generating missing field errors where appropriate.\n\t * @param mpvs the property values to be bound (can be modified)\n\t * @see #getRequiredFields\n\t * @see #getBindingErrorProcessor\n\t * @see BindingErrorProcessor#processMissingFieldError\n\t */\n\tprotected void checkRequiredFields(MutablePropertyValues mpvs) {\n\t\tString[] requiredFields = getRequiredFields();\n\t\tif (!ObjectUtils.isEmpty(requiredFields)) {\n\t\t\tMap<String, PropertyValue> propertyValues = new HashMap<>();\n\t\t\tPropertyValue[] pvs = mpvs.getPropertyValues();\n\t\t\tfor (PropertyValue pv : pvs) {\n\t\t\t\tString canonicalName = PropertyAccessorUtils.canonicalPropertyName(pv.getName());\n\t\t\t\tpropertyValues.put(canonicalName, pv);\n\t\t\t}\n\t\t\tfor (String field : requiredFields) {\n\t\t\t\tPropertyValue pv = propertyValues.get(field);\n\t\t\t\tboolean empty = (pv == null || pv.getValue() == null);\n\t\t\t\tif (!empty) {\n\t\t\t\t\tif (pv.getValue() instanceof String) {\n\t\t\t\t\t\tempty = !StringUtils.hasText((String) pv.getValue());\n\t\t\t\t\t}\n\t\t\t\t\telse if (pv.getValue() instanceof String[] values) {\n\t\t\t\t\t\tempty = (values.length == 0 || !StringUtils.hasText(values[0]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (empty) {\n\t\t\t\t\t// Use bind error processor to create FieldError.\n\t\t\t\t\tgetBindingErrorProcessor().processMissingFieldError(field, getInternalBindingResult());\n\t\t\t\t\t// Remove property from property values to bind:\n\t\t\t\t\t// It has already caused a field error with a rejected value.\n\t\t\t\t\tif (pv != null) {\n\t\t\t\t\t\tmpvs.removePropertyValue(pv);\n\t\t\t\t\t\tpropertyValues.remove(field);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Apply given property values to the target object.\n\t * <p>Default implementation applies all the supplied property\n\t * values as bean property values. By default, unknown fields will\n\t * be ignored.\n\t * @param mpvs the property values to be bound (can be modified)\n\t * @see #getTarget\n\t * @see #getPropertyAccessor\n\t * @see #isIgnoreUnknownFields\n\t * @see #getBindingErrorProcessor\n\t * @see BindingErrorProcessor#processPropertyAccessException\n\t */\n\tprotected void applyPropertyValues(MutablePropertyValues mpvs) {\n\t\ttry {\n\t\t\t// Bind request parameters onto target object.\n\t\t\tgetPropertyAccessor().setPropertyValues(mpvs, isIgnoreUnknownFields(), isIgnoreInvalidFields());\n\t\t}\n\t\tcatch (PropertyBatchUpdateException ex) {\n\t\t\t// Use bind error processor to create FieldErrors.\n\t\t\tfor (PropertyAccessException pae : ex.getPropertyAccessExceptions()) {\n\t\t\t\tgetBindingErrorProcessor().processPropertyAccessException(pae, getInternalBindingResult());\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Invoke the specified Validators, if any.\n\t * @see #setValidator(Validator)\n\t * @see #getBindingResult()\n\t */\n\tpublic void validate() {\n\t\tObject target = getTarget();\n\t\tAssert.state(target != null, \"No target to validate\");\n\t\tBindingResult bindingResult = getBindingResult();\n\t\t// Call each validator with the same binding result\n\t\tfor (Validator validator : getValidators()) {\n\t\t\tvalidator.validate(target, bindingResult);\n\t\t}\n\t}\n\n\t/**\n\t * Invoke the specified Validators, if any, with the given validation hints.\n\t * <p>Note: Validation hints may get ignored by the actual target Validator.\n\t * @param validationHints one or more hint objects to be passed to a {@link SmartValidator}\n\t * @since 3.1\n\t * @see #setValidator(Validator)\n\t * @see SmartValidator#validate(Object, Errors, Object...)\n\t */\n\tpublic void validate(Object... validationHints) {\n\t\tObject target = getTarget();\n\t\tAssert.state(target != null, \"No target to validate\");\n\t\tBindingResult bindingResult = getBindingResult();\n\t\t// Call each validator with the same binding result\n\t\tfor (Validator validator : getValidators()) {\n\t\t\tif (!ObjectUtils.isEmpty(validationHints) && validator instanceof SmartValidator) {\n\t\t\t\t((SmartValidator) validator).validate(target, bindingResult, validationHints);\n\t\t\t}\n\t\t\telse if (validator != null) {\n\t\t\t\tvalidator.validate(target, bindingResult);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Close this DataBinder, which may result in throwing\n\t * a BindException if it encountered any errors.\n\t * @return the model Map, containing target object and Errors instance\n\t * @throws BindException if there were any errors in the bind operation\n\t * @see BindingResult#getModel()\n\t */\n\tpublic Map<?, ?> close() throws BindException {\n\t\tif (getBindingResult().hasErrors()) {\n\t\t\tthrow new BindException(getBindingResult());\n\t\t}\n\t\treturn getBindingResult().getModel();\n\t}\n\n}"
  },
  "org.springframework.validation.DataBinder#addCustomFormatter(formatter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a custom formatter, applying it to all fields matching the\n\t * {@link Formatter}-declared type.\n\t * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.\n\t * @param formatter the formatter to add, generically declared for a specific type\n\t * @since 4.2\n\t * @see #registerCustomEditor(Class, PropertyEditor)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "formatter"
    ],
    "position": {
      "column": 1,
      "line": 652
    },
    "return": "void",
    "signature": "public void addCustomFormatter(Formatter<?> formatter)",
    "source_code": "\tpublic void addCustomFormatter(Formatter<?> formatter) {\n\t\tFormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);\n\t\tgetPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter);\n\t}"
  },
  "org.springframework.validation.DataBinder#addCustomFormatter(formatter,fieldTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a custom formatter, applying it to the specified field types only, if any,\n\t * or otherwise to all fields matching the {@link Formatter}-declared type.\n\t * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.\n\t * @param formatter the formatter to add (does not need to generically declare a\n\t * field type if field types are explicitly specified as parameters)\n\t * @param fieldTypes the field types to apply the formatter to, or none if to be\n\t * derived from the given {@link Formatter} implementation class\n\t * @since 4.2\n\t * @see #registerCustomEditor(Class, PropertyEditor)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "formatter",
      "fieldTypes"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "void",
    "signature": "public void addCustomFormatter(Formatter<?> formatter, Class<?>... fieldTypes)",
    "source_code": "\tpublic void addCustomFormatter(Formatter<?> formatter, Class<?>... fieldTypes) {\n\t\tFormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);\n\t\tif (ObjectUtils.isEmpty(fieldTypes)) {\n\t\t\tgetPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter);\n\t\t}\n\t\telse {\n\t\t\tfor (Class<?> fieldType : fieldTypes) {\n\t\t\t\tgetPropertyEditorRegistry().registerCustomEditor(fieldType, adapter);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.DataBinder#addCustomFormatter(formatter,fields)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a custom formatter for the field type specified in {@link Formatter} class,\n\t * applying it to the specified fields only, if any, or otherwise to all fields.\n\t * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.\n\t * @param formatter the formatter to add, generically declared for a specific type\n\t * @param fields the fields to apply the formatter to, or none if to be applied to all\n\t * @since 4.2\n\t * @see #registerCustomEditor(Class, String, PropertyEditor)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "formatter",
      "fields"
    ],
    "position": {
      "column": 1,
      "line": 666
    },
    "return": "void",
    "signature": "public void addCustomFormatter(Formatter<?> formatter, String... fields)",
    "source_code": "\tpublic void addCustomFormatter(Formatter<?> formatter, String... fields) {\n\t\tFormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);\n\t\tClass<?> fieldType = adapter.getFieldType();\n\t\tif (ObjectUtils.isEmpty(fields)) {\n\t\t\tgetPropertyEditorRegistry().registerCustomEditor(fieldType, adapter);\n\t\t}\n\t\telse {\n\t\t\tfor (String field : fields) {\n\t\t\t\tgetPropertyEditorRegistry().registerCustomEditor(fieldType, field, adapter);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.DataBinder#addValidators(validators)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add Validators to apply after each binding step.\n\t * @see #setValidator(Validator)\n\t * @see #replaceValidators(Validator...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "validators"
    ],
    "position": {
      "column": 1,
      "line": 588
    },
    "return": "void",
    "signature": "public void addValidators(Validator... validators)",
    "source_code": "\tpublic void addValidators(Validator... validators) {\n\t\tassertValidators(validators);\n\t\tthis.validators.addAll(Arrays.asList(validators));\n\t}"
  },
  "org.springframework.validation.DataBinder#applyPropertyValues(mpvs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply given property values to the target object.\n\t * <p>Default implementation applies all the supplied property\n\t * values as bean property values. By default, unknown fields will\n\t * be ignored.\n\t * @param mpvs the property values to be bound (can be modified)\n\t * @see #getTarget\n\t * @see #getPropertyAccessor\n\t * @see #isIgnoreUnknownFields\n\t * @see #getBindingErrorProcessor\n\t * @see BindingErrorProcessor#processPropertyAccessException\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mpvs"
    ],
    "position": {
      "column": 1,
      "line": 885
    },
    "return": "void",
    "signature": "protected void applyPropertyValues(MutablePropertyValues mpvs)",
    "source_code": "\tprotected void applyPropertyValues(MutablePropertyValues mpvs) {\n\t\ttry {\n\t\t\t// Bind request parameters onto target object.\n\t\t\tgetPropertyAccessor().setPropertyValues(mpvs, isIgnoreUnknownFields(), isIgnoreInvalidFields());\n\t\t}\n\t\tcatch (PropertyBatchUpdateException ex) {\n\t\t\t// Use bind error processor to create FieldErrors.\n\t\t\tfor (PropertyAccessException pae : ex.getPropertyAccessExceptions()) {\n\t\t\t\tgetBindingErrorProcessor().processPropertyAccessException(pae, getInternalBindingResult());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.DataBinder#bind(pvs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Bind the given property values to this binder's target.\n\t * <p>This call can create field errors, representing basic binding\n\t * errors like a required field (code \"required\"), or type mismatch\n\t * between value and bean property (code \"typeMismatch\").\n\t * <p>Note that the given PropertyValues should be a throwaway instance:\n\t * For efficiency, it will be modified to just contain allowed fields if it\n\t * implements the MutablePropertyValues interface; else, an internal mutable\n\t * copy will be created for this purpose. Pass in a copy of the PropertyValues\n\t * if you want your original instance to stay unmodified in any case.\n\t * @param pvs property values to bind\n\t * @see #doBind(org.springframework.beans.MutablePropertyValues)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 762
    },
    "return": "void",
    "signature": "public void bind(PropertyValues pvs)",
    "source_code": "\tpublic void bind(PropertyValues pvs) {\n\t\tMutablePropertyValues mpvs = (pvs instanceof MutablePropertyValues ?\n\t\t\t\t(MutablePropertyValues) pvs : new MutablePropertyValues(pvs));\n\t\tdoBind(mpvs);\n\t}"
  },
  "org.springframework.validation.DataBinder#checkAllowedFields(mpvs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check the given property values against the allowed fields,\n\t * removing values for fields that are not allowed.\n\t * @param mpvs the property values to be bound (can be modified)\n\t * @see #getAllowedFields\n\t * @see #isAllowed(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mpvs"
    ],
    "position": {
      "column": 1,
      "line": 790
    },
    "return": "void",
    "signature": "protected void checkAllowedFields(MutablePropertyValues mpvs)",
    "source_code": "\tprotected void checkAllowedFields(MutablePropertyValues mpvs) {\n\t\tPropertyValue[] pvs = mpvs.getPropertyValues();\n\t\tfor (PropertyValue pv : pvs) {\n\t\t\tString field = PropertyAccessorUtils.canonicalPropertyName(pv.getName());\n\t\t\tif (!isAllowed(field)) {\n\t\t\t\tmpvs.removePropertyValue(pv);\n\t\t\t\tgetBindingResult().recordSuppressedField(field);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Field [\" + field + \"] has been removed from PropertyValues \" +\n\t\t\t\t\t\t\t\"and will not be bound, because it has not been found in the list of allowed fields\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.DataBinder#checkRequiredFields(mpvs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check the given property values against the required fields,\n\t * generating missing field errors where appropriate.\n\t * @param mpvs the property values to be bound (can be modified)\n\t * @see #getRequiredFields\n\t * @see #getBindingErrorProcessor\n\t * @see BindingErrorProcessor#processMissingFieldError\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mpvs"
    ],
    "position": {
      "column": 1,
      "line": 839
    },
    "return": "void",
    "signature": "protected void checkRequiredFields(MutablePropertyValues mpvs)",
    "source_code": "\tprotected void checkRequiredFields(MutablePropertyValues mpvs) {\n\t\tString[] requiredFields = getRequiredFields();\n\t\tif (!ObjectUtils.isEmpty(requiredFields)) {\n\t\t\tMap<String, PropertyValue> propertyValues = new HashMap<>();\n\t\t\tPropertyValue[] pvs = mpvs.getPropertyValues();\n\t\t\tfor (PropertyValue pv : pvs) {\n\t\t\t\tString canonicalName = PropertyAccessorUtils.canonicalPropertyName(pv.getName());\n\t\t\t\tpropertyValues.put(canonicalName, pv);\n\t\t\t}\n\t\t\tfor (String field : requiredFields) {\n\t\t\t\tPropertyValue pv = propertyValues.get(field);\n\t\t\t\tboolean empty = (pv == null || pv.getValue() == null);\n\t\t\t\tif (!empty) {\n\t\t\t\t\tif (pv.getValue() instanceof String) {\n\t\t\t\t\t\tempty = !StringUtils.hasText((String) pv.getValue());\n\t\t\t\t\t}\n\t\t\t\t\telse if (pv.getValue() instanceof String[] values) {\n\t\t\t\t\t\tempty = (values.length == 0 || !StringUtils.hasText(values[0]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (empty) {\n\t\t\t\t\t// Use bind error processor to create FieldError.\n\t\t\t\t\tgetBindingErrorProcessor().processMissingFieldError(field, getInternalBindingResult());\n\t\t\t\t\t// Remove property from property values to bind:\n\t\t\t\t\t// It has already caused a field error with a rejected value.\n\t\t\t\t\tif (pv != null) {\n\t\t\t\t\t\tmpvs.removePropertyValue(pv);\n\t\t\t\t\t\tpropertyValues.remove(field);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.DataBinder#convertIfNecessary(value,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 720
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType) throws TypeMismatchException {\n\t\treturn getTypeConverter().convertIfNecessary(value, requiredType);\n\t}"
  },
  "org.springframework.validation.DataBinder#convertIfNecessary(value,requiredType,field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 734
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field)"
  },
  "org.springframework.validation.DataBinder#convertIfNecessary(value,requiredType,methodParam)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "methodParam"
    ],
    "position": {
      "column": 1,
      "line": 726
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable MethodParameter methodParam)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,"
  },
  "org.springframework.validation.DataBinder#convertIfNecessary(value,requiredType,typeDescriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "typeDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 742
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable TypeDescriptor typeDescriptor)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,"
  },
  "org.springframework.validation.DataBinder#createBeanPropertyBindingResult()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the {@link AbstractPropertyBindingResult} instance using standard\n\t * JavaBean property access.\n\t * @since 4.2.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "AbstractPropertyBindingResult",
    "signature": "protected AbstractPropertyBindingResult createBeanPropertyBindingResult()",
    "source_code": "\tprotected AbstractPropertyBindingResult createBeanPropertyBindingResult() {\n\t\tBeanPropertyBindingResult result = new BeanPropertyBindingResult(getTarget(),\n\t\t\t\tgetObjectName(), isAutoGrowNestedPaths(), getAutoGrowCollectionLimit());\n\n\t\tif (this.conversionService != null) {\n\t\t\tresult.initConversion(this.conversionService);\n\t\t}\n\t\tif (this.messageCodesResolver != null) {\n\t\t\tresult.setMessageCodesResolver(this.messageCodesResolver);\n\t\t}\n\n\t\treturn result;\n\t}"
  },
  "org.springframework.validation.DataBinder#createDirectFieldBindingResult()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the {@link AbstractPropertyBindingResult} instance using direct\n\t * field access.\n\t * @since 4.2.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "AbstractPropertyBindingResult",
    "signature": "protected AbstractPropertyBindingResult createDirectFieldBindingResult()",
    "source_code": "\tprotected AbstractPropertyBindingResult createDirectFieldBindingResult() {\n\t\tDirectFieldBindingResult result = new DirectFieldBindingResult(getTarget(),\n\t\t\t\tgetObjectName(), isAutoGrowNestedPaths());\n\n\t\tif (this.conversionService != null) {\n\t\t\tresult.initConversion(this.conversionService);\n\t\t}\n\t\tif (this.messageCodesResolver != null) {\n\t\t\tresult.setMessageCodesResolver(this.messageCodesResolver);\n\t\t}\n\n\t\treturn result;\n\t}"
  },
  "org.springframework.validation.DataBinder#doBind(mpvs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actual implementation of the binding process, working with the\n\t * passed-in MutablePropertyValues instance.\n\t * @param mpvs the property values to bind,\n\t * as MutablePropertyValues instance\n\t * @see #checkAllowedFields\n\t * @see #checkRequiredFields\n\t * @see #applyPropertyValues\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mpvs"
    ],
    "position": {
      "column": 1,
      "line": 777
    },
    "return": "void",
    "signature": "protected void doBind(MutablePropertyValues mpvs)",
    "source_code": "\tprotected void doBind(MutablePropertyValues mpvs) {\n\t\tcheckAllowedFields(mpvs);\n\t\tcheckRequiredFields(mpvs);\n\t\tapplyPropertyValues(mpvs);\n\t}"
  },
  "org.springframework.validation.DataBinder#findCustomEditor(requiredType,propertyPath)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "propertyPath"
    ],
    "position": {
      "column": 1,
      "line": 714
    },
    "return": "PropertyEditor",
    "signature": "public PropertyEditor findCustomEditor(@Nullable Class<?> requiredType, @Nullable String propertyPath)",
    "source_code": "\tpublic PropertyEditor findCustomEditor(@Nullable Class<?> requiredType, @Nullable String propertyPath) {\n\t\treturn getPropertyEditorRegistry().findCustomEditor(requiredType, propertyPath);\n\t}"
  },
  "org.springframework.validation.DataBinder#getAllowedFields()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the field patterns that should be allowed for binding.\n\t * @return array of allowed field patterns\n\t * @see #setAllowedFields(String...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 452
    },
    "return": "String[]",
    "signature": "public String[] getAllowedFields()",
    "source_code": "\tpublic String[] getAllowedFields() {\n\t\treturn this.allowedFields;\n\t}"
  },
  "org.springframework.validation.DataBinder#getAutoGrowCollectionLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the current limit for array and collection auto-growing.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "int",
    "signature": "public int getAutoGrowCollectionLimit()",
    "source_code": "\tpublic int getAutoGrowCollectionLimit() {\n\t\treturn this.autoGrowCollectionLimit;\n\t}"
  },
  "org.springframework.validation.DataBinder#getBindingErrorProcessor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the strategy for processing binding errors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 557
    },
    "return": "BindingErrorProcessor",
    "signature": "public BindingErrorProcessor getBindingErrorProcessor()",
    "source_code": "\tpublic BindingErrorProcessor getBindingErrorProcessor() {\n\t\treturn this.bindingErrorProcessor;\n\t}"
  },
  "org.springframework.validation.DataBinder#getBindingResult()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the BindingResult instance created by this DataBinder.\n\t * This allows for convenient access to the binding results after\n\t * a bind operation.\n\t * @return the BindingResult instance, to be treated as BindingResult\n\t * or as Errors instance (Errors is a super-interface of BindingResult)\n\t * @see Errors\n\t * @see #bind\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "BindingResult",
    "signature": "public BindingResult getBindingResult()",
    "source_code": "\tpublic BindingResult getBindingResult() {\n\t\treturn getInternalBindingResult();\n\t}"
  },
  "org.springframework.validation.DataBinder#getConversionService()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the associated ConversionService, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 640
    },
    "return": "ConversionService",
    "signature": "public ConversionService getConversionService()",
    "source_code": "\tpublic ConversionService getConversionService() {\n\t\treturn this.conversionService;\n\t}"
  },
  "org.springframework.validation.DataBinder#getDisallowedFields()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the field patterns that should <i>not</i> be allowed for binding.\n\t * @return array of disallowed field patterns\n\t * @see #setDisallowedFields(String...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 497
    },
    "return": "String[]",
    "signature": "public String[] getDisallowedFields()",
    "source_code": "\tpublic String[] getDisallowedFields() {\n\t\treturn this.disallowedFields;\n\t}"
  },
  "org.springframework.validation.DataBinder#getInternalBindingResult()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the internal BindingResult held by this DataBinder,\n\t * as an AbstractPropertyBindingResult.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "AbstractPropertyBindingResult",
    "signature": "protected AbstractPropertyBindingResult getInternalBindingResult()",
    "source_code": "\tprotected AbstractPropertyBindingResult getInternalBindingResult() {\n\t\tif (this.bindingResult == null) {\n\t\t\tthis.bindingResult = (this.directFieldAccess ?\n\t\t\t\t\tcreateDirectFieldBindingResult(): createBeanPropertyBindingResult());\n\t\t}\n\t\treturn this.bindingResult;\n\t}"
  },
  "org.springframework.validation.DataBinder#getObjectName()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the name of the bound object.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "String",
    "signature": "public String getObjectName()",
    "source_code": "\tpublic String getObjectName() {\n\t\treturn this.objectName;\n\t}"
  },
  "org.springframework.validation.DataBinder#getPropertyAccessor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the underlying PropertyAccessor of this binder's BindingResult.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "ConfigurablePropertyAccessor",
    "signature": "protected ConfigurablePropertyAccessor getPropertyAccessor()",
    "source_code": "\tprotected ConfigurablePropertyAccessor getPropertyAccessor() {\n\t\treturn getInternalBindingResult().getPropertyAccessor();\n\t}"
  },
  "org.springframework.validation.DataBinder#getPropertyEditorRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the underlying TypeConverter of this binder's BindingResult.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "PropertyEditorRegistry",
    "signature": "protected PropertyEditorRegistry getPropertyEditorRegistry()",
    "source_code": "\tprotected PropertyEditorRegistry getPropertyEditorRegistry() {\n\t\tif (getTarget() != null) {\n\t\t\treturn getInternalBindingResult().getPropertyAccessor();\n\t\t}\n\t\telse {\n\t\t\treturn getSimpleTypeConverter();\n\t\t}\n\t}"
  },
  "org.springframework.validation.DataBinder#getRequiredFields()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the fields that are required for each binding process.\n\t * @return array of field names\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 524
    },
    "return": "String[]",
    "signature": "public String[] getRequiredFields()",
    "source_code": "\tpublic String[] getRequiredFields() {\n\t\treturn this.requiredFields;\n\t}"
  },
  "org.springframework.validation.DataBinder#getSimpleTypeConverter()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return this binder's underlying SimpleTypeConverter.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "SimpleTypeConverter",
    "signature": "protected SimpleTypeConverter getSimpleTypeConverter()",
    "source_code": "\tprotected SimpleTypeConverter getSimpleTypeConverter() {\n\t\tif (this.typeConverter == null) {\n\t\t\tthis.typeConverter = new SimpleTypeConverter();\n\t\t\tif (this.conversionService != null) {\n\t\t\t\tthis.typeConverter.setConversionService(this.conversionService);\n\t\t\t}\n\t\t}\n\t\treturn this.typeConverter;\n\t}"
  },
  "org.springframework.validation.DataBinder#getTarget()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the wrapped target object.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "Object",
    "signature": "public Object getTarget()",
    "source_code": "\tpublic Object getTarget() {\n\t\treturn this.target;\n\t}"
  },
  "org.springframework.validation.DataBinder#getTypeConverter()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the underlying TypeConverter of this binder's BindingResult.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "TypeConverter",
    "signature": "protected TypeConverter getTypeConverter()",
    "source_code": "\tprotected TypeConverter getTypeConverter() {\n\t\tif (getTarget() != null) {\n\t\t\treturn getInternalBindingResult().getPropertyAccessor();\n\t\t}\n\t\telse {\n\t\t\treturn getSimpleTypeConverter();\n\t\t}\n\t}"
  },
  "org.springframework.validation.DataBinder#getValidator()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the primary Validator to apply after each binding step, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 608
    },
    "return": "Validator",
    "signature": "public Validator getValidator()",
    "source_code": "\tpublic Validator getValidator() {\n\t\treturn (!this.validators.isEmpty() ? this.validators.get(0) : null);\n\t}"
  },
  "org.springframework.validation.DataBinder#getValidators()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Validators to apply after data binding.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 615
    },
    "return": "List<Validator>",
    "signature": "public List<Validator> getValidators()",
    "source_code": "\tpublic List<Validator> getValidators() {\n\t\treturn Collections.unmodifiableList(this.validators);\n\t}"
  },
  "org.springframework.validation.DataBinder#initBeanPropertyAccess()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize standard JavaBean property access for this DataBinder.\n\t * <p>This is the default; an explicit call just leads to eager initialization.\n\t * @see #initDirectFieldAccess()\n\t * @see #createBeanPropertyBindingResult()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void initBeanPropertyAccess()",
    "source_code": "\tpublic void initBeanPropertyAccess() {\n\t\tAssert.state(this.bindingResult == null,\n\t\t\t\t\"DataBinder is already initialized - call initBeanPropertyAccess before other configuration methods\");\n\t\tthis.directFieldAccess = false;\n\t}"
  },
  "org.springframework.validation.DataBinder#initDirectFieldAccess()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize direct field access for this DataBinder,\n\t * as alternative to the default bean property access.\n\t * @see #initBeanPropertyAccess()\n\t * @see #createDirectFieldBindingResult()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 285
    },
    "return": "void",
    "signature": "public void initDirectFieldAccess()",
    "source_code": "\tpublic void initDirectFieldAccess() {\n\t\tAssert.state(this.bindingResult == null,\n\t\t\t\t\"DataBinder is already initialized - call initDirectFieldAccess before other configuration methods\");\n\t\tthis.directFieldAccess = true;\n\t}"
  },
  "org.springframework.validation.DataBinder#isAllowed(field)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the given field is allowed for binding.\n\t * <p>Invoked for each passed-in property value.\n\t * <p>Checks for {@code \"xxx*\"}, {@code \"*xxx\"}, {@code \"*xxx*\"}, and\n\t * {@code \"xxx*yyy\"} matches (with an arbitrary number of pattern parts), as\n\t * well as direct equality, in the configured lists of allowed field patterns\n\t * and disallowed field patterns.\n\t * <p>Matching against allowed field patterns is case-sensitive; whereas,\n\t * matching against disallowed field patterns is case-insensitive.\n\t * <p>A field matching a disallowed pattern will not be accepted even if it\n\t * also happens to match a pattern in the allowed list.\n\t * <p>Can be overridden in subclasses, but care must be taken to honor the\n\t * aforementioned contract.\n\t * @param field the field to check\n\t * @return {@code true} if the field is allowed\n\t * @see #setAllowedFields\n\t * @see #setDisallowedFields\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 824
    },
    "return": "boolean",
    "signature": "protected boolean isAllowed(String field)",
    "source_code": "\tprotected boolean isAllowed(String field) {\n\t\tString[] allowed = getAllowedFields();\n\t\tString[] disallowed = getDisallowedFields();\n\t\treturn ((ObjectUtils.isEmpty(allowed) || PatternMatchUtils.simpleMatch(allowed, field)) &&\n\t\t\t\t(ObjectUtils.isEmpty(disallowed) || !PatternMatchUtils.simpleMatch(disallowed, field.toLowerCase())));\n\t}"
  },
  "org.springframework.validation.DataBinder#isAutoGrowNestedPaths()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether \"auto-growing\" of nested paths has been activated.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "boolean",
    "signature": "public boolean isAutoGrowNestedPaths()",
    "source_code": "\tpublic boolean isAutoGrowNestedPaths() {\n\t\treturn this.autoGrowNestedPaths;\n\t}"
  },
  "org.springframework.validation.DataBinder#isIgnoreInvalidFields()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to ignore invalid fields when binding.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 419
    },
    "return": "boolean",
    "signature": "public boolean isIgnoreInvalidFields()",
    "source_code": "\tpublic boolean isIgnoreInvalidFields() {\n\t\treturn this.ignoreInvalidFields;\n\t}"
  },
  "org.springframework.validation.DataBinder#isIgnoreUnknownFields()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to ignore unknown fields when binding.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "boolean",
    "signature": "public boolean isIgnoreUnknownFields()",
    "source_code": "\tpublic boolean isIgnoreUnknownFields() {\n\t\treturn this.ignoreUnknownFields;\n\t}"
  },
  "org.springframework.validation.DataBinder#registerCustomEditor(requiredType,field,propertyEditor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "field",
      "propertyEditor"
    ],
    "position": {
      "column": 1,
      "line": 708
    },
    "return": "void",
    "signature": "public void registerCustomEditor(@Nullable Class<?> requiredType, @Nullable String field, PropertyEditor propertyEditor)",
    "source_code": "\tpublic void registerCustomEditor(@Nullable Class<?> requiredType, @Nullable String field, PropertyEditor propertyEditor) {\n\t\tgetPropertyEditorRegistry().registerCustomEditor(requiredType, field, propertyEditor);\n\t}"
  },
  "org.springframework.validation.DataBinder#registerCustomEditor(requiredType,propertyEditor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "propertyEditor"
    ],
    "position": {
      "column": 1,
      "line": 703
    },
    "return": "void",
    "signature": "public void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor)",
    "source_code": "\tpublic void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor) {\n\t\tgetPropertyEditorRegistry().registerCustomEditor(requiredType, propertyEditor);\n\t}"
  },
  "org.springframework.validation.DataBinder#replaceValidators(validators)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace the Validators to apply after each binding step.\n\t * @see #setValidator(Validator)\n\t * @see #addValidators(Validator...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "validators"
    ],
    "position": {
      "column": 1,
      "line": 598
    },
    "return": "void",
    "signature": "public void replaceValidators(Validator... validators)",
    "source_code": "\tpublic void replaceValidators(Validator... validators) {\n\t\tassertValidators(validators);\n\t\tthis.validators.clear();\n\t\tthis.validators.addAll(Arrays.asList(validators));\n\t}"
  },
  "org.springframework.validation.DataBinder#setAllowedFields(allowedFields)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register field patterns that should be allowed for binding.\n\t * <p>Default is all fields.\n\t * <p>Restrict this for example to avoid unwanted modifications by malicious\n\t * users when binding HTTP request parameters.\n\t * <p>Supports {@code \"xxx*\"}, {@code \"*xxx\"}, {@code \"*xxx*\"}, and\n\t * {@code \"xxx*yyy\"} matches (with an arbitrary number of pattern parts), as\n\t * well as direct equality.\n\t * <p>The default implementation of this method stores allowed field patterns\n\t * in {@linkplain PropertyAccessorUtils#canonicalPropertyName(String) canonical}\n\t * form. Subclasses which override this method must therefore take this into\n\t * account.\n\t * <p>More sophisticated matching can be implemented by overriding the\n\t * {@link #isAllowed} method.\n\t * <p>Alternatively, specify a list of <i>disallowed</i> field patterns.\n\t * @param allowedFields array of allowed field patterns\n\t * @see #setDisallowedFields\n\t * @see #isAllowed(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "allowedFields"
    ],
    "position": {
      "column": 1,
      "line": 442
    },
    "return": "void",
    "signature": "public void setAllowedFields(@Nullable String... allowedFields)",
    "source_code": "\tpublic void setAllowedFields(@Nullable String... allowedFields) {\n\t\tthis.allowedFields = PropertyAccessorUtils.canonicalPropertyNames(allowedFields);\n\t}"
  },
  "org.springframework.validation.DataBinder#setAutoGrowCollectionLimit(autoGrowCollectionLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the limit for array and collection auto-growing.\n\t * <p>Default is 256, preventing OutOfMemoryErrors in case of large indexes.\n\t * Raise this limit if your auto-growing needs are unusually high.\n\t * @see #initBeanPropertyAccess()\n\t * @see org.springframework.beans.BeanWrapper#setAutoGrowCollectionLimit\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "autoGrowCollectionLimit"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "void",
    "signature": "public void setAutoGrowCollectionLimit(int autoGrowCollectionLimit)",
    "source_code": "\tpublic void setAutoGrowCollectionLimit(int autoGrowCollectionLimit) {\n\t\tAssert.state(this.bindingResult == null,\n\t\t\t\t\"DataBinder is already initialized - call setAutoGrowCollectionLimit before other configuration methods\");\n\t\tthis.autoGrowCollectionLimit = autoGrowCollectionLimit;\n\t}"
  },
  "org.springframework.validation.DataBinder#setAutoGrowNestedPaths(autoGrowNestedPaths)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether this binder should attempt to \"auto-grow\" a nested path that contains a null value.\n\t * <p>If \"true\", a null path location will be populated with a default object value and traversed\n\t * instead of resulting in an exception. This flag also enables auto-growth of collection elements\n\t * when accessing an out-of-bounds index.\n\t * <p>Default is \"true\" on a standard DataBinder. Note that since Spring 4.1 this feature is supported\n\t * for bean property access (DataBinder's default mode) and field access.\n\t * @see #initBeanPropertyAccess()\n\t * @see org.springframework.beans.BeanWrapper#setAutoGrowNestedPaths\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "autoGrowNestedPaths"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "public void setAutoGrowNestedPaths(boolean autoGrowNestedPaths)",
    "source_code": "\tpublic void setAutoGrowNestedPaths(boolean autoGrowNestedPaths) {\n\t\tAssert.state(this.bindingResult == null,\n\t\t\t\t\"DataBinder is already initialized - call setAutoGrowNestedPaths before other configuration methods\");\n\t\tthis.autoGrowNestedPaths = autoGrowNestedPaths;\n\t}"
  },
  "org.springframework.validation.DataBinder#setBindingErrorProcessor(bindingErrorProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the strategy to use for processing binding errors, that is,\n\t * required field errors and {@code PropertyAccessException}s.\n\t * <p>Default is a DefaultBindingErrorProcessor.\n\t * @see DefaultBindingErrorProcessor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindingErrorProcessor"
    ],
    "position": {
      "column": 1,
      "line": 549
    },
    "return": "void",
    "signature": "public void setBindingErrorProcessor(BindingErrorProcessor bindingErrorProcessor)",
    "source_code": "\tpublic void setBindingErrorProcessor(BindingErrorProcessor bindingErrorProcessor) {\n\t\tAssert.notNull(bindingErrorProcessor, \"BindingErrorProcessor must not be null\");\n\t\tthis.bindingErrorProcessor = bindingErrorProcessor;\n\t}"
  },
  "org.springframework.validation.DataBinder#setConversionService(conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a {@link ConversionService} to use for converting\n\t * property values, as an alternative to JavaBeans PropertyEditors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 628
    },
    "return": "void",
    "signature": "public void setConversionService(@Nullable ConversionService conversionService)",
    "source_code": "\tpublic void setConversionService(@Nullable ConversionService conversionService) {\n\t\tAssert.state(this.conversionService == null, \"DataBinder is already initialized with ConversionService\");\n\t\tthis.conversionService = conversionService;\n\t\tif (this.bindingResult != null && conversionService != null) {\n\t\t\tthis.bindingResult.initConversion(conversionService);\n\t\t}\n\t}"
  },
  "org.springframework.validation.DataBinder#setDisallowedFields(disallowedFields)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register field patterns that should <i>not</i> be allowed for binding.\n\t * <p>Default is none.\n\t * <p>Mark fields as disallowed, for example to avoid unwanted\n\t * modifications by malicious users when binding HTTP request parameters.\n\t * <p>Supports {@code \"xxx*\"}, {@code \"*xxx\"}, {@code \"*xxx*\"}, and\n\t * {@code \"xxx*yyy\"} matches (with an arbitrary number of pattern parts), as\n\t * well as direct equality.\n\t * <p>The default implementation of this method stores disallowed field patterns\n\t * in {@linkplain PropertyAccessorUtils#canonicalPropertyName(String) canonical}\n\t * form. As of Spring Framework 5.2.21, the default implementation also transforms\n\t * disallowed field patterns to {@linkplain String#toLowerCase() lowercase} to\n\t * support case-insensitive pattern matching in {@link #isAllowed}. Subclasses\n\t * which override this method must therefore take both of these transformations\n\t * into account.\n\t * <p>More sophisticated matching can be implemented by overriding the\n\t * {@link #isAllowed} method.\n\t * <p>Alternatively, specify a list of <i>allowed</i> field patterns.\n\t * @param disallowedFields array of disallowed field patterns\n\t * @see #setAllowedFields\n\t * @see #isAllowed(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "disallowedFields"
    ],
    "position": {
      "column": 1,
      "line": 478
    },
    "return": "void",
    "signature": "public void setDisallowedFields(@Nullable String... disallowedFields)",
    "source_code": "\tpublic void setDisallowedFields(@Nullable String... disallowedFields) {\n\t\tif (disallowedFields == null) {\n\t\t\tthis.disallowedFields = null;\n\t\t}\n\t\telse {\n\t\t\tString[] fieldPatterns = new String[disallowedFields.length];\n\t\t\tfor (int i = 0; i < fieldPatterns.length; i++) {\n\t\t\t\tfieldPatterns[i] = PropertyAccessorUtils.canonicalPropertyName(disallowedFields[i]).toLowerCase();\n\t\t\t}\n\t\t\tthis.disallowedFields = fieldPatterns;\n\t\t}\n\t}"
  },
  "org.springframework.validation.DataBinder#setIgnoreInvalidFields(ignoreInvalidFields)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to ignore invalid fields, that is, whether to ignore bind\n\t * parameters that have corresponding fields in the target object which are\n\t * not accessible (for example because of null values in the nested path).\n\t * <p>Default is \"false\". Turn this on to ignore bind parameters for\n\t * nested objects in non-existing parts of the target object graph.\n\t * <p>Note that this setting only applies to <i>binding</i> operations\n\t * on this DataBinder, not to <i>retrieving</i> values via its\n\t * {@link #getBindingResult() BindingResult}.\n\t * @see #bind\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ignoreInvalidFields"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "void",
    "signature": "public void setIgnoreInvalidFields(boolean ignoreInvalidFields)",
    "source_code": "\tpublic void setIgnoreInvalidFields(boolean ignoreInvalidFields) {\n\t\tthis.ignoreInvalidFields = ignoreInvalidFields;\n\t}"
  },
  "org.springframework.validation.DataBinder#setIgnoreUnknownFields(ignoreUnknownFields)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to ignore unknown fields, that is, whether to ignore bind\n\t * parameters that do not have corresponding fields in the target object.\n\t * <p>Default is \"true\". Turn this off to enforce that all bind parameters\n\t * must have a matching field in the target object.\n\t * <p>Note that this setting only applies to <i>binding</i> operations\n\t * on this DataBinder, not to <i>retrieving</i> values via its\n\t * {@link #getBindingResult() BindingResult}.\n\t * @see #bind\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ignoreUnknownFields"
    ],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "void",
    "signature": "public void setIgnoreUnknownFields(boolean ignoreUnknownFields)",
    "source_code": "\tpublic void setIgnoreUnknownFields(boolean ignoreUnknownFields) {\n\t\tthis.ignoreUnknownFields = ignoreUnknownFields;\n\t}"
  },
  "org.springframework.validation.DataBinder#setMessageCodesResolver(messageCodesResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the strategy to use for resolving errors into message codes.\n\t * Applies the given strategy to the underlying errors holder.\n\t * <p>Default is a DefaultMessageCodesResolver.\n\t * @see BeanPropertyBindingResult#setMessageCodesResolver\n\t * @see DefaultMessageCodesResolver\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageCodesResolver"
    ],
    "position": {
      "column": 1,
      "line": 535
    },
    "return": "void",
    "signature": "public void setMessageCodesResolver(@Nullable MessageCodesResolver messageCodesResolver)",
    "source_code": "\tpublic void setMessageCodesResolver(@Nullable MessageCodesResolver messageCodesResolver) {\n\t\tAssert.state(this.messageCodesResolver == null, \"DataBinder is already initialized with MessageCodesResolver\");\n\t\tthis.messageCodesResolver = messageCodesResolver;\n\t\tif (this.bindingResult != null && messageCodesResolver != null) {\n\t\t\tthis.bindingResult.setMessageCodesResolver(messageCodesResolver);\n\t\t}\n\t}"
  },
  "org.springframework.validation.DataBinder#setRequiredFields(requiredFields)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register fields that are required for each binding process.\n\t * <p>If one of the specified fields is not contained in the list of\n\t * incoming property values, a corresponding \"missing field\" error\n\t * will be created, with error code \"required\" (by the default\n\t * binding error processor).\n\t * @param requiredFields array of field names\n\t * @see #setBindingErrorProcessor\n\t * @see DefaultBindingErrorProcessor#MISSING_FIELD_ERROR_CODE\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredFields"
    ],
    "position": {
      "column": 1,
      "line": 511
    },
    "return": "void",
    "signature": "public void setRequiredFields(@Nullable String... requiredFields)",
    "source_code": "\tpublic void setRequiredFields(@Nullable String... requiredFields) {\n\t\tthis.requiredFields = PropertyAccessorUtils.canonicalPropertyNames(requiredFields);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"DataBinder requires binding of required fields [\" +\n\t\t\t\t\tStringUtils.arrayToCommaDelimitedString(requiredFields) + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.validation.DataBinder#setValidator(validator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Validator to apply after each binding step.\n\t * @see #addValidators(Validator...)\n\t * @see #replaceValidators(Validator...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "validator"
    ],
    "position": {
      "column": 1,
      "line": 566
    },
    "return": "void",
    "signature": "public void setValidator(@Nullable Validator validator)",
    "source_code": "\tpublic void setValidator(@Nullable Validator validator) {\n\t\tassertValidators(validator);\n\t\tthis.validators.clear();\n\t\tif (validator != null) {\n\t\t\tthis.validators.add(validator);\n\t\t}\n\t}"
  },
  "org.springframework.validation.DataBinder#validate()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified Validators, if any.\n\t * @see #setValidator(Validator)\n\t * @see #getBindingResult()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 904
    },
    "return": "void",
    "signature": "public void validate()",
    "source_code": "\tpublic void validate() {\n\t\tObject target = getTarget();\n\t\tAssert.state(target != null, \"No target to validate\");\n\t\tBindingResult bindingResult = getBindingResult();\n\t\t// Call each validator with the same binding result\n\t\tfor (Validator validator : getValidators()) {\n\t\t\tvalidator.validate(target, bindingResult);\n\t\t}\n\t}"
  },
  "org.springframework.validation.DataBinder#validate(validationHints)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified Validators, if any, with the given validation hints.\n\t * <p>Note: Validation hints may get ignored by the actual target Validator.\n\t * @param validationHints one or more hint objects to be passed to a {@link SmartValidator}\n\t * @since 3.1\n\t * @see #setValidator(Validator)\n\t * @see SmartValidator#validate(Object, Errors, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "validationHints"
    ],
    "position": {
      "column": 1,
      "line": 922
    },
    "return": "void",
    "signature": "public void validate(Object... validationHints)",
    "source_code": "\tpublic void validate(Object... validationHints) {\n\t\tObject target = getTarget();\n\t\tAssert.state(target != null, \"No target to validate\");\n\t\tBindingResult bindingResult = getBindingResult();\n\t\t// Call each validator with the same binding result\n\t\tfor (Validator validator : getValidators()) {\n\t\t\tif (!ObjectUtils.isEmpty(validationHints) && validator instanceof SmartValidator) {\n\t\t\t\t((SmartValidator) validator).validate(target, bindingResult, validationHints);\n\t\t\t}\n\t\t\telse if (validator != null) {\n\t\t\t\tvalidator.validate(target, bindingResult);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationInterceptor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * An AOP Alliance {@link MethodInterceptor} implementation that delegates to a\n * JSR-303 provider for performing method-level validation on annotated methods.\n *\n * <p>Applicable methods have JSR-303 constraint annotations on their parameters\n * and/or on their return value (in the latter case specified at the method level,\n * typically as inline annotation).\n *\n * <p>E.g.: {@code public @NotNull Object myValidMethod(@NotNull String arg1, @Max(10) int arg2)}\n *\n * <p>Validation groups can be specified through Spring's {@link Validated} annotation\n * at the type level of the containing target class, applying to all public service methods\n * of that class. By default, JSR-303 will validate against its default group only.\n *\n * <p>As of Spring 5.0, this functionality requires a Bean Validation 1.1+ provider.\n *\n * @author Juergen Hoeller\n * @since 3.1\n * @see MethodValidationPostProcessor\n * @see jakarta.validation.executable.ExecutableValidator\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "signature": "public class MethodValidationInterceptor",
    "source_code": "public class MethodValidationInterceptor implements MethodInterceptor {\n\n\tprivate final Supplier<Validator> validator;\n\n\n\t/**\n\t * Create a new MethodValidationInterceptor using a default JSR-303 validator underneath.\n\t */\n\tpublic MethodValidationInterceptor() {\n\t\tthis.validator = SingletonSupplier.of(() -> Validation.buildDefaultValidatorFactory().getValidator());\n\t}\n\n\t/**\n\t * Create a new MethodValidationInterceptor using the given JSR-303 ValidatorFactory.\n\t * @param validatorFactory the JSR-303 ValidatorFactory to use\n\t */\n\tpublic MethodValidationInterceptor(ValidatorFactory validatorFactory) {\n\t\tthis.validator = SingletonSupplier.of(validatorFactory::getValidator);\n\t}\n\n\t/**\n\t * Create a new MethodValidationInterceptor using the given JSR-303 Validator.\n\t * @param validator the JSR-303 Validator to use\n\t */\n\tpublic MethodValidationInterceptor(Validator validator) {\n\t\tthis.validator = () -> validator;\n\t}\n\n\t/**\n\t * Create a new MethodValidationInterceptor for the supplied\n\t * (potentially lazily initialized) Validator.\n\t * @param validator a Supplier for the Validator to use\n\t * @since 6.0\n\t */\n\tpublic MethodValidationInterceptor(Supplier<Validator> validator) {\n\t\tthis.validator = validator;\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic Object invoke(MethodInvocation invocation) throws Throwable {\n\t\t// Avoid Validator invocation on FactoryBean.getObjectType/isSingleton\n\t\tif (isFactoryBeanMetadataMethod(invocation.getMethod())) {\n\t\t\treturn invocation.proceed();\n\t\t}\n\n\t\tClass<?>[] groups = determineValidationGroups(invocation);\n\n\t\t// Standard Bean Validation 1.1 API\n\t\tExecutableValidator execVal = this.validator.get().forExecutables();\n\t\tMethod methodToValidate = invocation.getMethod();\n\t\tSet<ConstraintViolation<Object>> result;\n\n\t\tObject target = invocation.getThis();\n\t\tif (target == null && invocation instanceof ProxyMethodInvocation methodInvocation) {\n\t\t\t// Allow validation for AOP proxy without a target\n\t\t\ttarget = methodInvocation.getProxy();\n\t\t}\n\t\tAssert.state(target != null, \"Target must not be null\");\n\n\t\ttry {\n\t\t\tresult = execVal.validateParameters(target, methodToValidate, invocation.getArguments(), groups);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\t// Probably a generic type mismatch between interface and impl as reported in SPR-12237 / HV-1011\n\t\t\t// Let's try to find the bridged method on the implementation class...\n\t\t\tmethodToValidate = BridgeMethodResolver.findBridgedMethod(\n\t\t\t\t\tClassUtils.getMostSpecificMethod(invocation.getMethod(), target.getClass()));\n\t\t\tresult = execVal.validateParameters(target, methodToValidate, invocation.getArguments(), groups);\n\t\t}\n\t\tif (!result.isEmpty()) {\n\t\t\tthrow new ConstraintViolationException(result);\n\t\t}\n\n\t\tObject returnValue = invocation.proceed();\n\n\t\tresult = execVal.validateReturnValue(target, methodToValidate, returnValue, groups);\n\t\tif (!result.isEmpty()) {\n\t\t\tthrow new ConstraintViolationException(result);\n\t\t}\n\n\t\treturn returnValue;\n\t}\n\n\tprivate boolean isFactoryBeanMetadataMethod(Method method) {\n\t\tClass<?> clazz = method.getDeclaringClass();\n\n\t\t// Call from interface-based proxy handle, allowing for an efficient check?\n\t\tif (clazz.isInterface()) {\n\t\t\treturn ((clazz == FactoryBean.class || clazz == SmartFactoryBean.class) &&\n\t\t\t\t\t!method.getName().equals(\"getObject\"));\n\t\t}\n\n\t\t// Call from CGLIB proxy handle, potentially implementing a FactoryBean method?\n\t\tClass<?> factoryBeanType = null;\n\t\tif (SmartFactoryBean.class.isAssignableFrom(clazz)) {\n\t\t\tfactoryBeanType = SmartFactoryBean.class;\n\t\t}\n\t\telse if (FactoryBean.class.isAssignableFrom(clazz)) {\n\t\t\tfactoryBeanType = FactoryBean.class;\n\t\t}\n\t\treturn (factoryBeanType != null && !method.getName().equals(\"getObject\") &&\n\t\t\t\tClassUtils.hasMethod(factoryBeanType, method));\n\t}\n\n\t/**\n\t * Determine the validation groups to validate against for the given method invocation.\n\t * <p>Default are the validation groups as specified in the {@link Validated} annotation\n\t * on the method, or on the containing target class of the method, or for an AOP proxy\n\t * without a target (with all behavior in advisors), also check on proxied interfaces.\n\t * @param invocation the current MethodInvocation\n\t * @return the applicable validation groups as a Class array\n\t */\n\tprotected Class<?>[] determineValidationGroups(MethodInvocation invocation) {\n\t\tValidated validatedAnn = AnnotationUtils.findAnnotation(invocation.getMethod(), Validated.class);\n\t\tif (validatedAnn == null) {\n\t\t\tObject target = invocation.getThis();\n\t\t\tif (target != null) {\n\t\t\t\tvalidatedAnn = AnnotationUtils.findAnnotation(target.getClass(), Validated.class);\n\t\t\t}\n\t\t\telse if (invocation instanceof ProxyMethodInvocation methodInvocation) {\n\t\t\t\tObject proxy = methodInvocation.getProxy();\n\t\t\t\tif (AopUtils.isAopProxy(proxy)) {\n\t\t\t\t\tfor (Class<?> type : AopProxyUtils.proxiedUserInterfaces(proxy)) {\n\t\t\t\t\t\tvalidatedAnn = AnnotationUtils.findAnnotation(type, Validated.class);\n\t\t\t\t\t\tif (validatedAnn != null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (validatedAnn != null ? validatedAnn.value() : new Class<?>[0]);\n\t}\n\n}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationInterceptor#invoke(invocation)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invocation"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "Object",
    "signature": "public Object invoke(MethodInvocation invocation)",
    "source_code": "\tpublic Object invoke(MethodInvocation invocation) throws Throwable {\n\t\t// Avoid Validator invocation on FactoryBean.getObjectType/isSingleton\n\t\tif (isFactoryBeanMetadataMethod(invocation.getMethod())) {\n\t\t\treturn invocation.proceed();\n\t\t}\n\n\t\tClass<?>[] groups = determineValidationGroups(invocation);\n\n\t\t// Standard Bean Validation 1.1 API\n\t\tExecutableValidator execVal = this.validator.get().forExecutables();\n\t\tMethod methodToValidate = invocation.getMethod();\n\t\tSet<ConstraintViolation<Object>> result;\n\n\t\tObject target = invocation.getThis();\n\t\tif (target == null && invocation instanceof ProxyMethodInvocation methodInvocation) {\n\t\t\t// Allow validation for AOP proxy without a target\n\t\t\ttarget = methodInvocation.getProxy();\n\t\t}\n\t\tAssert.state(target != null, \"Target must not be null\");\n\n\t\ttry {\n\t\t\tresult = execVal.validateParameters(target, methodToValidate, invocation.getArguments(), groups);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\t// Probably a generic type mismatch between interface and impl as reported in SPR-12237 / HV-1011\n\t\t\t// Let's try to find the bridged method on the implementation class...\n\t\t\tmethodToValidate = BridgeMethodResolver.findBridgedMethod(\n\t\t\t\t\tClassUtils.getMostSpecificMethod(invocation.getMethod(), target.getClass()));\n\t\t\tresult = execVal.validateParameters(target, methodToValidate, invocation.getArguments(), groups);\n\t\t}\n\t\tif (!result.isEmpty()) {\n\t\t\tthrow new ConstraintViolationException(result);\n\t\t}\n\n\t\tObject returnValue = invocation.proceed();\n\n\t\tresult = execVal.validateReturnValue(target, methodToValidate, returnValue, groups);\n\t\tif (!result.isEmpty()) {\n\t\t\tthrow new ConstraintViolationException(result);\n\t\t}\n\n\t\treturn returnValue;\n\t}"
  },
  "org.springframework.validation.logger": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * We'll create a lot of DataBinder instances: Let's use a static logger.\n\t */",
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected static final Log logger = LogFactory.getLog(DataBinder.class);",
    "type": "Log"
  },
  "org.springframework.web.cors.ALL": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Wildcard representing <em>all</em> origins, methods, or headers. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "signature": "public String ALL",
    "source_code": "\tpublic static final String ALL = \"*\";",
    "type": "String"
  },
  "org.springframework.web.cors.CorsConfiguration": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A container for CORS configuration along with methods to check against the\n * actual origin, HTTP methods, and headers of a given request.\n *\n * <p>By default a newly created {@code CorsConfiguration} does not permit any\n * cross-origin requests and must be configured explicitly to indicate what\n * should be allowed. Use {@link #applyPermitDefaultValues()} to flip the\n * initialization model to start with open defaults that permit all cross-origin\n * requests for GET, HEAD, and POST requests.\n *\n * @author Sebastien Deleuze\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Ruslan Akhundov\n * @since 4.2\n * @see <a href=\"https://www.w3.org/TR/cors/\">CORS spec</a>\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "signature": "public class CorsConfiguration",
    "source_code": "public class CorsConfiguration {\n\n\t/** Wildcard representing <em>all</em> origins, methods, or headers. */\n\tpublic static final String ALL = \"*\";\n\n\tprivate static final List<String> ALL_LIST = Collections.singletonList(ALL);\n\n\tprivate static final OriginPattern ALL_PATTERN = new OriginPattern(\"*\");\n\n\tprivate static final List<OriginPattern> ALL_PATTERN_LIST = Collections.singletonList(ALL_PATTERN);\n\n\tprivate static final List<String> DEFAULT_PERMIT_ALL = Collections.singletonList(ALL);\n\n\tprivate static final List<HttpMethod> DEFAULT_METHODS = List.of(HttpMethod.GET, HttpMethod.HEAD);\n\n\tprivate static final List<String> DEFAULT_PERMIT_METHODS = List.of(HttpMethod.GET.name(),\n\t\t\tHttpMethod.HEAD.name(), HttpMethod.POST.name());\n\n\n\t@Nullable\n\tprivate List<String> allowedOrigins;\n\n\t@Nullable\n\tprivate List<OriginPattern> allowedOriginPatterns;\n\n\t@Nullable\n\tprivate List<String> allowedMethods;\n\n\t@Nullable\n\tprivate List<HttpMethod> resolvedMethods = DEFAULT_METHODS;\n\n\t@Nullable\n\tprivate List<String> allowedHeaders;\n\n\t@Nullable\n\tprivate List<String> exposedHeaders;\n\n\t@Nullable\n\tprivate Boolean allowCredentials;\n\n\t@Nullable\n\tprivate Long maxAge;\n\n\n\t/**\n\t * Construct a new {@code CorsConfiguration} instance with no cross-origin\n\t * requests allowed for any origin by default.\n\t * @see #applyPermitDefaultValues()\n\t */\n\tpublic CorsConfiguration() {\n\t}\n\n\t/**\n\t * Construct a new {@code CorsConfiguration} instance by copying all\n\t * values from the supplied {@code CorsConfiguration}.\n\t */\n\tpublic CorsConfiguration(CorsConfiguration other) {\n\t\tthis.allowedOrigins = other.allowedOrigins;\n\t\tthis.allowedOriginPatterns = other.allowedOriginPatterns;\n\t\tthis.allowedMethods = other.allowedMethods;\n\t\tthis.resolvedMethods = other.resolvedMethods;\n\t\tthis.allowedHeaders = other.allowedHeaders;\n\t\tthis.exposedHeaders = other.exposedHeaders;\n\t\tthis.allowCredentials = other.allowCredentials;\n\t\tthis.maxAge = other.maxAge;\n\t}\n\n\n\t/**\n\t * A list of origins for which cross-origin requests are allowed where each\n\t * value may be one of the following:\n\t * <ul>\n\t * <li>a specific domain, e.g. {@code \"https://domain1.com\"}\n\t * <li>comma-delimited list of specific domains, e.g.\n\t * {@code \"https://a1.com,https://a2.com\"}; this is convenient when a value\n\t * is resolved through a property placeholder, e.g. {@code \"${origin}\"};\n\t * note that such placeholders must be resolved externally.\n\t * <li>the CORS defined special value {@code \"*\"} for all origins\n\t * </ul>\n\t * <p>For matched pre-flight and actual requests the\n\t * {@code Access-Control-Allow-Origin} response header is set either to the\n\t * matched domain value or to {@code \"*\"}. Keep in mind however that the\n\t * CORS spec does not allow {@code \"*\"} when {@link #setAllowCredentials\n\t * allowCredentials} is set to {@code true} and as of 5.3 that combination\n\t * is rejected in favor of using {@link #setAllowedOriginPatterns\n\t * allowedOriginPatterns} instead.\n\t * <p>By default this is not set which means that no origins are allowed.\n\t * However, an instance of this class is often initialized further, e.g. for\n\t * {@code @CrossOrigin}, via {@link #applyPermitDefaultValues()}.\n\t */\n\tpublic void setAllowedOrigins(@Nullable List<String> origins) {\n\t\tif (origins == null) {\n\t\t\tthis.allowedOrigins = null;\n\t\t}\n\t\telse {\n\t\t\tthis.allowedOrigins = new ArrayList<>(origins.size());\n\t\t\tfor (String origin : origins) {\n\t\t\t\taddAllowedOrigin(origin);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String trimTrailingSlash(String origin) {\n\t\treturn (origin.endsWith(\"/\") ? origin.substring(0, origin.length() - 1) : origin);\n\t}\n\n\t/**\n\t * Return the configured origins to allow, or {@code null} if none.\n\t */\n\t@Nullable\n\tpublic List<String> getAllowedOrigins() {\n\t\treturn this.allowedOrigins;\n\t}\n\n\t/**\n\t * Variant of {@link #setAllowedOrigins} for adding one origin at a time.\n\t */\n\tpublic void addAllowedOrigin(@Nullable String origin) {\n\t\tif (origin == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.allowedOrigins == null) {\n\t\t\tthis.allowedOrigins = new ArrayList<>(4);\n\t\t}\n\t\telse if (this.allowedOrigins == DEFAULT_PERMIT_ALL && CollectionUtils.isEmpty(this.allowedOriginPatterns)) {\n\t\t\tsetAllowedOrigins(DEFAULT_PERMIT_ALL);\n\t\t}\n\t\tparseCommaDelimitedOrigin(origin, value -> {\n\t\t\tvalue = trimTrailingSlash(value);\n\t\t\tthis.allowedOrigins.add(value);\n\t\t});\n\t}\n\n\t/**\n\t * Alternative to {@link #setAllowedOrigins} that supports more flexible\n\t * origins patterns with \"*\" anywhere in the host name in addition to port\n\t * lists. Examples:\n\t * <ul>\n\t * <li>{@literal https://*.domain1.com} -- domains ending with domain1.com\n\t * <li>{@literal https://*.domain1.com:[8080,8081]} -- domains ending with\n\t * domain1.com on port 8080 or port 8081\n\t * <li>{@literal https://*.domain1.com:[*]} -- domains ending with\n\t * domain1.com on any port, including the default port\n\t * <li>comma-delimited list of patters, e.g.\n\t * {@code \"https://*.a1.com,https://*.a2.com\"}; this is convenient when a\n\t * value is resolved through a property placeholder, e.g. {@code \"${origin}\"};\n\t * note that such placeholders must be resolved externally.\n\t * </ul>\n\t * <p>In contrast to {@link #setAllowedOrigins(List) allowedOrigins} which\n\t * only supports \"*\" and cannot be used with {@code allowCredentials}, when\n\t * an allowedOriginPattern is matched, the {@code Access-Control-Allow-Origin}\n\t * response header is set to the matched origin and not to {@code \"*\"} nor\n\t * to the pattern. Therefore, allowedOriginPatterns can be used in combination\n\t * with {@link #setAllowCredentials} set to {@code true}.\n\t * <p>By default this is not set.\n\t * @since 5.3\n\t */\n\tpublic CorsConfiguration setAllowedOriginPatterns(@Nullable List<String> allowedOriginPatterns) {\n\t\tif (allowedOriginPatterns == null) {\n\t\t\tthis.allowedOriginPatterns = null;\n\t\t}\n\t\telse {\n\t\t\tthis.allowedOriginPatterns = new ArrayList<>(allowedOriginPatterns.size());\n\t\t\tfor (String patternValue : allowedOriginPatterns) {\n\t\t\t\taddAllowedOriginPattern(patternValue);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the configured origins patterns to allow, or {@code null} if none.\n\t * @since 5.3\n\t */\n\t@Nullable\n\tpublic List<String> getAllowedOriginPatterns() {\n\t\tif (this.allowedOriginPatterns == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.allowedOriginPatterns.stream()\n\t\t\t\t.map(OriginPattern::getDeclaredPattern)\n\t\t\t\t.toList();\n\t}\n\n\t/**\n\t * Variant of {@link #setAllowedOriginPatterns} for adding one origin at a time.\n\t * @since 5.3\n\t */\n\tpublic void addAllowedOriginPattern(@Nullable String originPattern) {\n\t\tif (originPattern == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.allowedOriginPatterns == null) {\n\t\t\tthis.allowedOriginPatterns = new ArrayList<>(4);\n\t\t}\n\t\tparseCommaDelimitedOrigin(originPattern, value -> {\n\t\t\tvalue = trimTrailingSlash(value);\n\t\t\tthis.allowedOriginPatterns.add(new OriginPattern(value));\n\t\t\tif (this.allowedOrigins == DEFAULT_PERMIT_ALL) {\n\t\t\t\tthis.allowedOrigins = null;\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate static void parseCommaDelimitedOrigin(String rawValue, Consumer<String> valueConsumer) {\n\t\tif (rawValue.indexOf(',') == -1) {\n\t\t\tvalueConsumer.accept(rawValue);\n\t\t\treturn;\n\t\t}\n\t\tint start = 0;\n\t\tboolean withinPortRange = false;\n\t\tfor (int current = 0; current < rawValue.length(); current++) {\n\t\t\tswitch (rawValue.charAt(current)) {\n\t\t\t\tcase '[' -> withinPortRange = true;\n\t\t\t\tcase ']' -> withinPortRange = false;\n\t\t\t\tcase ',' -> {\n\t\t\t\t\tif (!withinPortRange) {\n\t\t\t\t\t\tvalueConsumer.accept(rawValue.substring(start, current).trim());\n\t\t\t\t\t\tstart = current + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (start < rawValue.length()) {\n\t\t\tvalueConsumer.accept(rawValue.substring(start));\n\t\t}\n\t}\n\n\t/**\n\t * Set the HTTP methods to allow, e.g. {@code \"GET\"}, {@code \"POST\"},\n\t * {@code \"PUT\"}, etc.\n\t * <p>The special value {@code \"*\"} allows all methods.\n\t * <p>If not set, only {@code \"GET\"} and {@code \"HEAD\"} are allowed.\n\t * <p>By default this is not set.\n\t * <p><strong>Note:</strong> CORS checks use values from \"Forwarded\"\n\t * (<a href=\"https://tools.ietf.org/html/rfc7239\">RFC 7239</a>),\n\t * \"X-Forwarded-Host\", \"X-Forwarded-Port\", and \"X-Forwarded-Proto\" headers,\n\t * if present, in order to reflect the client-originated address.\n\t * Consider using the {@code ForwardedHeaderFilter} in order to choose from a\n\t * central place whether to extract and use, or to discard such headers.\n\t * See the Spring Framework reference for more on this filter.\n\t */\n\tpublic void setAllowedMethods(@Nullable List<String> allowedMethods) {\n\t\tthis.allowedMethods = (allowedMethods != null ? new ArrayList<>(allowedMethods) : null);\n\t\tif (!CollectionUtils.isEmpty(allowedMethods)) {\n\t\t\tthis.resolvedMethods = new ArrayList<>(allowedMethods.size());\n\t\t\tfor (String method : allowedMethods) {\n\t\t\t\tif (ALL.equals(method)) {\n\t\t\t\t\tthis.resolvedMethods = null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.resolvedMethods.add(HttpMethod.valueOf(method));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.resolvedMethods = DEFAULT_METHODS;\n\t\t}\n\t}\n\n\t/**\n\t * Return the allowed HTTP methods, or {@code null} in which case\n\t * only {@code \"GET\"} and {@code \"HEAD\"} allowed.\n\t * @see #addAllowedMethod(HttpMethod)\n\t * @see #addAllowedMethod(String)\n\t * @see #setAllowedMethods(List)\n\t */\n\t@Nullable\n\tpublic List<String> getAllowedMethods() {\n\t\treturn this.allowedMethods;\n\t}\n\n\t/**\n\t * Add an HTTP method to allow.\n\t */\n\tpublic void addAllowedMethod(HttpMethod method) {\n\t\taddAllowedMethod(method.name());\n\t}\n\n\t/**\n\t * Add an HTTP method to allow.\n\t */\n\tpublic void addAllowedMethod(String method) {\n\t\tif (StringUtils.hasText(method)) {\n\t\t\tif (this.allowedMethods == null) {\n\t\t\t\tthis.allowedMethods = new ArrayList<>(4);\n\t\t\t\tthis.resolvedMethods = new ArrayList<>(4);\n\t\t\t}\n\t\t\telse if (this.allowedMethods == DEFAULT_PERMIT_METHODS) {\n\t\t\t\tsetAllowedMethods(DEFAULT_PERMIT_METHODS);\n\t\t\t}\n\t\t\tthis.allowedMethods.add(method);\n\t\t\tif (ALL.equals(method)) {\n\t\t\t\tthis.resolvedMethods = null;\n\t\t\t}\n\t\t\telse if (this.resolvedMethods != null) {\n\t\t\t\tthis.resolvedMethods.add(HttpMethod.valueOf(method));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Set the list of headers that a pre-flight request can list as allowed\n\t * for use during an actual request.\n\t * <p>The special value {@code \"*\"} allows actual requests to send any\n\t * header.\n\t * <p>A header name is not required to be listed if it is one of:\n\t * {@code Cache-Control}, {@code Content-Language}, {@code Expires},\n\t * {@code Last-Modified}, or {@code Pragma}.\n\t * <p>By default this is not set.\n\t */\n\tpublic void setAllowedHeaders(@Nullable List<String> allowedHeaders) {\n\t\tthis.allowedHeaders = (allowedHeaders != null ? new ArrayList<>(allowedHeaders) : null);\n\t}\n\n\t/**\n\t * Return the allowed actual request headers, or {@code null} if none.\n\t * @see #addAllowedHeader(String)\n\t * @see #setAllowedHeaders(List)\n\t */\n\t@Nullable\n\tpublic List<String> getAllowedHeaders() {\n\t\treturn this.allowedHeaders;\n\t}\n\n\t/**\n\t * Add an actual request header to allow.\n\t */\n\tpublic void addAllowedHeader(String allowedHeader) {\n\t\tif (this.allowedHeaders == null) {\n\t\t\tthis.allowedHeaders = new ArrayList<>(4);\n\t\t}\n\t\telse if (this.allowedHeaders == DEFAULT_PERMIT_ALL) {\n\t\t\tsetAllowedHeaders(DEFAULT_PERMIT_ALL);\n\t\t}\n\t\tthis.allowedHeaders.add(allowedHeader);\n\t}\n\n\t/**\n\t * Set the list of response headers other than simple headers (i.e.\n\t * {@code Cache-Control}, {@code Content-Language}, {@code Content-Type},\n\t * {@code Expires}, {@code Last-Modified}, or {@code Pragma}) that an\n\t * actual response might have and can be exposed.\n\t * <p>The special value {@code \"*\"} allows all headers to be exposed for\n\t * non-credentialed requests.\n\t * <p>By default this is not set.\n\t */\n\tpublic void setExposedHeaders(@Nullable List<String> exposedHeaders) {\n\t\tthis.exposedHeaders = (exposedHeaders != null ? new ArrayList<>(exposedHeaders) : null);\n\t}\n\n\t/**\n\t * Return the configured response headers to expose, or {@code null} if none.\n\t * @see #addExposedHeader(String)\n\t * @see #setExposedHeaders(List)\n\t */\n\t@Nullable\n\tpublic List<String> getExposedHeaders() {\n\t\treturn this.exposedHeaders;\n\t}\n\n\t/**\n\t * Add a response header to expose.\n\t * <p>The special value {@code \"*\"} allows all headers to be exposed for\n\t * non-credentialed requests.\n\t */\n\tpublic void addExposedHeader(String exposedHeader) {\n\t\tif (this.exposedHeaders == null) {\n\t\t\tthis.exposedHeaders = new ArrayList<>(4);\n\t\t}\n\t\tthis.exposedHeaders.add(exposedHeader);\n\t}\n\n\t/**\n\t * Whether user credentials are supported.\n\t * <p>By default this is not set (i.e. user credentials are not supported).\n\t */\n\tpublic void setAllowCredentials(@Nullable Boolean allowCredentials) {\n\t\tthis.allowCredentials = allowCredentials;\n\t}\n\n\t/**\n\t * Return the configured {@code allowCredentials} flag, or {@code null} if none.\n\t * @see #setAllowCredentials(Boolean)\n\t */\n\t@Nullable\n\tpublic Boolean getAllowCredentials() {\n\t\treturn this.allowCredentials;\n\t}\n\n\t/**\n\t * Configure how long, as a duration, the response from a pre-flight request\n\t * can be cached by clients.\n\t * @since 5.2\n\t * @see #setMaxAge(Long)\n\t */\n\tpublic void setMaxAge(Duration maxAge) {\n\t\tthis.maxAge = maxAge.getSeconds();\n\t}\n\n\t/**\n\t * Configure how long, in seconds, the response from a pre-flight request\n\t * can be cached by clients.\n\t * <p>By default this is not set.\n\t */\n\tpublic void setMaxAge(@Nullable Long maxAge) {\n\t\tthis.maxAge = maxAge;\n\t}\n\n\t/**\n\t * Return the configured {@code maxAge} value, or {@code null} if none.\n\t * @see #setMaxAge(Long)\n\t */\n\t@Nullable\n\tpublic Long getMaxAge() {\n\t\treturn this.maxAge;\n\t}\n\n\n\t/**\n\t * By default {@code CorsConfiguration} does not permit any cross-origin\n\t * requests and must be configured explicitly. Use this method to switch to\n\t * defaults that permit all cross-origin requests for GET, HEAD, and POST,\n\t * but not overriding any values that have already been set.\n\t * <p>The following defaults are applied for values that are not set:\n\t * <ul>\n\t * <li>Allow all origins with the special value {@code \"*\"} defined in the\n\t * CORS spec. This is set only if neither {@link #setAllowedOrigins origins}\n\t * nor {@link #setAllowedOriginPatterns originPatterns} are already set.</li>\n\t * <li>Allow \"simple\" methods {@code GET}, {@code HEAD} and {@code POST}.</li>\n\t * <li>Allow all headers.</li>\n\t * <li>Set max age to 1800 seconds (30 minutes).</li>\n\t * </ul>\n\t */\n\tpublic CorsConfiguration applyPermitDefaultValues() {\n\t\tif (this.allowedOrigins == null && this.allowedOriginPatterns == null) {\n\t\t\tthis.allowedOrigins = DEFAULT_PERMIT_ALL;\n\t\t}\n\t\tif (this.allowedMethods == null) {\n\t\t\tthis.allowedMethods = DEFAULT_PERMIT_METHODS;\n\t\t\tthis.resolvedMethods = DEFAULT_PERMIT_METHODS\n\t\t\t\t\t.stream().map(HttpMethod::valueOf).toList();\n\t\t}\n\t\tif (this.allowedHeaders == null) {\n\t\t\tthis.allowedHeaders = DEFAULT_PERMIT_ALL;\n\t\t}\n\t\tif (this.maxAge == null) {\n\t\t\tthis.maxAge = 1800L;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Validate that when {@link #setAllowCredentials allowCredentials} is {@code true},\n\t * {@link #setAllowedOrigins allowedOrigins} does not contain the special\n\t * value {@code \"*\"} since in that case the \"Access-Control-Allow-Origin\"\n\t * cannot be set to {@code \"*\"}.\n\t * @throws IllegalArgumentException if the validation fails\n\t * @since 5.3\n\t */\n\tpublic void validateAllowCredentials() {\n\t\tif (this.allowCredentials == Boolean.TRUE &&\n\t\t\t\tthis.allowedOrigins != null && this.allowedOrigins.contains(ALL)) {\n\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"When allowCredentials is true, allowedOrigins cannot contain the special value \\\"*\\\" \" +\n\t\t\t\t\t\t\t\"since that cannot be set on the \\\"Access-Control-Allow-Origin\\\" response header. \" +\n\t\t\t\t\t\t\t\"To allow credentials to a set of origins, list them explicitly \" +\n\t\t\t\t\t\t\t\"or consider using \\\"allowedOriginPatterns\\\" instead.\");\n\t\t}\n\t}\n\n\t/**\n\t * Combine the non-null properties of the supplied\n\t * {@code CorsConfiguration} with this one.\n\t * <p>When combining single values like {@code allowCredentials} or\n\t * {@code maxAge}, {@code this} properties are overridden by non-null\n\t * {@code other} properties if any.\n\t * <p>Combining lists like {@code allowedOrigins}, {@code allowedMethods},\n\t * {@code allowedHeaders} or {@code exposedHeaders} is done in an additive\n\t * way. For example, combining {@code [\"GET\", \"POST\"]} with\n\t * {@code [\"PATCH\"]} results in {@code [\"GET\", \"POST\", \"PATCH\"]}. However,\n\t * combining {@code [\"GET\", \"POST\"]} with {@code [\"*\"]} results in\n\t * {@code [\"*\"]}. Note also that default permit values set by\n\t * {@link CorsConfiguration#applyPermitDefaultValues()} are overridden by\n\t * any explicitly defined values.\n\t * @return the combined {@code CorsConfiguration}, or {@code this}\n\t * configuration if the supplied configuration is {@code null}\n\t */\n\tpublic CorsConfiguration combine(@Nullable CorsConfiguration other) {\n\t\tif (other == null) {\n\t\t\treturn this;\n\t\t}\n\t\t// Bypass setAllowedOrigins to avoid re-compiling patterns\n\t\tCorsConfiguration config = new CorsConfiguration(this);\n\t\tList<String> origins = combine(getAllowedOrigins(), other.getAllowedOrigins());\n\t\tList<OriginPattern> patterns = combinePatterns(this.allowedOriginPatterns, other.allowedOriginPatterns);\n\t\tconfig.allowedOrigins = (origins == DEFAULT_PERMIT_ALL && !CollectionUtils.isEmpty(patterns) ? null : origins);\n\t\tconfig.allowedOriginPatterns = patterns;\n\t\tconfig.setAllowedMethods(combine(getAllowedMethods(), other.getAllowedMethods()));\n\t\tconfig.setAllowedHeaders(combine(getAllowedHeaders(), other.getAllowedHeaders()));\n\t\tconfig.setExposedHeaders(combine(getExposedHeaders(), other.getExposedHeaders()));\n\t\tBoolean allowCredentials = other.getAllowCredentials();\n\t\tif (allowCredentials != null) {\n\t\t\tconfig.setAllowCredentials(allowCredentials);\n\t\t}\n\t\tLong maxAge = other.getMaxAge();\n\t\tif (maxAge != null) {\n\t\t\tconfig.setMaxAge(maxAge);\n\t\t}\n\t\treturn config;\n\t}\n\n\tprivate List<String> combine(@Nullable List<String> source, @Nullable List<String> other) {\n\t\tif (other == null) {\n\t\t\treturn (source != null ? source : Collections.emptyList());\n\t\t}\n\t\tif (source == null) {\n\t\t\treturn other;\n\t\t}\n\t\tif (source == DEFAULT_PERMIT_ALL || source == DEFAULT_PERMIT_METHODS) {\n\t\t\treturn other;\n\t\t}\n\t\tif (other == DEFAULT_PERMIT_ALL || other == DEFAULT_PERMIT_METHODS) {\n\t\t\treturn source;\n\t\t}\n\t\tif (source.contains(ALL) || other.contains(ALL)) {\n\t\t\treturn ALL_LIST;\n\t\t}\n\t\tSet<String> combined = new LinkedHashSet<>(source.size() + other.size());\n\t\tcombined.addAll(source);\n\t\tcombined.addAll(other);\n\t\treturn new ArrayList<>(combined);\n\t}\n\n\tprivate List<OriginPattern> combinePatterns(\n\t\t\t@Nullable List<OriginPattern> source, @Nullable List<OriginPattern> other) {\n\n\t\tif (other == null) {\n\t\t\treturn (source != null ? source : Collections.emptyList());\n\t\t}\n\t\tif (source == null) {\n\t\t\treturn other;\n\t\t}\n\t\tif (source.contains(ALL_PATTERN) || other.contains(ALL_PATTERN)) {\n\t\t\treturn ALL_PATTERN_LIST;\n\t\t}\n\t\tSet<OriginPattern> combined = new LinkedHashSet<>(source.size() + other.size());\n\t\tcombined.addAll(source);\n\t\tcombined.addAll(other);\n\t\treturn new ArrayList<>(combined);\n\t}\n\n\n\t/**\n\t * Check the origin of the request against the configured allowed origins.\n\t * @param origin the origin to check\n\t * @return the origin to use for the response, or {@code null} which\n\t * means the request origin is not allowed\n\t */\n\t@Nullable\n\tpublic String checkOrigin(@Nullable String origin) {\n\t\tif (!StringUtils.hasText(origin)) {\n\t\t\treturn null;\n\t\t}\n\t\tString originToCheck = trimTrailingSlash(origin);\n\t\tif (!ObjectUtils.isEmpty(this.allowedOrigins)) {\n\t\t\tif (this.allowedOrigins.contains(ALL)) {\n\t\t\t\tvalidateAllowCredentials();\n\t\t\t\treturn ALL;\n\t\t\t}\n\t\t\tfor (String allowedOrigin : this.allowedOrigins) {\n\t\t\t\tif (originToCheck.equalsIgnoreCase(allowedOrigin)) {\n\t\t\t\t\treturn origin;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ObjectUtils.isEmpty(this.allowedOriginPatterns)) {\n\t\t\tfor (OriginPattern p : this.allowedOriginPatterns) {\n\t\t\t\tif (p.getDeclaredPattern().equals(ALL) || p.getPattern().matcher(originToCheck).matches()) {\n\t\t\t\t\treturn origin;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Check the HTTP request method (or the method from the\n\t * {@code Access-Control-Request-Method} header on a pre-flight request)\n\t * against the configured allowed methods.\n\t * @param requestMethod the HTTP request method to check\n\t * @return the list of HTTP methods to list in the response of a pre-flight\n\t * request, or {@code null} if the supplied {@code requestMethod} is not allowed\n\t */\n\t@Nullable\n\tpublic List<HttpMethod> checkHttpMethod(@Nullable HttpMethod requestMethod) {\n\t\tif (requestMethod == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this.resolvedMethods == null) {\n\t\t\treturn Collections.singletonList(requestMethod);\n\t\t}\n\t\treturn (this.resolvedMethods.contains(requestMethod) ? this.resolvedMethods : null);\n\t}\n\n\t/**\n\t * Check the supplied request headers (or the headers listed in the\n\t * {@code Access-Control-Request-Headers} of a pre-flight request) against\n\t * the configured allowed headers.\n\t * @param requestHeaders the request headers to check\n\t * @return the list of allowed headers to list in the response of a pre-flight\n\t * request, or {@code null} if none of the supplied request headers is allowed\n\t */\n\t@Nullable\n\tpublic List<String> checkHeaders(@Nullable List<String> requestHeaders) {\n\t\tif (requestHeaders == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (requestHeaders.isEmpty()) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.allowedHeaders)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tboolean allowAnyHeader = this.allowedHeaders.contains(ALL);\n\t\tint maxResultSize = allowAnyHeader ? requestHeaders.size()\n\t\t\t\t: Math.min(requestHeaders.size(), this.allowedHeaders.size());\n\t\tList<String> result = new ArrayList<>(maxResultSize);\n\t\tfor (String requestHeader : requestHeaders) {\n\t\t\tif (StringUtils.hasText(requestHeader)) {\n\t\t\t\trequestHeader = requestHeader.trim();\n\t\t\t\tif (allowAnyHeader) {\n\t\t\t\t\tresult.add(requestHeader);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (String allowedHeader : this.allowedHeaders) {\n\t\t\t\t\t\tif (requestHeader.equalsIgnoreCase(allowedHeader)) {\n\t\t\t\t\t\t\tresult.add(requestHeader);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (result.isEmpty() ? null : result);\n\t}\n\n\n\t/**\n\t * Contains both the user-declared pattern (e.g. \"https://*.domain.com\") and\n\t * the regex {@link Pattern} derived from it.\n\t */\n\tprivate static class OriginPattern {\n\n\t\tprivate static final Pattern PORTS_PATTERN = Pattern.compile(\"(.*):\\\\[(\\\\*|\\\\d+(,\\\\d+)*)]\");\n\n\t\tprivate final String declaredPattern;\n\n\t\tprivate final Pattern pattern;\n\n\t\tOriginPattern(String declaredPattern) {\n\t\t\tthis.declaredPattern = declaredPattern;\n\t\t\tthis.pattern = initPattern(declaredPattern);\n\t\t}\n\n\t\tprivate static Pattern initPattern(String patternValue) {\n\t\t\tString portList = null;\n\t\t\tMatcher matcher = PORTS_PATTERN.matcher(patternValue);\n\t\t\tif (matcher.matches()) {\n\t\t\t\tpatternValue = matcher.group(1);\n\t\t\t\tportList = matcher.group(2);\n\t\t\t}\n\n\t\t\tpatternValue = \"\\\\Q\" + patternValue + \"\\\\E\";\n\t\t\tpatternValue = patternValue.replace(\"*\", \"\\\\E.*\\\\Q\");\n\n\t\t\tif (portList != null) {\n\t\t\t\tpatternValue += (portList.equals(ALL) ? \"(:\\\\d+)?\" : \":(\" + portList.replace(',', '|') + \")\");\n\t\t\t}\n\n\t\t\treturn Pattern.compile(patternValue);\n\t\t}\n\n\t\tpublic String getDeclaredPattern() {\n\t\t\treturn this.declaredPattern;\n\t\t}\n\n\t\tpublic Pattern getPattern() {\n\t\t\treturn this.pattern;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\tif (this == other) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (other == null || !getClass().equals(other.getClass())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn ObjectUtils.nullSafeEquals(\n\t\t\t\t\tthis.declaredPattern, ((OriginPattern) other).declaredPattern);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn this.declaredPattern.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.declaredPattern;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.cors.CorsConfiguration#addAllowedHeader(allowedHeader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an actual request header to allow.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "allowedHeader"
    ],
    "position": {
      "column": 1,
      "line": 380
    },
    "return": "void",
    "signature": "public void addAllowedHeader(String allowedHeader)",
    "source_code": "\tpublic void addAllowedHeader(String allowedHeader) {\n\t\tif (this.allowedHeaders == null) {\n\t\t\tthis.allowedHeaders = new ArrayList<>(4);\n\t\t}\n\t\telse if (this.allowedHeaders == DEFAULT_PERMIT_ALL) {\n\t\t\tsetAllowedHeaders(DEFAULT_PERMIT_ALL);\n\t\t}\n\t\tthis.allowedHeaders.add(allowedHeader);\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#addAllowedMethod(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an HTTP method to allow.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "void",
    "signature": "public void addAllowedMethod(String method)",
    "source_code": "\tpublic void addAllowedMethod(String method) {\n\t\tif (StringUtils.hasText(method)) {\n\t\t\tif (this.allowedMethods == null) {\n\t\t\t\tthis.allowedMethods = new ArrayList<>(4);\n\t\t\t\tthis.resolvedMethods = new ArrayList<>(4);\n\t\t\t}\n\t\t\telse if (this.allowedMethods == DEFAULT_PERMIT_METHODS) {\n\t\t\t\tsetAllowedMethods(DEFAULT_PERMIT_METHODS);\n\t\t\t}\n\t\t\tthis.allowedMethods.add(method);\n\t\t\tif (ALL.equals(method)) {\n\t\t\t\tthis.resolvedMethods = null;\n\t\t\t}\n\t\t\telse if (this.resolvedMethods != null) {\n\t\t\t\tthis.resolvedMethods.add(HttpMethod.valueOf(method));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#addAllowedOrigin(origin)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #setAllowedOrigins} for adding one origin at a time.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "origin"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "void",
    "signature": "public void addAllowedOrigin(@Nullable String origin)",
    "source_code": "\tpublic void addAllowedOrigin(@Nullable String origin) {\n\t\tif (origin == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.allowedOrigins == null) {\n\t\t\tthis.allowedOrigins = new ArrayList<>(4);\n\t\t}\n\t\telse if (this.allowedOrigins == DEFAULT_PERMIT_ALL && CollectionUtils.isEmpty(this.allowedOriginPatterns)) {\n\t\t\tsetAllowedOrigins(DEFAULT_PERMIT_ALL);\n\t\t}\n\t\tparseCommaDelimitedOrigin(origin, value -> {\n\t\t\tvalue = trimTrailingSlash(value);\n\t\t\tthis.allowedOrigins.add(value);\n\t\t});\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#addAllowedOriginPattern(originPattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #setAllowedOriginPatterns} for adding one origin at a time.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "originPattern"
    ],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "void",
    "signature": "public void addAllowedOriginPattern(@Nullable String originPattern)",
    "source_code": "\tpublic void addAllowedOriginPattern(@Nullable String originPattern) {\n\t\tif (originPattern == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.allowedOriginPatterns == null) {\n\t\t\tthis.allowedOriginPatterns = new ArrayList<>(4);\n\t\t}\n\t\tparseCommaDelimitedOrigin(originPattern, value -> {\n\t\t\tvalue = trimTrailingSlash(value);\n\t\t\tthis.allowedOriginPatterns.add(new OriginPattern(value));\n\t\t\tif (this.allowedOrigins == DEFAULT_PERMIT_ALL) {\n\t\t\t\tthis.allowedOrigins = null;\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#addExposedHeader(exposedHeader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a response header to expose.\n\t * <p>The special value {@code \"*\"} allows all headers to be exposed for\n\t * non-credentialed requests.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exposedHeader"
    ],
    "position": {
      "column": 1,
      "line": 418
    },
    "return": "void",
    "signature": "public void addExposedHeader(String exposedHeader)",
    "source_code": "\tpublic void addExposedHeader(String exposedHeader) {\n\t\tif (this.exposedHeaders == null) {\n\t\t\tthis.exposedHeaders = new ArrayList<>(4);\n\t\t}\n\t\tthis.exposedHeaders.add(exposedHeader);\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#applyPermitDefaultValues()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * By default {@code CorsConfiguration} does not permit any cross-origin\n\t * requests and must be configured explicitly. Use this method to switch to\n\t * defaults that permit all cross-origin requests for GET, HEAD, and POST,\n\t * but not overriding any values that have already been set.\n\t * <p>The following defaults are applied for values that are not set:\n\t * <ul>\n\t * <li>Allow all origins with the special value {@code \"*\"} defined in the\n\t * CORS spec. This is set only if neither {@link #setAllowedOrigins origins}\n\t * nor {@link #setAllowedOriginPatterns originPatterns} are already set.</li>\n\t * <li>Allow \"simple\" methods {@code GET}, {@code HEAD} and {@code POST}.</li>\n\t * <li>Allow all headers.</li>\n\t * <li>Set max age to 1800 seconds (30 minutes).</li>\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "CorsConfiguration",
    "signature": "public CorsConfiguration applyPermitDefaultValues()",
    "source_code": "\tpublic CorsConfiguration applyPermitDefaultValues() {\n\t\tif (this.allowedOrigins == null && this.allowedOriginPatterns == null) {\n\t\t\tthis.allowedOrigins = DEFAULT_PERMIT_ALL;\n\t\t}\n\t\tif (this.allowedMethods == null) {\n\t\t\tthis.allowedMethods = DEFAULT_PERMIT_METHODS;\n\t\t\tthis.resolvedMethods = DEFAULT_PERMIT_METHODS\n\t\t\t\t\t.stream().map(HttpMethod::valueOf).toList();\n\t\t}\n\t\tif (this.allowedHeaders == null) {\n\t\t\tthis.allowedHeaders = DEFAULT_PERMIT_ALL;\n\t\t}\n\t\tif (this.maxAge == null) {\n\t\t\tthis.maxAge = 1800L;\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#checkHeaders(requestHeaders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check the supplied request headers (or the headers listed in the\n\t * {@code Access-Control-Request-Headers} of a pre-flight request) against\n\t * the configured allowed headers.\n\t * @param requestHeaders the request headers to check\n\t * @return the list of allowed headers to list in the response of a pre-flight\n\t * request, or {@code null} if none of the supplied request headers is allowed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestHeaders"
    ],
    "position": {
      "column": 1,
      "line": 667
    },
    "return": "List<String>",
    "signature": "public List<String> checkHeaders(@Nullable List<String> requestHeaders)",
    "source_code": "\tpublic List<String> checkHeaders(@Nullable List<String> requestHeaders) {\n\t\tif (requestHeaders == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (requestHeaders.isEmpty()) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.allowedHeaders)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tboolean allowAnyHeader = this.allowedHeaders.contains(ALL);\n\t\tint maxResultSize = allowAnyHeader ? requestHeaders.size()\n\t\t\t\t: Math.min(requestHeaders.size(), this.allowedHeaders.size());\n\t\tList<String> result = new ArrayList<>(maxResultSize);\n\t\tfor (String requestHeader : requestHeaders) {\n\t\t\tif (StringUtils.hasText(requestHeader)) {\n\t\t\t\trequestHeader = requestHeader.trim();\n\t\t\t\tif (allowAnyHeader) {\n\t\t\t\t\tresult.add(requestHeader);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (String allowedHeader : this.allowedHeaders) {\n\t\t\t\t\t\tif (requestHeader.equalsIgnoreCase(allowedHeader)) {\n\t\t\t\t\t\t\tresult.add(requestHeader);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (result.isEmpty() ? null : result);\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#checkHttpMethod(requestMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check the HTTP request method (or the method from the\n\t * {@code Access-Control-Request-Method} header on a pre-flight request)\n\t * against the configured allowed methods.\n\t * @param requestMethod the HTTP request method to check\n\t * @return the list of HTTP methods to list in the response of a pre-flight\n\t * request, or {@code null} if the supplied {@code requestMethod} is not allowed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestMethod"
    ],
    "position": {
      "column": 1,
      "line": 648
    },
    "return": "List<HttpMethod>",
    "signature": "public List<HttpMethod> checkHttpMethod(@Nullable HttpMethod requestMethod)",
    "source_code": "\tpublic List<HttpMethod> checkHttpMethod(@Nullable HttpMethod requestMethod) {\n\t\tif (requestMethod == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this.resolvedMethods == null) {\n\t\t\treturn Collections.singletonList(requestMethod);\n\t\t}\n\t\treturn (this.resolvedMethods.contains(requestMethod) ? this.resolvedMethods : null);\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#checkOrigin(origin)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check the origin of the request against the configured allowed origins.\n\t * @param origin the origin to check\n\t * @return the origin to use for the response, or {@code null} which\n\t * means the request origin is not allowed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "origin"
    ],
    "position": {
      "column": 1,
      "line": 613
    },
    "return": "String",
    "signature": "public String checkOrigin(@Nullable String origin)",
    "source_code": "\tpublic String checkOrigin(@Nullable String origin) {\n\t\tif (!StringUtils.hasText(origin)) {\n\t\t\treturn null;\n\t\t}\n\t\tString originToCheck = trimTrailingSlash(origin);\n\t\tif (!ObjectUtils.isEmpty(this.allowedOrigins)) {\n\t\t\tif (this.allowedOrigins.contains(ALL)) {\n\t\t\t\tvalidateAllowCredentials();\n\t\t\t\treturn ALL;\n\t\t\t}\n\t\t\tfor (String allowedOrigin : this.allowedOrigins) {\n\t\t\t\tif (originToCheck.equalsIgnoreCase(allowedOrigin)) {\n\t\t\t\t\treturn origin;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ObjectUtils.isEmpty(this.allowedOriginPatterns)) {\n\t\t\tfor (OriginPattern p : this.allowedOriginPatterns) {\n\t\t\t\tif (p.getDeclaredPattern().equals(ALL) || p.getPattern().matcher(originToCheck).matches()) {\n\t\t\t\t\treturn origin;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#combine(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Combine the non-null properties of the supplied\n\t * {@code CorsConfiguration} with this one.\n\t * <p>When combining single values like {@code allowCredentials} or\n\t * {@code maxAge}, {@code this} properties are overridden by non-null\n\t * {@code other} properties if any.\n\t * <p>Combining lists like {@code allowedOrigins}, {@code allowedMethods},\n\t * {@code allowedHeaders} or {@code exposedHeaders} is done in an additive\n\t * way. For example, combining {@code [\"GET\", \"POST\"]} with\n\t * {@code [\"PATCH\"]} results in {@code [\"GET\", \"POST\", \"PATCH\"]}. However,\n\t * combining {@code [\"GET\", \"POST\"]} with {@code [\"*\"]} results in\n\t * {@code [\"*\"]}. Note also that default permit values set by\n\t * {@link CorsConfiguration#applyPermitDefaultValues()} are overridden by\n\t * any explicitly defined values.\n\t * @return the combined {@code CorsConfiguration}, or {@code this}\n\t * configuration if the supplied configuration is {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 541
    },
    "return": "CorsConfiguration",
    "signature": "public CorsConfiguration combine(@Nullable CorsConfiguration other)",
    "source_code": "\tpublic CorsConfiguration combine(@Nullable CorsConfiguration other) {\n\t\tif (other == null) {\n\t\t\treturn this;\n\t\t}\n\t\t// Bypass setAllowedOrigins to avoid re-compiling patterns\n\t\tCorsConfiguration config = new CorsConfiguration(this);\n\t\tList<String> origins = combine(getAllowedOrigins(), other.getAllowedOrigins());\n\t\tList<OriginPattern> patterns = combinePatterns(this.allowedOriginPatterns, other.allowedOriginPatterns);\n\t\tconfig.allowedOrigins = (origins == DEFAULT_PERMIT_ALL && !CollectionUtils.isEmpty(patterns) ? null : origins);\n\t\tconfig.allowedOriginPatterns = patterns;\n\t\tconfig.setAllowedMethods(combine(getAllowedMethods(), other.getAllowedMethods()));\n\t\tconfig.setAllowedHeaders(combine(getAllowedHeaders(), other.getAllowedHeaders()));\n\t\tconfig.setExposedHeaders(combine(getExposedHeaders(), other.getExposedHeaders()));\n\t\tBoolean allowCredentials = other.getAllowCredentials();\n\t\tif (allowCredentials != null) {\n\t\t\tconfig.setAllowCredentials(allowCredentials);\n\t\t}\n\t\tLong maxAge = other.getMaxAge();\n\t\tif (maxAge != null) {\n\t\t\tconfig.setMaxAge(maxAge);\n\t\t}\n\t\treturn config;\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 746
    },
    "return": "boolean",
    "signature": "public boolean equals(Object other)",
    "source_code": "\t\tpublic boolean equals(Object other) {\n\t\t\tif (this == other) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (other == null || !getClass().equals(other.getClass())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn ObjectUtils.nullSafeEquals(\n\t\t\t\t\tthis.declaredPattern, ((OriginPattern) other).declaredPattern);\n\t\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#getAllowCredentials()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@code allowCredentials} flag, or {@code null} if none.\n\t * @see #setAllowCredentials(Boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 438
    },
    "return": "Boolean",
    "signature": "public Boolean getAllowCredentials()",
    "source_code": "\tpublic Boolean getAllowCredentials() {\n\t\treturn this.allowCredentials;\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#getAllowedHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the allowed actual request headers, or {@code null} if none.\n\t * @see #addAllowedHeader(String)\n\t * @see #setAllowedHeaders(List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 373
    },
    "return": "List<String>",
    "signature": "public List<String> getAllowedHeaders()",
    "source_code": "\tpublic List<String> getAllowedHeaders() {\n\t\treturn this.allowedHeaders;\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#getAllowedMethods()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the allowed HTTP methods, or {@code null} in which case\n\t * only {@code \"GET\"} and {@code \"HEAD\"} allowed.\n\t * @see #addAllowedMethod(HttpMethod)\n\t * @see #addAllowedMethod(String)\n\t * @see #setAllowedMethods(List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "List<String>",
    "signature": "public List<String> getAllowedMethods()",
    "source_code": "\tpublic List<String> getAllowedMethods() {\n\t\treturn this.allowedMethods;\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#getAllowedOriginPatterns()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured origins patterns to allow, or {@code null} if none.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "List<String>",
    "signature": "public List<String> getAllowedOriginPatterns()",
    "source_code": "\tpublic List<String> getAllowedOriginPatterns() {\n\t\tif (this.allowedOriginPatterns == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.allowedOriginPatterns.stream()\n\t\t\t\t.map(OriginPattern::getDeclaredPattern)\n\t\t\t\t.toList();\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#getAllowedOrigins()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured origins to allow, or {@code null} if none.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "List<String>",
    "signature": "public List<String> getAllowedOrigins()",
    "source_code": "\tpublic List<String> getAllowedOrigins() {\n\t\treturn this.allowedOrigins;\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#getDeclaredPattern()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 737
    },
    "return": "String",
    "signature": "public String getDeclaredPattern()",
    "source_code": "\t\tpublic String getDeclaredPattern() {\n\t\t\treturn this.declaredPattern;\n\t\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#getExposedHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured response headers to expose, or {@code null} if none.\n\t * @see #addExposedHeader(String)\n\t * @see #setExposedHeaders(List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "List<String>",
    "signature": "public List<String> getExposedHeaders()",
    "source_code": "\tpublic List<String> getExposedHeaders() {\n\t\treturn this.exposedHeaders;\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#getMaxAge()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@code maxAge} value, or {@code null} if none.\n\t * @see #setMaxAge(Long)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 466
    },
    "return": "Long",
    "signature": "public Long getMaxAge()",
    "source_code": "\tpublic Long getMaxAge() {\n\t\treturn this.maxAge;\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#getPattern()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 741
    },
    "return": "Pattern",
    "signature": "public Pattern getPattern()",
    "source_code": "\t\tpublic Pattern getPattern() {\n\t\t\treturn this.pattern;\n\t\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 758
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn this.declaredPattern.hashCode();\n\t\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#setAllowCredentials(allowCredentials)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether user credentials are supported.\n\t * <p>By default this is not set (i.e. user credentials are not supported).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "allowCredentials"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "void",
    "signature": "public void setAllowCredentials(@Nullable Boolean allowCredentials)",
    "source_code": "\tpublic void setAllowCredentials(@Nullable Boolean allowCredentials) {\n\t\tthis.allowCredentials = allowCredentials;\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#setAllowedHeaders(allowedHeaders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the list of headers that a pre-flight request can list as allowed\n\t * for use during an actual request.\n\t * <p>The special value {@code \"*\"} allows actual requests to send any\n\t * header.\n\t * <p>A header name is not required to be listed if it is one of:\n\t * {@code Cache-Control}, {@code Content-Language}, {@code Expires},\n\t * {@code Last-Modified}, or {@code Pragma}.\n\t * <p>By default this is not set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "allowedHeaders"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "void",
    "signature": "public void setAllowedHeaders(@Nullable List<String> allowedHeaders)",
    "source_code": "\tpublic void setAllowedHeaders(@Nullable List<String> allowedHeaders) {\n\t\tthis.allowedHeaders = (allowedHeaders != null ? new ArrayList<>(allowedHeaders) : null);\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#setAllowedMethods(allowedMethods)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the HTTP methods to allow, e.g. {@code \"GET\"}, {@code \"POST\"},\n\t * {@code \"PUT\"}, etc.\n\t * <p>The special value {@code \"*\"} allows all methods.\n\t * <p>If not set, only {@code \"GET\"} and {@code \"HEAD\"} are allowed.\n\t * <p>By default this is not set.\n\t * <p><strong>Note:</strong> CORS checks use values from \"Forwarded\"\n\t * (<a href=\"https://tools.ietf.org/html/rfc7239\">RFC 7239</a>),\n\t * \"X-Forwarded-Host\", \"X-Forwarded-Port\", and \"X-Forwarded-Proto\" headers,\n\t * if present, in order to reflect the client-originated address.\n\t * Consider using the {@code ForwardedHeaderFilter} in order to choose from a\n\t * central place whether to extract and use, or to discard such headers.\n\t * See the Spring Framework reference for more on this filter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "allowedMethods"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "void",
    "signature": "public void setAllowedMethods(@Nullable List<String> allowedMethods)",
    "source_code": "\tpublic void setAllowedMethods(@Nullable List<String> allowedMethods) {\n\t\tthis.allowedMethods = (allowedMethods != null ? new ArrayList<>(allowedMethods) : null);\n\t\tif (!CollectionUtils.isEmpty(allowedMethods)) {\n\t\t\tthis.resolvedMethods = new ArrayList<>(allowedMethods.size());\n\t\t\tfor (String method : allowedMethods) {\n\t\t\t\tif (ALL.equals(method)) {\n\t\t\t\t\tthis.resolvedMethods = null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.resolvedMethods.add(HttpMethod.valueOf(method));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.resolvedMethods = DEFAULT_METHODS;\n\t\t}\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#setAllowedOriginPatterns(allowedOriginPatterns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Alternative to {@link #setAllowedOrigins} that supports more flexible\n\t * origins patterns with \"*\" anywhere in the host name in addition to port\n\t * lists. Examples:\n\t * <ul>\n\t * <li>{@literal https://*.domain1.com} -- domains ending with domain1.com\n\t * <li>{@literal https://*.domain1.com:[8080,8081]} -- domains ending with\n\t * domain1.com on port 8080 or port 8081\n\t * <li>{@literal https://*.domain1.com:[*]} -- domains ending with\n\t * domain1.com on any port, including the default port\n\t * <li>comma-delimited list of patters, e.g.\n\t * {@code \"https://*.a1.com,https://*.a2.com\"}; this is convenient when a\n\t * value is resolved through a property placeholder, e.g. {@code \"${origin}\"};\n\t * note that such placeholders must be resolved externally.\n\t * </ul>\n\t * <p>In contrast to {@link #setAllowedOrigins(List) allowedOrigins} which\n\t * only supports \"*\" and cannot be used with {@code allowCredentials}, when\n\t * an allowedOriginPattern is matched, the {@code Access-Control-Allow-Origin}\n\t * response header is set to the matched origin and not to {@code \"*\"} nor\n\t * to the pattern. Therefore, allowedOriginPatterns can be used in combination\n\t * with {@link #setAllowCredentials} set to {@code true}.\n\t * <p>By default this is not set.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "allowedOriginPatterns"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "CorsConfiguration",
    "signature": "public CorsConfiguration setAllowedOriginPatterns(@Nullable List<String> allowedOriginPatterns)",
    "source_code": "\tpublic CorsConfiguration setAllowedOriginPatterns(@Nullable List<String> allowedOriginPatterns) {\n\t\tif (allowedOriginPatterns == null) {\n\t\t\tthis.allowedOriginPatterns = null;\n\t\t}\n\t\telse {\n\t\t\tthis.allowedOriginPatterns = new ArrayList<>(allowedOriginPatterns.size());\n\t\t\tfor (String patternValue : allowedOriginPatterns) {\n\t\t\t\taddAllowedOriginPattern(patternValue);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#setAllowedOrigins(origins)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A list of origins for which cross-origin requests are allowed where each\n\t * value may be one of the following:\n\t * <ul>\n\t * <li>a specific domain, e.g. {@code \"https://domain1.com\"}\n\t * <li>comma-delimited list of specific domains, e.g.\n\t * {@code \"https://a1.com,https://a2.com\"}; this is convenient when a value\n\t * is resolved through a property placeholder, e.g. {@code \"${origin}\"};\n\t * note that such placeholders must be resolved externally.\n\t * <li>the CORS defined special value {@code \"*\"} for all origins\n\t * </ul>\n\t * <p>For matched pre-flight and actual requests the\n\t * {@code Access-Control-Allow-Origin} response header is set either to the\n\t * matched domain value or to {@code \"*\"}. Keep in mind however that the\n\t * CORS spec does not allow {@code \"*\"} when {@link #setAllowCredentials\n\t * allowCredentials} is set to {@code true} and as of 5.3 that combination\n\t * is rejected in favor of using {@link #setAllowedOriginPatterns\n\t * allowedOriginPatterns} instead.\n\t * <p>By default this is not set which means that no origins are allowed.\n\t * However, an instance of this class is often initialized further, e.g. for\n\t * {@code @CrossOrigin}, via {@link #applyPermitDefaultValues()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "origins"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void setAllowedOrigins(@Nullable List<String> origins)",
    "source_code": "\tpublic void setAllowedOrigins(@Nullable List<String> origins) {\n\t\tif (origins == null) {\n\t\t\tthis.allowedOrigins = null;\n\t\t}\n\t\telse {\n\t\t\tthis.allowedOrigins = new ArrayList<>(origins.size());\n\t\t\tfor (String origin : origins) {\n\t\t\t\taddAllowedOrigin(origin);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#setExposedHeaders(exposedHeaders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the list of response headers other than simple headers (i.e.\n\t * {@code Cache-Control}, {@code Content-Language}, {@code Content-Type},\n\t * {@code Expires}, {@code Last-Modified}, or {@code Pragma}) that an\n\t * actual response might have and can be exposed.\n\t * <p>The special value {@code \"*\"} allows all headers to be exposed for\n\t * non-credentialed requests.\n\t * <p>By default this is not set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exposedHeaders"
    ],
    "position": {
      "column": 1,
      "line": 399
    },
    "return": "void",
    "signature": "public void setExposedHeaders(@Nullable List<String> exposedHeaders)",
    "source_code": "\tpublic void setExposedHeaders(@Nullable List<String> exposedHeaders) {\n\t\tthis.exposedHeaders = (exposedHeaders != null ? new ArrayList<>(exposedHeaders) : null);\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#setMaxAge(maxAge)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure how long, in seconds, the response from a pre-flight request\n\t * can be cached by clients.\n\t * <p>By default this is not set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "maxAge"
    ],
    "position": {
      "column": 1,
      "line": 457
    },
    "return": "void",
    "signature": "public void setMaxAge(@Nullable Long maxAge)",
    "source_code": "\tpublic void setMaxAge(@Nullable Long maxAge) {\n\t\tthis.maxAge = maxAge;\n\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 763
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn this.declaredPattern;\n\t\t}"
  },
  "org.springframework.web.cors.CorsConfiguration#validateAllowCredentials()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate that when {@link #setAllowCredentials allowCredentials} is {@code true},\n\t * {@link #setAllowedOrigins allowedOrigins} does not contain the special\n\t * value {@code \"*\"} since in that case the \"Access-Control-Allow-Origin\"\n\t * cannot be set to {@code \"*\"}.\n\t * @throws IllegalArgumentException if the validation fails\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 512
    },
    "return": "void",
    "signature": "public void validateAllowCredentials()",
    "source_code": "\tpublic void validateAllowCredentials() {\n\t\tif (this.allowCredentials == Boolean.TRUE &&\n\t\t\t\tthis.allowedOrigins != null && this.allowedOrigins.contains(ALL)) {\n\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"When allowCredentials is true, allowedOrigins cannot contain the special value \\\"*\\\" \" +\n\t\t\t\t\t\t\t\"since that cannot be set on the \\\"Access-Control-Allow-Origin\\\" response header. \" +\n\t\t\t\t\t\t\t\"To allow credentials to a set of origins, list them explicitly \" +\n\t\t\t\t\t\t\t\"or consider using \\\"allowedOriginPatterns\\\" instead.\");\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#getContentAsByteArray()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "byte[]",
    "signature": "public byte[] getContentAsByteArray()",
    "source_code": "\t\tpublic byte[] getContentAsByteArray() throws IOException {\n\t\t\treturn this.encoded.getContentAsByteArray();\n\t\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#getContentAsString(charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "String",
    "signature": "public String getContentAsString(Charset charset)",
    "source_code": "\t\tpublic String getContentAsString(Charset charset) throws IOException {\n\t\t\treturn this.encoded.getContentAsString(charset);\n\t\t}"
  },
  "org.springframework.web.reactive.resource.EncodedResourceResolver#readableChannel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "ReadableByteChannel",
    "signature": "public ReadableByteChannel readableChannel()",
    "source_code": "\t\tpublic ReadableByteChannel readableChannel() throws IOException {\n\t\t\treturn this.encoded.readableChannel();\n\t\t}"
  },
  "org.springframework.web.reactive.resource.VersionResourceResolver#getContentAsByteArray()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "byte[]",
    "signature": "public byte[] getContentAsByteArray()",
    "source_code": "\t\tpublic byte[] getContentAsByteArray() throws IOException {\n\t\t\treturn this.original.getContentAsByteArray();\n\t\t}"
  },
  "org.springframework.web.reactive.resource.VersionResourceResolver#getContentAsString(charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "String",
    "signature": "public String getContentAsString(Charset charset)",
    "source_code": "\t\tpublic String getContentAsString(Charset charset) throws IOException {\n\t\t\treturn this.original.getContentAsString(charset);\n\t\t}"
  },
  "org.springframework.web.reactive.resource.VersionResourceResolver#readableChannel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "ReadableByteChannel",
    "signature": "public ReadableByteChannel readableChannel()",
    "source_code": "\t\tpublic ReadableByteChannel readableChannel() throws IOException {\n\t\t\treturn this.original.readableChannel();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Spring {@link WebSocketSession} implementation that adapts to a Jetty\n * WebSocket {@link org.eclipse.jetty.websocket.api.Session}.\n *\n * @author Violeta Georgieva\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class JettyWebSocketSession",
    "source_code": "public class JettyWebSocketSession extends AbstractListenerWebSocketSession<Session> {\n\n\t@Nullable\n\tprivate volatile SuspendToken suspendToken;\n\n\n\tpublic JettyWebSocketSession(Session session, HandshakeInfo info, DataBufferFactory factory) {\n\t\tthis(session, info, factory, null);\n\t}\n\n\tpublic JettyWebSocketSession(Session session, HandshakeInfo info, DataBufferFactory factory,\n\t\t\t@Nullable Sinks.Empty<Void> completionSink) {\n\n\t\tsuper(session, ObjectUtils.getIdentityHexString(session), info, factory, completionSink);\n\t\t// TODO: suspend causes failures if invoked at this stage\n\t\t// suspendReceiving();\n\t}\n\n\n\t@Override\n\tprotected boolean canSuspendReceiving() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tprotected void suspendReceiving() {\n\t\tAssert.state(this.suspendToken == null, \"Already suspended\");\n\t\tthis.suspendToken = getDelegate().suspend();\n\t}\n\n\t@Override\n\tprotected void resumeReceiving() {\n\t\tSuspendToken tokenToUse = this.suspendToken;\n\t\tthis.suspendToken = null;\n\t\tif (tokenToUse != null) {\n\t\t\ttokenToUse.resume();\n\t\t}\n\t}\n\n\t@Override\n\tprotected boolean sendMessage(WebSocketMessage message) throws IOException {\n\t\tDataBuffer dataBuffer = message.getPayload();\n\t\tRemoteEndpoint remote = getDelegate().getRemote();\n\t\tif (WebSocketMessage.Type.TEXT.equals(message.getType())) {\n\t\t\tgetSendProcessor().setReadyToSend(false);\n\t\t\tString text = dataBuffer.toString(StandardCharsets.UTF_8);\n\t\t\tremote.sendString(text, new SendProcessorCallback());\n\t\t}\n\t\telse {\n\t\t\tif (WebSocketMessage.Type.BINARY.equals(message.getType())) {\n\t\t\t\tgetSendProcessor().setReadyToSend(false);\n\t\t\t}\n\t\t\ttry (DataBuffer.ByteBufferIterator iterator = dataBuffer.readableByteBuffers()) {\n\t\t\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tByteBuffer byteBuffer = iterator.next();\n\t\t\t\t\tswitch (message.getType()) {\n\t\t\t\t\t\tcase BINARY -> remote.sendBytes(byteBuffer, new SendProcessorCallback());\n\t\t\t\t\t\tcase PING -> remote.sendPing(byteBuffer);\n\t\t\t\t\t\tcase PONG -> remote.sendPong(byteBuffer);\n\t\t\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected message type: \" + message.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isOpen() {\n\t\treturn getDelegate().isOpen();\n\t}\n\n\t@Override\n\tpublic Mono<Void> close(CloseStatus status) {\n\t\tgetDelegate().close(status.getCode(), status.getReason());\n\t\treturn Mono.empty();\n\t}\n\n\n\tprivate final class SendProcessorCallback implements WriteCallback {\n\n\t\t@Override\n\t\tpublic void writeFailed(Throwable x) {\n\t\t\tgetSendProcessor().cancel();\n\t\t\tgetSendProcessor().onError(x);\n\t\t}\n\n\t\t@Override\n\t\tpublic void writeSuccess() {\n\t\t\tgetSendProcessor().setReadyToSend(true);\n\t\t\tgetSendProcessor().onWritePossible();\n\t\t}\n\n\t}\n\n}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#canSuspendReceiving()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "boolean",
    "signature": "protected boolean canSuspendReceiving()",
    "source_code": "\tprotected boolean canSuspendReceiving() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#close(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> close(CloseStatus status)",
    "source_code": "\tpublic Mono<Void> close(CloseStatus status) {\n\t\tgetDelegate().close(status.getCode(), status.getReason());\n\t\treturn Mono.empty();\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#isOpen()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "boolean",
    "signature": "public boolean isOpen()",
    "source_code": "\tpublic boolean isOpen() {\n\t\treturn getDelegate().isOpen();\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#resumeReceiving()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "protected void resumeReceiving()",
    "source_code": "\tprotected void resumeReceiving() {\n\t\tSuspendToken tokenToUse = this.suspendToken;\n\t\tthis.suspendToken = null;\n\t\tif (tokenToUse != null) {\n\t\t\ttokenToUse.resume();\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#sendMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "boolean",
    "signature": "protected boolean sendMessage(WebSocketMessage message)",
    "source_code": "\tprotected boolean sendMessage(WebSocketMessage message) throws IOException {\n\t\tDataBuffer dataBuffer = message.getPayload();\n\t\tRemoteEndpoint remote = getDelegate().getRemote();\n\t\tif (WebSocketMessage.Type.TEXT.equals(message.getType())) {\n\t\t\tgetSendProcessor().setReadyToSend(false);\n\t\t\tString text = dataBuffer.toString(StandardCharsets.UTF_8);\n\t\t\tremote.sendString(text, new SendProcessorCallback());\n\t\t}\n\t\telse {\n\t\t\tif (WebSocketMessage.Type.BINARY.equals(message.getType())) {\n\t\t\t\tgetSendProcessor().setReadyToSend(false);\n\t\t\t}\n\t\t\ttry (DataBuffer.ByteBufferIterator iterator = dataBuffer.readableByteBuffers()) {\n\t\t\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tByteBuffer byteBuffer = iterator.next();\n\t\t\t\t\tswitch (message.getType()) {\n\t\t\t\t\t\tcase BINARY -> remote.sendBytes(byteBuffer, new SendProcessorCallback());\n\t\t\t\t\t\tcase PING -> remote.sendPing(byteBuffer);\n\t\t\t\t\t\tcase PONG -> remote.sendPong(byteBuffer);\n\t\t\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected message type: \" + message.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#suspendReceiving()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "protected void suspendReceiving()",
    "source_code": "\tprotected void suspendReceiving() {\n\t\tAssert.state(this.suspendToken == null, \"Already suspended\");\n\t\tthis.suspendToken = getDelegate().suspend();\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#writeFailed(x)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "x"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void writeFailed(Throwable x)",
    "source_code": "\t\tpublic void writeFailed(Throwable x) {\n\t\t\tgetSendProcessor().cancel();\n\t\t\tgetSendProcessor().onError(x);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#writeSuccess()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "public void writeSuccess()",
    "source_code": "\t\tpublic void writeSuccess() {\n\t\t\tgetSendProcessor().setReadyToSend(true);\n\t\t\tgetSendProcessor().onWritePossible();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.StandardWebSocketSession": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Spring {@link WebSocketSession} adapter for a standard Java (JSR 356)\n * {@link jakarta.websocket.Session}.\n *\n * @author Violeta Georgieva\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class StandardWebSocketSession",
    "source_code": "public class StandardWebSocketSession extends AbstractListenerWebSocketSession<Session> {\n\n\tpublic StandardWebSocketSession(Session session, HandshakeInfo info, DataBufferFactory factory) {\n\t\tthis(session, info, factory, null);\n\t}\n\n\tpublic StandardWebSocketSession(Session session, HandshakeInfo info, DataBufferFactory factory,\n\t\t\t@Nullable Sinks.Empty<Void> completionSink) {\n\n\t\tsuper(session, session.getId(), info, factory, completionSink);\n\t}\n\n\n\t@Override\n\tprotected boolean canSuspendReceiving() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tprotected void suspendReceiving() {\n\t\t// no-op\n\t}\n\n\t@Override\n\tprotected void resumeReceiving() {\n\t\t// no-op\n\t}\n\n\t@Override\n\tprotected boolean sendMessage(WebSocketMessage message) throws IOException {\n\t\tDataBuffer dataBuffer = message.getPayload();\n\t\tRemoteEndpoint.Async remote = getDelegate().getAsyncRemote();\n\t\tif (WebSocketMessage.Type.TEXT.equals(message.getType())) {\n\t\t\tgetSendProcessor().setReadyToSend(false);\n\t\t\tString text = dataBuffer.toString(StandardCharsets.UTF_8);\n\t\t\tremote.sendText(text, new SendProcessorCallback());\n\t\t}\n\t\telse {\n\t\t\tif (WebSocketMessage.Type.BINARY.equals(message.getType())) {\n\t\t\t\tgetSendProcessor().setReadyToSend(false);\n\t\t\t}\n\t\t\ttry (DataBuffer.ByteBufferIterator iterator = dataBuffer.readableByteBuffers()) {\n\t\t\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tByteBuffer byteBuffer = iterator.next();\n\t\t\t\t\tswitch (message.getType()) {\n\t\t\t\t\t\tcase BINARY -> remote.sendBinary(byteBuffer, new SendProcessorCallback());\n\t\t\t\t\t\tcase PING -> remote.sendPing(byteBuffer);\n\t\t\t\t\t\tcase PONG -> remote.sendPong(byteBuffer);\n\t\t\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected message type: \" + message.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isOpen() {\n\t\treturn getDelegate().isOpen();\n\t}\n\n\t@Override\n\tpublic Mono<Void> close(CloseStatus status) {\n\t\ttry {\n\t\t\tCloseReason.CloseCode code = CloseCodes.getCloseCode(status.getCode());\n\t\t\tgetDelegate().close(new CloseReason(code, status.getReason()));\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t\treturn Mono.empty();\n\t}\n\n\n\tprivate final class SendProcessorCallback implements SendHandler {\n\n\t\t@Override\n\t\tpublic void onResult(SendResult result) {\n\t\t\tif (result.isOK()) {\n\t\t\t\tgetSendProcessor().setReadyToSend(true);\n\t\t\t\tgetSendProcessor().onWritePossible();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgetSendProcessor().cancel();\n\t\t\t\tgetSendProcessor().onError(result.getException());\n\t\t\t}\n\t\t}\n\n\t}\n\n}"
  },
  "org.springframework.web.reactive.socket.adapter.StandardWebSocketSession#canSuspendReceiving()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "boolean",
    "signature": "protected boolean canSuspendReceiving()",
    "source_code": "\tprotected boolean canSuspendReceiving() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.StandardWebSocketSession#close(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> close(CloseStatus status)",
    "source_code": "\tpublic Mono<Void> close(CloseStatus status) {\n\t\ttry {\n\t\t\tCloseReason.CloseCode code = CloseCodes.getCloseCode(status.getCode());\n\t\t\tgetDelegate().close(new CloseReason(code, status.getReason()));\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t\treturn Mono.empty();\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.StandardWebSocketSession#isOpen()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "boolean",
    "signature": "public boolean isOpen()",
    "source_code": "\tpublic boolean isOpen() {\n\t\treturn getDelegate().isOpen();\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.StandardWebSocketSession#onResult(result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void onResult(SendResult result)",
    "source_code": "\t\tpublic void onResult(SendResult result) {\n\t\t\tif (result.isOK()) {\n\t\t\t\tgetSendProcessor().setReadyToSend(true);\n\t\t\t\tgetSendProcessor().onWritePossible();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgetSendProcessor().cancel();\n\t\t\t\tgetSendProcessor().onError(result.getException());\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.StandardWebSocketSession#resumeReceiving()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "protected void resumeReceiving()",
    "source_code": "\tprotected void resumeReceiving() {\n\t\t// no-op\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.StandardWebSocketSession#sendMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "boolean",
    "signature": "protected boolean sendMessage(WebSocketMessage message)",
    "source_code": "\tprotected boolean sendMessage(WebSocketMessage message) throws IOException {\n\t\tDataBuffer dataBuffer = message.getPayload();\n\t\tRemoteEndpoint.Async remote = getDelegate().getAsyncRemote();\n\t\tif (WebSocketMessage.Type.TEXT.equals(message.getType())) {\n\t\t\tgetSendProcessor().setReadyToSend(false);\n\t\t\tString text = dataBuffer.toString(StandardCharsets.UTF_8);\n\t\t\tremote.sendText(text, new SendProcessorCallback());\n\t\t}\n\t\telse {\n\t\t\tif (WebSocketMessage.Type.BINARY.equals(message.getType())) {\n\t\t\t\tgetSendProcessor().setReadyToSend(false);\n\t\t\t}\n\t\t\ttry (DataBuffer.ByteBufferIterator iterator = dataBuffer.readableByteBuffers()) {\n\t\t\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tByteBuffer byteBuffer = iterator.next();\n\t\t\t\t\tswitch (message.getType()) {\n\t\t\t\t\t\tcase BINARY -> remote.sendBinary(byteBuffer, new SendProcessorCallback());\n\t\t\t\t\t\tcase PING -> remote.sendPing(byteBuffer);\n\t\t\t\t\t\tcase PONG -> remote.sendPong(byteBuffer);\n\t\t\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected message type: \" + message.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.StandardWebSocketSession#suspendReceiving()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "protected void suspendReceiving()",
    "source_code": "\tprotected void suspendReceiving() {\n\t\t// no-op\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.UndertowWebSocketSession": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Spring {@link WebSocketSession} implementation that adapts to an Undertow\n * {@link io.undertow.websockets.core.WebSocketChannel}.\n *\n * @author Violeta Georgieva\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public class UndertowWebSocketSession",
    "source_code": "public class UndertowWebSocketSession extends AbstractListenerWebSocketSession<WebSocketChannel> {\n\n\tpublic UndertowWebSocketSession(WebSocketChannel channel, HandshakeInfo info, DataBufferFactory factory) {\n\t\tthis(channel, info, factory, null);\n\t}\n\n\tpublic UndertowWebSocketSession(WebSocketChannel channel, HandshakeInfo info,\n\t\t\tDataBufferFactory factory, @Nullable Sinks.Empty<Void> completionSink) {\n\n\t\tsuper(channel, ObjectUtils.getIdentityHexString(channel), info, factory, completionSink);\n\t\tsuspendReceiving();\n\t}\n\n\n\t@Override\n\tprotected boolean canSuspendReceiving() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tprotected void suspendReceiving() {\n\t\tgetDelegate().suspendReceives();\n\t}\n\n\t@Override\n\tprotected void resumeReceiving() {\n\t\tgetDelegate().resumeReceives();\n\t}\n\n\t@Override\n\tprotected boolean sendMessage(WebSocketMessage message) throws IOException {\n\t\tDataBuffer dataBuffer = message.getPayload();\n\t\tWebSocketChannel channel = getDelegate();\n\t\tif (WebSocketMessage.Type.TEXT.equals(message.getType())) {\n\t\t\tgetSendProcessor().setReadyToSend(false);\n\t\t\tString text = dataBuffer.toString(StandardCharsets.UTF_8);\n\t\t\tWebSockets.sendText(text, channel, new SendProcessorCallback(message.getPayload()));\n\t\t}\n\t\telse {\n\t\t\tgetSendProcessor().setReadyToSend(false);\n\t\t\ttry (DataBuffer.ByteBufferIterator iterator = dataBuffer.readableByteBuffers()) {\n\t\t\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tByteBuffer byteBuffer = iterator.next();\n\t\t\t\t\tswitch (message.getType()) {\n\t\t\t\t\t\tcase BINARY -> WebSockets.sendBinary(byteBuffer, channel, new SendProcessorCallback(dataBuffer));\n\t\t\t\t\t\tcase PING -> WebSockets.sendPing(byteBuffer, channel, new SendProcessorCallback(dataBuffer));\n\t\t\t\t\t\tcase PONG -> WebSockets.sendPong(byteBuffer, channel, new SendProcessorCallback(dataBuffer));\n\t\t\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected message type: \" + message.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isOpen() {\n\t\treturn getDelegate().isOpen();\n\t}\n\n\t@Override\n\tpublic Mono<Void> close(CloseStatus status) {\n\t\tCloseMessage cm = new CloseMessage(status.getCode(), status.getReason());\n\t\tif (!getDelegate().isCloseFrameSent()) {\n\t\t\tWebSockets.sendClose(cm, getDelegate(), null);\n\t\t}\n\t\treturn Mono.empty();\n\t}\n\n\n\tprivate final class SendProcessorCallback implements WebSocketCallback<Void> {\n\n\t\tprivate final DataBuffer payload;\n\n\t\tSendProcessorCallback(DataBuffer payload) {\n\t\t\tthis.payload = payload;\n\t\t}\n\n\t\t@Override\n\t\tpublic void complete(WebSocketChannel channel, Void context) {\n\t\t\tDataBufferUtils.release(this.payload);\n\t\t\tgetSendProcessor().setReadyToSend(true);\n\t\t\tgetSendProcessor().onWritePossible();\n\t\t}\n\n\t\t@Override\n\t\tpublic void onError(WebSocketChannel channel, Void context, Throwable throwable) {\n\t\t\tDataBufferUtils.release(this.payload);\n\t\t\tgetSendProcessor().cancel();\n\t\t\tgetSendProcessor().onError(throwable);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.socket.adapter.UndertowWebSocketSession#canSuspendReceiving()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "boolean",
    "signature": "protected boolean canSuspendReceiving()",
    "source_code": "\tprotected boolean canSuspendReceiving() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.UndertowWebSocketSession#close(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> close(CloseStatus status)",
    "source_code": "\tpublic Mono<Void> close(CloseStatus status) {\n\t\tCloseMessage cm = new CloseMessage(status.getCode(), status.getReason());\n\t\tif (!getDelegate().isCloseFrameSent()) {\n\t\t\tWebSockets.sendClose(cm, getDelegate(), null);\n\t\t}\n\t\treturn Mono.empty();\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.UndertowWebSocketSession#complete(channel,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channel",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void complete(WebSocketChannel channel, Void context)",
    "source_code": "\t\tpublic void complete(WebSocketChannel channel, Void context) {\n\t\t\tDataBufferUtils.release(this.payload);\n\t\t\tgetSendProcessor().setReadyToSend(true);\n\t\t\tgetSendProcessor().onWritePossible();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.UndertowWebSocketSession#isOpen()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "boolean",
    "signature": "public boolean isOpen()",
    "source_code": "\tpublic boolean isOpen() {\n\t\treturn getDelegate().isOpen();\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.UndertowWebSocketSession#onError(channel,context,throwable)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channel",
      "context",
      "throwable"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void onError(WebSocketChannel channel, Void context, Throwable throwable)",
    "source_code": "\t\tpublic void onError(WebSocketChannel channel, Void context, Throwable throwable) {\n\t\t\tDataBufferUtils.release(this.payload);\n\t\t\tgetSendProcessor().cancel();\n\t\t\tgetSendProcessor().onError(throwable);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.UndertowWebSocketSession#resumeReceiving()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "protected void resumeReceiving()",
    "source_code": "\tprotected void resumeReceiving() {\n\t\tgetDelegate().resumeReceives();\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.UndertowWebSocketSession#sendMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "boolean",
    "signature": "protected boolean sendMessage(WebSocketMessage message)",
    "source_code": "\tprotected boolean sendMessage(WebSocketMessage message) throws IOException {\n\t\tDataBuffer dataBuffer = message.getPayload();\n\t\tWebSocketChannel channel = getDelegate();\n\t\tif (WebSocketMessage.Type.TEXT.equals(message.getType())) {\n\t\t\tgetSendProcessor().setReadyToSend(false);\n\t\t\tString text = dataBuffer.toString(StandardCharsets.UTF_8);\n\t\t\tWebSockets.sendText(text, channel, new SendProcessorCallback(message.getPayload()));\n\t\t}\n\t\telse {\n\t\t\tgetSendProcessor().setReadyToSend(false);\n\t\t\ttry (DataBuffer.ByteBufferIterator iterator = dataBuffer.readableByteBuffers()) {\n\t\t\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tByteBuffer byteBuffer = iterator.next();\n\t\t\t\t\tswitch (message.getType()) {\n\t\t\t\t\t\tcase BINARY -> WebSockets.sendBinary(byteBuffer, channel, new SendProcessorCallback(dataBuffer));\n\t\t\t\t\t\tcase PING -> WebSockets.sendPing(byteBuffer, channel, new SendProcessorCallback(dataBuffer));\n\t\t\t\t\t\tcase PONG -> WebSockets.sendPong(byteBuffer, channel, new SendProcessorCallback(dataBuffer));\n\t\t\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected message type: \" + message.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.UndertowWebSocketSession#suspendReceiving()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "void",
    "signature": "protected void suspendReceiving()",
    "source_code": "\tprotected void suspendReceiving() {\n\t\tgetDelegate().suspendReceives();\n\t}"
  },
  "org.springframework.web.service.invoker.HttpServiceProxyFactory#invokeSuspendingFunction(invocation,httpServiceMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invocation",
      "httpServiceMethod"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "Object",
    "signature": "public Object invokeSuspendingFunction(MethodInvocation invocation, HttpServiceMethod httpServiceMethod)",
    "source_code": "\t\tpublic static Object invokeSuspendingFunction(MethodInvocation invocation, HttpServiceMethod httpServiceMethod) {\n\t\t\tObject[] rawArguments = invocation.getArguments();\n\t\t\tObject[] arguments = resolveArguments(rawArguments);\n\t\t\tContinuation<Object> continuation = (Continuation<Object>) rawArguments[rawArguments.length - 1];\n\t\t\tMono<Object> wrapped = (Mono<Object>) httpServiceMethod.invoke(arguments);\n\t\t\treturn MonoKt.awaitSingleOrNull(wrapped, continuation);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.AbstractHandlerMapping#getAdaptedInterceptors()": {
    "change": "modifier_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return all configured interceptors adapted to {@link HandlerInterceptor}.\n\t * @return the array of configured interceptors, or {@code null} if none\n\t * are configured; this method also returns {@code null} if called too early,\n\t * or more specifically before\n\t * {@link org.springframework.context.ApplicationContextAware#setApplicationContext}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "HandlerInterceptor[]",
    "signature": "public HandlerInterceptor[] getAdaptedInterceptors()",
    "source_code": "\tpublic final HandlerInterceptor[] getAdaptedInterceptors() {\n\t\treturn (!this.adaptedInterceptors.isEmpty() ?\n\t\t\t\tthis.adaptedInterceptors.toArray(new HandlerInterceptor[0]) : null);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#connect(adapter,returnValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "adapter",
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 460
    },
    "return": "void",
    "signature": "public void connect(ReactiveAdapter adapter, Object returnValue)",
    "source_code": "\t\tpublic void connect(ReactiveAdapter adapter, Object returnValue) {\n\t\t\tPublisher<Object> publisher = adapter.toPublisher(returnValue);\n\t\t\tpublisher.subscribe(this);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#extendResponse(outputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "void",
    "signature": "protected void extendResponse(ServerHttpResponse outputMessage)",
    "source_code": "\t\t\tprotected void extendResponse(ServerHttpResponse outputMessage) {\n\t\t\t\toutputMessage.getHeaders().setContentType(mediaType);\n\t\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#getEmitter()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "ResponseBodyEmitter",
    "signature": "protected ResponseBodyEmitter getEmitter()",
    "source_code": "\t\tprotected ResponseBodyEmitter getEmitter() {\n\t\t\treturn this.emitter;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#getReturnType()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 508
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType getReturnType()",
    "source_code": "\t\tpublic ResolvableType getReturnType() {\n\t\t\treturn ResolvableType.forClassWithGenerics(List.class, this.elementType);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleValue(returnValue,returnType,mav,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given reactive return value and decide whether to adapt it\n\t * to a {@link ResponseBodyEmitter} or a {@link DeferredResult}.\n\t * @return an emitter for streaming, or {@code null} if handled internally\n\t * with a {@link DeferredResult}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mav",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "ResponseBodyEmitter",
    "signature": "public ResponseBodyEmitter handleValue(Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mav, NativeWebRequest request)",
    "source_code": "\tpublic ResponseBodyEmitter handleValue(Object returnValue, MethodParameter returnType,"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#isReactiveType(type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the type can be adapted to a Reactive Streams {@link Publisher}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "boolean",
    "signature": "public boolean isReactiveType(Class<?> type)",
    "source_code": "\tpublic boolean isReactiveType(Class<?> type) {\n\t\treturn (this.adapterRegistry.getAdapter(type) != null);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#onComplete()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 482
    },
    "return": "void",
    "signature": "public void onComplete()",
    "source_code": "\t\tpublic void onComplete() {\n\t\t\tif (this.values.size() > 1 || this.multiValueSource) {\n\t\t\t\tthis.result.setResult(this.values);\n\t\t\t}\n\t\t\telse if (this.values.size() == 1) {\n\t\t\t\tthis.result.setResult(this.values.get(0));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.result.setResult(null);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#onError(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 477
    },
    "return": "void",
    "signature": "public void onError(Throwable ex)",
    "source_code": "\t\tpublic void onError(Throwable ex) {\n\t\t\tthis.result.setErrorResult(ex);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#onNext(element)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element"
    ],
    "position": {
      "column": 1,
      "line": 472
    },
    "return": "void",
    "signature": "public void onNext(Object element)",
    "source_code": "\t\tpublic void onNext(Object element) {\n\t\t\tthis.values.add(element);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#onSubscribe(subscription)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 466
    },
    "return": "void",
    "signature": "public void onSubscribe(Subscription subscription)",
    "source_code": "\t\tpublic void onSubscribe(Subscription subscription) {\n\t\t\tthis.result.onTimeout(subscription::cancel);\n\t\t\tsubscription.request(Long.MAX_VALUE);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#run()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "void",
    "signature": "public void run()",
    "source_code": "\t\tpublic void run() {\n\t\t\tif (this.done) {\n\t\t\t\tthis.elementRef.lazySet(null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check terminal signal before processing element..\n\t\t\tboolean isTerminated = this.terminated;\n\n\t\t\tObject element = this.elementRef.get();\n\t\t\tif (element != null) {\n\t\t\t\tthis.elementRef.lazySet(null);\n\t\t\t\tAssert.state(this.subscription != null, \"No subscription\");\n\t\t\t\ttry {\n\t\t\t\t\tsend(element);\n\t\t\t\t\tthis.subscription.request(1);\n\t\t\t\t}\n\t\t\t\tcatch (final Throwable ex) {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Send for \" + this.emitter + \" failed: \" + ex);\n\t\t\t\t\t}\n\t\t\t\t\tterminate();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isTerminated) {\n\t\t\t\tthis.done = true;\n\t\t\t\tThrowable ex = this.error;\n\t\t\t\tthis.error = null;\n\t\t\t\tif (ex != null) {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Publisher for \" + this.emitter + \" failed: \" + ex);\n\t\t\t\t\t}\n\t\t\t\t\tthis.emitter.completeWithError(ex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Publisher for \" + this.emitter + \" completed\");\n\t\t\t\t\t}\n\t\t\t\t\tthis.emitter.complete();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.executing.decrementAndGet() != 0) {\n\t\t\t\tschedule();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#send(element)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element"
    ],
    "position": {
      "column": 1,
      "line": 440
    },
    "return": "void",
    "signature": "protected void send(Object element)",
    "source_code": "\t\tprotected void send(Object element) throws IOException {\n\t\t\tgetEmitter().send(element, MediaType.TEXT_PLAIN);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#writeReactorContext(returnValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 516
    },
    "return": "Object",
    "signature": "public Object writeReactorContext(Object returnValue)",
    "source_code": "\t\tpublic static Object writeReactorContext(Object returnValue) {\n\t\t\tif (Mono.class.isAssignableFrom(returnValue.getClass())) {\n\t\t\t\tContextSnapshot snapshot = ContextSnapshot.captureAll();\n\t\t\t\treturn ((Mono<?>) returnValue).contextWrite(snapshot::updateContext);\n\t\t\t}\n\t\t\telse if (Flux.class.isAssignableFrom(returnValue.getClass())) {\n\t\t\t\tContextSnapshot snapshot = ContextSnapshot.captureAll();\n\t\t\t\treturn ((Flux<?>) returnValue).contextWrite(snapshot::updateContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn returnValue;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.resource.VersionResourceResolver#getContentAsByteArray()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "byte[]",
    "signature": "public byte[] getContentAsByteArray()",
    "source_code": "\t\tpublic byte[] getContentAsByteArray() throws IOException {\n\t\t\treturn this.original.getContentAsByteArray();\n\t\t}"
  },
  "org.springframework.web.servlet.resource.VersionResourceResolver#getContentAsString(charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "String",
    "signature": "public String getContentAsString(Charset charset)",
    "source_code": "\t\tpublic String getContentAsString(Charset charset) throws IOException {\n\t\t\treturn this.original.getContentAsString(charset);\n\t\t}"
  },
  "org.springframework.web.servlet.resource.VersionResourceResolver#readableChannel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "ReadableByteChannel",
    "signature": "public ReadableByteChannel readableChannel()",
    "source_code": "\t\tpublic ReadableByteChannel readableChannel() throws IOException {\n\t\t\treturn this.original.readableChannel();\n\t\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractMultiCheckedElementTag": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Abstract base class to provide common methods for implementing\n * databinding-aware JSP tags for rendering <i>multiple</i>\n * HTML '{@code input}' elements with a '{@code type}'\n * of '{@code checkbox}' or '{@code radio}'.\n *\n * @author Juergen Hoeller\n * @author Scott Andrews\n * @since 2.5.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public class AbstractMultiCheckedElementTag",
    "source_code": "public abstract class AbstractMultiCheckedElementTag extends AbstractCheckedElementTag {\n\n\t/**\n\t * The HTML '{@code span}' tag.\n\t */\n\tprivate static final String SPAN_TAG = \"span\";\n\n\n\t/**\n\t * The {@link java.util.Collection}, {@link java.util.Map} or array of objects\n\t * used to generate the '{@code input type=\"checkbox/radio\"}' tags.\n\t */\n\t@Nullable\n\tprivate Object items;\n\n\t/**\n\t * The name of the property mapped to the '{@code value}' attribute\n\t * of the '{@code input type=\"checkbox/radio\"}' tag.\n\t */\n\t@Nullable\n\tprivate String itemValue;\n\n\t/**\n\t * The value to be displayed as part of the '{@code input type=\"checkbox/radio\"}' tag.\n\t */\n\t@Nullable\n\tprivate String itemLabel;\n\n\t/**\n\t * The HTML element used to enclose the '{@code input type=\"checkbox/radio\"}' tag.\n\t */\n\tprivate String element = SPAN_TAG;\n\n\t/**\n\t * Delimiter to use between each '{@code input type=\"checkbox/radio\"}' tags.\n\t */\n\t@Nullable\n\tprivate String delimiter;\n\n\n\t/**\n\t * Set the {@link java.util.Collection}, {@link java.util.Map} or array of objects\n\t * used to generate the '{@code input type=\"checkbox/radio\"}' tags.\n\t * <p>Typically a runtime expression.\n\t * @param items said items\n\t */\n\tpublic void setItems(Object items) {\n\t\tAssert.notNull(items, \"'items' must not be null\");\n\t\tthis.items = items;\n\t}\n\n\t/**\n\t * Get the {@link java.util.Collection}, {@link java.util.Map} or array of objects\n\t * used to generate the '{@code input type=\"checkbox/radio\"}' tags.\n\t */\n\t@Nullable\n\tprotected Object getItems() {\n\t\treturn this.items;\n\t}\n\n\t/**\n\t * Set the name of the property mapped to the '{@code value}' attribute\n\t * of the '{@code input type=\"checkbox/radio\"}' tag.\n\t * <p>May be a runtime expression.\n\t */\n\tpublic void setItemValue(String itemValue) {\n\t\tAssert.hasText(itemValue, \"'itemValue' must not be empty\");\n\t\tthis.itemValue = itemValue;\n\t}\n\n\t/**\n\t * Get the name of the property mapped to the '{@code value}' attribute\n\t * of the '{@code input type=\"checkbox/radio\"}' tag.\n\t */\n\t@Nullable\n\tprotected String getItemValue() {\n\t\treturn this.itemValue;\n\t}\n\n\t/**\n\t * Set the value to be displayed as part of the\n\t * '{@code input type=\"checkbox/radio\"}' tag.\n\t * <p>May be a runtime expression.\n\t */\n\tpublic void setItemLabel(String itemLabel) {\n\t\tAssert.hasText(itemLabel, \"'itemLabel' must not be empty\");\n\t\tthis.itemLabel = itemLabel;\n\t}\n\n\t/**\n\t * Get the value to be displayed as part of the\n\t * '{@code input type=\"checkbox/radio\"}' tag.\n\t */\n\t@Nullable\n\tprotected String getItemLabel() {\n\t\treturn this.itemLabel;\n\t}\n\n\t/**\n\t * Set the delimiter to be used between each\n\t * '{@code input type=\"checkbox/radio\"}' tag.\n\t * <p>By default, there is <em>no</em> delimiter.\n\t */\n\tpublic void setDelimiter(String delimiter) {\n\t\tthis.delimiter = delimiter;\n\t}\n\n\t/**\n\t * Return the delimiter to be used between each\n\t * '{@code input type=\"radio\"}' tag.\n\t */\n\t@Nullable\n\tpublic String getDelimiter() {\n\t\treturn this.delimiter;\n\t}\n\n\t/**\n\t * Set the HTML element used to enclose the\n\t * '{@code input type=\"checkbox/radio\"}' tag.\n\t * <p>Defaults to an HTML '{@code <span/>}' tag.\n\t */\n\tpublic void setElement(String element) {\n\t\tAssert.hasText(element, \"'element' cannot be null or blank\");\n\t\tthis.element = element;\n\t}\n\n\t/**\n\t * Get the HTML element used to enclose\n\t * '{@code input type=\"checkbox/radio\"}' tag.\n\t */\n\tpublic String getElement() {\n\t\treturn this.element;\n\t}\n\n\n\t/**\n\t * Appends a counter to a specified id as well,\n\t * since we're dealing with multiple HTML elements.\n\t */\n\t@Override\n\tprotected String resolveId() throws JspException {\n\t\tObject id = evaluate(\"id\", getId());\n\t\tif (id != null) {\n\t\t\tString idString = id.toString();\n\t\t\treturn (StringUtils.hasText(idString) ? TagIdGenerator.nextId(idString, this.pageContext) : null);\n\t\t}\n\t\treturn autogenerateId();\n\t}\n\n\t/**\n\t * Renders the '{@code input type=\"radio\"}' element with the configured\n\t * {@link #setItems(Object)} values. Marks the element as checked if the\n\t * value matches the bound value.\n\t */\n\t@Override\n\t@SuppressWarnings(\"rawtypes\")\n\tprotected int writeTagContent(TagWriter tagWriter) throws JspException {\n\t\tObject items = getItems();\n\t\tObject itemsObject = (items instanceof String ? evaluate(\"items\", items) : items);\n\n\t\tString itemValue = getItemValue();\n\t\tString itemLabel = getItemLabel();\n\t\tString valueProperty =\n\t\t\t\t(itemValue != null ? ObjectUtils.getDisplayString(evaluate(\"itemValue\", itemValue)) : null);\n\t\tString labelProperty =\n\t\t\t\t(itemLabel != null ? ObjectUtils.getDisplayString(evaluate(\"itemLabel\", itemLabel)) : null);\n\n\t\tClass<?> boundType = getBindStatus().getValueType();\n\t\tif (itemsObject == null && boundType != null && boundType.isEnum()) {\n\t\t\titemsObject = boundType.getEnumConstants();\n\t\t}\n\n\t\tif (itemsObject == null) {\n\t\t\tthrow new IllegalArgumentException(\"Attribute 'items' is required and must be a Collection, an Array or a Map\");\n\t\t}\n\n\t\tif (itemsObject.getClass().isArray()) {\n\t\t\tObject[] itemsArray = (Object[]) itemsObject;\n\t\t\tfor (int i = 0; i < itemsArray.length; i++) {\n\t\t\t\tObject item = itemsArray[i];\n\t\t\t\twriteObjectEntry(tagWriter, valueProperty, labelProperty, item, i);\n\t\t\t}\n\t\t}\n\t\telse if (itemsObject instanceof final Collection<?> optionCollection) {\n\t\t\tint itemIndex = 0;\n\t\t\tfor (Iterator<?> it = optionCollection.iterator(); it.hasNext(); itemIndex++) {\n\t\t\t\tObject item = it.next();\n\t\t\t\twriteObjectEntry(tagWriter, valueProperty, labelProperty, item, itemIndex);\n\t\t\t}\n\t\t}\n\t\telse if (itemsObject instanceof final Map<?, ?> optionMap) {\n\t\t\tint itemIndex = 0;\n\t\t\tfor (Iterator it = optionMap.entrySet().iterator(); it.hasNext(); itemIndex++) {\n\t\t\t\tMap.Entry entry = (Map.Entry) it.next();\n\t\t\t\twriteMapEntry(tagWriter, valueProperty, labelProperty, entry, itemIndex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Attribute 'items' must be an array, a Collection or a Map\");\n\t\t}\n\n\t\treturn SKIP_BODY;\n\t}\n\n\tprivate void writeObjectEntry(TagWriter tagWriter, @Nullable String valueProperty,\n\t\t\t@Nullable String labelProperty, Object item, int itemIndex) throws JspException {\n\n\t\tBeanWrapper wrapper = PropertyAccessorFactory.forBeanPropertyAccess(item);\n\t\tObject renderValue;\n\t\tif (valueProperty != null) {\n\t\t\trenderValue = wrapper.getPropertyValue(valueProperty);\n\t\t}\n\t\telse if (item instanceof Enum) {\n\t\t\trenderValue = ((Enum<?>) item).name();\n\t\t}\n\t\telse {\n\t\t\trenderValue = item;\n\t\t}\n\t\tObject renderLabel = (labelProperty != null ? wrapper.getPropertyValue(labelProperty) : item);\n\t\twriteElementTag(tagWriter, item, renderValue, renderLabel, itemIndex);\n\t}\n\n\tprivate void writeMapEntry(TagWriter tagWriter, @Nullable String valueProperty,\n\t\t\t@Nullable String labelProperty, Map.Entry<?, ?> entry, int itemIndex) throws JspException {\n\n\t\tObject mapKey = entry.getKey();\n\t\tObject mapValue = entry.getValue();\n\t\tBeanWrapper mapKeyWrapper = PropertyAccessorFactory.forBeanPropertyAccess(mapKey);\n\t\tBeanWrapper mapValueWrapper = PropertyAccessorFactory.forBeanPropertyAccess(mapValue);\n\t\tObject renderValue = (valueProperty != null ?\n\t\t\t\tmapKeyWrapper.getPropertyValue(valueProperty) : mapKey.toString());\n\t\tObject renderLabel = (labelProperty != null ?\n\t\t\t\tmapValueWrapper.getPropertyValue(labelProperty) : mapValue.toString());\n\t\twriteElementTag(tagWriter, mapKey, renderValue, renderLabel, itemIndex);\n\t}\n\n\tprivate void writeElementTag(TagWriter tagWriter, Object item, @Nullable Object value,\n\t\t\t@Nullable Object label, int itemIndex) throws JspException {\n\n\t\ttagWriter.startTag(getElement());\n\t\tif (itemIndex > 0) {\n\t\t\tObject resolvedDelimiter = evaluate(\"delimiter\", getDelimiter());\n\t\t\tif (resolvedDelimiter != null) {\n\t\t\t\ttagWriter.appendValue(resolvedDelimiter.toString());\n\t\t\t}\n\t\t}\n\t\ttagWriter.startTag(\"input\");\n\t\tString id = resolveId();\n\t\tAssert.state(id != null, \"Attribute 'id' is required\");\n\t\twriteOptionalAttribute(tagWriter, \"id\", id);\n\t\twriteOptionalAttribute(tagWriter, \"name\", getName());\n\t\twriteOptionalAttributes(tagWriter);\n\t\ttagWriter.writeAttribute(\"type\", getInputType());\n\t\trenderFromValue(item, value, tagWriter);\n\t\ttagWriter.endTag();\n\t\ttagWriter.startTag(\"label\");\n\t\ttagWriter.writeAttribute(\"for\", id);\n\t\ttagWriter.appendValue(convertToDisplayString(label));\n\t\ttagWriter.endTag();\n\t\ttagWriter.endTag();\n\t}\n\n}"
  },
  "org.springframework.web.servlet.tags.form.AbstractMultiCheckedElementTag#getDelimiter()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the delimiter to be used between each\n\t * '{@code input type=\"radio\"}' tag.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "String",
    "signature": "public String getDelimiter()",
    "source_code": "\tpublic String getDelimiter() {\n\t\treturn this.delimiter;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractMultiCheckedElementTag#getElement()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the HTML element used to enclose\n\t * '{@code input type=\"checkbox/radio\"}' tag.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "String",
    "signature": "public String getElement()",
    "source_code": "\tpublic String getElement() {\n\t\treturn this.element;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractMultiCheckedElementTag#getItemLabel()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value to be displayed as part of the\n\t * '{@code input type=\"checkbox/radio\"}' tag.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "String",
    "signature": "protected String getItemLabel()",
    "source_code": "\tprotected String getItemLabel() {\n\t\treturn this.itemLabel;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractMultiCheckedElementTag#getItemValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the name of the property mapped to the '{@code value}' attribute\n\t * of the '{@code input type=\"checkbox/radio\"}' tag.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "String",
    "signature": "protected String getItemValue()",
    "source_code": "\tprotected String getItemValue() {\n\t\treturn this.itemValue;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractMultiCheckedElementTag#getItems()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link java.util.Collection}, {@link java.util.Map} or array of objects\n\t * used to generate the '{@code input type=\"checkbox/radio\"}' tags.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "Object",
    "signature": "protected Object getItems()",
    "source_code": "\tprotected Object getItems() {\n\t\treturn this.items;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractMultiCheckedElementTag#resolveId()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Appends a counter to a specified id as well,\n\t * since we're dealing with multiple HTML elements.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "String",
    "signature": "protected String resolveId()",
    "source_code": "\tprotected String resolveId() throws JspException {\n\t\tObject id = evaluate(\"id\", getId());\n\t\tif (id != null) {\n\t\t\tString idString = id.toString();\n\t\t\treturn (StringUtils.hasText(idString) ? TagIdGenerator.nextId(idString, this.pageContext) : null);\n\t\t}\n\t\treturn autogenerateId();\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractMultiCheckedElementTag#setDelimiter(delimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the delimiter to be used between each\n\t * '{@code input type=\"checkbox/radio\"}' tag.\n\t * <p>By default, there is <em>no</em> delimiter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "void",
    "signature": "public void setDelimiter(String delimiter)",
    "source_code": "\tpublic void setDelimiter(String delimiter) {\n\t\tthis.delimiter = delimiter;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractMultiCheckedElementTag#setElement(element)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the HTML element used to enclose the\n\t * '{@code input type=\"checkbox/radio\"}' tag.\n\t * <p>Defaults to an HTML '{@code <span/>}' tag.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void setElement(String element)",
    "source_code": "\tpublic void setElement(String element) {\n\t\tAssert.hasText(element, \"'element' cannot be null or blank\");\n\t\tthis.element = element;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractMultiCheckedElementTag#setItemLabel(itemLabel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value to be displayed as part of the\n\t * '{@code input type=\"checkbox/radio\"}' tag.\n\t * <p>May be a runtime expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "itemLabel"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void setItemLabel(String itemLabel)",
    "source_code": "\tpublic void setItemLabel(String itemLabel) {\n\t\tAssert.hasText(itemLabel, \"'itemLabel' must not be empty\");\n\t\tthis.itemLabel = itemLabel;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractMultiCheckedElementTag#setItemValue(itemValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of the property mapped to the '{@code value}' attribute\n\t * of the '{@code input type=\"checkbox/radio\"}' tag.\n\t * <p>May be a runtime expression.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "itemValue"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void setItemValue(String itemValue)",
    "source_code": "\tpublic void setItemValue(String itemValue) {\n\t\tAssert.hasText(itemValue, \"'itemValue' must not be empty\");\n\t\tthis.itemValue = itemValue;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractMultiCheckedElementTag#setItems(items)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link java.util.Collection}, {@link java.util.Map} or array of objects\n\t * used to generate the '{@code input type=\"checkbox/radio\"}' tags.\n\t * <p>Typically a runtime expression.\n\t * @param items said items\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "items"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void setItems(Object items)",
    "source_code": "\tpublic void setItems(Object items) {\n\t\tAssert.notNull(items, \"'items' must not be null\");\n\t\tthis.items = items;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.AbstractMultiCheckedElementTag#writeTagContent(tagWriter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Renders the '{@code input type=\"radio\"}' element with the configured\n\t * {@link #setItems(Object)} values. Marks the element as checked if the\n\t * value matches the bound value.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "tagWriter"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "int",
    "signature": "protected int writeTagContent(TagWriter tagWriter)",
    "source_code": "\tprotected int writeTagContent(TagWriter tagWriter) throws JspException {\n\t\tObject items = getItems();\n\t\tObject itemsObject = (items instanceof String ? evaluate(\"items\", items) : items);\n\n\t\tString itemValue = getItemValue();\n\t\tString itemLabel = getItemLabel();\n\t\tString valueProperty =\n\t\t\t\t(itemValue != null ? ObjectUtils.getDisplayString(evaluate(\"itemValue\", itemValue)) : null);\n\t\tString labelProperty =\n\t\t\t\t(itemLabel != null ? ObjectUtils.getDisplayString(evaluate(\"itemLabel\", itemLabel)) : null);\n\n\t\tClass<?> boundType = getBindStatus().getValueType();\n\t\tif (itemsObject == null && boundType != null && boundType.isEnum()) {\n\t\t\titemsObject = boundType.getEnumConstants();\n\t\t}\n\n\t\tif (itemsObject == null) {\n\t\t\tthrow new IllegalArgumentException(\"Attribute 'items' is required and must be a Collection, an Array or a Map\");\n\t\t}\n\n\t\tif (itemsObject.getClass().isArray()) {\n\t\t\tObject[] itemsArray = (Object[]) itemsObject;\n\t\t\tfor (int i = 0; i < itemsArray.length; i++) {\n\t\t\t\tObject item = itemsArray[i];\n\t\t\t\twriteObjectEntry(tagWriter, valueProperty, labelProperty, item, i);\n\t\t\t}\n\t\t}\n\t\telse if (itemsObject instanceof final Collection<?> optionCollection) {\n\t\t\tint itemIndex = 0;\n\t\t\tfor (Iterator<?> it = optionCollection.iterator(); it.hasNext(); itemIndex++) {\n\t\t\t\tObject item = it.next();\n\t\t\t\twriteObjectEntry(tagWriter, valueProperty, labelProperty, item, itemIndex);\n\t\t\t}\n\t\t}\n\t\telse if (itemsObject instanceof final Map<?, ?> optionMap) {\n\t\t\tint itemIndex = 0;\n\t\t\tfor (Iterator it = optionMap.entrySet().iterator(); it.hasNext(); itemIndex++) {\n\t\t\t\tMap.Entry entry = (Map.Entry) it.next();\n\t\t\t\twriteMapEntry(tagWriter, valueProperty, labelProperty, entry, itemIndex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Attribute 'items' must be an array, a Collection or a Map\");\n\t\t}\n\n\t\treturn SKIP_BODY;\n\t}"
  },
  "org.springframework.web.servlet.view.RedirectView": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * View that redirects to an absolute, context relative, or current request\n * relative URL. The URL may be a URI template in which case the URI template\n * variables will be replaced with values available in the model. By default,\n * all primitive model attributes (or collections thereof) are exposed as HTTP\n * query parameters (assuming they've not been used as URI template variables),\n * but this behavior can be changed by overriding the\n * {@link #isEligibleProperty(String, Object)} method.\n *\n * <p>A URL for this view is supposed to be an HTTP redirect URL, i.e.\n * suitable for HttpServletResponse's {@code sendRedirect} method, which\n * is what actually does the redirect if the HTTP 1.0 flag is on, or via sending\n * back an HTTP 303 code - if the HTTP 1.0 compatibility flag is off.\n *\n * <p>Note that while the default value for the \"contextRelative\" flag is off,\n * you will probably want to almost always set it to true. With the flag off,\n * URLs starting with \"/\" are considered relative to the web server root, while\n * with the flag on, they are considered relative to the web application root.\n * Since most web applications will never know or care what their context path\n * actually is, they are much better off setting this flag to true, and submitting\n * paths which are to be considered relative to the web application root.\n *\n * <p><b>NOTE when using this redirect view in a Portlet environment:</b> Make sure\n * that your controller respects the Portlet {@code sendRedirect} constraints.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Colin Sampaleanu\n * @author Sam Brannen\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @see #setContextRelative\n * @see #setHttp10Compatible\n * @see #setExposeModelAttributes\n * @see jakarta.servlet.http.HttpServletResponse#sendRedirect\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "signature": "public class RedirectView",
    "source_code": "public class RedirectView extends AbstractUrlBasedView implements SmartView {\n\n\tprivate static final Pattern URI_TEMPLATE_VARIABLE_PATTERN = Pattern.compile(\"\\\\{([^/]+?)\\\\}\");\n\n\n\tprivate boolean contextRelative = false;\n\n\tprivate boolean http10Compatible = true;\n\n\tprivate boolean exposeModelAttributes = true;\n\n\t@Nullable\n\tprivate String encodingScheme;\n\n\t@Nullable\n\tprivate HttpStatusCode statusCode;\n\n\tprivate boolean expandUriTemplateVariables = true;\n\n\tprivate boolean propagateQueryParams = false;\n\n\t@Nullable\n\tprivate String[] hosts;\n\n\n\t/**\n\t * Constructor for use as a bean.\n\t */\n\tpublic RedirectView() {\n\t\tsetExposePathVariables(false);\n\t}\n\n\t/**\n\t * Create a new RedirectView with the given URL.\n\t * <p>The given URL will be considered as relative to the web server,\n\t * not as relative to the current ServletContext.\n\t * @param url the URL to redirect to\n\t * @see #RedirectView(String, boolean)\n\t */\n\tpublic RedirectView(String url) {\n\t\tsuper(url);\n\t\tsetExposePathVariables(false);\n\t}\n\n\t/**\n\t * Create a new RedirectView with the given URL.\n\t * @param url the URL to redirect to\n\t * @param contextRelative whether to interpret the given URL as\n\t * relative to the current ServletContext\n\t */\n\tpublic RedirectView(String url, boolean contextRelative) {\n\t\tsuper(url);\n\t\tthis.contextRelative = contextRelative;\n\t\tsetExposePathVariables(false);\n\t}\n\n\t/**\n\t * Create a new RedirectView with the given URL.\n\t * @param url the URL to redirect to\n\t * @param contextRelative whether to interpret the given URL as\n\t * relative to the current ServletContext\n\t * @param http10Compatible whether to stay compatible with HTTP 1.0 clients\n\t */\n\tpublic RedirectView(String url, boolean contextRelative, boolean http10Compatible) {\n\t\tsuper(url);\n\t\tthis.contextRelative = contextRelative;\n\t\tthis.http10Compatible = http10Compatible;\n\t\tsetExposePathVariables(false);\n\t}\n\n\t/**\n\t * Create a new RedirectView with the given URL.\n\t * @param url the URL to redirect to\n\t * @param contextRelative whether to interpret the given URL as\n\t * relative to the current ServletContext\n\t * @param http10Compatible whether to stay compatible with HTTP 1.0 clients\n\t * @param exposeModelAttributes whether model attributes should be\n\t * exposed as query parameters\n\t */\n\tpublic RedirectView(String url, boolean contextRelative, boolean http10Compatible, boolean exposeModelAttributes) {\n\t\tsuper(url);\n\t\tthis.contextRelative = contextRelative;\n\t\tthis.http10Compatible = http10Compatible;\n\t\tthis.exposeModelAttributes = exposeModelAttributes;\n\t\tsetExposePathVariables(false);\n\t}\n\n\n\t/**\n\t * Set whether to interpret a given URL that starts with a slash (\"/\")\n\t * as relative to the current ServletContext, i.e. as relative to the\n\t * web application root.\n\t * <p>Default is \"false\": A URL that starts with a slash will be interpreted\n\t * as absolute, i.e. taken as-is. If \"true\", the context path will be\n\t * prepended to the URL in such a case.\n\t * @see jakarta.servlet.http.HttpServletRequest#getContextPath\n\t */\n\tpublic void setContextRelative(boolean contextRelative) {\n\t\tthis.contextRelative = contextRelative;\n\t}\n\n\t/**\n\t * Set whether to stay compatible with HTTP 1.0 clients.\n\t * <p>In the default implementation, this will enforce HTTP status code 302\n\t * in any case, i.e. delegate to {@code HttpServletResponse.sendRedirect}.\n\t * Turning this off will send HTTP status code 303, which is the correct\n\t * code for HTTP 1.1 clients, but not understood by HTTP 1.0 clients.\n\t * <p>Many HTTP 1.1 clients treat 302 just like 303, not making any\n\t * difference. However, some clients depend on 303 when redirecting\n\t * after a POST request; turn this flag off in such a scenario.\n\t * @see jakarta.servlet.http.HttpServletResponse#sendRedirect\n\t */\n\tpublic void setHttp10Compatible(boolean http10Compatible) {\n\t\tthis.http10Compatible = http10Compatible;\n\t}\n\n\t/**\n\t * Set the {@code exposeModelAttributes} flag which denotes whether\n\t * model attributes should be exposed as HTTP query parameters.\n\t * <p>Defaults to {@code true}.\n\t */\n\tpublic void setExposeModelAttributes(final boolean exposeModelAttributes) {\n\t\tthis.exposeModelAttributes = exposeModelAttributes;\n\t}\n\n\t/**\n\t * Set the encoding scheme for this view.\n\t * <p>Default is the request's encoding scheme\n\t * (which is ISO-8859-1 if not specified otherwise).\n\t */\n\tpublic void setEncodingScheme(String encodingScheme) {\n\t\tthis.encodingScheme = encodingScheme;\n\t}\n\n\t/**\n\t * Set the status code for this view.\n\t * <p>Default is to send 302/303, depending on the value of the\n\t * {@link #setHttp10Compatible(boolean) http10Compatible} flag.\n\t */\n\tpublic void setStatusCode(HttpStatusCode statusCode) {\n\t\tthis.statusCode = statusCode;\n\t}\n\n\t/**\n\t * Whether to treat the redirect URL as a URI template.\n\t * Set this flag to {@code false} if the redirect URL contains open\n\t * and close curly braces \"{\", \"}\" and you don't want them interpreted\n\t * as URI variables.\n\t * <p>Defaults to {@code true}.\n\t */\n\tpublic void setExpandUriTemplateVariables(boolean expandUriTemplateVariables) {\n\t\tthis.expandUriTemplateVariables = expandUriTemplateVariables;\n\t}\n\n\t/**\n\t * When set to {@code true} the query string of the current URL is appended\n\t * and thus propagated through to the redirected URL.\n\t * <p>Defaults to {@code false}.\n\t * @since 4.1\n\t */\n\tpublic void setPropagateQueryParams(boolean propagateQueryParams) {\n\t\tthis.propagateQueryParams = propagateQueryParams;\n\t}\n\n\t/**\n\t * Whether to propagate the query params of the current URL.\n\t * @since 4.1\n\t */\n\tpublic boolean isPropagateQueryProperties() {\n\t\treturn this.propagateQueryParams;\n\t}\n\n\t/**\n\t * Configure one or more hosts associated with the application.\n\t * All other hosts will be considered external hosts.\n\t * <p>In effect, this property provides a way turn off encoding via\n\t * {@link HttpServletResponse#encodeRedirectURL} for URLs that have a\n\t * host and that host is not listed as a known host.\n\t * <p>If not set (the default) all URLs are encoded through the response.\n\t * @param hosts one or more application hosts\n\t * @since 4.3\n\t */\n\tpublic void setHosts(@Nullable String... hosts) {\n\t\tthis.hosts = hosts;\n\t}\n\n\t/**\n\t * Return the configured application hosts.\n\t * @since 4.3\n\t */\n\t@Nullable\n\tpublic String[] getHosts() {\n\t\treturn this.hosts;\n\t}\n\n\t/**\n\t * Returns \"true\" indicating this view performs a redirect.\n\t */\n\t@Override\n\tpublic boolean isRedirectView() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * An ApplicationContext is not strictly required for RedirectView.\n\t */\n\t@Override\n\tprotected boolean isContextRequired() {\n\t\treturn false;\n\t}\n\n\n\t/**\n\t * Convert model to request parameters and redirect to the given URL.\n\t * @see #appendQueryProperties\n\t * @see #sendRedirect\n\t */\n\t@Override\n\tprotected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws IOException {\n\n\t\tString targetUrl = createTargetUrl(model, request);\n\t\ttargetUrl = updateTargetUrl(targetUrl, model, request, response);\n\n\t\t// Save flash attributes\n\t\tRequestContextUtils.saveOutputFlashMap(targetUrl, request, response);\n\n\t\t// Redirect\n\t\tsendRedirect(request, response, targetUrl, this.http10Compatible);\n\t}\n\n\t/**\n\t * Create the target URL by checking if the redirect string is a URI template first,\n\t * expanding it with the given model, and then optionally appending simple type model\n\t * attributes as query String parameters.\n\t */\n\tprotected final String createTargetUrl(Map<String, Object> model, HttpServletRequest request)\n\t\t\tthrows UnsupportedEncodingException {\n\n\t\t// Prepare target URL.\n\t\tStringBuilder targetUrl = new StringBuilder();\n\t\tString url = getUrl();\n\t\tAssert.state(url != null, \"'url' not set\");\n\n\t\tif (this.contextRelative && getUrl().startsWith(\"/\")) {\n\t\t\t// Do not apply context path to relative URLs.\n\t\t\ttargetUrl.append(getContextPath(request));\n\t\t}\n\t\ttargetUrl.append(getUrl());\n\n\t\tString enc = this.encodingScheme;\n\t\tif (enc == null) {\n\t\t\tenc = request.getCharacterEncoding();\n\t\t}\n\t\tif (enc == null) {\n\t\t\tenc = WebUtils.DEFAULT_CHARACTER_ENCODING;\n\t\t}\n\n\t\tif (this.expandUriTemplateVariables && StringUtils.hasText(targetUrl)) {\n\t\t\tMap<String, String> variables = getCurrentRequestUriVariables(request);\n\t\t\ttargetUrl = replaceUriTemplateVariables(targetUrl.toString(), model, variables, enc);\n\t\t}\n\t\tif (isPropagateQueryProperties()) {\n\t\t\tappendCurrentQueryParams(targetUrl, request);\n\t\t}\n\t\tif (this.exposeModelAttributes) {\n\t\t\tappendQueryProperties(targetUrl, model, enc);\n\t\t}\n\n\t\treturn targetUrl.toString();\n\t}\n\n\tprivate String getContextPath(HttpServletRequest request) {\n\t\tString contextPath = request.getContextPath();\n\t\twhile (contextPath.startsWith(\"//\")) {\n\t\t\tcontextPath = contextPath.substring(1);\n\t\t}\n\t\treturn contextPath;\n\t}\n\n\t/**\n\t * Replace URI template variables in the target URL with encoded model\n\t * attributes or URI variables from the current request. Model attributes\n\t * referenced in the URL are removed from the model.\n\t * @param targetUrl the redirect URL\n\t * @param model a Map that contains model attributes\n\t * @param currentUriVariables current request URI variables to use\n\t * @param encodingScheme the encoding scheme to use\n\t * @throws UnsupportedEncodingException if string encoding failed\n\t */\n\tprotected StringBuilder replaceUriTemplateVariables(\n\t\t\tString targetUrl, Map<String, Object> model, Map<String, String> currentUriVariables, String encodingScheme)\n\t\t\tthrows UnsupportedEncodingException {\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tMatcher matcher = URI_TEMPLATE_VARIABLE_PATTERN.matcher(targetUrl);\n\t\tint endLastMatch = 0;\n\t\twhile (matcher.find()) {\n\t\t\tString name = matcher.group(1);\n\t\t\tObject value = (model.containsKey(name) ? model.remove(name) : currentUriVariables.get(name));\n\t\t\tif (value == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Model has no value for key '\" + name + \"'\");\n\t\t\t}\n\t\t\tresult.append(targetUrl, endLastMatch, matcher.start());\n\t\t\tresult.append(UriUtils.encodePathSegment(value.toString(), encodingScheme));\n\t\t\tendLastMatch = matcher.end();\n\t\t}\n\t\tresult.append(targetUrl.substring(endLastMatch));\n\t\treturn result;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate Map<String, String> getCurrentRequestUriVariables(HttpServletRequest request) {\n\t\tString name = HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE;\n\t\tMap<String, String> uriVars = (Map<String, String>) request.getAttribute(name);\n\t\treturn (uriVars != null) ? uriVars : Collections.emptyMap();\n\t}\n\n\t/**\n\t * Append the query string of the current request to the target redirect URL.\n\t * @param targetUrl the StringBuilder to append the properties to\n\t * @param request the current request\n\t * @since 4.1\n\t */\n\tprotected void appendCurrentQueryParams(StringBuilder targetUrl, HttpServletRequest request) {\n\t\tString query = request.getQueryString();\n\t\tif (StringUtils.hasText(query)) {\n\t\t\t// Extract anchor fragment, if any.\n\t\t\tString fragment = null;\n\t\t\tint anchorIndex = targetUrl.indexOf(\"#\");\n\t\t\tif (anchorIndex > -1) {\n\t\t\t\tfragment = targetUrl.substring(anchorIndex);\n\t\t\t\ttargetUrl.delete(anchorIndex, targetUrl.length());\n\t\t\t}\n\n\t\t\tif (targetUrl.toString().indexOf('?') < 0) {\n\t\t\t\ttargetUrl.append('?').append(query);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttargetUrl.append('&').append(query);\n\t\t\t}\n\t\t\t// Append anchor fragment, if any, to end of URL.\n\t\t\tif (fragment != null) {\n\t\t\t\ttargetUrl.append(fragment);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Append query properties to the redirect URL.\n\t * Stringifies, URL-encodes and formats model attributes as query properties.\n\t * @param targetUrl the StringBuilder to append the properties to\n\t * @param model a Map that contains model attributes\n\t * @param encodingScheme the encoding scheme to use\n\t * @throws UnsupportedEncodingException if string encoding failed\n\t * @see #queryProperties\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected void appendQueryProperties(StringBuilder targetUrl, Map<String, Object> model, String encodingScheme)\n\t\t\tthrows UnsupportedEncodingException {\n\n\t\t// Extract anchor fragment, if any.\n\t\tString fragment = null;\n\t\tint anchorIndex = targetUrl.indexOf(\"#\");\n\t\tif (anchorIndex > -1) {\n\t\t\tfragment = targetUrl.substring(anchorIndex);\n\t\t\ttargetUrl.delete(anchorIndex, targetUrl.length());\n\t\t}\n\n\t\t// If there aren't already some parameters, we need a \"?\".\n\t\tboolean first = (targetUrl.toString().indexOf('?') < 0);\n\t\tfor (Map.Entry<String, Object> entry : queryProperties(model).entrySet()) {\n\t\t\tObject rawValue = entry.getValue();\n\t\t\tCollection<?> values;\n\t\t\tif (rawValue != null && rawValue.getClass().isArray()) {\n\t\t\t\tvalues = CollectionUtils.arrayToList(rawValue);\n\t\t\t}\n\t\t\telse if (rawValue instanceof Collection) {\n\t\t\t\tvalues = ((Collection<?>) rawValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = Collections.singleton(rawValue);\n\t\t\t}\n\t\t\tfor (Object value : values) {\n\t\t\t\tif (first) {\n\t\t\t\t\ttargetUrl.append('?');\n\t\t\t\t\tfirst = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttargetUrl.append('&');\n\t\t\t\t}\n\t\t\t\tString encodedKey = urlEncode(entry.getKey(), encodingScheme);\n\t\t\t\tString encodedValue = (value != null ? urlEncode(value.toString(), encodingScheme) : \"\");\n\t\t\t\ttargetUrl.append(encodedKey).append('=').append(encodedValue);\n\t\t\t}\n\t\t}\n\n\t\t// Append anchor fragment, if any, to end of URL.\n\t\tif (fragment != null) {\n\t\t\ttargetUrl.append(fragment);\n\t\t}\n\t}\n\n\t/**\n\t * Determine name-value pairs for query strings, which will be stringified,\n\t * URL-encoded and formatted by {@link #appendQueryProperties}.\n\t * <p>This implementation filters the model through checking\n\t * {@link #isEligibleProperty(String, Object)} for each element,\n\t * by default accepting Strings, primitives and primitive wrappers only.\n\t * @param model the original model Map\n\t * @return the filtered Map of eligible query properties\n\t * @see #isEligibleProperty(String, Object)\n\t */\n\tprotected Map<String, Object> queryProperties(Map<String, Object> model) {\n\t\tMap<String, Object> result = new LinkedHashMap<>();\n\t\tmodel.forEach((name, value) -> {\n\t\t\tif (isEligibleProperty(name, value)) {\n\t\t\t\tresult.put(name, value);\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}\n\n\t/**\n\t * Determine whether the given model element should be exposed\n\t * as a query property.\n\t * <p>The default implementation considers Strings and primitives\n\t * as eligible, and also arrays and Collections/Iterables with\n\t * corresponding elements. This can be overridden in subclasses.\n\t * @param key the key of the model element\n\t * @param value the value of the model element\n\t * @return whether the element is eligible as query property\n\t */\n\tprotected boolean isEligibleProperty(String key, @Nullable Object value) {\n\t\tif (value == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (isEligibleValue(value)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (value.getClass().isArray()) {\n\t\t\tint length = Array.getLength(value);\n\t\t\tif (length == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tObject element = Array.get(value, i);\n\t\t\t\tif (!isEligibleValue(element)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (value instanceof Collection<?> coll) {\n\t\t\tif (coll.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (Object element : coll) {\n\t\t\t\tif (!isEligibleValue(element)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine whether the given model element value is eligible for exposure.\n\t * <p>The default implementation considers primitives, strings, numbers, dates,\n\t * URIs, URLs etc as eligible, according to {@link BeanUtils#isSimpleValueType}.\n\t * This can be overridden in subclasses.\n\t * @param value the model element value\n\t * @return whether the element value is eligible\n\t * @see BeanUtils#isSimpleValueType\n\t */\n\tprotected boolean isEligibleValue(@Nullable Object value) {\n\t\treturn (value != null && BeanUtils.isSimpleValueType(value.getClass()));\n\t}\n\n\t/**\n\t * URL-encode the given input String with the given encoding scheme.\n\t * <p>The default implementation uses {@code URLEncoder.encode(input, enc)}.\n\t * @param input the unencoded input String\n\t * @param encodingScheme the encoding scheme\n\t * @return the encoded output String\n\t * @throws UnsupportedEncodingException if thrown by the JDK URLEncoder\n\t * @see java.net.URLEncoder#encode(String, String)\n\t */\n\tprotected String urlEncode(String input, String encodingScheme) throws UnsupportedEncodingException {\n\t\treturn URLEncoder.encode(input, encodingScheme);\n\t}\n\n\t/**\n\t * Find the registered {@link RequestDataValueProcessor}, if any, and allow\n\t * it to update the redirect target URL.\n\t * @param targetUrl the given redirect URL\n\t * @return the updated URL or the same as URL as the one passed in\n\t */\n\tprotected String updateTargetUrl(String targetUrl, Map<String, Object> model,\n\t\t\tHttpServletRequest request, HttpServletResponse response) {\n\n\t\tWebApplicationContext wac = getWebApplicationContext();\n\t\tif (wac == null) {\n\t\t\twac = RequestContextUtils.findWebApplicationContext(request, getServletContext());\n\t\t}\n\n\t\tif (wac != null && wac.containsBean(RequestContextUtils.REQUEST_DATA_VALUE_PROCESSOR_BEAN_NAME)) {\n\t\t\tRequestDataValueProcessor processor = wac.getBean(\n\t\t\t\t\tRequestContextUtils.REQUEST_DATA_VALUE_PROCESSOR_BEAN_NAME, RequestDataValueProcessor.class);\n\t\t\treturn processor.processUrl(request, targetUrl);\n\t\t}\n\n\t\treturn targetUrl;\n\t}\n\n\t/**\n\t * Send a redirect back to the HTTP client.\n\t * @param request current HTTP request (allows for reacting to request method)\n\t * @param response current HTTP response (for sending response headers)\n\t * @param targetUrl the target URL to redirect to\n\t * @param http10Compatible whether to stay compatible with HTTP 1.0 clients\n\t * @throws IOException if thrown by response methods\n\t */\n\tprotected void sendRedirect(HttpServletRequest request, HttpServletResponse response,\n\t\t\tString targetUrl, boolean http10Compatible) throws IOException {\n\n\t\tString encodedURL = (isRemoteHost(targetUrl) ? targetUrl : response.encodeRedirectURL(targetUrl));\n\t\tif (http10Compatible) {\n\t\t\tHttpStatusCode attributeStatusCode = (HttpStatusCode) request.getAttribute(View.RESPONSE_STATUS_ATTRIBUTE);\n\t\t\tif (this.statusCode != null) {\n\t\t\t\tresponse.setStatus(this.statusCode.value());\n\t\t\t\tresponse.setHeader(\"Location\", encodedURL);\n\t\t\t}\n\t\t\telse if (attributeStatusCode != null) {\n\t\t\t\tresponse.setStatus(attributeStatusCode.value());\n\t\t\t\tresponse.setHeader(\"Location\", encodedURL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Send status code 302 by default.\n\t\t\t\tresponse.sendRedirect(encodedURL);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tHttpStatusCode statusCode = getHttp11StatusCode(request, response, targetUrl);\n\t\t\tresponse.setStatus(statusCode.value());\n\t\t\tresponse.setHeader(\"Location\", encodedURL);\n\t\t}\n\t}\n\n\t/**\n\t * Whether the given targetUrl has a host that is a \"foreign\" system in which\n\t * case {@link HttpServletResponse#encodeRedirectURL} will not be applied.\n\t * <p>This method returns {@code true} if the {@link #setHosts(String[])}\n\t * property is configured and the target URL has a host that does not match.\n\t * @param targetUrl the target redirect URL\n\t * @return {@code true} if the target URL has a remote host, {@code false} if\n\t * the URL does not have a host or the \"host\" property is not configured\n\t * @since 4.3\n\t */\n\tprotected boolean isRemoteHost(String targetUrl) {\n\t\tif (ObjectUtils.isEmpty(getHosts())) {\n\t\t\treturn false;\n\t\t}\n\t\tString targetHost = UriComponentsBuilder.fromUriString(targetUrl).build().getHost();\n\t\tif (!StringUtils.hasLength(targetHost)) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (String host : getHosts()) {\n\t\t\tif (targetHost.equals(host)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Determines the status code to use for HTTP 1.1 compatible requests.\n\t * <p>The default implementation returns the {@link #setStatusCode(HttpStatusCode) statusCode}\n\t * property if set, or the value of the {@link #RESPONSE_STATUS_ATTRIBUTE} attribute.\n\t * If neither are set, it defaults to {@link HttpStatus#SEE_OTHER} (303).\n\t * @param request the request to inspect\n\t * @param response the servlet response\n\t * @param targetUrl the target URL\n\t * @return the response status\n\t */\n\tprotected HttpStatusCode getHttp11StatusCode(\n\t\t\tHttpServletRequest request, HttpServletResponse response, String targetUrl) {\n\n\t\tif (this.statusCode != null) {\n\t\t\treturn this.statusCode;\n\t\t}\n\t\tHttpStatusCode attributeStatusCode = (HttpStatusCode) request.getAttribute(View.RESPONSE_STATUS_ATTRIBUTE);\n\t\tif (attributeStatusCode != null) {\n\t\t\treturn attributeStatusCode;\n\t\t}\n\t\treturn HttpStatus.SEE_OTHER;\n\t}\n\n}"
  },
  "org.springframework.web.servlet.view.RedirectView#appendCurrentQueryParams(targetUrl,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Append the query string of the current request to the target redirect URL.\n\t * @param targetUrl the StringBuilder to append the properties to\n\t * @param request the current request\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "void",
    "signature": "protected void appendCurrentQueryParams(StringBuilder targetUrl, HttpServletRequest request)",
    "source_code": "\tprotected void appendCurrentQueryParams(StringBuilder targetUrl, HttpServletRequest request) {\n\t\tString query = request.getQueryString();\n\t\tif (StringUtils.hasText(query)) {\n\t\t\t// Extract anchor fragment, if any.\n\t\t\tString fragment = null;\n\t\t\tint anchorIndex = targetUrl.indexOf(\"#\");\n\t\t\tif (anchorIndex > -1) {\n\t\t\t\tfragment = targetUrl.substring(anchorIndex);\n\t\t\t\ttargetUrl.delete(anchorIndex, targetUrl.length());\n\t\t\t}\n\n\t\t\tif (targetUrl.toString().indexOf('?') < 0) {\n\t\t\t\ttargetUrl.append('?').append(query);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttargetUrl.append('&').append(query);\n\t\t\t}\n\t\t\t// Append anchor fragment, if any, to end of URL.\n\t\t\tif (fragment != null) {\n\t\t\t\ttargetUrl.append(fragment);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.RedirectView#appendQueryProperties(targetUrl,Map<String,model,encodingScheme)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Append query properties to the redirect URL.\n\t * Stringifies, URL-encodes and formats model attributes as query properties.\n\t * @param targetUrl the StringBuilder to append the properties to\n\t * @param model a Map that contains model attributes\n\t * @param encodingScheme the encoding scheme to use\n\t * @throws UnsupportedEncodingException if string encoding failed\n\t * @see #queryProperties\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "Map<String",
      "model",
      "encodingScheme"
    ],
    "position": {
      "column": 1,
      "line": 445
    },
    "return": "void",
    "signature": "protected void appendQueryProperties(StringBuilder targetUrl, Map<String, Object> model, String encodingScheme)",
    "source_code": "\tprotected void appendQueryProperties(StringBuilder targetUrl, Map<String, Object> model, String encodingScheme)"
  },
  "org.springframework.web.servlet.view.RedirectView#createTargetUrl(Map<String,model,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the target URL by checking if the redirect string is a URI template first,\n\t * expanding it with the given model, and then optionally appending simple type model\n\t * attributes as query String parameters.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "String",
    "signature": "protected String createTargetUrl(Map<String, Object> model, HttpServletRequest request)",
    "source_code": "\tprotected final String createTargetUrl(Map<String, Object> model, HttpServletRequest request)"
  },
  "org.springframework.web.servlet.view.RedirectView#getHosts()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured application hosts.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 278
    },
    "return": "String[]",
    "signature": "public String[] getHosts()",
    "source_code": "\tpublic String[] getHosts() {\n\t\treturn this.hosts;\n\t}"
  },
  "org.springframework.web.servlet.view.RedirectView#getHttp11StatusCode(request,response,targetUrl)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determines the status code to use for HTTP 1.1 compatible requests.\n\t * <p>The default implementation returns the {@link #setStatusCode(HttpStatusCode) statusCode}\n\t * property if set, or the value of the {@link #RESPONSE_STATUS_ATTRIBUTE} attribute.\n\t * If neither are set, it defaults to {@link HttpStatus#SEE_OTHER} (303).\n\t * @param request the request to inspect\n\t * @param response the servlet response\n\t * @param targetUrl the target URL\n\t * @return the response status\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "targetUrl"
    ],
    "position": {
      "column": 1,
      "line": 673
    },
    "return": "HttpStatusCode",
    "signature": "protected HttpStatusCode getHttp11StatusCode(HttpServletRequest request, HttpServletResponse response, String targetUrl)",
    "source_code": "\tprotected HttpStatusCode getHttp11StatusCode("
  },
  "org.springframework.web.servlet.view.RedirectView#isContextRequired()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An ApplicationContext is not strictly required for RedirectView.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "boolean",
    "signature": "protected boolean isContextRequired()",
    "source_code": "\tprotected boolean isContextRequired() {\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.servlet.view.RedirectView#isEligibleProperty(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given model element should be exposed\n\t * as a query property.\n\t * <p>The default implementation considers Strings and primitives\n\t * as eligible, and also arrays and Collections/Iterables with\n\t * corresponding elements. This can be overridden in subclasses.\n\t * @param key the key of the model element\n\t * @param value the value of the model element\n\t * @return whether the element is eligible as query property\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 520
    },
    "return": "boolean",
    "signature": "protected boolean isEligibleProperty(String key, @Nullable Object value)",
    "source_code": "\tprotected boolean isEligibleProperty(String key, @Nullable Object value) {\n\t\tif (value == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (isEligibleValue(value)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (value.getClass().isArray()) {\n\t\t\tint length = Array.getLength(value);\n\t\t\tif (length == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tObject element = Array.get(value, i);\n\t\t\t\tif (!isEligibleValue(element)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (value instanceof Collection<?> coll) {\n\t\t\tif (coll.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (Object element : coll) {\n\t\t\t\tif (!isEligibleValue(element)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.servlet.view.RedirectView#isEligibleValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given model element value is eligible for exposure.\n\t * <p>The default implementation considers primitives, strings, numbers, dates,\n\t * URIs, URLs etc as eligible, according to {@link BeanUtils#isSimpleValueType}.\n\t * This can be overridden in subclasses.\n\t * @param value the model element value\n\t * @return whether the element value is eligible\n\t * @see BeanUtils#isSimpleValueType\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "boolean",
    "signature": "protected boolean isEligibleValue(@Nullable Object value)",
    "source_code": "\tprotected boolean isEligibleValue(@Nullable Object value) {\n\t\treturn (value != null && BeanUtils.isSimpleValueType(value.getClass()));\n\t}"
  },
  "org.springframework.web.servlet.view.RedirectView#isPropagateQueryProperties()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to propagate the query params of the current URL.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "boolean",
    "signature": "public boolean isPropagateQueryProperties()",
    "source_code": "\tpublic boolean isPropagateQueryProperties() {\n\t\treturn this.propagateQueryParams;\n\t}"
  },
  "org.springframework.web.servlet.view.RedirectView#isRedirectView()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns \"true\" indicating this view performs a redirect.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "boolean",
    "signature": "public boolean isRedirectView()",
    "source_code": "\tpublic boolean isRedirectView() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.servlet.view.RedirectView#isRemoteHost(targetUrl)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the given targetUrl has a host that is a \"foreign\" system in which\n\t * case {@link HttpServletResponse#encodeRedirectURL} will not be applied.\n\t * <p>This method returns {@code true} if the {@link #setHosts(String[])}\n\t * property is configured and the target URL has a host that does not match.\n\t * @param targetUrl the target redirect URL\n\t * @return {@code true} if the target URL has a remote host, {@code false} if\n\t * the URL does not have a host or the \"host\" property is not configured\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl"
    ],
    "position": {
      "column": 1,
      "line": 647
    },
    "return": "boolean",
    "signature": "protected boolean isRemoteHost(String targetUrl)",
    "source_code": "\tprotected boolean isRemoteHost(String targetUrl) {\n\t\tif (ObjectUtils.isEmpty(getHosts())) {\n\t\t\treturn false;\n\t\t}\n\t\tString targetHost = UriComponentsBuilder.fromUriString(targetUrl).build().getHost();\n\t\tif (!StringUtils.hasLength(targetHost)) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (String host : getHosts()) {\n\t\t\tif (targetHost.equals(host)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.servlet.view.RedirectView#queryProperties(Map<String,model)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine name-value pairs for query strings, which will be stringified,\n\t * URL-encoded and formatted by {@link #appendQueryProperties}.\n\t * <p>This implementation filters the model through checking\n\t * {@link #isEligibleProperty(String, Object)} for each element,\n\t * by default accepting Strings, primitives and primitive wrappers only.\n\t * @param model the original model Map\n\t * @return the filtered Map of eligible query properties\n\t * @see #isEligibleProperty(String, Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model"
    ],
    "position": {
      "column": 1,
      "line": 500
    },
    "return": "Object>",
    "signature": "protected Object> queryProperties(Map<String, Object> model)",
    "source_code": "\tprotected Map<String, Object> queryProperties(Map<String, Object> model) {\n\t\tMap<String, Object> result = new LinkedHashMap<>();\n\t\tmodel.forEach((name, value) -> {\n\t\t\tif (isEligibleProperty(name, value)) {\n\t\t\t\tresult.put(name, value);\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.servlet.view.RedirectView#renderMergedOutputModel(Map<String,model,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert model to request parameters and redirect to the given URL.\n\t * @see #appendQueryProperties\n\t * @see #sendRedirect\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "void",
    "signature": "protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response)",
    "source_code": "\tprotected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,"
  },
  "org.springframework.web.servlet.view.RedirectView#replaceUriTemplateVariables(targetUrl,Map<String,model,Map<String,currentUriVariables,encodingScheme)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace URI template variables in the target URL with encoded model\n\t * attributes or URI variables from the current request. Model attributes\n\t * referenced in the URL are removed from the model.\n\t * @param targetUrl the redirect URL\n\t * @param model a Map that contains model attributes\n\t * @param currentUriVariables current request URI variables to use\n\t * @param encodingScheme the encoding scheme to use\n\t * @throws UnsupportedEncodingException if string encoding failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "Map<String",
      "model",
      "Map<String",
      "currentUriVariables",
      "encodingScheme"
    ],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "StringBuilder",
    "signature": "protected StringBuilder replaceUriTemplateVariables(String targetUrl, Map<String, Object> model, Map<String, String> currentUriVariables, String encodingScheme)",
    "source_code": "\tprotected StringBuilder replaceUriTemplateVariables("
  },
  "org.springframework.web.servlet.view.RedirectView#sendRedirect(request,response,targetUrl,http10Compatible)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Send a redirect back to the HTTP client.\n\t * @param request current HTTP request (allows for reacting to request method)\n\t * @param response current HTTP response (for sending response headers)\n\t * @param targetUrl the target URL to redirect to\n\t * @param http10Compatible whether to stay compatible with HTTP 1.0 clients\n\t * @throws IOException if thrown by response methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "targetUrl",
      "http10Compatible"
    ],
    "position": {
      "column": 1,
      "line": 611
    },
    "return": "void",
    "signature": "protected void sendRedirect(HttpServletRequest request, HttpServletResponse response,\n\t\t\tString targetUrl, boolean http10Compatible)",
    "source_code": "\tprotected void sendRedirect(HttpServletRequest request, HttpServletResponse response,"
  },
  "org.springframework.web.servlet.view.RedirectView#setContextRelative(contextRelative)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to interpret a given URL that starts with a slash (\"/\")\n\t * as relative to the current ServletContext, i.e. as relative to the\n\t * web application root.\n\t * <p>Default is \"false\": A URL that starts with a slash will be interpreted\n\t * as absolute, i.e. taken as-is. If \"true\", the context path will be\n\t * prepended to the URL in such a case.\n\t * @see jakarta.servlet.http.HttpServletRequest#getContextPath\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contextRelative"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void setContextRelative(boolean contextRelative)",
    "source_code": "\tpublic void setContextRelative(boolean contextRelative) {\n\t\tthis.contextRelative = contextRelative;\n\t}"
  },
  "org.springframework.web.servlet.view.RedirectView#setEncodingScheme(encodingScheme)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the encoding scheme for this view.\n\t * <p>Default is the request's encoding scheme\n\t * (which is ISO-8859-1 if not specified otherwise).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encodingScheme"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "void",
    "signature": "public void setEncodingScheme(String encodingScheme)",
    "source_code": "\tpublic void setEncodingScheme(String encodingScheme) {\n\t\tthis.encodingScheme = encodingScheme;\n\t}"
  },
  "org.springframework.web.servlet.view.RedirectView#setExpandUriTemplateVariables(expandUriTemplateVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to treat the redirect URL as a URI template.\n\t * Set this flag to {@code false} if the redirect URL contains open\n\t * and close curly braces \"{\", \"}\" and you don't want them interpreted\n\t * as URI variables.\n\t * <p>Defaults to {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expandUriTemplateVariables"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "void",
    "signature": "public void setExpandUriTemplateVariables(boolean expandUriTemplateVariables)",
    "source_code": "\tpublic void setExpandUriTemplateVariables(boolean expandUriTemplateVariables) {\n\t\tthis.expandUriTemplateVariables = expandUriTemplateVariables;\n\t}"
  },
  "org.springframework.web.servlet.view.RedirectView#setExposeModelAttributes(exposeModelAttributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@code exposeModelAttributes} flag which denotes whether\n\t * model attributes should be exposed as HTTP query parameters.\n\t * <p>Defaults to {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exposeModelAttributes"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "void",
    "signature": "public void setExposeModelAttributes(final boolean exposeModelAttributes)",
    "source_code": "\tpublic void setExposeModelAttributes(final boolean exposeModelAttributes) {\n\t\tthis.exposeModelAttributes = exposeModelAttributes;\n\t}"
  },
  "org.springframework.web.servlet.view.RedirectView#setHosts(hosts)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure one or more hosts associated with the application.\n\t * All other hosts will be considered external hosts.\n\t * <p>In effect, this property provides a way turn off encoding via\n\t * {@link HttpServletResponse#encodeRedirectURL} for URLs that have a\n\t * host and that host is not listed as a known host.\n\t * <p>If not set (the default) all URLs are encoded through the response.\n\t * @param hosts one or more application hosts\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hosts"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "void",
    "signature": "public void setHosts(@Nullable String... hosts)",
    "source_code": "\tpublic void setHosts(@Nullable String... hosts) {\n\t\tthis.hosts = hosts;\n\t}"
  },
  "org.springframework.web.servlet.view.RedirectView#setHttp10Compatible(http10Compatible)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to stay compatible with HTTP 1.0 clients.\n\t * <p>In the default implementation, this will enforce HTTP status code 302\n\t * in any case, i.e. delegate to {@code HttpServletResponse.sendRedirect}.\n\t * Turning this off will send HTTP status code 303, which is the correct\n\t * code for HTTP 1.1 clients, but not understood by HTTP 1.0 clients.\n\t * <p>Many HTTP 1.1 clients treat 302 just like 303, not making any\n\t * difference. However, some clients depend on 303 when redirecting\n\t * after a POST request; turn this flag off in such a scenario.\n\t * @see jakarta.servlet.http.HttpServletResponse#sendRedirect\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "http10Compatible"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "public void setHttp10Compatible(boolean http10Compatible)",
    "source_code": "\tpublic void setHttp10Compatible(boolean http10Compatible) {\n\t\tthis.http10Compatible = http10Compatible;\n\t}"
  },
  "org.springframework.web.servlet.view.RedirectView#setPropagateQueryParams(propagateQueryParams)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * When set to {@code true} the query string of the current URL is appended\n\t * and thus propagated through to the redirected URL.\n\t * <p>Defaults to {@code false}.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propagateQueryParams"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "void",
    "signature": "public void setPropagateQueryParams(boolean propagateQueryParams)",
    "source_code": "\tpublic void setPropagateQueryParams(boolean propagateQueryParams) {\n\t\tthis.propagateQueryParams = propagateQueryParams;\n\t}"
  },
  "org.springframework.web.servlet.view.RedirectView#setStatusCode(statusCode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the status code for this view.\n\t * <p>Default is to send 302/303, depending on the value of the\n\t * {@link #setHttp10Compatible(boolean) http10Compatible} flag.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCode"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "void",
    "signature": "public void setStatusCode(HttpStatusCode statusCode)",
    "source_code": "\tpublic void setStatusCode(HttpStatusCode statusCode) {\n\t\tthis.statusCode = statusCode;\n\t}"
  },
  "org.springframework.web.servlet.view.RedirectView#updateTargetUrl(targetUrl,Map<String,model,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the registered {@link RequestDataValueProcessor}, if any, and allow\n\t * it to update the redirect target URL.\n\t * @param targetUrl the given redirect URL\n\t * @return the updated URL or the same as URL as the one passed in\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 586
    },
    "return": "String",
    "signature": "protected String updateTargetUrl(String targetUrl, Map<String, Object> model,\n\t\t\tHttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected String updateTargetUrl(String targetUrl, Map<String, Object> model,"
  },
  "org.springframework.web.servlet.view.RedirectView#urlEncode(input,encodingScheme)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * URL-encode the given input String with the given encoding scheme.\n\t * <p>The default implementation uses {@code URLEncoder.encode(input, enc)}.\n\t * @param input the unencoded input String\n\t * @param encodingScheme the encoding scheme\n\t * @return the encoded output String\n\t * @throws UnsupportedEncodingException if thrown by the JDK URLEncoder\n\t * @see java.net.URLEncoder#encode(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "input",
      "encodingScheme"
    ],
    "position": {
      "column": 1,
      "line": 576
    },
    "return": "String",
    "signature": "protected String urlEncode(String input, String encodingScheme)",
    "source_code": "\tprotected String urlEncode(String input, String encodingScheme) throws UnsupportedEncodingException {\n\t\treturn URLEncoder.encode(input, encodingScheme);\n\t}"
  },
  "org.springframework.web.socket.messaging.CONNECTED_USER_HEADER": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The name of the header set on the CONNECTED frame indicating the name\n\t * of the user authenticated on the WebSocket session.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "signature": "public String CONNECTED_USER_HEADER",
    "source_code": "\tpublic static final String CONNECTED_USER_HEADER = \"user-name\";",
    "type": "String"
  },
  "org.springframework.web.socket.messaging.MINIMUM_WEBSOCKET_MESSAGE_SIZE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This handler supports assembling large STOMP messages split into multiple\n\t * WebSocket messages and STOMP clients (like stomp.js) indeed split large STOMP\n\t * messages at 16K boundaries. Therefore the WebSocket server input message\n\t * buffer size must allow 16K at least plus a little extra for SockJS framing.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "signature": "public int MINIMUM_WEBSOCKET_MESSAGE_SIZE",
    "source_code": "\tpublic static final int MINIMUM_WEBSOCKET_MESSAGE_SIZE = 16 * 1024 + 256;",
    "type": "int"
  },
  "org.springframework.web.socket.messaging.Stats": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Contract for access to session counters.\n\t * @since 5.2\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 688
    },
    "signature": "public interface Stats",
    "source_code": "\tpublic interface Stats {\n\n\t\t/**\n\t\t * The number of CONNECT frames processed.\n\t\t */\n\t\tint getTotalConnect();\n\n\t\t/**\n\t\t * The number of CONNECTED frames processed.\n\t\t */\n\t\tint getTotalConnected();\n\n\t\t/**\n\t\t * The number of DISCONNECT frames processed.\n\t\t */\n\t\tint getTotalDisconnect();\n\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@link SubProtocolHandler} for STOMP that supports versions 1.0, 1.1, and 1.2\n * of the STOMP specification.\n *\n * @author Rossen Stoyanchev\n * @author Andy Wilkinson\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "signature": "public class StompSubProtocolHandler",
    "source_code": "public class StompSubProtocolHandler implements SubProtocolHandler, ApplicationEventPublisherAware {\n\n\t/**\n\t * This handler supports assembling large STOMP messages split into multiple\n\t * WebSocket messages and STOMP clients (like stomp.js) indeed split large STOMP\n\t * messages at 16K boundaries. Therefore the WebSocket server input message\n\t * buffer size must allow 16K at least plus a little extra for SockJS framing.\n\t */\n\tpublic static final int MINIMUM_WEBSOCKET_MESSAGE_SIZE = 16 * 1024 + 256;\n\n\t/**\n\t * The name of the header set on the CONNECTED frame indicating the name\n\t * of the user authenticated on the WebSocket session.\n\t */\n\tpublic static final String CONNECTED_USER_HEADER = \"user-name\";\n\n\tprivate static final String[] SUPPORTED_VERSIONS = {\"1.2\", \"1.1\", \"1.0\"};\n\n\tprivate static final Log logger = LogFactory.getLog(StompSubProtocolHandler.class);\n\n\tprivate static final byte[] EMPTY_PAYLOAD = new byte[0];\n\n\n\t@Nullable\n\tprivate StompSubProtocolErrorHandler errorHandler;\n\n\tprivate int messageSizeLimit = 64 * 1024;\n\n\tprivate StompEncoder stompEncoder = new StompEncoder();\n\n\tprivate StompDecoder stompDecoder = new StompDecoder();\n\n\tprivate final Map<String, BufferingStompDecoder> decoders = new ConcurrentHashMap<>();\n\n\t@Nullable\n\tprivate MessageHeaderInitializer headerInitializer;\n\n\tprivate final Map<String, Principal> stompAuthentications = new ConcurrentHashMap<>();\n\n\t@Nullable\n\tprivate Boolean immutableMessageInterceptorPresent;\n\n\t@Nullable\n\tprivate ApplicationEventPublisher eventPublisher;\n\n\tprivate final DefaultStats stats = new DefaultStats();\n\n\n\t/**\n\t * Configure a handler for error messages sent to clients which allows\n\t * customizing the error messages or preventing them from being sent.\n\t * <p>By default this isn't configured in which case an ERROR frame is sent\n\t * with a message header reflecting the error.\n\t * @param errorHandler the error handler\n\t */\n\tpublic void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {\n\t\tthis.errorHandler = errorHandler;\n\t}\n\n\t/**\n\t * Return the configured error handler.\n\t */\n\t@Nullable\n\tpublic StompSubProtocolErrorHandler getErrorHandler() {\n\t\treturn this.errorHandler;\n\t}\n\n\t/**\n\t * Configure the maximum size allowed for an incoming STOMP message.\n\t * Since a STOMP message can be received in multiple WebSocket messages,\n\t * buffering may be required and therefore it is necessary to know the maximum\n\t * allowed message size.\n\t * <p>By default this property is set to 64K.\n\t * @since 4.0.3\n\t */\n\tpublic void setMessageSizeLimit(int messageSizeLimit) {\n\t\tthis.messageSizeLimit = messageSizeLimit;\n\t}\n\n\t/**\n\t * Get the configured message buffer size limit in bytes.\n\t * @since 4.0.3\n\t */\n\tpublic int getMessageSizeLimit() {\n\t\treturn this.messageSizeLimit;\n\t}\n\n\t/**\n\t * Configure a {@link StompEncoder} for encoding STOMP frames.\n\t * @since 4.3.5\n\t */\n\tpublic void setEncoder(StompEncoder encoder) {\n\t\tthis.stompEncoder = encoder;\n\t}\n\n\t/**\n\t * Configure a {@link StompDecoder} for decoding STOMP frames.\n\t * @since 4.3.5\n\t */\n\tpublic void setDecoder(StompDecoder decoder) {\n\t\tthis.stompDecoder = decoder;\n\t}\n\n\t/**\n\t * Configure a {@link MessageHeaderInitializer} to apply to the headers of all\n\t * messages created from decoded STOMP frames and other messages sent to the\n\t * client inbound channel.\n\t * <p>By default this property is not set.\n\t */\n\tpublic void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {\n\t\tthis.headerInitializer = headerInitializer;\n\t\tthis.stompDecoder.setHeaderInitializer(headerInitializer);\n\t}\n\n\t/**\n\t * Return the configured header initializer.\n\t */\n\t@Nullable\n\tpublic MessageHeaderInitializer getHeaderInitializer() {\n\t\treturn this.headerInitializer;\n\t}\n\n\t@Override\n\tpublic List<String> getSupportedProtocols() {\n\t\treturn Arrays.asList(\"v10.stomp\", \"v11.stomp\", \"v12.stomp\");\n\t}\n\n\t@Override\n\tpublic void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {\n\t\tthis.eventPublisher = applicationEventPublisher;\n\t}\n\n\t/**\n\t * Return a String describing internal state and counters.\n\t * Effectively {@code toString()} on {@link #getStats() getStats()}.\n\t */\n\tpublic String getStatsInfo() {\n\t\treturn this.stats.toString();\n\t}\n\n\t/**\n\t * Return a structured object with internal state and counters.\n\t * @since 5.2\n\t */\n\tpublic Stats getStats() {\n\t\treturn this.stats;\n\t}\n\n\n\t/**\n\t * Handle incoming WebSocket messages from clients.\n\t */\n\t@Override\n\tpublic void handleMessageFromClient(WebSocketSession session,\n\t\t\tWebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {\n\n\t\tList<Message<byte[]>> messages;\n\t\ttry {\n\t\t\tByteBuffer byteBuffer;\n\t\t\tif (webSocketMessage instanceof TextMessage) {\n\t\t\t\tbyteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes());\n\t\t\t}\n\t\t\telse if (webSocketMessage instanceof BinaryMessage) {\n\t\t\t\tbyteBuffer = ((BinaryMessage) webSocketMessage).getPayload();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tBufferingStompDecoder decoder = this.decoders.get(session.getId());\n\t\t\tif (decoder == null) {\n\t\t\t\tif (!session.isOpen()) {\n\t\t\t\t\tlogger.trace(\"Dropped inbound WebSocket message due to closed session\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthrow new IllegalStateException(\"No decoder for session id '\" + session.getId() + \"'\");\n\t\t\t}\n\n\t\t\tmessages = decoder.decode(byteBuffer);\n\t\t\tif (messages.isEmpty()) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Incomplete STOMP frame content received in session \" +\n\t\t\t\t\t\t\tsession + \", bufferSize=\" + decoder.getBufferSize() +\n\t\t\t\t\t\t\t\", bufferSizeLimit=\" + decoder.getBufferSizeLimit() + \".\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Failed to parse \" + webSocketMessage +\n\t\t\t\t\t\t\" in session \" + session.getId() + \". Sending STOMP ERROR to client.\", ex);\n\t\t\t}\n\t\t\thandleError(session, ex, null);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (Message<byte[]> message : messages) {\n\t\t\tStompHeaderAccessor headerAccessor =\n\t\t\t\t\tMessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);\n\t\t\tAssert.state(headerAccessor != null, \"No StompHeaderAccessor\");\n\n\t\t\tStompCommand command = headerAccessor.getCommand();\n\t\t\tboolean isConnect = StompCommand.CONNECT.equals(command) || StompCommand.STOMP.equals(command);\n\n\t\t\tboolean sent = false;\n\t\t\ttry {\n\n\t\t\t\theaderAccessor.setSessionId(session.getId());\n\t\t\t\theaderAccessor.setSessionAttributes(session.getAttributes());\n\t\t\t\theaderAccessor.setUser(getUser(session));\n\t\t\t\tif (isConnect) {\n\t\t\t\t\theaderAccessor.setUserChangeCallback(user -> {\n\t\t\t\t\t\tif (user != null && user != session.getPrincipal()) {\n\t\t\t\t\t\t\tthis.stompAuthentications.put(session.getId(), user);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\theaderAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat());\n\t\t\t\tif (!detectImmutableMessageInterceptor(outputChannel)) {\n\t\t\t\t\theaderAccessor.setImmutable();\n\t\t\t\t}\n\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"From client: \" + headerAccessor.getShortLogMessage(message.getPayload()));\n\t\t\t\t}\n\n\t\t\t\tif (isConnect) {\n\t\t\t\t\tthis.stats.incrementConnectCount();\n\t\t\t\t}\n\t\t\t\telse if (StompCommand.DISCONNECT.equals(command)) {\n\t\t\t\t\tthis.stats.incrementDisconnectCount();\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tSimpAttributesContextHolder.setAttributesFromMessage(message);\n\t\t\t\t\tsent = outputChannel.send(message);\n\n\t\t\t\t\tif (sent) {\n\t\t\t\t\t\tif (this.eventPublisher != null) {\n\t\t\t\t\t\t\tPrincipal user = getUser(session);\n\t\t\t\t\t\t\tif (isConnect) {\n\t\t\t\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionConnectEvent(this, message, user));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (StompCommand.SUBSCRIBE.equals(command)) {\n\t\t\t\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionSubscribeEvent(this, message, user));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (StompCommand.UNSUBSCRIBE.equals(command)) {\n\t\t\t\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionUnsubscribeEvent(this, message, user));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tSimpAttributesContextHolder.resetAttributes();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Failed to send message to MessageChannel in session \" + session.getId(), ex);\n\t\t\t\t}\n\t\t\t\telse if (logger.isErrorEnabled()) {\n\t\t\t\t\t// Skip unsent CONNECT messages (likely auth issues)\n\t\t\t\t\tif (!isConnect || sent) {\n\t\t\t\t\t\tlogger.error(\"Failed to send message to MessageChannel in session \" + session.getId() +\n\t\t\t\t\t\t\t\t\":\" + ex.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\thandleError(session, ex, message);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Nullable\n\tprivate Principal getUser(WebSocketSession session) {\n\t\tPrincipal user = this.stompAuthentications.get(session.getId());\n\t\treturn (user != null ? user : session.getPrincipal());\n\t}\n\n\tprivate void handleError(WebSocketSession session, Throwable ex, @Nullable Message<byte[]> clientMessage) {\n\t\tif (getErrorHandler() == null) {\n\t\t\tsendErrorMessage(session, ex);\n\t\t\treturn;\n\t\t}\n\t\tMessage<byte[]> message = getErrorHandler().handleClientMessageProcessingError(clientMessage, ex);\n\t\tif (message == null) {\n\t\t\treturn;\n\t\t}\n\t\tStompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);\n\t\tAssert.state(accessor != null, \"No StompHeaderAccessor\");\n\t\tsendToClient(session, accessor, message.getPayload());\n\t}\n\n\t/**\n\t * Invoked when no\n\t * {@link #setErrorHandler(StompSubProtocolErrorHandler) errorHandler}\n\t * is configured to send an ERROR frame to the client.\n\t */\n\tprivate void sendErrorMessage(WebSocketSession session, Throwable error) {\n\t\tStompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.ERROR);\n\t\theaderAccessor.setMessage(error.getMessage());\n\n\t\tbyte[] bytes = this.stompEncoder.encode(headerAccessor.getMessageHeaders(), EMPTY_PAYLOAD);\n\t\t// We cannot use try-with-resources here for the WebSocketSession, since we have\n\t\t// custom handling of the close() method in a finally-block.\n\t\ttry {\n\t\t\tsession.sendMessage(new TextMessage(bytes));\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// Could be part of normal workflow (e.g. browser tab closed)\n\t\t\tlogger.debug(\"Failed to send STOMP ERROR to client\", ex);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tsession.close(CloseStatus.PROTOCOL_ERROR);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean detectImmutableMessageInterceptor(MessageChannel channel) {\n\t\tif (this.immutableMessageInterceptorPresent != null) {\n\t\t\treturn this.immutableMessageInterceptorPresent;\n\t\t}\n\n\t\tif (channel instanceof AbstractMessageChannel) {\n\t\t\tfor (ChannelInterceptor interceptor : ((AbstractMessageChannel) channel).getInterceptors()) {\n\t\t\t\tif (interceptor instanceof ImmutableMessageChannelInterceptor) {\n\t\t\t\t\tthis.immutableMessageInterceptorPresent = true;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.immutableMessageInterceptorPresent = false;\n\t\treturn false;\n\t}\n\n\tprivate void publishEvent(ApplicationEventPublisher publisher, ApplicationEvent event) {\n\t\ttry {\n\t\t\tpublisher.publishEvent(event);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Error publishing \" + event, ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Handle STOMP messages going back out to WebSocket clients.\n\t */\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void handleMessageToClient(WebSocketSession session, Message<?> message) {\n\t\tif (!(message.getPayload() instanceof byte[] payload)) {\n\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Expected byte[] payload. Ignoring \" + message + \".\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tStompHeaderAccessor accessor = getStompHeaderAccessor(message);\n\t\tStompCommand command = accessor.getCommand();\n\n\t\tif (StompCommand.MESSAGE.equals(command)) {\n\t\t\tif (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"No STOMP \\\"subscription\\\" header in \" + message);\n\t\t\t}\n\t\t\tString origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION);\n\t\t\tif (origDestination != null) {\n\t\t\t\taccessor = toMutableAccessor(accessor, message);\n\t\t\t\taccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION);\n\t\t\t\taccessor.setDestination(origDestination);\n\t\t\t}\n\t\t}\n\t\telse if (StompCommand.CONNECTED.equals(command)) {\n\t\t\tthis.stats.incrementConnectedCount();\n\t\t\taccessor = afterStompSessionConnected(message, accessor, session);\n\t\t\tif (this.eventPublisher != null) {\n\t\t\t\ttry {\n\t\t\t\t\tSimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes());\n\t\t\t\t\tSimpAttributesContextHolder.setAttributes(simpAttributes);\n\t\t\t\t\tPrincipal user = getUser(session);\n\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionConnectedEvent(this, (Message<byte[]>) message, user));\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tSimpAttributesContextHolder.resetAttributes();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {\n\t\t\tMessage<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message);\n\t\t\tif (errorMessage != null) {\n\t\t\t\taccessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class);\n\t\t\t\tAssert.state(accessor != null, \"No StompHeaderAccessor\");\n\t\t\t\tpayload = errorMessage.getPayload();\n\t\t\t}\n\t\t}\n\n\t\tRunnable task = OrderedMessageChannelDecorator.getNextMessageTask(message);\n\t\tif (task != null) {\n\t\t\tAssert.isInstanceOf(ConcurrentWebSocketSessionDecorator.class, session);\n\t\t\t((ConcurrentWebSocketSessionDecorator) session).setMessageCallback(m -> task.run());\n\t\t}\n\n\t\tsendToClient(session, accessor, payload);\n\t}\n\n\tprivate void sendToClient(WebSocketSession session, StompHeaderAccessor stompAccessor, byte[] payload) {\n\t\tStompCommand command = stompAccessor.getCommand();\n\t\ttry {\n\t\t\tbyte[] bytes = this.stompEncoder.encode(stompAccessor.getMessageHeaders(), payload);\n\t\t\tboolean useBinary = (payload.length > 0 && !(session instanceof SockJsSession) &&\n\t\t\t\t\tMimeTypeUtils.APPLICATION_OCTET_STREAM.isCompatibleWith(stompAccessor.getContentType()));\n\t\t\tif (useBinary) {\n\t\t\t\tsession.sendMessage(new BinaryMessage(bytes));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsession.sendMessage(new TextMessage(bytes));\n\t\t\t}\n\t\t}\n\t\tcatch (SessionLimitExceededException ex) {\n\t\t\t// Bad session, just get out\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// Could be part of normal workflow (e.g. browser tab closed)\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Failed to send WebSocket message to client in session \" + session.getId(), ex);\n\t\t\t}\n\t\t\tcommand = StompCommand.ERROR;\n\t\t}\n\t\tfinally {\n\t\t\tif (StompCommand.ERROR.equals(command)) {\n\t\t\t\ttry {\n\t\t\t\t\tsession.close(CloseStatus.PROTOCOL_ERROR);\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate StompHeaderAccessor getStompHeaderAccessor(Message<?> message) {\n\t\tMessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class);\n\t\tif (accessor instanceof StompHeaderAccessor) {\n\t\t\treturn (StompHeaderAccessor) accessor;\n\t\t}\n\t\telse {\n\t\t\tStompHeaderAccessor stompAccessor = StompHeaderAccessor.wrap(message);\n\t\t\tSimpMessageType messageType = SimpMessageHeaderAccessor.getMessageType(message.getHeaders());\n\t\t\tif (SimpMessageType.CONNECT_ACK.equals(messageType)) {\n\t\t\t\tstompAccessor = convertConnectAcktoStompConnected(stompAccessor);\n\t\t\t}\n\t\t\telse if (SimpMessageType.DISCONNECT_ACK.equals(messageType)) {\n\t\t\t\tString receipt = getDisconnectReceipt(stompAccessor);\n\t\t\t\tif (receipt != null) {\n\t\t\t\t\tstompAccessor = StompHeaderAccessor.create(StompCommand.RECEIPT);\n\t\t\t\t\tstompAccessor.setReceiptId(receipt);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstompAccessor = StompHeaderAccessor.create(StompCommand.ERROR);\n\t\t\t\t\tstompAccessor.setMessage(\"Session closed.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (SimpMessageType.HEARTBEAT.equals(messageType)) {\n\t\t\t\tstompAccessor = StompHeaderAccessor.createForHeartbeat();\n\t\t\t}\n\t\t\telse if (stompAccessor.getCommand() == null || StompCommand.SEND.equals(stompAccessor.getCommand())) {\n\t\t\t\tstompAccessor.updateStompCommandAsServerMessage();\n\t\t\t}\n\t\t\treturn stompAccessor;\n\t\t}\n\t}\n\n\t/**\n\t * The simple broker produces {@code SimpMessageType.CONNECT_ACK} that's not STOMP\n\t * specific and needs to be turned into a STOMP CONNECTED frame.\n\t */\n\tprivate StompHeaderAccessor convertConnectAcktoStompConnected(StompHeaderAccessor connectAckHeaders) {\n\t\tString name = StompHeaderAccessor.CONNECT_MESSAGE_HEADER;\n\t\tMessage<?> message = (Message<?>) connectAckHeaders.getHeader(name);\n\t\tif (message == null) {\n\t\t\tthrow new IllegalStateException(\"Original STOMP CONNECT not found in \" + connectAckHeaders);\n\t\t}\n\n\t\tStompHeaderAccessor connectHeaders = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);\n\t\tStompHeaderAccessor connectedHeaders = StompHeaderAccessor.create(StompCommand.CONNECTED);\n\n\t\tif (connectHeaders != null) {\n\t\t\tSet<String> acceptVersions = connectHeaders.getAcceptVersion();\n\t\t\tconnectedHeaders.setVersion(\n\t\t\t\t\tArrays.stream(SUPPORTED_VERSIONS)\n\t\t\t\t\t\t\t.filter(acceptVersions::contains)\n\t\t\t\t\t\t\t.findAny()\n\t\t\t\t\t\t\t.orElseThrow(() -> new IllegalArgumentException(\n\t\t\t\t\t\t\t\t\t\"Unsupported STOMP version '\" + acceptVersions + \"'\")));\n\t\t}\n\n\t\tlong[] heartbeat = (long[]) connectAckHeaders.getHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER);\n\t\tif (heartbeat != null) {\n\t\t\tconnectedHeaders.setHeartbeat(heartbeat[0], heartbeat[1]);\n\t\t}\n\t\telse {\n\t\t\tconnectedHeaders.setHeartbeat(0, 0);\n\t\t}\n\n\t\treturn connectedHeaders;\n\t}\n\n\t@Nullable\n\tprivate String getDisconnectReceipt(SimpMessageHeaderAccessor simpHeaders) {\n\t\tString name = StompHeaderAccessor.DISCONNECT_MESSAGE_HEADER;\n\t\tMessage<?> message = (Message<?>) simpHeaders.getHeader(name);\n\t\tif (message != null) {\n\t\t\tStompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);\n\t\t\tif (accessor != null) {\n\t\t\t\treturn accessor.getReceipt();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected StompHeaderAccessor toMutableAccessor(StompHeaderAccessor headerAccessor, Message<?> message) {\n\t\treturn (headerAccessor.isMutable() ? headerAccessor : StompHeaderAccessor.wrap(message));\n\t}\n\n\tprivate StompHeaderAccessor afterStompSessionConnected(Message<?> message, StompHeaderAccessor accessor,\n\t\t\tWebSocketSession session) {\n\n\t\tPrincipal principal = getUser(session);\n\t\tif (principal != null) {\n\t\t\taccessor = toMutableAccessor(accessor, message);\n\t\t\taccessor.setNativeHeader(CONNECTED_USER_HEADER, principal.getName());\n\t\t}\n\n\t\tlong[] heartbeat = accessor.getHeartbeat();\n\t\tif (heartbeat[1] > 0) {\n\t\t\tsession = WebSocketSessionDecorator.unwrap(session);\n\t\t\tif (session instanceof SockJsSession) {\n\t\t\t\t((SockJsSession) session).disableHeartbeat();\n\t\t\t}\n\t\t}\n\n\t\treturn accessor;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic String resolveSessionId(Message<?> message) {\n\t\treturn SimpMessageHeaderAccessor.getSessionId(message.getHeaders());\n\t}\n\n\t@Override\n\tpublic void afterSessionStarted(WebSocketSession session, MessageChannel outputChannel) {\n\t\tif (session.getTextMessageSizeLimit() < MINIMUM_WEBSOCKET_MESSAGE_SIZE) {\n\t\t\tsession.setTextMessageSizeLimit(MINIMUM_WEBSOCKET_MESSAGE_SIZE);\n\t\t}\n\t\tthis.decoders.put(session.getId(), new BufferingStompDecoder(this.stompDecoder, getMessageSizeLimit()));\n\t}\n\n\t@Override\n\tpublic void afterSessionEnded(WebSocketSession session, CloseStatus closeStatus, MessageChannel outputChannel) {\n\t\tthis.decoders.remove(session.getId());\n\n\t\tMessage<byte[]> message = createDisconnectMessage(session);\n\t\tSimpAttributes simpAttributes = SimpAttributes.fromMessage(message);\n\t\ttry {\n\t\t\tSimpAttributesContextHolder.setAttributes(simpAttributes);\n\t\t\tif (this.eventPublisher != null) {\n\t\t\t\tPrincipal user = getUser(session);\n\t\t\t\tpublishEvent(this.eventPublisher, new SessionDisconnectEvent(this, message, session.getId(), closeStatus, user));\n\t\t\t}\n\t\t\toutputChannel.send(message);\n\t\t}\n\t\tfinally {\n\t\t\tthis.stompAuthentications.remove(session.getId());\n\t\t\tSimpAttributesContextHolder.resetAttributes();\n\t\t\tsimpAttributes.sessionCompleted();\n\t\t}\n\t}\n\n\tprivate Message<byte[]> createDisconnectMessage(WebSocketSession session) {\n\t\tStompHeaderAccessor headerAccessor = StompHeaderAccessor.create(StompCommand.DISCONNECT);\n\t\tif (getHeaderInitializer() != null) {\n\t\t\tgetHeaderInitializer().initHeaders(headerAccessor);\n\t\t}\n\n\t\theaderAccessor.setSessionId(session.getId());\n\t\theaderAccessor.setSessionAttributes(session.getAttributes());\n\n\t\tPrincipal user = getUser(session);\n\t\tif (user != null) {\n\t\t\theaderAccessor.setUser(user);\n\t\t}\n\n\t\treturn MessageBuilder.createMessage(EMPTY_PAYLOAD, headerAccessor.getMessageHeaders());\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"StompSubProtocolHandler\" + getSupportedProtocols();\n\t}\n\n\n\t/**\n\t * Contract for access to session counters.\n\t * @since 5.2\n\t */\n\tpublic interface Stats {\n\n\t\t/**\n\t\t * The number of CONNECT frames processed.\n\t\t */\n\t\tint getTotalConnect();\n\n\t\t/**\n\t\t * The number of CONNECTED frames processed.\n\t\t */\n\t\tint getTotalConnected();\n\n\t\t/**\n\t\t * The number of DISCONNECT frames processed.\n\t\t */\n\t\tint getTotalDisconnect();\n\t}\n\n\n\tprivate static class DefaultStats implements Stats {\n\n\t\tprivate final AtomicInteger connect = new AtomicInteger();\n\n\t\tprivate final AtomicInteger connected = new AtomicInteger();\n\n\t\tprivate final AtomicInteger disconnect = new AtomicInteger();\n\n\t\tpublic void incrementConnectCount() {\n\t\t\tthis.connect.incrementAndGet();\n\t\t}\n\n\t\tpublic void incrementConnectedCount() {\n\t\t\tthis.connected.incrementAndGet();\n\t\t}\n\n\t\tpublic void incrementDisconnectCount() {\n\t\t\tthis.disconnect.incrementAndGet();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getTotalConnect() {\n\t\t\treturn this.connect.get();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getTotalConnected() {\n\t\t\treturn this.connected.get();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getTotalDisconnect() {\n\t\t\treturn this.disconnect.get();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"processed CONNECT(\" + this.connect.get() + \")-CONNECTED(\" +\n\t\t\t\t\tthis.connected.get() + \")-DISCONNECT(\" + this.disconnect.get() + \")\";\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#afterSessionEnded(session,closeStatus,outputChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "closeStatus",
      "outputChannel"
    ],
    "position": {
      "column": 1,
      "line": 640
    },
    "return": "void",
    "signature": "public void afterSessionEnded(WebSocketSession session, CloseStatus closeStatus, MessageChannel outputChannel)",
    "source_code": "\tpublic void afterSessionEnded(WebSocketSession session, CloseStatus closeStatus, MessageChannel outputChannel) {\n\t\tthis.decoders.remove(session.getId());\n\n\t\tMessage<byte[]> message = createDisconnectMessage(session);\n\t\tSimpAttributes simpAttributes = SimpAttributes.fromMessage(message);\n\t\ttry {\n\t\t\tSimpAttributesContextHolder.setAttributes(simpAttributes);\n\t\t\tif (this.eventPublisher != null) {\n\t\t\t\tPrincipal user = getUser(session);\n\t\t\t\tpublishEvent(this.eventPublisher, new SessionDisconnectEvent(this, message, session.getId(), closeStatus, user));\n\t\t\t}\n\t\t\toutputChannel.send(message);\n\t\t}\n\t\tfinally {\n\t\t\tthis.stompAuthentications.remove(session.getId());\n\t\t\tSimpAttributesContextHolder.resetAttributes();\n\t\t\tsimpAttributes.sessionCompleted();\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#afterSessionStarted(session,outputChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "outputChannel"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "void",
    "signature": "public void afterSessionStarted(WebSocketSession session, MessageChannel outputChannel)",
    "source_code": "\tpublic void afterSessionStarted(WebSocketSession session, MessageChannel outputChannel) {\n\t\tif (session.getTextMessageSizeLimit() < MINIMUM_WEBSOCKET_MESSAGE_SIZE) {\n\t\t\tsession.setTextMessageSizeLimit(MINIMUM_WEBSOCKET_MESSAGE_SIZE);\n\t\t}\n\t\tthis.decoders.put(session.getId(), new BufferingStompDecoder(this.stompDecoder, getMessageSizeLimit()));\n\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#getErrorHandler()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured error handler.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "StompSubProtocolErrorHandler",
    "signature": "public StompSubProtocolErrorHandler getErrorHandler()",
    "source_code": "\tpublic StompSubProtocolErrorHandler getErrorHandler() {\n\t\treturn this.errorHandler;\n\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#getHeaderInitializer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured header initializer.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "MessageHeaderInitializer",
    "signature": "public MessageHeaderInitializer getHeaderInitializer()",
    "source_code": "\tpublic MessageHeaderInitializer getHeaderInitializer() {\n\t\treturn this.headerInitializer;\n\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#getMessageSizeLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the configured message buffer size limit in bytes.\n\t * @since 4.0.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "int",
    "signature": "public int getMessageSizeLimit()",
    "source_code": "\tpublic int getMessageSizeLimit() {\n\t\treturn this.messageSizeLimit;\n\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#getStats()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a structured object with internal state and counters.\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "Stats",
    "signature": "public Stats getStats()",
    "source_code": "\tpublic Stats getStats() {\n\t\treturn this.stats;\n\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#getStatsInfo()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a String describing internal state and counters.\n\t * Effectively {@code toString()} on {@link #getStats() getStats()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "String",
    "signature": "public String getStatsInfo()",
    "source_code": "\tpublic String getStatsInfo() {\n\t\treturn this.stats.toString();\n\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#getSupportedProtocols()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "List<String>",
    "signature": "public List<String> getSupportedProtocols()",
    "source_code": "\tpublic List<String> getSupportedProtocols() {\n\t\treturn Arrays.asList(\"v10.stomp\", \"v11.stomp\", \"v12.stomp\");\n\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#getTotalConnect()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 728
    },
    "return": "int",
    "signature": "public int getTotalConnect()",
    "source_code": "\t\tpublic int getTotalConnect() {\n\t\t\treturn this.connect.get();\n\t\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#getTotalConnected()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 733
    },
    "return": "int",
    "signature": "public int getTotalConnected()",
    "source_code": "\t\tpublic int getTotalConnected() {\n\t\t\treturn this.connected.get();\n\t\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#getTotalDisconnect()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 738
    },
    "return": "int",
    "signature": "public int getTotalDisconnect()",
    "source_code": "\t\tpublic int getTotalDisconnect() {\n\t\t\treturn this.disconnect.get();\n\t\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#handleMessageFromClient(session,webSocketMessage,outputChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle incoming WebSocket messages from clients.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "webSocketMessage",
      "outputChannel"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "void",
    "signature": "public void handleMessageFromClient(WebSocketSession session,\n\t\t\tWebSocketMessage<?> webSocketMessage, MessageChannel outputChannel)",
    "source_code": "\tpublic void handleMessageFromClient(WebSocketSession session,"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#handleMessageToClient(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle STOMP messages going back out to WebSocket clients.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "void",
    "signature": "public void handleMessageToClient(WebSocketSession session, Message<?> message)",
    "source_code": "\tpublic void handleMessageToClient(WebSocketSession session, Message<?> message) {\n\t\tif (!(message.getPayload() instanceof byte[] payload)) {\n\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Expected byte[] payload. Ignoring \" + message + \".\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tStompHeaderAccessor accessor = getStompHeaderAccessor(message);\n\t\tStompCommand command = accessor.getCommand();\n\n\t\tif (StompCommand.MESSAGE.equals(command)) {\n\t\t\tif (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"No STOMP \\\"subscription\\\" header in \" + message);\n\t\t\t}\n\t\t\tString origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION);\n\t\t\tif (origDestination != null) {\n\t\t\t\taccessor = toMutableAccessor(accessor, message);\n\t\t\t\taccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION);\n\t\t\t\taccessor.setDestination(origDestination);\n\t\t\t}\n\t\t}\n\t\telse if (StompCommand.CONNECTED.equals(command)) {\n\t\t\tthis.stats.incrementConnectedCount();\n\t\t\taccessor = afterStompSessionConnected(message, accessor, session);\n\t\t\tif (this.eventPublisher != null) {\n\t\t\t\ttry {\n\t\t\t\t\tSimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes());\n\t\t\t\t\tSimpAttributesContextHolder.setAttributes(simpAttributes);\n\t\t\t\t\tPrincipal user = getUser(session);\n\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionConnectedEvent(this, (Message<byte[]>) message, user));\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tSimpAttributesContextHolder.resetAttributes();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {\n\t\t\tMessage<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message);\n\t\t\tif (errorMessage != null) {\n\t\t\t\taccessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class);\n\t\t\t\tAssert.state(accessor != null, \"No StompHeaderAccessor\");\n\t\t\t\tpayload = errorMessage.getPayload();\n\t\t\t}\n\t\t}\n\n\t\tRunnable task = OrderedMessageChannelDecorator.getNextMessageTask(message);\n\t\tif (task != null) {\n\t\t\tAssert.isInstanceOf(ConcurrentWebSocketSessionDecorator.class, session);\n\t\t\t((ConcurrentWebSocketSessionDecorator) session).setMessageCallback(m -> task.run());\n\t\t}\n\n\t\tsendToClient(session, accessor, payload);\n\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#incrementConnectCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 715
    },
    "return": "void",
    "signature": "public void incrementConnectCount()",
    "source_code": "\t\tpublic void incrementConnectCount() {\n\t\t\tthis.connect.incrementAndGet();\n\t\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#incrementConnectedCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 719
    },
    "return": "void",
    "signature": "public void incrementConnectedCount()",
    "source_code": "\t\tpublic void incrementConnectedCount() {\n\t\t\tthis.connected.incrementAndGet();\n\t\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#incrementDisconnectCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 723
    },
    "return": "void",
    "signature": "public void incrementDisconnectCount()",
    "source_code": "\t\tpublic void incrementDisconnectCount() {\n\t\t\tthis.disconnect.incrementAndGet();\n\t\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#resolveSessionId(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 627
    },
    "return": "String",
    "signature": "public String resolveSessionId(Message<?> message)",
    "source_code": "\tpublic String resolveSessionId(Message<?> message) {\n\t\treturn SimpMessageHeaderAccessor.getSessionId(message.getHeaders());\n\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#setApplicationEventPublisher(applicationEventPublisher)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationEventPublisher"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher)",
    "source_code": "\tpublic void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {\n\t\tthis.eventPublisher = applicationEventPublisher;\n\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#setDecoder(decoder)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link StompDecoder} for decoding STOMP frames.\n\t * @since 4.3.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "decoder"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "public void setDecoder(StompDecoder decoder)",
    "source_code": "\tpublic void setDecoder(StompDecoder decoder) {\n\t\tthis.stompDecoder = decoder;\n\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#setEncoder(encoder)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link StompEncoder} for encoding STOMP frames.\n\t * @since 4.3.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "void",
    "signature": "public void setEncoder(StompEncoder encoder)",
    "source_code": "\tpublic void setEncoder(StompEncoder encoder) {\n\t\tthis.stompEncoder = encoder;\n\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#setErrorHandler(errorHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a handler for error messages sent to clients which allows\n\t * customizing the error messages or preventing them from being sent.\n\t * <p>By default this isn't configured in which case an ERROR frame is sent\n\t * with a message header reflecting the error.\n\t * @param errorHandler the error handler\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "void",
    "signature": "public void setErrorHandler(StompSubProtocolErrorHandler errorHandler)",
    "source_code": "\tpublic void setErrorHandler(StompSubProtocolErrorHandler errorHandler) {\n\t\tthis.errorHandler = errorHandler;\n\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#setHeaderInitializer(headerInitializer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link MessageHeaderInitializer} to apply to the headers of all\n\t * messages created from decoded STOMP frames and other messages sent to the\n\t * client inbound channel.\n\t * <p>By default this property is not set.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerInitializer"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer)",
    "source_code": "\tpublic void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {\n\t\tthis.headerInitializer = headerInitializer;\n\t\tthis.stompDecoder.setHeaderInitializer(headerInitializer);\n\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#setMessageSizeLimit(messageSizeLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the maximum size allowed for an incoming STOMP message.\n\t * Since a STOMP message can be received in multiple WebSocket messages,\n\t * buffering may be required and therefore it is necessary to know the maximum\n\t * allowed message size.\n\t * <p>By default this property is set to 64K.\n\t * @since 4.0.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSizeLimit"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void setMessageSizeLimit(int messageSizeLimit)",
    "source_code": "\tpublic void setMessageSizeLimit(int messageSizeLimit) {\n\t\tthis.messageSizeLimit = messageSizeLimit;\n\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#toMutableAccessor(headerAccessor,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headerAccessor",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 601
    },
    "return": "StompHeaderAccessor",
    "signature": "protected StompHeaderAccessor toMutableAccessor(StompHeaderAccessor headerAccessor, Message<?> message)",
    "source_code": "\tprotected StompHeaderAccessor toMutableAccessor(StompHeaderAccessor headerAccessor, Message<?> message) {\n\t\treturn (headerAccessor.isMutable() ? headerAccessor : StompHeaderAccessor.wrap(message));\n\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 743
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn \"processed CONNECT(\" + this.connect.get() + \")-CONNECTED(\" +\n\t\t\t\t\tthis.connected.get() + \")-DISCONNECT(\" + this.disconnect.get() + \")\";\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Base class for SockJS client implementations of {@link WebSocketSession}.\n *\n * <p>Provides processing of incoming SockJS message frames and delegates lifecycle\n * events and messages to the (application) {@link WebSocketHandler}.\n *\n * <p>Subclasses implement actual send as well as disconnect logic.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public class AbstractClientSockJsSession",
    "source_code": "public abstract class AbstractClientSockJsSession implements WebSocketSession {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate final TransportRequest request;\n\n\tprivate final WebSocketHandler webSocketHandler;\n\n\tprivate final CompletableFuture<WebSocketSession> connectFuture;\n\n\tprivate final Map<String, Object> attributes = new ConcurrentHashMap<>();\n\n\t@Nullable\n\tprivate volatile State state = State.NEW;\n\n\t@Nullable\n\tprivate volatile CloseStatus closeStatus;\n\n\t/**\n\t * Create a new {@code AbstractClientSockJsSession}.\n\t * @deprecated as of 6.0, in favor of {@link #AbstractClientSockJsSession(TransportRequest, WebSocketHandler, CompletableFuture)}\n\t */\n\t@Deprecated(since = \"6.0\")\n\tprotected AbstractClientSockJsSession(TransportRequest request, WebSocketHandler handler,\n\t\t\torg.springframework.util.concurrent.SettableListenableFuture<WebSocketSession> connectFuture) {\n\t\tthis(request, handler, connectFuture.completable());\n\t}\n\n\tprotected AbstractClientSockJsSession(TransportRequest request, WebSocketHandler handler,\n\t\t\tCompletableFuture<WebSocketSession> connectFuture) {\n\n\t\tAssert.notNull(request, \"'request' is required\");\n\t\tAssert.notNull(handler, \"'handler' is required\");\n\t\tAssert.notNull(connectFuture, \"'connectFuture' is required\");\n\t\tthis.request = request;\n\t\tthis.webSocketHandler = handler;\n\t\tthis.connectFuture = connectFuture;\n\t}\n\n\n\t@Override\n\tpublic String getId() {\n\t\treturn this.request.getSockJsUrlInfo().getSessionId();\n\t}\n\n\t@Override\n\tpublic URI getUri() {\n\t\treturn this.request.getSockJsUrlInfo().getSockJsUrl();\n\t}\n\n\t@Override\n\tpublic HttpHeaders getHandshakeHeaders() {\n\t\treturn this.request.getHandshakeHeaders();\n\t}\n\n\t@Override\n\tpublic Map<String, Object> getAttributes() {\n\t\treturn this.attributes;\n\t}\n\n\t@Override\n\tpublic Principal getPrincipal() {\n\t\treturn this.request.getUser();\n\t}\n\n\tpublic SockJsMessageCodec getMessageCodec() {\n\t\treturn this.request.getMessageCodec();\n\t}\n\n\tpublic WebSocketHandler getWebSocketHandler() {\n\t\treturn this.webSocketHandler;\n\t}\n\n\t/**\n\t * Return a timeout cleanup task to invoke if the SockJS sessions is not\n\t * fully established within the retransmission timeout period calculated in\n\t * {@code SockJsRequest} based on the duration of the initial SockJS \"Info\"\n\t * request.\n\t */\n\tRunnable getTimeoutTask() {\n\t\treturn new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tcloseInternal(new CloseStatus(2007, \"Transport timed out\"));\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\tlogger.warn(\"Failed to close \" + this + \" after transport timeout\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t@Override\n\tpublic boolean isOpen() {\n\t\treturn (this.state == State.OPEN);\n\t}\n\n\tpublic boolean isDisconnected() {\n\t\treturn (this.state == State.CLOSING || this.state == State.CLOSED);\n\t}\n\n\t@Override\n\tpublic final void sendMessage(WebSocketMessage<?> message) throws IOException {\n\t\tif (!(message instanceof TextMessage)) {\n\t\t\tthrow new IllegalArgumentException(this + \" supports text messages only.\");\n\t\t}\n\t\tif (this.state != State.OPEN) {\n\t\t\tthrow new IllegalStateException(this + \" is not open: current state \" + this.state);\n\t\t}\n\n\t\tString payload = ((TextMessage) message).getPayload();\n\t\tpayload = getMessageCodec().encode(payload);\n\t\tpayload = payload.substring(1);  // the client-side doesn't need message framing (letter \"a\")\n\n\t\tTextMessage messageToSend = new TextMessage(payload);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Sending message \" + messageToSend + \" in \" + this);\n\t\t}\n\t\tsendInternal(messageToSend);\n\t}\n\n\tprotected abstract void sendInternal(TextMessage textMessage) throws IOException;\n\n\t@Override\n\tpublic final void close() throws IOException {\n\t\tclose(CloseStatus.NORMAL);\n\t}\n\n\t@Override\n\tpublic final void close(CloseStatus status) throws IOException {\n\t\tif (!isUserSetStatus(status)) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid close status: \" + status);\n\t\t}\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Closing session with \" +  status + \" in \" + this);\n\t\t}\n\t\tcloseInternal(status);\n\t}\n\n\tprivate boolean isUserSetStatus(@Nullable CloseStatus status) {\n\t\treturn (status != null && (status.getCode() == 1000 ||\n\t\t\t\t(status.getCode() >= 3000 && status.getCode() <= 4999)));\n\t}\n\n\tprivate void silentClose(CloseStatus status) {\n\t\ttry {\n\t\t\tcloseInternal(status);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Failed to close \" + this, ex);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void closeInternal(CloseStatus status) throws IOException {\n\t\tif (this.state == null) {\n\t\t\tlogger.warn(\"Ignoring close since connect() was never invoked\");\n\t\t\treturn;\n\t\t}\n\t\tif (isDisconnected()) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Ignoring close (already closing or closed): current state \" + this.state);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tthis.state = State.CLOSING;\n\t\tthis.closeStatus = status;\n\t\tdisconnect(status);\n\t}\n\n\tprotected abstract void disconnect(CloseStatus status) throws IOException;\n\n\tpublic void handleFrame(String payload) {\n\t\tSockJsFrame frame = new SockJsFrame(payload);\n\t\tswitch (frame.getType()) {\n\t\t\tcase OPEN -> handleOpenFrame();\n\t\t\tcase HEARTBEAT -> {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Received heartbeat in \" + this);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase MESSAGE -> handleMessageFrame(frame);\n\t\t\tcase CLOSE -> handleCloseFrame(frame);\n\t\t}\n\t}\n\n\tprivate void handleOpenFrame() {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Processing SockJS open frame in \" + this);\n\t\t}\n\t\tif (this.state == State.NEW) {\n\t\t\tthis.state = State.OPEN;\n\t\t\ttry {\n\t\t\t\tthis.webSocketHandler.afterConnectionEstablished(this);\n\t\t\t\tthis.connectFuture.complete(this);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\tlogger.error(\"WebSocketHandler.afterConnectionEstablished threw exception in \" + this, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Open frame received in \" + getId() + \" but we're not connecting (current state \" +\n\t\t\t\t\t\tthis.state + \"). The server might have been restarted and lost track of the session.\");\n\t\t\t}\n\t\t\tsilentClose(new CloseStatus(1006, \"Server lost session\"));\n\t\t}\n\t}\n\n\tprivate void handleMessageFrame(SockJsFrame frame) {\n\t\tif (!isOpen()) {\n\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Ignoring received message due to state \" + this.state + \" in \" + this);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tString[] messages = null;\n\t\tString frameData = frame.getFrameData();\n\t\tif (frameData != null) {\n\t\t\ttry {\n\t\t\t\tmessages = getMessageCodec().decode(frameData);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\tlogger.error(\"Failed to decode data for SockJS \\\"message\\\" frame: \" + frame + \" in \" + this, ex);\n\t\t\t\t}\n\t\t\t\tsilentClose(CloseStatus.BAD_DATA);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (messages == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Processing SockJS message frame \" + frame.getContent() + \" in \" + this);\n\t\t}\n\t\tfor (String message : messages) {\n\t\t\tif (isOpen()) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.webSocketHandler.handleMessage(this, new TextMessage(message));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tlogger.error(\"WebSocketHandler.handleMessage threw an exception on \" + frame + \" in \" + this, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void handleCloseFrame(SockJsFrame frame) {\n\t\tCloseStatus closeStatus = CloseStatus.NO_STATUS_CODE;\n\t\ttry {\n\t\t\tString frameData = frame.getFrameData();\n\t\t\tif (frameData != null) {\n\t\t\t\tString[] data = getMessageCodec().decode(frameData);\n\t\t\t\tif (data != null && data.length == 2) {\n\t\t\t\t\tcloseStatus = new CloseStatus(Integer.parseInt(data[0]), data[1]);\n\t\t\t\t}\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Processing SockJS close frame with \" + closeStatus + \" in \" + this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Failed to decode data for \" + frame + \" in \" + this, ex);\n\t\t\t}\n\t\t}\n\t\tsilentClose(closeStatus);\n\t}\n\n\tpublic void handleTransportError(Throwable error) {\n\t\ttry {\n\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Transport error in \" + this, error);\n\t\t\t}\n\t\t\tthis.webSocketHandler.handleTransportError(this, error);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.error(\"WebSocketHandler.handleTransportError threw an exception\", ex);\n\t\t}\n\t}\n\n\tpublic void afterTransportClosed(@Nullable CloseStatus closeStatus) {\n\t\tCloseStatus cs = this.closeStatus;\n\t\tif (cs == null) {\n\t\t\tcs = closeStatus;\n\t\t\tthis.closeStatus = closeStatus;\n\t\t}\n\t\tAssert.state(cs != null, \"CloseStatus not available\");\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Transport closed with \" + cs + \" in \" + this);\n\t\t}\n\n\t\tthis.state = State.CLOSED;\n\t\ttry {\n\t\t\tthis.webSocketHandler.afterConnectionClosed(this, cs);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.error(\"WebSocketHandler.afterConnectionClosed threw an exception\", ex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \"[id='\" + getId() + \", url=\" + getUri() + \"]\";\n\t}\n\n\n\tprivate enum State { NEW, OPEN, CLOSING, CLOSED }\n\n}"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession#afterTransportClosed(closeStatus)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "closeStatus"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "void",
    "signature": "public void afterTransportClosed(@Nullable CloseStatus closeStatus)",
    "source_code": "\tpublic void afterTransportClosed(@Nullable CloseStatus closeStatus) {\n\t\tCloseStatus cs = this.closeStatus;\n\t\tif (cs == null) {\n\t\t\tcs = closeStatus;\n\t\t\tthis.closeStatus = closeStatus;\n\t\t}\n\t\tAssert.state(cs != null, \"CloseStatus not available\");\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Transport closed with \" + cs + \" in \" + this);\n\t\t}\n\n\t\tthis.state = State.CLOSED;\n\t\ttry {\n\t\t\tthis.webSocketHandler.afterConnectionClosed(this, cs);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.error(\"WebSocketHandler.afterConnectionClosed threw an exception\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\tpublic final void close() throws IOException {\n\t\tclose(CloseStatus.NORMAL);\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession#close(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void close(CloseStatus status)",
    "source_code": "\tpublic final void close(CloseStatus status) throws IOException {\n\t\tif (!isUserSetStatus(status)) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid close status: \" + status);\n\t\t}\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Closing session with \" +  status + \" in \" + this);\n\t\t}\n\t\tcloseInternal(status);\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession#closeInternal(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "protected void closeInternal(CloseStatus status)",
    "source_code": "\tprotected void closeInternal(CloseStatus status) throws IOException {\n\t\tif (this.state == null) {\n\t\t\tlogger.warn(\"Ignoring close since connect() was never invoked\");\n\t\t\treturn;\n\t\t}\n\t\tif (isDisconnected()) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Ignoring close (already closing or closed): current state \" + this.state);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tthis.state = State.CLOSING;\n\t\tthis.closeStatus = status;\n\t\tdisconnect(status);\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession#disconnect(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "void",
    "signature": "protected void disconnect(CloseStatus status)",
    "source_code": "\tprotected abstract void disconnect(CloseStatus status) throws IOException;"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession#getAttributes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "Object>",
    "signature": "public Object> getAttributes()",
    "source_code": "\tpublic Map<String, Object> getAttributes() {\n\t\treturn this.attributes;\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession#getHandshakeHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHandshakeHeaders()",
    "source_code": "\tpublic HttpHeaders getHandshakeHeaders() {\n\t\treturn this.request.getHandshakeHeaders();\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession#getId()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "String",
    "signature": "public String getId()",
    "source_code": "\tpublic String getId() {\n\t\treturn this.request.getSockJsUrlInfo().getSessionId();\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession#getMessageCodec()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "SockJsMessageCodec",
    "signature": "public SockJsMessageCodec getMessageCodec()",
    "source_code": "\tpublic SockJsMessageCodec getMessageCodec() {\n\t\treturn this.request.getMessageCodec();\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession#getPrincipal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "Principal",
    "signature": "public Principal getPrincipal()",
    "source_code": "\tpublic Principal getPrincipal() {\n\t\treturn this.request.getUser();\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession#getUri()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "URI",
    "signature": "public URI getUri()",
    "source_code": "\tpublic URI getUri() {\n\t\treturn this.request.getSockJsUrlInfo().getSockJsUrl();\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession#getWebSocketHandler()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "WebSocketHandler",
    "signature": "public WebSocketHandler getWebSocketHandler()",
    "source_code": "\tpublic WebSocketHandler getWebSocketHandler() {\n\t\treturn this.webSocketHandler;\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession#handleFrame(payload)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "void",
    "signature": "public void handleFrame(String payload)",
    "source_code": "\tpublic void handleFrame(String payload) {\n\t\tSockJsFrame frame = new SockJsFrame(payload);\n\t\tswitch (frame.getType()) {\n\t\t\tcase OPEN -> handleOpenFrame();\n\t\t\tcase HEARTBEAT -> {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Received heartbeat in \" + this);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase MESSAGE -> handleMessageFrame(frame);\n\t\t\tcase CLOSE -> handleCloseFrame(frame);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession#handleTransportError(error)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "error"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "void",
    "signature": "public void handleTransportError(Throwable error)",
    "source_code": "\tpublic void handleTransportError(Throwable error) {\n\t\ttry {\n\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Transport error in \" + this, error);\n\t\t\t}\n\t\t\tthis.webSocketHandler.handleTransportError(this, error);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.error(\"WebSocketHandler.handleTransportError threw an exception\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession#isDisconnected()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "boolean",
    "signature": "public boolean isDisconnected()",
    "source_code": "\tpublic boolean isDisconnected() {\n\t\treturn (this.state == State.CLOSING || this.state == State.CLOSED);\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession#isOpen()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "boolean",
    "signature": "public boolean isOpen()",
    "source_code": "\tpublic boolean isOpen() {\n\t\treturn (this.state == State.OPEN);\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession#run()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void run()",
    "source_code": "\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tcloseInternal(new CloseStatus(2007, \"Transport timed out\"));\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\tlogger.warn(\"Failed to close \" + this + \" after transport timeout\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession#sendInternal(textMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "textMessage"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "void",
    "signature": "protected void sendInternal(TextMessage textMessage)",
    "source_code": "\tprotected abstract void sendInternal(TextMessage textMessage) throws IOException;"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession#sendMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "public void sendMessage(WebSocketMessage<?> message)",
    "source_code": "\tpublic final void sendMessage(WebSocketMessage<?> message) throws IOException {\n\t\tif (!(message instanceof TextMessage)) {\n\t\t\tthrow new IllegalArgumentException(this + \" supports text messages only.\");\n\t\t}\n\t\tif (this.state != State.OPEN) {\n\t\t\tthrow new IllegalStateException(this + \" is not open: current state \" + this.state);\n\t\t}\n\n\t\tString payload = ((TextMessage) message).getPayload();\n\t\tpayload = getMessageCodec().encode(payload);\n\t\tpayload = payload.substring(1);  // the client-side doesn't need message framing (letter \"a\")\n\n\t\tTextMessage messageToSend = new TextMessage(payload);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Sending message \" + messageToSend + \" in \" + this);\n\t\t}\n\t\tsendInternal(messageToSend);\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 364
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \"[id='\" + getId() + \", url=\" + getUri() + \"]\";\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  }
}